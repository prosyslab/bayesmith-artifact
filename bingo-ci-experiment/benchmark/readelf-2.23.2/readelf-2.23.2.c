/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 194 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 270 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 50 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xatexit.c"
struct xatexit {
   struct xatexit *next ;
   int ind ;
   void (*fns[32])(void) ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
struct signal_info {
   int const   value ;
   char const   * const  name ;
};
#line 59 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
struct error_info {
   int const   value ;
   char const   * const  name ;
};
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 55 "./../include/splay-tree.h"
typedef uintptr_t splay_tree_key;
#line 56 "./../include/splay-tree.h"
typedef uintptr_t splay_tree_value;
#line 59
struct splay_tree_node_s ;
#line 59 "./../include/splay-tree.h"
typedef struct splay_tree_node_s *splay_tree_node;
#line 89 "./../include/splay-tree.h"
struct splay_tree_node_s {
   splay_tree_key key ;
   splay_tree_value value ;
   splay_tree_node left ;
   splay_tree_node right ;
};
#line 102 "./../include/splay-tree.h"
struct splay_tree_s {
   splay_tree_node root ;
   int (*comp)(splay_tree_key  , splay_tree_key  ) ;
   void (*delete_key)(splay_tree_key  ) ;
   void (*delete_value)(splay_tree_value  ) ;
   void *(*allocate)(int  , void * ) ;
   void (*deallocate)(void * , void * ) ;
   void *allocate_data ;
};
#line 125 "./../include/splay-tree.h"
typedef struct splay_tree_s *splay_tree;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sort.c"
typedef unsigned char digit_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 57 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 42 "./../include/simple-object.h"
struct simple_object_read_struct ;
#line 42 "./../include/simple-object.h"
typedef struct simple_object_read_struct simple_object_read;
#line 108
struct simple_object_attributes_struct ;
#line 108 "./../include/simple-object.h"
typedef struct simple_object_attributes_struct simple_object_attributes;
#line 137
struct simple_object_write_struct ;
#line 137 "./../include/simple-object.h"
typedef struct simple_object_write_struct simple_object_write;
#line 157
struct simple_object_write_section_struct ;
#line 157 "./../include/simple-object.h"
typedef struct simple_object_write_section_struct simple_object_write_section;
#line 21 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_functions ;
#line 25 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_read_struct {
   int descriptor ;
   off_t offset ;
   struct simple_object_functions  const  *functions ;
   void *data ;
};
#line 39 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_attributes_struct {
   struct simple_object_functions  const  *functions ;
   void *data ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_write_struct {
   struct simple_object_functions  const  *functions ;
   char *segment_name ;
   simple_object_write_section *sections ;
   simple_object_write_section *last_section ;
   void *data ;
};
#line 65
struct simple_object_write_section_buffer ;
#line 65 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_write_section_struct {
   simple_object_write_section *next ;
   char *name ;
   unsigned int align ;
   struct simple_object_write_section_buffer *buffers ;
   struct simple_object_write_section_buffer *last_buffer ;
};
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_write_section_buffer {
   struct simple_object_write_section_buffer *next ;
   size_t size ;
   void const   *buffer ;
   void *free_buffer ;
};
#line 100 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_functions {
   void *(*match)(unsigned char *header , int descriptor , off_t offset , char const   *segment_name ,
                  char const   **errmsg , int *err ) ;
   char const   *(*find_sections)(simple_object_read * , int (*pfn)(void * , char const   * ,
                                                                    off_t offset ,
                                                                    off_t length ) ,
                                  void *data , int *err ) ;
   void *(*fetch_attributes)(simple_object_read *sobj , char const   **errmsg , int *err ) ;
   void (*release_read)(void * ) ;
   char const   *(*attributes_merge)(void * , void * , int *err ) ;
   void (*release_attributes)(void * ) ;
   void *(*start_write)(void *attributes_data , char const   **errmsg , int *err ) ;
   char const   *(*write_to_file)(simple_object_write *sobj , int descriptor , int *err ) ;
   void (*release_write)(void * ) ;
};
#line 180 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
struct find_one_section_data {
   char const   *name ;
   off_t *offset ;
   off_t *length ;
   int found ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 174 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
typedef uint64_t ulong_type;
#line 48 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_header_32 {
   unsigned char magic[4] ;
   unsigned char cputype[4] ;
   unsigned char cpusubtype[4] ;
   unsigned char filetype[4] ;
   unsigned char ncmds[4] ;
   unsigned char sizeofcmds[4] ;
   unsigned char flags[4] ;
};
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_header_64 {
   unsigned char magic[4] ;
   unsigned char cputype[4] ;
   unsigned char cpusubtype[4] ;
   unsigned char filetype[4] ;
   unsigned char ncmds[4] ;
   unsigned char sizeofcmds[4] ;
   unsigned char flags[4] ;
   unsigned char reserved[4] ;
};
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_load_command {
   unsigned char cmd[4] ;
   unsigned char cmdsize[4] ;
};
#line 98 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_segment_command_32 {
   unsigned char cmd[4] ;
   unsigned char cmdsize[4] ;
   unsigned char segname[16] ;
   unsigned char vmaddr[4] ;
   unsigned char vmsize[4] ;
   unsigned char fileoff[4] ;
   unsigned char filesize[4] ;
   unsigned char maxprot[4] ;
   unsigned char initprot[4] ;
   unsigned char nsects[4] ;
   unsigned char flags[4] ;
};
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_segment_command_64 {
   unsigned char cmd[4] ;
   unsigned char cmdsize[4] ;
   unsigned char segname[16] ;
   unsigned char vmaddr[8] ;
   unsigned char vmsize[8] ;
   unsigned char fileoff[8] ;
   unsigned char filesize[8] ;
   unsigned char maxprot[4] ;
   unsigned char initprot[4] ;
   unsigned char nsects[4] ;
   unsigned char flags[4] ;
};
#line 132 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_section_32 {
   unsigned char sectname[16] ;
   unsigned char segname[16] ;
   unsigned char addr[4] ;
   unsigned char size[4] ;
   unsigned char offset[4] ;
   unsigned char align[4] ;
   unsigned char reloff[4] ;
   unsigned char nreloc[4] ;
   unsigned char flags[4] ;
   unsigned char reserved1[4] ;
   unsigned char reserved2[4] ;
};
#line 149 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct mach_o_section_64 {
   unsigned char sectname[16] ;
   unsigned char segname[16] ;
   unsigned char addr[8] ;
   unsigned char size[8] ;
   unsigned char offset[4] ;
   unsigned char align[4] ;
   unsigned char reloff[4] ;
   unsigned char nreloc[4] ;
   unsigned char flags[4] ;
   unsigned char reserved1[4] ;
   unsigned char reserved2[4] ;
   unsigned char reserved3[4] ;
};
#line 188 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct simple_object_mach_o_read {
   char *segment_name ;
   unsigned int magic ;
   int is_big_endian ;
   unsigned int cputype ;
   unsigned int cpusubtype ;
   unsigned int ncmds ;
   unsigned int flags ;
   unsigned int reserved ;
};
#line 210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct simple_object_mach_o_attributes {
   unsigned int magic ;
   int is_big_endian ;
   unsigned int cputype ;
   unsigned int cpusubtype ;
   unsigned int flags ;
   unsigned int reserved ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf32_External_Ehdr_45460738 {
   unsigned char e_ident[16] ;
   unsigned char e_type[2] ;
   unsigned char e_machine[2] ;
   unsigned char e_version[4] ;
   unsigned char e_entry[4] ;
   unsigned char e_phoff[4] ;
   unsigned char e_shoff[4] ;
   unsigned char e_flags[4] ;
   unsigned char e_ehsize[2] ;
   unsigned char e_phentsize[2] ;
   unsigned char e_phnum[2] ;
   unsigned char e_shentsize[2] ;
   unsigned char e_shnum[2] ;
   unsigned char e_shstrndx[2] ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf32_External_Ehdr_45460738 Elf32_External_Ehdr;
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf64_External_Ehdr_45460739 {
   unsigned char e_ident[16] ;
   unsigned char e_type[2] ;
   unsigned char e_machine[2] ;
   unsigned char e_version[4] ;
   unsigned char e_entry[8] ;
   unsigned char e_phoff[8] ;
   unsigned char e_shoff[8] ;
   unsigned char e_flags[4] ;
   unsigned char e_ehsize[2] ;
   unsigned char e_phentsize[2] ;
   unsigned char e_phnum[2] ;
   unsigned char e_shentsize[2] ;
   unsigned char e_shnum[2] ;
   unsigned char e_shstrndx[2] ;
};
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf64_External_Ehdr_45460739 Elf64_External_Ehdr;
#line 130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf32_External_Phdr_18596974 {
   unsigned char p_type[4] ;
   unsigned char p_offset[4] ;
   unsigned char p_vaddr[4] ;
   unsigned char p_paddr[4] ;
   unsigned char p_filesz[4] ;
   unsigned char p_memsz[4] ;
   unsigned char p_flags[4] ;
   unsigned char p_align[4] ;
};
#line 130 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf32_External_Phdr_18596974 Elf32_External_Phdr;
#line 143 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf64_External_Phdr_18596975 {
   unsigned char p_type[4] ;
   unsigned char p_flags[4] ;
   unsigned char p_offset[8] ;
   unsigned char p_vaddr[8] ;
   unsigned char p_paddr[8] ;
   unsigned char p_filesz[8] ;
   unsigned char p_memsz[8] ;
   unsigned char p_align[8] ;
};
#line 143 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf64_External_Phdr_18596975 Elf64_External_Phdr;
#line 156 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf32_External_Shdr_226953194 {
   unsigned char sh_name[4] ;
   unsigned char sh_type[4] ;
   unsigned char sh_flags[4] ;
   unsigned char sh_addr[4] ;
   unsigned char sh_offset[4] ;
   unsigned char sh_size[4] ;
   unsigned char sh_link[4] ;
   unsigned char sh_info[4] ;
   unsigned char sh_addralign[4] ;
   unsigned char sh_entsize[4] ;
};
#line 156 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf32_External_Shdr_226953194 Elf32_External_Shdr;
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct __anonstruct_Elf64_External_Shdr_226953195 {
   unsigned char sh_name[4] ;
   unsigned char sh_type[4] ;
   unsigned char sh_flags[8] ;
   unsigned char sh_addr[8] ;
   unsigned char sh_offset[8] ;
   unsigned char sh_size[8] ;
   unsigned char sh_link[4] ;
   unsigned char sh_info[4] ;
   unsigned char sh_addralign[8] ;
   unsigned char sh_entsize[8] ;
};
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
typedef struct __anonstruct_Elf64_External_Shdr_226953195 Elf64_External_Shdr;
#line 192 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct elf_type_functions {
   unsigned short (*fetch_Elf_Half)(unsigned char const   * ) ;
   unsigned int (*fetch_Elf_Word)(unsigned char const   * ) ;
   ulong_type (*fetch_Elf_Addr)(unsigned char const   * ) ;
   void (*set_Elf_Half)(unsigned char * , unsigned short  ) ;
   void (*set_Elf_Word)(unsigned char * , unsigned int  ) ;
   void (*set_Elf_Addr)(unsigned char * , ulong_type  ) ;
};
#line 311 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct simple_object_elf_read {
   struct elf_type_functions  const  *type_functions ;
   unsigned char ei_data ;
   unsigned char ei_class ;
   unsigned char ei_osabi ;
   unsigned short machine ;
   unsigned int flags ;
   ulong_type shoff ;
   unsigned int shnum ;
   unsigned int shstrndx ;
};
#line 335 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct simple_object_elf_attributes {
   struct elf_type_functions  const  *type_functions ;
   unsigned char ei_data ;
   unsigned char ei_class ;
   unsigned char ei_osabi ;
   unsigned short machine ;
   unsigned int flags ;
};
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct external_filehdr {
   unsigned char f_magic[2] ;
   unsigned char f_nscns[2] ;
   unsigned char f_timdat[4] ;
   unsigned char f_symptr[4] ;
   unsigned char f_nsyms[4] ;
   unsigned char f_opthdr[2] ;
   unsigned char f_flags[2] ;
};
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct external_scnhdr {
   unsigned char s_name[8] ;
   unsigned char s_paddr[4] ;
   unsigned char s_vaddr[4] ;
   unsigned char s_size[4] ;
   unsigned char s_scnptr[4] ;
   unsigned char s_relptr[4] ;
   unsigned char s_lnnoptr[4] ;
   unsigned char s_nreloc[2] ;
   unsigned char s_nlnno[2] ;
   unsigned char s_flags[4] ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct __anonstruct_e_443125039 {
   unsigned char e_zeroes[4] ;
   unsigned char e_offset[4] ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
union __anonunion_e_389857720 {
   unsigned char e_name[8] ;
   struct __anonstruct_e_443125039 e ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct external_syment {
   union __anonunion_e_389857720 e ;
   unsigned char e_value[4] ;
   unsigned char e_scnum[2] ;
   unsigned char e_type[2] ;
   unsigned char e_sclass[1] ;
   unsigned char e_numaux[1] ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct __anonstruct_x_n_794642161 {
   unsigned char x_zeroes[4] ;
   unsigned char x_offset[4] ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
union __anonunion_x_file_794642160 {
   char x_fname[18] ;
   struct __anonstruct_x_n_794642161 x_n ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct __anonstruct_x_scn_441262567 {
   unsigned char x_scnlen[4] ;
   unsigned char x_nreloc[2] ;
   unsigned char x_nlinno[2] ;
   unsigned char x_checksum[4] ;
   unsigned char x_associated[2] ;
   unsigned char x_comdat[1] ;
};
#line 128 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
union external_auxent {
   union __anonunion_x_file_794642160 x_file ;
   struct __anonstruct_x_scn_441262567 x_scn ;
};
#line 165 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct simple_object_coff_read {
   unsigned short magic ;
   unsigned char is_big_endian ;
   unsigned short nscns ;
   off_t symptr ;
   unsigned int nsyms ;
   unsigned short flags ;
   off_t scnhdr_offset ;
};
#line 185 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct simple_object_coff_attributes {
   unsigned short magic ;
   unsigned char is_big_endian ;
   unsigned short flags ;
};
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct coff_magic_struct {
   unsigned short magic ;
   unsigned char is_big_endian ;
   unsigned short non_object_flags ;
};
#line 619 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
union __anonunion_syms_806857204 {
   struct external_syment sym ;
   union external_auxent aux ;
};
#line 55 "./../include/sha1.h"
typedef unsigned int sha1_uint32;
#line 76 "./../include/sha1.h"
struct sha1_ctx {
   sha1_uint32 A ;
   sha1_uint32 B ;
   sha1_uint32 C ;
   sha1_uint32 D ;
   sha1_uint32 E ;
   sha1_uint32 total[2] ;
   sha1_uint32 buflen ;
   sha1_uint32 buffer[32] ;
};
#line 235 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
struct __anonstruct_694274947 {
   char c ;
   sha1_uint32 x ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 47 "./../include/xregex2.h"
typedef unsigned long active_reg_t;
#line 54 "./../include/xregex2.h"
typedef unsigned long reg_syntax_t;
#line 291
enum __anonenum_reg_errcode_t_784080967 {
    REG_ENOSYS = -1,
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
#line 291 "./../include/xregex2.h"
typedef enum __anonenum_reg_errcode_t_784080967 reg_errcode_t;
#line 331 "./../include/xregex2.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 399 "./../include/xregex2.h"
typedef struct re_pattern_buffer regex_t;
#line 402 "./../include/xregex2.h"
typedef int xregoff_t;
#line 407 "./../include/xregex2.h"
struct re_registers {
   unsigned int num_regs ;
   xregoff_t *start ;
   xregoff_t *end ;
};
#line 426 "./../include/xregex2.h"
struct __anonstruct_regmatch_t_986009469 {
   xregoff_t rm_so ;
   xregoff_t rm_eo ;
};
#line 426 "./../include/xregex2.h"
typedef struct __anonstruct_regmatch_t_986009469 regmatch_t;
#line 404 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef char boolean;
#line 453
enum __anonenum_re_opcode_t_433329371 {
    no_op = 0,
    succeed = 1,
    exactn = 2,
    anychar = 3,
    charset = 4,
    charset_not = 5,
    start_memory = 6,
    stop_memory = 7,
    duplicate = 8,
    begline = 9,
    endline = 10,
    begbuf = 11,
    endbuf = 12,
    jump = 13,
    jump_past_alt = 14,
    on_failure_jump = 15,
    on_failure_keep_string_jump = 16,
    pop_failure_jump = 17,
    maybe_pop_jump = 18,
    dummy_failure_jump = 19,
    push_dummy_failure = 20,
    succeed_n = 21,
    jump_n = 22,
    set_number_at = 23,
    wordchar = 24,
    notwordchar = 25,
    wordbeg = 26,
    wordend = 27,
    wordbound = 28,
    notwordbound = 29
} ;
#line 453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef enum __anonenum_re_opcode_t_433329371 re_opcode_t;
#line 1465 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
union byte_fail_stack_elt {
   unsigned char *pointer ;
   int integer ;
};
#line 1471 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef union byte_fail_stack_elt byte_fail_stack_elt_t;
#line 1473 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
struct __anonstruct_byte_fail_stack_type_401414316 {
   byte_fail_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 1473 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef struct __anonstruct_byte_fail_stack_type_401414316 byte_fail_stack_type;
#line 1794 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
struct __anonstruct_bits_582056016 {
   unsigned int match_null_string_p : 2 ;
   unsigned int is_active : 1 ;
   unsigned int matched_something : 1 ;
   unsigned int ever_matched_something : 1 ;
};
#line 1794 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
union __anonunion_byte_register_info_type_298643906 {
   byte_fail_stack_elt_t word ;
   struct __anonstruct_bits_582056016 bits ;
};
#line 1794 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef union __anonunion_byte_register_info_type_298643906 byte_register_info_type;
#line 2107 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef unsigned int regnum_t;
#line 2115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef long pattern_offset_t;
#line 2117 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
struct __anonstruct_compile_stack_elt_t_369398534 {
   pattern_offset_t begalt_offset ;
   pattern_offset_t fixup_alt_jump ;
   pattern_offset_t inner_group_offset ;
   pattern_offset_t laststart_offset ;
   regnum_t regnum ;
};
#line 2117 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef struct __anonstruct_compile_stack_elt_t_369398534 compile_stack_elt_t;
#line 2127 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
struct __anonstruct_compile_stack_type_541390256 {
   compile_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
#line 2127 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
typedef struct __anonstruct_compile_stack_type_541390256 compile_stack_type;
#line 401 "./../include/libiberty.h"
struct pex_obj ;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 559 "./../include/libiberty.h"
struct pex_time {
   unsigned long user_seconds ;
   unsigned long user_microseconds ;
   unsigned long system_seconds ;
   unsigned long system_microseconds ;
};
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 54 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.h"
struct pex_funcs ;
#line 54 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.h"
struct pex_obj {
   int flags ;
   char const   *pname ;
   char const   *tempbase ;
   int next_input ;
   char *next_input_name ;
   int next_input_name_allocated ;
   int stderr_pipe ;
   int count ;
   pid_t *children ;
   int *status ;
   struct pex_time *time ;
   int number_waited ;
   FILE *input_file ;
   FILE *read_output ;
   FILE *read_err ;
   int remove_count ;
   char **remove ;
   struct pex_funcs  const  *funcs ;
   void *sysdep ;
};
#line 99 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.h"
struct pex_funcs {
   int (*open_read)(struct pex_obj * , char const   * , int  ) ;
   int (*open_write)(struct pex_obj * , char const   * , int  ) ;
   pid_t (*exec_child)(struct pex_obj * , int  , char const   * , char * const  * ,
                       char * const  * , int  , int  , int  , int  , char const   ** ,
                       int * ) ;
   int (*close)(struct pex_obj * , int  ) ;
   pid_t (*wait)(struct pex_obj * , pid_t  , int * , struct pex_time * , int  , char const   ** ,
                 int * ) ;
   int (*pipe)(struct pex_obj * , int * , int  ) ;
   FILE *(*fdopenr)(struct pex_obj * , int  , int  ) ;
   FILE *(*fdopenw)(struct pex_obj * , int  , int  ) ;
   void (*cleanup)(struct pex_obj * ) ;
};
#line 129 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage ;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346496 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346497 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346498 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346499 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346500 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346501 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346502 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346503 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346504 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346505 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346506 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346507 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346508 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
union __anonunion____missing_field_name_1036346509 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_rusage.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_1036346496 __annonCompField4 ;
   union __anonunion____missing_field_name_1036346497 __annonCompField5 ;
   union __anonunion____missing_field_name_1036346498 __annonCompField6 ;
   union __anonunion____missing_field_name_1036346499 __annonCompField7 ;
   union __anonunion____missing_field_name_1036346500 __annonCompField8 ;
   union __anonunion____missing_field_name_1036346501 __annonCompField9 ;
   union __anonunion____missing_field_name_1036346502 __annonCompField10 ;
   union __anonunion____missing_field_name_1036346503 __annonCompField11 ;
   union __anonunion____missing_field_name_1036346504 __annonCompField12 ;
   union __anonunion____missing_field_name_1036346505 __annonCompField13 ;
   union __anonunion____missing_field_name_1036346506 __annonCompField14 ;
   union __anonunion____missing_field_name_1036346507 __annonCompField15 ;
   union __anonunion____missing_field_name_1036346508 __annonCompField16 ;
   union __anonunion____missing_field_name_1036346509 __annonCompField17 ;
};
#line 46 "./../include/partition.h"
struct partition_elem {
   int class_element ;
   struct partition_elem *next ;
   unsigned int class_count ;
};
#line 59 "./../include/partition.h"
struct partition_def {
   int num_elements ;
   struct partition_elem elements[1] ;
};
#line 59 "./../include/partition.h"
typedef struct partition_def *partition;
#line 44 "./../include/objalloc.h"
struct objalloc {
   char *current_ptr ;
   unsigned int current_space ;
   void *chunks ;
};
#line 53 "./../include/objalloc.h"
struct objalloc_align {
   char x ;
   double d ;
};
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./objalloc.c"
struct objalloc_chunk {
   struct objalloc_chunk *next ;
   char *current_ptr ;
};
#line 56 "./../include/md5.h"
typedef unsigned int md5_uint32;
#line 72 "./../include/md5.h"
typedef unsigned long md5_uintptr;
#line 80 "./../include/md5.h"
struct md5_ctx {
   md5_uint32 A ;
   md5_uint32 B ;
   md5_uint32 C ;
   md5_uint32 D ;
   md5_uint32 total[2] ;
   md5_uint32 buflen ;
   char buffer[128]  __attribute__((__aligned__(__alignof__(md5_uint32 )))) ;
};
#line 47 "./../include/hashtab.h"
typedef unsigned int hashval_t;
#line 100 "./../include/hashtab.h"
struct htab {
   hashval_t (*hash_f)(void const   * ) ;
   int (*eq_f)(void const   * , void const   * ) ;
   void (*del_f)(void * ) ;
   void **entries ;
   size_t size ;
   size_t n_elements ;
   size_t n_deleted ;
   unsigned int searches ;
   unsigned int collisions ;
   void *(*alloc_f)(size_t  , size_t  ) ;
   void (*free_f)(void * ) ;
   void *alloc_arg ;
   void *(*alloc_with_arg_f)(void * , size_t  , size_t  ) ;
   void (*free_with_arg_f)(void * , void * ) ;
   unsigned int size_prime_index ;
};
#line 144 "./../include/hashtab.h"
typedef struct htab *htab_t;
#line 147
enum insert_option {
    NO_INSERT = 0,
    INSERT = 1
} ;
#line 127 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
struct prime_ent {
   hashval_t prime ;
   hashval_t inv ;
   hashval_t inv_m2 ;
   hashval_t shift ;
};
#line 247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
typedef uint64_t ull;
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 34 "./../include/floatformat.h"
enum floatformat_byteorders {
    floatformat_little = 0,
    floatformat_big = 1,
    floatformat_littlebyte_bigword = 2,
    floatformat_vax = 3
} ;
#line 54
enum floatformat_intbit {
    floatformat_intbit_yes = 0,
    floatformat_intbit_no = 1
} ;
#line 56 "./../include/floatformat.h"
struct floatformat {
   enum floatformat_byteorders byteorder ;
   unsigned int totalsize ;
   unsigned int sign_start ;
   unsigned int exp_start ;
   unsigned int exp_len ;
   int exp_bias ;
   unsigned int exp_nan ;
   unsigned int man_start ;
   unsigned int man_len ;
   enum floatformat_intbit intbit ;
   char const   *name ;
   int (*is_valid)(struct floatformat  const  *fmt , void const   *from ) ;
   struct floatformat  const  *split_half ;
};
#line 50 "./../include/fibheap.h"
typedef long fibheapkey_t;
#line 52
struct fibnode ;
#line 52 "./../include/fibheap.h"
struct fibheap {
   size_t nodes ;
   struct fibnode *min ;
   struct fibnode *root ;
};
#line 52 "./../include/fibheap.h"
typedef struct fibheap *fibheap_t;
#line 59 "./../include/fibheap.h"
struct fibnode {
   struct fibnode *parent ;
   struct fibnode *child ;
   struct fibnode *left ;
   struct fibnode *right ;
   fibheapkey_t key ;
   void *data ;
   unsigned int degree : 31 ;
   unsigned int mark : 1 ;
};
#line 59 "./../include/fibheap.h"
typedef struct fibnode *fibnode_t;
#line 30 "./../include/dyn-string.h"
struct dyn_string {
   int allocated ;
   int length ;
   char *s ;
};
#line 30 "./../include/dyn-string.h"
typedef struct dyn_string *dyn_string_t;
#line 78 "./../include/demangle.h"
enum demangling_styles {
    no_demangling = -1,
    unknown_demangling = 0,
    auto_demangling = 256,
    gnu_demangling = 512,
    lucid_demangling = 1024,
    arm_demangling = 2048,
    hp_demangling = 4096,
    edg_demangling = 8192,
    gnu_v3_demangling = 16384,
    java_demangling = 4,
    gnat_demangling = 32768
} ;
#line 122 "./../include/demangle.h"
struct demangler_engine {
   char const   * const  demangling_style_name ;
   enum demangling_styles  const  demangling_style ;
   char const   * const  demangling_style_doc ;
};
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
struct string {
   char *b ;
   char *p ;
   char *e ;
};
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
typedef struct string string;
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
struct work_stuff {
   int options ;
   char **typevec ;
   char **ktypevec ;
   char **btypevec ;
   int numk ;
   int numb ;
   int ksize ;
   int bsize ;
   int ntypes ;
   int typevec_size ;
   int constructor ;
   int destructor ;
   int static_type ;
   int temp_start ;
   int type_quals ;
   int dllimported ;
   char **tmpl_argvec ;
   int ntmpl_args ;
   int forgetting_types ;
   string *previous_argument ;
   int nrepeats ;
};
#line 145 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
struct optable {
   char const   * const  in ;
   char const   * const  out ;
   int const   flags ;
};
#line 235
enum type_kind_t {
    tk_none = 0,
    tk_pointer = 1,
    tk_reference = 2,
    tk_integral = 3,
    tk_bool = 4,
    tk_char = 5,
    tk_real = 6
} ;
#line 235 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
typedef enum type_kind_t type_kind_t;
#line 172 "./../include/demangle.h"
enum gnu_v3_ctor_kinds {
    gnu_v3_complete_object_ctor = 1,
    gnu_v3_base_object_ctor = 2,
    gnu_v3_complete_object_allocating_ctor = 3,
    gnu_v3_object_ctor_group = 4
} ;
#line 187
enum gnu_v3_dtor_kinds {
    gnu_v3_deleting_dtor = 1,
    gnu_v3_complete_object_dtor = 2,
    gnu_v3_base_object_dtor = 3,
    gnu_v3_object_dtor_group = 4
} ;
#line 215
enum demangle_component_type {
    DEMANGLE_COMPONENT_NAME = 0,
    DEMANGLE_COMPONENT_QUAL_NAME = 1,
    DEMANGLE_COMPONENT_LOCAL_NAME = 2,
    DEMANGLE_COMPONENT_TYPED_NAME = 3,
    DEMANGLE_COMPONENT_TEMPLATE = 4,
    DEMANGLE_COMPONENT_TEMPLATE_PARAM = 5,
    DEMANGLE_COMPONENT_FUNCTION_PARAM = 6,
    DEMANGLE_COMPONENT_CTOR = 7,
    DEMANGLE_COMPONENT_DTOR = 8,
    DEMANGLE_COMPONENT_VTABLE = 9,
    DEMANGLE_COMPONENT_VTT = 10,
    DEMANGLE_COMPONENT_CONSTRUCTION_VTABLE = 11,
    DEMANGLE_COMPONENT_TYPEINFO = 12,
    DEMANGLE_COMPONENT_TYPEINFO_NAME = 13,
    DEMANGLE_COMPONENT_TYPEINFO_FN = 14,
    DEMANGLE_COMPONENT_THUNK = 15,
    DEMANGLE_COMPONENT_VIRTUAL_THUNK = 16,
    DEMANGLE_COMPONENT_COVARIANT_THUNK = 17,
    DEMANGLE_COMPONENT_JAVA_CLASS = 18,
    DEMANGLE_COMPONENT_GUARD = 19,
    DEMANGLE_COMPONENT_REFTEMP = 20,
    DEMANGLE_COMPONENT_HIDDEN_ALIAS = 21,
    DEMANGLE_COMPONENT_SUB_STD = 22,
    DEMANGLE_COMPONENT_RESTRICT = 23,
    DEMANGLE_COMPONENT_VOLATILE = 24,
    DEMANGLE_COMPONENT_CONST = 25,
    DEMANGLE_COMPONENT_RESTRICT_THIS = 26,
    DEMANGLE_COMPONENT_VOLATILE_THIS = 27,
    DEMANGLE_COMPONENT_CONST_THIS = 28,
    DEMANGLE_COMPONENT_VENDOR_TYPE_QUAL = 29,
    DEMANGLE_COMPONENT_POINTER = 30,
    DEMANGLE_COMPONENT_REFERENCE = 31,
    DEMANGLE_COMPONENT_RVALUE_REFERENCE = 32,
    DEMANGLE_COMPONENT_COMPLEX = 33,
    DEMANGLE_COMPONENT_IMAGINARY = 34,
    DEMANGLE_COMPONENT_BUILTIN_TYPE = 35,
    DEMANGLE_COMPONENT_VENDOR_TYPE = 36,
    DEMANGLE_COMPONENT_FUNCTION_TYPE = 37,
    DEMANGLE_COMPONENT_ARRAY_TYPE = 38,
    DEMANGLE_COMPONENT_PTRMEM_TYPE = 39,
    DEMANGLE_COMPONENT_FIXED_TYPE = 40,
    DEMANGLE_COMPONENT_VECTOR_TYPE = 41,
    DEMANGLE_COMPONENT_ARGLIST = 42,
    DEMANGLE_COMPONENT_TEMPLATE_ARGLIST = 43,
    DEMANGLE_COMPONENT_INITIALIZER_LIST = 44,
    DEMANGLE_COMPONENT_OPERATOR = 45,
    DEMANGLE_COMPONENT_EXTENDED_OPERATOR = 46,
    DEMANGLE_COMPONENT_CAST = 47,
    DEMANGLE_COMPONENT_NULLARY = 48,
    DEMANGLE_COMPONENT_UNARY = 49,
    DEMANGLE_COMPONENT_BINARY = 50,
    DEMANGLE_COMPONENT_BINARY_ARGS = 51,
    DEMANGLE_COMPONENT_TRINARY = 52,
    DEMANGLE_COMPONENT_TRINARY_ARG1 = 53,
    DEMANGLE_COMPONENT_TRINARY_ARG2 = 54,
    DEMANGLE_COMPONENT_LITERAL = 55,
    DEMANGLE_COMPONENT_LITERAL_NEG = 56,
    DEMANGLE_COMPONENT_JAVA_RESOURCE = 57,
    DEMANGLE_COMPONENT_COMPOUND_NAME = 58,
    DEMANGLE_COMPONENT_CHARACTER = 59,
    DEMANGLE_COMPONENT_NUMBER = 60,
    DEMANGLE_COMPONENT_DECLTYPE = 61,
    DEMANGLE_COMPONENT_GLOBAL_CONSTRUCTORS = 62,
    DEMANGLE_COMPONENT_GLOBAL_DESTRUCTORS = 63,
    DEMANGLE_COMPONENT_LAMBDA = 64,
    DEMANGLE_COMPONENT_DEFAULT_ARG = 65,
    DEMANGLE_COMPONENT_UNNAMED_TYPE = 66,
    DEMANGLE_COMPONENT_TRANSACTION_CLONE = 67,
    DEMANGLE_COMPONENT_NONTRANSACTION_CLONE = 68,
    DEMANGLE_COMPONENT_PACK_EXPANSION = 69,
    DEMANGLE_COMPONENT_CLONE = 70
} ;
#line 426
struct demangle_operator_info ;
#line 427
struct demangle_builtin_type_info ;
#line 434 "./../include/demangle.h"
struct __anonstruct_s_name_713894858 {
   char const   *s ;
   int len ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_operator_748683663 {
   struct demangle_operator_info  const  *op ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_extended_operator_590623169 {
   int args ;
   struct demangle_component *name ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_fixed_169630776 {
   struct demangle_component *length ;
   short accum ;
   short sat ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_ctor_307957940 {
   enum gnu_v3_ctor_kinds kind ;
   struct demangle_component *name ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_dtor_207014792 {
   enum gnu_v3_dtor_kinds kind ;
   struct demangle_component *name ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_builtin_158994218 {
   struct demangle_builtin_type_info  const  *type ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_string_748683664 {
   char const   *string ;
   int len ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_number_721778306 {
   long number ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_character_1064224081 {
   int character ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_binary_1038925671 {
   struct demangle_component *left ;
   struct demangle_component *right ;
};
#line 434 "./../include/demangle.h"
struct __anonstruct_s_unary_num_402786937 {
   struct demangle_component *sub ;
   int num ;
};
#line 434 "./../include/demangle.h"
union __anonunion_u_1064224080 {
   struct __anonstruct_s_name_713894858 s_name ;
   struct __anonstruct_s_operator_748683663 s_operator ;
   struct __anonstruct_s_extended_operator_590623169 s_extended_operator ;
   struct __anonstruct_s_fixed_169630776 s_fixed ;
   struct __anonstruct_s_ctor_307957940 s_ctor ;
   struct __anonstruct_s_dtor_207014792 s_dtor ;
   struct __anonstruct_s_builtin_158994218 s_builtin ;
   struct __anonstruct_s_string_748683664 s_string ;
   struct __anonstruct_s_number_721778306 s_number ;
   struct __anonstruct_s_character_1064224081 s_character ;
   struct __anonstruct_s_binary_1038925671 s_binary ;
   struct __anonstruct_s_unary_num_402786937 s_unary_num ;
};
#line 434 "./../include/demangle.h"
struct demangle_component {
   enum demangle_component_type type ;
   union __anonunion_u_1064224080 u ;
};
#line 37 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.h"
struct demangle_operator_info {
   char const   *code ;
   char const   *name ;
   int len ;
   int args ;
};
#line 51
enum d_builtin_type_print {
    D_PRINT_DEFAULT = 0,
    D_PRINT_INT = 1,
    D_PRINT_UNSIGNED = 2,
    D_PRINT_LONG = 3,
    D_PRINT_UNSIGNED_LONG = 4,
    D_PRINT_LONG_LONG = 5,
    D_PRINT_UNSIGNED_LONG_LONG = 6,
    D_PRINT_BOOL = 7,
    D_PRINT_FLOAT = 8,
    D_PRINT_VOID = 9
} ;
#line 77 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.h"
struct demangle_builtin_type_info {
   char const   *name ;
   int len ;
   char const   *java_name ;
   int java_len ;
   enum d_builtin_type_print print ;
};
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.h"
struct d_info {
   char const   *s ;
   char const   *send ;
   int options ;
   char const   *n ;
   struct demangle_component *comps ;
   int next_comp ;
   int num_comps ;
   struct demangle_component **subs ;
   int next_sub ;
   int num_subs ;
   int did_subs ;
   struct demangle_component *last_name ;
   int expansion ;
};
#line 213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct d_standard_sub_info {
   char code ;
   char const   *simple_expansion ;
   int simple_len ;
   char const   *full_expansion ;
   int full_len ;
   char const   *set_last_name ;
   int set_last_name_len ;
};
#line 241 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct d_print_template {
   struct d_print_template *next ;
   struct demangle_component  const  *template_decl ;
};
#line 251 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct d_print_mod {
   struct d_print_mod *next ;
   struct demangle_component  const  *mod ;
   int printed ;
   struct d_print_template *templates ;
};
#line 266 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct d_growable_string {
   char *buf ;
   size_t len ;
   size_t alc ;
   int allocation_failure ;
};
#line 279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct d_print_info {
   char buf[256] ;
   size_t len ;
   char last_char ;
   void (*callback)(char const   * , size_t  , void * ) ;
   void *opaque ;
   struct d_print_template *templates ;
   struct d_print_mod *modifiers ;
   int demangle_failure ;
   int pack_index ;
   unsigned long flush_count ;
};
#line 5197
enum __anonenum_type_117194467 {
    DCT_TYPE = 0,
    DCT_MANGLED = 1,
    DCT_GLOBAL_CTORS = 2,
    DCT_GLOBAL_DTORS = 3
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
struct __anonstruct_h_290956128 {
   union hdr *next ;
   char *deep ;
};
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
union hdr {
   char align[sizeof(double )] ;
   struct __anonstruct_h_290956128 h ;
};
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
typedef union hdr header;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 130 "../bfd/bfd.h"
typedef int bfd_boolean;
#line 44 "./../include/aout/ar.h"
struct ar_hdr {
   char ar_name[16] ;
   char ar_date[12] ;
   char ar_uid[6] ;
   char ar_gid[6] ;
   char ar_mode[8] ;
   char ar_size[10] ;
   char ar_fmag[2] ;
};
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.h"
typedef unsigned long long elf_vma;
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.h"
struct archive_info {
   char *file_name ;
   FILE *file ;
   elf_vma index_num ;
   elf_vma *index_array ;
   char *sym_table ;
   unsigned long sym_size ;
   char *longnames ;
   unsigned long longnames_size ;
   unsigned long nested_member_origin ;
   unsigned long next_arhdr_offset ;
   bfd_boolean is_thin_archive ;
   bfd_boolean uses_64bit_indicies ;
   struct ar_hdr arhdr ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 317 "./../include/dwarf2.h"
enum dwarf_macinfo_record_type {
    DW_MACINFO_define = 1,
    DW_MACINFO_undef = 2,
    DW_MACINFO_start_file = 3,
    DW_MACINFO_end_file = 4,
    DW_MACINFO_vendor_ext = 255
} ;
#line 22 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef unsigned long long dwarf_vma;
#line 23 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef long long dwarf_signed_vma;
#line 24 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef unsigned long long dwarf_size_type;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_LineInfo_750835996 {
   dwarf_vma li_length ;
   unsigned short li_version ;
   unsigned int li_prologue_length ;
   unsigned char li_min_insn_length ;
   unsigned char li_max_ops_per_insn ;
   unsigned char li_default_is_stmt ;
   int li_line_base ;
   unsigned char li_line_range ;
   unsigned char li_opcode_base ;
};
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_LineInfo_750835996 DWARF2_Internal_LineInfo;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_PubNames_63719989 {
   dwarf_vma pn_length ;
   unsigned short pn_version ;
   dwarf_vma pn_offset ;
   dwarf_vma pn_size ;
};
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_PubNames_63719989 DWARF2_Internal_PubNames;
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_CompUnit_606514397 {
   dwarf_vma cu_length ;
   unsigned short cu_version ;
   dwarf_vma cu_abbrev_offset ;
   unsigned char cu_pointer_size ;
};
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_CompUnit_606514397 DWARF2_Internal_CompUnit;
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct __anonstruct_DWARF2_Internal_ARange_813886262 {
   dwarf_vma ar_length ;
   unsigned short ar_version ;
   dwarf_vma ar_info_offset ;
   unsigned char ar_pointer_size ;
   unsigned char ar_segment_size ;
};
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef struct __anonstruct_DWARF2_Internal_ARange_813886262 DWARF2_Internal_ARange;
#line 112
enum dwarf_section_display_enum {
    abbrev = 0,
    aranges = 1,
    frame = 2,
    info = 3,
    line = 4,
    pubnames = 5,
    eh_frame = 6,
    macinfo = 7,
    macro = 8,
    str = 9,
    loc = 10,
    pubtypes = 11,
    ranges = 12,
    static_func = 13,
    static_vars = 14,
    types = 15,
    weaknames = 16,
    gdb_index = 17,
    trace_info = 18,
    trace_abbrev = 19,
    trace_aranges = 20,
    info_dwo = 21,
    abbrev_dwo = 22,
    types_dwo = 23,
    line_dwo = 24,
    loc_dwo = 25,
    macro_dwo = 26,
    macinfo_dwo = 27,
    str_dwo = 28,
    str_index = 29,
    str_index_dwo = 30,
    debug_addr = 31,
    max = 32
} ;
#line 149 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct dwarf_section {
   char const   *uncompressed_name ;
   char const   *compressed_name ;
   char const   *name ;
   unsigned char *start ;
   dwarf_vma address ;
   dwarf_size_type size ;
   enum dwarf_section_display_enum abbrev_sec ;
};
#line 166 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct dwarf_section_display {
   struct dwarf_section section ;
   int (*display)(struct dwarf_section * , void * ) ;
   int *enabled ;
   unsigned int relocate : 1 ;
};
#line 178 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct __anonstruct_debug_info_540759837 {
   unsigned int pointer_size ;
   unsigned int offset_size ;
   int dwarf_version ;
   dwarf_vma cu_offset ;
   dwarf_vma base_address ;
   dwarf_vma addr_base ;
   dwarf_vma ranges_base ;
   dwarf_vma *loc_offsets ;
   int *have_frame_base ;
   unsigned int num_loc_offsets ;
   unsigned int max_loc_offsets ;
   dwarf_vma *range_lists ;
   unsigned int num_range_lists ;
   unsigned int max_range_lists ;
};
#line 178 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
typedef struct __anonstruct_debug_info_540759837 debug_info;
#line 60 "./../include/gdb/gdb-index.h"
enum __anonenum_gdb_index_symbol_kind_213103833 {
    GDB_INDEX_SYMBOL_KIND_NONE = 0,
    GDB_INDEX_SYMBOL_KIND_TYPE = 1,
    GDB_INDEX_SYMBOL_KIND_VARIABLE = 2,
    GDB_INDEX_SYMBOL_KIND_FUNCTION = 3,
    GDB_INDEX_SYMBOL_KIND_OTHER = 4,
    GDB_INDEX_SYMBOL_KIND_UNUSED5 = 5,
    GDB_INDEX_SYMBOL_KIND_UNUSED6 = 6,
    GDB_INDEX_SYMBOL_KIND_UNUSED7 = 7
} ;
#line 60 "./../include/gdb/gdb-index.h"
typedef enum __anonenum_gdb_index_symbol_kind_213103833 gdb_index_symbol_kind;
#line 158 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct dwarf_vmatoa_buf {
   char place[64] ;
};
#line 232 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct State_Machine_Registers {
   dwarf_vma address ;
   unsigned int file ;
   unsigned int line ;
   unsigned int column ;
   int is_stmt ;
   int basic_block ;
   unsigned char op_index ;
   unsigned char end_sequence ;
   unsigned int last_file_entry ;
};
#line 232 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
typedef struct State_Machine_Registers SMR;
#line 511 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct abbrev_attr {
   unsigned long attribute ;
   unsigned long form ;
   struct abbrev_attr *next ;
};
#line 511 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
typedef struct abbrev_attr abbrev_attr;
#line 519 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct abbrev_entry {
   unsigned long entry ;
   unsigned long tag ;
   int children ;
   struct abbrev_attr *first_attr ;
   struct abbrev_attr *last_attr ;
   struct abbrev_entry *next ;
};
#line 519 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
typedef struct abbrev_entry abbrev_entry;
#line 2673 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct __anonstruct_File_Entry_450790744 {
   unsigned char *name ;
   unsigned int directory_index ;
   unsigned int modification_date ;
   unsigned int length ;
};
#line 2673 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
typedef struct __anonstruct_File_Entry_450790744 File_Entry;
#line 4438 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct range_entry {
   unsigned long ranges_offset ;
   debug_info *debug_info_p ;
};
#line 4611 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct Frame_Chunk {
   struct Frame_Chunk *next ;
   unsigned char *chunk_start ;
   int ncols ;
   short *col_type ;
   int *col_offset ;
   char *augmentation ;
   unsigned int code_factor ;
   int data_factor ;
   unsigned long pc_begin ;
   unsigned long pc_range ;
   int cfa_reg ;
   int cfa_offset ;
   int ra ;
   unsigned char fde_encoding ;
   unsigned char cfa_exp ;
   unsigned char ptr_size ;
   unsigned char segment_size ;
};
#line 4611 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
typedef struct Frame_Chunk Frame_Chunk;
#line 5895 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct __anonstruct_debug_dump_long_opts_37437826 {
   char const   *option ;
   int *variable ;
   int val ;
};
#line 5895 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
typedef struct __anonstruct_debug_dump_long_opts_37437826 debug_dump_long_opts;
#line 142 "../bfd/bfd.h"
typedef unsigned long bfd_vma;
#line 175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
typedef bfd_vma unw_word;
#line 1047 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
typedef unsigned char const   *(*unw_decoder)(unsigned char const   * , unsigned int  ,
                                              void * );
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_100682077 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_100682077 __mbstate_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 391 "/usr/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/usr/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/usr/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/usr/include/zconf.h"
typedef Byte Bytef;
#line 409 "/usr/include/zconf.h"
typedef void *voidpf;
#line 84 "/usr/include/zlib.h"
struct internal_state ;
#line 86 "/usr/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/usr/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/usr/include/zlib.h"
typedef z_stream *z_streamp;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 98 "../bfd/bfd.h"
typedef long bfd_int64_t;
#line 99 "../bfd/bfd.h"
typedef unsigned long bfd_uint64_t;
#line 119
struct bfd ;
#line 119 "../bfd/bfd.h"
typedef struct bfd bfd;
#line 143 "../bfd/bfd.h"
typedef long bfd_signed_vma;
#line 144 "../bfd/bfd.h"
typedef unsigned long bfd_size_type;
#line 145 "../bfd/bfd.h"
typedef unsigned long symvalue;
#line 197 "../bfd/bfd.h"
typedef long file_ptr;
#line 198 "../bfd/bfd.h"
typedef unsigned long ufile_ptr;
#line 206 "../bfd/bfd.h"
typedef unsigned int flagword;
#line 207 "../bfd/bfd.h"
typedef unsigned char bfd_byte;
#line 211
enum bfd_format {
    bfd_unknown = 0,
    bfd_object = 1,
    bfd_archive = 2,
    bfd_core = 3,
    bfd_type_end = 4
} ;
#line 211 "../bfd/bfd.h"
typedef enum bfd_format bfd_format;
#line 224 "../bfd/bfd.h"
typedef unsigned long symindex;
#line 227
struct reloc_howto_struct ;
#line 227 "../bfd/bfd.h"
typedef struct reloc_howto_struct  const  reloc_howto_type;
#line 258 "../bfd/bfd.h"
union __anonunion_u_849859159 {
   file_ptr pos ;
   bfd *abfd ;
};
#line 258 "../bfd/bfd.h"
struct orl {
   char **name ;
   union __anonunion_u_849859159 u ;
   int namidx ;
};
#line 270
struct bfd_symbol ;
#line 270 "../bfd/bfd.h"
union __anonunion_u_625080999 {
   struct bfd_symbol *sym ;
   bfd_vma offset ;
};
#line 270 "../bfd/bfd.h"
struct lineno_cache_entry {
   unsigned int line_number ;
   union __anonunion_u_625080999 u ;
};
#line 270 "../bfd/bfd.h"
typedef struct lineno_cache_entry alent;
#line 286
struct bfd_section ;
#line 286 "../bfd/bfd.h"
typedef struct bfd_section *sec_ptr;
#line 319
enum bfd_print_symbol {
    bfd_print_symbol_name = 0,
    bfd_print_symbol_more = 1,
    bfd_print_symbol_all = 2
} ;
#line 319 "../bfd/bfd.h"
typedef enum bfd_print_symbol bfd_print_symbol_type;
#line 328 "../bfd/bfd.h"
struct _symbol_info {
   symvalue value ;
   char type ;
   char const   *name ;
   unsigned char stab_type ;
   char stab_other ;
   short stab_desc ;
   char const   *stab_name ;
};
#line 328 "../bfd/bfd.h"
typedef struct _symbol_info symbol_info;
#line 348 "../bfd/bfd.h"
struct bfd_hash_entry {
   struct bfd_hash_entry *next ;
   char const   *string ;
   unsigned long hash ;
};
#line 361 "../bfd/bfd.h"
struct bfd_hash_table {
   struct bfd_hash_entry **table ;
   struct bfd_hash_entry *(*newfunc)(struct bfd_hash_entry * , struct bfd_hash_table * ,
                                     char const   * ) ;
   void *memory ;
   unsigned int size ;
   unsigned int count ;
   unsigned int entsize ;
   unsigned int frozen : 1 ;
};
#line 572
struct bfd_link_info ;
#line 573
struct bfd_link_hash_entry ;
#line 759
struct _bfd_window_internal ;
#line 762 "../bfd/bfd.h"
struct _bfd_window {
   void *data ;
   bfd_size_type size ;
   struct _bfd_window_internal *i ;
};
#line 762 "../bfd/bfd.h"
typedef struct _bfd_window bfd_window;
#line 1182
struct relax_table ;
#line 1182
struct reloc_cache_entry ;
#line 1182
struct relent_chain ;
#line 1182
struct bfd_link_order ;
#line 1182 "../bfd/bfd.h"
union __anonunion_map_head_422694991 {
   struct bfd_link_order *link_order ;
   struct bfd_section *s ;
};
#line 1182 "../bfd/bfd.h"
struct bfd_section {
   char const   *name ;
   int id ;
   int index ;
   struct bfd_section *next ;
   struct bfd_section *prev ;
   flagword flags ;
   unsigned int user_set_vma : 1 ;
   unsigned int linker_mark : 1 ;
   unsigned int linker_has_input : 1 ;
   unsigned int gc_mark : 1 ;
   unsigned int compress_status : 2 ;
   unsigned int segment_mark : 1 ;
   unsigned int sec_info_type : 3 ;
   unsigned int use_rela_p : 1 ;
   unsigned int sec_flg0 : 1 ;
   unsigned int sec_flg1 : 1 ;
   unsigned int sec_flg2 : 1 ;
   unsigned int sec_flg3 : 1 ;
   unsigned int sec_flg4 : 1 ;
   unsigned int sec_flg5 : 1 ;
   bfd_vma vma ;
   bfd_vma lma ;
   bfd_size_type size ;
   bfd_size_type rawsize ;
   bfd_size_type compressed_size ;
   struct relax_table *relax ;
   int relax_count ;
   bfd_vma output_offset ;
   struct bfd_section *output_section ;
   unsigned int alignment_power ;
   struct reloc_cache_entry *relocation ;
   struct reloc_cache_entry **orelocation ;
   unsigned int reloc_count ;
   file_ptr filepos ;
   file_ptr rel_filepos ;
   file_ptr line_filepos ;
   void *userdata ;
   unsigned char *contents ;
   alent *lineno ;
   unsigned int lineno_count ;
   unsigned int entsize ;
   struct bfd_section *kept_section ;
   file_ptr moving_line_filepos ;
   int target_index ;
   void *used_by_bfd ;
   struct relent_chain *constructor_chain ;
   bfd *owner ;
   struct bfd_symbol *symbol ;
   struct bfd_symbol **symbol_ptr_ptr ;
   union __anonunion_map_head_422694991 map_head ;
   union __anonunion_map_head_422694991 map_tail ;
};
#line 1182 "../bfd/bfd.h"
typedef struct bfd_section asection;
#line 1565 "../bfd/bfd.h"
struct relax_table {
   bfd_vma addr ;
   int size ;
};
#line 1800
enum bfd_architecture {
    bfd_arch_unknown = 0,
    bfd_arch_obscure = 1,
    bfd_arch_m68k = 2,
    bfd_arch_vax = 3,
    bfd_arch_i960 = 4,
    bfd_arch_or32 = 5,
    bfd_arch_sparc = 6,
    bfd_arch_spu = 7,
    bfd_arch_mips = 8,
    bfd_arch_i386 = 9,
    bfd_arch_l1om = 10,
    bfd_arch_k1om = 11,
    bfd_arch_we32k = 12,
    bfd_arch_tahoe = 13,
    bfd_arch_i860 = 14,
    bfd_arch_i370 = 15,
    bfd_arch_romp = 16,
    bfd_arch_convex = 17,
    bfd_arch_m88k = 18,
    bfd_arch_m98k = 19,
    bfd_arch_pyramid = 20,
    bfd_arch_h8300 = 21,
    bfd_arch_pdp11 = 22,
    bfd_arch_plugin = 23,
    bfd_arch_powerpc = 24,
    bfd_arch_rs6000 = 25,
    bfd_arch_hppa = 26,
    bfd_arch_d10v = 27,
    bfd_arch_d30v = 28,
    bfd_arch_dlx = 29,
    bfd_arch_m68hc11 = 30,
    bfd_arch_m68hc12 = 31,
    bfd_arch_m9s12x = 32,
    bfd_arch_m9s12xg = 33,
    bfd_arch_z8k = 34,
    bfd_arch_h8500 = 35,
    bfd_arch_sh = 36,
    bfd_arch_alpha = 37,
    bfd_arch_arm = 38,
    bfd_arch_ns32k = 39,
    bfd_arch_w65 = 40,
    bfd_arch_tic30 = 41,
    bfd_arch_tic4x = 42,
    bfd_arch_tic54x = 43,
    bfd_arch_tic6x = 44,
    bfd_arch_tic80 = 45,
    bfd_arch_v850 = 46,
    bfd_arch_arc = 47,
    bfd_arch_m32c = 48,
    bfd_arch_m32r = 49,
    bfd_arch_mn10200 = 50,
    bfd_arch_mn10300 = 51,
    bfd_arch_fr30 = 52,
    bfd_arch_frv = 53,
    bfd_arch_moxie = 54,
    bfd_arch_mcore = 55,
    bfd_arch_mep = 56,
    bfd_arch_ia64 = 57,
    bfd_arch_ip2k = 58,
    bfd_arch_iq2000 = 59,
    bfd_arch_epiphany = 60,
    bfd_arch_mt = 61,
    bfd_arch_pj = 62,
    bfd_arch_avr = 63,
    bfd_arch_bfin = 64,
    bfd_arch_cr16 = 65,
    bfd_arch_cr16c = 66,
    bfd_arch_crx = 67,
    bfd_arch_cris = 68,
    bfd_arch_rl78 = 69,
    bfd_arch_rx = 70,
    bfd_arch_s390 = 71,
    bfd_arch_score = 72,
    bfd_arch_openrisc = 73,
    bfd_arch_mmix = 74,
    bfd_arch_xstormy16 = 75,
    bfd_arch_msp430 = 76,
    bfd_arch_xc16x = 77,
    bfd_arch_xgate = 78,
    bfd_arch_xtensa = 79,
    bfd_arch_z80 = 80,
    bfd_arch_lm32 = 81,
    bfd_arch_microblaze = 82,
    bfd_arch_tilepro = 83,
    bfd_arch_tilegx = 84,
    bfd_arch_aarch64 = 85,
    bfd_arch_last = 86
} ;
#line 2198 "../bfd/bfd.h"
struct bfd_arch_info {
   int bits_per_word ;
   int bits_per_address ;
   int bits_per_byte ;
   enum bfd_architecture arch ;
   unsigned long mach ;
   char const   *arch_name ;
   char const   *printable_name ;
   unsigned int section_align_power ;
   bfd_boolean the_default ;
   struct bfd_arch_info  const  *(*compatible)(struct bfd_arch_info  const  *a , struct bfd_arch_info  const  *b ) ;
   bfd_boolean (*scan)(struct bfd_arch_info  const  * , char const   * ) ;
   void *(*fill)(bfd_size_type count , bfd_boolean is_bigendian , bfd_boolean code ) ;
   struct bfd_arch_info  const  *next ;
};
#line 2260
enum bfd_reloc_status {
    bfd_reloc_ok = 0,
    bfd_reloc_overflow = 1,
    bfd_reloc_outofrange = 2,
    bfd_reloc_continue = 3,
    bfd_reloc_notsupported = 4,
    bfd_reloc_other = 5,
    bfd_reloc_undefined = 6,
    bfd_reloc_dangerous = 7
} ;
#line 2260 "../bfd/bfd.h"
typedef enum bfd_reloc_status bfd_reloc_status_type;
#line 2292 "../bfd/bfd.h"
struct reloc_cache_entry {
   struct bfd_symbol **sym_ptr_ptr ;
   bfd_size_type address ;
   bfd_vma addend ;
   reloc_howto_type *howto ;
};
#line 2292 "../bfd/bfd.h"
typedef struct reloc_cache_entry arelent;
#line 2309
enum complain_overflow {
    complain_overflow_dont = 0,
    complain_overflow_bitfield = 1,
    complain_overflow_signed = 2,
    complain_overflow_unsigned = 3
} ;
#line 2328 "../bfd/bfd.h"
struct reloc_howto_struct {
   unsigned int type ;
   unsigned int rightshift ;
   int size ;
   unsigned int bitsize ;
   bfd_boolean pc_relative ;
   unsigned int bitpos ;
   enum complain_overflow complain_on_overflow ;
   bfd_reloc_status_type (*special_function)(bfd * , arelent * , struct bfd_symbol * ,
                                             void * , asection * , bfd * , char ** ) ;
   char *name ;
   bfd_boolean partial_inplace ;
   bfd_vma src_mask ;
   bfd_vma dst_mask ;
   bfd_boolean pcrel_offset ;
};
#line 2440 "../bfd/bfd.h"
struct relent_chain {
   arelent relent ;
   struct relent_chain *next ;
};
#line 2469
enum bfd_reloc_code_real {
    _dummy_first_bfd_reloc_code_real = 0,
    BFD_RELOC_64 = 1,
    BFD_RELOC_32 = 2,
    BFD_RELOC_26 = 3,
    BFD_RELOC_24 = 4,
    BFD_RELOC_16 = 5,
    BFD_RELOC_14 = 6,
    BFD_RELOC_8 = 7,
    BFD_RELOC_64_PCREL = 8,
    BFD_RELOC_32_PCREL = 9,
    BFD_RELOC_24_PCREL = 10,
    BFD_RELOC_16_PCREL = 11,
    BFD_RELOC_12_PCREL = 12,
    BFD_RELOC_8_PCREL = 13,
    BFD_RELOC_32_SECREL = 14,
    BFD_RELOC_32_GOT_PCREL = 15,
    BFD_RELOC_16_GOT_PCREL = 16,
    BFD_RELOC_8_GOT_PCREL = 17,
    BFD_RELOC_32_GOTOFF = 18,
    BFD_RELOC_16_GOTOFF = 19,
    BFD_RELOC_LO16_GOTOFF = 20,
    BFD_RELOC_HI16_GOTOFF = 21,
    BFD_RELOC_HI16_S_GOTOFF = 22,
    BFD_RELOC_8_GOTOFF = 23,
    BFD_RELOC_64_PLT_PCREL = 24,
    BFD_RELOC_32_PLT_PCREL = 25,
    BFD_RELOC_24_PLT_PCREL = 26,
    BFD_RELOC_16_PLT_PCREL = 27,
    BFD_RELOC_8_PLT_PCREL = 28,
    BFD_RELOC_64_PLTOFF = 29,
    BFD_RELOC_32_PLTOFF = 30,
    BFD_RELOC_16_PLTOFF = 31,
    BFD_RELOC_LO16_PLTOFF = 32,
    BFD_RELOC_HI16_PLTOFF = 33,
    BFD_RELOC_HI16_S_PLTOFF = 34,
    BFD_RELOC_8_PLTOFF = 35,
    BFD_RELOC_68K_GLOB_DAT = 36,
    BFD_RELOC_68K_JMP_SLOT = 37,
    BFD_RELOC_68K_RELATIVE = 38,
    BFD_RELOC_68K_TLS_GD32 = 39,
    BFD_RELOC_68K_TLS_GD16 = 40,
    BFD_RELOC_68K_TLS_GD8 = 41,
    BFD_RELOC_68K_TLS_LDM32 = 42,
    BFD_RELOC_68K_TLS_LDM16 = 43,
    BFD_RELOC_68K_TLS_LDM8 = 44,
    BFD_RELOC_68K_TLS_LDO32 = 45,
    BFD_RELOC_68K_TLS_LDO16 = 46,
    BFD_RELOC_68K_TLS_LDO8 = 47,
    BFD_RELOC_68K_TLS_IE32 = 48,
    BFD_RELOC_68K_TLS_IE16 = 49,
    BFD_RELOC_68K_TLS_IE8 = 50,
    BFD_RELOC_68K_TLS_LE32 = 51,
    BFD_RELOC_68K_TLS_LE16 = 52,
    BFD_RELOC_68K_TLS_LE8 = 53,
    BFD_RELOC_32_BASEREL = 54,
    BFD_RELOC_16_BASEREL = 55,
    BFD_RELOC_LO16_BASEREL = 56,
    BFD_RELOC_HI16_BASEREL = 57,
    BFD_RELOC_HI16_S_BASEREL = 58,
    BFD_RELOC_8_BASEREL = 59,
    BFD_RELOC_RVA = 60,
    BFD_RELOC_8_FFnn = 61,
    BFD_RELOC_32_PCREL_S2 = 62,
    BFD_RELOC_16_PCREL_S2 = 63,
    BFD_RELOC_23_PCREL_S2 = 64,
    BFD_RELOC_HI22 = 65,
    BFD_RELOC_LO10 = 66,
    BFD_RELOC_GPREL16 = 67,
    BFD_RELOC_GPREL32 = 68,
    BFD_RELOC_I960_CALLJ = 69,
    BFD_RELOC_NONE = 70,
    BFD_RELOC_SPARC_WDISP22 = 71,
    BFD_RELOC_SPARC22 = 72,
    BFD_RELOC_SPARC13 = 73,
    BFD_RELOC_SPARC_GOT10 = 74,
    BFD_RELOC_SPARC_GOT13 = 75,
    BFD_RELOC_SPARC_GOT22 = 76,
    BFD_RELOC_SPARC_PC10 = 77,
    BFD_RELOC_SPARC_PC22 = 78,
    BFD_RELOC_SPARC_WPLT30 = 79,
    BFD_RELOC_SPARC_COPY = 80,
    BFD_RELOC_SPARC_GLOB_DAT = 81,
    BFD_RELOC_SPARC_JMP_SLOT = 82,
    BFD_RELOC_SPARC_RELATIVE = 83,
    BFD_RELOC_SPARC_UA16 = 84,
    BFD_RELOC_SPARC_UA32 = 85,
    BFD_RELOC_SPARC_UA64 = 86,
    BFD_RELOC_SPARC_GOTDATA_HIX22 = 87,
    BFD_RELOC_SPARC_GOTDATA_LOX10 = 88,
    BFD_RELOC_SPARC_GOTDATA_OP_HIX22 = 89,
    BFD_RELOC_SPARC_GOTDATA_OP_LOX10 = 90,
    BFD_RELOC_SPARC_GOTDATA_OP = 91,
    BFD_RELOC_SPARC_JMP_IREL = 92,
    BFD_RELOC_SPARC_IRELATIVE = 93,
    BFD_RELOC_SPARC_BASE13 = 94,
    BFD_RELOC_SPARC_BASE22 = 95,
    BFD_RELOC_SPARC_10 = 96,
    BFD_RELOC_SPARC_11 = 97,
    BFD_RELOC_SPARC_OLO10 = 98,
    BFD_RELOC_SPARC_HH22 = 99,
    BFD_RELOC_SPARC_HM10 = 100,
    BFD_RELOC_SPARC_LM22 = 101,
    BFD_RELOC_SPARC_PC_HH22 = 102,
    BFD_RELOC_SPARC_PC_HM10 = 103,
    BFD_RELOC_SPARC_PC_LM22 = 104,
    BFD_RELOC_SPARC_WDISP16 = 105,
    BFD_RELOC_SPARC_WDISP19 = 106,
    BFD_RELOC_SPARC_7 = 107,
    BFD_RELOC_SPARC_6 = 108,
    BFD_RELOC_SPARC_5 = 109,
    BFD_RELOC_SPARC_PLT32 = 110,
    BFD_RELOC_SPARC_PLT64 = 111,
    BFD_RELOC_SPARC_HIX22 = 112,
    BFD_RELOC_SPARC_LOX10 = 113,
    BFD_RELOC_SPARC_H44 = 114,
    BFD_RELOC_SPARC_M44 = 115,
    BFD_RELOC_SPARC_L44 = 116,
    BFD_RELOC_SPARC_REGISTER = 117,
    BFD_RELOC_SPARC_H34 = 118,
    BFD_RELOC_SPARC_SIZE32 = 119,
    BFD_RELOC_SPARC_SIZE64 = 120,
    BFD_RELOC_SPARC_WDISP10 = 121,
    BFD_RELOC_SPARC_REV32 = 122,
    BFD_RELOC_SPARC_TLS_GD_HI22 = 123,
    BFD_RELOC_SPARC_TLS_GD_LO10 = 124,
    BFD_RELOC_SPARC_TLS_GD_ADD = 125,
    BFD_RELOC_SPARC_TLS_GD_CALL = 126,
    BFD_RELOC_SPARC_TLS_LDM_HI22 = 127,
    BFD_RELOC_SPARC_TLS_LDM_LO10 = 128,
    BFD_RELOC_SPARC_TLS_LDM_ADD = 129,
    BFD_RELOC_SPARC_TLS_LDM_CALL = 130,
    BFD_RELOC_SPARC_TLS_LDO_HIX22 = 131,
    BFD_RELOC_SPARC_TLS_LDO_LOX10 = 132,
    BFD_RELOC_SPARC_TLS_LDO_ADD = 133,
    BFD_RELOC_SPARC_TLS_IE_HI22 = 134,
    BFD_RELOC_SPARC_TLS_IE_LO10 = 135,
    BFD_RELOC_SPARC_TLS_IE_LD = 136,
    BFD_RELOC_SPARC_TLS_IE_LDX = 137,
    BFD_RELOC_SPARC_TLS_IE_ADD = 138,
    BFD_RELOC_SPARC_TLS_LE_HIX22 = 139,
    BFD_RELOC_SPARC_TLS_LE_LOX10 = 140,
    BFD_RELOC_SPARC_TLS_DTPMOD32 = 141,
    BFD_RELOC_SPARC_TLS_DTPMOD64 = 142,
    BFD_RELOC_SPARC_TLS_DTPOFF32 = 143,
    BFD_RELOC_SPARC_TLS_DTPOFF64 = 144,
    BFD_RELOC_SPARC_TLS_TPOFF32 = 145,
    BFD_RELOC_SPARC_TLS_TPOFF64 = 146,
    BFD_RELOC_SPU_IMM7 = 147,
    BFD_RELOC_SPU_IMM8 = 148,
    BFD_RELOC_SPU_IMM10 = 149,
    BFD_RELOC_SPU_IMM10W = 150,
    BFD_RELOC_SPU_IMM16 = 151,
    BFD_RELOC_SPU_IMM16W = 152,
    BFD_RELOC_SPU_IMM18 = 153,
    BFD_RELOC_SPU_PCREL9a = 154,
    BFD_RELOC_SPU_PCREL9b = 155,
    BFD_RELOC_SPU_PCREL16 = 156,
    BFD_RELOC_SPU_LO16 = 157,
    BFD_RELOC_SPU_HI16 = 158,
    BFD_RELOC_SPU_PPU32 = 159,
    BFD_RELOC_SPU_PPU64 = 160,
    BFD_RELOC_SPU_ADD_PIC = 161,
    BFD_RELOC_ALPHA_GPDISP_HI16 = 162,
    BFD_RELOC_ALPHA_GPDISP_LO16 = 163,
    BFD_RELOC_ALPHA_GPDISP = 164,
    BFD_RELOC_ALPHA_LITERAL = 165,
    BFD_RELOC_ALPHA_ELF_LITERAL = 166,
    BFD_RELOC_ALPHA_LITUSE = 167,
    BFD_RELOC_ALPHA_HINT = 168,
    BFD_RELOC_ALPHA_LINKAGE = 169,
    BFD_RELOC_ALPHA_CODEADDR = 170,
    BFD_RELOC_ALPHA_GPREL_HI16 = 171,
    BFD_RELOC_ALPHA_GPREL_LO16 = 172,
    BFD_RELOC_ALPHA_BRSGP = 173,
    BFD_RELOC_ALPHA_NOP = 174,
    BFD_RELOC_ALPHA_BSR = 175,
    BFD_RELOC_ALPHA_LDA = 176,
    BFD_RELOC_ALPHA_BOH = 177,
    BFD_RELOC_ALPHA_TLSGD = 178,
    BFD_RELOC_ALPHA_TLSLDM = 179,
    BFD_RELOC_ALPHA_DTPMOD64 = 180,
    BFD_RELOC_ALPHA_GOTDTPREL16 = 181,
    BFD_RELOC_ALPHA_DTPREL64 = 182,
    BFD_RELOC_ALPHA_DTPREL_HI16 = 183,
    BFD_RELOC_ALPHA_DTPREL_LO16 = 184,
    BFD_RELOC_ALPHA_DTPREL16 = 185,
    BFD_RELOC_ALPHA_GOTTPREL16 = 186,
    BFD_RELOC_ALPHA_TPREL64 = 187,
    BFD_RELOC_ALPHA_TPREL_HI16 = 188,
    BFD_RELOC_ALPHA_TPREL_LO16 = 189,
    BFD_RELOC_ALPHA_TPREL16 = 190,
    BFD_RELOC_MIPS_JMP = 191,
    BFD_RELOC_MICROMIPS_JMP = 192,
    BFD_RELOC_MIPS16_JMP = 193,
    BFD_RELOC_MIPS16_GPREL = 194,
    BFD_RELOC_HI16 = 195,
    BFD_RELOC_HI16_S = 196,
    BFD_RELOC_LO16 = 197,
    BFD_RELOC_HI16_PCREL = 198,
    BFD_RELOC_HI16_S_PCREL = 199,
    BFD_RELOC_LO16_PCREL = 200,
    BFD_RELOC_MIPS16_GOT16 = 201,
    BFD_RELOC_MIPS16_CALL16 = 202,
    BFD_RELOC_MIPS16_HI16 = 203,
    BFD_RELOC_MIPS16_HI16_S = 204,
    BFD_RELOC_MIPS16_LO16 = 205,
    BFD_RELOC_MIPS16_TLS_GD = 206,
    BFD_RELOC_MIPS16_TLS_LDM = 207,
    BFD_RELOC_MIPS16_TLS_DTPREL_HI16 = 208,
    BFD_RELOC_MIPS16_TLS_DTPREL_LO16 = 209,
    BFD_RELOC_MIPS16_TLS_GOTTPREL = 210,
    BFD_RELOC_MIPS16_TLS_TPREL_HI16 = 211,
    BFD_RELOC_MIPS16_TLS_TPREL_LO16 = 212,
    BFD_RELOC_MIPS_LITERAL = 213,
    BFD_RELOC_MICROMIPS_LITERAL = 214,
    BFD_RELOC_MICROMIPS_7_PCREL_S1 = 215,
    BFD_RELOC_MICROMIPS_10_PCREL_S1 = 216,
    BFD_RELOC_MICROMIPS_16_PCREL_S1 = 217,
    BFD_RELOC_MICROMIPS_GPREL16 = 218,
    BFD_RELOC_MICROMIPS_HI16 = 219,
    BFD_RELOC_MICROMIPS_HI16_S = 220,
    BFD_RELOC_MICROMIPS_LO16 = 221,
    BFD_RELOC_MIPS_GOT16 = 222,
    BFD_RELOC_MICROMIPS_GOT16 = 223,
    BFD_RELOC_MIPS_CALL16 = 224,
    BFD_RELOC_MICROMIPS_CALL16 = 225,
    BFD_RELOC_MIPS_GOT_HI16 = 226,
    BFD_RELOC_MICROMIPS_GOT_HI16 = 227,
    BFD_RELOC_MIPS_GOT_LO16 = 228,
    BFD_RELOC_MICROMIPS_GOT_LO16 = 229,
    BFD_RELOC_MIPS_CALL_HI16 = 230,
    BFD_RELOC_MICROMIPS_CALL_HI16 = 231,
    BFD_RELOC_MIPS_CALL_LO16 = 232,
    BFD_RELOC_MICROMIPS_CALL_LO16 = 233,
    BFD_RELOC_MIPS_SUB = 234,
    BFD_RELOC_MICROMIPS_SUB = 235,
    BFD_RELOC_MIPS_GOT_PAGE = 236,
    BFD_RELOC_MICROMIPS_GOT_PAGE = 237,
    BFD_RELOC_MIPS_GOT_OFST = 238,
    BFD_RELOC_MICROMIPS_GOT_OFST = 239,
    BFD_RELOC_MIPS_GOT_DISP = 240,
    BFD_RELOC_MICROMIPS_GOT_DISP = 241,
    BFD_RELOC_MIPS_SHIFT5 = 242,
    BFD_RELOC_MIPS_SHIFT6 = 243,
    BFD_RELOC_MIPS_INSERT_A = 244,
    BFD_RELOC_MIPS_INSERT_B = 245,
    BFD_RELOC_MIPS_DELETE = 246,
    BFD_RELOC_MIPS_HIGHEST = 247,
    BFD_RELOC_MICROMIPS_HIGHEST = 248,
    BFD_RELOC_MIPS_HIGHER = 249,
    BFD_RELOC_MICROMIPS_HIGHER = 250,
    BFD_RELOC_MIPS_SCN_DISP = 251,
    BFD_RELOC_MICROMIPS_SCN_DISP = 252,
    BFD_RELOC_MIPS_REL16 = 253,
    BFD_RELOC_MIPS_RELGOT = 254,
    BFD_RELOC_MIPS_JALR = 255,
    BFD_RELOC_MICROMIPS_JALR = 256,
    BFD_RELOC_MIPS_TLS_DTPMOD32 = 257,
    BFD_RELOC_MIPS_TLS_DTPREL32 = 258,
    BFD_RELOC_MIPS_TLS_DTPMOD64 = 259,
    BFD_RELOC_MIPS_TLS_DTPREL64 = 260,
    BFD_RELOC_MIPS_TLS_GD = 261,
    BFD_RELOC_MICROMIPS_TLS_GD = 262,
    BFD_RELOC_MIPS_TLS_LDM = 263,
    BFD_RELOC_MICROMIPS_TLS_LDM = 264,
    BFD_RELOC_MIPS_TLS_DTPREL_HI16 = 265,
    BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16 = 266,
    BFD_RELOC_MIPS_TLS_DTPREL_LO16 = 267,
    BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16 = 268,
    BFD_RELOC_MIPS_TLS_GOTTPREL = 269,
    BFD_RELOC_MICROMIPS_TLS_GOTTPREL = 270,
    BFD_RELOC_MIPS_TLS_TPREL32 = 271,
    BFD_RELOC_MIPS_TLS_TPREL64 = 272,
    BFD_RELOC_MIPS_TLS_TPREL_HI16 = 273,
    BFD_RELOC_MICROMIPS_TLS_TPREL_HI16 = 274,
    BFD_RELOC_MIPS_TLS_TPREL_LO16 = 275,
    BFD_RELOC_MICROMIPS_TLS_TPREL_LO16 = 276,
    BFD_RELOC_MIPS_COPY = 277,
    BFD_RELOC_MIPS_JUMP_SLOT = 278,
    BFD_RELOC_MOXIE_10_PCREL = 279,
    BFD_RELOC_FRV_LABEL16 = 280,
    BFD_RELOC_FRV_LABEL24 = 281,
    BFD_RELOC_FRV_LO16 = 282,
    BFD_RELOC_FRV_HI16 = 283,
    BFD_RELOC_FRV_GPREL12 = 284,
    BFD_RELOC_FRV_GPRELU12 = 285,
    BFD_RELOC_FRV_GPREL32 = 286,
    BFD_RELOC_FRV_GPRELHI = 287,
    BFD_RELOC_FRV_GPRELLO = 288,
    BFD_RELOC_FRV_GOT12 = 289,
    BFD_RELOC_FRV_GOTHI = 290,
    BFD_RELOC_FRV_GOTLO = 291,
    BFD_RELOC_FRV_FUNCDESC = 292,
    BFD_RELOC_FRV_FUNCDESC_GOT12 = 293,
    BFD_RELOC_FRV_FUNCDESC_GOTHI = 294,
    BFD_RELOC_FRV_FUNCDESC_GOTLO = 295,
    BFD_RELOC_FRV_FUNCDESC_VALUE = 296,
    BFD_RELOC_FRV_FUNCDESC_GOTOFF12 = 297,
    BFD_RELOC_FRV_FUNCDESC_GOTOFFHI = 298,
    BFD_RELOC_FRV_FUNCDESC_GOTOFFLO = 299,
    BFD_RELOC_FRV_GOTOFF12 = 300,
    BFD_RELOC_FRV_GOTOFFHI = 301,
    BFD_RELOC_FRV_GOTOFFLO = 302,
    BFD_RELOC_FRV_GETTLSOFF = 303,
    BFD_RELOC_FRV_TLSDESC_VALUE = 304,
    BFD_RELOC_FRV_GOTTLSDESC12 = 305,
    BFD_RELOC_FRV_GOTTLSDESCHI = 306,
    BFD_RELOC_FRV_GOTTLSDESCLO = 307,
    BFD_RELOC_FRV_TLSMOFF12 = 308,
    BFD_RELOC_FRV_TLSMOFFHI = 309,
    BFD_RELOC_FRV_TLSMOFFLO = 310,
    BFD_RELOC_FRV_GOTTLSOFF12 = 311,
    BFD_RELOC_FRV_GOTTLSOFFHI = 312,
    BFD_RELOC_FRV_GOTTLSOFFLO = 313,
    BFD_RELOC_FRV_TLSOFF = 314,
    BFD_RELOC_FRV_TLSDESC_RELAX = 315,
    BFD_RELOC_FRV_GETTLSOFF_RELAX = 316,
    BFD_RELOC_FRV_TLSOFF_RELAX = 317,
    BFD_RELOC_FRV_TLSMOFF = 318,
    BFD_RELOC_MN10300_GOTOFF24 = 319,
    BFD_RELOC_MN10300_GOT32 = 320,
    BFD_RELOC_MN10300_GOT24 = 321,
    BFD_RELOC_MN10300_GOT16 = 322,
    BFD_RELOC_MN10300_COPY = 323,
    BFD_RELOC_MN10300_GLOB_DAT = 324,
    BFD_RELOC_MN10300_JMP_SLOT = 325,
    BFD_RELOC_MN10300_RELATIVE = 326,
    BFD_RELOC_MN10300_SYM_DIFF = 327,
    BFD_RELOC_MN10300_ALIGN = 328,
    BFD_RELOC_MN10300_TLS_GD = 329,
    BFD_RELOC_MN10300_TLS_LD = 330,
    BFD_RELOC_MN10300_TLS_LDO = 331,
    BFD_RELOC_MN10300_TLS_GOTIE = 332,
    BFD_RELOC_MN10300_TLS_IE = 333,
    BFD_RELOC_MN10300_TLS_LE = 334,
    BFD_RELOC_MN10300_TLS_DTPMOD = 335,
    BFD_RELOC_MN10300_TLS_DTPOFF = 336,
    BFD_RELOC_MN10300_TLS_TPOFF = 337,
    BFD_RELOC_MN10300_32_PCREL = 338,
    BFD_RELOC_MN10300_16_PCREL = 339,
    BFD_RELOC_386_GOT32 = 340,
    BFD_RELOC_386_PLT32 = 341,
    BFD_RELOC_386_COPY = 342,
    BFD_RELOC_386_GLOB_DAT = 343,
    BFD_RELOC_386_JUMP_SLOT = 344,
    BFD_RELOC_386_RELATIVE = 345,
    BFD_RELOC_386_GOTOFF = 346,
    BFD_RELOC_386_GOTPC = 347,
    BFD_RELOC_386_TLS_TPOFF = 348,
    BFD_RELOC_386_TLS_IE = 349,
    BFD_RELOC_386_TLS_GOTIE = 350,
    BFD_RELOC_386_TLS_LE = 351,
    BFD_RELOC_386_TLS_GD = 352,
    BFD_RELOC_386_TLS_LDM = 353,
    BFD_RELOC_386_TLS_LDO_32 = 354,
    BFD_RELOC_386_TLS_IE_32 = 355,
    BFD_RELOC_386_TLS_LE_32 = 356,
    BFD_RELOC_386_TLS_DTPMOD32 = 357,
    BFD_RELOC_386_TLS_DTPOFF32 = 358,
    BFD_RELOC_386_TLS_TPOFF32 = 359,
    BFD_RELOC_386_TLS_GOTDESC = 360,
    BFD_RELOC_386_TLS_DESC_CALL = 361,
    BFD_RELOC_386_TLS_DESC = 362,
    BFD_RELOC_386_IRELATIVE = 363,
    BFD_RELOC_X86_64_GOT32 = 364,
    BFD_RELOC_X86_64_PLT32 = 365,
    BFD_RELOC_X86_64_COPY = 366,
    BFD_RELOC_X86_64_GLOB_DAT = 367,
    BFD_RELOC_X86_64_JUMP_SLOT = 368,
    BFD_RELOC_X86_64_RELATIVE = 369,
    BFD_RELOC_X86_64_GOTPCREL = 370,
    BFD_RELOC_X86_64_32S = 371,
    BFD_RELOC_X86_64_DTPMOD64 = 372,
    BFD_RELOC_X86_64_DTPOFF64 = 373,
    BFD_RELOC_X86_64_TPOFF64 = 374,
    BFD_RELOC_X86_64_TLSGD = 375,
    BFD_RELOC_X86_64_TLSLD = 376,
    BFD_RELOC_X86_64_DTPOFF32 = 377,
    BFD_RELOC_X86_64_GOTTPOFF = 378,
    BFD_RELOC_X86_64_TPOFF32 = 379,
    BFD_RELOC_X86_64_GOTOFF64 = 380,
    BFD_RELOC_X86_64_GOTPC32 = 381,
    BFD_RELOC_X86_64_GOT64 = 382,
    BFD_RELOC_X86_64_GOTPCREL64 = 383,
    BFD_RELOC_X86_64_GOTPC64 = 384,
    BFD_RELOC_X86_64_GOTPLT64 = 385,
    BFD_RELOC_X86_64_PLTOFF64 = 386,
    BFD_RELOC_X86_64_GOTPC32_TLSDESC = 387,
    BFD_RELOC_X86_64_TLSDESC_CALL = 388,
    BFD_RELOC_X86_64_TLSDESC = 389,
    BFD_RELOC_X86_64_IRELATIVE = 390,
    BFD_RELOC_NS32K_IMM_8 = 391,
    BFD_RELOC_NS32K_IMM_16 = 392,
    BFD_RELOC_NS32K_IMM_32 = 393,
    BFD_RELOC_NS32K_IMM_8_PCREL = 394,
    BFD_RELOC_NS32K_IMM_16_PCREL = 395,
    BFD_RELOC_NS32K_IMM_32_PCREL = 396,
    BFD_RELOC_NS32K_DISP_8 = 397,
    BFD_RELOC_NS32K_DISP_16 = 398,
    BFD_RELOC_NS32K_DISP_32 = 399,
    BFD_RELOC_NS32K_DISP_8_PCREL = 400,
    BFD_RELOC_NS32K_DISP_16_PCREL = 401,
    BFD_RELOC_NS32K_DISP_32_PCREL = 402,
    BFD_RELOC_PDP11_DISP_8_PCREL = 403,
    BFD_RELOC_PDP11_DISP_6_PCREL = 404,
    BFD_RELOC_PJ_CODE_HI16 = 405,
    BFD_RELOC_PJ_CODE_LO16 = 406,
    BFD_RELOC_PJ_CODE_DIR16 = 407,
    BFD_RELOC_PJ_CODE_DIR32 = 408,
    BFD_RELOC_PJ_CODE_REL16 = 409,
    BFD_RELOC_PJ_CODE_REL32 = 410,
    BFD_RELOC_PPC_B26 = 411,
    BFD_RELOC_PPC_BA26 = 412,
    BFD_RELOC_PPC_TOC16 = 413,
    BFD_RELOC_PPC_B16 = 414,
    BFD_RELOC_PPC_B16_BRTAKEN = 415,
    BFD_RELOC_PPC_B16_BRNTAKEN = 416,
    BFD_RELOC_PPC_BA16 = 417,
    BFD_RELOC_PPC_BA16_BRTAKEN = 418,
    BFD_RELOC_PPC_BA16_BRNTAKEN = 419,
    BFD_RELOC_PPC_COPY = 420,
    BFD_RELOC_PPC_GLOB_DAT = 421,
    BFD_RELOC_PPC_JMP_SLOT = 422,
    BFD_RELOC_PPC_RELATIVE = 423,
    BFD_RELOC_PPC_LOCAL24PC = 424,
    BFD_RELOC_PPC_EMB_NADDR32 = 425,
    BFD_RELOC_PPC_EMB_NADDR16 = 426,
    BFD_RELOC_PPC_EMB_NADDR16_LO = 427,
    BFD_RELOC_PPC_EMB_NADDR16_HI = 428,
    BFD_RELOC_PPC_EMB_NADDR16_HA = 429,
    BFD_RELOC_PPC_EMB_SDAI16 = 430,
    BFD_RELOC_PPC_EMB_SDA2I16 = 431,
    BFD_RELOC_PPC_EMB_SDA2REL = 432,
    BFD_RELOC_PPC_EMB_SDA21 = 433,
    BFD_RELOC_PPC_EMB_MRKREF = 434,
    BFD_RELOC_PPC_EMB_RELSEC16 = 435,
    BFD_RELOC_PPC_EMB_RELST_LO = 436,
    BFD_RELOC_PPC_EMB_RELST_HI = 437,
    BFD_RELOC_PPC_EMB_RELST_HA = 438,
    BFD_RELOC_PPC_EMB_BIT_FLD = 439,
    BFD_RELOC_PPC_EMB_RELSDA = 440,
    BFD_RELOC_PPC_VLE_REL8 = 441,
    BFD_RELOC_PPC_VLE_REL15 = 442,
    BFD_RELOC_PPC_VLE_REL24 = 443,
    BFD_RELOC_PPC_VLE_LO16A = 444,
    BFD_RELOC_PPC_VLE_LO16D = 445,
    BFD_RELOC_PPC_VLE_HI16A = 446,
    BFD_RELOC_PPC_VLE_HI16D = 447,
    BFD_RELOC_PPC_VLE_HA16A = 448,
    BFD_RELOC_PPC_VLE_HA16D = 449,
    BFD_RELOC_PPC_VLE_SDA21 = 450,
    BFD_RELOC_PPC_VLE_SDA21_LO = 451,
    BFD_RELOC_PPC_VLE_SDAREL_LO16A = 452,
    BFD_RELOC_PPC_VLE_SDAREL_LO16D = 453,
    BFD_RELOC_PPC_VLE_SDAREL_HI16A = 454,
    BFD_RELOC_PPC_VLE_SDAREL_HI16D = 455,
    BFD_RELOC_PPC_VLE_SDAREL_HA16A = 456,
    BFD_RELOC_PPC_VLE_SDAREL_HA16D = 457,
    BFD_RELOC_PPC64_HIGHER = 458,
    BFD_RELOC_PPC64_HIGHER_S = 459,
    BFD_RELOC_PPC64_HIGHEST = 460,
    BFD_RELOC_PPC64_HIGHEST_S = 461,
    BFD_RELOC_PPC64_TOC16_LO = 462,
    BFD_RELOC_PPC64_TOC16_HI = 463,
    BFD_RELOC_PPC64_TOC16_HA = 464,
    BFD_RELOC_PPC64_TOC = 465,
    BFD_RELOC_PPC64_PLTGOT16 = 466,
    BFD_RELOC_PPC64_PLTGOT16_LO = 467,
    BFD_RELOC_PPC64_PLTGOT16_HI = 468,
    BFD_RELOC_PPC64_PLTGOT16_HA = 469,
    BFD_RELOC_PPC64_ADDR16_DS = 470,
    BFD_RELOC_PPC64_ADDR16_LO_DS = 471,
    BFD_RELOC_PPC64_GOT16_DS = 472,
    BFD_RELOC_PPC64_GOT16_LO_DS = 473,
    BFD_RELOC_PPC64_PLT16_LO_DS = 474,
    BFD_RELOC_PPC64_SECTOFF_DS = 475,
    BFD_RELOC_PPC64_SECTOFF_LO_DS = 476,
    BFD_RELOC_PPC64_TOC16_DS = 477,
    BFD_RELOC_PPC64_TOC16_LO_DS = 478,
    BFD_RELOC_PPC64_PLTGOT16_DS = 479,
    BFD_RELOC_PPC64_PLTGOT16_LO_DS = 480,
    BFD_RELOC_PPC_TLS = 481,
    BFD_RELOC_PPC_TLSGD = 482,
    BFD_RELOC_PPC_TLSLD = 483,
    BFD_RELOC_PPC_DTPMOD = 484,
    BFD_RELOC_PPC_TPREL16 = 485,
    BFD_RELOC_PPC_TPREL16_LO = 486,
    BFD_RELOC_PPC_TPREL16_HI = 487,
    BFD_RELOC_PPC_TPREL16_HA = 488,
    BFD_RELOC_PPC_TPREL = 489,
    BFD_RELOC_PPC_DTPREL16 = 490,
    BFD_RELOC_PPC_DTPREL16_LO = 491,
    BFD_RELOC_PPC_DTPREL16_HI = 492,
    BFD_RELOC_PPC_DTPREL16_HA = 493,
    BFD_RELOC_PPC_DTPREL = 494,
    BFD_RELOC_PPC_GOT_TLSGD16 = 495,
    BFD_RELOC_PPC_GOT_TLSGD16_LO = 496,
    BFD_RELOC_PPC_GOT_TLSGD16_HI = 497,
    BFD_RELOC_PPC_GOT_TLSGD16_HA = 498,
    BFD_RELOC_PPC_GOT_TLSLD16 = 499,
    BFD_RELOC_PPC_GOT_TLSLD16_LO = 500,
    BFD_RELOC_PPC_GOT_TLSLD16_HI = 501,
    BFD_RELOC_PPC_GOT_TLSLD16_HA = 502,
    BFD_RELOC_PPC_GOT_TPREL16 = 503,
    BFD_RELOC_PPC_GOT_TPREL16_LO = 504,
    BFD_RELOC_PPC_GOT_TPREL16_HI = 505,
    BFD_RELOC_PPC_GOT_TPREL16_HA = 506,
    BFD_RELOC_PPC_GOT_DTPREL16 = 507,
    BFD_RELOC_PPC_GOT_DTPREL16_LO = 508,
    BFD_RELOC_PPC_GOT_DTPREL16_HI = 509,
    BFD_RELOC_PPC_GOT_DTPREL16_HA = 510,
    BFD_RELOC_PPC64_TPREL16_DS = 511,
    BFD_RELOC_PPC64_TPREL16_LO_DS = 512,
    BFD_RELOC_PPC64_TPREL16_HIGHER = 513,
    BFD_RELOC_PPC64_TPREL16_HIGHERA = 514,
    BFD_RELOC_PPC64_TPREL16_HIGHEST = 515,
    BFD_RELOC_PPC64_TPREL16_HIGHESTA = 516,
    BFD_RELOC_PPC64_DTPREL16_DS = 517,
    BFD_RELOC_PPC64_DTPREL16_LO_DS = 518,
    BFD_RELOC_PPC64_DTPREL16_HIGHER = 519,
    BFD_RELOC_PPC64_DTPREL16_HIGHERA = 520,
    BFD_RELOC_PPC64_DTPREL16_HIGHEST = 521,
    BFD_RELOC_PPC64_DTPREL16_HIGHESTA = 522,
    BFD_RELOC_I370_D12 = 523,
    BFD_RELOC_CTOR = 524,
    BFD_RELOC_ARM_PCREL_BRANCH = 525,
    BFD_RELOC_ARM_PCREL_BLX = 526,
    BFD_RELOC_THUMB_PCREL_BLX = 527,
    BFD_RELOC_ARM_PCREL_CALL = 528,
    BFD_RELOC_ARM_PCREL_JUMP = 529,
    BFD_RELOC_THUMB_PCREL_BRANCH7 = 530,
    BFD_RELOC_THUMB_PCREL_BRANCH9 = 531,
    BFD_RELOC_THUMB_PCREL_BRANCH12 = 532,
    BFD_RELOC_THUMB_PCREL_BRANCH20 = 533,
    BFD_RELOC_THUMB_PCREL_BRANCH23 = 534,
    BFD_RELOC_THUMB_PCREL_BRANCH25 = 535,
    BFD_RELOC_ARM_OFFSET_IMM = 536,
    BFD_RELOC_ARM_THUMB_OFFSET = 537,
    BFD_RELOC_ARM_TARGET1 = 538,
    BFD_RELOC_ARM_ROSEGREL32 = 539,
    BFD_RELOC_ARM_SBREL32 = 540,
    BFD_RELOC_ARM_TARGET2 = 541,
    BFD_RELOC_ARM_PREL31 = 542,
    BFD_RELOC_ARM_MOVW = 543,
    BFD_RELOC_ARM_MOVT = 544,
    BFD_RELOC_ARM_MOVW_PCREL = 545,
    BFD_RELOC_ARM_MOVT_PCREL = 546,
    BFD_RELOC_ARM_THUMB_MOVW = 547,
    BFD_RELOC_ARM_THUMB_MOVT = 548,
    BFD_RELOC_ARM_THUMB_MOVW_PCREL = 549,
    BFD_RELOC_ARM_THUMB_MOVT_PCREL = 550,
    BFD_RELOC_ARM_JUMP_SLOT = 551,
    BFD_RELOC_ARM_GLOB_DAT = 552,
    BFD_RELOC_ARM_GOT32 = 553,
    BFD_RELOC_ARM_PLT32 = 554,
    BFD_RELOC_ARM_RELATIVE = 555,
    BFD_RELOC_ARM_GOTOFF = 556,
    BFD_RELOC_ARM_GOTPC = 557,
    BFD_RELOC_ARM_GOT_PREL = 558,
    BFD_RELOC_ARM_TLS_GD32 = 559,
    BFD_RELOC_ARM_TLS_LDO32 = 560,
    BFD_RELOC_ARM_TLS_LDM32 = 561,
    BFD_RELOC_ARM_TLS_DTPOFF32 = 562,
    BFD_RELOC_ARM_TLS_DTPMOD32 = 563,
    BFD_RELOC_ARM_TLS_TPOFF32 = 564,
    BFD_RELOC_ARM_TLS_IE32 = 565,
    BFD_RELOC_ARM_TLS_LE32 = 566,
    BFD_RELOC_ARM_TLS_GOTDESC = 567,
    BFD_RELOC_ARM_TLS_CALL = 568,
    BFD_RELOC_ARM_THM_TLS_CALL = 569,
    BFD_RELOC_ARM_TLS_DESCSEQ = 570,
    BFD_RELOC_ARM_THM_TLS_DESCSEQ = 571,
    BFD_RELOC_ARM_TLS_DESC = 572,
    BFD_RELOC_ARM_ALU_PC_G0_NC = 573,
    BFD_RELOC_ARM_ALU_PC_G0 = 574,
    BFD_RELOC_ARM_ALU_PC_G1_NC = 575,
    BFD_RELOC_ARM_ALU_PC_G1 = 576,
    BFD_RELOC_ARM_ALU_PC_G2 = 577,
    BFD_RELOC_ARM_LDR_PC_G0 = 578,
    BFD_RELOC_ARM_LDR_PC_G1 = 579,
    BFD_RELOC_ARM_LDR_PC_G2 = 580,
    BFD_RELOC_ARM_LDRS_PC_G0 = 581,
    BFD_RELOC_ARM_LDRS_PC_G1 = 582,
    BFD_RELOC_ARM_LDRS_PC_G2 = 583,
    BFD_RELOC_ARM_LDC_PC_G0 = 584,
    BFD_RELOC_ARM_LDC_PC_G1 = 585,
    BFD_RELOC_ARM_LDC_PC_G2 = 586,
    BFD_RELOC_ARM_ALU_SB_G0_NC = 587,
    BFD_RELOC_ARM_ALU_SB_G0 = 588,
    BFD_RELOC_ARM_ALU_SB_G1_NC = 589,
    BFD_RELOC_ARM_ALU_SB_G1 = 590,
    BFD_RELOC_ARM_ALU_SB_G2 = 591,
    BFD_RELOC_ARM_LDR_SB_G0 = 592,
    BFD_RELOC_ARM_LDR_SB_G1 = 593,
    BFD_RELOC_ARM_LDR_SB_G2 = 594,
    BFD_RELOC_ARM_LDRS_SB_G0 = 595,
    BFD_RELOC_ARM_LDRS_SB_G1 = 596,
    BFD_RELOC_ARM_LDRS_SB_G2 = 597,
    BFD_RELOC_ARM_LDC_SB_G0 = 598,
    BFD_RELOC_ARM_LDC_SB_G1 = 599,
    BFD_RELOC_ARM_LDC_SB_G2 = 600,
    BFD_RELOC_ARM_V4BX = 601,
    BFD_RELOC_ARM_IRELATIVE = 602,
    BFD_RELOC_ARM_IMMEDIATE = 603,
    BFD_RELOC_ARM_ADRL_IMMEDIATE = 604,
    BFD_RELOC_ARM_T32_IMMEDIATE = 605,
    BFD_RELOC_ARM_T32_ADD_IMM = 606,
    BFD_RELOC_ARM_T32_IMM12 = 607,
    BFD_RELOC_ARM_T32_ADD_PC12 = 608,
    BFD_RELOC_ARM_SHIFT_IMM = 609,
    BFD_RELOC_ARM_SMC = 610,
    BFD_RELOC_ARM_HVC = 611,
    BFD_RELOC_ARM_SWI = 612,
    BFD_RELOC_ARM_MULTI = 613,
    BFD_RELOC_ARM_CP_OFF_IMM = 614,
    BFD_RELOC_ARM_CP_OFF_IMM_S2 = 615,
    BFD_RELOC_ARM_T32_CP_OFF_IMM = 616,
    BFD_RELOC_ARM_T32_CP_OFF_IMM_S2 = 617,
    BFD_RELOC_ARM_ADR_IMM = 618,
    BFD_RELOC_ARM_LDR_IMM = 619,
    BFD_RELOC_ARM_LITERAL = 620,
    BFD_RELOC_ARM_IN_POOL = 621,
    BFD_RELOC_ARM_OFFSET_IMM8 = 622,
    BFD_RELOC_ARM_T32_OFFSET_U8 = 623,
    BFD_RELOC_ARM_T32_OFFSET_IMM = 624,
    BFD_RELOC_ARM_HWLITERAL = 625,
    BFD_RELOC_ARM_THUMB_ADD = 626,
    BFD_RELOC_ARM_THUMB_IMM = 627,
    BFD_RELOC_ARM_THUMB_SHIFT = 628,
    BFD_RELOC_SH_PCDISP8BY2 = 629,
    BFD_RELOC_SH_PCDISP12BY2 = 630,
    BFD_RELOC_SH_IMM3 = 631,
    BFD_RELOC_SH_IMM3U = 632,
    BFD_RELOC_SH_DISP12 = 633,
    BFD_RELOC_SH_DISP12BY2 = 634,
    BFD_RELOC_SH_DISP12BY4 = 635,
    BFD_RELOC_SH_DISP12BY8 = 636,
    BFD_RELOC_SH_DISP20 = 637,
    BFD_RELOC_SH_DISP20BY8 = 638,
    BFD_RELOC_SH_IMM4 = 639,
    BFD_RELOC_SH_IMM4BY2 = 640,
    BFD_RELOC_SH_IMM4BY4 = 641,
    BFD_RELOC_SH_IMM8 = 642,
    BFD_RELOC_SH_IMM8BY2 = 643,
    BFD_RELOC_SH_IMM8BY4 = 644,
    BFD_RELOC_SH_PCRELIMM8BY2 = 645,
    BFD_RELOC_SH_PCRELIMM8BY4 = 646,
    BFD_RELOC_SH_SWITCH16 = 647,
    BFD_RELOC_SH_SWITCH32 = 648,
    BFD_RELOC_SH_USES = 649,
    BFD_RELOC_SH_COUNT = 650,
    BFD_RELOC_SH_ALIGN = 651,
    BFD_RELOC_SH_CODE = 652,
    BFD_RELOC_SH_DATA = 653,
    BFD_RELOC_SH_LABEL = 654,
    BFD_RELOC_SH_LOOP_START = 655,
    BFD_RELOC_SH_LOOP_END = 656,
    BFD_RELOC_SH_COPY = 657,
    BFD_RELOC_SH_GLOB_DAT = 658,
    BFD_RELOC_SH_JMP_SLOT = 659,
    BFD_RELOC_SH_RELATIVE = 660,
    BFD_RELOC_SH_GOTPC = 661,
    BFD_RELOC_SH_GOT_LOW16 = 662,
    BFD_RELOC_SH_GOT_MEDLOW16 = 663,
    BFD_RELOC_SH_GOT_MEDHI16 = 664,
    BFD_RELOC_SH_GOT_HI16 = 665,
    BFD_RELOC_SH_GOTPLT_LOW16 = 666,
    BFD_RELOC_SH_GOTPLT_MEDLOW16 = 667,
    BFD_RELOC_SH_GOTPLT_MEDHI16 = 668,
    BFD_RELOC_SH_GOTPLT_HI16 = 669,
    BFD_RELOC_SH_PLT_LOW16 = 670,
    BFD_RELOC_SH_PLT_MEDLOW16 = 671,
    BFD_RELOC_SH_PLT_MEDHI16 = 672,
    BFD_RELOC_SH_PLT_HI16 = 673,
    BFD_RELOC_SH_GOTOFF_LOW16 = 674,
    BFD_RELOC_SH_GOTOFF_MEDLOW16 = 675,
    BFD_RELOC_SH_GOTOFF_MEDHI16 = 676,
    BFD_RELOC_SH_GOTOFF_HI16 = 677,
    BFD_RELOC_SH_GOTPC_LOW16 = 678,
    BFD_RELOC_SH_GOTPC_MEDLOW16 = 679,
    BFD_RELOC_SH_GOTPC_MEDHI16 = 680,
    BFD_RELOC_SH_GOTPC_HI16 = 681,
    BFD_RELOC_SH_COPY64 = 682,
    BFD_RELOC_SH_GLOB_DAT64 = 683,
    BFD_RELOC_SH_JMP_SLOT64 = 684,
    BFD_RELOC_SH_RELATIVE64 = 685,
    BFD_RELOC_SH_GOT10BY4 = 686,
    BFD_RELOC_SH_GOT10BY8 = 687,
    BFD_RELOC_SH_GOTPLT10BY4 = 688,
    BFD_RELOC_SH_GOTPLT10BY8 = 689,
    BFD_RELOC_SH_GOTPLT32 = 690,
    BFD_RELOC_SH_SHMEDIA_CODE = 691,
    BFD_RELOC_SH_IMMU5 = 692,
    BFD_RELOC_SH_IMMS6 = 693,
    BFD_RELOC_SH_IMMS6BY32 = 694,
    BFD_RELOC_SH_IMMU6 = 695,
    BFD_RELOC_SH_IMMS10 = 696,
    BFD_RELOC_SH_IMMS10BY2 = 697,
    BFD_RELOC_SH_IMMS10BY4 = 698,
    BFD_RELOC_SH_IMMS10BY8 = 699,
    BFD_RELOC_SH_IMMS16 = 700,
    BFD_RELOC_SH_IMMU16 = 701,
    BFD_RELOC_SH_IMM_LOW16 = 702,
    BFD_RELOC_SH_IMM_LOW16_PCREL = 703,
    BFD_RELOC_SH_IMM_MEDLOW16 = 704,
    BFD_RELOC_SH_IMM_MEDLOW16_PCREL = 705,
    BFD_RELOC_SH_IMM_MEDHI16 = 706,
    BFD_RELOC_SH_IMM_MEDHI16_PCREL = 707,
    BFD_RELOC_SH_IMM_HI16 = 708,
    BFD_RELOC_SH_IMM_HI16_PCREL = 709,
    BFD_RELOC_SH_PT_16 = 710,
    BFD_RELOC_SH_TLS_GD_32 = 711,
    BFD_RELOC_SH_TLS_LD_32 = 712,
    BFD_RELOC_SH_TLS_LDO_32 = 713,
    BFD_RELOC_SH_TLS_IE_32 = 714,
    BFD_RELOC_SH_TLS_LE_32 = 715,
    BFD_RELOC_SH_TLS_DTPMOD32 = 716,
    BFD_RELOC_SH_TLS_DTPOFF32 = 717,
    BFD_RELOC_SH_TLS_TPOFF32 = 718,
    BFD_RELOC_SH_GOT20 = 719,
    BFD_RELOC_SH_GOTOFF20 = 720,
    BFD_RELOC_SH_GOTFUNCDESC = 721,
    BFD_RELOC_SH_GOTFUNCDESC20 = 722,
    BFD_RELOC_SH_GOTOFFFUNCDESC = 723,
    BFD_RELOC_SH_GOTOFFFUNCDESC20 = 724,
    BFD_RELOC_SH_FUNCDESC = 725,
    BFD_RELOC_ARC_B22_PCREL = 726,
    BFD_RELOC_ARC_B26 = 727,
    BFD_RELOC_BFIN_16_IMM = 728,
    BFD_RELOC_BFIN_16_HIGH = 729,
    BFD_RELOC_BFIN_4_PCREL = 730,
    BFD_RELOC_BFIN_5_PCREL = 731,
    BFD_RELOC_BFIN_16_LOW = 732,
    BFD_RELOC_BFIN_10_PCREL = 733,
    BFD_RELOC_BFIN_11_PCREL = 734,
    BFD_RELOC_BFIN_12_PCREL_JUMP = 735,
    BFD_RELOC_BFIN_12_PCREL_JUMP_S = 736,
    BFD_RELOC_BFIN_24_PCREL_CALL_X = 737,
    BFD_RELOC_BFIN_24_PCREL_JUMP_L = 738,
    BFD_RELOC_BFIN_GOT17M4 = 739,
    BFD_RELOC_BFIN_GOTHI = 740,
    BFD_RELOC_BFIN_GOTLO = 741,
    BFD_RELOC_BFIN_FUNCDESC = 742,
    BFD_RELOC_BFIN_FUNCDESC_GOT17M4 = 743,
    BFD_RELOC_BFIN_FUNCDESC_GOTHI = 744,
    BFD_RELOC_BFIN_FUNCDESC_GOTLO = 745,
    BFD_RELOC_BFIN_FUNCDESC_VALUE = 746,
    BFD_RELOC_BFIN_FUNCDESC_GOTOFF17M4 = 747,
    BFD_RELOC_BFIN_FUNCDESC_GOTOFFHI = 748,
    BFD_RELOC_BFIN_FUNCDESC_GOTOFFLO = 749,
    BFD_RELOC_BFIN_GOTOFF17M4 = 750,
    BFD_RELOC_BFIN_GOTOFFHI = 751,
    BFD_RELOC_BFIN_GOTOFFLO = 752,
    BFD_RELOC_BFIN_GOT = 753,
    BFD_RELOC_BFIN_PLTPC = 754,
    BFD_ARELOC_BFIN_PUSH = 755,
    BFD_ARELOC_BFIN_CONST = 756,
    BFD_ARELOC_BFIN_ADD = 757,
    BFD_ARELOC_BFIN_SUB = 758,
    BFD_ARELOC_BFIN_MULT = 759,
    BFD_ARELOC_BFIN_DIV = 760,
    BFD_ARELOC_BFIN_MOD = 761,
    BFD_ARELOC_BFIN_LSHIFT = 762,
    BFD_ARELOC_BFIN_RSHIFT = 763,
    BFD_ARELOC_BFIN_AND = 764,
    BFD_ARELOC_BFIN_OR = 765,
    BFD_ARELOC_BFIN_XOR = 766,
    BFD_ARELOC_BFIN_LAND = 767,
    BFD_ARELOC_BFIN_LOR = 768,
    BFD_ARELOC_BFIN_LEN = 769,
    BFD_ARELOC_BFIN_NEG = 770,
    BFD_ARELOC_BFIN_COMP = 771,
    BFD_ARELOC_BFIN_PAGE = 772,
    BFD_ARELOC_BFIN_HWPAGE = 773,
    BFD_ARELOC_BFIN_ADDR = 774,
    BFD_RELOC_D10V_10_PCREL_R = 775,
    BFD_RELOC_D10V_10_PCREL_L = 776,
    BFD_RELOC_D10V_18 = 777,
    BFD_RELOC_D10V_18_PCREL = 778,
    BFD_RELOC_D30V_6 = 779,
    BFD_RELOC_D30V_9_PCREL = 780,
    BFD_RELOC_D30V_9_PCREL_R = 781,
    BFD_RELOC_D30V_15 = 782,
    BFD_RELOC_D30V_15_PCREL = 783,
    BFD_RELOC_D30V_15_PCREL_R = 784,
    BFD_RELOC_D30V_21 = 785,
    BFD_RELOC_D30V_21_PCREL = 786,
    BFD_RELOC_D30V_21_PCREL_R = 787,
    BFD_RELOC_D30V_32 = 788,
    BFD_RELOC_D30V_32_PCREL = 789,
    BFD_RELOC_DLX_HI16_S = 790,
    BFD_RELOC_DLX_LO16 = 791,
    BFD_RELOC_DLX_JMP26 = 792,
    BFD_RELOC_M32C_HI8 = 793,
    BFD_RELOC_M32C_RL_JUMP = 794,
    BFD_RELOC_M32C_RL_1ADDR = 795,
    BFD_RELOC_M32C_RL_2ADDR = 796,
    BFD_RELOC_M32R_24 = 797,
    BFD_RELOC_M32R_10_PCREL = 798,
    BFD_RELOC_M32R_18_PCREL = 799,
    BFD_RELOC_M32R_26_PCREL = 800,
    BFD_RELOC_M32R_HI16_ULO = 801,
    BFD_RELOC_M32R_HI16_SLO = 802,
    BFD_RELOC_M32R_LO16 = 803,
    BFD_RELOC_M32R_SDA16 = 804,
    BFD_RELOC_M32R_GOT24 = 805,
    BFD_RELOC_M32R_26_PLTREL = 806,
    BFD_RELOC_M32R_COPY = 807,
    BFD_RELOC_M32R_GLOB_DAT = 808,
    BFD_RELOC_M32R_JMP_SLOT = 809,
    BFD_RELOC_M32R_RELATIVE = 810,
    BFD_RELOC_M32R_GOTOFF = 811,
    BFD_RELOC_M32R_GOTOFF_HI_ULO = 812,
    BFD_RELOC_M32R_GOTOFF_HI_SLO = 813,
    BFD_RELOC_M32R_GOTOFF_LO = 814,
    BFD_RELOC_M32R_GOTPC24 = 815,
    BFD_RELOC_M32R_GOT16_HI_ULO = 816,
    BFD_RELOC_M32R_GOT16_HI_SLO = 817,
    BFD_RELOC_M32R_GOT16_LO = 818,
    BFD_RELOC_M32R_GOTPC_HI_ULO = 819,
    BFD_RELOC_M32R_GOTPC_HI_SLO = 820,
    BFD_RELOC_M32R_GOTPC_LO = 821,
    BFD_RELOC_V850_9_PCREL = 822,
    BFD_RELOC_V850_22_PCREL = 823,
    BFD_RELOC_V850_SDA_16_16_OFFSET = 824,
    BFD_RELOC_V850_SDA_15_16_OFFSET = 825,
    BFD_RELOC_V850_ZDA_16_16_OFFSET = 826,
    BFD_RELOC_V850_ZDA_15_16_OFFSET = 827,
    BFD_RELOC_V850_TDA_6_8_OFFSET = 828,
    BFD_RELOC_V850_TDA_7_8_OFFSET = 829,
    BFD_RELOC_V850_TDA_7_7_OFFSET = 830,
    BFD_RELOC_V850_TDA_16_16_OFFSET = 831,
    BFD_RELOC_V850_TDA_4_5_OFFSET = 832,
    BFD_RELOC_V850_TDA_4_4_OFFSET = 833,
    BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET = 834,
    BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET = 835,
    BFD_RELOC_V850_CALLT_6_7_OFFSET = 836,
    BFD_RELOC_V850_CALLT_16_16_OFFSET = 837,
    BFD_RELOC_V850_LONGCALL = 838,
    BFD_RELOC_V850_LONGJUMP = 839,
    BFD_RELOC_V850_ALIGN = 840,
    BFD_RELOC_V850_LO16_SPLIT_OFFSET = 841,
    BFD_RELOC_V850_16_PCREL = 842,
    BFD_RELOC_V850_17_PCREL = 843,
    BFD_RELOC_V850_23 = 844,
    BFD_RELOC_V850_32_PCREL = 845,
    BFD_RELOC_V850_32_ABS = 846,
    BFD_RELOC_V850_16_SPLIT_OFFSET = 847,
    BFD_RELOC_V850_16_S1 = 848,
    BFD_RELOC_V850_LO16_S1 = 849,
    BFD_RELOC_V850_CALLT_15_16_OFFSET = 850,
    BFD_RELOC_V850_32_GOTPCREL = 851,
    BFD_RELOC_V850_16_GOT = 852,
    BFD_RELOC_V850_32_GOT = 853,
    BFD_RELOC_V850_22_PLT_PCREL = 854,
    BFD_RELOC_V850_32_PLT_PCREL = 855,
    BFD_RELOC_V850_COPY = 856,
    BFD_RELOC_V850_GLOB_DAT = 857,
    BFD_RELOC_V850_JMP_SLOT = 858,
    BFD_RELOC_V850_RELATIVE = 859,
    BFD_RELOC_V850_16_GOTOFF = 860,
    BFD_RELOC_V850_32_GOTOFF = 861,
    BFD_RELOC_V850_CODE = 862,
    BFD_RELOC_V850_DATA = 863,
    BFD_RELOC_TIC30_LDP = 864,
    BFD_RELOC_TIC54X_PARTLS7 = 865,
    BFD_RELOC_TIC54X_PARTMS9 = 866,
    BFD_RELOC_TIC54X_23 = 867,
    BFD_RELOC_TIC54X_16_OF_23 = 868,
    BFD_RELOC_TIC54X_MS7_OF_23 = 869,
    BFD_RELOC_C6000_PCR_S21 = 870,
    BFD_RELOC_C6000_PCR_S12 = 871,
    BFD_RELOC_C6000_PCR_S10 = 872,
    BFD_RELOC_C6000_PCR_S7 = 873,
    BFD_RELOC_C6000_ABS_S16 = 874,
    BFD_RELOC_C6000_ABS_L16 = 875,
    BFD_RELOC_C6000_ABS_H16 = 876,
    BFD_RELOC_C6000_SBR_U15_B = 877,
    BFD_RELOC_C6000_SBR_U15_H = 878,
    BFD_RELOC_C6000_SBR_U15_W = 879,
    BFD_RELOC_C6000_SBR_S16 = 880,
    BFD_RELOC_C6000_SBR_L16_B = 881,
    BFD_RELOC_C6000_SBR_L16_H = 882,
    BFD_RELOC_C6000_SBR_L16_W = 883,
    BFD_RELOC_C6000_SBR_H16_B = 884,
    BFD_RELOC_C6000_SBR_H16_H = 885,
    BFD_RELOC_C6000_SBR_H16_W = 886,
    BFD_RELOC_C6000_SBR_GOT_U15_W = 887,
    BFD_RELOC_C6000_SBR_GOT_L16_W = 888,
    BFD_RELOC_C6000_SBR_GOT_H16_W = 889,
    BFD_RELOC_C6000_DSBT_INDEX = 890,
    BFD_RELOC_C6000_PREL31 = 891,
    BFD_RELOC_C6000_COPY = 892,
    BFD_RELOC_C6000_JUMP_SLOT = 893,
    BFD_RELOC_C6000_EHTYPE = 894,
    BFD_RELOC_C6000_PCR_H16 = 895,
    BFD_RELOC_C6000_PCR_L16 = 896,
    BFD_RELOC_C6000_ALIGN = 897,
    BFD_RELOC_C6000_FPHEAD = 898,
    BFD_RELOC_C6000_NOCMP = 899,
    BFD_RELOC_FR30_48 = 900,
    BFD_RELOC_FR30_20 = 901,
    BFD_RELOC_FR30_6_IN_4 = 902,
    BFD_RELOC_FR30_8_IN_8 = 903,
    BFD_RELOC_FR30_9_IN_8 = 904,
    BFD_RELOC_FR30_10_IN_8 = 905,
    BFD_RELOC_FR30_9_PCREL = 906,
    BFD_RELOC_FR30_12_PCREL = 907,
    BFD_RELOC_MCORE_PCREL_IMM8BY4 = 908,
    BFD_RELOC_MCORE_PCREL_IMM11BY2 = 909,
    BFD_RELOC_MCORE_PCREL_IMM4BY2 = 910,
    BFD_RELOC_MCORE_PCREL_32 = 911,
    BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2 = 912,
    BFD_RELOC_MCORE_RVA = 913,
    BFD_RELOC_MEP_8 = 914,
    BFD_RELOC_MEP_16 = 915,
    BFD_RELOC_MEP_32 = 916,
    BFD_RELOC_MEP_PCREL8A2 = 917,
    BFD_RELOC_MEP_PCREL12A2 = 918,
    BFD_RELOC_MEP_PCREL17A2 = 919,
    BFD_RELOC_MEP_PCREL24A2 = 920,
    BFD_RELOC_MEP_PCABS24A2 = 921,
    BFD_RELOC_MEP_LOW16 = 922,
    BFD_RELOC_MEP_HI16U = 923,
    BFD_RELOC_MEP_HI16S = 924,
    BFD_RELOC_MEP_GPREL = 925,
    BFD_RELOC_MEP_TPREL = 926,
    BFD_RELOC_MEP_TPREL7 = 927,
    BFD_RELOC_MEP_TPREL7A2 = 928,
    BFD_RELOC_MEP_TPREL7A4 = 929,
    BFD_RELOC_MEP_UIMM24 = 930,
    BFD_RELOC_MEP_ADDR24A4 = 931,
    BFD_RELOC_MEP_GNU_VTINHERIT = 932,
    BFD_RELOC_MEP_GNU_VTENTRY = 933,
    BFD_RELOC_MMIX_GETA = 934,
    BFD_RELOC_MMIX_GETA_1 = 935,
    BFD_RELOC_MMIX_GETA_2 = 936,
    BFD_RELOC_MMIX_GETA_3 = 937,
    BFD_RELOC_MMIX_CBRANCH = 938,
    BFD_RELOC_MMIX_CBRANCH_J = 939,
    BFD_RELOC_MMIX_CBRANCH_1 = 940,
    BFD_RELOC_MMIX_CBRANCH_2 = 941,
    BFD_RELOC_MMIX_CBRANCH_3 = 942,
    BFD_RELOC_MMIX_PUSHJ = 943,
    BFD_RELOC_MMIX_PUSHJ_1 = 944,
    BFD_RELOC_MMIX_PUSHJ_2 = 945,
    BFD_RELOC_MMIX_PUSHJ_3 = 946,
    BFD_RELOC_MMIX_PUSHJ_STUBBABLE = 947,
    BFD_RELOC_MMIX_JMP = 948,
    BFD_RELOC_MMIX_JMP_1 = 949,
    BFD_RELOC_MMIX_JMP_2 = 950,
    BFD_RELOC_MMIX_JMP_3 = 951,
    BFD_RELOC_MMIX_ADDR19 = 952,
    BFD_RELOC_MMIX_ADDR27 = 953,
    BFD_RELOC_MMIX_REG_OR_BYTE = 954,
    BFD_RELOC_MMIX_REG = 955,
    BFD_RELOC_MMIX_BASE_PLUS_OFFSET = 956,
    BFD_RELOC_MMIX_LOCAL = 957,
    BFD_RELOC_AVR_7_PCREL = 958,
    BFD_RELOC_AVR_13_PCREL = 959,
    BFD_RELOC_AVR_16_PM = 960,
    BFD_RELOC_AVR_LO8_LDI = 961,
    BFD_RELOC_AVR_HI8_LDI = 962,
    BFD_RELOC_AVR_HH8_LDI = 963,
    BFD_RELOC_AVR_MS8_LDI = 964,
    BFD_RELOC_AVR_LO8_LDI_NEG = 965,
    BFD_RELOC_AVR_HI8_LDI_NEG = 966,
    BFD_RELOC_AVR_HH8_LDI_NEG = 967,
    BFD_RELOC_AVR_MS8_LDI_NEG = 968,
    BFD_RELOC_AVR_LO8_LDI_PM = 969,
    BFD_RELOC_AVR_LO8_LDI_GS = 970,
    BFD_RELOC_AVR_HI8_LDI_PM = 971,
    BFD_RELOC_AVR_HI8_LDI_GS = 972,
    BFD_RELOC_AVR_HH8_LDI_PM = 973,
    BFD_RELOC_AVR_LO8_LDI_PM_NEG = 974,
    BFD_RELOC_AVR_HI8_LDI_PM_NEG = 975,
    BFD_RELOC_AVR_HH8_LDI_PM_NEG = 976,
    BFD_RELOC_AVR_CALL = 977,
    BFD_RELOC_AVR_LDI = 978,
    BFD_RELOC_AVR_6 = 979,
    BFD_RELOC_AVR_6_ADIW = 980,
    BFD_RELOC_AVR_8_LO = 981,
    BFD_RELOC_AVR_8_HI = 982,
    BFD_RELOC_AVR_8_HLO = 983,
    BFD_RELOC_RL78_NEG8 = 984,
    BFD_RELOC_RL78_NEG16 = 985,
    BFD_RELOC_RL78_NEG24 = 986,
    BFD_RELOC_RL78_NEG32 = 987,
    BFD_RELOC_RL78_16_OP = 988,
    BFD_RELOC_RL78_24_OP = 989,
    BFD_RELOC_RL78_32_OP = 990,
    BFD_RELOC_RL78_8U = 991,
    BFD_RELOC_RL78_16U = 992,
    BFD_RELOC_RL78_24U = 993,
    BFD_RELOC_RL78_DIR3U_PCREL = 994,
    BFD_RELOC_RL78_DIFF = 995,
    BFD_RELOC_RL78_GPRELB = 996,
    BFD_RELOC_RL78_GPRELW = 997,
    BFD_RELOC_RL78_GPRELL = 998,
    BFD_RELOC_RL78_SYM = 999,
    BFD_RELOC_RL78_OP_SUBTRACT = 1000,
    BFD_RELOC_RL78_OP_NEG = 1001,
    BFD_RELOC_RL78_OP_AND = 1002,
    BFD_RELOC_RL78_OP_SHRA = 1003,
    BFD_RELOC_RL78_ABS8 = 1004,
    BFD_RELOC_RL78_ABS16 = 1005,
    BFD_RELOC_RL78_ABS16_REV = 1006,
    BFD_RELOC_RL78_ABS32 = 1007,
    BFD_RELOC_RL78_ABS32_REV = 1008,
    BFD_RELOC_RL78_ABS16U = 1009,
    BFD_RELOC_RL78_ABS16UW = 1010,
    BFD_RELOC_RL78_ABS16UL = 1011,
    BFD_RELOC_RL78_RELAX = 1012,
    BFD_RELOC_RL78_HI16 = 1013,
    BFD_RELOC_RL78_HI8 = 1014,
    BFD_RELOC_RL78_LO16 = 1015,
    BFD_RELOC_RX_NEG8 = 1016,
    BFD_RELOC_RX_NEG16 = 1017,
    BFD_RELOC_RX_NEG24 = 1018,
    BFD_RELOC_RX_NEG32 = 1019,
    BFD_RELOC_RX_16_OP = 1020,
    BFD_RELOC_RX_24_OP = 1021,
    BFD_RELOC_RX_32_OP = 1022,
    BFD_RELOC_RX_8U = 1023,
    BFD_RELOC_RX_16U = 1024,
    BFD_RELOC_RX_24U = 1025,
    BFD_RELOC_RX_DIR3U_PCREL = 1026,
    BFD_RELOC_RX_DIFF = 1027,
    BFD_RELOC_RX_GPRELB = 1028,
    BFD_RELOC_RX_GPRELW = 1029,
    BFD_RELOC_RX_GPRELL = 1030,
    BFD_RELOC_RX_SYM = 1031,
    BFD_RELOC_RX_OP_SUBTRACT = 1032,
    BFD_RELOC_RX_OP_NEG = 1033,
    BFD_RELOC_RX_ABS8 = 1034,
    BFD_RELOC_RX_ABS16 = 1035,
    BFD_RELOC_RX_ABS16_REV = 1036,
    BFD_RELOC_RX_ABS32 = 1037,
    BFD_RELOC_RX_ABS32_REV = 1038,
    BFD_RELOC_RX_ABS16U = 1039,
    BFD_RELOC_RX_ABS16UW = 1040,
    BFD_RELOC_RX_ABS16UL = 1041,
    BFD_RELOC_RX_RELAX = 1042,
    BFD_RELOC_390_12 = 1043,
    BFD_RELOC_390_GOT12 = 1044,
    BFD_RELOC_390_PLT32 = 1045,
    BFD_RELOC_390_COPY = 1046,
    BFD_RELOC_390_GLOB_DAT = 1047,
    BFD_RELOC_390_JMP_SLOT = 1048,
    BFD_RELOC_390_RELATIVE = 1049,
    BFD_RELOC_390_GOTPC = 1050,
    BFD_RELOC_390_GOT16 = 1051,
    BFD_RELOC_390_PC16DBL = 1052,
    BFD_RELOC_390_PLT16DBL = 1053,
    BFD_RELOC_390_PC32DBL = 1054,
    BFD_RELOC_390_PLT32DBL = 1055,
    BFD_RELOC_390_GOTPCDBL = 1056,
    BFD_RELOC_390_GOT64 = 1057,
    BFD_RELOC_390_PLT64 = 1058,
    BFD_RELOC_390_GOTENT = 1059,
    BFD_RELOC_390_GOTOFF64 = 1060,
    BFD_RELOC_390_GOTPLT12 = 1061,
    BFD_RELOC_390_GOTPLT16 = 1062,
    BFD_RELOC_390_GOTPLT32 = 1063,
    BFD_RELOC_390_GOTPLT64 = 1064,
    BFD_RELOC_390_GOTPLTENT = 1065,
    BFD_RELOC_390_PLTOFF16 = 1066,
    BFD_RELOC_390_PLTOFF32 = 1067,
    BFD_RELOC_390_PLTOFF64 = 1068,
    BFD_RELOC_390_TLS_LOAD = 1069,
    BFD_RELOC_390_TLS_GDCALL = 1070,
    BFD_RELOC_390_TLS_LDCALL = 1071,
    BFD_RELOC_390_TLS_GD32 = 1072,
    BFD_RELOC_390_TLS_GD64 = 1073,
    BFD_RELOC_390_TLS_GOTIE12 = 1074,
    BFD_RELOC_390_TLS_GOTIE32 = 1075,
    BFD_RELOC_390_TLS_GOTIE64 = 1076,
    BFD_RELOC_390_TLS_LDM32 = 1077,
    BFD_RELOC_390_TLS_LDM64 = 1078,
    BFD_RELOC_390_TLS_IE32 = 1079,
    BFD_RELOC_390_TLS_IE64 = 1080,
    BFD_RELOC_390_TLS_IEENT = 1081,
    BFD_RELOC_390_TLS_LE32 = 1082,
    BFD_RELOC_390_TLS_LE64 = 1083,
    BFD_RELOC_390_TLS_LDO32 = 1084,
    BFD_RELOC_390_TLS_LDO64 = 1085,
    BFD_RELOC_390_TLS_DTPMOD = 1086,
    BFD_RELOC_390_TLS_DTPOFF = 1087,
    BFD_RELOC_390_TLS_TPOFF = 1088,
    BFD_RELOC_390_20 = 1089,
    BFD_RELOC_390_GOT20 = 1090,
    BFD_RELOC_390_GOTPLT20 = 1091,
    BFD_RELOC_390_TLS_GOTIE20 = 1092,
    BFD_RELOC_390_IRELATIVE = 1093,
    BFD_RELOC_SCORE_GPREL15 = 1094,
    BFD_RELOC_SCORE_DUMMY2 = 1095,
    BFD_RELOC_SCORE_JMP = 1096,
    BFD_RELOC_SCORE_BRANCH = 1097,
    BFD_RELOC_SCORE_IMM30 = 1098,
    BFD_RELOC_SCORE_IMM32 = 1099,
    BFD_RELOC_SCORE16_JMP = 1100,
    BFD_RELOC_SCORE16_BRANCH = 1101,
    BFD_RELOC_SCORE_BCMP = 1102,
    BFD_RELOC_SCORE_GOT15 = 1103,
    BFD_RELOC_SCORE_GOT_LO16 = 1104,
    BFD_RELOC_SCORE_CALL15 = 1105,
    BFD_RELOC_SCORE_DUMMY_HI16 = 1106,
    BFD_RELOC_IP2K_FR9 = 1107,
    BFD_RELOC_IP2K_BANK = 1108,
    BFD_RELOC_IP2K_ADDR16CJP = 1109,
    BFD_RELOC_IP2K_PAGE3 = 1110,
    BFD_RELOC_IP2K_LO8DATA = 1111,
    BFD_RELOC_IP2K_HI8DATA = 1112,
    BFD_RELOC_IP2K_EX8DATA = 1113,
    BFD_RELOC_IP2K_LO8INSN = 1114,
    BFD_RELOC_IP2K_HI8INSN = 1115,
    BFD_RELOC_IP2K_PC_SKIP = 1116,
    BFD_RELOC_IP2K_TEXT = 1117,
    BFD_RELOC_IP2K_FR_OFFSET = 1118,
    BFD_RELOC_VPE4KMATH_DATA = 1119,
    BFD_RELOC_VPE4KMATH_INSN = 1120,
    BFD_RELOC_VTABLE_INHERIT = 1121,
    BFD_RELOC_VTABLE_ENTRY = 1122,
    BFD_RELOC_IA64_IMM14 = 1123,
    BFD_RELOC_IA64_IMM22 = 1124,
    BFD_RELOC_IA64_IMM64 = 1125,
    BFD_RELOC_IA64_DIR32MSB = 1126,
    BFD_RELOC_IA64_DIR32LSB = 1127,
    BFD_RELOC_IA64_DIR64MSB = 1128,
    BFD_RELOC_IA64_DIR64LSB = 1129,
    BFD_RELOC_IA64_GPREL22 = 1130,
    BFD_RELOC_IA64_GPREL64I = 1131,
    BFD_RELOC_IA64_GPREL32MSB = 1132,
    BFD_RELOC_IA64_GPREL32LSB = 1133,
    BFD_RELOC_IA64_GPREL64MSB = 1134,
    BFD_RELOC_IA64_GPREL64LSB = 1135,
    BFD_RELOC_IA64_LTOFF22 = 1136,
    BFD_RELOC_IA64_LTOFF64I = 1137,
    BFD_RELOC_IA64_PLTOFF22 = 1138,
    BFD_RELOC_IA64_PLTOFF64I = 1139,
    BFD_RELOC_IA64_PLTOFF64MSB = 1140,
    BFD_RELOC_IA64_PLTOFF64LSB = 1141,
    BFD_RELOC_IA64_FPTR64I = 1142,
    BFD_RELOC_IA64_FPTR32MSB = 1143,
    BFD_RELOC_IA64_FPTR32LSB = 1144,
    BFD_RELOC_IA64_FPTR64MSB = 1145,
    BFD_RELOC_IA64_FPTR64LSB = 1146,
    BFD_RELOC_IA64_PCREL21B = 1147,
    BFD_RELOC_IA64_PCREL21BI = 1148,
    BFD_RELOC_IA64_PCREL21M = 1149,
    BFD_RELOC_IA64_PCREL21F = 1150,
    BFD_RELOC_IA64_PCREL22 = 1151,
    BFD_RELOC_IA64_PCREL60B = 1152,
    BFD_RELOC_IA64_PCREL64I = 1153,
    BFD_RELOC_IA64_PCREL32MSB = 1154,
    BFD_RELOC_IA64_PCREL32LSB = 1155,
    BFD_RELOC_IA64_PCREL64MSB = 1156,
    BFD_RELOC_IA64_PCREL64LSB = 1157,
    BFD_RELOC_IA64_LTOFF_FPTR22 = 1158,
    BFD_RELOC_IA64_LTOFF_FPTR64I = 1159,
    BFD_RELOC_IA64_LTOFF_FPTR32MSB = 1160,
    BFD_RELOC_IA64_LTOFF_FPTR32LSB = 1161,
    BFD_RELOC_IA64_LTOFF_FPTR64MSB = 1162,
    BFD_RELOC_IA64_LTOFF_FPTR64LSB = 1163,
    BFD_RELOC_IA64_SEGREL32MSB = 1164,
    BFD_RELOC_IA64_SEGREL32LSB = 1165,
    BFD_RELOC_IA64_SEGREL64MSB = 1166,
    BFD_RELOC_IA64_SEGREL64LSB = 1167,
    BFD_RELOC_IA64_SECREL32MSB = 1168,
    BFD_RELOC_IA64_SECREL32LSB = 1169,
    BFD_RELOC_IA64_SECREL64MSB = 1170,
    BFD_RELOC_IA64_SECREL64LSB = 1171,
    BFD_RELOC_IA64_REL32MSB = 1172,
    BFD_RELOC_IA64_REL32LSB = 1173,
    BFD_RELOC_IA64_REL64MSB = 1174,
    BFD_RELOC_IA64_REL64LSB = 1175,
    BFD_RELOC_IA64_LTV32MSB = 1176,
    BFD_RELOC_IA64_LTV32LSB = 1177,
    BFD_RELOC_IA64_LTV64MSB = 1178,
    BFD_RELOC_IA64_LTV64LSB = 1179,
    BFD_RELOC_IA64_IPLTMSB = 1180,
    BFD_RELOC_IA64_IPLTLSB = 1181,
    BFD_RELOC_IA64_COPY = 1182,
    BFD_RELOC_IA64_LTOFF22X = 1183,
    BFD_RELOC_IA64_LDXMOV = 1184,
    BFD_RELOC_IA64_TPREL14 = 1185,
    BFD_RELOC_IA64_TPREL22 = 1186,
    BFD_RELOC_IA64_TPREL64I = 1187,
    BFD_RELOC_IA64_TPREL64MSB = 1188,
    BFD_RELOC_IA64_TPREL64LSB = 1189,
    BFD_RELOC_IA64_LTOFF_TPREL22 = 1190,
    BFD_RELOC_IA64_DTPMOD64MSB = 1191,
    BFD_RELOC_IA64_DTPMOD64LSB = 1192,
    BFD_RELOC_IA64_LTOFF_DTPMOD22 = 1193,
    BFD_RELOC_IA64_DTPREL14 = 1194,
    BFD_RELOC_IA64_DTPREL22 = 1195,
    BFD_RELOC_IA64_DTPREL64I = 1196,
    BFD_RELOC_IA64_DTPREL32MSB = 1197,
    BFD_RELOC_IA64_DTPREL32LSB = 1198,
    BFD_RELOC_IA64_DTPREL64MSB = 1199,
    BFD_RELOC_IA64_DTPREL64LSB = 1200,
    BFD_RELOC_IA64_LTOFF_DTPREL22 = 1201,
    BFD_RELOC_M68HC11_HI8 = 1202,
    BFD_RELOC_M68HC11_LO8 = 1203,
    BFD_RELOC_M68HC11_3B = 1204,
    BFD_RELOC_M68HC11_RL_JUMP = 1205,
    BFD_RELOC_M68HC11_RL_GROUP = 1206,
    BFD_RELOC_M68HC11_LO16 = 1207,
    BFD_RELOC_M68HC11_PAGE = 1208,
    BFD_RELOC_M68HC11_24 = 1209,
    BFD_RELOC_M68HC12_5B = 1210,
    BFD_RELOC_XGATE_RL_JUMP = 1211,
    BFD_RELOC_XGATE_RL_GROUP = 1212,
    BFD_RELOC_XGATE_LO16 = 1213,
    BFD_RELOC_XGATE_GPAGE = 1214,
    BFD_RELOC_XGATE_24 = 1215,
    BFD_RELOC_XGATE_PCREL_9 = 1216,
    BFD_RELOC_XGATE_PCREL_10 = 1217,
    BFD_RELOC_XGATE_IMM8_LO = 1218,
    BFD_RELOC_XGATE_IMM8_HI = 1219,
    BFD_RELOC_XGATE_IMM3 = 1220,
    BFD_RELOC_XGATE_IMM4 = 1221,
    BFD_RELOC_XGATE_IMM5 = 1222,
    BFD_RELOC_M68HC12_9B = 1223,
    BFD_RELOC_M68HC12_16B = 1224,
    BFD_RELOC_M68HC12_9_PCREL = 1225,
    BFD_RELOC_M68HC12_10_PCREL = 1226,
    BFD_RELOC_M68HC12_LO8XG = 1227,
    BFD_RELOC_M68HC12_HI8XG = 1228,
    BFD_RELOC_16C_NUM08 = 1229,
    BFD_RELOC_16C_NUM08_C = 1230,
    BFD_RELOC_16C_NUM16 = 1231,
    BFD_RELOC_16C_NUM16_C = 1232,
    BFD_RELOC_16C_NUM32 = 1233,
    BFD_RELOC_16C_NUM32_C = 1234,
    BFD_RELOC_16C_DISP04 = 1235,
    BFD_RELOC_16C_DISP04_C = 1236,
    BFD_RELOC_16C_DISP08 = 1237,
    BFD_RELOC_16C_DISP08_C = 1238,
    BFD_RELOC_16C_DISP16 = 1239,
    BFD_RELOC_16C_DISP16_C = 1240,
    BFD_RELOC_16C_DISP24 = 1241,
    BFD_RELOC_16C_DISP24_C = 1242,
    BFD_RELOC_16C_DISP24a = 1243,
    BFD_RELOC_16C_DISP24a_C = 1244,
    BFD_RELOC_16C_REG04 = 1245,
    BFD_RELOC_16C_REG04_C = 1246,
    BFD_RELOC_16C_REG04a = 1247,
    BFD_RELOC_16C_REG04a_C = 1248,
    BFD_RELOC_16C_REG14 = 1249,
    BFD_RELOC_16C_REG14_C = 1250,
    BFD_RELOC_16C_REG16 = 1251,
    BFD_RELOC_16C_REG16_C = 1252,
    BFD_RELOC_16C_REG20 = 1253,
    BFD_RELOC_16C_REG20_C = 1254,
    BFD_RELOC_16C_ABS20 = 1255,
    BFD_RELOC_16C_ABS20_C = 1256,
    BFD_RELOC_16C_ABS24 = 1257,
    BFD_RELOC_16C_ABS24_C = 1258,
    BFD_RELOC_16C_IMM04 = 1259,
    BFD_RELOC_16C_IMM04_C = 1260,
    BFD_RELOC_16C_IMM16 = 1261,
    BFD_RELOC_16C_IMM16_C = 1262,
    BFD_RELOC_16C_IMM20 = 1263,
    BFD_RELOC_16C_IMM20_C = 1264,
    BFD_RELOC_16C_IMM24 = 1265,
    BFD_RELOC_16C_IMM24_C = 1266,
    BFD_RELOC_16C_IMM32 = 1267,
    BFD_RELOC_16C_IMM32_C = 1268,
    BFD_RELOC_CR16_NUM8 = 1269,
    BFD_RELOC_CR16_NUM16 = 1270,
    BFD_RELOC_CR16_NUM32 = 1271,
    BFD_RELOC_CR16_NUM32a = 1272,
    BFD_RELOC_CR16_REGREL0 = 1273,
    BFD_RELOC_CR16_REGREL4 = 1274,
    BFD_RELOC_CR16_REGREL4a = 1275,
    BFD_RELOC_CR16_REGREL14 = 1276,
    BFD_RELOC_CR16_REGREL14a = 1277,
    BFD_RELOC_CR16_REGREL16 = 1278,
    BFD_RELOC_CR16_REGREL20 = 1279,
    BFD_RELOC_CR16_REGREL20a = 1280,
    BFD_RELOC_CR16_ABS20 = 1281,
    BFD_RELOC_CR16_ABS24 = 1282,
    BFD_RELOC_CR16_IMM4 = 1283,
    BFD_RELOC_CR16_IMM8 = 1284,
    BFD_RELOC_CR16_IMM16 = 1285,
    BFD_RELOC_CR16_IMM20 = 1286,
    BFD_RELOC_CR16_IMM24 = 1287,
    BFD_RELOC_CR16_IMM32 = 1288,
    BFD_RELOC_CR16_IMM32a = 1289,
    BFD_RELOC_CR16_DISP4 = 1290,
    BFD_RELOC_CR16_DISP8 = 1291,
    BFD_RELOC_CR16_DISP16 = 1292,
    BFD_RELOC_CR16_DISP20 = 1293,
    BFD_RELOC_CR16_DISP24 = 1294,
    BFD_RELOC_CR16_DISP24a = 1295,
    BFD_RELOC_CR16_SWITCH8 = 1296,
    BFD_RELOC_CR16_SWITCH16 = 1297,
    BFD_RELOC_CR16_SWITCH32 = 1298,
    BFD_RELOC_CR16_GOT_REGREL20 = 1299,
    BFD_RELOC_CR16_GOTC_REGREL20 = 1300,
    BFD_RELOC_CR16_GLOB_DAT = 1301,
    BFD_RELOC_CRX_REL4 = 1302,
    BFD_RELOC_CRX_REL8 = 1303,
    BFD_RELOC_CRX_REL8_CMP = 1304,
    BFD_RELOC_CRX_REL16 = 1305,
    BFD_RELOC_CRX_REL24 = 1306,
    BFD_RELOC_CRX_REL32 = 1307,
    BFD_RELOC_CRX_REGREL12 = 1308,
    BFD_RELOC_CRX_REGREL22 = 1309,
    BFD_RELOC_CRX_REGREL28 = 1310,
    BFD_RELOC_CRX_REGREL32 = 1311,
    BFD_RELOC_CRX_ABS16 = 1312,
    BFD_RELOC_CRX_ABS32 = 1313,
    BFD_RELOC_CRX_NUM8 = 1314,
    BFD_RELOC_CRX_NUM16 = 1315,
    BFD_RELOC_CRX_NUM32 = 1316,
    BFD_RELOC_CRX_IMM16 = 1317,
    BFD_RELOC_CRX_IMM32 = 1318,
    BFD_RELOC_CRX_SWITCH8 = 1319,
    BFD_RELOC_CRX_SWITCH16 = 1320,
    BFD_RELOC_CRX_SWITCH32 = 1321,
    BFD_RELOC_CRIS_BDISP8 = 1322,
    BFD_RELOC_CRIS_UNSIGNED_5 = 1323,
    BFD_RELOC_CRIS_SIGNED_6 = 1324,
    BFD_RELOC_CRIS_UNSIGNED_6 = 1325,
    BFD_RELOC_CRIS_SIGNED_8 = 1326,
    BFD_RELOC_CRIS_UNSIGNED_8 = 1327,
    BFD_RELOC_CRIS_SIGNED_16 = 1328,
    BFD_RELOC_CRIS_UNSIGNED_16 = 1329,
    BFD_RELOC_CRIS_LAPCQ_OFFSET = 1330,
    BFD_RELOC_CRIS_UNSIGNED_4 = 1331,
    BFD_RELOC_CRIS_COPY = 1332,
    BFD_RELOC_CRIS_GLOB_DAT = 1333,
    BFD_RELOC_CRIS_JUMP_SLOT = 1334,
    BFD_RELOC_CRIS_RELATIVE = 1335,
    BFD_RELOC_CRIS_32_GOT = 1336,
    BFD_RELOC_CRIS_16_GOT = 1337,
    BFD_RELOC_CRIS_32_GOTPLT = 1338,
    BFD_RELOC_CRIS_16_GOTPLT = 1339,
    BFD_RELOC_CRIS_32_GOTREL = 1340,
    BFD_RELOC_CRIS_32_PLT_GOTREL = 1341,
    BFD_RELOC_CRIS_32_PLT_PCREL = 1342,
    BFD_RELOC_CRIS_32_GOT_GD = 1343,
    BFD_RELOC_CRIS_16_GOT_GD = 1344,
    BFD_RELOC_CRIS_32_GD = 1345,
    BFD_RELOC_CRIS_DTP = 1346,
    BFD_RELOC_CRIS_32_DTPREL = 1347,
    BFD_RELOC_CRIS_16_DTPREL = 1348,
    BFD_RELOC_CRIS_32_GOT_TPREL = 1349,
    BFD_RELOC_CRIS_16_GOT_TPREL = 1350,
    BFD_RELOC_CRIS_32_TPREL = 1351,
    BFD_RELOC_CRIS_16_TPREL = 1352,
    BFD_RELOC_CRIS_DTPMOD = 1353,
    BFD_RELOC_CRIS_32_IE = 1354,
    BFD_RELOC_860_COPY = 1355,
    BFD_RELOC_860_GLOB_DAT = 1356,
    BFD_RELOC_860_JUMP_SLOT = 1357,
    BFD_RELOC_860_RELATIVE = 1358,
    BFD_RELOC_860_PC26 = 1359,
    BFD_RELOC_860_PLT26 = 1360,
    BFD_RELOC_860_PC16 = 1361,
    BFD_RELOC_860_LOW0 = 1362,
    BFD_RELOC_860_SPLIT0 = 1363,
    BFD_RELOC_860_LOW1 = 1364,
    BFD_RELOC_860_SPLIT1 = 1365,
    BFD_RELOC_860_LOW2 = 1366,
    BFD_RELOC_860_SPLIT2 = 1367,
    BFD_RELOC_860_LOW3 = 1368,
    BFD_RELOC_860_LOGOT0 = 1369,
    BFD_RELOC_860_SPGOT0 = 1370,
    BFD_RELOC_860_LOGOT1 = 1371,
    BFD_RELOC_860_SPGOT1 = 1372,
    BFD_RELOC_860_LOGOTOFF0 = 1373,
    BFD_RELOC_860_SPGOTOFF0 = 1374,
    BFD_RELOC_860_LOGOTOFF1 = 1375,
    BFD_RELOC_860_SPGOTOFF1 = 1376,
    BFD_RELOC_860_LOGOTOFF2 = 1377,
    BFD_RELOC_860_LOGOTOFF3 = 1378,
    BFD_RELOC_860_LOPC = 1379,
    BFD_RELOC_860_HIGHADJ = 1380,
    BFD_RELOC_860_HAGOT = 1381,
    BFD_RELOC_860_HAGOTOFF = 1382,
    BFD_RELOC_860_HAPC = 1383,
    BFD_RELOC_860_HIGH = 1384,
    BFD_RELOC_860_HIGOT = 1385,
    BFD_RELOC_860_HIGOTOFF = 1386,
    BFD_RELOC_OPENRISC_ABS_26 = 1387,
    BFD_RELOC_OPENRISC_REL_26 = 1388,
    BFD_RELOC_H8_DIR16A8 = 1389,
    BFD_RELOC_H8_DIR16R8 = 1390,
    BFD_RELOC_H8_DIR24A8 = 1391,
    BFD_RELOC_H8_DIR24R8 = 1392,
    BFD_RELOC_H8_DIR32A16 = 1393,
    BFD_RELOC_XSTORMY16_REL_12 = 1394,
    BFD_RELOC_XSTORMY16_12 = 1395,
    BFD_RELOC_XSTORMY16_24 = 1396,
    BFD_RELOC_XSTORMY16_FPTR16 = 1397,
    BFD_RELOC_RELC = 1398,
    BFD_RELOC_XC16X_PAG = 1399,
    BFD_RELOC_XC16X_POF = 1400,
    BFD_RELOC_XC16X_SEG = 1401,
    BFD_RELOC_XC16X_SOF = 1402,
    BFD_RELOC_VAX_GLOB_DAT = 1403,
    BFD_RELOC_VAX_JMP_SLOT = 1404,
    BFD_RELOC_VAX_RELATIVE = 1405,
    BFD_RELOC_MT_PC16 = 1406,
    BFD_RELOC_MT_HI16 = 1407,
    BFD_RELOC_MT_LO16 = 1408,
    BFD_RELOC_MT_GNU_VTINHERIT = 1409,
    BFD_RELOC_MT_GNU_VTENTRY = 1410,
    BFD_RELOC_MT_PCINSN8 = 1411,
    BFD_RELOC_MSP430_10_PCREL = 1412,
    BFD_RELOC_MSP430_16_PCREL = 1413,
    BFD_RELOC_MSP430_16 = 1414,
    BFD_RELOC_MSP430_16_PCREL_BYTE = 1415,
    BFD_RELOC_MSP430_16_BYTE = 1416,
    BFD_RELOC_MSP430_2X_PCREL = 1417,
    BFD_RELOC_MSP430_RL_PCREL = 1418,
    BFD_RELOC_IQ2000_OFFSET_16 = 1419,
    BFD_RELOC_IQ2000_OFFSET_21 = 1420,
    BFD_RELOC_IQ2000_UHI16 = 1421,
    BFD_RELOC_XTENSA_RTLD = 1422,
    BFD_RELOC_XTENSA_GLOB_DAT = 1423,
    BFD_RELOC_XTENSA_JMP_SLOT = 1424,
    BFD_RELOC_XTENSA_RELATIVE = 1425,
    BFD_RELOC_XTENSA_PLT = 1426,
    BFD_RELOC_XTENSA_DIFF8 = 1427,
    BFD_RELOC_XTENSA_DIFF16 = 1428,
    BFD_RELOC_XTENSA_DIFF32 = 1429,
    BFD_RELOC_XTENSA_SLOT0_OP = 1430,
    BFD_RELOC_XTENSA_SLOT1_OP = 1431,
    BFD_RELOC_XTENSA_SLOT2_OP = 1432,
    BFD_RELOC_XTENSA_SLOT3_OP = 1433,
    BFD_RELOC_XTENSA_SLOT4_OP = 1434,
    BFD_RELOC_XTENSA_SLOT5_OP = 1435,
    BFD_RELOC_XTENSA_SLOT6_OP = 1436,
    BFD_RELOC_XTENSA_SLOT7_OP = 1437,
    BFD_RELOC_XTENSA_SLOT8_OP = 1438,
    BFD_RELOC_XTENSA_SLOT9_OP = 1439,
    BFD_RELOC_XTENSA_SLOT10_OP = 1440,
    BFD_RELOC_XTENSA_SLOT11_OP = 1441,
    BFD_RELOC_XTENSA_SLOT12_OP = 1442,
    BFD_RELOC_XTENSA_SLOT13_OP = 1443,
    BFD_RELOC_XTENSA_SLOT14_OP = 1444,
    BFD_RELOC_XTENSA_SLOT0_ALT = 1445,
    BFD_RELOC_XTENSA_SLOT1_ALT = 1446,
    BFD_RELOC_XTENSA_SLOT2_ALT = 1447,
    BFD_RELOC_XTENSA_SLOT3_ALT = 1448,
    BFD_RELOC_XTENSA_SLOT4_ALT = 1449,
    BFD_RELOC_XTENSA_SLOT5_ALT = 1450,
    BFD_RELOC_XTENSA_SLOT6_ALT = 1451,
    BFD_RELOC_XTENSA_SLOT7_ALT = 1452,
    BFD_RELOC_XTENSA_SLOT8_ALT = 1453,
    BFD_RELOC_XTENSA_SLOT9_ALT = 1454,
    BFD_RELOC_XTENSA_SLOT10_ALT = 1455,
    BFD_RELOC_XTENSA_SLOT11_ALT = 1456,
    BFD_RELOC_XTENSA_SLOT12_ALT = 1457,
    BFD_RELOC_XTENSA_SLOT13_ALT = 1458,
    BFD_RELOC_XTENSA_SLOT14_ALT = 1459,
    BFD_RELOC_XTENSA_OP0 = 1460,
    BFD_RELOC_XTENSA_OP1 = 1461,
    BFD_RELOC_XTENSA_OP2 = 1462,
    BFD_RELOC_XTENSA_ASM_EXPAND = 1463,
    BFD_RELOC_XTENSA_ASM_SIMPLIFY = 1464,
    BFD_RELOC_XTENSA_TLSDESC_FN = 1465,
    BFD_RELOC_XTENSA_TLSDESC_ARG = 1466,
    BFD_RELOC_XTENSA_TLS_DTPOFF = 1467,
    BFD_RELOC_XTENSA_TLS_TPOFF = 1468,
    BFD_RELOC_XTENSA_TLS_FUNC = 1469,
    BFD_RELOC_XTENSA_TLS_ARG = 1470,
    BFD_RELOC_XTENSA_TLS_CALL = 1471,
    BFD_RELOC_Z80_DISP8 = 1472,
    BFD_RELOC_Z8K_DISP7 = 1473,
    BFD_RELOC_Z8K_CALLR = 1474,
    BFD_RELOC_Z8K_IMM4L = 1475,
    BFD_RELOC_LM32_CALL = 1476,
    BFD_RELOC_LM32_BRANCH = 1477,
    BFD_RELOC_LM32_16_GOT = 1478,
    BFD_RELOC_LM32_GOTOFF_HI16 = 1479,
    BFD_RELOC_LM32_GOTOFF_LO16 = 1480,
    BFD_RELOC_LM32_COPY = 1481,
    BFD_RELOC_LM32_GLOB_DAT = 1482,
    BFD_RELOC_LM32_JMP_SLOT = 1483,
    BFD_RELOC_LM32_RELATIVE = 1484,
    BFD_RELOC_MACH_O_SECTDIFF = 1485,
    BFD_RELOC_MACH_O_LOCAL_SECTDIFF = 1486,
    BFD_RELOC_MACH_O_PAIR = 1487,
    BFD_RELOC_MACH_O_X86_64_BRANCH32 = 1488,
    BFD_RELOC_MACH_O_X86_64_BRANCH8 = 1489,
    BFD_RELOC_MACH_O_X86_64_GOT = 1490,
    BFD_RELOC_MACH_O_X86_64_GOT_LOAD = 1491,
    BFD_RELOC_MACH_O_X86_64_SUBTRACTOR32 = 1492,
    BFD_RELOC_MACH_O_X86_64_SUBTRACTOR64 = 1493,
    BFD_RELOC_MACH_O_X86_64_PCREL32_1 = 1494,
    BFD_RELOC_MACH_O_X86_64_PCREL32_2 = 1495,
    BFD_RELOC_MACH_O_X86_64_PCREL32_4 = 1496,
    BFD_RELOC_MICROBLAZE_32_LO = 1497,
    BFD_RELOC_MICROBLAZE_32_LO_PCREL = 1498,
    BFD_RELOC_MICROBLAZE_32_ROSDA = 1499,
    BFD_RELOC_MICROBLAZE_32_RWSDA = 1500,
    BFD_RELOC_MICROBLAZE_32_SYM_OP_SYM = 1501,
    BFD_RELOC_MICROBLAZE_64_NONE = 1502,
    BFD_RELOC_MICROBLAZE_64_GOTPC = 1503,
    BFD_RELOC_MICROBLAZE_64_GOT = 1504,
    BFD_RELOC_MICROBLAZE_64_PLT = 1505,
    BFD_RELOC_MICROBLAZE_64_GOTOFF = 1506,
    BFD_RELOC_MICROBLAZE_32_GOTOFF = 1507,
    BFD_RELOC_MICROBLAZE_COPY = 1508,
    BFD_RELOC_AARCH64_ADD_LO12 = 1509,
    BFD_RELOC_AARCH64_ADR_GOT_PAGE = 1510,
    BFD_RELOC_AARCH64_ADR_HI21_PCREL = 1511,
    BFD_RELOC_AARCH64_ADR_HI21_NC_PCREL = 1512,
    BFD_RELOC_AARCH64_ADR_LO21_PCREL = 1513,
    BFD_RELOC_AARCH64_BRANCH19 = 1514,
    BFD_RELOC_AARCH64_CALL26 = 1515,
    BFD_RELOC_AARCH64_GAS_INTERNAL_FIXUP = 1516,
    BFD_RELOC_AARCH64_JUMP26 = 1517,
    BFD_RELOC_AARCH64_LD_LO19_PCREL = 1518,
    BFD_RELOC_AARCH64_LD64_GOT_LO12_NC = 1519,
    BFD_RELOC_AARCH64_LDST_LO12 = 1520,
    BFD_RELOC_AARCH64_LDST8_LO12 = 1521,
    BFD_RELOC_AARCH64_LDST16_LO12 = 1522,
    BFD_RELOC_AARCH64_LDST32_LO12 = 1523,
    BFD_RELOC_AARCH64_LDST64_LO12 = 1524,
    BFD_RELOC_AARCH64_LDST128_LO12 = 1525,
    BFD_RELOC_AARCH64_MOVW_G0 = 1526,
    BFD_RELOC_AARCH64_MOVW_G0_S = 1527,
    BFD_RELOC_AARCH64_MOVW_G0_NC = 1528,
    BFD_RELOC_AARCH64_MOVW_G1 = 1529,
    BFD_RELOC_AARCH64_MOVW_G1_NC = 1530,
    BFD_RELOC_AARCH64_MOVW_G1_S = 1531,
    BFD_RELOC_AARCH64_MOVW_G2 = 1532,
    BFD_RELOC_AARCH64_MOVW_G2_NC = 1533,
    BFD_RELOC_AARCH64_MOVW_G2_S = 1534,
    BFD_RELOC_AARCH64_MOVW_G3 = 1535,
    BFD_RELOC_AARCH64_TLSDESC = 1536,
    BFD_RELOC_AARCH64_TLSDESC_ADD = 1537,
    BFD_RELOC_AARCH64_TLSDESC_ADD_LO12_NC = 1538,
    BFD_RELOC_AARCH64_TLSDESC_ADR_PAGE = 1539,
    BFD_RELOC_AARCH64_TLSDESC_ADR_PREL21 = 1540,
    BFD_RELOC_AARCH64_TLSDESC_CALL = 1541,
    BFD_RELOC_AARCH64_TLSDESC_LD64_LO12_NC = 1542,
    BFD_RELOC_AARCH64_TLSDESC_LD64_PREL19 = 1543,
    BFD_RELOC_AARCH64_TLSDESC_LDR = 1544,
    BFD_RELOC_AARCH64_TLSDESC_OFF_G0_NC = 1545,
    BFD_RELOC_AARCH64_TLSDESC_OFF_G1 = 1546,
    BFD_RELOC_AARCH64_TLSGD_ADD_LO12_NC = 1547,
    BFD_RELOC_AARCH64_TLSGD_ADR_PAGE21 = 1548,
    BFD_RELOC_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21 = 1549,
    BFD_RELOC_AARCH64_TLSIE_LD_GOTTPREL_PREL19 = 1550,
    BFD_RELOC_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC = 1551,
    BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC = 1552,
    BFD_RELOC_AARCH64_TLSIE_MOVW_GOTTPREL_G1 = 1553,
    BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_HI12 = 1554,
    BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12 = 1555,
    BFD_RELOC_AARCH64_TLSLE_ADD_TPREL_LO12_NC = 1556,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0 = 1557,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G0_NC = 1558,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1 = 1559,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G1_NC = 1560,
    BFD_RELOC_AARCH64_TLSLE_MOVW_TPREL_G2 = 1561,
    BFD_RELOC_AARCH64_TLS_DTPMOD64 = 1562,
    BFD_RELOC_AARCH64_TLS_DTPREL64 = 1563,
    BFD_RELOC_AARCH64_TLS_TPREL64 = 1564,
    BFD_RELOC_AARCH64_TSTBR14 = 1565,
    BFD_RELOC_TILEPRO_COPY = 1566,
    BFD_RELOC_TILEPRO_GLOB_DAT = 1567,
    BFD_RELOC_TILEPRO_JMP_SLOT = 1568,
    BFD_RELOC_TILEPRO_RELATIVE = 1569,
    BFD_RELOC_TILEPRO_BROFF_X1 = 1570,
    BFD_RELOC_TILEPRO_JOFFLONG_X1 = 1571,
    BFD_RELOC_TILEPRO_JOFFLONG_X1_PLT = 1572,
    BFD_RELOC_TILEPRO_IMM8_X0 = 1573,
    BFD_RELOC_TILEPRO_IMM8_Y0 = 1574,
    BFD_RELOC_TILEPRO_IMM8_X1 = 1575,
    BFD_RELOC_TILEPRO_IMM8_Y1 = 1576,
    BFD_RELOC_TILEPRO_DEST_IMM8_X1 = 1577,
    BFD_RELOC_TILEPRO_MT_IMM15_X1 = 1578,
    BFD_RELOC_TILEPRO_MF_IMM15_X1 = 1579,
    BFD_RELOC_TILEPRO_IMM16_X0 = 1580,
    BFD_RELOC_TILEPRO_IMM16_X1 = 1581,
    BFD_RELOC_TILEPRO_IMM16_X0_LO = 1582,
    BFD_RELOC_TILEPRO_IMM16_X1_LO = 1583,
    BFD_RELOC_TILEPRO_IMM16_X0_HI = 1584,
    BFD_RELOC_TILEPRO_IMM16_X1_HI = 1585,
    BFD_RELOC_TILEPRO_IMM16_X0_HA = 1586,
    BFD_RELOC_TILEPRO_IMM16_X1_HA = 1587,
    BFD_RELOC_TILEPRO_IMM16_X0_PCREL = 1588,
    BFD_RELOC_TILEPRO_IMM16_X1_PCREL = 1589,
    BFD_RELOC_TILEPRO_IMM16_X0_LO_PCREL = 1590,
    BFD_RELOC_TILEPRO_IMM16_X1_LO_PCREL = 1591,
    BFD_RELOC_TILEPRO_IMM16_X0_HI_PCREL = 1592,
    BFD_RELOC_TILEPRO_IMM16_X1_HI_PCREL = 1593,
    BFD_RELOC_TILEPRO_IMM16_X0_HA_PCREL = 1594,
    BFD_RELOC_TILEPRO_IMM16_X1_HA_PCREL = 1595,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT = 1596,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT = 1597,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT_LO = 1598,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT_LO = 1599,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT_HI = 1600,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT_HI = 1601,
    BFD_RELOC_TILEPRO_IMM16_X0_GOT_HA = 1602,
    BFD_RELOC_TILEPRO_IMM16_X1_GOT_HA = 1603,
    BFD_RELOC_TILEPRO_MMSTART_X0 = 1604,
    BFD_RELOC_TILEPRO_MMEND_X0 = 1605,
    BFD_RELOC_TILEPRO_MMSTART_X1 = 1606,
    BFD_RELOC_TILEPRO_MMEND_X1 = 1607,
    BFD_RELOC_TILEPRO_SHAMT_X0 = 1608,
    BFD_RELOC_TILEPRO_SHAMT_X1 = 1609,
    BFD_RELOC_TILEPRO_SHAMT_Y0 = 1610,
    BFD_RELOC_TILEPRO_SHAMT_Y1 = 1611,
    BFD_RELOC_TILEPRO_TLS_GD_CALL = 1612,
    BFD_RELOC_TILEPRO_IMM8_X0_TLS_GD_ADD = 1613,
    BFD_RELOC_TILEPRO_IMM8_X1_TLS_GD_ADD = 1614,
    BFD_RELOC_TILEPRO_IMM8_Y0_TLS_GD_ADD = 1615,
    BFD_RELOC_TILEPRO_IMM8_Y1_TLS_GD_ADD = 1616,
    BFD_RELOC_TILEPRO_TLS_IE_LOAD = 1617,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD = 1618,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD = 1619,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_LO = 1620,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_LO = 1621,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HI = 1622,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HI = 1623,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_GD_HA = 1624,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_GD_HA = 1625,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE = 1626,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE = 1627,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_LO = 1628,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_LO = 1629,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HI = 1630,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HI = 1631,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_IE_HA = 1632,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_IE_HA = 1633,
    BFD_RELOC_TILEPRO_TLS_DTPMOD32 = 1634,
    BFD_RELOC_TILEPRO_TLS_DTPOFF32 = 1635,
    BFD_RELOC_TILEPRO_TLS_TPOFF32 = 1636,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE = 1637,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE = 1638,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_LO = 1639,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_LO = 1640,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HI = 1641,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HI = 1642,
    BFD_RELOC_TILEPRO_IMM16_X0_TLS_LE_HA = 1643,
    BFD_RELOC_TILEPRO_IMM16_X1_TLS_LE_HA = 1644,
    BFD_RELOC_TILEGX_HW0 = 1645,
    BFD_RELOC_TILEGX_HW1 = 1646,
    BFD_RELOC_TILEGX_HW2 = 1647,
    BFD_RELOC_TILEGX_HW3 = 1648,
    BFD_RELOC_TILEGX_HW0_LAST = 1649,
    BFD_RELOC_TILEGX_HW1_LAST = 1650,
    BFD_RELOC_TILEGX_HW2_LAST = 1651,
    BFD_RELOC_TILEGX_COPY = 1652,
    BFD_RELOC_TILEGX_GLOB_DAT = 1653,
    BFD_RELOC_TILEGX_JMP_SLOT = 1654,
    BFD_RELOC_TILEGX_RELATIVE = 1655,
    BFD_RELOC_TILEGX_BROFF_X1 = 1656,
    BFD_RELOC_TILEGX_JUMPOFF_X1 = 1657,
    BFD_RELOC_TILEGX_JUMPOFF_X1_PLT = 1658,
    BFD_RELOC_TILEGX_IMM8_X0 = 1659,
    BFD_RELOC_TILEGX_IMM8_Y0 = 1660,
    BFD_RELOC_TILEGX_IMM8_X1 = 1661,
    BFD_RELOC_TILEGX_IMM8_Y1 = 1662,
    BFD_RELOC_TILEGX_DEST_IMM8_X1 = 1663,
    BFD_RELOC_TILEGX_MT_IMM14_X1 = 1664,
    BFD_RELOC_TILEGX_MF_IMM14_X1 = 1665,
    BFD_RELOC_TILEGX_MMSTART_X0 = 1666,
    BFD_RELOC_TILEGX_MMEND_X0 = 1667,
    BFD_RELOC_TILEGX_SHAMT_X0 = 1668,
    BFD_RELOC_TILEGX_SHAMT_X1 = 1669,
    BFD_RELOC_TILEGX_SHAMT_Y0 = 1670,
    BFD_RELOC_TILEGX_SHAMT_Y1 = 1671,
    BFD_RELOC_TILEGX_IMM16_X0_HW0 = 1672,
    BFD_RELOC_TILEGX_IMM16_X1_HW0 = 1673,
    BFD_RELOC_TILEGX_IMM16_X0_HW1 = 1674,
    BFD_RELOC_TILEGX_IMM16_X1_HW1 = 1675,
    BFD_RELOC_TILEGX_IMM16_X0_HW2 = 1676,
    BFD_RELOC_TILEGX_IMM16_X1_HW2 = 1677,
    BFD_RELOC_TILEGX_IMM16_X0_HW3 = 1678,
    BFD_RELOC_TILEGX_IMM16_X1_HW3 = 1679,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST = 1680,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST = 1681,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST = 1682,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST = 1683,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST = 1684,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST = 1685,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_PCREL = 1686,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_PCREL = 1687,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_PCREL = 1688,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_PCREL = 1689,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_PCREL = 1690,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_PCREL = 1691,
    BFD_RELOC_TILEGX_IMM16_X0_HW3_PCREL = 1692,
    BFD_RELOC_TILEGX_IMM16_X1_HW3_PCREL = 1693,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_PCREL = 1694,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_PCREL = 1695,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_PCREL = 1696,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_PCREL = 1697,
    BFD_RELOC_TILEGX_IMM16_X0_HW2_LAST_PCREL = 1698,
    BFD_RELOC_TILEGX_IMM16_X1_HW2_LAST_PCREL = 1699,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_GOT = 1700,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_GOT = 1701,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_GOT = 1702,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_GOT = 1703,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_GOT = 1704,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_GOT = 1705,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_GD = 1706,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_GD = 1707,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_LE = 1708,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_LE = 1709,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_LE = 1710,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_LE = 1711,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_LE = 1712,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_LE = 1713,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_GD = 1714,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_GD = 1715,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_GD = 1716,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_GD = 1717,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_TLS_IE = 1718,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_TLS_IE = 1719,
    BFD_RELOC_TILEGX_IMM16_X0_HW0_LAST_TLS_IE = 1720,
    BFD_RELOC_TILEGX_IMM16_X1_HW0_LAST_TLS_IE = 1721,
    BFD_RELOC_TILEGX_IMM16_X0_HW1_LAST_TLS_IE = 1722,
    BFD_RELOC_TILEGX_IMM16_X1_HW1_LAST_TLS_IE = 1723,
    BFD_RELOC_TILEGX_TLS_DTPMOD64 = 1724,
    BFD_RELOC_TILEGX_TLS_DTPOFF64 = 1725,
    BFD_RELOC_TILEGX_TLS_TPOFF64 = 1726,
    BFD_RELOC_TILEGX_TLS_DTPMOD32 = 1727,
    BFD_RELOC_TILEGX_TLS_DTPOFF32 = 1728,
    BFD_RELOC_TILEGX_TLS_TPOFF32 = 1729,
    BFD_RELOC_TILEGX_TLS_GD_CALL = 1730,
    BFD_RELOC_TILEGX_IMM8_X0_TLS_GD_ADD = 1731,
    BFD_RELOC_TILEGX_IMM8_X1_TLS_GD_ADD = 1732,
    BFD_RELOC_TILEGX_IMM8_Y0_TLS_GD_ADD = 1733,
    BFD_RELOC_TILEGX_IMM8_Y1_TLS_GD_ADD = 1734,
    BFD_RELOC_TILEGX_TLS_IE_LOAD = 1735,
    BFD_RELOC_TILEGX_IMM8_X0_TLS_ADD = 1736,
    BFD_RELOC_TILEGX_IMM8_X1_TLS_ADD = 1737,
    BFD_RELOC_TILEGX_IMM8_Y0_TLS_ADD = 1738,
    BFD_RELOC_TILEGX_IMM8_Y1_TLS_ADD = 1739,
    BFD_RELOC_EPIPHANY_SIMM8 = 1740,
    BFD_RELOC_EPIPHANY_SIMM24 = 1741,
    BFD_RELOC_EPIPHANY_HIGH = 1742,
    BFD_RELOC_EPIPHANY_LOW = 1743,
    BFD_RELOC_EPIPHANY_SIMM11 = 1744,
    BFD_RELOC_EPIPHANY_IMM11 = 1745,
    BFD_RELOC_EPIPHANY_IMM8 = 1746,
    BFD_RELOC_UNUSED = 1747
} ;
#line 5484 "../bfd/bfd.h"
typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;
#line 5494 "../bfd/bfd.h"
union __anonunion_udata_563736225 {
   void *p ;
   bfd_vma i ;
};
#line 5494 "../bfd/bfd.h"
struct bfd_symbol {
   struct bfd *the_bfd ;
   char const   *name ;
   symvalue value ;
   flagword flags ;
   struct bfd_section *section ;
   union __anonunion_udata_563736225 udata ;
};
#line 5494 "../bfd/bfd.h"
typedef struct bfd_symbol asymbol;
#line 5681
enum bfd_direction {
    no_direction = 0,
    read_direction = 1,
    write_direction = 2,
    both_direction = 3
} ;
#line 5689
struct bfd_target ;
#line 5689
struct bfd_iovec ;
#line 5689
struct aout_data_struct ;
#line 5689
struct artdata ;
#line 5689
struct _oasys_data ;
#line 5689
struct _oasys_ar_data ;
#line 5689
struct coff_tdata ;
#line 5689
struct pe_tdata ;
#line 5689
struct xcoff_tdata ;
#line 5689
struct ecoff_tdata ;
#line 5689
struct ieee_data_struct ;
#line 5689
struct ieee_ar_data_struct ;
#line 5689
struct srec_data_struct ;
#line 5689
struct verilog_data_struct ;
#line 5689
struct ihex_data_struct ;
#line 5689
struct tekhex_data_struct ;
#line 5689
struct elf_obj_tdata ;
#line 5689
struct nlm_obj_tdata ;
#line 5689
struct bout_data_struct ;
#line 5689
struct mmo_data_struct ;
#line 5689
struct sun_core_struct ;
#line 5689
struct sco5_core_struct ;
#line 5689
struct trad_core_struct ;
#line 5689
struct som_data_struct ;
#line 5689
struct hpux_core_struct ;
#line 5689
struct hppabsd_core_struct ;
#line 5689
struct sgi_core_struct ;
#line 5689
struct lynx_core_struct ;
#line 5689
struct osf_core_struct ;
#line 5689
struct cisco_core_struct ;
#line 5689
struct versados_data_struct ;
#line 5689
struct netbsd_core_struct ;
#line 5689
struct mach_o_data_struct ;
#line 5689
struct mach_o_fat_data_struct ;
#line 5689
struct plugin_data_struct ;
#line 5689
struct bfd_pef_data_struct ;
#line 5689
struct bfd_pef_xlib_data_struct ;
#line 5689
struct bfd_sym_data_struct ;
#line 5689 "../bfd/bfd.h"
union __anonunion_tdata_99884381 {
   struct aout_data_struct *aout_data ;
   struct artdata *aout_ar_data ;
   struct _oasys_data *oasys_obj_data ;
   struct _oasys_ar_data *oasys_ar_data ;
   struct coff_tdata *coff_obj_data ;
   struct pe_tdata *pe_obj_data ;
   struct xcoff_tdata *xcoff_obj_data ;
   struct ecoff_tdata *ecoff_obj_data ;
   struct ieee_data_struct *ieee_data ;
   struct ieee_ar_data_struct *ieee_ar_data ;
   struct srec_data_struct *srec_data ;
   struct verilog_data_struct *verilog_data ;
   struct ihex_data_struct *ihex_data ;
   struct tekhex_data_struct *tekhex_data ;
   struct elf_obj_tdata *elf_obj_data ;
   struct nlm_obj_tdata *nlm_obj_data ;
   struct bout_data_struct *bout_data ;
   struct mmo_data_struct *mmo_data ;
   struct sun_core_struct *sun_core_data ;
   struct sco5_core_struct *sco5_core_data ;
   struct trad_core_struct *trad_core_data ;
   struct som_data_struct *som_data ;
   struct hpux_core_struct *hpux_core_data ;
   struct hppabsd_core_struct *hppabsd_core_data ;
   struct sgi_core_struct *sgi_core_data ;
   struct lynx_core_struct *lynx_core_data ;
   struct osf_core_struct *osf_core_data ;
   struct cisco_core_struct *cisco_core_data ;
   struct versados_data_struct *versados_data ;
   struct netbsd_core_struct *netbsd_core_data ;
   struct mach_o_data_struct *mach_o_data ;
   struct mach_o_fat_data_struct *mach_o_fat_data ;
   struct plugin_data_struct *plugin_data ;
   struct bfd_pef_data_struct *pef_data ;
   struct bfd_pef_xlib_data_struct *pef_xlib_data ;
   struct bfd_sym_data_struct *sym_data ;
   void *any ;
};
#line 5689 "../bfd/bfd.h"
struct bfd {
   unsigned int id ;
   char const   *filename ;
   struct bfd_target  const  *xvec ;
   void *iostream ;
   struct bfd_iovec  const  *iovec ;
   struct bfd *lru_prev ;
   struct bfd *lru_next ;
   ufile_ptr where ;
   long mtime ;
   int ifd ;
   bfd_format format ;
   enum bfd_direction direction ;
   flagword flags ;
   ufile_ptr origin ;
   ufile_ptr proxy_origin ;
   struct bfd_hash_table section_htab ;
   struct bfd_section *sections ;
   struct bfd_section *section_last ;
   unsigned int section_count ;
   bfd_vma start_address ;
   unsigned int symcount ;
   struct bfd_symbol **outsymbols ;
   unsigned int dynsymcount ;
   struct bfd_arch_info  const  *arch_info ;
   void *arelt_data ;
   struct bfd *my_archive ;
   struct bfd *archive_next ;
   struct bfd *archive_head ;
   struct bfd *nested_archives ;
   struct bfd *link_next ;
   int archive_pass ;
   union __anonunion_tdata_99884381 tdata ;
   void *usrdata ;
   void *memory ;
   unsigned int cacheable : 1 ;
   unsigned int target_defaulted : 1 ;
   unsigned int opened_once : 1 ;
   unsigned int mtime_set : 1 ;
   unsigned int no_export : 1 ;
   unsigned int output_has_begun : 1 ;
   unsigned int has_armap : 1 ;
   unsigned int is_thin_archive : 1 ;
   unsigned int selective_search : 1 ;
};
#line 6218
enum bfd_flavour {
    bfd_target_unknown_flavour = 0,
    bfd_target_aout_flavour = 1,
    bfd_target_coff_flavour = 2,
    bfd_target_ecoff_flavour = 3,
    bfd_target_xcoff_flavour = 4,
    bfd_target_elf_flavour = 5,
    bfd_target_ieee_flavour = 6,
    bfd_target_nlm_flavour = 7,
    bfd_target_oasys_flavour = 8,
    bfd_target_tekhex_flavour = 9,
    bfd_target_srec_flavour = 10,
    bfd_target_verilog_flavour = 11,
    bfd_target_ihex_flavour = 12,
    bfd_target_som_flavour = 13,
    bfd_target_os9k_flavour = 14,
    bfd_target_versados_flavour = 15,
    bfd_target_msdos_flavour = 16,
    bfd_target_ovax_flavour = 17,
    bfd_target_evax_flavour = 18,
    bfd_target_mmo_flavour = 19,
    bfd_target_mach_o_flavour = 20,
    bfd_target_pef_flavour = 21,
    bfd_target_pef_xlib_flavour = 22,
    bfd_target_sym_flavour = 23
} ;
#line 6246
enum bfd_endian {
    BFD_ENDIAN_BIG = 0,
    BFD_ENDIAN_LITTLE = 1,
    BFD_ENDIAN_UNKNOWN = 2
} ;
#line 6252
struct flag_info ;
#line 6254
struct bfd_link_hash_table ;
#line 6254 "../bfd/bfd.h"
struct bfd_target {
   char *name ;
   enum bfd_flavour flavour ;
   enum bfd_endian byteorder ;
   enum bfd_endian header_byteorder ;
   flagword object_flags ;
   flagword section_flags ;
   char symbol_leading_char ;
   char ar_pad_char ;
   unsigned char ar_max_namelen ;
   unsigned char match_priority ;
   bfd_uint64_t (*bfd_getx64)(void const   * ) ;
   bfd_int64_t (*bfd_getx_signed_64)(void const   * ) ;
   void (*bfd_putx64)(bfd_uint64_t  , void * ) ;
   bfd_vma (*bfd_getx32)(void const   * ) ;
   bfd_signed_vma (*bfd_getx_signed_32)(void const   * ) ;
   void (*bfd_putx32)(bfd_vma  , void * ) ;
   bfd_vma (*bfd_getx16)(void const   * ) ;
   bfd_signed_vma (*bfd_getx_signed_16)(void const   * ) ;
   void (*bfd_putx16)(bfd_vma  , void * ) ;
   bfd_uint64_t (*bfd_h_getx64)(void const   * ) ;
   bfd_int64_t (*bfd_h_getx_signed_64)(void const   * ) ;
   void (*bfd_h_putx64)(bfd_uint64_t  , void * ) ;
   bfd_vma (*bfd_h_getx32)(void const   * ) ;
   bfd_signed_vma (*bfd_h_getx_signed_32)(void const   * ) ;
   void (*bfd_h_putx32)(bfd_vma  , void * ) ;
   bfd_vma (*bfd_h_getx16)(void const   * ) ;
   bfd_signed_vma (*bfd_h_getx_signed_16)(void const   * ) ;
   void (*bfd_h_putx16)(bfd_vma  , void * ) ;
   struct bfd_target  const  *(*_bfd_check_format[4])(bfd * ) ;
   bfd_boolean (*_bfd_set_format[4])(bfd * ) ;
   bfd_boolean (*_bfd_write_contents[4])(bfd * ) ;
   bfd_boolean (*_close_and_cleanup)(bfd * ) ;
   bfd_boolean (*_bfd_free_cached_info)(bfd * ) ;
   bfd_boolean (*_new_section_hook)(bfd * , sec_ptr  ) ;
   bfd_boolean (*_bfd_get_section_contents)(bfd * , sec_ptr  , void * , file_ptr  ,
                                            bfd_size_type  ) ;
   bfd_boolean (*_bfd_get_section_contents_in_window)(bfd * , sec_ptr  , bfd_window * ,
                                                      file_ptr  , bfd_size_type  ) ;
   bfd_boolean (*_bfd_copy_private_bfd_data)(bfd * , bfd * ) ;
   bfd_boolean (*_bfd_merge_private_bfd_data)(bfd * , bfd * ) ;
   bfd_boolean (*_bfd_init_private_section_data)(bfd * , sec_ptr  , bfd * , sec_ptr  ,
                                                 struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_copy_private_section_data)(bfd * , sec_ptr  , bfd * , sec_ptr  ) ;
   bfd_boolean (*_bfd_copy_private_symbol_data)(bfd * , asymbol * , bfd * , asymbol * ) ;
   bfd_boolean (*_bfd_copy_private_header_data)(bfd * , bfd * ) ;
   bfd_boolean (*_bfd_set_private_flags)(bfd * , flagword  ) ;
   bfd_boolean (*_bfd_print_private_bfd_data)(bfd * , void * ) ;
   char *(*_core_file_failing_command)(bfd * ) ;
   int (*_core_file_failing_signal)(bfd * ) ;
   bfd_boolean (*_core_file_matches_executable_p)(bfd * , bfd * ) ;
   int (*_core_file_pid)(bfd * ) ;
   bfd_boolean (*_bfd_slurp_armap)(bfd * ) ;
   bfd_boolean (*_bfd_slurp_extended_name_table)(bfd * ) ;
   bfd_boolean (*_bfd_construct_extended_name_table)(bfd * , char ** , bfd_size_type * ,
                                                     char const   ** ) ;
   void (*_bfd_truncate_arname)(bfd * , char const   * , char * ) ;
   bfd_boolean (*write_armap)(bfd * , unsigned int  , struct orl * , unsigned int  ,
                              int  ) ;
   void *(*_bfd_read_ar_hdr_fn)(bfd * ) ;
   bfd_boolean (*_bfd_write_ar_hdr_fn)(bfd * , bfd * ) ;
   bfd *(*openr_next_archived_file)(bfd * , bfd * ) ;
   bfd *(*_bfd_get_elt_at_index)(bfd * , symindex  ) ;
   int (*_bfd_stat_arch_elt)(bfd * , struct stat * ) ;
   bfd_boolean (*_bfd_update_armap_timestamp)(bfd * ) ;
   long (*_bfd_get_symtab_upper_bound)(bfd * ) ;
   long (*_bfd_canonicalize_symtab)(bfd * , struct bfd_symbol ** ) ;
   struct bfd_symbol *(*_bfd_make_empty_symbol)(bfd * ) ;
   void (*_bfd_print_symbol)(bfd * , void * , struct bfd_symbol * , bfd_print_symbol_type  ) ;
   void (*_bfd_get_symbol_info)(bfd * , struct bfd_symbol * , symbol_info * ) ;
   bfd_boolean (*_bfd_is_local_label_name)(bfd * , char const   * ) ;
   bfd_boolean (*_bfd_is_target_special_symbol)(bfd * , asymbol * ) ;
   alent *(*_get_lineno)(bfd * , struct bfd_symbol * ) ;
   bfd_boolean (*_bfd_find_nearest_line)(bfd * , struct bfd_section * , struct bfd_symbol ** ,
                                         bfd_vma  , char const   ** , char const   ** ,
                                         unsigned int * ) ;
   bfd_boolean (*_bfd_find_nearest_line_discriminator)(bfd * , struct bfd_section * ,
                                                       struct bfd_symbol ** , bfd_vma  ,
                                                       char const   ** , char const   ** ,
                                                       unsigned int * , unsigned int * ) ;
   bfd_boolean (*_bfd_find_line)(bfd * , struct bfd_symbol ** , struct bfd_symbol * ,
                                 char const   ** , unsigned int * ) ;
   bfd_boolean (*_bfd_find_inliner_info)(bfd * , char const   ** , char const   ** ,
                                         unsigned int * ) ;
   asymbol *(*_bfd_make_debug_symbol)(bfd * , void * , unsigned long size ) ;
   long (*_read_minisymbols)(bfd * , bfd_boolean  , void ** , unsigned int * ) ;
   asymbol *(*_minisymbol_to_symbol)(bfd * , bfd_boolean  , void const   * , asymbol * ) ;
   long (*_get_reloc_upper_bound)(bfd * , sec_ptr  ) ;
   long (*_bfd_canonicalize_reloc)(bfd * , sec_ptr  , arelent ** , struct bfd_symbol ** ) ;
   reloc_howto_type *(*reloc_type_lookup)(bfd * , bfd_reloc_code_real_type  ) ;
   reloc_howto_type *(*reloc_name_lookup)(bfd * , char const   * ) ;
   bfd_boolean (*_bfd_set_arch_mach)(bfd * , enum bfd_architecture  , unsigned long  ) ;
   bfd_boolean (*_bfd_set_section_contents)(bfd * , sec_ptr  , void const   * , file_ptr  ,
                                            bfd_size_type  ) ;
   int (*_bfd_sizeof_headers)(bfd * , struct bfd_link_info * ) ;
   bfd_byte *(*_bfd_get_relocated_section_contents)(bfd * , struct bfd_link_info * ,
                                                    struct bfd_link_order * , bfd_byte * ,
                                                    bfd_boolean  , struct bfd_symbol ** ) ;
   bfd_boolean (*_bfd_relax_section)(bfd * , struct bfd_section * , struct bfd_link_info * ,
                                     bfd_boolean * ) ;
   struct bfd_link_hash_table *(*_bfd_link_hash_table_create)(bfd * ) ;
   void (*_bfd_link_hash_table_free)(struct bfd_link_hash_table * ) ;
   bfd_boolean (*_bfd_link_add_symbols)(bfd * , struct bfd_link_info * ) ;
   void (*_bfd_link_just_syms)(asection * , struct bfd_link_info * ) ;
   void (*_bfd_copy_link_hash_symbol_type)(bfd * , struct bfd_link_hash_entry * ,
                                           struct bfd_link_hash_entry * ) ;
   bfd_boolean (*_bfd_final_link)(bfd * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_link_split_section)(bfd * , struct bfd_section * ) ;
   bfd_boolean (*_bfd_gc_sections)(bfd * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_lookup_section_flags)(struct bfd_link_info * , struct flag_info * ,
                                            asection * ) ;
   bfd_boolean (*_bfd_merge_sections)(bfd * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_is_group_section)(bfd * , struct bfd_section  const  * ) ;
   bfd_boolean (*_bfd_discard_group)(bfd * , struct bfd_section * ) ;
   bfd_boolean (*_section_already_linked)(bfd * , asection * , struct bfd_link_info * ) ;
   bfd_boolean (*_bfd_define_common_symbol)(bfd * , struct bfd_link_info * , struct bfd_link_hash_entry * ) ;
   long (*_bfd_get_dynamic_symtab_upper_bound)(bfd * ) ;
   long (*_bfd_canonicalize_dynamic_symtab)(bfd * , struct bfd_symbol ** ) ;
   long (*_bfd_get_synthetic_symtab)(bfd * , long  , struct bfd_symbol ** , long  ,
                                     struct bfd_symbol ** , struct bfd_symbol ** ) ;
   long (*_bfd_get_dynamic_reloc_upper_bound)(bfd * ) ;
   long (*_bfd_canonicalize_dynamic_reloc)(bfd * , arelent ** , struct bfd_symbol ** ) ;
   struct bfd_target  const  *alternative_target ;
   void const   *backend_data ;
};
#line 141 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Sym_441262567 {
   unsigned char st_name[4] ;
   unsigned char st_value[4] ;
   unsigned char st_size[4] ;
   unsigned char st_info[1] ;
   unsigned char st_other[1] ;
   unsigned char st_shndx[2] ;
};
#line 141 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Sym_441262567 Elf32_External_Sym;
#line 150 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Sym_441262568 {
   unsigned char st_name[4] ;
   unsigned char st_info[1] ;
   unsigned char st_other[1] ;
   unsigned char st_shndx[2] ;
   unsigned char st_value[8] ;
   unsigned char st_size[8] ;
};
#line 150 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Sym_441262568 Elf64_External_Sym;
#line 159 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Sym_Shndx_184927680 {
   unsigned char est_shndx[4] ;
};
#line 159 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Sym_Shndx_184927680 Elf_External_Sym_Shndx;
#line 165 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Note_328036297 {
   unsigned char namesz[4] ;
   unsigned char descsz[4] ;
   unsigned char type[4] ;
   char name[1] ;
};
#line 165 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Note_328036297 Elf_External_Note;
#line 173 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Rel_443125039 {
   unsigned char r_offset[4] ;
   unsigned char r_info[4] ;
};
#line 173 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Rel_443125039 Elf32_External_Rel;
#line 178 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Rela_948896363 {
   unsigned char r_offset[4] ;
   unsigned char r_info[4] ;
   unsigned char r_addend[4] ;
};
#line 178 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Rela_948896363 Elf32_External_Rela;
#line 184 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Rel_948896364 {
   unsigned char r_offset[8] ;
   unsigned char r_info[8] ;
};
#line 184 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Rel_948896364 Elf64_External_Rel;
#line 189 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Rela_948896365 {
   unsigned char r_offset[8] ;
   unsigned char r_info[8] ;
   unsigned char r_addend[8] ;
};
#line 189 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Rela_948896365 Elf64_External_Rela;
#line 197 "./../include/elf/external.h"
union __anonunion_d_un_948896366 {
   unsigned char d_val[4] ;
   unsigned char d_ptr[4] ;
};
#line 197 "./../include/elf/external.h"
struct __anonstruct_Elf32_External_Dyn_101797483 {
   unsigned char d_tag[4] ;
   union __anonunion_d_un_948896366 d_un ;
};
#line 197 "./../include/elf/external.h"
typedef struct __anonstruct_Elf32_External_Dyn_101797483 Elf32_External_Dyn;
#line 205 "./../include/elf/external.h"
union __anonunion_d_un_1006031669 {
   unsigned char d_val[8] ;
   unsigned char d_ptr[8] ;
};
#line 205 "./../include/elf/external.h"
struct __anonstruct_Elf64_External_Dyn_1006031668 {
   unsigned char d_tag[8] ;
   union __anonunion_d_un_1006031669 d_un ;
};
#line 205 "./../include/elf/external.h"
typedef struct __anonstruct_Elf64_External_Dyn_1006031668 Elf64_External_Dyn;
#line 219 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Verdef_834899447 {
   unsigned char vd_version[2] ;
   unsigned char vd_flags[2] ;
   unsigned char vd_ndx[2] ;
   unsigned char vd_cnt[2] ;
   unsigned char vd_hash[4] ;
   unsigned char vd_aux[4] ;
   unsigned char vd_next[4] ;
};
#line 219 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Verdef_834899447 Elf_External_Verdef;
#line 231 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Verdaux_1006031670 {
   unsigned char vda_name[4] ;
   unsigned char vda_next[4] ;
};
#line 231 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Verdaux_1006031670 Elf_External_Verdaux;
#line 238 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Verneed_1006031671 {
   unsigned char vn_version[2] ;
   unsigned char vn_cnt[2] ;
   unsigned char vn_file[4] ;
   unsigned char vn_aux[4] ;
   unsigned char vn_next[4] ;
};
#line 238 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Verneed_1006031671 Elf_External_Verneed;
#line 248 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Vernaux_1006031672 {
   unsigned char vna_hash[4] ;
   unsigned char vna_flags[2] ;
   unsigned char vna_other[2] ;
   unsigned char vna_name[4] ;
   unsigned char vna_next[4] ;
};
#line 248 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Vernaux_1006031672 Elf_External_Vernaux;
#line 259 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Versym_1006031673 {
   unsigned char vs_vers[2] ;
} __attribute__((__packed__)) ;
#line 259 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Versym_1006031673 Elf_External_Versym;
#line 264 "./../include/elf/external.h"
struct __anonstruct_Elf_External_Syminfo_1006031674 {
   unsigned char si_boundto[2] ;
   unsigned char si_flags[2] ;
};
#line 264 "./../include/elf/external.h"
typedef struct __anonstruct_Elf_External_Syminfo_1006031674 Elf_External_Syminfo;
#line 68 "./../include/elf/internal.h"
struct elf_internal_ehdr {
   unsigned char e_ident[16] ;
   bfd_vma e_entry ;
   bfd_size_type e_phoff ;
   bfd_size_type e_shoff ;
   unsigned long e_version ;
   unsigned long e_flags ;
   unsigned short e_type ;
   unsigned short e_machine ;
   unsigned int e_ehsize ;
   unsigned int e_phentsize ;
   unsigned int e_phnum ;
   unsigned int e_shentsize ;
   unsigned int e_shnum ;
   unsigned int e_shstrndx ;
};
#line 68 "./../include/elf/internal.h"
typedef struct elf_internal_ehdr Elf_Internal_Ehdr;
#line 87 "./../include/elf/internal.h"
struct elf_internal_phdr {
   unsigned long p_type ;
   unsigned long p_flags ;
   bfd_vma p_offset ;
   bfd_vma p_vaddr ;
   bfd_vma p_paddr ;
   bfd_vma p_filesz ;
   bfd_vma p_memsz ;
   bfd_vma p_align ;
};
#line 98 "./../include/elf/internal.h"
typedef struct elf_internal_phdr Elf_Internal_Phdr;
#line 102 "./../include/elf/internal.h"
struct elf_internal_shdr {
   unsigned int sh_name ;
   unsigned int sh_type ;
   bfd_vma sh_flags ;
   bfd_vma sh_addr ;
   file_ptr sh_offset ;
   bfd_size_type sh_size ;
   unsigned int sh_link ;
   unsigned int sh_info ;
   bfd_vma sh_addralign ;
   bfd_size_type sh_entsize ;
   asection *bfd_section ;
   unsigned char *contents ;
};
#line 102 "./../include/elf/internal.h"
typedef struct elf_internal_shdr Elf_Internal_Shdr;
#line 121 "./../include/elf/internal.h"
struct elf_internal_sym {
   bfd_vma st_value ;
   bfd_vma st_size ;
   unsigned long st_name ;
   unsigned char st_info ;
   unsigned char st_other ;
   unsigned char st_target_internal ;
   unsigned int st_shndx ;
};
#line 131 "./../include/elf/internal.h"
typedef struct elf_internal_sym Elf_Internal_Sym;
#line 135 "./../include/elf/internal.h"
struct elf_internal_note {
   unsigned long namesz ;
   unsigned long descsz ;
   unsigned long type ;
   char *namedata ;
   char *descdata ;
   bfd_vma descpos ;
};
#line 135 "./../include/elf/internal.h"
typedef struct elf_internal_note Elf_Internal_Note;
#line 146 "./../include/elf/internal.h"
struct elf_internal_rela {
   bfd_vma r_offset ;
   bfd_vma r_info ;
   bfd_vma r_addend ;
};
#line 146 "./../include/elf/internal.h"
typedef struct elf_internal_rela Elf_Internal_Rela;
#line 154 "./../include/elf/internal.h"
union __anonunion_d_un_138939745 {
   bfd_vma d_val ;
   bfd_vma d_ptr ;
};
#line 154 "./../include/elf/internal.h"
struct elf_internal_dyn {
   bfd_vma d_tag ;
   union __anonunion_d_un_138939745 d_un ;
};
#line 154 "./../include/elf/internal.h"
typedef struct elf_internal_dyn Elf_Internal_Dyn;
#line 166
struct elf_internal_verdaux ;
#line 166 "./../include/elf/internal.h"
struct elf_internal_verdef {
   unsigned short vd_version ;
   unsigned short vd_flags ;
   unsigned short vd_ndx ;
   unsigned short vd_cnt ;
   unsigned long vd_hash ;
   unsigned long vd_aux ;
   unsigned long vd_next ;
   bfd *vd_bfd ;
   char const   *vd_nodename ;
   struct elf_internal_verdef *vd_nextdef ;
   struct elf_internal_verdaux *vd_auxptr ;
   unsigned int vd_exp_refno ;
};
#line 166 "./../include/elf/internal.h"
typedef struct elf_internal_verdef Elf_Internal_Verdef;
#line 186 "./../include/elf/internal.h"
struct elf_internal_verdaux {
   unsigned long vda_name ;
   unsigned long vda_next ;
   char const   *vda_nodename ;
   struct elf_internal_verdaux *vda_nextptr ;
};
#line 186 "./../include/elf/internal.h"
typedef struct elf_internal_verdaux Elf_Internal_Verdaux;
#line 198
struct elf_internal_vernaux ;
#line 198 "./../include/elf/internal.h"
struct elf_internal_verneed {
   unsigned short vn_version ;
   unsigned short vn_cnt ;
   unsigned long vn_file ;
   unsigned long vn_aux ;
   unsigned long vn_next ;
   bfd *vn_bfd ;
   char const   *vn_filename ;
   struct elf_internal_vernaux *vn_auxptr ;
   struct elf_internal_verneed *vn_nextref ;
};
#line 198 "./../include/elf/internal.h"
typedef struct elf_internal_verneed Elf_Internal_Verneed;
#line 215 "./../include/elf/internal.h"
struct elf_internal_vernaux {
   unsigned long vna_hash ;
   unsigned short vna_flags ;
   unsigned short vna_other ;
   unsigned long vna_name ;
   unsigned long vna_next ;
   char const   *vna_nodename ;
   struct elf_internal_vernaux *vna_nextptr ;
};
#line 215 "./../include/elf/internal.h"
typedef struct elf_internal_vernaux Elf_Internal_Vernaux;
#line 236 "./../include/elf/internal.h"
struct __anonstruct_Elf_Internal_Syminfo_674933912 {
   unsigned short si_boundto ;
   unsigned short si_flags ;
};
#line 236 "./../include/elf/internal.h"
typedef struct __anonstruct_Elf_Internal_Syminfo_674933912 Elf_Internal_Syminfo;
#line 214 "./../include/elf/ia64.h"
struct __anonstruct_Elf64_External_VMS_IMAGE_FIXUP_1006031677 {
   unsigned char fixup_offset[8] ;
   unsigned char type[4] ;
   unsigned char fixup_seg[4] ;
   unsigned char addend[8] ;
   unsigned char symvec_index[4] ;
   unsigned char data_type[4] ;
};
#line 214 "./../include/elf/ia64.h"
typedef struct __anonstruct_Elf64_External_VMS_IMAGE_FIXUP_1006031677 Elf64_External_VMS_IMAGE_FIXUP;
#line 224 "./../include/elf/ia64.h"
struct __anonstruct_Elf64_External_VMS_IMAGE_RELA_1006031678 {
   unsigned char rela_offset[8] ;
   unsigned char type[4] ;
   unsigned char rela_seg[4] ;
   unsigned char addend[8] ;
   unsigned char sym_offset[8] ;
   unsigned char sym_seg[4] ;
   unsigned char fill_1[4] ;
};
#line 224 "./../include/elf/ia64.h"
typedef struct __anonstruct_Elf64_External_VMS_IMAGE_RELA_1006031678 Elf64_External_VMS_IMAGE_RELA;
#line 237 "./../include/elf/ia64.h"
struct __anonstruct_Elf64_External_VMS_Note_1006031679 {
   unsigned char namesz[8] ;
   unsigned char descsz[8] ;
   unsigned char type[8] ;
   char name[1] ;
};
#line 237 "./../include/elf/ia64.h"
typedef struct __anonstruct_Elf64_External_VMS_Note_1006031679 Elf64_External_VMS_Note;
#line 430 "./../include/elf/mips.h"
struct __anonstruct_Elf32_Lib_725717072 {
   unsigned long l_name ;
   unsigned long l_time_stamp ;
   unsigned long l_checksum ;
   unsigned long l_version ;
   unsigned long l_flags ;
};
#line 430 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_Lib_725717072 Elf32_Lib;
#line 445 "./../include/elf/mips.h"
struct __anonstruct_Elf32_External_Lib_1006031681 {
   unsigned char l_name[4] ;
   unsigned char l_time_stamp[4] ;
   unsigned char l_checksum[4] ;
   unsigned char l_version[4] ;
   unsigned char l_flags[4] ;
};
#line 445 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_External_Lib_1006031681 Elf32_External_Lib;
#line 478 "./../include/elf/mips.h"
typedef unsigned long Elf32_Conflict;
#line 479 "./../include/elf/mips.h"
typedef unsigned char Elf32_External_Conflict[4];
#line 482 "./../include/elf/mips.h"
typedef unsigned char Elf64_External_Conflict[8];
#line 528 "./../include/elf/mips.h"
struct __anonstruct_Elf32_RegInfo_1006031684 {
   unsigned long ri_gprmask ;
   unsigned long ri_cprmask[4] ;
   long ri_gp_value ;
};
#line 528 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_RegInfo_1006031684 Elf32_RegInfo;
#line 539 "./../include/elf/mips.h"
struct __anonstruct_Elf32_External_RegInfo_1006031685 {
   unsigned char ri_gprmask[4] ;
   unsigned char ri_cprmask[4][4] ;
   unsigned char ri_gp_value[4] ;
};
#line 539 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf32_External_RegInfo_1006031685 Elf32_External_RegInfo;
#line 942 "./../include/elf/mips.h"
struct __anonstruct_Elf_External_Options_1006031688 {
   unsigned char kind[1] ;
   unsigned char size[1] ;
   unsigned char section[2] ;
   unsigned char info[4] ;
};
#line 942 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf_External_Options_1006031688 Elf_External_Options;
#line 954 "./../include/elf/mips.h"
struct __anonstruct_Elf_Internal_Options_723972842 {
   unsigned char kind ;
   unsigned char size ;
   unsigned short section ;
   unsigned long info ;
};
#line 954 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf_Internal_Options_723972842 Elf_Internal_Options;
#line 1012 "./../include/elf/mips.h"
struct __anonstruct_Elf64_External_RegInfo_1006031689 {
   unsigned char ri_gprmask[4] ;
   unsigned char ri_pad[4] ;
   unsigned char ri_cprmask[4][4] ;
   unsigned char ri_gp_value[8] ;
};
#line 1012 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf64_External_RegInfo_1006031689 Elf64_External_RegInfo;
#line 1024 "./../include/elf/mips.h"
struct __anonstruct_Elf64_Internal_RegInfo_659547826 {
   unsigned long ri_gprmask ;
   unsigned long ri_pad ;
   unsigned long ri_cprmask[4] ;
   bfd_vma ri_gp_value ;
};
#line 1024 "./../include/elf/mips.h"
typedef struct __anonstruct_Elf64_Internal_RegInfo_659547826 Elf64_Internal_RegInfo;
#line 82 "./../include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct group_list {
   struct group_list *next ;
   unsigned int section_index ;
};
#line 213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct group {
   struct group_list *root ;
   unsigned int group_index ;
};
#line 231 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
typedef unsigned char dump_type;
#line 234 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct dump_list_entry {
   char *name ;
   dump_type type ;
   struct dump_list_entry *next ;
};
#line 257
enum print_mode {
    HEX = 0,
    DEC = 1,
    DEC_5 = 2,
    UNSIGNED = 3,
    PREFIX_HEX = 4,
    FULL_HEX = 5,
    LONG_HEX = 6
} ;
#line 257 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
typedef enum print_mode print_mode;
#line 4298 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct __anonstruct_flags_713894858 {
   char const   *str ;
   int len ;
};
#line 5241 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct ia64_vms_dynfixup {
   bfd_vma needed_ident ;
   bfd_vma needed ;
   bfd_vma fixup_needed ;
   bfd_vma fixup_rela_cnt ;
   bfd_vma fixup_rela_off ;
};
#line 5252 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct ia64_vms_dynimgrela {
   bfd_vma img_rela_cnt ;
   bfd_vma img_rela_off ;
};
#line 5420 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct __anonstruct_dynamic_relocations_602783530 {
   char const   *name ;
   int reloc ;
   int size ;
   int rela ;
};
#line 5590 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct absaddr {
   unsigned short section ;
   bfd_vma offset ;
};
#line 5601 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct ia64_unw_table_entry {
   struct absaddr start ;
   struct absaddr end ;
   struct absaddr info ;
};
#line 5608 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct ia64_unw_aux_info {
   struct ia64_unw_table_entry *table ;
   unsigned long table_len ;
   unsigned char *info ;
   unsigned long info_size ;
   bfd_vma info_addr ;
   bfd_vma seg_base ;
   Elf_Internal_Sym *symtab ;
   unsigned long nsyms ;
   char *strtab ;
   unsigned long strtab_size ;
};
#line 5982 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct hppa_unw_table_entry {
   struct absaddr start ;
   struct absaddr end ;
   unsigned int Cannot_unwind : 1 ;
   unsigned int Millicode : 1 ;
   unsigned int Millicode_save_sr0 : 1 ;
   unsigned int Region_description : 2 ;
   unsigned int reserved1 : 1 ;
   unsigned int Entry_SR : 1 ;
   unsigned int Entry_FR : 4 ;
   unsigned int Entry_GR : 5 ;
   unsigned int Args_stored : 1 ;
   unsigned int Variable_Frame : 1 ;
   unsigned int Separate_Package_Body : 1 ;
   unsigned int Frame_Extension_Millicode : 1 ;
   unsigned int Stack_Overflow_Check : 1 ;
   unsigned int Two_Instruction_SP_Increment : 1 ;
   unsigned int Ada_Region : 1 ;
   unsigned int cxx_info : 1 ;
   unsigned int cxx_try_catch : 1 ;
   unsigned int sched_entry_seq : 1 ;
   unsigned int reserved2 : 1 ;
   unsigned int Save_SP : 1 ;
   unsigned int Save_RP : 1 ;
   unsigned int Save_MRP_in_frame : 1 ;
   unsigned int extn_ptr_defined : 1 ;
   unsigned int Cleanup_defined : 1 ;
   unsigned int MPE_XL_interrupt_marker : 1 ;
   unsigned int HP_UX_interrupt_marker : 1 ;
   unsigned int Large_frame : 1 ;
   unsigned int Pseudo_SP_Set : 1 ;
   unsigned int reserved4 : 1 ;
   unsigned int Total_frame_size : 27 ;
};
#line 6019 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct hppa_unw_aux_info {
   struct hppa_unw_table_entry *table ;
   unsigned long table_len ;
   bfd_vma seg_base ;
   Elf_Internal_Sym *symtab ;
   unsigned long nsyms ;
   char *strtab ;
   unsigned long strtab_size ;
};
#line 6313 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct arm_section {
   unsigned char *data ;
   Elf_Internal_Shdr *sec ;
   Elf_Internal_Rela *rela ;
   unsigned long nrelas ;
   unsigned int rel_type ;
   Elf_Internal_Rela *next_rela ;
};
#line 6323 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct arm_unw_aux_info {
   FILE *file ;
   Elf_Internal_Sym *symtab ;
   unsigned long nsyms ;
   char *strtab ;
   unsigned long strtab_size ;
};
#line 6850 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct __anonstruct_regpos_1006031692 {
   unsigned int offset ;
   unsigned int reg ;
};
#line 7270 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct unwind_handler {
   int machtype ;
   void (*handler)(FILE * ) ;
};
#line 7375 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct __anonstruct_flags_85572036 {
   long bit ;
   char const   *str ;
};
#line 10874 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct __anonstruct_arm_attr_public_tag_862478845 {
   int tag ;
   char const   *name ;
   int type ;
   char const   **table ;
};
#line 10874 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
typedef struct __anonstruct_arm_attr_public_tag_862478845 arm_attr_public_tag;
#line 12017 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
struct __anonstruct_l_flags_vals_1006031693 {
   char const   *name ;
   int bit ;
};
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 301 "./../include/libiberty.h"
void *xmalloc(size_t size )  __attribute__((__malloc__)) ;
#line 320
char *xstrndup(char const   *s , size_t n )  __attribute__((__malloc__)) ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrndup.c"
char *xstrndup(char const   *s , size_t n )  __attribute__((__malloc__)) ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrndup.c"
char *xstrndup(char const   *s , size_t n ) 
{ 
  char *result ;
  size_t len ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 51
  tmp___0 = strlen(s);
#line 51
  len = tmp___0;
  }
#line 53
  if (n < len) {
#line 54
    len = n;
  }
  {
#line 56
  tmp___1 = xmalloc(sizeof(char ) * (len + 1UL));
#line 56
  result = (char *)tmp___1;
#line 58
  *(result + len) = (char )'\000';
#line 59
  tmp___2 = memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)s,
                   len);
  }
#line 59
  return ((char *)tmp___2);
}
}
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 259 "./../include/libiberty.h"
char *xstrerror(int errnum ) ;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrerror.c"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 49 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrerror.c"
static char xstrerror_buf[sizeof("undocumented error #%d") + 20UL]  ;
#line 53 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrerror.c"
char *xstrerror(int errnum ) 
{ 
  char *errstr ;

  {
  {
#line 69
  errstr = strerror(errnum);
  }
#line 73
  if (! errstr) {
    {
#line 75
    sprintf((char */* __restrict  */)(xstrerror_buf), (char const   */* __restrict  */)"undocumented error #%d",
            errnum);
#line 76
    errstr = xstrerror_buf;
    }
  }
#line 78
  return (errstr);
}
}
#line 316 "./../include/libiberty.h"
char *xstrdup(char const   *s )  __attribute__((__malloc__)) ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrdup.c"
char *xstrdup(char const   *s )  __attribute__((__malloc__)) ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xstrdup.c"
char *xstrdup(char const   *s ) 
{ 
  register size_t len ;
  size_t tmp___0 ;
  register char *ret ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 33
  tmp___0 = strlen(s);
#line 33
  len = tmp___0 + 1UL;
#line 34
  tmp___1 = xmalloc(sizeof(char ) * len);
#line 34
  ret = (char *)tmp___1;
#line 35
  tmp___2 = memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)s,
                   len);
  }
#line 35
  return ((char *)tmp___2);
}
}
#line 312 "./../include/libiberty.h"
void *xcalloc(size_t nelem , size_t elsize )  __attribute__((__malloc__)) ;
#line 324
void *xmemdup(void const   *input , size_t copy_size , size_t alloc_size )  __attribute__((__malloc__)) ;
#line 34 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmemdup.c"
void *xmemdup(void const   *input , size_t copy_size , size_t alloc_size )  __attribute__((__malloc__)) ;
#line 34 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmemdup.c"
void *xmemdup(void const   *input , size_t copy_size , size_t alloc_size ) 
{ 
  void *output ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 37
  tmp___0 = xcalloc((size_t )1, alloc_size);
#line 37
  output = tmp___0;
#line 38
  tmp___1 = memcpy((void */* __restrict  */)output, (void const   */* __restrict  */)input,
                   copy_size);
  }
#line 38
  return (tmp___1);
}
}
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 288 "./../include/libiberty.h"
 __attribute__((__noreturn__)) void xexit(int code ) ;
#line 292
void xmalloc_set_program_name(char const   *s ) ;
#line 295
 __attribute__((__noreturn__)) void xmalloc_failed(size_t size ) ;
#line 307
void *xrealloc(void *oldmem , size_t size ) ;
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 1044 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) sbrk)(intptr_t __delta ) ;
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
static char const   *name  =    "";
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
static char *first_break  =    (char *)((void *)0);
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
void xmalloc_set_program_name(char const   *s ) 
{ 
  void *tmp___0 ;

  {
#line 108
  name = s;
#line 111
  if ((unsigned long )first_break == (unsigned long )((void *)0)) {
    {
#line 112
    tmp___0 = sbrk((intptr_t )0);
#line 112
    first_break = (char *)tmp___0;
    }
  }
#line 114
  return;
}
}
#line 120
extern char **environ ;
#line 116
 __attribute__((__noreturn__)) void xmalloc_failed(size_t size ) ;
#line 116 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
void xmalloc_failed(size_t size ) 
{ 
  size_t allocated ;
  void *tmp___0 ;
  void *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 123
  if ((unsigned long )first_break != (unsigned long )((void *)0)) {
    {
#line 124
    tmp___0 = sbrk((intptr_t )0);
#line 124
    allocated = (size_t )((char *)tmp___0 - first_break);
    }
  } else {
    {
#line 126
    tmp___1 = sbrk((intptr_t )0);
#line 126
    allocated = (size_t )((char *)tmp___1 - (char *)(& environ));
    }
  }
#line 127
  if (*name) {
#line 127
    tmp___2 = ": ";
  } else {
#line 127
    tmp___2 = "";
  }
  {
#line 127
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s%sout of memory allocating %lu bytes after a total of %lu bytes\n",
          name, tmp___2, size, allocated);
#line 137
  xexit(1);
  }
}
}
#line 140
void *xmalloc(size_t size )  __attribute__((__malloc__)) ;
#line 140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
void *xmalloc(size_t size ) 
{ 
  void *newmem ;

  {
#line 145
  if (size == 0UL) {
#line 146
    size = (size_t )1;
  }
  {
#line 147
  newmem = malloc(size);
  }
#line 148
  if (! newmem) {
    {
#line 149
    xmalloc_failed(size);
    }
  }
#line 151
  return (newmem);
}
}
#line 154
void *xcalloc(size_t nelem , size_t elsize )  __attribute__((__malloc__)) ;
#line 154 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
void *xcalloc(size_t nelem , size_t elsize ) 
{ 
  void *newmem ;

  {
#line 159
  if (nelem == 0UL) {
#line 160
    elsize = (size_t )1;
#line 160
    nelem = elsize;
  } else
#line 159
  if (elsize == 0UL) {
#line 160
    elsize = (size_t )1;
#line 160
    nelem = elsize;
  }
  {
#line 162
  newmem = calloc(nelem, elsize);
  }
#line 163
  if (! newmem) {
    {
#line 164
    xmalloc_failed(nelem * elsize);
    }
  }
#line 166
  return (newmem);
}
}
#line 169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xmalloc.c"
void *xrealloc(void *oldmem , size_t size ) 
{ 
  void *newmem ;

  {
#line 174
  if (size == 0UL) {
#line 175
    size = (size_t )1;
  }
#line 176
  if (! oldmem) {
    {
#line 177
    newmem = malloc(size);
    }
  } else {
    {
#line 179
    newmem = realloc(oldmem, size);
    }
  }
#line 180
  if (! newmem) {
    {
#line 181
    xmalloc_failed(size);
    }
  }
#line 183
  return (newmem);
}
}
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 44 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xexit.c"
void (*_xexit_cleanup)(void)  ;
#line 46
 __attribute__((__noreturn__)) void xexit(int code ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xexit.c"
void xexit(int code ) 
{ 


  {
#line 49
  if ((unsigned long )_xexit_cleanup != (unsigned long )((void *)0)) {
    {
#line 50
    (*_xexit_cleanup)();
    }
  }
  {
#line 51
  exit(code);
  }
}
}
#line 284 "./../include/libiberty.h"
int xatexit(void (*fn)(void) ) ;
#line 43 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xatexit.c"
static void xatexit_cleanup(void) ;
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xatexit.c"
static struct xatexit xatexit_first  ;
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xatexit.c"
static struct xatexit *xatexit_head  =    & xatexit_first;
#line 66 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xatexit.c"
int xatexit(void (*fn)(void) ) 
{ 
  register struct xatexit *p ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 72
  if (! _xexit_cleanup) {
#line 73
    _xexit_cleanup = & xatexit_cleanup;
  }
#line 75
  p = xatexit_head;
#line 76
  if (p->ind >= 32) {
    {
#line 78
    tmp___0 = malloc(sizeof(*p));
#line 78
    p = (struct xatexit *)tmp___0;
    }
#line 78
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 79
      return (-1);
    }
#line 80
    p->ind = 0;
#line 81
    p->next = xatexit_head;
#line 82
    xatexit_head = p;
  }
#line 84
  tmp___1 = p->ind;
#line 84
  (p->ind) ++;
#line 84
  p->fns[tmp___1] = fn;
#line 85
  return (0);
}
}
#line 90 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./xatexit.c"
static void xatexit_cleanup(void) 
{ 
  register struct xatexit *p ;
  register int n ;

  {
#line 96
  p = xatexit_head;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! p) {
#line 96
      goto while_break;
    }
#line 97
    n = p->ind;
    {
#line 97
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 97
      n --;
#line 97
      if (! (n >= 0)) {
#line 97
        goto while_break___0;
      }
      {
#line 98
      (*(p->fns[n]))();
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 96
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 828 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 259 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 237 "./../include/libiberty.h"
int unlink_if_ordinary(char const   *name___0 ) ;
#line 62 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./unlink-if-ordinary.c"
int unlink_if_ordinary(char const   *name___0 ) 
{ 
  struct stat st ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 67
  tmp___1 = lstat((char const   */* __restrict  */)name___0, (struct stat */* __restrict  */)(& st));
  }
#line 67
  if (tmp___1 == 0) {
#line 67
    if ((st.st_mode & 61440U) == 32768U) {
      {
#line 69
      tmp___0 = unlink(name___0);
      }
#line 69
      return (tmp___0);
    } else
#line 67
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 69
      tmp___0 = unlink(name___0);
      }
#line 69
      return (tmp___0);
    }
  }
#line 71
  return (1);
}
}
#line 30 "./../include/timeval-utils.h"
void timeval_add(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) ;
#line 33
void timeval_sub(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./timeval-utils.c"
void timeval_add(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) 
{ 


  {
#line 56
  result->tv_sec = (__time_t )(a->tv_sec + b->tv_sec);
#line 57
  result->tv_usec = (__suseconds_t )(a->tv_usec + b->tv_usec);
#line 58
  if (result->tv_usec >= 1000000L) {
#line 60
    (result->tv_sec) ++;
#line 61
    result->tv_usec -= 1000000L;
  }
#line 63
  return;
}
}
#line 76 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./timeval-utils.c"
void timeval_sub(struct timeval *result , struct timeval  const  *a , struct timeval  const  *b ) 
{ 


  {
#line 80
  result->tv_sec = (__time_t )(a->tv_sec - b->tv_sec);
#line 81
  result->tv_usec = (__suseconds_t )(a->tv_usec - b->tv_usec);
#line 82
  if (result->tv_usec < 0L) {
#line 84
    (result->tv_sec) --;
#line 85
    result->tv_usec += 1000000L;
  }
#line 87
  return;
}
}
#line 264 "./../include/libiberty.h"
int signo_max(void) ;
#line 276
char const   *strsigno(int signo ) ;
#line 280
int strtosigno(char const   *name___0 ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 51 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static void init_signal_tables(void) ;
#line 78 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static struct signal_info  const  signal_table[34]  = 
#line 78
  {      {(int const   )1, (char const   */* const  */)"SIGHUP"}, 
        {(int const   )2, (char const   */* const  */)"SIGINT"}, 
        {(int const   )3, (char const   */* const  */)"SIGQUIT"}, 
        {(int const   )4, (char const   */* const  */)"SIGILL"}, 
        {(int const   )5, (char const   */* const  */)"SIGTRAP"}, 
        {(int const   )6, (char const   */* const  */)"SIGIOT"}, 
        {(int const   )6, (char const   */* const  */)"SIGABRT"}, 
        {(int const   )8, (char const   */* const  */)"SIGFPE"}, 
        {(int const   )9, (char const   */* const  */)"SIGKILL"}, 
        {(int const   )7, (char const   */* const  */)"SIGBUS"}, 
        {(int const   )11, (char const   */* const  */)"SIGSEGV"}, 
        {(int const   )31, (char const   */* const  */)"SIGSYS"}, 
        {(int const   )13, (char const   */* const  */)"SIGPIPE"}, 
        {(int const   )14, (char const   */* const  */)"SIGALRM"}, 
        {(int const   )15, (char const   */* const  */)"SIGTERM"}, 
        {(int const   )10, (char const   */* const  */)"SIGUSR1"}, 
        {(int const   )12, (char const   */* const  */)"SIGUSR2"}, 
        {(int const   )17, (char const   */* const  */)"SIGCLD"}, 
        {(int const   )17, (char const   */* const  */)"SIGCHLD"}, 
        {(int const   )30, (char const   */* const  */)"SIGPWR"}, 
        {(int const   )28, (char const   */* const  */)"SIGWINCH"}, 
        {(int const   )23, (char const   */* const  */)"SIGURG"}, 
        {(int const   )29, (char const   */* const  */)"SIGIO"}, 
        {(int const   )29, (char const   */* const  */)"SIGPOLL"}, 
        {(int const   )19, (char const   */* const  */)"SIGSTOP"}, 
        {(int const   )20, (char const   */* const  */)"SIGTSTP"}, 
        {(int const   )18, (char const   */* const  */)"SIGCONT"}, 
        {(int const   )21, (char const   */* const  */)"SIGTTIN"}, 
        {(int const   )22, (char const   */* const  */)"SIGTTOU"}, 
        {(int const   )26, (char const   */* const  */)"SIGVTALRM"}, 
        {(int const   )27, (char const   */* const  */)"SIGPROF"}, 
        {(int const   )24, (char const   */* const  */)"SIGXCPU"}, 
        {(int const   )25, (char const   */* const  */)"SIGXFSZ"}, 
        {(int const   )0, (char const   */* const  */)((void *)0)}};
#line 228 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static char const   **signal_names  ;
#line 229 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static int num_signal_names  =    0;
#line 247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static int sys_nsig  =    65;
#line 286 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static void init_signal_tables(void) 
{ 
  struct signal_info  const  *eip ;
  int nbytes ;
  void *tmp___0 ;

  {
#line 295
  if (num_signal_names == 0) {
#line 297
    eip = signal_table;
    {
#line 297
    while (1) {
      while_continue: /* CIL Label */ ;
#line 297
      if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 297
        goto while_break;
      }
#line 299
      if (eip->value >= (int const   )num_signal_names) {
#line 301
        num_signal_names = (int )(eip->value + 1);
      }
#line 297
      eip ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 309
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 311
    nbytes = (int )((unsigned long )num_signal_names * sizeof(char *));
#line 312
    tmp___0 = malloc((size_t )nbytes);
#line 312
    signal_names = (char const   **)tmp___0;
    }
#line 312
    if ((unsigned long )signal_names != (unsigned long )((void *)0)) {
      {
#line 314
      memset((void *)signal_names, 0, (size_t )nbytes);
#line 315
      eip = signal_table;
      }
      {
#line 315
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 315
        if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 315
          goto while_break___0;
        }
#line 317
        *(signal_names + eip->value) = (char const   *)eip->name;
#line 315
        eip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 343
  return;
}
}
#line 367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
int signo_max(void) 
{ 
  int maxsize___0 ;

  {
#line 372
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 374
    init_signal_tables();
    }
  }
#line 376
  if (sys_nsig > num_signal_names) {
#line 376
    maxsize___0 = sys_nsig;
  } else {
#line 376
    maxsize___0 = num_signal_names;
  }
#line 377
  return (maxsize___0 - 1);
}
}
#line 472 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
static char buf[32]  ;
#line 468 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
char const   *strsigno(int signo ) 
{ 
  char const   *name___0 ;

  {
#line 474
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 476
    init_signal_tables();
    }
  }
#line 479
  if (signo < 0) {
#line 482
    name___0 = (char const   *)((void *)0);
  } else
#line 479
  if (signo >= num_signal_names) {
#line 482
    name___0 = (char const   *)((void *)0);
  } else
#line 484
  if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
    {
#line 487
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Signal %d",
            signo);
#line 488
    name___0 = (char const   *)(buf);
    }
  } else
#line 484
  if ((unsigned long )*(signal_names + signo) == (unsigned long )((void *)0)) {
    {
#line 487
    sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)"Signal %d",
            signo);
#line 488
    name___0 = (char const   *)(buf);
    }
  } else {
#line 493
    name___0 = *(signal_names + signo);
  }
#line 496
  return (name___0);
}
}
#line 511 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strsignal.c"
int strtosigno(char const   *name___0 ) 
{ 
  int signo ;
  int tmp___0 ;

  {
#line 514
  signo = 0;
#line 516
  if ((unsigned long )name___0 != (unsigned long )((void *)0)) {
#line 518
    if ((unsigned long )signal_names == (unsigned long )((void *)0)) {
      {
#line 520
      init_signal_tables();
      }
    }
#line 522
    signo = 0;
    {
#line 522
    while (1) {
      while_continue: /* CIL Label */ ;
#line 522
      if (! (signo < num_signal_names)) {
#line 522
        goto while_break;
      }
#line 524
      if ((unsigned long )*(signal_names + signo) != (unsigned long )((void *)0)) {
        {
#line 524
        tmp___0 = strcmp(name___0, *(signal_names + signo));
        }
#line 524
        if (tmp___0 == 0) {
#line 527
          goto while_break;
        }
      }
#line 522
      signo ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 530
    if (signo == num_signal_names) {
#line 532
      signo = 0;
    }
  }
#line 535
  return (signo);
}
}
#line 246 "./../include/libiberty.h"
int errno_max(void) ;
#line 251
char const   *strerrno(int errnoval ) ;
#line 255
int strtoerrno(char const   *name___0 ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
static void init_error_tables(void) ;
#line 74 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
static struct error_info  const  error_table[122]  = 
#line 74
  {      {(int const   )1, (char const   */* const  */)"EPERM"}, 
        {(int const   )2, (char const   */* const  */)"ENOENT"}, 
        {(int const   )3, (char const   */* const  */)"ESRCH"}, 
        {(int const   )4, (char const   */* const  */)"EINTR"}, 
        {(int const   )5, (char const   */* const  */)"EIO"}, 
        {(int const   )6, (char const   */* const  */)"ENXIO"}, 
        {(int const   )7, (char const   */* const  */)"E2BIG"}, 
        {(int const   )8, (char const   */* const  */)"ENOEXEC"}, 
        {(int const   )9, (char const   */* const  */)"EBADF"}, 
        {(int const   )10, (char const   */* const  */)"ECHILD"}, 
        {(int const   )11, (char const   */* const  */)"EWOULDBLOCK"}, 
        {(int const   )11, (char const   */* const  */)"EAGAIN"}, 
        {(int const   )12, (char const   */* const  */)"ENOMEM"}, 
        {(int const   )13, (char const   */* const  */)"EACCES"}, 
        {(int const   )14, (char const   */* const  */)"EFAULT"}, 
        {(int const   )15, (char const   */* const  */)"ENOTBLK"}, 
        {(int const   )16, (char const   */* const  */)"EBUSY"}, 
        {(int const   )17, (char const   */* const  */)"EEXIST"}, 
        {(int const   )18, (char const   */* const  */)"EXDEV"}, 
        {(int const   )19, (char const   */* const  */)"ENODEV"}, 
        {(int const   )20, (char const   */* const  */)"ENOTDIR"}, 
        {(int const   )21, (char const   */* const  */)"EISDIR"}, 
        {(int const   )22, (char const   */* const  */)"EINVAL"}, 
        {(int const   )23, (char const   */* const  */)"ENFILE"}, 
        {(int const   )24, (char const   */* const  */)"EMFILE"}, 
        {(int const   )25, (char const   */* const  */)"ENOTTY"}, 
        {(int const   )26, (char const   */* const  */)"ETXTBSY"}, 
        {(int const   )27, (char const   */* const  */)"EFBIG"}, 
        {(int const   )28, (char const   */* const  */)"ENOSPC"}, 
        {(int const   )29, (char const   */* const  */)"ESPIPE"}, 
        {(int const   )30, (char const   */* const  */)"EROFS"}, 
        {(int const   )31, (char const   */* const  */)"EMLINK"}, 
        {(int const   )32, (char const   */* const  */)"EPIPE"}, 
        {(int const   )33, (char const   */* const  */)"EDOM"}, 
        {(int const   )34, (char const   */* const  */)"ERANGE"}, 
        {(int const   )42, (char const   */* const  */)"ENOMSG"}, 
        {(int const   )43, (char const   */* const  */)"EIDRM"}, 
        {(int const   )44, (char const   */* const  */)"ECHRNG"}, 
        {(int const   )45, (char const   */* const  */)"EL2NSYNC"}, 
        {(int const   )46, (char const   */* const  */)"EL3HLT"}, 
        {(int const   )47, (char const   */* const  */)"EL3RST"}, 
        {(int const   )48, (char const   */* const  */)"ELNRNG"}, 
        {(int const   )49, (char const   */* const  */)"EUNATCH"}, 
        {(int const   )50, (char const   */* const  */)"ENOCSI"}, 
        {(int const   )51, (char const   */* const  */)"EL2HLT"}, 
        {(int const   )35, (char const   */* const  */)"EDEADLK"}, 
        {(int const   )37, (char const   */* const  */)"ENOLCK"}, 
        {(int const   )52, (char const   */* const  */)"EBADE"}, 
        {(int const   )53, (char const   */* const  */)"EBADR"}, 
        {(int const   )54, (char const   */* const  */)"EXFULL"}, 
        {(int const   )55, (char const   */* const  */)"ENOANO"}, 
        {(int const   )56, (char const   */* const  */)"EBADRQC"}, 
        {(int const   )57, (char const   */* const  */)"EBADSLT"}, 
        {(int const   )35, (char const   */* const  */)"EDEADLOCK"}, 
        {(int const   )59, (char const   */* const  */)"EBFONT"}, 
        {(int const   )60, (char const   */* const  */)"ENOSTR"}, 
        {(int const   )61, (char const   */* const  */)"ENODATA"}, 
        {(int const   )62, (char const   */* const  */)"ETIME"}, 
        {(int const   )63, (char const   */* const  */)"ENOSR"}, 
        {(int const   )64, (char const   */* const  */)"ENONET"}, 
        {(int const   )65, (char const   */* const  */)"ENOPKG"}, 
        {(int const   )66, (char const   */* const  */)"EREMOTE"}, 
        {(int const   )67, (char const   */* const  */)"ENOLINK"}, 
        {(int const   )68, (char const   */* const  */)"EADV"}, 
        {(int const   )69, (char const   */* const  */)"ESRMNT"}, 
        {(int const   )70, (char const   */* const  */)"ECOMM"}, 
        {(int const   )71, (char const   */* const  */)"EPROTO"}, 
        {(int const   )72, (char const   */* const  */)"EMULTIHOP"}, 
        {(int const   )73, (char const   */* const  */)"EDOTDOT"}, 
        {(int const   )74, (char const   */* const  */)"EBADMSG"}, 
        {(int const   )36, (char const   */* const  */)"ENAMETOOLONG"}, 
        {(int const   )75, (char const   */* const  */)"EOVERFLOW"}, 
        {(int const   )76, (char const   */* const  */)"ENOTUNIQ"}, 
        {(int const   )77, (char const   */* const  */)"EBADFD"}, 
        {(int const   )78, (char const   */* const  */)"EREMCHG"}, 
        {(int const   )79, (char const   */* const  */)"ELIBACC"}, 
        {(int const   )80, (char const   */* const  */)"ELIBBAD"}, 
        {(int const   )81, (char const   */* const  */)"ELIBSCN"}, 
        {(int const   )82, (char const   */* const  */)"ELIBMAX"}, 
        {(int const   )83, (char const   */* const  */)"ELIBEXEC"}, 
        {(int const   )84, (char const   */* const  */)"EILSEQ"}, 
        {(int const   )38, (char const   */* const  */)"ENOSYS"}, 
        {(int const   )40, (char const   */* const  */)"ELOOP"}, 
        {(int const   )85, (char const   */* const  */)"ERESTART"}, 
        {(int const   )86, (char const   */* const  */)"ESTRPIPE"}, 
        {(int const   )39, (char const   */* const  */)"ENOTEMPTY"}, 
        {(int const   )87, (char const   */* const  */)"EUSERS"}, 
        {(int const   )88, (char const   */* const  */)"ENOTSOCK"}, 
        {(int const   )89, (char const   */* const  */)"EDESTADDRREQ"}, 
        {(int const   )90, (char const   */* const  */)"EMSGSIZE"}, 
        {(int const   )91, (char const   */* const  */)"EPROTOTYPE"}, 
        {(int const   )92, (char const   */* const  */)"ENOPROTOOPT"}, 
        {(int const   )93, (char const   */* const  */)"EPROTONOSUPPORT"}, 
        {(int const   )94, (char const   */* const  */)"ESOCKTNOSUPPORT"}, 
        {(int const   )95, (char const   */* const  */)"EOPNOTSUPP"}, 
        {(int const   )96, (char const   */* const  */)"EPFNOSUPPORT"}, 
        {(int const   )97, (char const   */* const  */)"EAFNOSUPPORT"}, 
        {(int const   )98, (char const   */* const  */)"EADDRINUSE"}, 
        {(int const   )99, (char const   */* const  */)"EADDRNOTAVAIL"}, 
        {(int const   )100, (char const   */* const  */)"ENETDOWN"}, 
        {(int const   )101, (char const   */* const  */)"ENETUNREACH"}, 
        {(int const   )102, (char const   */* const  */)"ENETRESET"}, 
        {(int const   )103, (char const   */* const  */)"ECONNABORTED"}, 
        {(int const   )104, (char const   */* const  */)"ECONNRESET"}, 
        {(int const   )105, (char const   */* const  */)"ENOBUFS"}, 
        {(int const   )106, (char const   */* const  */)"EISCONN"}, 
        {(int const   )107, (char const   */* const  */)"ENOTCONN"}, 
        {(int const   )108, (char const   */* const  */)"ESHUTDOWN"}, 
        {(int const   )109, (char const   */* const  */)"ETOOMANYREFS"}, 
        {(int const   )110, (char const   */* const  */)"ETIMEDOUT"}, 
        {(int const   )111, (char const   */* const  */)"ECONNREFUSED"}, 
        {(int const   )112, (char const   */* const  */)"EHOSTDOWN"}, 
        {(int const   )113, (char const   */* const  */)"EHOSTUNREACH"}, 
        {(int const   )114, (char const   */* const  */)"EALREADY"}, 
        {(int const   )115, (char const   */* const  */)"EINPROGRESS"}, 
        {(int const   )116, (char const   */* const  */)"ESTALE"}, 
        {(int const   )117, (char const   */* const  */)"EUCLEAN"}, 
        {(int const   )118, (char const   */* const  */)"ENOTNAM"}, 
        {(int const   )119, (char const   */* const  */)"ENAVAIL"}, 
        {(int const   )120, (char const   */* const  */)"EISNAM"}, 
        {(int const   )121, (char const   */* const  */)"EREMOTEIO"}, 
        {(int const   )0, (char const   */* const  */)((void *)0)}};
#line 452 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
static char const   **error_names  ;
#line 453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
static int num_error_names  =    0;
#line 472
extern int sys_nerr ;
#line 505 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
static void init_error_tables(void) 
{ 
  struct error_info  const  *eip ;
  int nbytes ;
  void *tmp___0 ;

  {
#line 514
  if (num_error_names == 0) {
#line 516
    eip = error_table;
    {
#line 516
    while (1) {
      while_continue: /* CIL Label */ ;
#line 516
      if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 516
        goto while_break;
      }
#line 518
      if (eip->value >= (int const   )num_error_names) {
#line 520
        num_error_names = (int )(eip->value + 1);
      }
#line 516
      eip ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 528
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 530
    nbytes = (int )((unsigned long )num_error_names * sizeof(char *));
#line 531
    tmp___0 = malloc((size_t )nbytes);
#line 531
    error_names = (char const   **)tmp___0;
    }
#line 531
    if ((unsigned long )error_names != (unsigned long )((void *)0)) {
      {
#line 533
      memset((void *)error_names, 0, (size_t )nbytes);
#line 534
      eip = error_table;
      }
      {
#line 534
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 534
        if (! ((unsigned long )eip->name != (unsigned long )((void *)0))) {
#line 534
          goto while_break___0;
        }
#line 536
        *(error_names + eip->value) = (char const   *)eip->name;
#line 534
        eip ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 562
  return;
}
}
#line 586 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
int errno_max(void) 
{ 
  int maxsize___0 ;

  {
#line 591
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 593
    init_error_tables();
    }
  }
#line 595
  if (sys_nerr > num_error_names) {
#line 595
    maxsize___0 = sys_nerr;
  } else {
#line 595
    maxsize___0 = num_error_names;
  }
#line 596
  return (maxsize___0 - 1);
}
}
#line 695 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
static char buf___0[32]  ;
#line 691 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
char const   *strerrno(int errnoval ) 
{ 
  char const   *name___0 ;

  {
#line 697
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 699
    init_error_tables();
    }
  }
#line 702
  if (errnoval < 0) {
#line 710
    name___0 = (char const   *)((void *)0);
  } else
#line 702
  if (errnoval >= num_error_names) {
#line 710
    name___0 = (char const   *)((void *)0);
  } else
#line 712
  if ((unsigned long )error_names == (unsigned long )((void *)0)) {
    {
#line 715
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Error %d",
            errnoval);
#line 716
    name___0 = (char const   *)(buf___0);
    }
  } else
#line 712
  if ((unsigned long )*(error_names + errnoval) == (unsigned long )((void *)0)) {
    {
#line 715
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"Error %d",
            errnoval);
#line 716
    name___0 = (char const   *)(buf___0);
    }
  } else {
#line 721
    name___0 = *(error_names + errnoval);
  }
#line 724
  return (name___0);
}
}
#line 738 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./strerror.c"
int strtoerrno(char const   *name___0 ) 
{ 
  int errnoval ;
  int tmp___0 ;

  {
#line 741
  errnoval = 0;
#line 743
  if ((unsigned long )name___0 != (unsigned long )((void *)0)) {
#line 745
    if ((unsigned long )error_names == (unsigned long )((void *)0)) {
      {
#line 747
      init_error_tables();
      }
    }
#line 749
    errnoval = 0;
    {
#line 749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 749
      if (! (errnoval < num_error_names)) {
#line 749
        goto while_break;
      }
#line 751
      if ((unsigned long )*(error_names + errnoval) != (unsigned long )((void *)0)) {
        {
#line 751
        tmp___0 = strcmp(name___0, *(error_names + errnoval));
        }
#line 751
        if (tmp___0 == 0) {
#line 754
          goto while_break;
        }
      }
#line 749
      errnoval ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 757
    if (errnoval == num_error_names) {
#line 764
      errnoval = 0;
    }
  }
#line 767
  return (errnoval);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./stack-limit.c"
void stack_limit_increase(unsigned long pref  __attribute__((__unused__)) ) 
{ 
  struct rlimit rlim ;
  int tmp___0 ;

  {
  {
#line 52
  tmp___0 = getrlimit(3, & rlim);
  }
#line 52
  if (tmp___0 == 0) {
#line 52
    if (rlim.rlim_cur != 0xffffffffffffffffUL) {
#line 52
      if (rlim.rlim_cur < pref) {
#line 52
        if (rlim.rlim_max == 0xffffffffffffffffUL) {
#line 52
          goto _L;
        } else
#line 52
        if (rlim.rlim_cur < rlim.rlim_max) {
          _L: /* CIL Label */ 
#line 57
          rlim.rlim_cur = pref;
#line 58
          if (rlim.rlim_max != 0xffffffffffffffffUL) {
#line 58
            if (rlim.rlim_cur > rlim.rlim_max) {
#line 59
              rlim.rlim_cur = rlim.rlim_max;
            }
          }
          {
#line 60
          setrlimit(3, (struct rlimit  const  *)(& rlim));
          }
        }
      }
    }
  }
#line 63
  return;
}
}
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 127 "./../include/splay-tree.h"
splay_tree splay_tree_new(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                          void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ) ;
#line 130
splay_tree splay_tree_new_with_allocator(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                         void (*delete_key_fn)(splay_tree_key  ) ,
                                         void (*delete_value_fn)(splay_tree_value  ) ,
                                         void *(*allocate_fn)(int  , void * ) , void (*deallocate_fn)(void * ,
                                                                                                      void * ) ,
                                         void *allocate_data ) ;
#line 136
splay_tree splay_tree_new_typed_alloc(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                      void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ,
                                      void *(*tree_allocate_fn)(int  , void * ) ,
                                      void *(*node_allocate_fn)(int  , void * ) ,
                                      void (*deallocate_fn)(void * , void * ) , void *allocate_data ) ;
#line 143
void splay_tree_delete(splay_tree sp ) ;
#line 144
splay_tree_node splay_tree_insert(splay_tree sp , splay_tree_key key , splay_tree_value value ) ;
#line 147
void splay_tree_remove(splay_tree sp , splay_tree_key key ) ;
#line 148
splay_tree_node splay_tree_lookup(splay_tree sp , splay_tree_key key ) ;
#line 149
splay_tree_node splay_tree_predecessor(splay_tree sp , splay_tree_key key ) ;
#line 150
splay_tree_node splay_tree_successor(splay_tree sp , splay_tree_key key ) ;
#line 151
splay_tree_node splay_tree_max(splay_tree sp ) ;
#line 152
splay_tree_node splay_tree_min(splay_tree sp ) ;
#line 153
int splay_tree_foreach(splay_tree sp , int (*fn)(splay_tree_node  , void * ) , void *data ) ;
#line 154
int splay_tree_compare_ints(splay_tree_key k1 , splay_tree_key k2 ) ;
#line 155
int splay_tree_compare_pointers(splay_tree_key k1 , splay_tree_key k2 ) ;
#line 41 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
static void splay_tree_delete_helper(splay_tree sp , splay_tree_node node ) ;
#line 42
__inline static void rotate_left(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) ;
#line 44
__inline static void rotate_right(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) ;
#line 46
static void splay_tree_splay(splay_tree sp , splay_tree_key key ) ;
#line 47
static int splay_tree_foreach_helper(splay_tree_node node , int (*fn)(splay_tree_node  ,
                                                                      void * ) , void *data ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
static void splay_tree_delete_helper(splay_tree sp , splay_tree_node node ) 
{ 
  splay_tree_node pending ;
  splay_tree_node active ;
  splay_tree_node temp ;

  {
#line 55
  pending = (splay_tree_node )0;
#line 56
  active = (splay_tree_node )0;
#line 58
  if (! node) {
#line 59
    return;
  }
#line 64
  if (sp->delete_key) {
    {
#line 64
    (*(sp->delete_key))(node->key);
    }
  }
#line 65
  if (sp->delete_value) {
    {
#line 65
    (*(sp->delete_value))(node->value);
    }
  }
#line 68
  node->key = (splay_tree_key )pending;
#line 69
  pending = node;
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
#line 75
    if (! pending) {
#line 75
      goto while_break;
    }
#line 77
    active = pending;
#line 78
    pending = (splay_tree_node )0;
    {
#line 79
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 79
      if (! active) {
#line 79
        goto while_break___0;
      }
#line 86
      if (active->left) {
#line 88
        if (sp->delete_key) {
          {
#line 88
          (*(sp->delete_key))((active->left)->key);
          }
        }
#line 89
        if (sp->delete_value) {
          {
#line 89
          (*(sp->delete_value))((active->left)->value);
          }
        }
#line 90
        (active->left)->key = (splay_tree_key )pending;
#line 91
        pending = active->left;
      }
#line 93
      if (active->right) {
#line 95
        if (sp->delete_key) {
          {
#line 95
          (*(sp->delete_key))((active->right)->key);
          }
        }
#line 96
        if (sp->delete_value) {
          {
#line 96
          (*(sp->delete_value))((active->right)->value);
          }
        }
#line 97
        (active->right)->key = (splay_tree_key )pending;
#line 98
        pending = active->right;
      }
      {
#line 101
      temp = active;
#line 102
      active = (splay_tree_node )temp->key;
#line 103
      (*(sp->deallocate))((void *)((char *)temp), sp->allocate_data);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return;
}
}
#line 113 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
__inline static void rotate_left(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) 
{ 
  splay_tree_node tmp___0 ;

  {
#line 117
  tmp___0 = n->right;
#line 118
  n->right = p;
#line 119
  p->left = tmp___0;
#line 120
  *pp = n;
#line 121
  return;
}
}
#line 126 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
__inline static void rotate_right(splay_tree_node *pp , splay_tree_node p , splay_tree_node n ) 
{ 
  splay_tree_node tmp___0 ;

  {
#line 130
  tmp___0 = n->left;
#line 131
  n->left = p;
#line 132
  p->right = tmp___0;
#line 133
  *pp = n;
#line 134
  return;
}
}
#line 138 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
static void splay_tree_splay(splay_tree sp , splay_tree_key key ) 
{ 
  int cmp1 ;
  int cmp2 ;
  splay_tree_node n ;
  splay_tree_node c ;

  {
#line 141
  if ((unsigned long )sp->root == (unsigned long )((splay_tree_node )0)) {
#line 142
    return;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    n = sp->root;
#line 149
    cmp1 = (*(sp->comp))(key, n->key);
    }
#line 152
    if (cmp1 == 0) {
#line 153
      return;
    }
#line 156
    if (cmp1 < 0) {
#line 157
      c = n->left;
    } else {
#line 159
      c = n->right;
    }
#line 160
    if (! c) {
#line 161
      return;
    }
    {
#line 165
    cmp2 = (*(sp->comp))(key, c->key);
    }
#line 166
    if (cmp2 == 0) {
#line 166
      goto _L;
    } else
#line 166
    if (cmp2 < 0) {
#line 166
      if (! c->left) {
#line 166
        goto _L;
      } else {
#line 166
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 166
    if (cmp2 > 0) {
#line 166
      if (! c->right) {
        _L: /* CIL Label */ 
#line 170
        if (cmp1 < 0) {
          {
#line 171
          rotate_left(& sp->root, n, c);
          }
        } else {
          {
#line 173
          rotate_right(& sp->root, n, c);
          }
        }
#line 174
        return;
      }
    }
#line 178
    if (cmp1 < 0) {
#line 178
      if (cmp2 < 0) {
        {
#line 180
        rotate_left(& n->left, c, c->left);
#line 181
        rotate_left(& sp->root, n, n->left);
        }
      } else {
#line 178
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 183
    if (cmp1 > 0) {
#line 183
      if (cmp2 > 0) {
        {
#line 185
        rotate_right(& n->right, c, c->right);
#line 186
        rotate_right(& sp->root, n, n->right);
        }
      } else {
#line 183
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 188
    if (cmp1 < 0) {
#line 188
      if (cmp2 > 0) {
        {
#line 190
        rotate_right(& n->left, c, c->right);
#line 191
        rotate_left(& sp->root, n, n->left);
        }
      } else {
#line 188
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 193
    if (cmp1 > 0) {
#line 193
      if (cmp2 < 0) {
        {
#line 195
        rotate_left(& n->right, c, c->left);
#line 196
        rotate_right(& sp->root, n, n->right);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
static int splay_tree_foreach_helper(splay_tree_node node , int (*fn)(splay_tree_node  ,
                                                                      void * ) , void *data ) 
{ 
  int val ;
  splay_tree_node *stack ;
  int stack_ptr ;
  int stack_size ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 219
  stack_size = 100;
#line 220
  stack_ptr = 0;
#line 221
  tmp___0 = xmalloc(sizeof(splay_tree_node ) * (unsigned long )stack_size);
#line 221
  stack = (splay_tree_node *)tmp___0;
#line 222
  val = 0;
  }
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! ((unsigned long )node != (unsigned long )((void *)0))) {
#line 226
        goto while_break___0;
      }
#line 228
      if (stack_ptr == stack_size) {
        {
#line 230
        stack_size *= 2;
#line 231
        tmp___1 = xrealloc((void *)stack, sizeof(splay_tree_node ) * (unsigned long )stack_size);
#line 231
        stack = (splay_tree_node *)tmp___1;
        }
      }
#line 233
      tmp___2 = stack_ptr;
#line 233
      stack_ptr ++;
#line 233
      *(stack + tmp___2) = node;
#line 234
      node = node->left;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 237
    if (stack_ptr == 0) {
#line 238
      goto while_break;
    }
    {
#line 240
    stack_ptr --;
#line 240
    node = *(stack + stack_ptr);
#line 242
    val = (*fn)(node, data);
    }
#line 243
    if (val) {
#line 244
      goto while_break;
    }
#line 246
    node = node->right;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 249
  free((void *)stack);
  }
#line 250
  return (val);
}
}
#line 254 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
static void *splay_tree_xmalloc_allocate(int size , void *data  __attribute__((__unused__)) ) 
{ 
  void *tmp___0 ;

  {
  {
#line 257
  tmp___0 = xmalloc((size_t )size);
  }
#line 257
  return (tmp___0);
}
}
#line 260 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
static void splay_tree_xmalloc_deallocate(void *object , void *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 263
  free(object);
  }
#line 264
  return;
}
}
#line 272 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree splay_tree_new(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                          void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ) 
{ 
  splay_tree tmp___0 ;

  {
  {
#line 277
  tmp___0 = splay_tree_new_with_allocator(compare_fn, delete_key_fn, delete_value_fn,
                                          & splay_tree_xmalloc_allocate, & splay_tree_xmalloc_deallocate,
                                          (void *)0);
  }
#line 277
  return (tmp___0);
}
}
#line 287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree splay_tree_new_with_allocator(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                         void (*delete_key_fn)(splay_tree_key  ) ,
                                         void (*delete_value_fn)(splay_tree_value  ) ,
                                         void *(*allocate_fn)(int  , void * ) , void (*deallocate_fn)(void * ,
                                                                                                      void * ) ,
                                         void *allocate_data ) 
{ 
  splay_tree tmp___0 ;

  {
  {
#line 295
  tmp___0 = splay_tree_new_typed_alloc(compare_fn, delete_key_fn, delete_value_fn,
                                       allocate_fn, allocate_fn, deallocate_fn, allocate_data);
  }
#line 295
  return (tmp___0);
}
}
#line 325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree splay_tree_new_typed_alloc(int (*compare_fn)(splay_tree_key  , splay_tree_key  ) ,
                                      void (*delete_key_fn)(splay_tree_key  ) , void (*delete_value_fn)(splay_tree_value  ) ,
                                      void *(*tree_allocate_fn)(int  , void * ) ,
                                      void *(*node_allocate_fn)(int  , void * ) ,
                                      void (*deallocate_fn)(void * , void * ) , void *allocate_data ) 
{ 
  splay_tree sp ;
  void *tmp___0 ;

  {
  {
#line 334
  tmp___0 = (*tree_allocate_fn)((int )sizeof(struct splay_tree_s ), allocate_data);
#line 334
  sp = (splay_tree )tmp___0;
#line 337
  sp->root = (splay_tree_node )0;
#line 338
  sp->comp = compare_fn;
#line 339
  sp->delete_key = delete_key_fn;
#line 340
  sp->delete_value = delete_value_fn;
#line 341
  sp->allocate = node_allocate_fn;
#line 342
  sp->deallocate = deallocate_fn;
#line 343
  sp->allocate_data = allocate_data;
  }
#line 345
  return (sp);
}
}
#line 350 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
void splay_tree_delete(splay_tree sp ) 
{ 


  {
  {
#line 353
  splay_tree_delete_helper(sp, sp->root);
#line 354
  (*(sp->deallocate))((void *)((char *)sp), sp->allocate_data);
  }
#line 355
  return;
}
}
#line 361 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree_node splay_tree_insert(splay_tree sp , splay_tree_key key , splay_tree_value value ) 
{ 
  int comparison ;
  splay_tree_node node ;
  void *tmp___0 ;
  splay_tree_node tmp___1 ;

  {
  {
#line 364
  comparison = 0;
#line 366
  splay_tree_splay(sp, key);
  }
#line 368
  if (sp->root) {
    {
#line 369
    comparison = (*(sp->comp))((sp->root)->key, key);
    }
  }
#line 371
  if (sp->root) {
#line 371
    if (comparison == 0) {
#line 375
      if (sp->delete_value) {
        {
#line 376
        (*(sp->delete_value))((sp->root)->value);
        }
      }
#line 377
      (sp->root)->value = value;
    } else {
#line 371
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 384
    tmp___0 = (*(sp->allocate))((int )sizeof(struct splay_tree_node_s ), sp->allocate_data);
#line 384
    node = (splay_tree_node )tmp___0;
#line 387
    node->key = key;
#line 388
    node->value = value;
    }
#line 390
    if (! sp->root) {
#line 391
      tmp___1 = (splay_tree_node )0;
#line 391
      node->right = tmp___1;
#line 391
      node->left = tmp___1;
    } else
#line 392
    if (comparison < 0) {
#line 394
      node->left = sp->root;
#line 395
      node->right = (node->left)->right;
#line 396
      (node->left)->right = (splay_tree_node )0;
    } else {
#line 400
      node->right = sp->root;
#line 401
      node->left = (node->right)->left;
#line 402
      (node->right)->left = (splay_tree_node )0;
    }
#line 405
    sp->root = node;
  }
#line 408
  return (sp->root);
}
}
#line 413 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
void splay_tree_remove(splay_tree sp , splay_tree_key key ) 
{ 
  splay_tree_node left ;
  splay_tree_node right ;
  int tmp___0 ;

  {
  {
#line 416
  splay_tree_splay(sp, key);
  }
#line 418
  if (sp->root) {
    {
#line 418
    tmp___0 = (*(sp->comp))((sp->root)->key, key);
    }
#line 418
    if (tmp___0 == 0) {
#line 422
      left = (sp->root)->left;
#line 423
      right = (sp->root)->right;
#line 426
      if (sp->delete_value) {
        {
#line 427
        (*(sp->delete_value))((sp->root)->value);
        }
      }
      {
#line 428
      (*(sp->deallocate))((void *)sp->root, sp->allocate_data);
      }
#line 432
      if (left) {
#line 434
        sp->root = left;
#line 438
        if (right) {
          {
#line 440
          while (1) {
            while_continue: /* CIL Label */ ;
#line 440
            if (! left->right) {
#line 440
              goto while_break;
            }
#line 441
            left = left->right;
          }
          while_break: /* CIL Label */ ;
          }
#line 442
          left->right = right;
        }
      } else {
#line 446
        sp->root = right;
      }
    }
  }
#line 448
  return;
}
}
#line 453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree_node splay_tree_lookup(splay_tree sp , splay_tree_key key ) 
{ 
  int tmp___0 ;

  {
  {
#line 456
  splay_tree_splay(sp, key);
  }
#line 458
  if (sp->root) {
    {
#line 458
    tmp___0 = (*(sp->comp))((sp->root)->key, key);
    }
#line 458
    if (tmp___0 == 0) {
#line 459
      return (sp->root);
    } else {
#line 461
      return ((splay_tree_node )0);
    }
  } else {
#line 461
    return ((splay_tree_node )0);
  }
}
}
#line 466 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree_node splay_tree_max(splay_tree sp ) 
{ 
  splay_tree_node n ;

  {
#line 469
  n = sp->root;
#line 471
  if (! n) {
#line 472
    return ((splay_tree_node )((void *)0));
  }
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! n->right) {
#line 474
      goto while_break;
    }
#line 475
    n = n->right;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return (n);
}
}
#line 482 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree_node splay_tree_min(splay_tree sp ) 
{ 
  splay_tree_node n ;

  {
#line 485
  n = sp->root;
#line 487
  if (! n) {
#line 488
    return ((splay_tree_node )((void *)0));
  }
  {
#line 490
  while (1) {
    while_continue: /* CIL Label */ ;
#line 490
    if (! n->left) {
#line 490
      goto while_break;
    }
#line 491
    n = n->left;
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return (n);
}
}
#line 499 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree_node splay_tree_predecessor(splay_tree sp , splay_tree_key key ) 
{ 
  int comparison ;
  splay_tree_node node ;

  {
#line 506
  if (! sp->root) {
#line 507
    return ((splay_tree_node )((void *)0));
  }
  {
#line 511
  splay_tree_splay(sp, key);
#line 512
  comparison = (*(sp->comp))((sp->root)->key, key);
  }
#line 515
  if (comparison < 0) {
#line 516
    return (sp->root);
  }
#line 519
  node = (sp->root)->left;
#line 520
  if (node) {
    {
#line 521
    while (1) {
      while_continue: /* CIL Label */ ;
#line 521
      if (! node->right) {
#line 521
        goto while_break;
      }
#line 522
      node = node->right;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 524
  return (node);
}
}
#line 530 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
splay_tree_node splay_tree_successor(splay_tree sp , splay_tree_key key ) 
{ 
  int comparison ;
  splay_tree_node node ;

  {
#line 537
  if (! sp->root) {
#line 538
    return ((splay_tree_node )((void *)0));
  }
  {
#line 542
  splay_tree_splay(sp, key);
#line 543
  comparison = (*(sp->comp))((sp->root)->key, key);
  }
#line 546
  if (comparison > 0) {
#line 547
    return (sp->root);
  }
#line 550
  node = (sp->root)->right;
#line 551
  if (node) {
    {
#line 552
    while (1) {
      while_continue: /* CIL Label */ ;
#line 552
      if (! node->left) {
#line 552
        goto while_break;
      }
#line 553
      node = node->left;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 555
  return (node);
}
}
#line 563 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
int splay_tree_foreach(splay_tree sp , int (*fn)(splay_tree_node  , void * ) , void *data ) 
{ 
  int tmp___0 ;

  {
  {
#line 566
  tmp___0 = splay_tree_foreach_helper(sp->root, fn, data);
  }
#line 566
  return (tmp___0);
}
}
#line 571 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
int splay_tree_compare_ints(splay_tree_key k1 , splay_tree_key k2 ) 
{ 


  {
#line 574
  if ((int )k1 < (int )k2) {
#line 575
    return (-1);
  } else
#line 576
  if ((int )k1 > (int )k2) {
#line 577
    return (1);
  } else {
#line 579
    return (0);
  }
}
}
#line 584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./splay-tree.c"
int splay_tree_compare_pointers(splay_tree_key k1 , splay_tree_key k2 ) 
{ 


  {
#line 587
  if ((unsigned long )((char *)k1) < (unsigned long )((char *)k2)) {
#line 588
    return (-1);
  } else
#line 589
  if ((unsigned long )((char *)k1) > (unsigned long )((char *)k2)) {
#line 590
    return (1);
  } else {
#line 592
    return (0);
  }
}
}
#line 241 "./../include/libiberty.h"
char const   *spaces(int count ) ;
#line 51 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./spaces.c"
static char *buf___1  ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./spaces.c"
static int maxsize  ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./spaces.c"
char const   *spaces(int count ) 
{ 
  register char *t ;
  void *tmp___0 ;

  {
#line 54
  if (count > maxsize) {
    {
#line 56
    free((void *)buf___1);
#line 57
    tmp___0 = malloc((size_t )(count + 1));
#line 57
    buf___1 = (char *)tmp___0;
    }
#line 58
    if ((unsigned long )buf___1 == (unsigned long )((char *)0)) {
#line 59
      return ((char const   *)0);
    }
#line 60
    t = buf___1 + count;
    {
#line 60
    while (1) {
      while_continue: /* CIL Label */ ;
#line 60
      if (! ((unsigned long )t != (unsigned long )buf___1)) {
#line 60
        goto while_break;
      }
#line 62
      t --;
#line 62
      *t = (char )' ';
    }
    while_break: /* CIL Label */ ;
    }
#line 64
    maxsize = count;
#line 65
    *(buf___1 + count) = (char )'\000';
  }
#line 67
  return ((char const   *)((buf___1 + maxsize) - count));
}
}
#line 38 "./../include/sort.h"
void sort_pointers(size_t n , void **pointers , void **work ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 47 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sort.c"
void sort_pointers(size_t n , void **pointers , void **work ) 
{ 
  unsigned int count[256] ;
  int big_endian_p ;
  size_t i ;
  size_t j ;
  digit_t *digit ;
  digit_t *bias ;
  digit_t *top ;
  unsigned int *countp ;
  void **pointerp ;

  {
#line 70
  if ((sizeof(void *) / sizeof(digit_t )) % 2UL != 0UL) {
    {
#line 71
    abort();
    }
  }
#line 74
  i = (size_t )0;
#line 74
  j = (size_t )0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (i < sizeof(size_t ))) {
#line 74
      goto while_break;
    }
#line 76
    j *= 256UL;
#line 77
    j += i;
#line 74
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  big_endian_p = (int )*((char *)(& j) + 0) == 0;
#line 83
  i = (size_t )0;
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! (i < sizeof(void *) / sizeof(digit_t ))) {
#line 83
      goto while_break___0;
    }
#line 93
    if (big_endian_p) {
#line 94
      j = sizeof(void *) / sizeof(digit_t ) - i;
    } else {
#line 96
      j = i;
    }
    {
#line 100
    memset((void *)(count), 0, 256UL * sizeof(unsigned int ));
#line 105
    bias = (digit_t *)pointers + j;
#line 106
    top = (digit_t *)(pointers + n) + j;
#line 111
    digit = bias;
    }
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 111
      if (! ((unsigned long )digit < (unsigned long )top)) {
#line 111
        goto while_break___1;
      }
#line 114
      (count[*digit]) ++;
#line 111
      digit += sizeof(void *) / sizeof(digit_t );
    }
    while_break___1: /* CIL Label */ ;
    }
#line 118
    countp = count + 1;
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 118
      if (! ((unsigned long )countp < (unsigned long )(count + 256))) {
#line 118
        goto while_break___2;
      }
#line 119
      *countp += *(countp + -1);
#line 118
      countp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 122
    pointerp = (pointers + n) - 1;
    {
#line 122
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 122
      if (! ((unsigned long )pointerp >= (unsigned long )pointers)) {
#line 122
        goto while_break___3;
      }
#line 123
      (count[*((digit_t *)pointerp + j)]) --;
#line 123
      *(work + count[*((digit_t *)pointerp + j)]) = *pointerp;
#line 122
      pointerp --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 127
    pointerp = pointers;
#line 128
    pointers = work;
#line 129
    work = pointerp;
#line 83
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 363
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 369
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 55 "./../include/simple-object.h"
simple_object_read *simple_object_start_read(int descriptor , off_t offset , char const   *segment_name ,
                                             char const   **errmsg , int *err ) ;
#line 70
char const   *simple_object_find_sections(simple_object_read *sobj , int (*pfn)(void *data ,
                                                                                char const   * ,
                                                                                off_t offset ,
                                                                                off_t length ) ,
                                          void *data , int *err ) ;
#line 93
int simple_object_find_section(simple_object_read *sobj , char const   *name___0 ,
                               off_t *offset , off_t *length , char const   **errmsg ,
                               int *err ) ;
#line 101
void simple_object_release_read(simple_object_read *sobj ) ;
#line 116
simple_object_attributes *simple_object_fetch_attributes(simple_object_read *sobj ,
                                                         char const   **errmsg , int *err ) ;
#line 125
char const   *simple_object_attributes_merge(simple_object_attributes *to , simple_object_attributes *from ,
                                             int *err ) ;
#line 132
void simple_object_release_attributes(simple_object_attributes *attrs ) ;
#line 149
simple_object_write *simple_object_start_write(simple_object_attributes *attrs , char const   *segment_name ,
                                               char const   **errmsg , int *err ) ;
#line 167
simple_object_write_section *simple_object_write_create_section(simple_object_write *sobj ,
                                                                char const   *name___0 ,
                                                                unsigned int align ,
                                                                char const   **errmsg  __attribute__((__unused__)) ,
                                                                int *err  __attribute__((__unused__)) ) ;
#line 179
char const   *simple_object_write_add_data(simple_object_write *sobj  __attribute__((__unused__)) ,
                                           simple_object_write_section *section ,
                                           void const   *buffer___2 , size_t size ,
                                           int copy , int *err  __attribute__((__unused__)) ) ;
#line 190
char const   *simple_object_write_to_file(simple_object_write *sobj , int descriptor ,
                                          int *err ) ;
#line 197
void simple_object_release_write(simple_object_write *sobj ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 148 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
struct simple_object_functions  const  simple_object_coff_functions ;
#line 149
struct simple_object_functions  const  simple_object_elf_functions ;
#line 150
struct simple_object_functions  const  simple_object_mach_o_functions ;
#line 156
int simple_object_internal_read(int descriptor , off_t offset , unsigned char *buffer___2 ,
                                size_t size , char const   **errmsg , int *err ) ;
#line 165
int simple_object_internal_write(int descriptor , off_t offset , unsigned char const   *buffer___2 ,
                                 size_t size , char const   **errmsg , int *err ) ;
#line 50 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
static struct simple_object_functions  const  * const  format_functions[3]  = {      (struct simple_object_functions  const  */* const  */)(& simple_object_elf_functions),      (struct simple_object_functions  const  */* const  */)(& simple_object_mach_o_functions),      (struct simple_object_functions  const  */* const  */)(& simple_object_coff_functions)};
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
int simple_object_internal_read(int descriptor , off_t offset , unsigned char *buffer___2 ,
                                size_t size , char const   **errmsg , int *err ) 
{ 
  ssize_t got ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 67
  tmp___1 = lseek(descriptor, offset, 0);
  }
#line 67
  if (tmp___1 < 0L) {
    {
#line 69
    *errmsg = "lseek";
#line 70
    tmp___0 = __errno_location();
#line 70
    *err = *tmp___0;
    }
#line 71
    return (0);
  }
  {
#line 74
  got = read(descriptor, (void *)buffer___2, size);
  }
#line 75
  if (got < 0L) {
    {
#line 77
    *errmsg = "read";
#line 78
    tmp___2 = __errno_location();
#line 78
    *err = *tmp___2;
    }
#line 79
    return (0);
  }
#line 82
  if ((size_t )got < size) {
#line 84
    *errmsg = "file too short";
#line 85
    *err = 0;
#line 86
    return (0);
  }
#line 89
  return (1);
}
}
#line 95 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
int simple_object_internal_write(int descriptor , off_t offset , unsigned char const   *buffer___2 ,
                                 size_t size , char const   **errmsg , int *err ) 
{ 
  ssize_t wrote ;
  int *tmp___0 ;
  __off_t tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 102
  tmp___1 = lseek(descriptor, offset, 0);
  }
#line 102
  if (tmp___1 < 0L) {
    {
#line 104
    *errmsg = "lseek";
#line 105
    tmp___0 = __errno_location();
#line 105
    *err = *tmp___0;
    }
#line 106
    return (0);
  }
  {
#line 109
  wrote = write(descriptor, (void const   *)buffer___2, size);
  }
#line 110
  if (wrote < 0L) {
    {
#line 112
    *errmsg = "write";
#line 113
    tmp___2 = __errno_location();
#line 113
    *err = *tmp___2;
    }
#line 114
    return (0);
  }
#line 117
  if ((size_t )wrote < size) {
#line 119
    *errmsg = "short write";
#line 120
    *err = 0;
#line 121
    return (0);
  }
#line 124
  return (1);
}
}
#line 129 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
simple_object_read *simple_object_start_read(int descriptor , off_t offset , char const   *segment_name ,
                                             char const   **errmsg , int *err ) 
{ 
  unsigned char header[16] ;
  size_t len ;
  size_t i ;
  int tmp___0 ;
  void *data ;
  simple_object_read *ret ;
  void *tmp___1 ;

  {
  {
#line 137
  tmp___0 = simple_object_internal_read(descriptor, offset, header, (size_t )16, errmsg,
                                        err);
  }
#line 137
  if (! tmp___0) {
#line 140
    return ((simple_object_read *)((void *)0));
  }
#line 142
  len = sizeof(format_functions) / sizeof(format_functions[0]);
#line 143
  i = (size_t )0;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! (i < len)) {
#line 143
      goto while_break;
    }
    {
#line 147
    data = (*((format_functions[i])->match))((unsigned char *)(header), descriptor,
                                             offset, segment_name, errmsg, err);
    }
#line 149
    if ((unsigned long )data != (unsigned long )((void *)0)) {
      {
#line 153
      tmp___1 = xmalloc(sizeof(simple_object_read ));
#line 153
      ret = (simple_object_read *)tmp___1;
#line 154
      ret->descriptor = descriptor;
#line 155
      ret->offset = offset;
#line 156
      ret->functions = (struct simple_object_functions  const  *)format_functions[i];
#line 157
      ret->data = data;
      }
#line 158
      return (ret);
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  *errmsg = "file not recognized";
#line 163
  *err = 0;
#line 164
  return ((simple_object_read *)((void *)0));
}
}
#line 169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
char const   *simple_object_find_sections(simple_object_read *sobj , int (*pfn)(void *data ,
                                                                                char const   * ,
                                                                                off_t offset ,
                                                                                off_t length ) ,
                                          void *data , int *err ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 175
  tmp___0 = (*((sobj->functions)->find_sections))(sobj, pfn, data, err);
  }
#line 175
  return (tmp___0);
}
}
#line 194 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
static int find_one_section(void *data , char const   *name___0 , off_t offset , off_t length ) 
{ 
  struct find_one_section_data *fosd ;
  int tmp___0 ;

  {
  {
#line 197
  fosd = (struct find_one_section_data *)data;
#line 199
  tmp___0 = strcmp(name___0, fosd->name);
  }
#line 199
  if (tmp___0 != 0) {
#line 200
    return (1);
  }
#line 202
  *(fosd->offset) = offset;
#line 203
  *(fosd->length) = length;
#line 204
  fosd->found = 1;
#line 207
  return (0);
}
}
#line 212 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
int simple_object_find_section(simple_object_read *sobj , char const   *name___0 ,
                               off_t *offset , off_t *length , char const   **errmsg ,
                               int *err ) 
{ 
  struct find_one_section_data fosd ;

  {
  {
#line 219
  fosd.name = name___0;
#line 220
  fosd.offset = offset;
#line 221
  fosd.length = length;
#line 222
  fosd.found = 0;
#line 224
  *errmsg = simple_object_find_sections(sobj, & find_one_section, (void *)(& fosd),
                                        err);
  }
#line 226
  if ((unsigned long )*errmsg != (unsigned long )((void *)0)) {
#line 227
    return (0);
  }
#line 228
  if (! fosd.found) {
#line 229
    return (0);
  }
#line 230
  return (1);
}
}
#line 235 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
simple_object_attributes *simple_object_fetch_attributes(simple_object_read *sobj ,
                                                         char const   **errmsg , int *err ) 
{ 
  void *data ;
  simple_object_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 242
  data = (*((sobj->functions)->fetch_attributes))(sobj, errmsg, err);
  }
#line 243
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 244
    return ((simple_object_attributes *)((void *)0));
  }
  {
#line 245
  tmp___0 = xmalloc(sizeof(simple_object_attributes ));
#line 245
  ret = (simple_object_attributes *)tmp___0;
#line 246
  ret->functions = sobj->functions;
#line 247
  ret->data = data;
  }
#line 248
  return (ret);
}
}
#line 253 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
void simple_object_release_read(simple_object_read *sobj ) 
{ 


  {
  {
#line 256
  (*((sobj->functions)->release_read))(sobj->data);
#line 257
  free((void *)sobj);
  }
#line 258
  return;
}
}
#line 262 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
char const   *simple_object_attributes_merge(simple_object_attributes *to , simple_object_attributes *from ,
                                             int *err ) 
{ 
  char const   *tmp___0 ;

  {
#line 267
  if ((unsigned long )to->functions != (unsigned long )from->functions) {
#line 269
    *err = 0;
#line 270
    return ("different object file format");
  }
  {
#line 272
  tmp___0 = (*((to->functions)->attributes_merge))(to->data, from->data, err);
  }
#line 272
  return (tmp___0);
}
}
#line 277 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
void simple_object_release_attributes(simple_object_attributes *attrs ) 
{ 


  {
  {
#line 280
  (*((attrs->functions)->release_attributes))(attrs->data);
#line 281
  free((void *)attrs);
  }
#line 282
  return;
}
}
#line 286 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
simple_object_write *simple_object_start_write(simple_object_attributes *attrs , char const   *segment_name ,
                                               char const   **errmsg , int *err ) 
{ 
  void *data ;
  simple_object_write *ret ;
  void *tmp___0 ;

  {
  {
#line 294
  data = (*((attrs->functions)->start_write))(attrs->data, errmsg, err);
  }
#line 295
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 296
    return ((simple_object_write *)((void *)0));
  }
  {
#line 297
  tmp___0 = xmalloc(sizeof(simple_object_write ));
#line 297
  ret = (simple_object_write *)tmp___0;
#line 298
  ret->functions = attrs->functions;
#line 299
  ret->segment_name = xstrdup(segment_name);
#line 300
  ret->sections = (simple_object_write_section *)((void *)0);
#line 301
  ret->last_section = (simple_object_write_section *)((void *)0);
#line 302
  ret->data = data;
  }
#line 303
  return (ret);
}
}
#line 308 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
simple_object_write_section *simple_object_write_create_section(simple_object_write *sobj ,
                                                                char const   *name___0 ,
                                                                unsigned int align ,
                                                                char const   **errmsg  __attribute__((__unused__)) ,
                                                                int *err  __attribute__((__unused__)) ) 
{ 
  simple_object_write_section *ret ;
  void *tmp___0 ;

  {
  {
#line 316
  tmp___0 = xmalloc(sizeof(simple_object_write_section ));
#line 316
  ret = (simple_object_write_section *)tmp___0;
#line 317
  ret->next = (simple_object_write_section *)((void *)0);
#line 318
  ret->name = xstrdup(name___0);
#line 319
  ret->align = align;
#line 320
  ret->buffers = (struct simple_object_write_section_buffer *)((void *)0);
#line 321
  ret->last_buffer = (struct simple_object_write_section_buffer *)((void *)0);
  }
#line 323
  if ((unsigned long )sobj->last_section == (unsigned long )((void *)0)) {
#line 325
    sobj->sections = ret;
#line 326
    sobj->last_section = ret;
  } else {
#line 330
    (sobj->last_section)->next = ret;
#line 331
    sobj->last_section = ret;
  }
#line 334
  return (ret);
}
}
#line 339 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
char const   *simple_object_write_add_data(simple_object_write *sobj  __attribute__((__unused__)) ,
                                           simple_object_write_section *section ,
                                           void const   *buffer___2 , size_t size ,
                                           int copy , int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_write_section_buffer *wsb ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 348
  tmp___0 = xmalloc(sizeof(struct simple_object_write_section_buffer ));
#line 348
  wsb = (struct simple_object_write_section_buffer *)tmp___0;
#line 349
  wsb->next = (struct simple_object_write_section_buffer *)((void *)0);
#line 350
  wsb->size = size;
  }
#line 352
  if (! copy) {
#line 354
    wsb->buffer = buffer___2;
#line 355
    wsb->free_buffer = (void *)0;
  } else {
    {
#line 359
    tmp___1 = xmalloc(sizeof(char ) * size);
#line 359
    wsb->free_buffer = (void *)((char *)tmp___1);
#line 360
    memcpy((void */* __restrict  */)wsb->free_buffer, (void const   */* __restrict  */)buffer___2,
           size);
#line 361
    wsb->buffer = (void const   *)wsb->free_buffer;
    }
  }
#line 364
  if ((unsigned long )section->last_buffer == (unsigned long )((void *)0)) {
#line 366
    section->buffers = wsb;
#line 367
    section->last_buffer = wsb;
  } else {
#line 371
    (section->last_buffer)->next = wsb;
#line 372
    section->last_buffer = wsb;
  }
#line 375
  return ((char const   *)((void *)0));
}
}
#line 380 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
char const   *simple_object_write_to_file(simple_object_write *sobj , int descriptor ,
                                          int *err ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 384
  tmp___0 = (*((sobj->functions)->write_to_file))(sobj, descriptor, err);
  }
#line 384
  return (tmp___0);
}
}
#line 389 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object.c"
void simple_object_release_write(simple_object_write *sobj ) 
{ 
  simple_object_write_section *section ;
  struct simple_object_write_section_buffer *buffer___2 ;
  simple_object_write_section *next_section ;
  struct simple_object_write_section_buffer *next_buffer ;

  {
  {
#line 394
  free((void *)sobj->segment_name);
#line 396
  section = sobj->sections;
  }
  {
#line 397
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 397
      goto while_break;
    }
#line 402
    buffer___2 = section->buffers;
    {
#line 403
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 403
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 403
        goto while_break___0;
      }
#line 407
      if ((unsigned long )buffer___2->free_buffer != (unsigned long )((void *)0)) {
        {
#line 408
        free(buffer___2->free_buffer);
        }
      }
      {
#line 409
      next_buffer = buffer___2->next;
#line 410
      free((void *)buffer___2);
#line 411
      buffer___2 = next_buffer;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 414
    next_section = section->next;
#line 415
    free((void *)section->name);
#line 416
    free((void *)section);
#line 417
    section = next_section;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 420
  (*((sobj->functions)->release_write))(sobj->data);
#line 421
  free((void *)sobj);
  }
#line 422
  return;
}
}
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static unsigned int simple_object_fetch_big_32(unsigned char const   *buf___4 ) 
{ 


  {
#line 200
  return (((((unsigned int )*(buf___4 + 0) << 24) | ((unsigned int )*(buf___4 + 1) << 16)) | ((unsigned int )*(buf___4 + 2) << 8)) | (unsigned int )*(buf___4 + 3));
}
}
#line 208 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static unsigned int simple_object_fetch_little_32(unsigned char const   *buf___4 ) 
{ 


  {
#line 211
  return (((((unsigned int )*(buf___4 + 3) << 24) | ((unsigned int )*(buf___4 + 2) << 16)) | ((unsigned int )*(buf___4 + 1) << 8)) | (unsigned int )*(buf___4 + 0));
}
}
#line 237 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_big_64(unsigned char const   *buf___4 ) 
{ 


  {
#line 240
  return (((((((((ulong_type )*(buf___4 + 0) << 56) | ((ulong_type )*(buf___4 + 1) << 48)) | ((ulong_type )*(buf___4 + 2) << 40)) | ((ulong_type )*(buf___4 + 3) << 32)) | ((ulong_type )*(buf___4 + 4) << 24)) | ((ulong_type )*(buf___4 + 5) << 16)) | ((ulong_type )*(buf___4 + 6) << 8)) | (ulong_type )*(buf___4 + 7));
}
}
#line 252 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_little_64(unsigned char const   *buf___4 ) 
{ 


  {
#line 255
  return (((((((((ulong_type )*(buf___4 + 7) << 56) | ((ulong_type )*(buf___4 + 6) << 48)) | ((ulong_type )*(buf___4 + 5) << 40)) | ((ulong_type )*(buf___4 + 4) << 32)) | ((ulong_type )*(buf___4 + 3) << 24)) | ((ulong_type )*(buf___4 + 2) << 16)) | ((ulong_type )*(buf___4 + 1) << 8)) | (ulong_type )*(buf___4 + 0));
}
}
#line 287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_32(unsigned char *buf___4 , unsigned int val ) 
{ 


  {
#line 290
  *(buf___4 + 0) = (unsigned char )((val >> 24) & 255U);
#line 291
  *(buf___4 + 1) = (unsigned char )((val >> 16) & 255U);
#line 292
  *(buf___4 + 2) = (unsigned char )((val >> 8) & 255U);
#line 293
  *(buf___4 + 3) = (unsigned char )(val & 255U);
#line 294
  return;
}
}
#line 298 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_32(unsigned char *buf___4 , unsigned int val ) 
{ 


  {
#line 301
  *(buf___4 + 3) = (unsigned char )((val >> 24) & 255U);
#line 302
  *(buf___4 + 2) = (unsigned char )((val >> 16) & 255U);
#line 303
  *(buf___4 + 1) = (unsigned char )((val >> 8) & 255U);
#line 304
  *(buf___4 + 0) = (unsigned char )(val & 255U);
#line 305
  return;
}
}
#line 327 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_64(unsigned char *buf___4 , ulong_type val ) 
{ 


  {
#line 330
  *(buf___4 + 0) = (unsigned char )((val >> 56) & 255UL);
#line 331
  *(buf___4 + 1) = (unsigned char )((val >> 48) & 255UL);
#line 332
  *(buf___4 + 2) = (unsigned char )((val >> 40) & 255UL);
#line 333
  *(buf___4 + 3) = (unsigned char )((val >> 32) & 255UL);
#line 334
  *(buf___4 + 4) = (unsigned char )((val >> 24) & 255UL);
#line 335
  *(buf___4 + 5) = (unsigned char )((val >> 16) & 255UL);
#line 336
  *(buf___4 + 6) = (unsigned char )((val >> 8) & 255UL);
#line 337
  *(buf___4 + 7) = (unsigned char )(val & 255UL);
#line 338
  return;
}
}
#line 342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_64(unsigned char *buf___4 , ulong_type val ) 
{ 


  {
#line 345
  *(buf___4 + 7) = (unsigned char )((val >> 56) & 255UL);
#line 346
  *(buf___4 + 6) = (unsigned char )((val >> 48) & 255UL);
#line 347
  *(buf___4 + 5) = (unsigned char )((val >> 40) & 255UL);
#line 348
  *(buf___4 + 4) = (unsigned char )((val >> 32) & 255UL);
#line 349
  *(buf___4 + 3) = (unsigned char )((val >> 24) & 255UL);
#line 350
  *(buf___4 + 2) = (unsigned char )((val >> 16) & 255UL);
#line 351
  *(buf___4 + 1) = (unsigned char )((val >> 8) & 255UL);
#line 352
  *(buf___4 + 0) = (unsigned char )(val & 255UL);
#line 353
  return;
}
}
#line 239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void *simple_object_mach_o_match(unsigned char *header , int descriptor , off_t offset ,
                                        char const   *segment_name , char const   **errmsg ,
                                        int *err ) 
{ 
  unsigned int magic ;
  int is_big_endian ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  unsigned int filetype ;
  struct simple_object_mach_o_read *omr ;
  unsigned char buf___4[sizeof(struct mach_o_header_64 )] ;
  unsigned char *b ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 256
  magic = simple_object_fetch_big_32((unsigned char const   *)header);
  }
#line 257
  if (magic == 4277009102U) {
#line 258
    is_big_endian = 1;
  } else
#line 257
  if (magic == 4277009103U) {
#line 258
    is_big_endian = 1;
  } else {
    {
#line 261
    magic = simple_object_fetch_little_32((unsigned char const   *)header);
    }
#line 262
    if (magic == 4277009102U) {
#line 263
      is_big_endian = 0;
    } else
#line 262
    if (magic == 4277009103U) {
#line 263
      is_big_endian = 0;
    } else {
#line 266
      *errmsg = (char const   *)((void *)0);
#line 267
      *err = 0;
#line 268
      return ((void *)0);
    }
  }
#line 284
  if ((unsigned long )segment_name == (unsigned long )((void *)0)) {
#line 286
    *errmsg = "Mach-O file found but no segment name specified";
#line 287
    *err = 0;
#line 288
    return ((void *)0);
  }
  {
#line 291
  tmp___0 = strlen(segment_name);
  }
#line 291
  if (tmp___0 > 16UL) {
#line 293
    *errmsg = "Mach-O segment name too long";
#line 294
    *err = 0;
#line 295
    return ((void *)0);
  }
#line 301
  if (is_big_endian) {
#line 301
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 301
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 305
  if (magic == 4277009102U) {
#line 305
    tmp___1 = sizeof(struct mach_o_header_32 );
  } else {
#line 305
    tmp___1 = sizeof(struct mach_o_header_64 );
  }
  {
#line 305
  tmp___2 = simple_object_internal_read(descriptor, offset, buf___4, tmp___1, errmsg,
                                        err);
  }
#line 305
  if (! tmp___2) {
#line 310
    return ((void *)0);
  }
  {
#line 312
  b = & buf___4[0];
#line 314
  filetype = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->filetype)));
  }
#line 315
  if (filetype != 1U) {
#line 317
    *errmsg = "Mach-O file is not object file";
#line 318
    *err = 0;
#line 319
    return ((void *)0);
  }
  {
#line 322
  tmp___3 = xmalloc(sizeof(struct simple_object_mach_o_read ));
#line 322
  omr = (struct simple_object_mach_o_read *)tmp___3;
#line 323
  omr->segment_name = xstrdup(segment_name);
#line 324
  omr->magic = magic;
#line 325
  omr->is_big_endian = is_big_endian;
#line 326
  omr->cputype = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->cputype)));
#line 327
  omr->cpusubtype = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->cpusubtype)));
#line 330
  omr->ncmds = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->ncmds)));
#line 331
  omr->flags = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_32 *)0)->flags)));
  }
#line 332
  if (magic == 4277009102U) {
#line 333
    omr->reserved = 0U;
  } else {
    {
#line 335
    omr->reserved = (*fetch_32)((unsigned char const   *)(b + (unsigned long )(& ((struct mach_o_header_64 *)0)->reserved)));
    }
  }
#line 339
  return ((void *)omr);
}
}
#line 344 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_section_info(int is_big_endian , int is_32 , unsigned char const   *sechdr ,
                                              off_t *offset , size_t *size ) 
{ 
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  ulong_type (*fetch_64)(unsigned char const   * ) ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 352
  if (is_big_endian) {
#line 352
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 352
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 356
  fetch_64 = (ulong_type (*)(unsigned char const   * ))((void *)0);
#line 358
  if (is_big_endian) {
#line 358
    fetch_64 = & simple_object_fetch_big_64;
  } else {
#line 358
    fetch_64 = & simple_object_fetch_little_64;
  }
#line 363
  if (is_32) {
    {
#line 365
    tmp___0 = (*fetch_32)(sechdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->offset));
#line 365
    *offset = (off_t )tmp___0;
#line 367
    tmp___1 = (*fetch_32)(sechdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->size));
#line 367
    *size = (size_t )tmp___1;
    }
  } else {
    {
#line 372
    tmp___2 = (*fetch_32)(sechdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->offset));
#line 372
    *offset = (off_t )tmp___2;
#line 374
    *size = (*fetch_64)(sechdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->size));
    }
  }
#line 377
  return;
}
}
#line 403 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_segment(simple_object_read *sobj , off_t offset ,
                                        unsigned char const   *segbuf , int (*pfn)(void * ,
                                                                                   char const   * ,
                                                                                   off_t offset ,
                                                                                   off_t length ) ,
                                        void *data , char const   **errmsg , int *err ) 
{ 
  struct simple_object_mach_o_read *omr ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  int is_32 ;
  size_t seghdrsize ;
  size_t sechdrsize ;
  size_t segname_offset ;
  size_t sectname_offset ;
  unsigned int nsects ;
  unsigned char *secdata ;
  unsigned int i ;
  unsigned int gnu_sections_found ;
  unsigned int strtab_index ;
  unsigned int index_index ;
  unsigned int nametab_index ;
  unsigned int sections_index ;
  char *strtab ;
  char *nametab ;
  unsigned char *index___0 ;
  size_t strtab_size ;
  size_t nametab_size ;
  size_t index_size ;
  unsigned int n_wrapped_sects ;
  size_t wrapper_sect_size ;
  off_t wrapper_sect_offset ;
  void *tmp___0 ;
  int tmp___1 ;
  size_t nameoff ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  off_t nametab_offset ;
  off_t index_offset ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  off_t strtab_offset ;
  void *tmp___11 ;
  int tmp___12 ;
  unsigned char const   *sechdr ;
  char namebuf[34] ;
  char *name___0 ;
  off_t secoffset ;
  size_t secsize ;
  int l ;
  int tmp___13 ;
  unsigned int j ;
  unsigned int subsect_offset ;
  unsigned int subsect_length ;
  unsigned int name_offset ;
  int tmp___14 ;
  unsigned long stringoffset ;
  int tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;

  {
#line 411
  omr = (struct simple_object_mach_o_read *)sobj->data;
#line 437
  if (omr->is_big_endian) {
#line 437
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 437
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 441
  is_32 = omr->magic == 4277009102U;
#line 443
  if (is_32) {
    {
#line 445
    seghdrsize = sizeof(struct mach_o_segment_command_32 );
#line 446
    sechdrsize = sizeof(struct mach_o_section_32 );
#line 447
    segname_offset = (unsigned long )(& ((struct mach_o_section_32 *)0)->segname);
#line 448
    sectname_offset = (unsigned long )(& ((struct mach_o_section_32 *)0)->sectname);
#line 449
    nsects = (*fetch_32)(segbuf + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->nsects));
    }
  } else {
    {
#line 455
    seghdrsize = sizeof(struct mach_o_segment_command_64 );
#line 456
    sechdrsize = sizeof(struct mach_o_section_64 );
#line 457
    segname_offset = (unsigned long )(& ((struct mach_o_section_64 *)0)->segname);
#line 458
    sectname_offset = (unsigned long )(& ((struct mach_o_section_64 *)0)->sectname);
#line 459
    nsects = (*fetch_32)(segbuf + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->nsects));
    }
  }
  {
#line 466
  tmp___0 = xmalloc(sizeof(unsigned char ) * ((size_t )nsects * sechdrsize));
#line 466
  secdata = (unsigned char *)tmp___0;
#line 467
  tmp___1 = simple_object_internal_read(sobj->descriptor, (off_t )((size_t )offset + seghdrsize),
                                        secdata, (size_t )nsects * sechdrsize, errmsg,
                                        err);
  }
#line 467
  if (! tmp___1) {
    {
#line 470
    free((void *)secdata);
    }
#line 471
    return (0);
  }
#line 476
  gnu_sections_found = 0U;
#line 477
  index_index = nsects;
#line 478
  sections_index = nsects;
#line 479
  strtab_index = nsects;
#line 480
  nametab_index = nsects;
#line 481
  i = 0U;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < nsects)) {
#line 481
      goto while_break;
    }
    {
#line 485
    nameoff = (size_t )i * sechdrsize + segname_offset;
#line 486
    tmp___2 = strcmp((char const   *)((char *)secdata + nameoff), (char const   *)omr->segment_name);
    }
#line 486
    if (tmp___2 != 0) {
#line 487
      goto __Cont;
    }
    {
#line 489
    nameoff = (size_t )i * sechdrsize + sectname_offset;
#line 490
    tmp___6 = strcmp((char const   *)((char *)secdata + nameoff), "__wrapper_names");
    }
#line 490
    if (tmp___6 == 0) {
#line 492
      nametab_index = i;
#line 493
      gnu_sections_found |= 4U;
    } else {
      {
#line 495
      tmp___5 = strcmp((char const   *)((char *)secdata + nameoff), "__wrapper_index");
      }
#line 495
      if (tmp___5 == 0) {
#line 497
        index_index = i;
#line 498
        gnu_sections_found |= 2U;
      } else {
        {
#line 500
        tmp___4 = strcmp((char const   *)((char *)secdata + nameoff), "__wrapper_sects");
        }
#line 500
        if (tmp___4 == 0) {
#line 502
          sections_index = i;
#line 503
          gnu_sections_found |= 1U;
        } else {
          {
#line 505
          tmp___3 = strcmp((char const   *)((char *)secdata + nameoff), "__section_names");
          }
#line 505
          if (tmp___3 == 0) {
#line 507
            strtab_index = i;
#line 508
            gnu_sections_found |= 8U;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  if ((gnu_sections_found & 7U) != 0U) {
#line 520
    if ((gnu_sections_found & 7U) != 7U) {
      {
#line 522
      *errmsg = "GNU Mach-o section wrapper: required section missing";
#line 523
      *err = 0;
#line 524
      free((void *)secdata);
      }
#line 525
      return (0);
    }
    {
#line 530
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )nametab_index * sechdrsize),
                                      & nametab_offset, & nametab_size);
#line 533
    tmp___7 = xmalloc(sizeof(char ) * nametab_size);
#line 533
    nametab = (char *)tmp___7;
#line 534
    tmp___8 = simple_object_internal_read(sobj->descriptor, sobj->offset + nametab_offset,
                                          (unsigned char *)nametab, nametab_size,
                                          errmsg, err);
    }
#line 534
    if (! tmp___8) {
      {
#line 539
      free((void *)nametab);
#line 540
      free((void *)secdata);
      }
#line 541
      return (0);
    }
    {
#line 546
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )index_index * sechdrsize),
                                      & index_offset, & index_size);
#line 549
    tmp___9 = xmalloc(sizeof(unsigned char ) * index_size);
#line 549
    index___0 = (unsigned char *)tmp___9;
#line 550
    tmp___10 = simple_object_internal_read(sobj->descriptor, sobj->offset + index_offset,
                                           index___0, index_size, errmsg, err);
    }
#line 550
    if (! tmp___10) {
      {
#line 555
      free((void *)index___0);
#line 556
      free((void *)nametab);
#line 557
      free((void *)secdata);
      }
#line 558
      return (0);
    }
    {
#line 565
    n_wrapped_sects = (unsigned int )(index_size / 16UL);
#line 568
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )sections_index * sechdrsize),
                                      & wrapper_sect_offset, & wrapper_sect_size);
    }
  } else {
#line 575
    index___0 = (unsigned char *)((void *)0);
#line 576
    index_size = (size_t )0;
#line 577
    nametab = (char *)((void *)0);
#line 578
    nametab_size = (size_t )0;
#line 579
    n_wrapped_sects = 0U;
  }
#line 584
  if ((gnu_sections_found & 8U) != 0U) {
    {
#line 588
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, (unsigned char const   *)(secdata + (size_t )strtab_index * sechdrsize),
                                      & strtab_offset, & strtab_size);
#line 591
    tmp___11 = xmalloc(sizeof(char ) * strtab_size);
#line 591
    strtab = (char *)tmp___11;
#line 592
    tmp___12 = simple_object_internal_read(sobj->descriptor, sobj->offset + strtab_offset,
                                           (unsigned char *)strtab, strtab_size, errmsg,
                                           err);
    }
#line 592
    if (! tmp___12) {
      {
#line 597
      free((void *)strtab);
#line 598
      free((void *)index___0);
#line 599
      free((void *)nametab);
#line 600
      free((void *)secdata);
      }
#line 601
      return (0);
    }
  } else {
#line 606
    strtab = (char *)((void *)0);
#line 607
    strtab_size = (size_t )0;
#line 608
    strtab_index = nsects;
  }
#line 613
  i = 0U;
  {
#line 613
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 613
    if (! (i < nsects)) {
#line 613
      goto while_break___0;
    }
#line 622
    sechdr = (unsigned char const   *)(secdata + (size_t )i * sechdrsize);
#line 626
    if ((gnu_sections_found & 8U) != 0U) {
#line 626
      if (i == strtab_index) {
#line 628
        goto __Cont___0;
      }
    }
    {
#line 632
    tmp___13 = strcmp((char const   *)((char *)sechdr + segname_offset), (char const   *)omr->segment_name);
    }
#line 632
    if (tmp___13 != 0) {
#line 633
      goto __Cont___0;
    }
#line 637
    if ((gnu_sections_found & 7U) != 0U) {
#line 639
      if (i == nametab_index) {
#line 640
        goto __Cont___0;
      } else
#line 639
      if (i == index_index) {
#line 640
        goto __Cont___0;
      }
#line 642
      if (i == sections_index) {
#line 645
        j = 0U;
        {
#line 645
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 645
          if (! (j < n_wrapped_sects)) {
#line 645
            goto while_break___1;
          }
          {
#line 648
          subsect_offset = (*fetch_32)((unsigned char const   *)(index___0 + 16U * j));
#line 649
          subsect_length = (*fetch_32)((unsigned char const   *)((index___0 + 16U * j) + 4));
#line 650
          name_offset = (*fetch_32)((unsigned char const   *)((index___0 + 16U * j) + 8));
#line 653
          secoffset = wrapper_sect_offset + (off_t )subsect_offset;
#line 654
          secsize = (size_t )subsect_length;
#line 655
          name___0 = nametab + name_offset;
#line 657
          tmp___14 = (*pfn)(data, (char const   *)name___0, secoffset, (off_t )secsize);
          }
#line 657
          if (! tmp___14) {
            {
#line 659
            *errmsg = (char const   *)((void *)0);
#line 660
            *err = 0;
#line 661
            free((void *)index___0);
#line 662
            free((void *)nametab);
#line 663
            free((void *)strtab);
#line 664
            free((void *)secdata);
            }
#line 665
            return (0);
          }
#line 645
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 668
        goto __Cont___0;
      }
    }
#line 672
    if ((gnu_sections_found & 8U) != 0U) {
      {
#line 674
      memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)(sechdr + sectname_offset),
             (size_t )16);
#line 675
      namebuf[16] = (char )'\000';
#line 677
      name___0 = & namebuf[0];
      }
#line 678
      if ((unsigned long )strtab != (unsigned long )((void *)0)) {
#line 678
        if ((int )*(name___0 + 0) == 95) {
#line 678
          if ((int )*(name___0 + 1) == 95) {
            {
#line 682
            tmp___15 = sscanf((char const   */* __restrict  */)(name___0 + 2), (char const   */* __restrict  */)"%08lX",
                              & stringoffset);
            }
#line 682
            if (tmp___15 == 1) {
#line 684
              if (stringoffset >= strtab_size) {
                {
#line 686
                *errmsg = "section name offset out of range";
#line 687
                *err = 0;
#line 688
                free((void *)index___0);
#line 689
                free((void *)nametab);
#line 690
                free((void *)strtab);
#line 691
                free((void *)secdata);
                }
#line 692
                return (0);
              }
#line 695
              name___0 = strtab + stringoffset;
            }
          }
        }
      }
    } else {
      {
#line 703
      name___0 = & namebuf[0];
#line 704
      memset((void *)(namebuf), 0, (size_t )34);
#line 705
      memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)((char *)sechdr + segname_offset),
             (size_t )16);
#line 706
      tmp___16 = strlen((char const   *)(namebuf));
#line 706
      l = (int )tmp___16;
#line 707
      namebuf[l] = (char )',';
#line 708
      memcpy((void */* __restrict  */)((namebuf + l) + 1), (void const   */* __restrict  */)((char *)sechdr + sectname_offset),
             (size_t )16);
      }
    }
    {
#line 712
    simple_object_mach_o_section_info(omr->is_big_endian, is_32, sechdr, & secoffset,
                                      & secsize);
#line 715
    tmp___17 = (*pfn)(data, (char const   *)name___0, secoffset, (off_t )secsize);
    }
#line 715
    if (! tmp___17) {
      {
#line 717
      *errmsg = (char const   *)((void *)0);
#line 718
      *err = 0;
#line 719
      free((void *)index___0);
#line 720
      free((void *)nametab);
#line 721
      free((void *)strtab);
#line 722
      free((void *)secdata);
      }
#line 723
      return (0);
    }
    __Cont___0: /* CIL Label */ 
#line 613
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 727
  free((void *)index___0);
#line 728
  free((void *)nametab);
#line 729
  free((void *)strtab);
#line 730
  free((void *)secdata);
  }
#line 732
  return (1);
}
}
#line 737 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static char const   *simple_object_mach_o_find_sections(simple_object_read *sobj ,
                                                        int (*pfn)(void * , char const   * ,
                                                                   off_t offset ,
                                                                   off_t length ) ,
                                                        void *data , int *err ) 
{ 
  struct simple_object_mach_o_read *omr ;
  off_t offset ;
  size_t seghdrsize ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  char const   *errmsg ;
  unsigned int i ;
  unsigned char loadbuf[sizeof(struct mach_o_load_command )] ;
  unsigned int cmd ;
  unsigned int cmdsize ;
  int tmp___0 ;
  unsigned char segbuf[sizeof(struct mach_o_segment_command_64 )] ;
  int r ;
  int tmp___1 ;

  {
#line 744
  omr = (struct simple_object_mach_o_read *)sobj->data;
#line 752
  if (omr->magic == 4277009102U) {
#line 754
    offset = (off_t )sizeof(struct mach_o_header_32 );
#line 755
    seghdrsize = sizeof(struct mach_o_segment_command_32 );
  } else {
#line 759
    offset = (off_t )sizeof(struct mach_o_header_64 );
#line 760
    seghdrsize = sizeof(struct mach_o_segment_command_64 );
  }
#line 763
  if (omr->is_big_endian) {
#line 763
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 763
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 767
  i = 0U;
  {
#line 767
  while (1) {
    while_continue: /* CIL Label */ ;
#line 767
    if (! (i < omr->ncmds)) {
#line 767
      goto while_break;
    }
    {
#line 773
    tmp___0 = simple_object_internal_read(sobj->descriptor, sobj->offset + offset,
                                          loadbuf, sizeof(struct mach_o_load_command ),
                                          & errmsg, err);
    }
#line 773
    if (! tmp___0) {
#line 778
      return (errmsg);
    }
    {
#line 780
    cmd = (*fetch_32)((unsigned char const   *)(loadbuf + (unsigned long )(& ((struct mach_o_load_command *)0)->cmd)));
#line 781
    cmdsize = (*fetch_32)((unsigned char const   *)(loadbuf + (unsigned long )(& ((struct mach_o_load_command *)0)->cmdsize)));
    }
#line 784
    if (cmd == 1U) {
#line 784
      goto _L;
    } else
#line 784
    if (cmd == 25U) {
      _L: /* CIL Label */ 
      {
#line 789
      tmp___1 = simple_object_internal_read(sobj->descriptor, sobj->offset + offset,
                                            segbuf, seghdrsize, & errmsg, err);
      }
#line 789
      if (! tmp___1) {
#line 792
        return (errmsg);
      }
      {
#line 794
      r = simple_object_mach_o_segment(sobj, offset, (unsigned char const   *)(segbuf),
                                       pfn, data, & errmsg, err);
      }
#line 796
      if (! r) {
#line 797
        return (errmsg);
      }
    }
#line 800
    offset += (off_t )cmdsize;
#line 767
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 803
  return ((char const   *)((void *)0));
}
}
#line 808 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void *simple_object_mach_o_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                   int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_mach_o_read *omr ;
  struct simple_object_mach_o_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 813
  omr = (struct simple_object_mach_o_read *)sobj->data;
#line 817
  tmp___0 = xmalloc(sizeof(struct simple_object_mach_o_attributes ));
#line 817
  ret = (struct simple_object_mach_o_attributes *)tmp___0;
#line 818
  ret->magic = omr->magic;
#line 819
  ret->is_big_endian = omr->is_big_endian;
#line 820
  ret->cputype = omr->cputype;
#line 821
  ret->cpusubtype = omr->cpusubtype;
#line 822
  ret->flags = omr->flags;
#line 823
  ret->reserved = omr->reserved;
  }
#line 824
  return ((void *)ret);
}
}
#line 829 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_release_read(void *data ) 
{ 
  struct simple_object_mach_o_read *omr ;

  {
  {
#line 832
  omr = (struct simple_object_mach_o_read *)data;
#line 835
  free((void *)omr->segment_name);
#line 836
  free((void *)omr);
  }
#line 837
  return;
}
}
#line 841 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static char const   *simple_object_mach_o_attributes_merge(void *todata , void *fromdata ,
                                                           int *err ) 
{ 
  struct simple_object_mach_o_attributes *to ;
  struct simple_object_mach_o_attributes *from ;

  {
#line 844
  to = (struct simple_object_mach_o_attributes *)todata;
#line 846
  from = (struct simple_object_mach_o_attributes *)fromdata;
#line 849
  if (to->magic != from->magic) {
#line 853
    *err = 0;
#line 854
    return ("Mach-O object format mismatch");
  } else
#line 849
  if (to->is_big_endian != from->is_big_endian) {
#line 853
    *err = 0;
#line 854
    return ("Mach-O object format mismatch");
  } else
#line 849
  if (to->cputype != from->cputype) {
#line 853
    *err = 0;
#line 854
    return ("Mach-O object format mismatch");
  }
#line 856
  return ((char const   *)((void *)0));
}
}
#line 861 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_release_attributes(void *data ) 
{ 


  {
  {
#line 864
  free(data);
  }
#line 865
  return;
}
}
#line 869 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void *simple_object_mach_o_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                              int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  struct simple_object_mach_o_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 874
  attrs = (struct simple_object_mach_o_attributes *)attributes_data;
#line 880
  tmp___0 = xmalloc(sizeof(struct simple_object_mach_o_attributes ));
#line 880
  ret = (struct simple_object_mach_o_attributes *)tmp___0;
#line 881
  *ret = *attrs;
  }
#line 882
  return ((void *)ret);
}
}
#line 887 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_write_header(simple_object_write *sobj , int descriptor ,
                                             size_t nsects , char const   **errmsg ,
                                             int *err ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct mach_o_header_64 )] ;
  unsigned char *hdr ;
  size_t wrsize ;
  int tmp___0 ;

  {
#line 892
  attrs = (struct simple_object_mach_o_attributes *)sobj->data;
#line 899
  if (attrs->is_big_endian) {
#line 899
    set_32 = & simple_object_set_big_32;
  } else {
#line 899
    set_32 = & simple_object_set_little_32;
  }
  {
#line 903
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 907
  hdr = & hdrbuf[0];
#line 908
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->magic), attrs->magic);
#line 909
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->cputype), attrs->cputype);
#line 910
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->cpusubtype),
            attrs->cpusubtype);
#line 912
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->filetype), 1U);
#line 913
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->ncmds), 1U);
#line 914
  (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->flags), attrs->flags);
  }
#line 915
  if (attrs->magic == 4277009102U) {
    {
#line 917
    wrsize = sizeof(struct mach_o_header_32 );
#line 918
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_32 *)0)->sizeofcmds),
              (unsigned int )(sizeof(struct mach_o_segment_command_32 ) + nsects * sizeof(struct mach_o_section_32 )));
    }
  } else {
    {
#line 924
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_64 *)0)->sizeofcmds),
              (unsigned int )(sizeof(struct mach_o_segment_command_64 ) + nsects * sizeof(struct mach_o_section_64 )));
#line 927
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_header_64 *)0)->reserved),
              attrs->reserved);
#line 929
    wrsize = sizeof(struct mach_o_header_64 );
    }
  }
  {
#line 932
  tmp___0 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(hdrbuf),
                                         wrsize, errmsg, err);
  }
#line 932
  return (tmp___0);
}
}
#line 938 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_write_section_header(simple_object_write *sobj , int descriptor ,
                                                     size_t sechdr_offset , char const   *name___0 ,
                                                     char const   *segn , size_t secaddr ,
                                                     size_t secsize , size_t offset ,
                                                     unsigned int align , char const   **errmsg ,
                                                     int *err ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct mach_o_section_64 )] ;
  unsigned char *hdr ;
  size_t sechdrsize ;
  void (*set_64)(unsigned char * , ulong_type  ) ;
  int tmp___0 ;

  {
#line 947
  attrs = (struct simple_object_mach_o_attributes *)sobj->data;
#line 954
  if (attrs->is_big_endian) {
#line 954
    set_32 = & simple_object_set_big_32;
  } else {
#line 954
    set_32 = & simple_object_set_little_32;
  }
  {
#line 958
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 960
  hdr = & hdrbuf[0];
  }
#line 961
  if (attrs->magic == 4277009102U) {
    {
#line 963
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->sectname)),
            (char const   */* __restrict  */)name___0, (size_t )16);
#line 965
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->segname)),
            (char const   */* __restrict  */)segn, (size_t )16);
#line 967
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->addr), (unsigned int )secaddr);
#line 968
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->size), (unsigned int )secsize);
#line 969
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->offset), (unsigned int )offset);
#line 970
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->align), align);
#line 973
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_32 *)0)->flags), 33554432U);
#line 977
    sechdrsize = sizeof(struct mach_o_section_32 );
    }
  } else {
#line 984
    if (attrs->is_big_endian) {
#line 984
      set_64 = & simple_object_set_big_64;
    } else {
#line 984
      set_64 = & simple_object_set_little_64;
    }
    {
#line 988
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->sectname)),
            (char const   */* __restrict  */)name___0, (size_t )16);
#line 990
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->segname)),
            (char const   */* __restrict  */)segn, (size_t )16);
#line 992
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->addr), secaddr);
#line 993
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->size), secsize);
#line 994
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->offset), (unsigned int )offset);
#line 995
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->align), align);
#line 998
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_section_64 *)0)->flags), 33554432U);
#line 1004
    sechdrsize = sizeof(struct mach_o_section_64 );
    }
  }
  {
#line 1007
  tmp___0 = simple_object_internal_write(descriptor, (off_t )sechdr_offset, (unsigned char const   *)hdr,
                                         sechdrsize, errmsg, err);
  }
#line 1007
  return (tmp___0);
}
}
#line 1027 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static int simple_object_mach_o_write_segment(simple_object_write *sobj , int descriptor ,
                                              size_t *nsects , char const   **errmsg ,
                                              int *err ) 
{ 
  struct simple_object_mach_o_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  size_t hdrsize ;
  size_t seghdrsize ;
  size_t sechdrsize ;
  size_t cmdsize ;
  size_t offset ;
  size_t sechdr_offset ;
  size_t secaddr ;
  unsigned int name_offset ;
  simple_object_write_section *section ;
  unsigned char hdrbuf[sizeof(struct mach_o_segment_command_64 )] ;
  unsigned char *hdr ;
  size_t nsects_in ;
  unsigned int *index___0 ;
  char *snames ;
  unsigned int sect ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t mask ;
  size_t new_offset ;
  size_t secsize ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___4 ;
  int tmp___5 ;
  char namebuf[17] ;
  char segnbuf[17] ;
  char *comma ;
  int len ;
  int tmp___6 ;
  size_t secsize___0 ;
  unsigned int i ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  void (*set_64)(unsigned char * , ulong_type  ) ;
  int tmp___12 ;

  {
#line 1032
  attrs = (struct simple_object_mach_o_attributes *)sobj->data;
#line 1051
  if (attrs->is_big_endian) {
#line 1051
    set_32 = & simple_object_set_big_32;
  } else {
#line 1051
    set_32 = & simple_object_set_little_32;
  }
#line 1057
  if (attrs->magic == 4277009102U) {
#line 1059
    hdrsize = sizeof(struct mach_o_header_32 );
#line 1060
    seghdrsize = sizeof(struct mach_o_segment_command_32 );
#line 1061
    sechdrsize = sizeof(struct mach_o_section_32 );
  } else {
#line 1065
    hdrsize = sizeof(struct mach_o_header_64 );
#line 1066
    seghdrsize = sizeof(struct mach_o_segment_command_64 );
#line 1067
    sechdrsize = sizeof(struct mach_o_section_64 );
  }
#line 1070
  name_offset = 0U;
#line 1071
  nsects_in = (size_t )0;
#line 1071
  *nsects = nsects_in;
#line 1075
  section = sobj->sections;
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 1075
      goto while_break;
    }
#line 1076
    nsects_in ++;
#line 1075
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1078
  if ((unsigned long )sobj->segment_name != (unsigned long )((void *)0)) {
    {
#line 1082
    *nsects = (size_t )3;
#line 1092
    tmp___0 = xmalloc(sizeof(unsigned int ) * (nsects_in * 4UL));
#line 1092
    index___0 = (unsigned int *)tmp___0;
#line 1098
    section = sobj->sections;
#line 1098
    sect = 0U;
    }
    {
#line 1098
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1098
      if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 1098
        goto while_break___0;
      }
      {
#line 1101
      *(index___0 + (sect * 4U + 2U)) = name_offset;
#line 1102
      tmp___1 = strlen((char const   *)section->name);
#line 1102
      *(index___0 + (sect * 4U + 3U)) = (unsigned int )(tmp___1 + 1UL);
#line 1103
      tmp___2 = strlen((char const   *)section->name);
#line 1103
      name_offset = (unsigned int )((size_t )name_offset + (tmp___2 + 1UL));
#line 1098
      section = section->next;
#line 1098
      sect ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1105
    tmp___3 = xmalloc(sizeof(char ) * (unsigned long )name_offset);
#line 1105
    snames = (char *)tmp___3;
    }
  } else {
#line 1109
    *nsects = nsects_in;
#line 1110
    index___0 = (unsigned int *)((void *)0);
#line 1111
    snames = (char *)((void *)0);
  }
#line 1114
  sechdr_offset = hdrsize + seghdrsize;
#line 1115
  cmdsize = seghdrsize + *nsects * sechdrsize;
#line 1116
  offset = hdrsize + cmdsize;
#line 1117
  secaddr = (size_t )0;
#line 1119
  section = sobj->sections;
#line 1119
  sect = 0U;
  {
#line 1119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1119
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 1119
      goto while_break___1;
    }
#line 1127
    mask = (size_t )((1U << section->align) - 1U);
#line 1128
    new_offset = offset + mask;
#line 1129
    new_offset &= ~ mask;
    {
#line 1130
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1130
      if (! (new_offset > offset)) {
#line 1130
        goto while_break___2;
      }
      {
#line 1135
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 1136
      write___0 = new_offset - offset;
      }
#line 1137
      if (write___0 > sizeof(zeroes)) {
#line 1138
        write___0 = sizeof(zeroes);
      }
      {
#line 1139
      tmp___4 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(zeroes),
                                             write___0, errmsg, err);
      }
#line 1139
      if (! tmp___4) {
#line 1141
        return (0);
      }
#line 1142
      offset += write___0;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1145
    secsize = (size_t )0;
#line 1146
    buffer___2 = section->buffers;
    {
#line 1146
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1146
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 1146
        goto while_break___3;
      }
      {
#line 1148
      tmp___5 = simple_object_internal_write(descriptor, (off_t )(offset + secsize),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, errmsg, err);
      }
#line 1148
      if (! tmp___5) {
#line 1152
        return (0);
      }
#line 1153
      secsize += buffer___2->size;
#line 1146
      buffer___2 = buffer___2->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1156
    if ((unsigned long )sobj->segment_name != (unsigned long )((void *)0)) {
      {
#line 1158
      *(index___0 + sect * 4U) = (unsigned int )offset;
#line 1159
      *(index___0 + (sect * 4U + 1U)) = (unsigned int )secsize;
#line 1161
      memcpy((void */* __restrict  */)(snames + *(index___0 + (sect * 4U + 2U))),
             (void const   */* __restrict  */)section->name, (size_t )*(index___0 + (sect * 4U + 3U)));
      }
    } else {
      {
#line 1172
      memset((void *)(namebuf), 0, sizeof(namebuf));
#line 1173
      memset((void *)(segnbuf), 0, sizeof(segnbuf));
#line 1174
      comma = strchr((char const   *)section->name, ',');
      }
#line 1175
      if ((unsigned long )comma != (unsigned long )((void *)0)) {
#line 1177
        len = (int )(comma - section->name);
#line 1178
        if (len > 16) {
#line 1178
          len = 16;
        } else {
#line 1178
          len = len;
        }
        {
#line 1179
        strncpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)section->name,
                (size_t )len);
#line 1180
        strncpy((char */* __restrict  */)(segnbuf), (char const   */* __restrict  */)(comma + 1),
                (size_t )16);
        }
      } else {
        {
#line 1183
        strncpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)section->name,
                (size_t )16);
        }
      }
      {
#line 1185
      tmp___6 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                          (char const   *)(namebuf),
                                                          (char const   *)(segnbuf),
                                                          secaddr, secsize, offset,
                                                          section->align, errmsg,
                                                          err);
      }
#line 1185
      if (! tmp___6) {
#line 1192
        return (0);
      }
#line 1193
      sechdr_offset += sechdrsize;
    }
#line 1196
    offset += secsize;
#line 1197
    secaddr += secsize;
#line 1119
    section = section->next;
#line 1119
    sect ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1200
  if ((unsigned long )sobj->segment_name != (unsigned long )((void *)0)) {
    {
#line 1209
    secsize___0 = offset - (size_t )*(index___0 + 0);
#line 1210
    tmp___7 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                        "__wrapper_sects", (char const   *)sobj->segment_name,
                                                        (size_t )0, secsize___0, (size_t )*(index___0 + 0),
                                                        (sobj->sections)->align, errmsg,
                                                        err);
    }
#line 1210
    if (! tmp___7) {
#line 1218
      return (0);
    }
#line 1223
    i = 1U;
    {
#line 1223
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1223
      if (! ((size_t )i < nsects_in)) {
#line 1223
        goto while_break___4;
      }
#line 1224
      *(index___0 + 4U * i) -= *(index___0 + 0);
#line 1223
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 1225
    *(index___0 + 0) = 0U;
#line 1227
    sechdr_offset += sechdrsize;
#line 1233
    tmp___8 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                        "__wrapper_names", (char const   *)sobj->segment_name,
                                                        (size_t )0, (size_t )name_offset,
                                                        offset, 0U, errmsg, err);
    }
#line 1233
    if (! tmp___8) {
#line 1241
      return (0);
    }
    {
#line 1244
    tmp___9 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)snames,
                                           (size_t )name_offset, errmsg, err);
    }
#line 1244
    if (! tmp___9) {
#line 1247
      return (0);
    }
    {
#line 1249
    sechdr_offset += sechdrsize;
#line 1250
    secaddr += (size_t )name_offset;
#line 1251
    offset += (size_t )name_offset;
#line 1256
    offset += 3UL;
#line 1257
    offset &= 0xfffffffffffffffcUL;
#line 1258
    tmp___10 = simple_object_mach_o_write_section_header(sobj, descriptor, sechdr_offset,
                                                         "__wrapper_index", (char const   *)sobj->segment_name,
                                                         (size_t )0, nsects_in * 16UL,
                                                         offset, 2U, errmsg, err);
    }
#line 1258
    if (! tmp___10) {
#line 1266
      return (0);
    }
    {
#line 1269
    tmp___11 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)index___0,
                                            nsects_in * 16UL, errmsg, err);
    }
#line 1269
    if (! tmp___11) {
#line 1272
      return (0);
    }
    {
#line 1274
    free((void *)index___0);
#line 1275
    free((void *)snames);
    }
  }
  {
#line 1280
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 1282
  hdr = & hdrbuf[0];
  }
#line 1283
  if (attrs->magic == 4277009102U) {
    {
#line 1285
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->cmd),
              1U);
#line 1287
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->cmdsize),
              (unsigned int )cmdsize);
#line 1293
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->fileoff),
              (unsigned int )(hdrsize + cmdsize));
#line 1295
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->filesize),
              (unsigned int )(offset - (hdrsize + cmdsize)));
#line 1299
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_32 *)0)->nsects),
              (unsigned int )*nsects);
    }
  } else {
#line 1308
    if (attrs->is_big_endian) {
#line 1308
      set_64 = & simple_object_set_big_64;
    } else {
#line 1308
      set_64 = & simple_object_set_little_64;
    }
    {
#line 1312
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->cmd),
              1U);
#line 1314
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->cmdsize),
              (unsigned int )cmdsize);
#line 1320
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->fileoff),
              hdrsize + cmdsize);
#line 1322
    (*set_64)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->filesize),
              offset - (hdrsize + cmdsize));
#line 1326
    (*set_32)(hdr + (unsigned long )(& ((struct mach_o_segment_command_64 *)0)->nsects),
              (unsigned int )*nsects);
    }
  }
  {
#line 1332
  tmp___12 = simple_object_internal_write(descriptor, (off_t )hdrsize, (unsigned char const   *)hdr,
                                          seghdrsize, errmsg, err);
  }
#line 1332
  return (tmp___12);
}
}
#line 1338 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static char const   *simple_object_mach_o_write_to_file(simple_object_write *sobj ,
                                                        int descriptor , int *err ) 
{ 
  size_t nsects ;
  char const   *errmsg ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1342
  nsects = (size_t )0;
#line 1345
  tmp___0 = simple_object_mach_o_write_segment(sobj, descriptor, & nsects, & errmsg,
                                               err);
  }
#line 1345
  if (! tmp___0) {
#line 1347
    return (errmsg);
  }
  {
#line 1349
  tmp___1 = simple_object_mach_o_write_header(sobj, descriptor, nsects, & errmsg,
                                              err);
  }
#line 1349
  if (! tmp___1) {
#line 1351
    return (errmsg);
  }
#line 1353
  return ((char const   *)((void *)0));
}
}
#line 1358 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
static void simple_object_mach_o_release_write(void *data ) 
{ 


  {
  {
#line 1361
  free(data);
  }
#line 1362
  return;
}
}
#line 1366 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-mach-o.c"
struct simple_object_functions  const  simple_object_mach_o_functions  = 
#line 1366
     {& simple_object_mach_o_match, & simple_object_mach_o_find_sections, & simple_object_mach_o_fetch_attributes,
    & simple_object_mach_o_release_read, & simple_object_mach_o_attributes_merge,
    & simple_object_mach_o_release_attributes, & simple_object_mach_o_start_write,
    & simple_object_mach_o_write_to_file, & simple_object_mach_o_release_write};
#line 181 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static unsigned short simple_object_fetch_big_16(unsigned char const   *buf___4 ) 
{ 


  {
#line 184
  return ((unsigned short )(((int )((unsigned short )*(buf___4 + 0)) << 8) | (int )((unsigned short )*(buf___4 + 1))));
}
}
#line 189 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static unsigned short simple_object_fetch_little_16(unsigned char const   *buf___4 ) 
{ 


  {
#line 192
  return ((unsigned short )(((int )((unsigned short )*(buf___4 + 1)) << 8) | (int )((unsigned short )*(buf___4 + 0))));
}
}
#line 219 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_big_32_ulong(unsigned char const   *buf___4 ) 
{ 
  unsigned int tmp___0 ;

  {
  {
#line 222
  tmp___0 = simple_object_fetch_big_32(buf___4);
  }
#line 222
  return ((ulong_type )tmp___0);
}
}
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static ulong_type simple_object_fetch_little_32_ulong(unsigned char const   *buf___4 ) 
{ 
  unsigned int tmp___0 ;

  {
  {
#line 230
  tmp___0 = simple_object_fetch_little_32(buf___4);
  }
#line 230
  return ((ulong_type )tmp___0);
}
}
#line 269 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_16(unsigned char *buf___4 , unsigned short val ) 
{ 


  {
#line 272
  *(buf___4 + 0) = (unsigned char )(((int )val >> 8) & 255);
#line 273
  *(buf___4 + 1) = (unsigned char )((int )val & 255);
#line 274
  return;
}
}
#line 278 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_16(unsigned char *buf___4 , unsigned short val ) 
{ 


  {
#line 281
  *(buf___4 + 1) = (unsigned char )(((int )val >> 8) & 255);
#line 282
  *(buf___4 + 0) = (unsigned char )((int )val & 255);
#line 283
  return;
}
}
#line 309 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_big_32_ulong(unsigned char *buf___4 , ulong_type val ) 
{ 


  {
  {
#line 312
  simple_object_set_big_32(buf___4, (unsigned int )val);
  }
#line 313
  return;
}
}
#line 317 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-common.h"
__inline static void simple_object_set_little_32_ulong(unsigned char *buf___4 , ulong_type val ) 
{ 


  {
  {
#line 320
  simple_object_set_little_32(buf___4, (unsigned int )val);
  }
#line 321
  return;
}
}
#line 202 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_big_32_functions  =    {& simple_object_fetch_big_16, & simple_object_fetch_big_32, & simple_object_fetch_big_32_ulong,
    & simple_object_set_big_16, & simple_object_set_big_32, & simple_object_set_big_32_ulong};
#line 212 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_little_32_functions  =    {& simple_object_fetch_little_16, & simple_object_fetch_little_32, & simple_object_fetch_little_32_ulong,
    & simple_object_set_little_16, & simple_object_set_little_32, & simple_object_set_little_32_ulong};
#line 224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_big_64_functions  =    {& simple_object_fetch_big_16, & simple_object_fetch_big_32, & simple_object_fetch_big_64,
    & simple_object_set_big_16, & simple_object_set_big_32, & simple_object_set_big_64};
#line 234 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static struct elf_type_functions  const  elf_little_64_functions  =    {& simple_object_fetch_little_16, & simple_object_fetch_little_32, & simple_object_fetch_little_64,
    & simple_object_set_little_16, & simple_object_set_little_32, & simple_object_set_little_64};
#line 353 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static void *simple_object_elf_match(unsigned char *header , int descriptor , off_t offset ,
                                     char const   *segment_name  __attribute__((__unused__)) ,
                                     char const   **errmsg , int *err ) 
{ 
  unsigned char ei_data ;
  unsigned char ei_class ;
  struct elf_type_functions  const  *type_functions ;
  unsigned char ehdr[sizeof(Elf64_External_Ehdr )] ;
  struct simple_object_elf_read *eor ;
  int tmp___0 ;
  void *tmp___1 ;
  unsigned short tmp___2 ;
  unsigned short tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  ulong_type tmp___6 ;
  ulong_type tmp___7 ;
  unsigned short tmp___8 ;
  unsigned short tmp___9 ;
  unsigned short tmp___10 ;
  unsigned short tmp___11 ;
  unsigned char shdr[sizeof(Elf64_External_Shdr )] ;
  unsigned long tmp___12 ;
  int tmp___13 ;
  ulong_type tmp___14 ;
  ulong_type tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;

  {
#line 365
  if ((int )*(header + 0) != 127) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 1) != 69) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 2) != 76) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 3) != 70) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  } else
#line 365
  if ((int )*(header + 6) != 1) {
#line 371
    *errmsg = (char const   *)((void *)0);
#line 372
    *err = 0;
#line 373
    return ((void *)0);
  }
#line 376
  ei_data = *(header + 5);
#line 377
  if ((int )ei_data != 1) {
#line 377
    if ((int )ei_data != 2) {
#line 379
      *errmsg = "unknown ELF endianness";
#line 380
      *err = 0;
#line 381
      return ((void *)0);
    }
  }
#line 384
  ei_class = *(header + 4);
  {
#line 387
  if ((int )ei_class == 1) {
#line 387
    goto case_1;
  }
#line 393
  if ((int )ei_class == 2) {
#line 393
    goto case_2;
  }
#line 405
  goto switch_default;
  case_1: /* CIL Label */ 
#line 388
  if ((int )ei_data == 1) {
#line 388
    type_functions = & elf_little_32_functions;
  } else {
#line 388
    type_functions = & elf_big_32_functions;
  }
#line 391
  goto switch_break;
  case_2: /* CIL Label */ 
#line 399
  if ((int )ei_data == 1) {
#line 399
    type_functions = & elf_little_64_functions;
  } else {
#line 399
    type_functions = & elf_big_64_functions;
  }
#line 402
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 406
  *errmsg = "unrecognized ELF size";
#line 407
  *err = 0;
#line 408
  return ((void *)0);
  switch_break: /* CIL Label */ ;
  }
  {
#line 411
  tmp___0 = simple_object_internal_read(descriptor, offset, ehdr, sizeof(ehdr), errmsg,
                                        err);
  }
#line 411
  if (! tmp___0) {
#line 413
    return ((void *)0);
  }
  {
#line 415
  tmp___1 = xmalloc(sizeof(struct simple_object_elf_read ));
#line 415
  eor = (struct simple_object_elf_read *)tmp___1;
#line 416
  eor->type_functions = type_functions;
#line 417
  eor->ei_data = ei_data;
#line 418
  eor->ei_class = ei_class;
#line 419
  eor->ei_osabi = *(header + 7);
  }
#line 420
  if ((int )ei_class == 1) {
    {
#line 420
    tmp___2 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_machine)));
#line 420
    eor->machine = tmp___2;
    }
  } else {
    {
#line 420
    tmp___3 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_machine)));
#line 420
    eor->machine = tmp___3;
    }
  }
#line 422
  if ((int )ei_class == 1) {
    {
#line 422
    tmp___4 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_flags)));
#line 422
    eor->flags = tmp___4;
    }
  } else {
    {
#line 422
    tmp___5 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_flags)));
#line 422
    eor->flags = tmp___5;
    }
  }
#line 424
  if ((int )ei_class == 1) {
    {
#line 424
    tmp___6 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shoff)));
#line 424
    eor->shoff = tmp___6;
    }
  } else {
    {
#line 424
    tmp___7 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shoff)));
#line 424
    eor->shoff = tmp___7;
    }
  }
#line 426
  if ((int )ei_class == 1) {
    {
#line 426
    tmp___8 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shnum)));
#line 426
    eor->shnum = (unsigned int )tmp___8;
    }
  } else {
    {
#line 426
    tmp___9 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shnum)));
#line 426
    eor->shnum = (unsigned int )tmp___9;
    }
  }
#line 428
  if ((int )ei_class == 1) {
    {
#line 428
    tmp___10 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shstrndx)));
#line 428
    eor->shstrndx = (unsigned int )tmp___10;
    }
  } else {
    {
#line 428
    tmp___11 = (*(type_functions->fetch_Elf_Half))((unsigned char const   *)(ehdr + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shstrndx)));
#line 428
    eor->shstrndx = (unsigned int )tmp___11;
    }
  }
#line 431
  if (eor->shnum == 0U) {
#line 431
    goto _L;
  } else
#line 431
  if (eor->shstrndx == 65535U) {
    _L: /* CIL Label */ 
#line 431
    if (eor->shoff != 0UL) {
#line 438
      if ((int )ei_class == 1) {
#line 438
        tmp___12 = sizeof(Elf32_External_Shdr );
      } else {
#line 438
        tmp___12 = sizeof(Elf64_External_Shdr );
      }
      {
#line 438
      tmp___13 = simple_object_internal_read(descriptor, (off_t )((ulong_type )offset + eor->shoff),
                                             shdr, tmp___12, errmsg, err);
      }
#line 438
      if (! tmp___13) {
        {
#line 444
        free((void *)eor);
        }
#line 445
        return ((void *)0);
      }
#line 448
      if (eor->shnum == 0U) {
#line 449
        if ((int )ei_class == 1) {
          {
#line 449
          tmp___14 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size)));
#line 449
          eor->shnum = (unsigned int )tmp___14;
          }
        } else {
          {
#line 449
          tmp___15 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size)));
#line 449
          eor->shnum = (unsigned int )tmp___15;
          }
        }
      }
#line 452
      if (eor->shstrndx == 65535U) {
#line 454
        if ((int )ei_class == 1) {
          {
#line 454
          tmp___16 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_link)));
#line 454
          eor->shstrndx = tmp___16;
          }
        } else {
          {
#line 454
          tmp___17 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_link)));
#line 454
          eor->shstrndx = tmp___17;
          }
        }
#line 468
        if (eor->shstrndx >= eor->shnum) {
#line 468
          if (eor->shstrndx >= 65536U) {
#line 470
            eor->shstrndx -= 256U;
          }
        }
      }
    }
  }
#line 474
  if (eor->shstrndx >= eor->shnum) {
    {
#line 476
    *errmsg = "invalid ELF shstrndx >= shnum";
#line 477
    *err = 0;
#line 478
    free((void *)eor);
    }
#line 479
    return ((void *)0);
  }
#line 482
  return ((void *)eor);
}
}
#line 487 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static char const   *simple_object_elf_find_sections(simple_object_read *sobj , int (*pfn)(void * ,
                                                                                           char const   * ,
                                                                                           off_t offset ,
                                                                                           off_t length ) ,
                                                     void *data , int *err ) 
{ 
  struct simple_object_elf_read *eor ;
  struct elf_type_functions  const  *type_functions ;
  unsigned char ei_class ;
  size_t shdr_size ;
  unsigned int shnum ;
  unsigned char *shdrs ;
  char const   *errmsg ;
  unsigned char *shstrhdr ;
  size_t name_size ;
  off_t shstroff ;
  unsigned char *names ;
  unsigned int i ;
  void *tmp___0 ;
  int tmp___1 ;
  ulong_type tmp___2 ;
  ulong_type tmp___3 ;
  ulong_type tmp___4 ;
  ulong_type tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  unsigned char *shdr ;
  unsigned int sh_name ;
  char const   *name___0 ;
  off_t offset ;
  off_t length ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  ulong_type tmp___10 ;
  ulong_type tmp___11 ;
  ulong_type tmp___12 ;
  ulong_type tmp___13 ;
  int tmp___14 ;

  {
#line 494
  eor = (struct simple_object_elf_read *)sobj->data;
#line 496
  type_functions = eor->type_functions;
#line 497
  ei_class = eor->ei_class;
#line 508
  if ((int )ei_class == 1) {
#line 508
    shdr_size = sizeof(Elf32_External_Shdr );
  } else {
#line 508
    shdr_size = sizeof(Elf64_External_Shdr );
  }
  {
#line 515
  shnum = eor->shnum;
#line 516
  tmp___0 = xmalloc(sizeof(unsigned char ) * (shdr_size * (size_t )(shnum - 1U)));
#line 516
  shdrs = (unsigned char *)tmp___0;
#line 518
  tmp___1 = simple_object_internal_read(sobj->descriptor, (off_t )(((ulong_type )sobj->offset + eor->shoff) + shdr_size),
                                        shdrs, shdr_size * (size_t )(shnum - 1U),
                                        & errmsg, err);
  }
#line 518
  if (! tmp___1) {
    {
#line 524
    free((void *)shdrs);
    }
#line 525
    return (errmsg);
  }
#line 530
  shstrhdr = shdrs + (size_t )(eor->shstrndx - 1U) * shdr_size;
#line 531
  if ((int )ei_class == 1) {
    {
#line 531
    tmp___2 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size)));
#line 531
    name_size = tmp___2;
    }
  } else {
    {
#line 531
    tmp___3 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size)));
#line 531
    name_size = tmp___3;
    }
  }
#line 533
  if ((int )ei_class == 1) {
    {
#line 533
    tmp___4 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_offset)));
#line 533
    shstroff = (off_t )tmp___4;
    }
  } else {
    {
#line 533
    tmp___5 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shstrhdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_offset)));
#line 533
    shstroff = (off_t )tmp___5;
    }
  }
  {
#line 535
  tmp___6 = xmalloc(sizeof(unsigned char ) * name_size);
#line 535
  names = (unsigned char *)tmp___6;
#line 536
  tmp___7 = simple_object_internal_read(sobj->descriptor, sobj->offset + shstroff,
                                        names, name_size, & errmsg, err);
  }
#line 536
  if (! tmp___7) {
    {
#line 540
    free((void *)names);
#line 541
    free((void *)shdrs);
    }
#line 542
    return (errmsg);
  }
#line 545
  i = 1U;
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (! (i < shnum)) {
#line 545
      goto while_break;
    }
#line 553
    shdr = shdrs + (size_t )(i - 1U) * shdr_size;
#line 554
    if ((int )ei_class == 1) {
      {
#line 554
      tmp___8 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_name)));
#line 554
      sh_name = tmp___8;
      }
    } else {
      {
#line 554
      tmp___9 = (*(type_functions->fetch_Elf_Word))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_name)));
#line 554
      sh_name = tmp___9;
      }
    }
#line 556
    if ((size_t )sh_name >= name_size) {
      {
#line 558
      *err = 0;
#line 559
      free((void *)names);
#line 560
      free((void *)shdrs);
      }
#line 561
      return ("ELF section name out of range");
    }
#line 564
    name___0 = (char const   *)names + sh_name;
#line 565
    if ((int )ei_class == 1) {
      {
#line 565
      tmp___10 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_offset)));
#line 565
      offset = (off_t )tmp___10;
      }
    } else {
      {
#line 565
      tmp___11 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_offset)));
#line 565
      offset = (off_t )tmp___11;
      }
    }
#line 567
    if ((int )ei_class == 1) {
      {
#line 567
      tmp___12 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size)));
#line 567
      length = (off_t )tmp___12;
      }
    } else {
      {
#line 567
      tmp___13 = (*(type_functions->fetch_Elf_Addr))((unsigned char const   *)(shdr + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size)));
#line 567
      length = (off_t )tmp___13;
      }
    }
    {
#line 570
    tmp___14 = (*pfn)(data, name___0, offset, length);
    }
#line 570
    if (! tmp___14) {
#line 571
      goto while_break;
    }
#line 545
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 574
  free((void *)names);
#line 575
  free((void *)shdrs);
  }
#line 577
  return ((char const   *)((void *)0));
}
}
#line 582 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static void *simple_object_elf_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_elf_read *eor ;
  struct simple_object_elf_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 587
  eor = (struct simple_object_elf_read *)sobj->data;
#line 591
  tmp___0 = xmalloc(sizeof(struct simple_object_elf_attributes ));
#line 591
  ret = (struct simple_object_elf_attributes *)tmp___0;
#line 592
  ret->type_functions = eor->type_functions;
#line 593
  ret->ei_data = eor->ei_data;
#line 594
  ret->ei_class = eor->ei_class;
#line 595
  ret->ei_osabi = eor->ei_osabi;
#line 596
  ret->machine = eor->machine;
#line 597
  ret->flags = eor->flags;
  }
#line 598
  return ((void *)ret);
}
}
#line 603 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static void simple_object_elf_release_read(void *data ) 
{ 


  {
  {
#line 606
  free(data);
  }
#line 607
  return;
}
}
#line 611 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static char const   *simple_object_elf_attributes_merge(void *todata , void *fromdata ,
                                                        int *err ) 
{ 
  struct simple_object_elf_attributes *to ;
  struct simple_object_elf_attributes *from ;
  int ok ;

  {
#line 614
  to = (struct simple_object_elf_attributes *)todata;
#line 616
  from = (struct simple_object_elf_attributes *)fromdata;
#line 619
  if ((int )to->ei_data != (int )from->ei_data) {
#line 621
    *err = 0;
#line 622
    return ("ELF object format mismatch");
  } else
#line 619
  if ((int )to->ei_class != (int )from->ei_class) {
#line 621
    *err = 0;
#line 622
    return ("ELF object format mismatch");
  }
#line 625
  if ((int )to->machine != (int )from->machine) {
#line 631
    ok = 0;
    {
#line 634
    if ((int )to->machine == 2) {
#line 634
      goto case_2;
    }
#line 642
    if ((int )to->machine == 18) {
#line 642
      goto case_18;
    }
#line 647
    goto switch_default;
    case_2: /* CIL Label */ 
#line 635
    if ((int )from->machine == 18) {
#line 637
      to->machine = from->machine;
#line 638
      ok = 1;
    }
#line 640
    goto switch_break;
    case_18: /* CIL Label */ 
#line 643
    if ((int )from->machine == 2) {
#line 644
      ok = 1;
    }
#line 645
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 648
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 651
    if (! ok) {
#line 653
      *err = 0;
#line 654
      return ("ELF machine number mismatch");
    }
  }
#line 658
  return ((char const   *)((void *)0));
}
}
#line 663 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static void simple_object_elf_release_attributes(void *data ) 
{ 


  {
  {
#line 666
  free(data);
  }
#line 667
  return;
}
}
#line 671 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static void *simple_object_elf_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                           int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  struct simple_object_elf_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 676
  attrs = (struct simple_object_elf_attributes *)attributes_data;
#line 682
  tmp___0 = xmalloc(sizeof(struct simple_object_elf_attributes ));
#line 682
  ret = (struct simple_object_elf_attributes *)tmp___0;
#line 683
  *ret = *attrs;
  }
#line 684
  return ((void *)ret);
}
}
#line 689 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static int simple_object_elf_write_ehdr(simple_object_write *sobj , int descriptor ,
                                        char const   **errmsg , int *err ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  struct elf_type_functions  const  *fns ;
  unsigned char cl ;
  size_t ehdr_size ;
  unsigned char buf___4[sizeof(Elf64_External_Ehdr )] ;
  simple_object_write_section *section ;
  unsigned int shnum ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;

  {
#line 693
  attrs = (struct simple_object_elf_attributes *)sobj->data;
#line 702
  fns = attrs->type_functions;
#line 703
  cl = attrs->ei_class;
#line 705
  shnum = 0U;
#line 706
  section = sobj->sections;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 706
      goto while_break;
    }
#line 707
    shnum ++;
#line 706
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if (shnum > 0U) {
#line 712
    shnum += 2U;
  }
#line 715
  if ((int )cl == 1) {
#line 715
    ehdr_size = sizeof(Elf32_External_Ehdr );
  } else {
#line 715
    ehdr_size = sizeof(Elf64_External_Ehdr );
  }
  {
#line 718
  memset((void *)(buf___4), 0, sizeof(Elf64_External_Ehdr ));
#line 720
  buf___4[0] = (unsigned char)127;
#line 721
  buf___4[1] = (unsigned char )'E';
#line 722
  buf___4[2] = (unsigned char )'L';
#line 723
  buf___4[3] = (unsigned char )'F';
#line 724
  buf___4[4] = cl;
#line 725
  buf___4[5] = attrs->ei_data;
#line 726
  buf___4[6] = (unsigned char)1;
#line 727
  buf___4[7] = attrs->ei_osabi;
  }
#line 729
  if ((int )cl == 1) {
    {
#line 729
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_type),
                           (unsigned short)1);
    }
  } else {
    {
#line 729
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_type),
                           (unsigned short)1);
    }
  }
#line 730
  if ((int )cl == 1) {
    {
#line 730
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_machine),
                           attrs->machine);
    }
  } else {
    {
#line 730
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_machine),
                           attrs->machine);
    }
  }
#line 731
  if ((int )cl == 1) {
    {
#line 731
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_version),
                           1U);
    }
  } else {
    {
#line 731
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_version),
                           1U);
    }
  }
#line 734
  if ((int )cl == 1) {
    {
#line 734
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shoff),
                           ehdr_size);
    }
  } else {
    {
#line 734
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shoff),
                           ehdr_size);
    }
  }
#line 735
  if ((int )cl == 1) {
    {
#line 735
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_flags),
                           attrs->flags);
    }
  } else {
    {
#line 735
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_flags),
                           attrs->flags);
    }
  }
#line 736
  if ((int )cl == 1) {
    {
#line 736
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_ehsize),
                           (unsigned short )ehdr_size);
    }
  } else {
    {
#line 736
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_ehsize),
                           (unsigned short )ehdr_size);
    }
  }
#line 737
  if ((int )cl == 1) {
#line 737
    if ((int )cl == 1) {
#line 737
      tmp___1 = sizeof(Elf32_External_Phdr );
    } else {
#line 737
      tmp___1 = sizeof(Elf64_External_Phdr );
    }
    {
#line 737
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_phentsize),
                           (unsigned short )tmp___1);
    }
  } else {
#line 737
    if ((int )cl == 1) {
#line 737
      tmp___0 = sizeof(Elf32_External_Phdr );
    } else {
#line 737
      tmp___0 = sizeof(Elf64_External_Phdr );
    }
    {
#line 737
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_phentsize),
                           (unsigned short )tmp___0);
    }
  }
#line 742
  if ((int )cl == 1) {
#line 742
    if ((int )cl == 1) {
#line 742
      tmp___3 = sizeof(Elf32_External_Shdr );
    } else {
#line 742
      tmp___3 = sizeof(Elf64_External_Shdr );
    }
    {
#line 742
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shentsize),
                           (unsigned short )tmp___3);
    }
  } else {
#line 742
    if ((int )cl == 1) {
#line 742
      tmp___2 = sizeof(Elf32_External_Shdr );
    } else {
#line 742
      tmp___2 = sizeof(Elf64_External_Shdr );
    }
    {
#line 742
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shentsize),
                           (unsigned short )tmp___2);
    }
  }
#line 746
  if ((int )cl == 1) {
    {
#line 746
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shnum),
                           (unsigned short )shnum);
    }
  } else {
    {
#line 746
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shnum),
                           (unsigned short )shnum);
    }
  }
#line 747
  if ((int )cl == 1) {
#line 747
    if (shnum == 0U) {
#line 747
      tmp___5 = 0U;
    } else {
#line 747
      tmp___5 = shnum - 1U;
    }
    {
#line 747
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf32_External_Ehdr *)0)->e_shstrndx),
                           (unsigned short )tmp___5);
    }
  } else {
#line 747
    if (shnum == 0U) {
#line 747
      tmp___4 = 0U;
    } else {
#line 747
      tmp___4 = shnum - 1U;
    }
    {
#line 747
    (*(fns->set_Elf_Half))(buf___4 + (unsigned long )(& ((Elf64_External_Ehdr *)0)->e_shstrndx),
                           (unsigned short )tmp___4);
    }
  }
  {
#line 750
  tmp___6 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(buf___4),
                                         ehdr_size, errmsg, err);
  }
#line 750
  return (tmp___6);
}
}
#line 756 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static int simple_object_elf_write_shdr(simple_object_write *sobj , int descriptor ,
                                        off_t offset , unsigned int sh_name , unsigned int sh_type ,
                                        unsigned int sh_flags , unsigned int sh_offset ,
                                        unsigned int sh_size , unsigned int sh_addralign ,
                                        char const   **errmsg , int *err ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  struct elf_type_functions  const  *fns ;
  unsigned char cl ;
  size_t shdr_size ;
  unsigned char buf___4[sizeof(Elf64_External_Shdr )] ;
  int tmp___0 ;

  {
#line 764
  attrs = (struct simple_object_elf_attributes *)sobj->data;
#line 771
  fns = attrs->type_functions;
#line 772
  cl = attrs->ei_class;
#line 774
  if ((int )cl == 1) {
#line 774
    shdr_size = sizeof(Elf32_External_Shdr );
  } else {
#line 774
    shdr_size = sizeof(Elf64_External_Shdr );
  }
  {
#line 777
  memset((void *)(buf___4), 0, sizeof(Elf64_External_Shdr ));
  }
#line 779
  if ((int )cl == 1) {
    {
#line 779
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_name),
                           sh_name);
    }
  } else {
    {
#line 779
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_name),
                           sh_name);
    }
  }
#line 780
  if ((int )cl == 1) {
    {
#line 780
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_type),
                           sh_type);
    }
  } else {
    {
#line 780
    (*(fns->set_Elf_Word))(buf___4 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_type),
                           sh_type);
    }
  }
#line 781
  if ((int )cl == 1) {
    {
#line 781
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_flags),
                           (ulong_type )sh_flags);
    }
  } else {
    {
#line 781
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_flags),
                           (ulong_type )sh_flags);
    }
  }
#line 782
  if ((int )cl == 1) {
    {
#line 782
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_offset),
                           (ulong_type )sh_offset);
    }
  } else {
    {
#line 782
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_offset),
                           (ulong_type )sh_offset);
    }
  }
#line 783
  if ((int )cl == 1) {
    {
#line 783
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_size),
                           (ulong_type )sh_size);
    }
  } else {
    {
#line 783
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_size),
                           (ulong_type )sh_size);
    }
  }
#line 786
  if ((int )cl == 1) {
    {
#line 786
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf32_External_Shdr *)0)->sh_addralign),
                           (ulong_type )sh_addralign);
    }
  } else {
    {
#line 786
    (*(fns->set_Elf_Addr))(buf___4 + (unsigned long )(& ((Elf64_External_Shdr *)0)->sh_addralign),
                           (ulong_type )sh_addralign);
    }
  }
  {
#line 789
  tmp___0 = simple_object_internal_write(descriptor, offset, (unsigned char const   *)(buf___4),
                                         shdr_size, errmsg, err);
  }
#line 789
  return (tmp___0);
}
}
#line 801 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static char const   *simple_object_elf_write_to_file(simple_object_write *sobj , int descriptor ,
                                                     int *err ) 
{ 
  struct simple_object_elf_attributes *attrs ;
  unsigned char cl ;
  size_t ehdr_size ;
  size_t shdr_size ;
  char const   *errmsg ;
  simple_object_write_section *section ;
  unsigned int shnum ;
  size_t shdr_offset ;
  size_t sh_offset ;
  size_t sh_name ;
  unsigned char zero ;
  int tmp___0 ;
  int tmp___1 ;
  size_t mask ;
  size_t new_sh_offset ;
  size_t sh_size ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t len ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 805
  attrs = (struct simple_object_elf_attributes *)sobj->data;
#line 818
  tmp___0 = simple_object_elf_write_ehdr(sobj, descriptor, & errmsg, err);
  }
#line 818
  if (! tmp___0) {
#line 819
    return (errmsg);
  }
#line 821
  cl = attrs->ei_class;
#line 822
  if ((int )cl == 1) {
#line 824
    ehdr_size = sizeof(Elf32_External_Ehdr );
#line 825
    shdr_size = sizeof(Elf32_External_Shdr );
  } else {
#line 829
    ehdr_size = sizeof(Elf64_External_Ehdr );
#line 830
    shdr_size = sizeof(Elf64_External_Shdr );
  }
#line 833
  shnum = 0U;
#line 834
  section = sobj->sections;
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 834
      goto while_break;
    }
#line 835
    shnum ++;
#line 834
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 836
  if (shnum == 0U) {
#line 837
    return ((char const   *)((void *)0));
  }
  {
#line 840
  shnum += 2U;
#line 842
  shdr_offset = ehdr_size;
#line 843
  sh_offset = shdr_offset + (size_t )shnum * shdr_size;
#line 845
  tmp___1 = simple_object_elf_write_shdr(sobj, descriptor, (off_t )shdr_offset, 0U,
                                         0U, 0U, 0U, 0U, 0U, & errmsg, err);
  }
#line 845
  if (! tmp___1) {
#line 847
    return (errmsg);
  }
#line 849
  shdr_offset += shdr_size;
#line 851
  sh_name = (size_t )1;
#line 852
  section = sobj->sections;
  {
#line 852
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 852
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 852
      goto while_break___0;
    }
#line 859
    mask = (size_t )((1U << section->align) - 1U);
#line 860
    new_sh_offset = sh_offset + mask;
#line 861
    new_sh_offset &= ~ mask;
    {
#line 862
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 862
      if (! (new_sh_offset > sh_offset)) {
#line 862
        goto while_break___1;
      }
      {
#line 867
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 868
      write___0 = new_sh_offset - sh_offset;
      }
#line 869
      if (write___0 > sizeof(zeroes)) {
#line 870
        write___0 = sizeof(zeroes);
      }
      {
#line 871
      tmp___2 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)(zeroes),
                                             write___0, & errmsg, err);
      }
#line 871
      if (! tmp___2) {
#line 873
        return (errmsg);
      }
#line 874
      sh_offset += write___0;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 877
    sh_size = (size_t )0;
#line 878
    buffer___2 = section->buffers;
    {
#line 878
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 878
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 878
        goto while_break___2;
      }
      {
#line 880
      tmp___3 = simple_object_internal_write(descriptor, (off_t )(sh_offset + sh_size),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, & errmsg, err);
      }
#line 880
      if (! tmp___3) {
#line 884
        return (errmsg);
      }
#line 885
      sh_size += buffer___2->size;
#line 878
      buffer___2 = buffer___2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 888
    tmp___4 = simple_object_elf_write_shdr(sobj, descriptor, (off_t )shdr_offset,
                                           (unsigned int )sh_name, 1U, 0U, (unsigned int )sh_offset,
                                           (unsigned int )sh_size, 1U << section->align,
                                           & errmsg, err);
    }
#line 888
    if (! tmp___4) {
#line 892
      return (errmsg);
    }
    {
#line 894
    shdr_offset += shdr_size;
#line 895
    tmp___5 = strlen((char const   *)section->name);
#line 895
    sh_name += tmp___5 + 1UL;
#line 896
    sh_offset += sh_size;
#line 852
    section = section->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 899
  tmp___6 = strlen(".shstrtab");
#line 899
  tmp___7 = simple_object_elf_write_shdr(sobj, descriptor, (off_t )shdr_offset, (unsigned int )sh_name,
                                         3U, 0U, (unsigned int )sh_offset, (unsigned int )((sh_name + tmp___6) + 1UL),
                                         1U, & errmsg, err);
  }
#line 899
  if (! tmp___7) {
#line 903
    return (errmsg);
  }
  {
#line 906
  zero = (unsigned char)0;
#line 907
  tmp___8 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)(& zero),
                                         (size_t )1, & errmsg, err);
  }
#line 907
  if (! tmp___8) {
#line 909
    return (errmsg);
  }
#line 910
  sh_offset ++;
#line 912
  section = sobj->sections;
  {
#line 912
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 912
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 912
      goto while_break___3;
    }
    {
#line 916
    tmp___9 = strlen((char const   *)section->name);
#line 916
    len = tmp___9 + 1UL;
#line 917
    tmp___10 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)section->name,
                                            len, & errmsg, err);
    }
#line 917
    if (! tmp___10) {
#line 920
      return (errmsg);
    }
#line 921
    sh_offset += len;
#line 912
    section = section->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 924
  tmp___11 = strlen(".shstrtab");
#line 924
  tmp___12 = simple_object_internal_write(descriptor, (off_t )sh_offset, (unsigned char const   *)".shstrtab",
                                          tmp___11 + 1UL, & errmsg, err);
  }
#line 924
  if (! tmp___12) {
#line 927
    return (errmsg);
  }
#line 929
  return ((char const   *)((void *)0));
}
}
#line 934 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
static void simple_object_elf_release_write(void *data ) 
{ 


  {
  {
#line 937
  free(data);
  }
#line 938
  return;
}
}
#line 942 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-elf.c"
struct simple_object_functions  const  simple_object_elf_functions  = 
#line 942
     {& simple_object_elf_match, & simple_object_elf_find_sections, & simple_object_elf_fetch_attributes,
    & simple_object_elf_release_read, & simple_object_elf_attributes_merge, & simple_object_elf_release_attributes,
    & simple_object_elf_start_write, & simple_object_elf_write_to_file, & simple_object_elf_release_write};
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static struct coff_magic_struct  const  coff_magic[2]  = {      {(unsigned short)332, (unsigned char)0, (unsigned short)12290}, 
        {(unsigned short)34404, (unsigned char)0, (unsigned short)12290}};
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static void *simple_object_coff_match(unsigned char *header , int descriptor , off_t offset ,
                                      char const   *segment_name  __attribute__((__unused__)) ,
                                      char const   **errmsg , int *err ) 
{ 
  size_t c ;
  unsigned short magic_big ;
  unsigned short magic_little ;
  unsigned short magic ;
  size_t i ;
  int is_big_endian ;
  unsigned short (*fetch_16)(unsigned char const   * ) ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  unsigned char hdrbuf[sizeof(struct external_filehdr )] ;
  unsigned short flags___1 ;
  struct simple_object_coff_read *ocr ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  unsigned int tmp___3 ;
  unsigned short tmp___4 ;

  {
  {
#line 245
  c = sizeof(coff_magic) / sizeof(coff_magic[0]);
#line 246
  magic_big = simple_object_fetch_big_16((unsigned char const   *)header);
#line 247
  magic_little = simple_object_fetch_little_16((unsigned char const   *)header);
#line 248
  i = (size_t )0;
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i < c)) {
#line 248
      goto while_break;
    }
#line 250
    if (coff_magic[i].is_big_endian) {
#line 250
      tmp___0 = (int const   )coff_magic[i].magic == (int const   )magic_big;
    } else {
#line 250
      tmp___0 = (int const   )coff_magic[i].magic == (int const   )magic_little;
    }
#line 250
    if (tmp___0) {
#line 253
      goto while_break;
    }
#line 248
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  if (i >= c) {
#line 257
    *errmsg = (char const   *)((void *)0);
#line 258
    *err = 0;
#line 259
    return ((void *)0);
  }
#line 261
  is_big_endian = (int )coff_magic[i].is_big_endian;
#line 263
  if (is_big_endian) {
#line 263
    magic = magic_big;
  } else {
#line 263
    magic = magic_little;
  }
#line 264
  if (is_big_endian) {
#line 264
    fetch_16 = & simple_object_fetch_big_16;
  } else {
#line 264
    fetch_16 = & simple_object_fetch_little_16;
  }
#line 267
  if (is_big_endian) {
#line 267
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 267
    fetch_32 = & simple_object_fetch_little_32;
  }
  {
#line 271
  tmp___1 = simple_object_internal_read(descriptor, offset, hdrbuf, sizeof(hdrbuf),
                                        errmsg, err);
  }
#line 271
  if (! tmp___1) {
#line 273
    return ((void *)0);
  }
  {
#line 275
  flags___1 = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->f_flags)));
  }
#line 276
  if (((int )flags___1 & (int )coff_magic[i].non_object_flags) != 0) {
#line 278
    *errmsg = "not relocatable object file";
#line 279
    *err = 0;
#line 280
    return ((void *)0);
  }
  {
#line 283
  tmp___2 = xmalloc(sizeof(struct simple_object_coff_read ));
#line 283
  ocr = (struct simple_object_coff_read *)tmp___2;
#line 284
  ocr->magic = magic;
#line 285
  ocr->is_big_endian = (unsigned char )is_big_endian;
#line 286
  ocr->nscns = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->f_nscns)));
#line 287
  tmp___3 = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->f_symptr)));
#line 287
  ocr->symptr = (off_t )tmp___3;
#line 289
  ocr->nsyms = (*fetch_32)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->f_nsyms)));
#line 290
  ocr->flags = flags___1;
#line 291
  tmp___4 = (*fetch_16)((unsigned char const   *)(hdrbuf + (unsigned long )(& ((struct external_filehdr *)0)->f_opthdr)));
#line 291
  ocr->scnhdr_offset = (off_t )(sizeof(struct external_filehdr ) + (unsigned long )tmp___4);
  }
#line 295
  return ((void *)ocr);
}
}
#line 300 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static char *simple_object_coff_read_strtab(simple_object_read *sobj , size_t *strtab_size ,
                                            char const   **errmsg , int *err ) 
{ 
  struct simple_object_coff_read *ocr ;
  off_t strtab_offset ;
  unsigned char strsizebuf[4] ;
  size_t strsize ;
  char *strtab ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 304
  ocr = (struct simple_object_coff_read *)sobj->data;
#line 311
  strtab_offset = (off_t )((unsigned long )(sobj->offset + ocr->symptr) + (unsigned long )ocr->nsyms * sizeof(struct external_syment ));
#line 313
  tmp___0 = simple_object_internal_read(sobj->descriptor, strtab_offset, strsizebuf,
                                        (size_t )4, errmsg, err);
  }
#line 313
  if (! tmp___0) {
#line 315
    return ((char *)((void *)0));
  }
#line 316
  if (ocr->is_big_endian) {
    {
#line 316
    tmp___1 = simple_object_fetch_big_32((unsigned char const   *)(strsizebuf));
#line 316
    strsize = (size_t )tmp___1;
    }
  } else {
    {
#line 316
    tmp___2 = simple_object_fetch_little_32((unsigned char const   *)(strsizebuf));
#line 316
    strsize = (size_t )tmp___2;
    }
  }
  {
#line 319
  tmp___3 = xmalloc(sizeof(char ) * strsize);
#line 319
  strtab = (char *)tmp___3;
#line 320
  tmp___4 = simple_object_internal_read(sobj->descriptor, strtab_offset, (unsigned char *)strtab,
                                        strsize, errmsg, err);
  }
#line 320
  if (! tmp___4) {
    {
#line 324
    free((void *)strtab);
    }
#line 325
    return ((char *)((void *)0));
  }
#line 327
  *strtab_size = strsize;
#line 328
  return (strtab);
}
}
#line 333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static char const   *simple_object_coff_find_sections(simple_object_read *sobj , int (*pfn)(void * ,
                                                                                            char const   * ,
                                                                                            off_t offset ,
                                                                                            off_t length ) ,
                                                      void *data , int *err ) 
{ 
  struct simple_object_coff_read *ocr ;
  size_t scnhdr_size ;
  unsigned char *scnbuf ;
  char const   *errmsg ;
  unsigned int (*fetch_32)(unsigned char const   * ) ;
  unsigned int nscns ;
  char *strtab ;
  size_t strtab_size ;
  unsigned int i ;
  void *tmp___0 ;
  int tmp___1 ;
  unsigned char *scnhdr ;
  unsigned char *scnname ;
  char namebuf[9] ;
  char *name___0 ;
  off_t scnptr ;
  unsigned int size ;
  size_t strindex ;
  char *end ;
  long tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 340
  ocr = (struct simple_object_coff_read *)sobj->data;
#line 351
  scnhdr_size = sizeof(struct external_scnhdr );
#line 352
  tmp___0 = xmalloc(sizeof(unsigned char ) * (scnhdr_size * (size_t )ocr->nscns));
#line 352
  scnbuf = (unsigned char *)tmp___0;
#line 353
  tmp___1 = simple_object_internal_read(sobj->descriptor, sobj->offset + ocr->scnhdr_offset,
                                        scnbuf, scnhdr_size * (size_t )ocr->nscns,
                                        & errmsg, err);
  }
#line 353
  if (! tmp___1) {
    {
#line 358
    free((void *)scnbuf);
    }
#line 359
    return (errmsg);
  }
#line 362
  if (ocr->is_big_endian) {
#line 362
    fetch_32 = & simple_object_fetch_big_32;
  } else {
#line 362
    fetch_32 = & simple_object_fetch_little_32;
  }
#line 366
  nscns = (unsigned int )ocr->nscns;
#line 367
  strtab = (char *)((void *)0);
#line 368
  strtab_size = (size_t )0;
#line 369
  i = 0U;
  {
#line 369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 369
    if (! (i < nscns)) {
#line 369
      goto while_break;
    }
    {
#line 378
    scnhdr = scnbuf + (size_t )i * scnhdr_size;
#line 379
    scnname = scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_name);
#line 380
    memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)scnname,
           (size_t )8);
#line 381
    namebuf[8] = (char )'\000';
#line 382
    name___0 = & namebuf[0];
    }
#line 383
    if ((int )namebuf[0] == 47) {
      {
#line 388
      tmp___2 = strtol((char const   */* __restrict  */)(namebuf + 1), (char **/* __restrict  */)(& end),
                       10);
#line 388
      strindex = (size_t )tmp___2;
      }
#line 389
      if ((int )*end == 0) {
#line 393
        if ((unsigned long )strtab == (unsigned long )((void *)0)) {
          {
#line 395
          strtab = simple_object_coff_read_strtab(sobj, & strtab_size, & errmsg, err);
          }
#line 398
          if ((unsigned long )strtab == (unsigned long )((void *)0)) {
            {
#line 400
            free((void *)scnbuf);
            }
#line 401
            return (errmsg);
          }
        }
#line 405
        if (strindex < 4UL) {
          {
#line 407
          free((void *)strtab);
#line 408
          free((void *)scnbuf);
#line 409
          *err = 0;
          }
#line 410
          return ("section string index out of range");
        } else
#line 405
        if (strindex >= strtab_size) {
          {
#line 407
          free((void *)strtab);
#line 408
          free((void *)scnbuf);
#line 409
          *err = 0;
          }
#line 410
          return ("section string index out of range");
        }
#line 413
        name___0 = strtab + strindex;
      }
    }
    {
#line 417
    tmp___3 = (*fetch_32)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_scnptr)));
#line 417
    scnptr = (off_t )tmp___3;
#line 418
    size = (*fetch_32)((unsigned char const   *)(scnhdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_size)));
#line 420
    tmp___4 = (*pfn)(data, (char const   *)name___0, scnptr, (off_t )size);
    }
#line 420
    if (! tmp___4) {
#line 421
      goto while_break;
    }
#line 369
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  if ((unsigned long )strtab != (unsigned long )((void *)0)) {
    {
#line 425
    free((void *)strtab);
    }
  }
  {
#line 426
  free((void *)scnbuf);
  }
#line 428
  return ((char const   *)((void *)0));
}
}
#line 433 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static void *simple_object_coff_fetch_attributes(simple_object_read *sobj , char const   **errmsg  __attribute__((__unused__)) ,
                                                 int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_coff_read *ocr ;
  struct simple_object_coff_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 438
  ocr = (struct simple_object_coff_read *)sobj->data;
#line 442
  tmp___0 = xmalloc(sizeof(struct simple_object_coff_attributes ));
#line 442
  ret = (struct simple_object_coff_attributes *)tmp___0;
#line 443
  ret->magic = ocr->magic;
#line 444
  ret->is_big_endian = ocr->is_big_endian;
#line 445
  ret->flags = ocr->flags;
  }
#line 446
  return ((void *)ret);
}
}
#line 451 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static void simple_object_coff_release_read(void *data ) 
{ 


  {
  {
#line 454
  free(data);
  }
#line 455
  return;
}
}
#line 459 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static char const   *simple_object_coff_attributes_merge(void *todata , void *fromdata ,
                                                         int *err ) 
{ 
  struct simple_object_coff_attributes *to ;
  struct simple_object_coff_attributes *from ;

  {
#line 462
  to = (struct simple_object_coff_attributes *)todata;
#line 464
  from = (struct simple_object_coff_attributes *)fromdata;
#line 467
  if ((int )to->magic != (int )from->magic) {
#line 469
    *err = 0;
#line 470
    return ("COFF object format mismatch");
  } else
#line 467
  if ((int )to->is_big_endian != (int )from->is_big_endian) {
#line 469
    *err = 0;
#line 470
    return ("COFF object format mismatch");
  }
#line 472
  return ((char const   *)((void *)0));
}
}
#line 477 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static void simple_object_coff_release_attributes(void *data ) 
{ 


  {
  {
#line 480
  free(data);
  }
#line 481
  return;
}
}
#line 485 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static void *simple_object_coff_start_write(void *attributes_data , char const   **errmsg  __attribute__((__unused__)) ,
                                            int *err  __attribute__((__unused__)) ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  struct simple_object_coff_attributes *ret ;
  void *tmp___0 ;

  {
  {
#line 490
  attrs = (struct simple_object_coff_attributes *)attributes_data;
#line 496
  tmp___0 = xmalloc(sizeof(struct simple_object_coff_attributes ));
#line 496
  ret = (struct simple_object_coff_attributes *)tmp___0;
#line 497
  *ret = *attrs;
  }
#line 498
  return ((void *)ret);
}
}
#line 503 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static int simple_object_coff_write_filehdr(simple_object_write *sobj , int descriptor ,
                                            unsigned int nscns , size_t symtab_offset ,
                                            unsigned int nsyms , char const   **errmsg ,
                                            int *err ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  unsigned char hdrbuf[sizeof(struct external_filehdr )] ;
  unsigned char *hdr ;
  void (*set_16)(unsigned char * , unsigned short  ) ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  int tmp___0 ;

  {
#line 509
  attrs = (struct simple_object_coff_attributes *)sobj->data;
#line 516
  hdr = & hdrbuf[0];
#line 518
  if (attrs->is_big_endian) {
#line 518
    set_16 = & simple_object_set_big_16;
  } else {
#line 518
    set_16 = & simple_object_set_little_16;
  }
#line 521
  if (attrs->is_big_endian) {
#line 521
    set_32 = & simple_object_set_big_32;
  } else {
#line 521
    set_32 = & simple_object_set_little_32;
  }
  {
#line 525
  memset((void *)hdr, 0, sizeof(struct external_filehdr ));
#line 527
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_magic), attrs->magic);
#line 528
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_nscns), (unsigned short )nscns);
#line 530
  (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_symptr), (unsigned int )symtab_offset);
#line 531
  (*set_32)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_nsyms), nsyms);
#line 533
  (*set_16)(hdr + (unsigned long )(& ((struct external_filehdr *)0)->f_flags), attrs->flags);
#line 535
  tmp___0 = simple_object_internal_write(descriptor, (off_t )0, (unsigned char const   *)(hdrbuf),
                                         sizeof(struct external_filehdr ), errmsg,
                                         err);
  }
#line 535
  return (tmp___0);
}
}
#line 542 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static int simple_object_coff_write_scnhdr(simple_object_write *sobj , int descriptor ,
                                           char const   *name___0 , size_t *name_offset ,
                                           off_t scnhdr_offset , size_t scnsize ,
                                           off_t offset , unsigned int align , char const   **errmsg ,
                                           int *err ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  unsigned char hdrbuf[sizeof(struct external_scnhdr )] ;
  unsigned char *hdr ;
  size_t namelen ;
  unsigned int flags___1 ;
  int tmp___0 ;

  {
#line 549
  attrs = (struct simple_object_coff_attributes *)sobj->data;
#line 557
  if (attrs->is_big_endian) {
#line 557
    set_32 = & simple_object_set_big_32;
  } else {
#line 557
    set_32 = & simple_object_set_little_32;
  }
  {
#line 561
  memset((void *)(hdrbuf), 0, sizeof(hdrbuf));
#line 562
  hdr = & hdrbuf[0];
#line 564
  namelen = strlen(name___0);
  }
#line 565
  if (namelen <= 8UL) {
    {
#line 566
    strncpy((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_name)),
            (char const   */* __restrict  */)name___0, (size_t )8);
    }
  } else {
    {
#line 570
    snprintf((char */* __restrict  */)((char *)hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_name)),
             (size_t )8, (char const   */* __restrict  */)"/%lu", *name_offset);
#line 572
    *name_offset += namelen + 1UL;
    }
  }
  {
#line 577
  (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_size), (unsigned int )scnsize);
#line 578
  (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_scnptr), (unsigned int )offset);
#line 583
  flags___1 = (unsigned int )((((1 << 6) | (1 << 25)) | (1 << 28)) | (1 << 30));
  }
#line 586
  if (align > 13U) {
#line 587
    align = 13U;
  }
  {
#line 588
  flags___1 |= (align + 1U) << 20;
#line 589
  (*set_32)(hdr + (unsigned long )(& ((struct external_scnhdr *)0)->s_flags), flags___1);
#line 591
  tmp___0 = simple_object_internal_write(descriptor, scnhdr_offset, (unsigned char const   *)(hdrbuf),
                                         sizeof(struct external_scnhdr ), errmsg,
                                         err);
  }
#line 591
  return (tmp___0);
}
}
#line 598 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static char const   *simple_object_coff_write_to_file(simple_object_write *sobj ,
                                                      int descriptor , int *err ) 
{ 
  struct simple_object_coff_attributes *attrs ;
  unsigned int nscns ;
  unsigned int secnum ;
  simple_object_write_section *section ;
  off_t scnhdr_offset ;
  size_t symtab_offset ;
  off_t secsym_offset ;
  unsigned int nsyms ;
  size_t offset ;
  size_t name_offset ;
  char const   *errmsg ;
  unsigned char strsizebuf[4] ;
  char const   *source_filename ;
  size_t sflen ;
  union __anonunion_syms_806857204 syms[2] ;
  void (*set_16)(unsigned char * , unsigned short  ) ;
  void (*set_32)(unsigned char * , unsigned int  ) ;
  size_t mask ;
  size_t new_offset ;
  size_t scnsize ;
  struct simple_object_write_section_buffer *buffer___2 ;
  unsigned char zeroes[16] ;
  size_t write___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t namelen ;
  size_t scnsize___0 ;
  struct simple_object_write_section_buffer *buffer___3 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 602
  attrs = (struct simple_object_coff_attributes *)sobj->data;
#line 617
  source_filename = "fake";
#line 627
  if (attrs->is_big_endian) {
#line 627
    set_16 = & simple_object_set_big_16;
  } else {
#line 627
    set_16 = & simple_object_set_little_16;
  }
#line 630
  if (attrs->is_big_endian) {
#line 630
    set_32 = & simple_object_set_big_32;
  } else {
#line 630
    set_32 = & simple_object_set_little_32;
  }
#line 634
  nscns = 0U;
#line 635
  section = sobj->sections;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 635
      goto while_break;
    }
#line 636
    nscns ++;
#line 635
    section = section->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 638
  scnhdr_offset = (off_t )sizeof(struct external_filehdr );
#line 639
  offset = (unsigned long )scnhdr_offset + (unsigned long )nscns * sizeof(struct external_scnhdr );
#line 640
  name_offset = (size_t )4;
#line 641
  section = sobj->sections;
  {
#line 641
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 641
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 641
      goto while_break___0;
    }
#line 648
    mask = (size_t )((1U << section->align) - 1U);
#line 649
    new_offset = offset & mask;
#line 650
    new_offset &= ~ mask;
    {
#line 651
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 651
      if (! (new_offset > offset)) {
#line 651
        goto while_break___1;
      }
      {
#line 656
      memset((void *)(zeroes), 0, sizeof(zeroes));
#line 657
      write___0 = new_offset - offset;
      }
#line 658
      if (write___0 > sizeof(zeroes)) {
#line 659
        write___0 = sizeof(zeroes);
      }
      {
#line 660
      tmp___0 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(zeroes),
                                             write___0, & errmsg, err);
      }
#line 660
      if (! tmp___0) {
#line 662
        return (errmsg);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 665
    scnsize = (size_t )0;
#line 666
    buffer___2 = section->buffers;
    {
#line 666
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 666
      if (! ((unsigned long )buffer___2 != (unsigned long )((void *)0))) {
#line 666
        goto while_break___2;
      }
      {
#line 668
      tmp___1 = simple_object_internal_write(descriptor, (off_t )(offset + scnsize),
                                             (unsigned char const   *)buffer___2->buffer,
                                             buffer___2->size, & errmsg, err);
      }
#line 668
      if (! tmp___1) {
#line 672
        return (errmsg);
      }
#line 673
      scnsize += buffer___2->size;
#line 666
      buffer___2 = buffer___2->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 676
    tmp___2 = simple_object_coff_write_scnhdr(sobj, descriptor, (char const   *)section->name,
                                              & name_offset, scnhdr_offset, scnsize,
                                              (off_t )offset, section->align, & errmsg,
                                              err);
    }
#line 676
    if (! tmp___2) {
#line 680
      return (errmsg);
    }
#line 682
    scnhdr_offset = (off_t )((unsigned long )scnhdr_offset + sizeof(struct external_scnhdr ));
#line 683
    offset += scnsize;
#line 641
    section = section->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 687
  offset += offset & 1UL;
#line 690
  nsyms = 2U * (nscns + 1U);
#line 691
  symtab_offset = offset;
#line 694
  offset += (unsigned long )nsyms * sizeof(struct external_syment );
#line 697
  memset((void *)(& syms[0]), 0, sizeof(syms));
#line 698
  strcpy((char */* __restrict  */)((char *)(& syms[0].sym.e.e_name[0])), (char const   */* __restrict  */)".file");
#line 699
  (*set_16)(& syms[0].sym.e_scnum[0], (unsigned short)65534);
#line 700
  (*set_16)(& syms[0].sym.e_type[0], (unsigned short)0);
#line 701
  syms[0].sym.e_sclass[0] = (unsigned char)103;
#line 702
  syms[0].sym.e_numaux[0] = (unsigned char)1;
#line 705
  sflen = strlen(source_filename);
  }
#line 706
  if (sflen <= 18UL) {
    {
#line 707
    memcpy((void */* __restrict  */)(& syms[1].aux.x_file.x_fname[0]), (void const   */* __restrict  */)source_filename,
           sflen);
    }
  } else {
    {
#line 710
    (*set_32)(& syms[1].aux.x_file.x_n.x_offset[0], (unsigned int )name_offset);
#line 711
    tmp___3 = simple_object_internal_write(descriptor, (off_t )(offset + name_offset),
                                           (unsigned char const   *)source_filename,
                                           sflen + 1UL, & errmsg, err);
    }
#line 711
    if (! tmp___3) {
#line 715
      return (errmsg);
    }
    {
#line 716
    tmp___4 = strlen(source_filename);
#line 716
    name_offset += tmp___4 + 1UL;
    }
  }
  {
#line 718
  tmp___5 = simple_object_internal_write(descriptor, (off_t )symtab_offset, (unsigned char const   *)(& syms[0]),
                                         sizeof(syms), & errmsg, err);
  }
#line 718
  if (! tmp___5) {
#line 721
    return (errmsg);
  }
  {
#line 725
  (*set_32)(strsizebuf, (unsigned int )name_offset);
#line 726
  tmp___6 = simple_object_internal_write(descriptor, (off_t )offset, (unsigned char const   *)(strsizebuf),
                                         (size_t )4, & errmsg, err);
  }
#line 726
  if (! tmp___6) {
#line 728
    return (errmsg);
  }
  {
#line 730
  name_offset = (size_t )4;
#line 731
  secsym_offset = (off_t )(symtab_offset + sizeof(syms));
#line 732
  memset((void *)(& syms[0]), 0, sizeof(syms));
#line 733
  (*set_16)(& syms[0].sym.e_type[0], (unsigned short)0);
#line 734
  syms[0].sym.e_sclass[0] = (unsigned char)3;
#line 735
  syms[0].sym.e_numaux[0] = (unsigned char)1;
#line 736
  secnum = 1U;
#line 738
  section = sobj->sections;
  }
  {
#line 738
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 738
    if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 738
      goto while_break___3;
    }
    {
#line 744
    namelen = strlen((char const   *)section->name);
#line 745
    tmp___7 = secnum;
#line 745
    secnum ++;
#line 745
    (*set_16)(& syms[0].sym.e_scnum[0], (unsigned short )tmp___7);
#line 746
    scnsize___0 = (size_t )0;
#line 747
    buffer___3 = section->buffers;
    }
    {
#line 747
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 747
      if (! ((unsigned long )buffer___3 != (unsigned long )((void *)0))) {
#line 747
        goto while_break___4;
      }
#line 748
      scnsize___0 += buffer___3->size;
#line 747
      buffer___3 = buffer___3->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 749
    (*set_32)(& syms[1].aux.x_scn.x_scnlen[0], (unsigned int )scnsize___0);
    }
#line 750
    if (namelen > 8UL) {
      {
#line 752
      (*set_32)(& syms[0].sym.e.e.e_zeroes[0], 0U);
#line 753
      (*set_32)(& syms[0].sym.e.e.e_offset[0], (unsigned int )name_offset);
#line 754
      tmp___8 = simple_object_internal_write(descriptor, (off_t )(offset + name_offset),
                                             (unsigned char const   *)section->name,
                                             namelen + 1UL, & errmsg, err);
      }
#line 754
      if (! tmp___8) {
#line 758
        return (errmsg);
      }
#line 759
      name_offset += namelen + 1UL;
    } else {
      {
#line 763
      tmp___9 = strlen((char const   *)section->name);
#line 763
      memcpy((void */* __restrict  */)(& syms[0].sym.e.e_name[0]), (void const   */* __restrict  */)section->name,
             tmp___9);
#line 765
      tmp___10 = strlen((char const   *)section->name);
#line 765
      tmp___11 = strlen((char const   *)section->name);
#line 765
      memset((void *)(& syms[0].sym.e.e_name[tmp___11]), 0, 8UL - tmp___10);
      }
    }
    {
#line 769
    tmp___12 = simple_object_internal_write(descriptor, secsym_offset, (unsigned char const   *)(& syms[0]),
                                            sizeof(syms), & errmsg, err);
    }
#line 769
    if (! tmp___12) {
#line 772
      return (errmsg);
    }
#line 773
    secsym_offset = (off_t )((unsigned long )secsym_offset + sizeof(syms));
#line 738
    section = section->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 776
  tmp___13 = simple_object_coff_write_filehdr(sobj, descriptor, nscns, symtab_offset,
                                              nsyms, & errmsg, err);
  }
#line 776
  if (! tmp___13) {
#line 778
    return (errmsg);
  }
#line 780
  return ((char const   *)((void *)0));
}
}
#line 785 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
static void simple_object_coff_release_write(void *data ) 
{ 


  {
  {
#line 788
  free(data);
  }
#line 789
  return;
}
}
#line 793 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./simple-object-coff.c"
struct simple_object_functions  const  simple_object_coff_functions  = 
#line 793
     {& simple_object_coff_match, & simple_object_coff_find_sections, & simple_object_coff_fetch_attributes,
    & simple_object_coff_release_read, & simple_object_coff_attributes_merge, & simple_object_coff_release_attributes,
    & simple_object_coff_start_write, & simple_object_coff_write_to_file, & simple_object_coff_release_write};
#line 646 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 91 "./../include/sha1.h"
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
#line 97
void sha1_process_block(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) ;
#line 104
void sha1_process_bytes(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) ;
#line 114
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
#line 123
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
#line 129
int sha1_stream(FILE *stream , void *resblock ) ;
#line 135
void *sha1_buffer(char const   *buffer___2 , size_t len , void *resblock ) ;
#line 51 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 57 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ 
  sha1_uint32 tmp___0 ;

  {
#line 60
  ctx->A = (sha1_uint32 )1732584193;
#line 61
  ctx->B = 4023233417U;
#line 62
  ctx->C = 2562383102U;
#line 63
  ctx->D = (sha1_uint32 )271733878;
#line 64
  ctx->E = 3285377520U;
#line 66
  tmp___0 = (sha1_uint32 )0;
#line 66
  ctx->total[1] = tmp___0;
#line 66
  ctx->total[0] = tmp___0;
#line 67
  ctx->buflen = (sha1_uint32 )0;
#line 68
  return;
}
}
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ 


  {
#line 78
  *((sha1_uint32 *)resbuf + 0) = (sha1_uint32 )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24));
#line 79
  *((sha1_uint32 *)resbuf + 1) = (sha1_uint32 )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24));
#line 80
  *((sha1_uint32 *)resbuf + 2) = (sha1_uint32 )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24));
#line 81
  *((sha1_uint32 *)resbuf + 3) = (sha1_uint32 )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24));
#line 82
  *((sha1_uint32 *)resbuf + 4) = (sha1_uint32 )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24));
#line 84
  return (resbuf);
}
}
#line 92 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ 
  sha1_uint32 bytes ;
  size_t size ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 96
  bytes = ctx->buflen;
#line 97
  if (bytes < 56U) {
#line 97
    tmp___0 = 16;
  } else {
#line 97
    tmp___0 = 32;
  }
#line 97
  size = (size_t )tmp___0;
#line 100
  ctx->total[0] += bytes;
#line 101
  if (ctx->total[0] < bytes) {
#line 102
    (ctx->total[1]) ++;
  }
  {
#line 105
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 106
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 108
  memcpy((void */* __restrict  */)((char *)(ctx->buffer) + bytes), (void const   */* __restrict  */)(fillbuf),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 111
  sha1_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 113
  tmp___1 = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
  }
#line 113
  return (tmp___1);
}
}
#line 119 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
int sha1_stream(FILE *stream , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  char buffer___2[4168] ;
  size_t sum ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 127
  sha1_init_ctx(& ctx);
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    sum = (size_t )0;
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 141
      n = fread((void */* __restrict  */)(buffer___2 + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 143
      sum += n;
      }
#line 145
      if (sum == 4096UL) {
#line 146
        goto while_break___0;
      }
#line 148
      if (n == 0UL) {
        {
#line 153
        tmp___0 = ferror(stream);
        }
#line 153
        if (tmp___0) {
#line 154
          return (1);
        }
#line 155
        goto process_partial_block;
      }
      {
#line 161
      tmp___1 = feof(stream);
      }
#line 161
      if (tmp___1) {
#line 162
        goto process_partial_block;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 168
    sha1_process_block((void const   *)(buffer___2), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
  process_partial_block: ;
#line 174
  if (sum > 0UL) {
    {
#line 175
    sha1_process_bytes((void const   *)(buffer___2), sum, & ctx);
    }
  }
  {
#line 178
  sha1_finish_ctx(& ctx, resblock);
  }
#line 179
  return (0);
}
}
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
void *sha1_buffer(char const   *buffer___2 , size_t len , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  void *tmp___0 ;

  {
  {
#line 192
  sha1_init_ctx(& ctx);
#line 195
  sha1_process_bytes((void const   *)buffer___2, len, & ctx);
#line 198
  tmp___0 = sha1_finish_ctx(& ctx, resblock);
  }
#line 198
  return (tmp___0);
}
}
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
void sha1_process_bytes(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t left_over___0 ;

  {
#line 206
  if (ctx->buflen != 0U) {
#line 208
    left_over = (size_t )ctx->buflen;
#line 209
    if (128UL - left_over > len) {
#line 209
      tmp___0 = len;
    } else {
#line 209
      tmp___0 = 128UL - left_over;
    }
    {
#line 209
    add = tmp___0;
#line 211
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over), (void const   */* __restrict  */)buffer___2,
           add);
#line 212
    ctx->buflen = (sha1_uint32 )((size_t )ctx->buflen + add);
    }
#line 214
    if (ctx->buflen > 64U) {
      {
#line 216
      sha1_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
#line 218
      ctx->buflen &= 63U;
#line 220
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
      }
    }
#line 225
    buffer___2 = (void const   *)((char const   *)buffer___2 + add);
#line 226
    len -= add;
  }
#line 230
  if (len >= 64UL) {
#line 235
    if ((size_t )buffer___2 % (unsigned long )(& ((struct __anonstruct_694274947 *)0)->x) != 0UL) {
      {
#line 236
      while (1) {
        while_continue: /* CIL Label */ ;
#line 236
        if (! (len > 64UL)) {
#line 236
          goto while_break;
        }
        {
#line 238
        tmp___1 = memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer___2,
                         (size_t )64);
#line 238
        sha1_process_block((void const   *)tmp___1, (size_t )64, ctx);
#line 239
        buffer___2 = (void const   *)((char const   *)buffer___2 + 64);
#line 240
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 245
      sha1_process_block(buffer___2, len & 0xffffffffffffffc0UL, ctx);
#line 246
      buffer___2 = (void const   *)((char const   *)buffer___2 + (len & 0xffffffffffffffc0UL));
#line 247
      len &= 63UL;
      }
    }
  }
#line 252
  if (len > 0UL) {
    {
#line 254
    left_over___0 = (size_t )ctx->buflen;
#line 256
    memcpy((void */* __restrict  */)((char *)(ctx->buffer) + left_over___0), (void const   */* __restrict  */)buffer___2,
           len);
#line 257
    left_over___0 += len;
    }
#line 258
    if (left_over___0 >= 64UL) {
      {
#line 260
      sha1_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 261
      left_over___0 -= 64UL;
#line 262
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[16]),
             left_over___0);
      }
    }
#line 264
    ctx->buflen = (sha1_uint32 )left_over___0;
  }
#line 266
  return;
}
}
#line 286 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./sha1.c"
void sha1_process_block(void const   *buffer___2 , size_t len , struct sha1_ctx *ctx ) 
{ 
  sha1_uint32 const   *words ;
  size_t nwords ;
  sha1_uint32 const   *endp ;
  sha1_uint32 x[16] ;
  sha1_uint32 a ;
  sha1_uint32 b ;
  sha1_uint32 c ;
  sha1_uint32 d ;
  sha1_uint32 e ;
  sha1_uint32 tm ;
  int t ;
  sha1_uint32 tmp___0 ;
  sha1_uint32 tmp___1 ;
  sha1_uint32 tmp___2 ;
  sha1_uint32 tmp___3 ;
  sha1_uint32 tmp___4 ;

  {
#line 289
  words = (sha1_uint32 const   *)buffer___2;
#line 290
  nwords = len / sizeof(sha1_uint32 );
#line 291
  endp = words + nwords;
#line 293
  a = ctx->A;
#line 294
  b = ctx->B;
#line 295
  c = ctx->C;
#line 296
  d = ctx->D;
#line 297
  e = ctx->E;
#line 302
  ctx->total[0] = (sha1_uint32 )((size_t )ctx->total[0] + len);
#line 303
  if ((size_t )ctx->total[0] < len) {
#line 304
    (ctx->total[1]) ++;
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 319
      goto while_break;
    }
#line 323
    t = 0;
    {
#line 323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 323
      if (! (t < 16)) {
#line 323
        goto while_break___0;
      }
#line 325
      x[t] = (sha1_uint32 )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 326
      words ++;
#line 323
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 329
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 329
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
#line 329
      b = (b << 30) | (b >> 2);
#line 329
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
#line 330
      a = (a << 30) | (a >> 2);
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 331
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 331
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
#line 331
      e = (e << 30) | (e >> 2);
#line 331
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 332
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 332
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
#line 332
      d = (d << 30) | (d >> 2);
#line 332
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 333
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 333
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
#line 333
      c = (c << 30) | (c >> 2);
#line 333
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 334
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 334
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
#line 334
      b = (b << 30) | (b >> 2);
#line 334
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 335
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 335
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
#line 335
      a = (a << 30) | (a >> 2);
#line 335
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 336
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 336
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
#line 336
      e = (e << 30) | (e >> 2);
#line 336
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 337
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 337
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
#line 337
      d = (d << 30) | (d >> 2);
#line 337
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 338
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
#line 338
      c = (c << 30) | (c >> 2);
#line 338
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 339
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
#line 339
      b = (b << 30) | (b >> 2);
#line 339
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 340
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
#line 340
      a = (a << 30) | (a >> 2);
#line 340
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 341
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
#line 341
      e = (e << 30) | (e >> 2);
#line 341
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 342
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
#line 342
      d = (d << 30) | (d >> 2);
#line 342
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 343
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
#line 343
      c = (c << 30) | (c >> 2);
#line 343
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 344
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
#line 344
      b = (b << 30) | (b >> 2);
#line 344
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 345
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 345
      x[0] = (tm << 1) | (tm >> 31);
#line 345
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
#line 345
      a = (a << 30) | (a >> 2);
#line 345
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 346
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 346
      x[1] = (tm << 1) | (tm >> 31);
#line 346
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
#line 346
      e = (e << 30) | (e >> 2);
#line 346
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 347
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 347
      x[2] = (tm << 1) | (tm >> 31);
#line 347
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
#line 347
      d = (d << 30) | (d >> 2);
#line 347
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 348
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 348
      x[3] = (tm << 1) | (tm >> 31);
#line 348
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
#line 348
      c = (c << 30) | (c >> 2);
#line 348
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 349
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 349
      x[4] = (tm << 1) | (tm >> 31);
#line 349
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
#line 349
      b = (b << 30) | (b >> 2);
#line 349
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 350
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 350
      x[5] = (tm << 1) | (tm >> 31);
#line 350
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
#line 350
      a = (a << 30) | (a >> 2);
#line 350
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 351
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 351
      x[6] = (tm << 1) | (tm >> 31);
#line 351
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
#line 351
      e = (e << 30) | (e >> 2);
#line 351
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 352
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 352
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 352
      x[7] = (tm << 1) | (tm >> 31);
#line 352
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
#line 352
      d = (d << 30) | (d >> 2);
#line 352
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 353
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 353
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 353
      x[8] = (tm << 1) | (tm >> 31);
#line 353
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
#line 353
      c = (c << 30) | (c >> 2);
#line 353
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 354
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 354
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 354
      x[9] = (tm << 1) | (tm >> 31);
#line 354
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
#line 354
      b = (b << 30) | (b >> 2);
#line 354
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 355
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 355
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 355
      x[10] = (tm << 1) | (tm >> 31);
#line 355
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
#line 355
      a = (a << 30) | (a >> 2);
#line 355
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 356
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 356
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 356
      x[11] = (tm << 1) | (tm >> 31);
#line 356
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
#line 356
      e = (e << 30) | (e >> 2);
#line 356
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 357
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 357
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 357
      x[12] = (tm << 1) | (tm >> 31);
#line 357
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
#line 357
      d = (d << 30) | (d >> 2);
#line 357
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 358
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 358
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 358
      x[13] = (tm << 1) | (tm >> 31);
#line 358
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
#line 358
      c = (c << 30) | (c >> 2);
#line 358
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 359
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 359
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 359
      x[14] = (tm << 1) | (tm >> 31);
#line 359
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
#line 359
      b = (b << 30) | (b >> 2);
#line 359
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 360
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 360
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 360
      x[15] = (tm << 1) | (tm >> 31);
#line 360
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
#line 360
      a = (a << 30) | (a >> 2);
#line 360
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 361
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 361
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 361
      x[0] = (tm << 1) | (tm >> 31);
#line 361
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
#line 361
      e = (e << 30) | (e >> 2);
#line 361
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 362
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 362
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 362
      x[1] = (tm << 1) | (tm >> 31);
#line 362
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
#line 362
      d = (d << 30) | (d >> 2);
#line 362
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 363
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 363
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 363
      x[2] = (tm << 1) | (tm >> 31);
#line 363
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
#line 363
      c = (c << 30) | (c >> 2);
#line 363
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 364
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 364
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 364
      x[3] = (tm << 1) | (tm >> 31);
#line 364
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
#line 364
      b = (b << 30) | (b >> 2);
#line 364
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 365
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 365
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 365
      x[4] = (tm << 1) | (tm >> 31);
#line 365
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
#line 365
      a = (a << 30) | (a >> 2);
#line 365
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 366
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 366
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 366
      x[5] = (tm << 1) | (tm >> 31);
#line 366
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
#line 366
      e = (e << 30) | (e >> 2);
#line 366
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 367
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 367
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 367
      x[6] = (tm << 1) | (tm >> 31);
#line 367
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
#line 367
      d = (d << 30) | (d >> 2);
#line 367
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 368
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 368
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 368
      x[7] = (tm << 1) | (tm >> 31);
#line 368
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
#line 368
      c = (c << 30) | (c >> 2);
#line 368
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 369
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 369
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 369
      x[8] = (tm << 1) | (tm >> 31);
#line 369
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
#line 369
      b = (b << 30) | (b >> 2);
#line 369
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 370
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 370
      x[9] = (tm << 1) | (tm >> 31);
#line 370
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
#line 370
      a = (a << 30) | (a >> 2);
#line 370
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 371
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 371
      x[10] = (tm << 1) | (tm >> 31);
#line 371
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
#line 371
      e = (e << 30) | (e >> 2);
#line 371
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 372
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 372
      x[11] = (tm << 1) | (tm >> 31);
#line 372
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
#line 372
      d = (d << 30) | (d >> 2);
#line 372
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 373
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 373
      x[12] = (tm << 1) | (tm >> 31);
#line 373
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
#line 373
      c = (c << 30) | (c >> 2);
#line 373
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 374
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 374
      x[13] = (tm << 1) | (tm >> 31);
#line 374
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
#line 374
      b = (b << 30) | (b >> 2);
#line 374
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 375
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 375
      x[14] = (tm << 1) | (tm >> 31);
#line 375
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
#line 375
      a = (a << 30) | (a >> 2);
#line 375
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 376
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 376
      x[15] = (tm << 1) | (tm >> 31);
#line 376
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
#line 376
      e = (e << 30) | (e >> 2);
#line 376
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 377
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 377
      x[0] = (tm << 1) | (tm >> 31);
#line 377
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
#line 377
      d = (d << 30) | (d >> 2);
#line 377
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 378
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 378
      x[1] = (tm << 1) | (tm >> 31);
#line 378
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
#line 378
      c = (c << 30) | (c >> 2);
#line 378
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 379
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 379
      x[2] = (tm << 1) | (tm >> 31);
#line 379
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
#line 379
      b = (b << 30) | (b >> 2);
#line 379
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 380
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 380
      x[3] = (tm << 1) | (tm >> 31);
#line 380
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
#line 380
      a = (a << 30) | (a >> 2);
#line 380
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 381
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 381
      x[4] = (tm << 1) | (tm >> 31);
#line 381
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
#line 381
      e = (e << 30) | (e >> 2);
#line 381
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 382
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 382
      x[5] = (tm << 1) | (tm >> 31);
#line 382
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
#line 382
      d = (d << 30) | (d >> 2);
#line 382
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 383
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 383
      x[6] = (tm << 1) | (tm >> 31);
#line 383
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
#line 383
      c = (c << 30) | (c >> 2);
#line 383
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 384
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 384
      x[7] = (tm << 1) | (tm >> 31);
#line 384
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
#line 384
      b = (b << 30) | (b >> 2);
#line 384
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 385
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 385
      x[8] = (tm << 1) | (tm >> 31);
#line 385
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
#line 385
      a = (a << 30) | (a >> 2);
#line 385
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 386
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 386
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 386
      x[9] = (tm << 1) | (tm >> 31);
#line 386
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
#line 386
      e = (e << 30) | (e >> 2);
#line 386
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 387
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 387
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 387
      x[10] = (tm << 1) | (tm >> 31);
#line 387
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
#line 387
      d = (d << 30) | (d >> 2);
#line 387
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 388
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 388
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 388
      x[11] = (tm << 1) | (tm >> 31);
#line 388
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
#line 388
      c = (c << 30) | (c >> 2);
#line 388
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 389
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 389
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 389
      x[12] = (tm << 1) | (tm >> 31);
#line 389
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
#line 389
      b = (b << 30) | (b >> 2);
#line 389
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 390
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 390
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 390
      x[13] = (tm << 1) | (tm >> 31);
#line 390
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
#line 390
      a = (a << 30) | (a >> 2);
#line 390
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 391
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 391
      x[14] = (tm << 1) | (tm >> 31);
#line 391
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
#line 391
      e = (e << 30) | (e >> 2);
#line 391
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___64: /* CIL Label */ ;
#line 392
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 392
      x[15] = (tm << 1) | (tm >> 31);
#line 392
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
#line 392
      d = (d << 30) | (d >> 2);
#line 392
      goto while_break___64;
    }
    while_break___64: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 393
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 393
      x[0] = (tm << 1) | (tm >> 31);
#line 393
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
#line 393
      c = (c << 30) | (c >> 2);
#line 393
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 394
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 394
      x[1] = (tm << 1) | (tm >> 31);
#line 394
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
#line 394
      b = (b << 30) | (b >> 2);
#line 394
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___67: /* CIL Label */ ;
#line 395
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 395
      x[2] = (tm << 1) | (tm >> 31);
#line 395
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
#line 395
      a = (a << 30) | (a >> 2);
#line 395
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___68: /* CIL Label */ ;
#line 396
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 396
      x[3] = (tm << 1) | (tm >> 31);
#line 396
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
#line 396
      e = (e << 30) | (e >> 2);
#line 396
      goto while_break___68;
    }
    while_break___68: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___69: /* CIL Label */ ;
#line 397
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 397
      x[4] = (tm << 1) | (tm >> 31);
#line 397
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
#line 397
      d = (d << 30) | (d >> 2);
#line 397
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___70: /* CIL Label */ ;
#line 398
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 398
      x[5] = (tm << 1) | (tm >> 31);
#line 398
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
#line 398
      c = (c << 30) | (c >> 2);
#line 398
      goto while_break___70;
    }
    while_break___70: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 399
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 399
      x[6] = (tm << 1) | (tm >> 31);
#line 399
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
#line 399
      b = (b << 30) | (b >> 2);
#line 399
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 400
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 400
      x[7] = (tm << 1) | (tm >> 31);
#line 400
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
#line 400
      a = (a << 30) | (a >> 2);
#line 400
      goto while_break___72;
    }
    while_break___72: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 401
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 401
      x[8] = (tm << 1) | (tm >> 31);
#line 401
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
#line 401
      e = (e << 30) | (e >> 2);
#line 401
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___74: /* CIL Label */ ;
#line 402
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 402
      x[9] = (tm << 1) | (tm >> 31);
#line 402
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
#line 402
      d = (d << 30) | (d >> 2);
#line 402
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 403
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 403
      x[10] = (tm << 1) | (tm >> 31);
#line 403
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
#line 403
      c = (c << 30) | (c >> 2);
#line 403
      goto while_break___75;
    }
    while_break___75: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 404
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 404
      x[11] = (tm << 1) | (tm >> 31);
#line 404
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
#line 404
      b = (b << 30) | (b >> 2);
#line 404
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___77: /* CIL Label */ ;
#line 405
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 405
      x[12] = (tm << 1) | (tm >> 31);
#line 405
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
#line 405
      a = (a << 30) | (a >> 2);
#line 405
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___78: /* CIL Label */ ;
#line 406
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 406
      x[13] = (tm << 1) | (tm >> 31);
#line 406
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
#line 406
      e = (e << 30) | (e >> 2);
#line 406
      goto while_break___78;
    }
    while_break___78: /* CIL Label */ ;
    }
    {
#line 407
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 407
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 407
      x[14] = (tm << 1) | (tm >> 31);
#line 407
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
#line 407
      d = (d << 30) | (d >> 2);
#line 407
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    {
#line 408
    while (1) {
      while_continue___80: /* CIL Label */ ;
#line 408
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 408
      x[15] = (tm << 1) | (tm >> 31);
#line 408
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
#line 408
      c = (c << 30) | (c >> 2);
#line 408
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 410
    tmp___0 = ctx->A + a;
#line 410
    ctx->A = tmp___0;
#line 410
    a = tmp___0;
#line 411
    tmp___1 = ctx->B + b;
#line 411
    ctx->B = tmp___1;
#line 411
    b = tmp___1;
#line 412
    tmp___2 = ctx->C + c;
#line 412
    ctx->C = tmp___2;
#line 412
    c = tmp___2;
#line 413
    tmp___3 = ctx->D + d;
#line 413
    ctx->D = tmp___3;
#line 413
    d = tmp___3;
#line 414
    tmp___4 = ctx->E + e;
#line 414
    ctx->E = tmp___4;
#line 414
    e = tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  return;
}
}
#line 27 "/usr/include/x86_64-linux-gnu/sys/prctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) prctl)(int __option 
                                                                            , ...) ;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./setproctitle.c"
void setproctitle(char const   *name___0  __attribute__((__unused__))  , ...) 
{ 


  {
  {
#line 46
  prctl(15, name___0);
  }
#line 48
  return;
}
}
#line 85 "./../include/safe-ctype.h"
unsigned short const   _sch_istable[256] ;
#line 110
unsigned char const   _sch_toupper[256] ;
#line 111
unsigned char const   _sch_tolower[256] ;
#line 159 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./safe-ctype.c"
unsigned short const   _sch_istable[256]  = 
#line 159 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./safe-ctype.c"
  {      (unsigned short const   )2050,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2115,      (unsigned short const   )1090,      (unsigned short const   )2114, 
        (unsigned short const   )2114,      (unsigned short const   )1090,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2,      (unsigned short const   )2, 
        (unsigned short const   )2129,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )276, 
        (unsigned short const   )276,      (unsigned short const   )276,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912, 
        (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )912,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656, 
        (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )656,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )560, 
        (unsigned short const   )48,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792, 
        (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )792,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536, 
        (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )536,      (unsigned short const   )48, 
        (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )48,      (unsigned short const   )2, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0, 
        (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0,      (unsigned short const   )0};
#line 191 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./safe-ctype.c"
unsigned char const   _sch_tolower[256]  = 
#line 191
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'a',      (unsigned char const   )'b',      (unsigned char const   )'c', 
        (unsigned char const   )'d',      (unsigned char const   )'e',      (unsigned char const   )'f',      (unsigned char const   )'g', 
        (unsigned char const   )'h',      (unsigned char const   )'i',      (unsigned char const   )'j',      (unsigned char const   )'k', 
        (unsigned char const   )'l',      (unsigned char const   )'m',      (unsigned char const   )'n',      (unsigned char const   )'o', 
        (unsigned char const   )'p',      (unsigned char const   )'q',      (unsigned char const   )'r',      (unsigned char const   )'s', 
        (unsigned char const   )'t',      (unsigned char const   )'u',      (unsigned char const   )'v',      (unsigned char const   )'w', 
        (unsigned char const   )'x',      (unsigned char const   )'y',      (unsigned char const   )'z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
#line 220 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./safe-ctype.c"
unsigned char const   _sch_toupper[256]  = 
#line 220
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )'A',      (unsigned char const   )'B',      (unsigned char const   )'C', 
        (unsigned char const   )'D',      (unsigned char const   )'E',      (unsigned char const   )'F',      (unsigned char const   )'G', 
        (unsigned char const   )'H',      (unsigned char const   )'I',      (unsigned char const   )'J',      (unsigned char const   )'K', 
        (unsigned char const   )'L',      (unsigned char const   )'M',      (unsigned char const   )'N',      (unsigned char const   )'O', 
        (unsigned char const   )'P',      (unsigned char const   )'Q',      (unsigned char const   )'R',      (unsigned char const   )'S', 
        (unsigned char const   )'T',      (unsigned char const   )'U',      (unsigned char const   )'V',      (unsigned char const   )'W', 
        (unsigned char const   )'X',      (unsigned char const   )'Y',      (unsigned char const   )'Z',      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 174 "./../include/xregex2.h"
reg_syntax_t xre_syntax_options  ;
#line 442
reg_syntax_t xre_set_syntax(reg_syntax_t syntax ) ;
#line 447
char const   *xre_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 454
int xre_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 462
int xre_search(struct re_pattern_buffer *bufp , char const   *string , int size ,
               int startpos , int range , struct re_registers *regs ) ;
#line 469
int xre_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                 char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs ,
                 int stop ) ;
#line 477
int xre_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
              struct re_registers *regs ) ;
#line 482
int xre_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int pos , struct re_registers *regs ,
                int stop ) ;
#line 499
void xre_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                       unsigned int num_regs , xregoff_t *starts , xregoff_t *ends ) ;
#line 507
char *xre_comp(char const   *s ) ;
#line 508
int xre_exec(char const   *s ) ;
#line 535
int xregcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) ;
#line 542
int xregexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
             size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 547
size_t xregerror(int errcode , regex_t const   *preg  __attribute__((__unused__)) ,
                 char *errbuf , size_t errbuf_size ) ;
#line 550
void xregfree(regex_t *preg ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 81
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 272 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static char re_syntax_table[256]  ;
#line 274
static void init_syntax_once(void) ;
#line 280 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static int done  =    0;
#line 276 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static void init_syntax_once(void) 
{ 
  register int c ;
  unsigned short const   **tmp___0 ;

  {
#line 282
  if (done) {
#line 283
    return;
  }
  {
#line 284
  memset((void *)(re_syntax_table), '\000', sizeof(re_syntax_table));
#line 286
  c = 0;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (c < 256)) {
#line 286
      goto while_break;
    }
    {
#line 287
    tmp___0 = __ctype_b_loc();
    }
#line 287
    if ((int const   )*(*tmp___0 + c) & 8) {
#line 288
      re_syntax_table[c] = (char)1;
    }
#line 286
    c ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  re_syntax_table['_'] = (char)1;
#line 292
  done = 1;
#line 293
  return;
}
}
#line 408
static reg_errcode_t byte_regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                        struct re_pattern_buffer *bufp ) ;
#line 412
static int byte_re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                                    int size1 , char const   *string2 , int size2 ,
                                    int pos , struct re_registers *regs , int stop ) ;
#line 418
static int byte_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int size1 , char const   *string2 , int size2 , int startpos ,
                            int range , struct re_registers *regs , int stop ) ;
#line 423
static int byte_re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 1459 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_max_failures  =    4000;
#line 1838 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static char byte_reg_unset_dummy  ;
#line 1843
static void byte_store_op1(re_opcode_t op , unsigned char *loc , int arg ) ;
#line 1844
static void byte_store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) ;
#line 1846
static void byte_insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) ;
#line 1848
static void byte_insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                            unsigned char *end ) ;
#line 1850
static boolean byte_at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) ;
#line 1853
static boolean byte_at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) ;
#line 1866
static reg_errcode_t byte_compile_range(unsigned int range_start_char , char const   **p_ptr ,
                                        char const   *pend , char *translate , reg_syntax_t syntax ,
                                        unsigned char *b ) ;
#line 2250
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) ;
#line 2281 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static reg_errcode_t byte_regex_compile(char const   *pattern , size_t size , reg_syntax_t syntax ,
                                        struct re_pattern_buffer *bufp ) 
{ 
  register unsigned char c ;
  register unsigned char c1 ;
  char const   *p1 ;
  register unsigned char *b ;
  compile_stack_type compile_stack ;
  char const   *p ;
  char const   *pend ;
  char *translate ;
  unsigned char *pending_exact ;
  unsigned char *laststart ;
  unsigned char *begalt ;
  unsigned char *fixup_alt_jump ;
  regnum_t regnum ;
  void *tmp___0 ;
  unsigned int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  unsigned char *old_buffer ;
  void *tmp___5 ;
  int incr ;
  unsigned char *tmp___6 ;
  boolean tmp___7 ;
  unsigned char *old_buffer___0 ;
  void *tmp___8 ;
  int incr___0 ;
  unsigned char *tmp___9 ;
  boolean tmp___10 ;
  boolean keep_string_p ;
  char zero_times_ok ;
  char many_times_ok ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  unsigned char *old_buffer___1 ;
  void *tmp___13 ;
  int incr___1 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned char *old_buffer___2 ;
  void *tmp___18 ;
  int incr___2 ;
  int tmp___19 ;
  unsigned char *old_buffer___3 ;
  void *tmp___20 ;
  int incr___3 ;
  unsigned char *old_buffer___4 ;
  void *tmp___21 ;
  int incr___4 ;
  unsigned char *tmp___22 ;
  boolean had_char_class ;
  unsigned int range_start ;
  unsigned char *old_buffer___5 ;
  void *tmp___23 ;
  int incr___5 ;
  unsigned char *old_buffer___6 ;
  void *tmp___24 ;
  int incr___6 ;
  unsigned char *tmp___25 ;
  int tmp___26 ;
  unsigned char *old_buffer___7 ;
  void *tmp___27 ;
  int incr___7 ;
  unsigned char *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___31 ;
  reg_errcode_t ret___0 ;
  char const   *tmp___32 ;
  char str[7] ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  unsigned char tmp___35 ;
  int ch ;
  boolean is_alnum ;
  int tmp___36 ;
  boolean is_alpha ;
  int tmp___37 ;
  boolean is_blank ;
  int tmp___38 ;
  boolean is_cntrl ;
  int tmp___39 ;
  boolean is_digit ;
  int tmp___40 ;
  boolean is_graph ;
  int tmp___41 ;
  boolean is_lower ;
  int tmp___42 ;
  boolean is_print ;
  int tmp___43 ;
  boolean is_punct ;
  int tmp___44 ;
  boolean is_space ;
  int tmp___45 ;
  boolean is_upper ;
  int tmp___46 ;
  boolean is_xdigit ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  unsigned short const   **tmp___61 ;
  unsigned short const   **tmp___62 ;
  unsigned short const   **tmp___63 ;
  unsigned short const   **tmp___64 ;
  unsigned short const   **tmp___65 ;
  unsigned short const   **tmp___66 ;
  unsigned short const   **tmp___67 ;
  unsigned short const   **tmp___68 ;
  unsigned short const   **tmp___69 ;
  unsigned short const   **tmp___70 ;
  unsigned short const   **tmp___71 ;
  unsigned short const   **tmp___72 ;
  unsigned short const   **tmp___73 ;
  unsigned short const   **tmp___74 ;
  unsigned char tmp___75 ;
  unsigned char str___0[17] ;
  char const   *tmp___76 ;
  char const   *tmp___77 ;
  unsigned char tmp___78 ;
  char const   *tmp___79 ;
  unsigned char tmp___80 ;
  unsigned char str___1[128] ;
  char const   *tmp___81 ;
  char const   *tmp___82 ;
  unsigned char tmp___83 ;
  char const   *tmp___84 ;
  unsigned char tmp___85 ;
  char const   *tmp___86 ;
  void *tmp___87 ;
  unsigned char *old_buffer___8 ;
  void *tmp___88 ;
  int incr___8 ;
  unsigned char *tmp___89 ;
  unsigned char *tmp___90 ;
  unsigned char *tmp___91 ;
  unsigned char *old_buffer___9 ;
  void *tmp___92 ;
  int incr___9 ;
  unsigned char *tmp___93 ;
  regnum_t this_group_regnum ;
  unsigned char *inner_group_loc ;
  unsigned char *old_buffer___10 ;
  void *tmp___94 ;
  int incr___10 ;
  unsigned char *tmp___95 ;
  unsigned char *tmp___96 ;
  unsigned char *tmp___97 ;
  unsigned char *old_buffer___11 ;
  void *tmp___98 ;
  int incr___11 ;
  unsigned char *old_buffer___12 ;
  void *tmp___99 ;
  int incr___12 ;
  int lower_bound ;
  int upper_bound ;
  char const   *beg_interval ;
  char const   *tmp___100 ;
  char const   *tmp___101 ;
  char const   *tmp___102 ;
  unsigned char *old_buffer___13 ;
  void *tmp___103 ;
  int incr___13 ;
  unsigned int nbytes ;
  unsigned char *old_buffer___14 ;
  void *tmp___104 ;
  int incr___14 ;
  int tmp___105 ;
  unsigned char *old_buffer___15 ;
  void *tmp___106 ;
  int incr___15 ;
  unsigned char *tmp___107 ;
  unsigned char *old_buffer___16 ;
  void *tmp___108 ;
  int incr___16 ;
  unsigned char *tmp___109 ;
  unsigned char *old_buffer___17 ;
  void *tmp___110 ;
  int incr___17 ;
  unsigned char *tmp___111 ;
  unsigned char *old_buffer___18 ;
  void *tmp___112 ;
  int incr___18 ;
  unsigned char *tmp___113 ;
  unsigned char *old_buffer___19 ;
  void *tmp___114 ;
  int incr___19 ;
  unsigned char *tmp___115 ;
  unsigned char *old_buffer___20 ;
  void *tmp___116 ;
  int incr___20 ;
  unsigned char *tmp___117 ;
  unsigned char *old_buffer___21 ;
  void *tmp___118 ;
  int incr___21 ;
  unsigned char *tmp___119 ;
  unsigned char *old_buffer___22 ;
  void *tmp___120 ;
  int incr___22 ;
  unsigned char *tmp___121 ;
  boolean tmp___122 ;
  unsigned char *old_buffer___23 ;
  void *tmp___123 ;
  int incr___23 ;
  unsigned char *tmp___124 ;
  unsigned char *tmp___125 ;
  unsigned char *old_buffer___24 ;
  void *tmp___126 ;
  int incr___24 ;
  unsigned char *tmp___127 ;
  unsigned char *tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  int tmp___133 ;
  unsigned char *old_buffer___25 ;
  void *tmp___134 ;
  int incr___25 ;
  unsigned char *tmp___135 ;
  unsigned char *old_buffer___26 ;
  void *tmp___136 ;
  int incr___26 ;
  unsigned char *tmp___137 ;

  {
  {
#line 2317
  p = pattern;
#line 2318
  pend = pattern + size;
#line 2322
  translate = bufp->translate;
#line 2328
  pending_exact = (unsigned char *)0;
#line 2333
  laststart = (unsigned char *)0;
#line 2341
  fixup_alt_jump = (unsigned char *)0;
#line 2346
  regnum = (regnum_t )0;
#line 2385
  tmp___0 = malloc(32UL * sizeof(compile_stack_elt_t ));
#line 2385
  compile_stack.stack = (compile_stack_elt_t *)tmp___0;
  }
#line 2386
  if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
#line 2393
    return ((reg_errcode_t )12);
  }
  {
#line 2396
  compile_stack.size = 32U;
#line 2397
  compile_stack.avail = 0U;
#line 2400
  bufp->syntax = syntax;
#line 2401
  bufp->fastmap_accurate = 0U;
#line 2402
  tmp___1 = 0U;
#line 2402
  bufp->not_eol = tmp___1;
#line 2402
  bufp->not_bol = tmp___1;
#line 2407
  bufp->used = 0UL;
#line 2410
  bufp->re_nsub = (size_t )0;
#line 2414
  init_syntax_once();
  }
#line 2417
  if (bufp->allocated == 0UL) {
#line 2419
    if (bufp->buffer) {
      {
#line 2430
      tmp___2 = realloc((void *)bufp->buffer, (32UL * sizeof(unsigned char )) * sizeof(unsigned char ));
#line 2430
      bufp->buffer = (unsigned char *)tmp___2;
      }
    } else {
      {
#line 2435
      tmp___3 = malloc(((32UL * sizeof(unsigned char )) / sizeof(unsigned char )) * sizeof(unsigned char ));
#line 2435
      bufp->buffer = (unsigned char *)tmp___3;
      }
    }
#line 2439
    if (! bufp->buffer) {
      {
#line 2439
      free((void *)compile_stack.stack);
      }
#line 2439
      return ((reg_errcode_t )12);
    }
#line 2443
    bufp->allocated = 32UL * sizeof(unsigned char );
  }
#line 2450
  b = bufp->buffer;
#line 2450
  begalt = b;
  {
#line 2453
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2453
    if (! ((unsigned long )p != (unsigned long )pend)) {
#line 2453
      goto while_break;
    }
    {
#line 2455
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2455
      if ((unsigned long )p == (unsigned long )pend) {
#line 2455
        return ((reg_errcode_t )14);
      }
#line 2455
      tmp___4 = p;
#line 2455
      p ++;
#line 2455
      c = (unsigned char )*tmp___4;
#line 2455
      if (translate) {
#line 2455
        c = (unsigned char )*(translate + c);
      }
#line 2455
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2459
    if ((int )c == 94) {
#line 2459
      goto case_94;
    }
#line 2474
    if ((int )c == 36) {
#line 2474
      goto case_36;
    }
#line 2490
    if ((int )c == 63) {
#line 2490
      goto case_63;
    }
#line 2490
    if ((int )c == 43) {
#line 2490
      goto case_63;
    }
#line 2495
    if ((int )c == 42) {
#line 2495
      goto handle_plus;
    }
#line 2626
    if ((int )c == 46) {
#line 2626
      goto case_46;
    }
#line 2632
    if ((int )c == 91) {
#line 2632
      goto case_91;
    }
#line 3607
    if ((int )c == 40) {
#line 3607
      goto case_40;
    }
#line 3614
    if ((int )c == 41) {
#line 3614
      goto case_41;
    }
#line 3621
    if ((int )c == 10) {
#line 3621
      goto case_10;
    }
#line 3628
    if ((int )c == 124) {
#line 3628
      goto case_124;
    }
#line 3635
    if ((int )c == 123) {
#line 3635
      goto case_123;
    }
#line 3642
    if ((int )c == 92) {
#line 3642
      goto case_92;
    }
#line 4093
    goto normal_char;
    case_94: /* CIL Label */ 
#line 2461
    if ((unsigned long )p == (unsigned long )(pattern + 1)) {
#line 2461
      goto _L;
    } else
#line 2461
    if (syntax & (((1UL << 1) << 1) << 1)) {
#line 2461
      goto _L;
    } else {
      {
#line 2461
      tmp___7 = byte_at_begline_loc_p(pattern, p, syntax);
      }
#line 2461
      if (tmp___7) {
        _L: /* CIL Label */ 
        {
#line 2467
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 2467
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 2467
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2467
              goto while_break___2;
            }
            {
#line 2467
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2467
              old_buffer = bufp->buffer;
#line 2467
              if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2467
                return ((reg_errcode_t )15);
              }
#line 2467
              bufp->allocated <<= 1;
#line 2467
              if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2467
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
#line 2467
              tmp___5 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2467
              bufp->buffer = (unsigned char *)tmp___5;
              }
#line 2467
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2467
                return ((reg_errcode_t )12);
              }
#line 2467
              if ((unsigned long )old_buffer != (unsigned long )bufp->buffer) {
#line 2467
                incr = (int )(bufp->buffer - old_buffer);
#line 2467
                b += incr;
#line 2467
                begalt += incr;
#line 2467
                if (fixup_alt_jump) {
#line 2467
                  fixup_alt_jump += incr;
                }
#line 2467
                if (laststart) {
#line 2467
                  laststart += incr;
                }
#line 2467
                if (pending_exact) {
#line 2467
                  pending_exact += incr;
                }
              }
#line 2467
              goto while_break___3;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
#line 2467
          tmp___6 = b;
#line 2467
          b ++;
#line 2467
          *tmp___6 = (unsigned char)9;
#line 2467
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else {
#line 2469
        goto normal_char;
      }
    }
#line 2471
    goto switch_break;
    case_36: /* CIL Label */ 
#line 2476
    if ((unsigned long )p == (unsigned long )pend) {
#line 2476
      goto _L___0;
    } else
#line 2476
    if (syntax & (((1UL << 1) << 1) << 1)) {
#line 2476
      goto _L___0;
    } else {
      {
#line 2476
      tmp___10 = byte_at_endline_loc_p(p, pend, syntax);
      }
#line 2476
      if (tmp___10) {
        _L___0: /* CIL Label */ 
        {
#line 2482
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 2482
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 2482
            if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2482
              goto while_break___5;
            }
            {
#line 2482
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 2482
              old_buffer___0 = bufp->buffer;
#line 2482
              if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2482
                return ((reg_errcode_t )15);
              }
#line 2482
              bufp->allocated <<= 1;
#line 2482
              if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2482
                bufp->allocated = (unsigned long )(1L << 16);
              }
              {
#line 2482
              tmp___8 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2482
              bufp->buffer = (unsigned char *)tmp___8;
              }
#line 2482
              if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2482
                return ((reg_errcode_t )12);
              }
#line 2482
              if ((unsigned long )old_buffer___0 != (unsigned long )bufp->buffer) {
#line 2482
                incr___0 = (int )(bufp->buffer - old_buffer___0);
#line 2482
                b += incr___0;
#line 2482
                begalt += incr___0;
#line 2482
                if (fixup_alt_jump) {
#line 2482
                  fixup_alt_jump += incr___0;
                }
#line 2482
                if (laststart) {
#line 2482
                  laststart += incr___0;
                }
#line 2482
                if (pending_exact) {
#line 2482
                  pending_exact += incr___0;
                }
              }
#line 2482
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 2482
          tmp___9 = b;
#line 2482
          b ++;
#line 2482
          *tmp___9 = (unsigned char)10;
#line 2482
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
#line 2484
        goto normal_char;
      }
    }
#line 2486
    goto switch_break;
    case_63: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 2491
    if (syntax & (1UL << 1)) {
#line 2493
      goto normal_char;
    } else
#line 2491
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2493
      goto normal_char;
    }
    handle_plus: 
    case_42: /* CIL Label */ 
#line 2497
    if (! laststart) {
#line 2499
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
        {
#line 2500
        free((void *)compile_stack.stack);
        }
#line 2500
        return ((reg_errcode_t )13);
      } else
#line 2501
      if (! (syntax & ((((1UL << 1) << 1) << 1) << 1))) {
#line 2502
        goto normal_char;
      }
    }
#line 2507
    keep_string_p = (boolean )0;
#line 2510
    zero_times_ok = (char)0;
#line 2510
    many_times_ok = (char)0;
    {
#line 2517
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2519
      zero_times_ok = (char )((int )zero_times_ok | ((int )c != 43));
#line 2520
      many_times_ok = (char )((int )many_times_ok | ((int )c != 63));
#line 2522
      if ((unsigned long )p == (unsigned long )pend) {
#line 2523
        goto while_break___7;
      }
      {
#line 2525
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2525
        if ((unsigned long )p == (unsigned long )pend) {
#line 2525
          return ((reg_errcode_t )14);
        }
#line 2525
        tmp___11 = p;
#line 2525
        p ++;
#line 2525
        c = (unsigned char )*tmp___11;
#line 2525
        if (translate) {
#line 2525
          c = (unsigned char )*(translate + c);
        }
#line 2525
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2527
      if (! ((int )c == 42)) {
#line 2527
        if (! (syntax & (1UL << 1))) {
#line 2527
          if (! ((int )c == 43)) {
#line 2527
            if (! ((int )c == 63)) {
#line 2527
              goto _L___1;
            }
          }
        } else
        _L___1: /* CIL Label */ 
#line 2531
        if (syntax & (1UL << 1)) {
#line 2531
          if ((int )c == 92) {
#line 2533
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 2533
              free((void *)compile_stack.stack);
              }
#line 2533
              return ((reg_errcode_t )5);
            }
            {
#line 2535
            while (1) {
              while_continue___9: /* CIL Label */ ;
#line 2535
              if ((unsigned long )p == (unsigned long )pend) {
#line 2535
                return ((reg_errcode_t )14);
              }
#line 2535
              tmp___12 = p;
#line 2535
              p ++;
#line 2535
              c1 = (unsigned char )*tmp___12;
#line 2535
              if (translate) {
#line 2535
                c1 = (unsigned char )*(translate + c1);
              }
#line 2535
              goto while_break___9;
            }
            while_break___9: /* CIL Label */ ;
            }
#line 2536
            if (! ((int )c1 == 43)) {
#line 2536
              if (! ((int )c1 == 63)) {
#line 2538
                p --;
#line 2539
                p --;
#line 2540
                goto while_break___7;
              }
            }
#line 2543
            c = c1;
          } else {
#line 2547
            p --;
#line 2548
            goto while_break___7;
          }
        } else {
#line 2547
          p --;
#line 2548
          goto while_break___7;
        }
      }
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2556
    if (! laststart) {
#line 2557
      goto switch_break;
    }
#line 2561
    if (many_times_ok) {
      {
#line 2575
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2575
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2575
          goto while_break___10;
        }
        {
#line 2575
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 2575
          old_buffer___1 = bufp->buffer;
#line 2575
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2575
            return ((reg_errcode_t )15);
          }
#line 2575
          bufp->allocated <<= 1;
#line 2575
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2575
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2575
          tmp___13 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2575
          bufp->buffer = (unsigned char *)tmp___13;
          }
#line 2575
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2575
            return ((reg_errcode_t )12);
          }
#line 2575
          if ((unsigned long )old_buffer___1 != (unsigned long )bufp->buffer) {
#line 2575
            incr___1 = (int )(bufp->buffer - old_buffer___1);
#line 2575
            b += incr___1;
#line 2575
            begalt += incr___1;
#line 2575
            if (fixup_alt_jump) {
#line 2575
              fixup_alt_jump += incr___1;
            }
#line 2575
            if (laststart) {
#line 2575
              laststart += incr___1;
            }
#line 2575
            if (pending_exact) {
#line 2575
              pending_exact += incr___1;
            }
          }
#line 2575
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 2582
      if (translate) {
#line 2582
        tmp___14 = (int )*(translate + (unsigned char )*(p - 2));
      } else {
#line 2582
        tmp___14 = (int )((char )*(p - 2));
      }
#line 2582
      if (translate) {
#line 2582
        tmp___15 = (int )*(translate + (unsigned char )'.');
      } else {
#line 2582
        tmp___15 = (int )((char )'.');
      }
#line 2582
      if (tmp___14 == tmp___15) {
#line 2582
        if (zero_times_ok) {
#line 2582
          if ((unsigned long )p < (unsigned long )pend) {
#line 2582
            if (translate) {
#line 2582
              tmp___16 = (int )*(translate + (unsigned char )*p);
            } else {
#line 2582
              tmp___16 = (int )((char )*p);
            }
#line 2582
            if (translate) {
#line 2582
              tmp___17 = (int )*(translate + (unsigned char )'\n');
            } else {
#line 2582
              tmp___17 = (int )((char )'\n');
            }
#line 2582
            if (tmp___16 == tmp___17) {
#line 2582
              if (! (syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
                {
#line 2587
                byte_store_op1((re_opcode_t )13, b, (int )((laststart - b) - 3L));
#line 2588
                keep_string_p = (boolean )1;
                }
              } else {
                {
#line 2592
                byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
                }
              }
            } else {
              {
#line 2592
              byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
              }
            }
          } else {
            {
#line 2592
            byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
            }
          }
        } else {
          {
#line 2592
          byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
          }
        }
      } else {
        {
#line 2592
        byte_store_op1((re_opcode_t )18, b, (int )(((laststart - 3) - b) - 3L));
        }
      }
#line 2596
      b += 3;
    }
    {
#line 2603
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 2603
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2603
        goto while_break___12;
      }
      {
#line 2603
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 2603
        old_buffer___2 = bufp->buffer;
#line 2603
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2603
          return ((reg_errcode_t )15);
        }
#line 2603
        bufp->allocated <<= 1;
#line 2603
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2603
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 2603
        tmp___18 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2603
        bufp->buffer = (unsigned char *)tmp___18;
        }
#line 2603
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2603
          return ((reg_errcode_t )12);
        }
#line 2603
        if ((unsigned long )old_buffer___2 != (unsigned long )bufp->buffer) {
#line 2603
          incr___2 = (int )(bufp->buffer - old_buffer___2);
#line 2603
          b += incr___2;
#line 2603
          begalt += incr___2;
#line 2603
          if (fixup_alt_jump) {
#line 2603
            fixup_alt_jump += incr___2;
          }
#line 2603
          if (laststart) {
#line 2603
            laststart += incr___2;
          }
#line 2603
          if (pending_exact) {
#line 2603
            pending_exact += incr___2;
          }
        }
#line 2603
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    while_break___12: /* CIL Label */ ;
    }
#line 2604
    if (keep_string_p) {
#line 2604
      tmp___19 = 16;
    } else {
#line 2604
      tmp___19 = 15;
    }
    {
#line 2604
    byte_insert_op1((re_opcode_t )tmp___19, laststart, (int )((((b + 1) + 2) - laststart) - 3L),
                    b);
#line 2607
    pending_exact = (unsigned char *)0;
#line 2608
    b += 3;
    }
#line 2610
    if (! zero_times_ok) {
      {
#line 2617
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 2617
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 2617
          goto while_break___14;
        }
        {
#line 2617
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 2617
          old_buffer___3 = bufp->buffer;
#line 2617
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2617
            return ((reg_errcode_t )15);
          }
#line 2617
          bufp->allocated <<= 1;
#line 2617
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2617
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2617
          tmp___20 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2617
          bufp->buffer = (unsigned char *)tmp___20;
          }
#line 2617
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2617
            return ((reg_errcode_t )12);
          }
#line 2617
          if ((unsigned long )old_buffer___3 != (unsigned long )bufp->buffer) {
#line 2617
            incr___3 = (int )(bufp->buffer - old_buffer___3);
#line 2617
            b += incr___3;
#line 2617
            begalt += incr___3;
#line 2617
            if (fixup_alt_jump) {
#line 2617
              fixup_alt_jump += incr___3;
            }
#line 2617
            if (laststart) {
#line 2617
              laststart += incr___3;
            }
#line 2617
            if (pending_exact) {
#line 2617
              pending_exact += incr___3;
            }
          }
#line 2617
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 2618
      byte_insert_op1((re_opcode_t )19, laststart, (int )((((laststart + 2) + 4) - laststart) - 3L),
                      b);
#line 2620
      b += 3;
      }
    }
#line 2623
    goto switch_break;
    case_46: /* CIL Label */ 
#line 2627
    laststart = b;
    {
#line 2628
    while (1) {
      while_continue___16: /* CIL Label */ ;
      {
#line 2628
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 2628
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 2628
          goto while_break___17;
        }
        {
#line 2628
        while (1) {
          while_continue___18: /* CIL Label */ ;
#line 2628
          old_buffer___4 = bufp->buffer;
#line 2628
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 2628
            return ((reg_errcode_t )15);
          }
#line 2628
          bufp->allocated <<= 1;
#line 2628
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 2628
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 2628
          tmp___21 = realloc((void *)bufp->buffer, bufp->allocated);
#line 2628
          bufp->buffer = (unsigned char *)tmp___21;
          }
#line 2628
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 2628
            return ((reg_errcode_t )12);
          }
#line 2628
          if ((unsigned long )old_buffer___4 != (unsigned long )bufp->buffer) {
#line 2628
            incr___4 = (int )(bufp->buffer - old_buffer___4);
#line 2628
            b += incr___4;
#line 2628
            begalt += incr___4;
#line 2628
            if (fixup_alt_jump) {
#line 2628
              fixup_alt_jump += incr___4;
            }
#line 2628
            if (laststart) {
#line 2628
              laststart += incr___4;
            }
#line 2628
            if (pending_exact) {
#line 2628
              pending_exact += incr___4;
            }
          }
#line 2628
          goto while_break___18;
        }
        while_break___18: /* CIL Label */ ;
        }
      }
      while_break___17: /* CIL Label */ ;
      }
#line 2628
      tmp___22 = b;
#line 2628
      b ++;
#line 2628
      *tmp___22 = (unsigned char)3;
#line 2628
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 2629
    goto switch_break;
    case_91: /* CIL Label */ 
#line 2634
    had_char_class = (boolean )0;
#line 2638
    range_start = 4294967295U;
#line 2640
    if ((unsigned long )p == (unsigned long )pend) {
      {
#line 2640
      free((void *)compile_stack.stack);
      }
#line 2640
      return ((reg_errcode_t )7);
    }
    {
#line 3107
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 3107
      if (! ((unsigned long )((b - bufp->buffer) + 34L) > bufp->allocated)) {
#line 3107
        goto while_break___19;
      }
      {
#line 3107
      while (1) {
        while_continue___20: /* CIL Label */ ;
#line 3107
        old_buffer___5 = bufp->buffer;
#line 3107
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3107
          return ((reg_errcode_t )15);
        }
#line 3107
        bufp->allocated <<= 1;
#line 3107
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3107
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 3107
        tmp___23 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3107
        bufp->buffer = (unsigned char *)tmp___23;
        }
#line 3107
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3107
          return ((reg_errcode_t )12);
        }
#line 3107
        if ((unsigned long )old_buffer___5 != (unsigned long )bufp->buffer) {
#line 3107
          incr___5 = (int )(bufp->buffer - old_buffer___5);
#line 3107
          b += incr___5;
#line 3107
          begalt += incr___5;
#line 3107
          if (fixup_alt_jump) {
#line 3107
            fixup_alt_jump += incr___5;
          }
#line 3107
          if (laststart) {
#line 3107
            laststart += incr___5;
          }
#line 3107
          if (pending_exact) {
#line 3107
            pending_exact += incr___5;
          }
        }
#line 3107
        goto while_break___20;
      }
      while_break___20: /* CIL Label */ ;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
#line 3109
    laststart = b;
    {
#line 3113
    while (1) {
      while_continue___21: /* CIL Label */ ;
      {
#line 3113
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 3113
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 3113
          goto while_break___22;
        }
        {
#line 3113
        while (1) {
          while_continue___23: /* CIL Label */ ;
#line 3113
          old_buffer___6 = bufp->buffer;
#line 3113
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3113
            return ((reg_errcode_t )15);
          }
#line 3113
          bufp->allocated <<= 1;
#line 3113
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3113
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3113
          tmp___24 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3113
          bufp->buffer = (unsigned char *)tmp___24;
          }
#line 3113
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3113
            return ((reg_errcode_t )12);
          }
#line 3113
          if ((unsigned long )old_buffer___6 != (unsigned long )bufp->buffer) {
#line 3113
            incr___6 = (int )(bufp->buffer - old_buffer___6);
#line 3113
            b += incr___6;
#line 3113
            begalt += incr___6;
#line 3113
            if (fixup_alt_jump) {
#line 3113
              fixup_alt_jump += incr___6;
            }
#line 3113
            if (laststart) {
#line 3113
              laststart += incr___6;
            }
#line 3113
            if (pending_exact) {
#line 3113
              pending_exact += incr___6;
            }
          }
#line 3113
          goto while_break___23;
        }
        while_break___23: /* CIL Label */ ;
        }
      }
      while_break___22: /* CIL Label */ ;
      }
#line 3113
      tmp___25 = b;
#line 3113
      b ++;
#line 3113
      if ((int const   )*p == 94) {
#line 3113
        tmp___26 = 5;
      } else {
#line 3113
        tmp___26 = 4;
      }
#line 3113
      *tmp___25 = (unsigned char )tmp___26;
#line 3113
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 3114
    if ((int const   )*p == 94) {
#line 3115
      p ++;
    }
#line 3118
    p1 = p;
    {
#line 3121
    while (1) {
      while_continue___24: /* CIL Label */ ;
      {
#line 3121
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 3121
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 3121
          goto while_break___25;
        }
        {
#line 3121
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 3121
          old_buffer___7 = bufp->buffer;
#line 3121
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3121
            return ((reg_errcode_t )15);
          }
#line 3121
          bufp->allocated <<= 1;
#line 3121
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3121
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3121
          tmp___27 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3121
          bufp->buffer = (unsigned char *)tmp___27;
          }
#line 3121
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3121
            return ((reg_errcode_t )12);
          }
#line 3121
          if ((unsigned long )old_buffer___7 != (unsigned long )bufp->buffer) {
#line 3121
            incr___7 = (int )(bufp->buffer - old_buffer___7);
#line 3121
            b += incr___7;
#line 3121
            begalt += incr___7;
#line 3121
            if (fixup_alt_jump) {
#line 3121
              fixup_alt_jump += incr___7;
            }
#line 3121
            if (laststart) {
#line 3121
              laststart += incr___7;
            }
#line 3121
            if (pending_exact) {
#line 3121
              pending_exact += incr___7;
            }
          }
#line 3121
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
      }
      while_break___25: /* CIL Label */ ;
      }
#line 3121
      tmp___28 = b;
#line 3121
      b ++;
#line 3121
      *tmp___28 = (unsigned char )((1 << 8) / 8);
#line 3121
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 3124
    memset((void *)b, '\000', (size_t )((1 << 8) / 8));
    }
#line 3127
    if ((unsigned int )((re_opcode_t )*(b + -2)) == 5U) {
#line 3127
      if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3129
        *(b + 1) = (unsigned char )((int )*(b + 1) | (1 << 2));
      }
    }
    {
#line 3132
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 3134
      if ((unsigned long )p == (unsigned long )pend) {
        {
#line 3134
        free((void *)compile_stack.stack);
        }
#line 3134
        return ((reg_errcode_t )7);
      }
      {
#line 3136
      while (1) {
        while_continue___28: /* CIL Label */ ;
#line 3136
        if ((unsigned long )p == (unsigned long )pend) {
#line 3136
          return ((reg_errcode_t )14);
        }
#line 3136
        tmp___29 = p;
#line 3136
        p ++;
#line 3136
        c = (unsigned char )*tmp___29;
#line 3136
        if (translate) {
#line 3136
          c = (unsigned char )*(translate + c);
        }
#line 3136
        goto while_break___28;
      }
      while_break___28: /* CIL Label */ ;
      }
#line 3139
      if (syntax & 1UL) {
#line 3139
        if ((int )c == 92) {
#line 3141
          if ((unsigned long )p == (unsigned long )pend) {
            {
#line 3141
            free((void *)compile_stack.stack);
            }
#line 3141
            return ((reg_errcode_t )5);
          }
          {
#line 3143
          while (1) {
            while_continue___29: /* CIL Label */ ;
#line 3143
            if ((unsigned long )p == (unsigned long )pend) {
#line 3143
              return ((reg_errcode_t )14);
            }
#line 3143
            tmp___30 = p;
#line 3143
            p ++;
#line 3143
            c1 = (unsigned char )*tmp___30;
#line 3143
            if (translate) {
#line 3143
              c1 = (unsigned char )*(translate + c1);
            }
#line 3143
            goto while_break___29;
          }
          while_break___29: /* CIL Label */ ;
          }
#line 3144
          *(b + (int )c1 / 8) = (unsigned char )((int )*(b + (int )c1 / 8) | (1 << (int )c1 % 8));
#line 3145
          range_start = (unsigned int )c1;
#line 3146
          goto __Cont;
        }
      }
#line 3152
      if ((int )c == 93) {
#line 3152
        if ((unsigned long )p != (unsigned long )(p1 + 1)) {
#line 3153
          goto while_break___27;
        }
      }
#line 3157
      if (had_char_class) {
#line 3157
        if ((int )c == 45) {
#line 3157
          if ((int const   )*p != 93) {
            {
#line 3158
            free((void *)compile_stack.stack);
            }
#line 3158
            return ((reg_errcode_t )11);
          }
        }
      }
#line 3164
      if ((int )c == 45) {
#line 3164
        if ((unsigned long )(p - 2) >= (unsigned long )pattern) {
#line 3164
          if ((int const   )*(p + -2) == 91) {
#line 3164
            goto _L___29;
          } else {
#line 3164
            goto _L___30;
          }
        } else
        _L___30: /* CIL Label */ 
#line 3164
        if ((unsigned long )(p - 3) >= (unsigned long )pattern) {
#line 3164
          if ((int const   )*(p + -3) == 91) {
#line 3164
            if ((int const   )*(p + -2) == 94) {
#line 3164
              goto _L___29;
            } else {
#line 3164
              goto _L___28;
            }
          } else {
#line 3164
            goto _L___28;
          }
        } else
        _L___28: /* CIL Label */ 
#line 3164
        if ((int const   )*p != 93) {
          {
#line 3169
          tmp___31 = byte_compile_range(range_start, & p, pend, translate, syntax,
                                        b);
#line 3169
          ret = tmp___31;
          }
#line 3172
          if ((int )ret != 0) {
            {
#line 3172
            free((void *)compile_stack.stack);
            }
#line 3172
            return (ret);
          }
#line 3173
          range_start = 4294967295U;
        } else {
#line 3164
          goto _L___29;
        }
      } else
      _L___29: /* CIL Label */ 
#line 3176
      if ((int const   )*(p + 0) == 45) {
#line 3176
        if ((int const   )*(p + 1) != 93) {
          {
#line 3181
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 3181
            if ((unsigned long )p == (unsigned long )pend) {
#line 3181
              return ((reg_errcode_t )14);
            }
#line 3181
            tmp___32 = p;
#line 3181
            p ++;
#line 3181
            c1 = (unsigned char )*tmp___32;
#line 3181
            if (translate) {
#line 3181
              c1 = (unsigned char )*(translate + c1);
            }
#line 3181
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 3183
          ret___0 = byte_compile_range((unsigned int )c, & p, pend, translate, syntax,
                                       b);
          }
#line 3184
          if ((int )ret___0 != 0) {
            {
#line 3184
            free((void *)compile_stack.stack);
            }
#line 3184
            return (ret___0);
          }
#line 3185
          range_start = 4294967295U;
        } else {
#line 3176
          goto _L___24;
        }
      } else
      _L___24: /* CIL Label */ 
#line 3191
      if (syntax & ((1UL << 1) << 1)) {
#line 3191
        if ((int )c == 91) {
#line 3191
          if ((int const   )*p == 58) {
            {
#line 3195
            while (1) {
              while_continue___31: /* CIL Label */ ;
#line 3195
              if ((unsigned long )p == (unsigned long )pend) {
#line 3195
                return ((reg_errcode_t )14);
              }
#line 3195
              tmp___33 = p;
#line 3195
              p ++;
#line 3195
              c = (unsigned char )*tmp___33;
#line 3195
              if (translate) {
#line 3195
                c = (unsigned char )*(translate + c);
              }
#line 3195
              goto while_break___31;
            }
            while_break___31: /* CIL Label */ ;
            }
#line 3196
            c1 = (unsigned char)0;
#line 3199
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 3199
              free((void *)compile_stack.stack);
              }
#line 3199
              return ((reg_errcode_t )7);
            }
            {
#line 3201
            while (1) {
              while_continue___32: /* CIL Label */ ;
              {
#line 3203
              while (1) {
                while_continue___33: /* CIL Label */ ;
#line 3203
                if ((unsigned long )p == (unsigned long )pend) {
#line 3203
                  return ((reg_errcode_t )14);
                }
#line 3203
                tmp___34 = p;
#line 3203
                p ++;
#line 3203
                c = (unsigned char )*tmp___34;
#line 3203
                if (translate) {
#line 3203
                  c = (unsigned char )*(translate + c);
                }
#line 3203
                goto while_break___33;
              }
              while_break___33: /* CIL Label */ ;
              }
#line 3204
              if ((int )c == 58) {
#line 3204
                if ((int const   )*p == 93) {
#line 3205
                  goto while_break___32;
                } else {
#line 3204
                  goto _L___2;
                }
              } else
              _L___2: /* CIL Label */ 
#line 3204
              if ((unsigned long )p == (unsigned long )pend) {
#line 3205
                goto while_break___32;
              }
#line 3206
              if ((int )c1 < 6) {
#line 3207
                tmp___35 = c1;
#line 3207
                c1 = (unsigned char )((int )c1 + 1);
#line 3207
                str[tmp___35] = (char )c;
              } else {
#line 3210
                str[0] = (char )'\000';
              }
            }
            while_break___32: /* CIL Label */ ;
            }
#line 3212
            str[c1] = (char )'\000';
#line 3217
            if ((int )c == 58) {
#line 3217
              if ((int const   )*p == 93) {
                {
#line 3253
                tmp___36 = strcmp((char const   *)(str), "alnum");
#line 3253
                is_alnum = (boolean )(tmp___36 == 0);
#line 3254
                tmp___37 = strcmp((char const   *)(str), "alpha");
#line 3254
                is_alpha = (boolean )(tmp___37 == 0);
#line 3255
                tmp___38 = strcmp((char const   *)(str), "blank");
#line 3255
                is_blank = (boolean )(tmp___38 == 0);
#line 3256
                tmp___39 = strcmp((char const   *)(str), "cntrl");
#line 3256
                is_cntrl = (boolean )(tmp___39 == 0);
#line 3257
                tmp___40 = strcmp((char const   *)(str), "digit");
#line 3257
                is_digit = (boolean )(tmp___40 == 0);
#line 3258
                tmp___41 = strcmp((char const   *)(str), "graph");
#line 3258
                is_graph = (boolean )(tmp___41 == 0);
#line 3259
                tmp___42 = strcmp((char const   *)(str), "lower");
#line 3259
                is_lower = (boolean )(tmp___42 == 0);
#line 3260
                tmp___43 = strcmp((char const   *)(str), "print");
#line 3260
                is_print = (boolean )(tmp___43 == 0);
#line 3261
                tmp___44 = strcmp((char const   *)(str), "punct");
#line 3261
                is_punct = (boolean )(tmp___44 == 0);
#line 3262
                tmp___45 = strcmp((char const   *)(str), "space");
#line 3262
                is_space = (boolean )(tmp___45 == 0);
#line 3263
                tmp___46 = strcmp((char const   *)(str), "upper");
#line 3263
                is_upper = (boolean )(tmp___46 == 0);
#line 3264
                tmp___47 = strcmp((char const   *)(str), "xdigit");
#line 3264
                is_xdigit = (boolean )(tmp___47 == 0);
#line 3266
                tmp___48 = strcmp((char const   *)(str), "alpha");
                }
#line 3266
                if (! (tmp___48 == 0)) {
                  {
#line 3266
                  tmp___49 = strcmp((char const   *)(str), "upper");
                  }
#line 3266
                  if (! (tmp___49 == 0)) {
                    {
#line 3266
                    tmp___50 = strcmp((char const   *)(str), "lower");
                    }
#line 3266
                    if (! (tmp___50 == 0)) {
                      {
#line 3266
                      tmp___51 = strcmp((char const   *)(str), "digit");
                      }
#line 3266
                      if (! (tmp___51 == 0)) {
                        {
#line 3266
                        tmp___52 = strcmp((char const   *)(str), "alnum");
                        }
#line 3266
                        if (! (tmp___52 == 0)) {
                          {
#line 3266
                          tmp___53 = strcmp((char const   *)(str), "xdigit");
                          }
#line 3266
                          if (! (tmp___53 == 0)) {
                            {
#line 3266
                            tmp___54 = strcmp((char const   *)(str), "space");
                            }
#line 3266
                            if (! (tmp___54 == 0)) {
                              {
#line 3266
                              tmp___55 = strcmp((char const   *)(str), "print");
                              }
#line 3266
                              if (! (tmp___55 == 0)) {
                                {
#line 3266
                                tmp___56 = strcmp((char const   *)(str), "punct");
                                }
#line 3266
                                if (! (tmp___56 == 0)) {
                                  {
#line 3266
                                  tmp___57 = strcmp((char const   *)(str), "graph");
                                  }
#line 3266
                                  if (! (tmp___57 == 0)) {
                                    {
#line 3266
                                    tmp___58 = strcmp((char const   *)(str), "cntrl");
                                    }
#line 3266
                                    if (! (tmp___58 == 0)) {
                                      {
#line 3266
                                      tmp___59 = strcmp((char const   *)(str), "blank");
                                      }
#line 3266
                                      if (! (tmp___59 == 0)) {
                                        {
#line 3267
                                        free((void *)compile_stack.stack);
                                        }
#line 3267
                                        return ((reg_errcode_t )4);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                {
#line 3271
                while (1) {
                  while_continue___34: /* CIL Label */ ;
#line 3271
                  if ((unsigned long )p == (unsigned long )pend) {
#line 3271
                    return ((reg_errcode_t )14);
                  }
#line 3271
                  tmp___60 = p;
#line 3271
                  p ++;
#line 3271
                  c = (unsigned char )*tmp___60;
#line 3271
                  if (translate) {
#line 3271
                    c = (unsigned char )*(translate + c);
                  }
#line 3271
                  goto while_break___34;
                }
                while_break___34: /* CIL Label */ ;
                }
#line 3273
                if ((unsigned long )p == (unsigned long )pend) {
                  {
#line 3273
                  free((void *)compile_stack.stack);
                  }
#line 3273
                  return ((reg_errcode_t )7);
                }
#line 3275
                ch = 0;
                {
#line 3275
                while (1) {
                  while_continue___35: /* CIL Label */ ;
#line 3275
                  if (! (ch < 1 << 8)) {
#line 3275
                    goto while_break___35;
                  }
#line 3279
                  if (is_alnum) {
                    {
#line 3279
                    tmp___61 = __ctype_b_loc();
                    }
#line 3279
                    if ((int const   )*(*tmp___61 + ch) & 8) {
#line 3283
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3279
                      goto _L___5;
                    }
                  } else
                  _L___5: /* CIL Label */ 
#line 3279
                  if (is_alpha) {
                    {
#line 3279
                    tmp___62 = __ctype_b_loc();
                    }
#line 3279
                    if ((int const   )*(*tmp___62 + ch) & 1024) {
#line 3283
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3279
                      goto _L___4;
                    }
                  } else
                  _L___4: /* CIL Label */ 
#line 3279
                  if (is_blank) {
                    {
#line 3279
                    tmp___63 = __ctype_b_loc();
                    }
#line 3279
                    if ((int const   )*(*tmp___63 + ch) & 1) {
#line 3283
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3279
                      goto _L___3;
                    }
                  } else
                  _L___3: /* CIL Label */ 
#line 3279
                  if (is_cntrl) {
                    {
#line 3279
                    tmp___64 = __ctype_b_loc();
                    }
#line 3279
                    if ((int const   )*(*tmp___64 + ch) & 2) {
#line 3283
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 3284
                  if (is_digit) {
                    {
#line 3284
                    tmp___65 = __ctype_b_loc();
                    }
#line 3284
                    if ((int const   )*(*tmp___65 + ch) & 2048) {
#line 3288
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3284
                      goto _L___8;
                    }
                  } else
                  _L___8: /* CIL Label */ 
#line 3284
                  if (is_graph) {
                    {
#line 3284
                    tmp___66 = __ctype_b_loc();
                    }
#line 3284
                    if ((int const   )*(*tmp___66 + ch) & 32768) {
#line 3288
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3284
                      goto _L___7;
                    }
                  } else
                  _L___7: /* CIL Label */ 
#line 3284
                  if (is_lower) {
                    {
#line 3284
                    tmp___67 = __ctype_b_loc();
                    }
#line 3284
                    if ((int const   )*(*tmp___67 + ch) & 512) {
#line 3288
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3284
                      goto _L___6;
                    }
                  } else
                  _L___6: /* CIL Label */ 
#line 3284
                  if (is_print) {
                    {
#line 3284
                    tmp___68 = __ctype_b_loc();
                    }
#line 3284
                    if ((int const   )*(*tmp___68 + ch) & 16384) {
#line 3288
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 3289
                  if (is_punct) {
                    {
#line 3289
                    tmp___69 = __ctype_b_loc();
                    }
#line 3289
                    if ((int const   )*(*tmp___69 + ch) & 4) {
#line 3293
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3289
                      goto _L___11;
                    }
                  } else
                  _L___11: /* CIL Label */ 
#line 3289
                  if (is_space) {
                    {
#line 3289
                    tmp___70 = __ctype_b_loc();
                    }
#line 3289
                    if ((int const   )*(*tmp___70 + ch) & 8192) {
#line 3293
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3289
                      goto _L___10;
                    }
                  } else
                  _L___10: /* CIL Label */ 
#line 3289
                  if (is_upper) {
                    {
#line 3289
                    tmp___71 = __ctype_b_loc();
                    }
#line 3289
                    if ((int const   )*(*tmp___71 + ch) & 256) {
#line 3293
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    } else {
#line 3289
                      goto _L___9;
                    }
                  } else
                  _L___9: /* CIL Label */ 
#line 3289
                  if (is_xdigit) {
                    {
#line 3289
                    tmp___72 = __ctype_b_loc();
                    }
#line 3289
                    if ((int const   )*(*tmp___72 + ch) & 4096) {
#line 3293
                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                    }
                  }
#line 3294
                  if (translate) {
#line 3294
                    if (is_upper) {
#line 3294
                      goto _L___12;
                    } else
#line 3294
                    if (is_lower) {
                      _L___12: /* CIL Label */ 
                      {
#line 3294
                      tmp___73 = __ctype_b_loc();
                      }
#line 3294
                      if ((int const   )*(*tmp___73 + ch) & 256) {
#line 3296
                        *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                      } else {
                        {
#line 3294
                        tmp___74 = __ctype_b_loc();
                        }
#line 3294
                        if ((int const   )*(*tmp___74 + ch) & 512) {
#line 3296
                          *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                        }
                      }
                    }
                  }
#line 3275
                  ch ++;
                }
                while_break___35: /* CIL Label */ ;
                }
#line 3298
                had_char_class = (boolean )1;
              } else {
#line 3217
                goto _L___13;
              }
            } else {
              _L___13: /* CIL Label */ 
#line 3303
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 3304
              while (1) {
                while_continue___36: /* CIL Label */ ;
#line 3304
                tmp___75 = c1;
#line 3304
                c1 = (unsigned char )((int )c1 - 1);
#line 3304
                if (! tmp___75) {
#line 3304
                  goto while_break___36;
                }
#line 3305
                p --;
              }
              while_break___36: /* CIL Label */ ;
              }
#line 3306
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 3307
              *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 2));
#line 3308
              range_start = (unsigned int )':';
#line 3309
              had_char_class = (boolean )0;
            }
          } else {
#line 3191
            goto _L___23;
          }
        } else {
#line 3191
          goto _L___23;
        }
      } else
      _L___23: /* CIL Label */ 
#line 3312
      if (syntax & ((1UL << 1) << 1)) {
#line 3312
        if ((int )c == 91) {
#line 3312
          if ((int const   )*p == 61) {
            {
#line 3320
            while (1) {
              while_continue___37: /* CIL Label */ ;
#line 3320
              if ((unsigned long )p == (unsigned long )pend) {
#line 3320
                return ((reg_errcode_t )14);
              }
#line 3320
              tmp___76 = p;
#line 3320
              p ++;
#line 3320
              c = (unsigned char )*tmp___76;
#line 3320
              if (translate) {
#line 3320
                c = (unsigned char )*(translate + c);
              }
#line 3320
              goto while_break___37;
            }
            while_break___37: /* CIL Label */ ;
            }
#line 3321
            c1 = (unsigned char)0;
#line 3324
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 3324
              free((void *)compile_stack.stack);
              }
#line 3324
              return ((reg_errcode_t )7);
            }
            {
#line 3326
            while (1) {
              while_continue___38: /* CIL Label */ ;
              {
#line 3328
              while (1) {
                while_continue___39: /* CIL Label */ ;
#line 3328
                if ((unsigned long )p == (unsigned long )pend) {
#line 3328
                  return ((reg_errcode_t )14);
                }
#line 3328
                tmp___77 = p;
#line 3328
                p ++;
#line 3328
                c = (unsigned char )*tmp___77;
#line 3328
                if (translate) {
#line 3328
                  c = (unsigned char )*(translate + c);
                }
#line 3328
                goto while_break___39;
              }
              while_break___39: /* CIL Label */ ;
              }
#line 3329
              if ((int )c == 61) {
#line 3329
                if ((int const   )*p == 93) {
#line 3330
                  goto while_break___38;
                } else {
#line 3329
                  goto _L___14;
                }
              } else
              _L___14: /* CIL Label */ 
#line 3329
              if ((unsigned long )p == (unsigned long )pend) {
#line 3330
                goto while_break___38;
              }
#line 3331
              if ((int )c1 < 16) {
#line 3332
                tmp___78 = c1;
#line 3332
                c1 = (unsigned char )((int )c1 + 1);
#line 3332
                str___0[tmp___78] = c;
              } else {
#line 3335
                str___0[0] = (unsigned char )'\000';
              }
            }
            while_break___38: /* CIL Label */ ;
            }
#line 3337
            str___0[c1] = (unsigned char )'\000';
#line 3339
            if ((int )c == 61) {
#line 3339
              if ((int const   )*p == 93) {
#line 3339
                if ((int )str___0[0] != 0) {
#line 3351
                  if ((int )c1 != 1) {
                    {
#line 3352
                    free((void *)compile_stack.stack);
                    }
#line 3352
                    return ((reg_errcode_t )3);
                  }
                  {
#line 3356
                  while (1) {
                    while_continue___40: /* CIL Label */ ;
#line 3356
                    if ((unsigned long )p == (unsigned long )pend) {
#line 3356
                      return ((reg_errcode_t )14);
                    }
#line 3356
                    tmp___79 = p;
#line 3356
                    p ++;
#line 3356
                    c = (unsigned char )*tmp___79;
#line 3356
                    if (translate) {
#line 3356
                      c = (unsigned char )*(translate + c);
                    }
#line 3356
                    goto while_break___40;
                  }
                  while_break___40: /* CIL Label */ ;
                  }
#line 3359
                  *(b + (int )str___0[0] / 8) = (unsigned char )((int )*(b + (int )str___0[0] / 8) | (1 << (int )str___0[0] % 8));
#line 3433
                  had_char_class = (boolean )1;
                } else {
#line 3339
                  goto _L___16;
                }
              } else {
#line 3339
                goto _L___16;
              }
            } else {
              _L___16: /* CIL Label */ 
#line 3437
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 3438
              while (1) {
                while_continue___41: /* CIL Label */ ;
#line 3438
                tmp___80 = c1;
#line 3438
                c1 = (unsigned char )((int )c1 - 1);
#line 3438
                if (! tmp___80) {
#line 3438
                  goto while_break___41;
                }
#line 3439
                p --;
              }
              while_break___41: /* CIL Label */ ;
              }
#line 3440
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 3441
              *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 5));
#line 3442
              range_start = (unsigned int )'=';
#line 3443
              had_char_class = (boolean )0;
            }
          } else {
#line 3312
            goto _L___21;
          }
        } else {
#line 3312
          goto _L___21;
        }
      } else
      _L___21: /* CIL Label */ 
#line 3446
      if (syntax & ((1UL << 1) << 1)) {
#line 3446
        if ((int )c == 91) {
#line 3446
          if ((int const   )*p == 46) {
            {
#line 3454
            while (1) {
              while_continue___42: /* CIL Label */ ;
#line 3454
              if ((unsigned long )p == (unsigned long )pend) {
#line 3454
                return ((reg_errcode_t )14);
              }
#line 3454
              tmp___81 = p;
#line 3454
              p ++;
#line 3454
              c = (unsigned char )*tmp___81;
#line 3454
              if (translate) {
#line 3454
                c = (unsigned char )*(translate + c);
              }
#line 3454
              goto while_break___42;
            }
            while_break___42: /* CIL Label */ ;
            }
#line 3455
            c1 = (unsigned char)0;
#line 3458
            if ((unsigned long )p == (unsigned long )pend) {
              {
#line 3458
              free((void *)compile_stack.stack);
              }
#line 3458
              return ((reg_errcode_t )7);
            }
            {
#line 3460
            while (1) {
              while_continue___43: /* CIL Label */ ;
              {
#line 3462
              while (1) {
                while_continue___44: /* CIL Label */ ;
#line 3462
                if ((unsigned long )p == (unsigned long )pend) {
#line 3462
                  return ((reg_errcode_t )14);
                }
#line 3462
                tmp___82 = p;
#line 3462
                p ++;
#line 3462
                c = (unsigned char )*tmp___82;
#line 3462
                if (translate) {
#line 3462
                  c = (unsigned char )*(translate + c);
                }
#line 3462
                goto while_break___44;
              }
              while_break___44: /* CIL Label */ ;
              }
#line 3463
              if ((int )c == 46) {
#line 3463
                if ((int const   )*p == 93) {
#line 3464
                  goto while_break___43;
                } else {
#line 3463
                  goto _L___17;
                }
              } else
              _L___17: /* CIL Label */ 
#line 3463
              if ((unsigned long )p == (unsigned long )pend) {
#line 3464
                goto while_break___43;
              }
#line 3465
              if ((unsigned long )c1 < sizeof(str___1)) {
#line 3466
                tmp___83 = c1;
#line 3466
                c1 = (unsigned char )((int )c1 + 1);
#line 3466
                str___1[tmp___83] = c;
              } else {
#line 3469
                str___1[0] = (unsigned char )'\000';
              }
            }
            while_break___43: /* CIL Label */ ;
            }
#line 3471
            str___1[c1] = (unsigned char )'\000';
#line 3473
            if ((int )c == 46) {
#line 3473
              if ((int const   )*p == 93) {
#line 3473
                if ((int )str___1[0] != 0) {
#line 3486
                  if ((int )c1 != 1) {
                    {
#line 3487
                    free((void *)compile_stack.stack);
                    }
#line 3487
                    return ((reg_errcode_t )3);
                  }
                  {
#line 3491
                  while (1) {
                    while_continue___45: /* CIL Label */ ;
#line 3491
                    if ((unsigned long )p == (unsigned long )pend) {
#line 3491
                      return ((reg_errcode_t )14);
                    }
#line 3491
                    tmp___84 = p;
#line 3491
                    p ++;
#line 3491
                    c = (unsigned char )*tmp___84;
#line 3491
                    if (translate) {
#line 3491
                      c = (unsigned char )*(translate + c);
                    }
#line 3491
                    goto while_break___45;
                  }
                  while_break___45: /* CIL Label */ ;
                  }
#line 3494
                  *(b + (int )str___1[0] / 8) = (unsigned char )((int )*(b + (int )str___1[0] / 8) | (1 << (int )str___1[0] % 8));
#line 3495
                  range_start = (unsigned int )*((unsigned char const   *)(str___1) + 0);
#line 3576
                  had_char_class = (boolean )0;
                } else {
#line 3473
                  goto _L___19;
                }
              } else {
#line 3473
                goto _L___19;
              }
            } else {
              _L___19: /* CIL Label */ 
#line 3580
              c1 = (unsigned char )((int )c1 + 1);
              {
#line 3581
              while (1) {
                while_continue___46: /* CIL Label */ ;
#line 3581
                tmp___85 = c1;
#line 3581
                c1 = (unsigned char )((int )c1 - 1);
#line 3581
                if (! tmp___85) {
#line 3581
                  goto while_break___46;
                }
#line 3582
                p --;
              }
              while_break___46: /* CIL Label */ ;
              }
#line 3583
              *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
#line 3584
              *(b + 5) = (unsigned char )((int )*(b + 5) | (1 << 6));
#line 3585
              range_start = (unsigned int )'.';
#line 3586
              had_char_class = (boolean )0;
            }
          } else {
#line 3591
            had_char_class = (boolean )0;
#line 3592
            *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
#line 3593
            range_start = (unsigned int )c;
          }
        } else {
#line 3591
          had_char_class = (boolean )0;
#line 3592
          *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
#line 3593
          range_start = (unsigned int )c;
        }
      } else {
#line 3591
        had_char_class = (boolean )0;
#line 3592
        *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
#line 3593
        range_start = (unsigned int )c;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 3599
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 3599
      if ((int )*(b + -1) > 0) {
#line 3599
        if (! ((int )*(b + ((int )*(b + -1) - 1)) == 0)) {
#line 3599
          goto while_break___47;
        }
      } else {
#line 3599
        goto while_break___47;
      }
#line 3600
      *(b + -1) = (unsigned char )((int )*(b + -1) - 1);
    }
    while_break___47: /* CIL Label */ ;
    }
#line 3601
    b += (int )*(b + -1);
#line 3604
    goto switch_break;
    case_40: /* CIL Label */ 
#line 3608
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3609
      goto handle_open;
    } else {
#line 3611
      goto normal_char;
    }
    case_41: /* CIL Label */ 
#line 3615
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3616
      goto handle_close;
    } else {
#line 3618
      goto normal_char;
    }
    case_10: /* CIL Label */ 
#line 3622
    if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3623
      goto handle_alt;
    } else {
#line 3625
      goto normal_char;
    }
    case_124: /* CIL Label */ 
#line 3629
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3630
      goto handle_alt;
    } else {
#line 3632
      goto normal_char;
    }
    case_123: /* CIL Label */ 
#line 3636
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3636
      if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3637
        goto handle_interval;
      } else {
#line 3639
        goto normal_char;
      }
    } else {
#line 3639
      goto normal_char;
    }
    case_92: /* CIL Label */ 
#line 3643
    if ((unsigned long )p == (unsigned long )pend) {
      {
#line 3643
      free((void *)compile_stack.stack);
      }
#line 3643
      return ((reg_errcode_t )5);
    }
    {
#line 3648
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 3648
      if ((unsigned long )p == (unsigned long )pend) {
#line 3648
        return ((reg_errcode_t )14);
      }
#line 3648
      tmp___86 = p;
#line 3648
      p ++;
#line 3648
      c = (unsigned char )*tmp___86;
#line 3648
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 3652
    if ((int )c == 40) {
#line 3652
      goto case_40___0;
    }
#line 3702
    if ((int )c == 41) {
#line 3702
      goto case_41___0;
    }
#line 3772
    if ((int )c == 124) {
#line 3772
      goto case_124___0;
    }
#line 3818
    if ((int )c == 123) {
#line 3818
      goto case_123___0;
    }
#line 4004
    if ((int )c == 119) {
#line 4004
      goto case_119;
    }
#line 4012
    if ((int )c == 87) {
#line 4012
      goto case_87;
    }
#line 4020
    if ((int )c == 60) {
#line 4020
      goto case_60;
    }
#line 4026
    if ((int )c == 62) {
#line 4026
      goto case_62;
    }
#line 4032
    if ((int )c == 98) {
#line 4032
      goto case_98;
    }
#line 4038
    if ((int )c == 66) {
#line 4038
      goto case_66;
    }
#line 4044
    if ((int )c == 96) {
#line 4044
      goto case_96;
    }
#line 4050
    if ((int )c == 39) {
#line 4050
      goto case_39;
    }
#line 4057
    if ((int )c == 57) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 56) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 55) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 54) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 53) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 52) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 51) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 50) {
#line 4057
      goto case_57;
    }
#line 4057
    if ((int )c == 49) {
#line 4057
      goto case_57;
    }
#line 4076
    if ((int )c == 63) {
#line 4076
      goto case_63___0;
    }
#line 4076
    if ((int )c == 43) {
#line 4076
      goto case_63___0;
    }
#line 4082
    goto normal_backslash;
    case_40___0: /* CIL Label */ 
#line 3653
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3654
      goto normal_backslash;
    }
    handle_open: 
#line 3657
    (bufp->re_nsub) ++;
#line 3658
    regnum ++;
#line 3660
    if (compile_stack.avail == compile_stack.size) {
      {
#line 3662
      tmp___87 = realloc((void *)compile_stack.stack, (unsigned long )(compile_stack.size << 1) * sizeof(compile_stack_elt_t ));
#line 3662
      compile_stack.stack = (compile_stack_elt_t *)tmp___87;
      }
#line 3664
      if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
#line 3664
        return ((reg_errcode_t )12);
      }
#line 3666
      compile_stack.size <<= 1;
    }
#line 3673
    (compile_stack.stack + compile_stack.avail)->begalt_offset = begalt - bufp->buffer;
#line 3674
    if (fixup_alt_jump) {
#line 3674
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (fixup_alt_jump - bufp->buffer) + 1L;
    } else {
#line 3674
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (pattern_offset_t )0;
    }
#line 3676
    (compile_stack.stack + compile_stack.avail)->laststart_offset = b - bufp->buffer;
#line 3677
    (compile_stack.stack + compile_stack.avail)->regnum = regnum;
#line 3683
    if (regnum <= 255U) {
#line 3685
      (compile_stack.stack + compile_stack.avail)->inner_group_offset = (b - bufp->buffer) + 2L;
      {
#line 3687
      while (1) {
        while_continue___49: /* CIL Label */ ;
        {
#line 3687
        while (1) {
          while_continue___50: /* CIL Label */ ;
#line 3687
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3687
            goto while_break___50;
          }
          {
#line 3687
          while (1) {
            while_continue___51: /* CIL Label */ ;
#line 3687
            old_buffer___8 = bufp->buffer;
#line 3687
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3687
              return ((reg_errcode_t )15);
            }
#line 3687
            bufp->allocated <<= 1;
#line 3687
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3687
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 3687
            tmp___88 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3687
            bufp->buffer = (unsigned char *)tmp___88;
            }
#line 3687
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3687
              return ((reg_errcode_t )12);
            }
#line 3687
            if ((unsigned long )old_buffer___8 != (unsigned long )bufp->buffer) {
#line 3687
              incr___8 = (int )(bufp->buffer - old_buffer___8);
#line 3687
              b += incr___8;
#line 3687
              begalt += incr___8;
#line 3687
              if (fixup_alt_jump) {
#line 3687
                fixup_alt_jump += incr___8;
              }
#line 3687
              if (laststart) {
#line 3687
                laststart += incr___8;
              }
#line 3687
              if (pending_exact) {
#line 3687
                pending_exact += incr___8;
              }
            }
#line 3687
            goto while_break___51;
          }
          while_break___51: /* CIL Label */ ;
          }
        }
        while_break___50: /* CIL Label */ ;
        }
#line 3687
        tmp___89 = b;
#line 3687
        b ++;
#line 3687
        *tmp___89 = (unsigned char)6;
#line 3687
        tmp___90 = b;
#line 3687
        b ++;
#line 3687
        *tmp___90 = (unsigned char )regnum;
#line 3687
        tmp___91 = b;
#line 3687
        b ++;
#line 3687
        *tmp___91 = (unsigned char)0;
#line 3687
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
    }
#line 3690
    (compile_stack.avail) ++;
#line 3692
    fixup_alt_jump = (unsigned char *)0;
#line 3693
    laststart = (unsigned char *)0;
#line 3694
    begalt = b;
#line 3698
    pending_exact = (unsigned char *)0;
#line 3699
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
#line 3703
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3703
      goto normal_backslash;
    }
#line 3705
    if (compile_stack.avail == 0U) {
#line 3707
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3708
        goto normal_backslash;
      } else {
        {
#line 3710
        free((void *)compile_stack.stack);
        }
#line 3710
        return ((reg_errcode_t )16);
      }
    }
    handle_close: 
#line 3714
    if (fixup_alt_jump) {
      {
#line 3719
      while (1) {
        while_continue___52: /* CIL Label */ ;
        {
#line 3719
        while (1) {
          while_continue___53: /* CIL Label */ ;
#line 3719
          if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 3719
            goto while_break___53;
          }
          {
#line 3719
          while (1) {
            while_continue___54: /* CIL Label */ ;
#line 3719
            old_buffer___9 = bufp->buffer;
#line 3719
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3719
              return ((reg_errcode_t )15);
            }
#line 3719
            bufp->allocated <<= 1;
#line 3719
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3719
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 3719
            tmp___92 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3719
            bufp->buffer = (unsigned char *)tmp___92;
            }
#line 3719
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3719
              return ((reg_errcode_t )12);
            }
#line 3719
            if ((unsigned long )old_buffer___9 != (unsigned long )bufp->buffer) {
#line 3719
              incr___9 = (int )(bufp->buffer - old_buffer___9);
#line 3719
              b += incr___9;
#line 3719
              begalt += incr___9;
#line 3719
              if (fixup_alt_jump) {
#line 3719
                fixup_alt_jump += incr___9;
              }
#line 3719
              if (laststart) {
#line 3719
                laststart += incr___9;
              }
#line 3719
              if (pending_exact) {
#line 3719
                pending_exact += incr___9;
              }
            }
#line 3719
            goto while_break___54;
          }
          while_break___54: /* CIL Label */ ;
          }
        }
        while_break___53: /* CIL Label */ ;
        }
#line 3719
        tmp___93 = b;
#line 3719
        b ++;
#line 3719
        *tmp___93 = (unsigned char)20;
#line 3719
        goto while_break___52;
      }
      while_break___52: /* CIL Label */ ;
      }
      {
#line 3723
      byte_store_op1((re_opcode_t )14, fixup_alt_jump, (int )(((b - 1) - fixup_alt_jump) - 3L));
      }
    }
#line 3727
    if (compile_stack.avail == 0U) {
#line 3729
      if (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3730
        goto normal_char;
      } else {
        {
#line 3732
        free((void *)compile_stack.stack);
        }
#line 3732
        return ((reg_errcode_t )16);
      }
    }
#line 3744
    (compile_stack.avail) --;
#line 3745
    begalt = bufp->buffer + (compile_stack.stack + compile_stack.avail)->begalt_offset;
#line 3746
    if ((compile_stack.stack + compile_stack.avail)->fixup_alt_jump) {
#line 3746
      fixup_alt_jump = (bufp->buffer + (compile_stack.stack + compile_stack.avail)->fixup_alt_jump) - 1;
    } else {
#line 3746
      fixup_alt_jump = (unsigned char *)0;
    }
#line 3750
    laststart = bufp->buffer + (compile_stack.stack + compile_stack.avail)->laststart_offset;
#line 3751
    this_group_regnum = (compile_stack.stack + compile_stack.avail)->regnum;
#line 3755
    pending_exact = (unsigned char *)0;
#line 3759
    if (this_group_regnum <= 255U) {
#line 3761
      inner_group_loc = bufp->buffer + (compile_stack.stack + compile_stack.avail)->inner_group_offset;
#line 3764
      *inner_group_loc = (unsigned char )(regnum - this_group_regnum);
      {
#line 3765
      while (1) {
        while_continue___55: /* CIL Label */ ;
        {
#line 3765
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 3765
          if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3765
            goto while_break___56;
          }
          {
#line 3765
          while (1) {
            while_continue___57: /* CIL Label */ ;
#line 3765
            old_buffer___10 = bufp->buffer;
#line 3765
            if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3765
              return ((reg_errcode_t )15);
            }
#line 3765
            bufp->allocated <<= 1;
#line 3765
            if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3765
              bufp->allocated = (unsigned long )(1L << 16);
            }
            {
#line 3765
            tmp___94 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3765
            bufp->buffer = (unsigned char *)tmp___94;
            }
#line 3765
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3765
              return ((reg_errcode_t )12);
            }
#line 3765
            if ((unsigned long )old_buffer___10 != (unsigned long )bufp->buffer) {
#line 3765
              incr___10 = (int )(bufp->buffer - old_buffer___10);
#line 3765
              b += incr___10;
#line 3765
              begalt += incr___10;
#line 3765
              if (fixup_alt_jump) {
#line 3765
                fixup_alt_jump += incr___10;
              }
#line 3765
              if (laststart) {
#line 3765
                laststart += incr___10;
              }
#line 3765
              if (pending_exact) {
#line 3765
                pending_exact += incr___10;
              }
            }
#line 3765
            goto while_break___57;
          }
          while_break___57: /* CIL Label */ ;
          }
        }
        while_break___56: /* CIL Label */ ;
        }
#line 3765
        tmp___95 = b;
#line 3765
        b ++;
#line 3765
        *tmp___95 = (unsigned char)7;
#line 3765
        tmp___96 = b;
#line 3765
        b ++;
#line 3765
        *tmp___96 = (unsigned char )this_group_regnum;
#line 3765
        tmp___97 = b;
#line 3765
        b ++;
#line 3765
        *tmp___97 = (unsigned char )(regnum - this_group_regnum);
#line 3765
        goto while_break___55;
      }
      while_break___55: /* CIL Label */ ;
      }
    }
#line 3769
    goto switch_break___0;
    case_124___0: /* CIL Label */ 
#line 3773
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3774
      goto normal_backslash;
    } else
#line 3773
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3774
      goto normal_backslash;
    }
    handle_alt: 
#line 3776
    if (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3777
      goto normal_char;
    }
    {
#line 3781
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 3781
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3781
        goto while_break___58;
      }
      {
#line 3781
      while (1) {
        while_continue___59: /* CIL Label */ ;
#line 3781
        old_buffer___11 = bufp->buffer;
#line 3781
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3781
          return ((reg_errcode_t )15);
        }
#line 3781
        bufp->allocated <<= 1;
#line 3781
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3781
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 3781
        tmp___98 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3781
        bufp->buffer = (unsigned char *)tmp___98;
        }
#line 3781
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3781
          return ((reg_errcode_t )12);
        }
#line 3781
        if ((unsigned long )old_buffer___11 != (unsigned long )bufp->buffer) {
#line 3781
          incr___11 = (int )(bufp->buffer - old_buffer___11);
#line 3781
          b += incr___11;
#line 3781
          begalt += incr___11;
#line 3781
          if (fixup_alt_jump) {
#line 3781
            fixup_alt_jump += incr___11;
          }
#line 3781
          if (laststart) {
#line 3781
            laststart += incr___11;
          }
#line 3781
          if (pending_exact) {
#line 3781
            pending_exact += incr___11;
          }
        }
#line 3781
        goto while_break___59;
      }
      while_break___59: /* CIL Label */ ;
      }
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 3782
    byte_insert_op1((re_opcode_t )15, begalt, (int )((((b + 2) + 4) - begalt) - 3L),
                    b);
#line 3784
    pending_exact = (unsigned char *)0;
#line 3785
    b += 3;
    }
#line 3803
    if (fixup_alt_jump) {
      {
#line 3804
      byte_store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
      }
    }
#line 3809
    fixup_alt_jump = b;
    {
#line 3810
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 3810
      if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3810
        goto while_break___60;
      }
      {
#line 3810
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 3810
        old_buffer___12 = bufp->buffer;
#line 3810
        if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3810
          return ((reg_errcode_t )15);
        }
#line 3810
        bufp->allocated <<= 1;
#line 3810
        if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3810
          bufp->allocated = (unsigned long )(1L << 16);
        }
        {
#line 3810
        tmp___99 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3810
        bufp->buffer = (unsigned char *)tmp___99;
        }
#line 3810
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3810
          return ((reg_errcode_t )12);
        }
#line 3810
        if ((unsigned long )old_buffer___12 != (unsigned long )bufp->buffer) {
#line 3810
          incr___12 = (int )(bufp->buffer - old_buffer___12);
#line 3810
          b += incr___12;
#line 3810
          begalt += incr___12;
#line 3810
          if (fixup_alt_jump) {
#line 3810
            fixup_alt_jump += incr___12;
          }
#line 3810
          if (laststart) {
#line 3810
            laststart += incr___12;
          }
#line 3810
          if (pending_exact) {
#line 3810
            pending_exact += incr___12;
          }
        }
#line 3810
        goto while_break___61;
      }
      while_break___61: /* CIL Label */ ;
      }
    }
    while_break___60: /* CIL Label */ ;
    }
#line 3811
    b += 3;
#line 3813
    laststart = (unsigned char *)0;
#line 3814
    begalt = b;
#line 3815
    goto switch_break___0;
    case_123___0: /* CIL Label */ 
#line 3820
    if (! (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3824
      goto normal_backslash;
    } else
#line 3820
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3824
      goto normal_backslash;
    }
    handle_interval: 
#line 3831
    lower_bound = -1;
#line 3831
    upper_bound = -1;
#line 3835
    beg_interval = p;
#line 3837
    if ((unsigned long )p == (unsigned long )pend) {
#line 3838
      goto invalid_interval;
    }
    {
#line 3840
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 3840
      if (! ((unsigned long )p != (unsigned long )pend)) {
#line 3840
        goto while_break___62;
      }
      {
#line 3840
      while (1) {
        while_continue___63: /* CIL Label */ ;
#line 3840
        if ((unsigned long )p == (unsigned long )pend) {
#line 3840
          return ((reg_errcode_t )14);
        }
#line 3840
        tmp___100 = p;
#line 3840
        p ++;
#line 3840
        c = (unsigned char )*tmp___100;
#line 3840
        if (translate) {
#line 3840
          c = (unsigned char )*(translate + c);
        }
#line 3840
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
#line 3840
      if ((int )c < 48) {
#line 3840
        goto while_break___62;
      } else
#line 3840
      if ((int )c > 57) {
#line 3840
        goto while_break___62;
      }
#line 3840
      if (lower_bound <= 32767) {
#line 3840
        if (lower_bound < 0) {
#line 3840
          lower_bound = 0;
        }
#line 3840
        lower_bound = (lower_bound * 10 + (int )c) - 48;
      }
    }
    while_break___62: /* CIL Label */ ;
    }
#line 3842
    if ((int )c == 44) {
      {
#line 3844
      while (1) {
        while_continue___64: /* CIL Label */ ;
#line 3844
        if (! ((unsigned long )p != (unsigned long )pend)) {
#line 3844
          goto while_break___64;
        }
        {
#line 3844
        while (1) {
          while_continue___65: /* CIL Label */ ;
#line 3844
          if ((unsigned long )p == (unsigned long )pend) {
#line 3844
            return ((reg_errcode_t )14);
          }
#line 3844
          tmp___101 = p;
#line 3844
          p ++;
#line 3844
          c = (unsigned char )*tmp___101;
#line 3844
          if (translate) {
#line 3844
            c = (unsigned char )*(translate + c);
          }
#line 3844
          goto while_break___65;
        }
        while_break___65: /* CIL Label */ ;
        }
#line 3844
        if ((int )c < 48) {
#line 3844
          goto while_break___64;
        } else
#line 3844
        if ((int )c > 57) {
#line 3844
          goto while_break___64;
        }
#line 3844
        if (upper_bound <= 32767) {
#line 3844
          if (upper_bound < 0) {
#line 3844
            upper_bound = 0;
          }
#line 3844
          upper_bound = (upper_bound * 10 + (int )c) - 48;
        }
      }
      while_break___64: /* CIL Label */ ;
      }
#line 3845
      if (upper_bound < 0) {
#line 3846
        upper_bound = 32767;
      }
    } else {
#line 3850
      upper_bound = lower_bound;
    }
#line 3852
    if (0 <= lower_bound) {
#line 3852
      if (! (lower_bound <= upper_bound)) {
#line 3853
        goto invalid_interval;
      }
    } else {
#line 3853
      goto invalid_interval;
    }
#line 3855
    if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3857
      if ((int )c != 92) {
#line 3858
        goto invalid_interval;
      } else
#line 3857
      if ((unsigned long )p == (unsigned long )pend) {
#line 3858
        goto invalid_interval;
      }
      {
#line 3859
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 3859
        if ((unsigned long )p == (unsigned long )pend) {
#line 3859
          return ((reg_errcode_t )14);
        }
#line 3859
        tmp___102 = p;
#line 3859
        p ++;
#line 3859
        c = (unsigned char )*tmp___102;
#line 3859
        if (translate) {
#line 3859
          c = (unsigned char )*(translate + c);
        }
#line 3859
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
    }
#line 3862
    if ((int )c != 125) {
#line 3863
      goto invalid_interval;
    }
#line 3866
    if (! laststart) {
#line 3868
      if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 3868
        if (! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 3870
          free((void *)compile_stack.stack);
          }
#line 3870
          return ((reg_errcode_t )13);
        } else {
#line 3868
          goto _L___31;
        }
      } else
      _L___31: /* CIL Label */ 
#line 3871
      if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
#line 3872
        laststart = b;
      } else {
#line 3874
        goto unfetch_interval;
      }
    }
#line 3879
    if (32767 < upper_bound) {
      {
#line 3880
      free((void *)compile_stack.stack);
      }
#line 3880
      return ((reg_errcode_t )10);
    }
#line 3887
    if (upper_bound == 0) {
      {
#line 3889
      while (1) {
        while_continue___67: /* CIL Label */ ;
#line 3889
        if (! ((unsigned long )((b - bufp->buffer) + 3L) > bufp->allocated)) {
#line 3889
          goto while_break___67;
        }
        {
#line 3889
        while (1) {
          while_continue___68: /* CIL Label */ ;
#line 3889
          old_buffer___13 = bufp->buffer;
#line 3889
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3889
            return ((reg_errcode_t )15);
          }
#line 3889
          bufp->allocated <<= 1;
#line 3889
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3889
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3889
          tmp___103 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3889
          bufp->buffer = (unsigned char *)tmp___103;
          }
#line 3889
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3889
            return ((reg_errcode_t )12);
          }
#line 3889
          if ((unsigned long )old_buffer___13 != (unsigned long )bufp->buffer) {
#line 3889
            incr___13 = (int )(bufp->buffer - old_buffer___13);
#line 3889
            b += incr___13;
#line 3889
            begalt += incr___13;
#line 3889
            if (fixup_alt_jump) {
#line 3889
              fixup_alt_jump += incr___13;
            }
#line 3889
            if (laststart) {
#line 3889
              laststart += incr___13;
            }
#line 3889
            if (pending_exact) {
#line 3889
              pending_exact += incr___13;
            }
          }
#line 3889
          goto while_break___68;
        }
        while_break___68: /* CIL Label */ ;
        }
      }
      while_break___67: /* CIL Label */ ;
      }
      {
#line 3890
      byte_insert_op1((re_opcode_t )13, laststart, (int )((((b + 1) + 2) - laststart) - 3L),
                      b);
#line 3892
      b += 3;
      }
    } else {
#line 3907
      nbytes = (unsigned int )(10 + (upper_bound > 1) * 10);
      {
#line 3910
      while (1) {
        while_continue___69: /* CIL Label */ ;
#line 3910
        if (! ((unsigned long )((b - bufp->buffer) + (long )nbytes) > bufp->allocated)) {
#line 3910
          goto while_break___69;
        }
        {
#line 3910
        while (1) {
          while_continue___70: /* CIL Label */ ;
#line 3910
          old_buffer___14 = bufp->buffer;
#line 3910
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 3910
            return ((reg_errcode_t )15);
          }
#line 3910
          bufp->allocated <<= 1;
#line 3910
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 3910
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 3910
          tmp___104 = realloc((void *)bufp->buffer, bufp->allocated);
#line 3910
          bufp->buffer = (unsigned char *)tmp___104;
          }
#line 3910
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 3910
            return ((reg_errcode_t )12);
          }
#line 3910
          if ((unsigned long )old_buffer___14 != (unsigned long )bufp->buffer) {
#line 3910
            incr___14 = (int )(bufp->buffer - old_buffer___14);
#line 3910
            b += incr___14;
#line 3910
            begalt += incr___14;
#line 3910
            if (fixup_alt_jump) {
#line 3910
              fixup_alt_jump += incr___14;
            }
#line 3910
            if (laststart) {
#line 3910
              laststart += incr___14;
            }
#line 3910
            if (pending_exact) {
#line 3910
              pending_exact += incr___14;
            }
          }
#line 3910
          goto while_break___70;
        }
        while_break___70: /* CIL Label */ ;
        }
      }
      while_break___69: /* CIL Label */ ;
      }
      {
#line 3917
      byte_insert_op2((re_opcode_t )21, laststart, (int )(((((b + 1) + 4) + (upper_bound > 1) * 5) - laststart) - 3L),
                      lower_bound, b);
#line 3921
      b += 5;
#line 3930
      byte_insert_op2((re_opcode_t )23, laststart, 5, lower_bound, b);
#line 3932
      b += 5;
      }
#line 3934
      if (upper_bound > 1) {
        {
#line 3942
        byte_store_op2((re_opcode_t )22, b, (int )((((laststart + 4) + 1) - b) - 3L),
                       upper_bound - 1);
#line 3945
        b += 5;
#line 3961
        byte_insert_op2((re_opcode_t )23, laststart, (int )(b - laststart), upper_bound - 1,
                        b);
#line 3964
        b += 5;
        }
      }
    }
#line 3967
    pending_exact = (unsigned char *)0;
#line 3968
    goto switch_break___0;
    invalid_interval: 
#line 3971
    if (! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      {
#line 3972
      free((void *)compile_stack.stack);
      }
#line 3972
      if ((unsigned long )p == (unsigned long )pend) {
#line 3972
        tmp___105 = 9;
      } else {
#line 3972
        tmp___105 = 10;
      }
#line 3972
      return ((reg_errcode_t )tmp___105);
    }
    unfetch_interval: 
#line 3975
    p = beg_interval;
#line 3976
    c = (unsigned char )'{';
#line 3977
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3978
      goto normal_char;
    } else {
#line 3980
      goto normal_backslash;
    }
    case_119: /* CIL Label */ 
#line 4005
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4006
      goto normal_char;
    }
#line 4007
    laststart = b;
    {
#line 4008
    while (1) {
      while_continue___71: /* CIL Label */ ;
      {
#line 4008
      while (1) {
        while_continue___72: /* CIL Label */ ;
#line 4008
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4008
          goto while_break___72;
        }
        {
#line 4008
        while (1) {
          while_continue___73: /* CIL Label */ ;
#line 4008
          old_buffer___15 = bufp->buffer;
#line 4008
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4008
            return ((reg_errcode_t )15);
          }
#line 4008
          bufp->allocated <<= 1;
#line 4008
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4008
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4008
          tmp___106 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4008
          bufp->buffer = (unsigned char *)tmp___106;
          }
#line 4008
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4008
            return ((reg_errcode_t )12);
          }
#line 4008
          if ((unsigned long )old_buffer___15 != (unsigned long )bufp->buffer) {
#line 4008
            incr___15 = (int )(bufp->buffer - old_buffer___15);
#line 4008
            b += incr___15;
#line 4008
            begalt += incr___15;
#line 4008
            if (fixup_alt_jump) {
#line 4008
              fixup_alt_jump += incr___15;
            }
#line 4008
            if (laststart) {
#line 4008
              laststart += incr___15;
            }
#line 4008
            if (pending_exact) {
#line 4008
              pending_exact += incr___15;
            }
          }
#line 4008
          goto while_break___73;
        }
        while_break___73: /* CIL Label */ ;
        }
      }
      while_break___72: /* CIL Label */ ;
      }
#line 4008
      tmp___107 = b;
#line 4008
      b ++;
#line 4008
      *tmp___107 = (unsigned char)24;
#line 4008
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 4009
    goto switch_break___0;
    case_87: /* CIL Label */ 
#line 4013
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4014
      goto normal_char;
    }
#line 4015
    laststart = b;
    {
#line 4016
    while (1) {
      while_continue___74: /* CIL Label */ ;
      {
#line 4016
      while (1) {
        while_continue___75: /* CIL Label */ ;
#line 4016
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4016
          goto while_break___75;
        }
        {
#line 4016
        while (1) {
          while_continue___76: /* CIL Label */ ;
#line 4016
          old_buffer___16 = bufp->buffer;
#line 4016
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4016
            return ((reg_errcode_t )15);
          }
#line 4016
          bufp->allocated <<= 1;
#line 4016
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4016
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4016
          tmp___108 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4016
          bufp->buffer = (unsigned char *)tmp___108;
          }
#line 4016
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4016
            return ((reg_errcode_t )12);
          }
#line 4016
          if ((unsigned long )old_buffer___16 != (unsigned long )bufp->buffer) {
#line 4016
            incr___16 = (int )(bufp->buffer - old_buffer___16);
#line 4016
            b += incr___16;
#line 4016
            begalt += incr___16;
#line 4016
            if (fixup_alt_jump) {
#line 4016
              fixup_alt_jump += incr___16;
            }
#line 4016
            if (laststart) {
#line 4016
              laststart += incr___16;
            }
#line 4016
            if (pending_exact) {
#line 4016
              pending_exact += incr___16;
            }
          }
#line 4016
          goto while_break___76;
        }
        while_break___76: /* CIL Label */ ;
        }
      }
      while_break___75: /* CIL Label */ ;
      }
#line 4016
      tmp___109 = b;
#line 4016
      b ++;
#line 4016
      *tmp___109 = (unsigned char)25;
#line 4016
      goto while_break___74;
    }
    while_break___74: /* CIL Label */ ;
    }
#line 4017
    goto switch_break___0;
    case_60: /* CIL Label */ 
#line 4021
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4022
      goto normal_char;
    }
    {
#line 4023
    while (1) {
      while_continue___77: /* CIL Label */ ;
      {
#line 4023
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 4023
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4023
          goto while_break___78;
        }
        {
#line 4023
        while (1) {
          while_continue___79: /* CIL Label */ ;
#line 4023
          old_buffer___17 = bufp->buffer;
#line 4023
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4023
            return ((reg_errcode_t )15);
          }
#line 4023
          bufp->allocated <<= 1;
#line 4023
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4023
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4023
          tmp___110 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4023
          bufp->buffer = (unsigned char *)tmp___110;
          }
#line 4023
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4023
            return ((reg_errcode_t )12);
          }
#line 4023
          if ((unsigned long )old_buffer___17 != (unsigned long )bufp->buffer) {
#line 4023
            incr___17 = (int )(bufp->buffer - old_buffer___17);
#line 4023
            b += incr___17;
#line 4023
            begalt += incr___17;
#line 4023
            if (fixup_alt_jump) {
#line 4023
              fixup_alt_jump += incr___17;
            }
#line 4023
            if (laststart) {
#line 4023
              laststart += incr___17;
            }
#line 4023
            if (pending_exact) {
#line 4023
              pending_exact += incr___17;
            }
          }
#line 4023
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
      }
      while_break___78: /* CIL Label */ ;
      }
#line 4023
      tmp___111 = b;
#line 4023
      b ++;
#line 4023
      *tmp___111 = (unsigned char)26;
#line 4023
      goto while_break___77;
    }
    while_break___77: /* CIL Label */ ;
    }
#line 4024
    goto switch_break___0;
    case_62: /* CIL Label */ 
#line 4027
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4028
      goto normal_char;
    }
    {
#line 4029
    while (1) {
      while_continue___80: /* CIL Label */ ;
      {
#line 4029
      while (1) {
        while_continue___81: /* CIL Label */ ;
#line 4029
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4029
          goto while_break___81;
        }
        {
#line 4029
        while (1) {
          while_continue___82: /* CIL Label */ ;
#line 4029
          old_buffer___18 = bufp->buffer;
#line 4029
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4029
            return ((reg_errcode_t )15);
          }
#line 4029
          bufp->allocated <<= 1;
#line 4029
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4029
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4029
          tmp___112 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4029
          bufp->buffer = (unsigned char *)tmp___112;
          }
#line 4029
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4029
            return ((reg_errcode_t )12);
          }
#line 4029
          if ((unsigned long )old_buffer___18 != (unsigned long )bufp->buffer) {
#line 4029
            incr___18 = (int )(bufp->buffer - old_buffer___18);
#line 4029
            b += incr___18;
#line 4029
            begalt += incr___18;
#line 4029
            if (fixup_alt_jump) {
#line 4029
              fixup_alt_jump += incr___18;
            }
#line 4029
            if (laststart) {
#line 4029
              laststart += incr___18;
            }
#line 4029
            if (pending_exact) {
#line 4029
              pending_exact += incr___18;
            }
          }
#line 4029
          goto while_break___82;
        }
        while_break___82: /* CIL Label */ ;
        }
      }
      while_break___81: /* CIL Label */ ;
      }
#line 4029
      tmp___113 = b;
#line 4029
      b ++;
#line 4029
      *tmp___113 = (unsigned char)27;
#line 4029
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
#line 4030
    goto switch_break___0;
    case_98: /* CIL Label */ 
#line 4033
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4034
      goto normal_char;
    }
    {
#line 4035
    while (1) {
      while_continue___83: /* CIL Label */ ;
      {
#line 4035
      while (1) {
        while_continue___84: /* CIL Label */ ;
#line 4035
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4035
          goto while_break___84;
        }
        {
#line 4035
        while (1) {
          while_continue___85: /* CIL Label */ ;
#line 4035
          old_buffer___19 = bufp->buffer;
#line 4035
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4035
            return ((reg_errcode_t )15);
          }
#line 4035
          bufp->allocated <<= 1;
#line 4035
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4035
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4035
          tmp___114 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4035
          bufp->buffer = (unsigned char *)tmp___114;
          }
#line 4035
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4035
            return ((reg_errcode_t )12);
          }
#line 4035
          if ((unsigned long )old_buffer___19 != (unsigned long )bufp->buffer) {
#line 4035
            incr___19 = (int )(bufp->buffer - old_buffer___19);
#line 4035
            b += incr___19;
#line 4035
            begalt += incr___19;
#line 4035
            if (fixup_alt_jump) {
#line 4035
              fixup_alt_jump += incr___19;
            }
#line 4035
            if (laststart) {
#line 4035
              laststart += incr___19;
            }
#line 4035
            if (pending_exact) {
#line 4035
              pending_exact += incr___19;
            }
          }
#line 4035
          goto while_break___85;
        }
        while_break___85: /* CIL Label */ ;
        }
      }
      while_break___84: /* CIL Label */ ;
      }
#line 4035
      tmp___115 = b;
#line 4035
      b ++;
#line 4035
      *tmp___115 = (unsigned char)28;
#line 4035
      goto while_break___83;
    }
    while_break___83: /* CIL Label */ ;
    }
#line 4036
    goto switch_break___0;
    case_66: /* CIL Label */ 
#line 4039
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4040
      goto normal_char;
    }
    {
#line 4041
    while (1) {
      while_continue___86: /* CIL Label */ ;
      {
#line 4041
      while (1) {
        while_continue___87: /* CIL Label */ ;
#line 4041
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4041
          goto while_break___87;
        }
        {
#line 4041
        while (1) {
          while_continue___88: /* CIL Label */ ;
#line 4041
          old_buffer___20 = bufp->buffer;
#line 4041
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4041
            return ((reg_errcode_t )15);
          }
#line 4041
          bufp->allocated <<= 1;
#line 4041
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4041
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4041
          tmp___116 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4041
          bufp->buffer = (unsigned char *)tmp___116;
          }
#line 4041
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4041
            return ((reg_errcode_t )12);
          }
#line 4041
          if ((unsigned long )old_buffer___20 != (unsigned long )bufp->buffer) {
#line 4041
            incr___20 = (int )(bufp->buffer - old_buffer___20);
#line 4041
            b += incr___20;
#line 4041
            begalt += incr___20;
#line 4041
            if (fixup_alt_jump) {
#line 4041
              fixup_alt_jump += incr___20;
            }
#line 4041
            if (laststart) {
#line 4041
              laststart += incr___20;
            }
#line 4041
            if (pending_exact) {
#line 4041
              pending_exact += incr___20;
            }
          }
#line 4041
          goto while_break___88;
        }
        while_break___88: /* CIL Label */ ;
        }
      }
      while_break___87: /* CIL Label */ ;
      }
#line 4041
      tmp___117 = b;
#line 4041
      b ++;
#line 4041
      *tmp___117 = (unsigned char)29;
#line 4041
      goto while_break___86;
    }
    while_break___86: /* CIL Label */ ;
    }
#line 4042
    goto switch_break___0;
    case_96: /* CIL Label */ 
#line 4045
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4046
      goto normal_char;
    }
    {
#line 4047
    while (1) {
      while_continue___89: /* CIL Label */ ;
      {
#line 4047
      while (1) {
        while_continue___90: /* CIL Label */ ;
#line 4047
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4047
          goto while_break___90;
        }
        {
#line 4047
        while (1) {
          while_continue___91: /* CIL Label */ ;
#line 4047
          old_buffer___21 = bufp->buffer;
#line 4047
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4047
            return ((reg_errcode_t )15);
          }
#line 4047
          bufp->allocated <<= 1;
#line 4047
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4047
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4047
          tmp___118 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4047
          bufp->buffer = (unsigned char *)tmp___118;
          }
#line 4047
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4047
            return ((reg_errcode_t )12);
          }
#line 4047
          if ((unsigned long )old_buffer___21 != (unsigned long )bufp->buffer) {
#line 4047
            incr___21 = (int )(bufp->buffer - old_buffer___21);
#line 4047
            b += incr___21;
#line 4047
            begalt += incr___21;
#line 4047
            if (fixup_alt_jump) {
#line 4047
              fixup_alt_jump += incr___21;
            }
#line 4047
            if (laststart) {
#line 4047
              laststart += incr___21;
            }
#line 4047
            if (pending_exact) {
#line 4047
              pending_exact += incr___21;
            }
          }
#line 4047
          goto while_break___91;
        }
        while_break___91: /* CIL Label */ ;
        }
      }
      while_break___90: /* CIL Label */ ;
      }
#line 4047
      tmp___119 = b;
#line 4047
      b ++;
#line 4047
      *tmp___119 = (unsigned char)11;
#line 4047
      goto while_break___89;
    }
    while_break___89: /* CIL Label */ ;
    }
#line 4048
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 4051
    if (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4052
      goto normal_char;
    }
    {
#line 4053
    while (1) {
      while_continue___92: /* CIL Label */ ;
      {
#line 4053
      while (1) {
        while_continue___93: /* CIL Label */ ;
#line 4053
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4053
          goto while_break___93;
        }
        {
#line 4053
        while (1) {
          while_continue___94: /* CIL Label */ ;
#line 4053
          old_buffer___22 = bufp->buffer;
#line 4053
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4053
            return ((reg_errcode_t )15);
          }
#line 4053
          bufp->allocated <<= 1;
#line 4053
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4053
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4053
          tmp___120 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4053
          bufp->buffer = (unsigned char *)tmp___120;
          }
#line 4053
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4053
            return ((reg_errcode_t )12);
          }
#line 4053
          if ((unsigned long )old_buffer___22 != (unsigned long )bufp->buffer) {
#line 4053
            incr___22 = (int )(bufp->buffer - old_buffer___22);
#line 4053
            b += incr___22;
#line 4053
            begalt += incr___22;
#line 4053
            if (fixup_alt_jump) {
#line 4053
              fixup_alt_jump += incr___22;
            }
#line 4053
            if (laststart) {
#line 4053
              laststart += incr___22;
            }
#line 4053
            if (pending_exact) {
#line 4053
              pending_exact += incr___22;
            }
          }
#line 4053
          goto while_break___94;
        }
        while_break___94: /* CIL Label */ ;
        }
      }
      while_break___93: /* CIL Label */ ;
      }
#line 4053
      tmp___121 = b;
#line 4053
      b ++;
#line 4053
      *tmp___121 = (unsigned char)12;
#line 4053
      goto while_break___92;
    }
    while_break___92: /* CIL Label */ ;
    }
#line 4054
    goto switch_break___0;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 4058
    if (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4059
      goto normal_char;
    }
#line 4061
    c1 = (unsigned char )((int )c - 48);
#line 4063
    if ((regnum_t )c1 > regnum) {
      {
#line 4064
      free((void *)compile_stack.stack);
      }
#line 4064
      return ((reg_errcode_t )6);
    }
    {
#line 4067
    tmp___122 = group_in_compile_stack(compile_stack, (regnum_t )c1);
    }
#line 4067
    if (tmp___122) {
#line 4068
      goto normal_char;
    }
#line 4070
    laststart = b;
    {
#line 4071
    while (1) {
      while_continue___95: /* CIL Label */ ;
      {
#line 4071
      while (1) {
        while_continue___96: /* CIL Label */ ;
#line 4071
        if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
#line 4071
          goto while_break___96;
        }
        {
#line 4071
        while (1) {
          while_continue___97: /* CIL Label */ ;
#line 4071
          old_buffer___23 = bufp->buffer;
#line 4071
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4071
            return ((reg_errcode_t )15);
          }
#line 4071
          bufp->allocated <<= 1;
#line 4071
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4071
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4071
          tmp___123 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4071
          bufp->buffer = (unsigned char *)tmp___123;
          }
#line 4071
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4071
            return ((reg_errcode_t )12);
          }
#line 4071
          if ((unsigned long )old_buffer___23 != (unsigned long )bufp->buffer) {
#line 4071
            incr___23 = (int )(bufp->buffer - old_buffer___23);
#line 4071
            b += incr___23;
#line 4071
            begalt += incr___23;
#line 4071
            if (fixup_alt_jump) {
#line 4071
              fixup_alt_jump += incr___23;
            }
#line 4071
            if (laststart) {
#line 4071
              laststart += incr___23;
            }
#line 4071
            if (pending_exact) {
#line 4071
              pending_exact += incr___23;
            }
          }
#line 4071
          goto while_break___97;
        }
        while_break___97: /* CIL Label */ ;
        }
      }
      while_break___96: /* CIL Label */ ;
      }
#line 4071
      tmp___124 = b;
#line 4071
      b ++;
#line 4071
      *tmp___124 = (unsigned char)8;
#line 4071
      tmp___125 = b;
#line 4071
      b ++;
#line 4071
      *tmp___125 = c1;
#line 4071
      goto while_break___95;
    }
    while_break___95: /* CIL Label */ ;
    }
#line 4072
    goto switch_break___0;
    case_63___0: /* CIL Label */ 
    case_43___0: /* CIL Label */ 
#line 4077
    if (syntax & (1UL << 1)) {
#line 4078
      goto handle_plus;
    }
    normal_backslash: 
    switch_default: /* CIL Label */ 
#line 4087
    if (translate) {
#line 4087
      c = (unsigned char )*(translate + c);
    } else {
#line 4087
      c = (unsigned char )((char )c);
    }
#line 4088
    goto normal_char;
    switch_break___0: /* CIL Label */ ;
    }
#line 4090
    goto switch_break;
    normal_char: 
    switch_default___0: /* CIL Label */ 
#line 4097
    if (! pending_exact) {
#line 4097
      goto _L___32;
    } else
#line 4097
    if ((unsigned long )((pending_exact + (int )*pending_exact) + 1) != (unsigned long )b) {
#line 4097
      goto _L___32;
    } else
#line 4097
    if ((int )*pending_exact == (1 << 8) - 1) {
#line 4097
      goto _L___32;
    } else
#line 4097
    if ((int const   )*p == 42) {
#line 4097
      goto _L___32;
    } else
#line 4097
    if ((int const   )*p == 94) {
#line 4097
      goto _L___32;
    } else {
#line 4097
      if (syntax & (1UL << 1)) {
#line 4097
        if ((int const   )*p == 92) {
#line 4097
          if ((int const   )*(p + 1) == 43) {
#line 4097
            tmp___129 = 1;
          } else
#line 4097
          if ((int const   )*(p + 1) == 63) {
#line 4097
            tmp___129 = 1;
          } else {
#line 4097
            tmp___129 = 0;
          }
        } else {
#line 4097
          tmp___129 = 0;
        }
#line 4097
        tmp___131 = tmp___129;
      } else {
#line 4097
        if ((int const   )*p == 43) {
#line 4097
          tmp___130 = 1;
        } else
#line 4097
        if ((int const   )*p == 63) {
#line 4097
          tmp___130 = 1;
        } else {
#line 4097
          tmp___130 = 0;
        }
#line 4097
        tmp___131 = tmp___130;
      }
#line 4097
      if (tmp___131) {
#line 4097
        goto _L___32;
      } else
#line 4097
      if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4097
        if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4097
          tmp___133 = (int const   )*p == 123;
        } else {
#line 4097
          if ((int const   )*(p + 0) == 92) {
#line 4097
            if ((int const   )*(p + 1) == 123) {
#line 4097
              tmp___132 = 1;
            } else {
#line 4097
              tmp___132 = 0;
            }
          } else {
#line 4097
            tmp___132 = 0;
          }
#line 4097
          tmp___133 = tmp___132;
        }
#line 4097
        if (tmp___133) {
          _L___32: /* CIL Label */ 
#line 4122
          laststart = b;
          {
#line 4132
          while (1) {
            while_continue___98: /* CIL Label */ ;
            {
#line 4132
            while (1) {
              while_continue___99: /* CIL Label */ ;
#line 4132
              if (! ((unsigned long )((b - bufp->buffer) + 2L) > bufp->allocated)) {
#line 4132
                goto while_break___99;
              }
              {
#line 4132
              while (1) {
                while_continue___100: /* CIL Label */ ;
#line 4132
                old_buffer___24 = bufp->buffer;
#line 4132
                if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4132
                  return ((reg_errcode_t )15);
                }
#line 4132
                bufp->allocated <<= 1;
#line 4132
                if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4132
                  bufp->allocated = (unsigned long )(1L << 16);
                }
                {
#line 4132
                tmp___126 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4132
                bufp->buffer = (unsigned char *)tmp___126;
                }
#line 4132
                if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4132
                  return ((reg_errcode_t )12);
                }
#line 4132
                if ((unsigned long )old_buffer___24 != (unsigned long )bufp->buffer) {
#line 4132
                  incr___24 = (int )(bufp->buffer - old_buffer___24);
#line 4132
                  b += incr___24;
#line 4132
                  begalt += incr___24;
#line 4132
                  if (fixup_alt_jump) {
#line 4132
                    fixup_alt_jump += incr___24;
                  }
#line 4132
                  if (laststart) {
#line 4132
                    laststart += incr___24;
                  }
#line 4132
                  if (pending_exact) {
#line 4132
                    pending_exact += incr___24;
                  }
                }
#line 4132
                goto while_break___100;
              }
              while_break___100: /* CIL Label */ ;
              }
            }
            while_break___99: /* CIL Label */ ;
            }
#line 4132
            tmp___127 = b;
#line 4132
            b ++;
#line 4132
            *tmp___127 = (unsigned char)2;
#line 4132
            tmp___128 = b;
#line 4132
            b ++;
#line 4132
            *tmp___128 = (unsigned char)0;
#line 4132
            goto while_break___98;
          }
          while_break___98: /* CIL Label */ ;
          }
#line 4134
          pending_exact = b - 1;
        }
      }
    }
    {
#line 4137
    while (1) {
      while_continue___101: /* CIL Label */ ;
      {
#line 4137
      while (1) {
        while_continue___102: /* CIL Label */ ;
#line 4137
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4137
          goto while_break___102;
        }
        {
#line 4137
        while (1) {
          while_continue___103: /* CIL Label */ ;
#line 4137
          old_buffer___25 = bufp->buffer;
#line 4137
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4137
            return ((reg_errcode_t )15);
          }
#line 4137
          bufp->allocated <<= 1;
#line 4137
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4137
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4137
          tmp___134 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4137
          bufp->buffer = (unsigned char *)tmp___134;
          }
#line 4137
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4137
            return ((reg_errcode_t )12);
          }
#line 4137
          if ((unsigned long )old_buffer___25 != (unsigned long )bufp->buffer) {
#line 4137
            incr___25 = (int )(bufp->buffer - old_buffer___25);
#line 4137
            b += incr___25;
#line 4137
            begalt += incr___25;
#line 4137
            if (fixup_alt_jump) {
#line 4137
              fixup_alt_jump += incr___25;
            }
#line 4137
            if (laststart) {
#line 4137
              laststart += incr___25;
            }
#line 4137
            if (pending_exact) {
#line 4137
              pending_exact += incr___25;
            }
          }
#line 4137
          goto while_break___103;
        }
        while_break___103: /* CIL Label */ ;
        }
      }
      while_break___102: /* CIL Label */ ;
      }
#line 4137
      tmp___135 = b;
#line 4137
      b ++;
#line 4137
      *tmp___135 = c;
#line 4137
      goto while_break___101;
    }
    while_break___101: /* CIL Label */ ;
    }
#line 4138
    *pending_exact = (unsigned char )((int )*pending_exact + 1);
#line 4139
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4146
  if (fixup_alt_jump) {
    {
#line 4147
    byte_store_op1((re_opcode_t )14, fixup_alt_jump, (int )((b - fixup_alt_jump) - 3L));
    }
  }
#line 4149
  if (! (compile_stack.avail == 0U)) {
    {
#line 4150
    free((void *)compile_stack.stack);
    }
#line 4150
    return ((reg_errcode_t )8);
  }
#line 4154
  if (syntax & ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    {
#line 4155
    while (1) {
      while_continue___104: /* CIL Label */ ;
      {
#line 4155
      while (1) {
        while_continue___105: /* CIL Label */ ;
#line 4155
        if (! ((unsigned long )((b - bufp->buffer) + 1L) > bufp->allocated)) {
#line 4155
          goto while_break___105;
        }
        {
#line 4155
        while (1) {
          while_continue___106: /* CIL Label */ ;
#line 4155
          old_buffer___26 = bufp->buffer;
#line 4155
          if (bufp->allocated == (unsigned long )(1L << 16)) {
#line 4155
            return ((reg_errcode_t )15);
          }
#line 4155
          bufp->allocated <<= 1;
#line 4155
          if (bufp->allocated > (unsigned long )(1L << 16)) {
#line 4155
            bufp->allocated = (unsigned long )(1L << 16);
          }
          {
#line 4155
          tmp___136 = realloc((void *)bufp->buffer, bufp->allocated);
#line 4155
          bufp->buffer = (unsigned char *)tmp___136;
          }
#line 4155
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
#line 4155
            return ((reg_errcode_t )12);
          }
#line 4155
          if ((unsigned long )old_buffer___26 != (unsigned long )bufp->buffer) {
#line 4155
            incr___26 = (int )(bufp->buffer - old_buffer___26);
#line 4155
            b += incr___26;
#line 4155
            begalt += incr___26;
#line 4155
            if (fixup_alt_jump) {
#line 4155
              fixup_alt_jump += incr___26;
            }
#line 4155
            if (laststart) {
#line 4155
              laststart += incr___26;
            }
#line 4155
            if (pending_exact) {
#line 4155
              pending_exact += incr___26;
            }
          }
#line 4155
          goto while_break___106;
        }
        while_break___106: /* CIL Label */ ;
        }
      }
      while_break___105: /* CIL Label */ ;
      }
#line 4155
      tmp___137 = b;
#line 4155
      b ++;
#line 4155
      *tmp___137 = (unsigned char)1;
#line 4155
      goto while_break___104;
    }
    while_break___104: /* CIL Label */ ;
    }
  }
  {
#line 4162
  free((void *)compile_stack.stack);
#line 4168
  bufp->used = (unsigned long )(b - bufp->buffer);
  }
#line 4220
  return ((reg_errcode_t )0);
}
}
#line 4228 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static void byte_store_op1(re_opcode_t op , unsigned char *loc , int arg ) 
{ 


  {
#line 4231
  *loc = (unsigned char )op;
  {
#line 4232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4232
    *((loc + 1) + 0) = (unsigned char )(arg & 255);
#line 4232
    *((loc + 1) + 1) = (unsigned char )(arg >> 8);
#line 4232
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 4233
  return;
}
}
#line 4239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static void byte_store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) 
{ 


  {
#line 4242
  *loc = (unsigned char )op;
  {
#line 4243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4243
    *((loc + 1) + 0) = (unsigned char )(arg1 & 255);
#line 4243
    *((loc + 1) + 1) = (unsigned char )(arg1 >> 8);
#line 4243
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4244
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4244
    *(((loc + 1) + 2) + 0) = (unsigned char )(arg2 & 255);
#line 4244
    *(((loc + 1) + 2) + 1) = (unsigned char )(arg2 >> 8);
#line 4244
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4245
  return;
}
}
#line 4252 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static void byte_insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
#line 4255
  pfrom = end;
#line 4256
  pto = (end + 1) + 2;
  {
#line 4258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4258
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
#line 4258
      goto while_break;
    }
#line 4259
    pto --;
#line 4259
    pfrom --;
#line 4259
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4261
  byte_store_op1(op, loc, arg);
  }
#line 4262
  return;
}
}
#line 4268 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static void byte_insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ,
                            unsigned char *end ) 
{ 
  register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
#line 4272
  pfrom = end;
#line 4273
  pto = (end + 1) + 4;
  {
#line 4275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4275
    if (! ((unsigned long )pfrom != (unsigned long )loc)) {
#line 4275
      goto while_break;
    }
#line 4276
    pto --;
#line 4276
    pfrom --;
#line 4276
    *pto = *pfrom;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4278
  byte_store_op2(op, loc, arg1, arg2);
  }
#line 4279
  return;
}
}
#line 4286 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static boolean byte_at_begline_loc_p(char const   *pattern , char const   *p , reg_syntax_t syntax ) 
{ 
  char const   *prev ;
  boolean prev_prev_backslash ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 4290
  prev = p - 2;
#line 4291
  if ((unsigned long )prev > (unsigned long )pattern) {
#line 4291
    if ((int const   )*(prev + -1) == 92) {
#line 4291
      tmp___0 = 1;
    } else {
#line 4291
      tmp___0 = 0;
    }
  } else {
#line 4291
    tmp___0 = 0;
  }
#line 4291
  prev_prev_backslash = (boolean )tmp___0;
#line 4293
  if ((int const   )*prev == 40) {
#line 4293
    if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4293
      tmp___1 = 1;
    } else
#line 4293
    if (prev_prev_backslash) {
#line 4293
      tmp___1 = 1;
    } else {
#line 4293
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4293
  if ((int const   )*prev == 124) {
#line 4293
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4293
      tmp___1 = 1;
    } else
#line 4293
    if (prev_prev_backslash) {
#line 4293
      tmp___1 = 1;
    } else {
#line 4293
      tmp___1 = 0;
    }
  } else {
#line 4293
    tmp___1 = 0;
  }
#line 4293
  return ((boolean )tmp___1);
}
}
#line 4304 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static boolean byte_at_endline_loc_p(char const   *p , char const   *pend , reg_syntax_t syntax ) 
{ 
  char const   *next ;
  boolean next_backslash ;
  char const   *next_next ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 4308
  next = p;
#line 4309
  next_backslash = (boolean )((int const   )*next == 92);
#line 4310
  if ((unsigned long )(p + 1) < (unsigned long )pend) {
#line 4310
    tmp___0 = p + 1;
  } else {
#line 4310
    tmp___0 = (char const   *)0;
  }
#line 4310
  next_next = tmp___0;
#line 4312
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4312
    tmp___2 = (int const   )*next == 41;
  } else {
#line 4312
    if (next_backslash) {
#line 4312
      if (next_next) {
#line 4312
        if ((int const   )*next_next == 41) {
#line 4312
          tmp___1 = 1;
        } else {
#line 4312
          tmp___1 = 0;
        }
      } else {
#line 4312
        tmp___1 = 0;
      }
    } else {
#line 4312
      tmp___1 = 0;
    }
#line 4312
    tmp___2 = tmp___1;
  }
#line 4312
  if (tmp___2) {
#line 4312
    tmp___5 = 1;
  } else {
#line 4312
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4312
      tmp___4 = (int const   )*next == 124;
    } else {
#line 4312
      if (next_backslash) {
#line 4312
        if (next_next) {
#line 4312
          if ((int const   )*next_next == 124) {
#line 4312
            tmp___3 = 1;
          } else {
#line 4312
            tmp___3 = 0;
          }
        } else {
#line 4312
          tmp___3 = 0;
        }
      } else {
#line 4312
        tmp___3 = 0;
      }
#line 4312
      tmp___4 = tmp___3;
    }
#line 4312
    if (tmp___4) {
#line 4312
      tmp___5 = 1;
    } else {
#line 4312
      tmp___5 = 0;
    }
  }
#line 4312
  return ((boolean )tmp___5);
}
}
#line 4441 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static reg_errcode_t byte_compile_range(unsigned int range_start_char , char const   **p_ptr ,
                                        char const   *pend , char *translate , reg_syntax_t syntax ,
                                        unsigned char *b ) 
{ 
  unsigned int this_char ;
  char const   *p ;
  reg_errcode_t ret ;
  unsigned int end_char ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4447
  p = *p_ptr;
#line 4457
  if ((unsigned long )p == (unsigned long )pend) {
#line 4458
    return ((reg_errcode_t )11);
  }
#line 4462
  (*p_ptr) ++;
#line 4465
  if (syntax & ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4465
    ret = (reg_errcode_t )11;
  } else {
#line 4465
    ret = (reg_errcode_t )0;
  }
#line 4487
  if (translate) {
#line 4487
    range_start_char = (unsigned int )*(translate + (unsigned char )range_start_char);
  } else {
#line 4487
    range_start_char = (unsigned int )((char )range_start_char);
  }
#line 4493
  if (translate) {
#line 4493
    tmp___0 = (int )*(translate + (unsigned char )*(p + 0));
  } else {
#line 4493
    tmp___0 = (int )((char )*(p + 0));
  }
#line 4493
  end_char = (unsigned int )tmp___0 & (unsigned int )((1 << 8) - 1);
#line 4495
  this_char = range_start_char;
  {
#line 4495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4495
    if (! (this_char <= end_char)) {
#line 4495
      goto while_break;
    }
#line 4497
    if (translate) {
#line 4497
      tmp___1 = (int )*(translate + (unsigned char )this_char);
    } else {
#line 4497
      tmp___1 = (int )((char )this_char);
    }
#line 4497
    if (translate) {
#line 4497
      tmp___2 = (int )*(translate + (unsigned char )this_char);
    } else {
#line 4497
      tmp___2 = (int )((char )this_char);
    }
#line 4497
    *(b + (int )((unsigned char )tmp___1) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )tmp___1) / 8) | (1 << (int )((unsigned char )tmp___2) % 8));
#line 4498
    ret = (reg_errcode_t )0;
#line 4495
    this_char ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4502
  return (ret);
}
}
#line 4540 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static int byte_re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  int j ;
  int k ;
  byte_fail_stack_type fail_stack ;
  char *destination ;
  register char *fastmap ;
  unsigned char *pattern ;
  register unsigned char *pend ;
  unsigned char *p ;
  boolean path_can_be_null ;
  boolean succeed_n_p ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int fastmap_newline ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 4551
  fastmap = bufp->fastmap;
#line 4559
  pattern = bufp->buffer;
#line 4560
  pend = pattern + bufp->used;
#line 4562
  p = pattern;
#line 4574
  path_can_be_null = (boolean )1;
#line 4577
  succeed_n_p = (boolean )0;
  {
#line 4581
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 4581
    tmp___0 = __builtin_alloca(5UL * sizeof(byte_fail_stack_elt_t ));
#line 4581
    fail_stack.stack = (byte_fail_stack_elt_t *)tmp___0;
    }
#line 4581
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4581
      return (-2);
    }
#line 4581
    fail_stack.size = 5U;
#line 4581
    fail_stack.avail = 0U;
#line 4581
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4582
  memset((void *)fastmap, '\000', (size_t )(1 << 8));
#line 4583
  bufp->fastmap_accurate = 1U;
#line 4584
  bufp->can_be_null = 0U;
  }
  {
#line 4586
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4588
    if ((unsigned long )p == (unsigned long )pend) {
#line 4588
      goto _L;
    } else
#line 4588
    if ((int )*p == 1) {
      _L: /* CIL Label */ 
#line 4591
      if (! (fail_stack.avail == 0U)) {
#line 4593
        bufp->can_be_null |= (unsigned int )path_can_be_null;
#line 4596
        path_can_be_null = (boolean )1;
#line 4598
        (fail_stack.avail) --;
#line 4598
        p = (fail_stack.stack + fail_stack.avail)->pointer;
#line 4600
        goto while_continue___0;
      } else {
#line 4603
        goto while_break___0;
      }
    }
#line 4609
    tmp___1 = p;
#line 4609
    p ++;
    {
#line 4617
    if ((unsigned int )((re_opcode_t )*tmp___1) == 8U) {
#line 4617
      goto case_8;
    }
#line 4630
    if ((unsigned int )((re_opcode_t )*tmp___1) == 2U) {
#line 4630
      goto case_2;
    }
#line 4650
    if ((unsigned int )((re_opcode_t )*tmp___1) == 4U) {
#line 4650
      goto case_4;
    }
#line 4657
    if ((unsigned int )((re_opcode_t )*tmp___1) == 5U) {
#line 4657
      goto case_5;
    }
#line 4668
    if ((unsigned int )((re_opcode_t )*tmp___1) == 24U) {
#line 4668
      goto case_24;
    }
#line 4675
    if ((unsigned int )((re_opcode_t )*tmp___1) == 25U) {
#line 4675
      goto case_25;
    }
#line 4682
    if ((unsigned int )((re_opcode_t )*tmp___1) == 3U) {
#line 4682
      goto case_3;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 20U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 27U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 26U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 29U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 28U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 12U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 11U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 10U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 9U) {
#line 4740
      goto case_20;
    }
#line 4740
    if ((unsigned int )((re_opcode_t )*tmp___1) == 0U) {
#line 4740
      goto case_20;
    }
#line 4749
    if ((unsigned int )((re_opcode_t )*tmp___1) == 19U) {
#line 4749
      goto case_19;
    }
#line 4749
    if ((unsigned int )((re_opcode_t )*tmp___1) == 14U) {
#line 4749
      goto case_19;
    }
#line 4749
    if ((unsigned int )((re_opcode_t )*tmp___1) == 13U) {
#line 4749
      goto case_19;
    }
#line 4749
    if ((unsigned int )((re_opcode_t )*tmp___1) == 18U) {
#line 4749
      goto case_19;
    }
#line 4749
    if ((unsigned int )((re_opcode_t )*tmp___1) == 17U) {
#line 4749
      goto case_19;
    }
#line 4749
    if ((unsigned int )((re_opcode_t )*tmp___1) == 22U) {
#line 4749
      goto case_19;
    }
#line 4777
    if ((unsigned int )((re_opcode_t )*tmp___1) == 16U) {
#line 4777
      goto handle_on_failure_jump;
    }
#line 4777
    if ((unsigned int )((re_opcode_t )*tmp___1) == 15U) {
#line 4777
      goto handle_on_failure_jump;
    }
#line 4808
    if ((unsigned int )((re_opcode_t )*tmp___1) == 21U) {
#line 4808
      goto case_21;
    }
#line 4823
    if ((unsigned int )((re_opcode_t )*tmp___1) == 23U) {
#line 4823
      goto case_23;
    }
#line 4829
    if ((unsigned int )((re_opcode_t )*tmp___1) == 7U) {
#line 4829
      goto case_7;
    }
#line 4829
    if ((unsigned int )((re_opcode_t )*tmp___1) == 6U) {
#line 4829
      goto case_7;
    }
#line 4834
    goto switch_default;
    case_8: /* CIL Label */ 
#line 4618
    bufp->can_be_null = 1U;
#line 4619
    goto done;
    case_2: /* CIL Label */ 
#line 4631
    *(fastmap + *(p + 1)) = (char)1;
#line 4632
    goto switch_break;
    case_4: /* CIL Label */ 
#line 4651
    tmp___2 = p;
#line 4651
    p ++;
#line 4651
    j = (int )*tmp___2 * 8 - 1;
    {
#line 4651
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4651
      if (! (j >= 0)) {
#line 4651
        goto while_break___1;
      }
#line 4652
      if ((int )*(p + j / 8) & (1 << j % 8)) {
#line 4653
        *(fastmap + j) = (char)1;
      }
#line 4651
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4654
    goto switch_break;
    case_5: /* CIL Label */ 
#line 4659
    j = (int )*p * 8;
    {
#line 4659
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4659
      if (! (j < 1 << 8)) {
#line 4659
        goto while_break___2;
      }
#line 4660
      *(fastmap + j) = (char)1;
#line 4659
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4662
    tmp___3 = p;
#line 4662
    p ++;
#line 4662
    j = (int )*tmp___3 * 8 - 1;
    {
#line 4662
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4662
      if (! (j >= 0)) {
#line 4662
        goto while_break___3;
      }
#line 4663
      if (! ((int )*(p + j / 8) & (1 << j % 8))) {
#line 4664
        *(fastmap + j) = (char)1;
      }
#line 4662
      j --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4665
    goto switch_break;
    case_24: /* CIL Label */ 
#line 4669
    j = 0;
    {
#line 4669
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 4669
      if (! (j < 1 << 8)) {
#line 4669
        goto while_break___4;
      }
#line 4670
      if ((int )re_syntax_table[(unsigned char )j] == 1) {
#line 4671
        *(fastmap + j) = (char)1;
      }
#line 4669
      j ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 4672
    goto switch_break;
    case_25: /* CIL Label */ 
#line 4676
    j = 0;
    {
#line 4676
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 4676
      if (! (j < 1 << 8)) {
#line 4676
        goto while_break___5;
      }
#line 4677
      if ((int )re_syntax_table[(unsigned char )j] != 1) {
#line 4678
        *(fastmap + j) = (char)1;
      }
#line 4676
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 4679
    goto switch_break;
    case_3: /* CIL Label */ 
#line 4684
    fastmap_newline = (int )*(fastmap + '\n');
#line 4687
    j = 0;
    {
#line 4687
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 4687
      if (! (j < 1 << 8)) {
#line 4687
        goto while_break___6;
      }
#line 4688
      *(fastmap + j) = (char)1;
#line 4687
      j ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 4691
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4692
      *(fastmap + '\n') = (char )fastmap_newline;
    } else
#line 4696
    if (bufp->can_be_null) {
#line 4697
      goto done;
    }
#line 4700
    goto switch_break;
    case_20: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 4741
    goto while_continue___0;
    case_19: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_22: /* CIL Label */ 
    {
#line 4750
    while (1) {
      while_continue___7: /* CIL Label */ ;
      {
#line 4750
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 4750
        j = (int )*p & 255;
#line 4750
        j += (int )((signed char )*(p + 1)) << 8;
#line 4750
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 4750
      p += 2;
#line 4750
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 4751
    p += j;
#line 4752
    if (j > 0) {
#line 4753
      goto while_continue___0;
    }
#line 4760
    if ((unsigned int )((re_opcode_t )*p) != 15U) {
#line 4760
      if ((unsigned int )((re_opcode_t )*p) != 21U) {
#line 4762
        goto while_continue___0;
      }
    }
#line 4764
    p ++;
    {
#line 4765
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 4765
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 4765
        j = (int )*p & 255;
#line 4765
        j += (int )((signed char )*(p + 1)) << 8;
#line 4765
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 4765
      p += 2;
#line 4765
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 4766
    p += j;
#line 4769
    if (! (fail_stack.avail == 0U)) {
#line 4769
      if ((unsigned long )(fail_stack.stack + (fail_stack.avail - 1U))->pointer == (unsigned long )p) {
#line 4771
        (fail_stack.avail) --;
      }
    }
#line 4773
    goto while_continue___0;
    handle_on_failure_jump: 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    {
#line 4779
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 4779
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 4779
        j = (int )*p & 255;
#line 4779
        j += (int )((signed char )*(p + 1)) << 8;
#line 4779
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 4779
      p += 2;
#line 4779
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 4788
    if ((unsigned long )(p + j) < (unsigned long )pend) {
#line 4790
      if (fail_stack.avail == fail_stack.size) {
#line 4790
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 4790
          tmp___12 = 0;
        } else {
          {
#line 4790
          tmp___9 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 4790
          destination = (char *)tmp___9;
#line 4790
          tmp___10 = memcpy((void */* __restrict  */)destination, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 4790
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___10;
          }
#line 4790
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 4790
            tmp___11 = 0;
          } else {
#line 4790
            fail_stack.size <<= 1;
#line 4790
            tmp___11 = 1;
          }
#line 4790
          tmp___12 = tmp___11;
        }
#line 4790
        if (tmp___12) {
#line 4790
          tmp___7 = fail_stack.avail;
#line 4790
          (fail_stack.avail) ++;
#line 4790
          (fail_stack.stack + tmp___7)->pointer = p + j;
#line 4790
          tmp___8 = 1;
        } else {
#line 4790
          tmp___8 = 0;
        }
      } else {
#line 4790
        tmp___7 = fail_stack.avail;
#line 4790
        (fail_stack.avail) ++;
#line 4790
        (fail_stack.stack + tmp___7)->pointer = p + j;
#line 4790
        tmp___8 = 1;
      }
#line 4790
      if (! tmp___8) {
#line 4793
        return (-2);
      }
    } else {
#line 4797
      bufp->can_be_null = 1U;
    }
#line 4799
    if (succeed_n_p) {
      {
#line 4801
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 4801
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 4801
          k = (int )*p & 255;
#line 4801
          k += (int )((signed char )*(p + 1)) << 8;
#line 4801
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 4801
        p += 2;
#line 4801
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 4802
      succeed_n_p = (boolean )0;
    }
#line 4805
    goto while_continue___0;
    case_21: /* CIL Label */ 
#line 4810
    p += 2;
    {
#line 4813
    while (1) {
      while_continue___15: /* CIL Label */ ;
      {
#line 4813
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 4813
        k = (int )*p & 255;
#line 4813
        k += (int )((signed char )*(p + 1)) << 8;
#line 4813
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 4813
      p += 2;
#line 4813
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 4814
    if (k == 0) {
#line 4816
      p -= 4;
#line 4817
      succeed_n_p = (boolean )1;
#line 4818
      goto handle_on_failure_jump;
    }
#line 4820
    goto while_continue___0;
    case_23: /* CIL Label */ 
#line 4824
    p += 4;
#line 4825
    goto while_continue___0;
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 4830
    p += 2;
#line 4831
    goto while_continue___0;
    switch_default: /* CIL Label */ 
    {
#line 4835
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 4844
    path_can_be_null = (boolean )0;
#line 4845
    p = pend;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4850
  bufp->can_be_null |= (unsigned int )path_can_be_null;
  done: ;
#line 4854
  return (0);
}
}
#line 5006 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static int byte_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                            int size1 , char const   *string2 , int size2 , int startpos ,
                            int range , struct re_registers *regs , int stop ) 
{ 
  int val ;
  register char *fastmap ;
  register char *translate ;
  int total_size ;
  int endpos ;
  int tmp___0 ;
  register char const   *d ;
  register int lim ;
  int irange ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  register char c ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 5013
  fastmap = bufp->fastmap;
#line 5014
  translate = bufp->translate;
#line 5015
  total_size = size1 + size2;
#line 5016
  endpos = startpos + range;
#line 5029
  if (startpos < 0) {
#line 5030
    return (-1);
  } else
#line 5029
  if (startpos > total_size) {
#line 5030
    return (-1);
  }
#line 5035
  if (endpos < 0) {
#line 5036
    range = 0 - startpos;
  } else
#line 5037
  if (endpos > total_size) {
#line 5038
    range = total_size - startpos;
  }
#line 5042
  if (bufp->used > 0UL) {
#line 5042
    if (range > 0) {
#line 5042
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 11U) {
#line 5042
        goto _L;
      } else
#line 5042
      if ((unsigned int )((re_opcode_t )*(bufp->buffer + 0)) == 9U) {
#line 5042
        if (! bufp->newline_anchor) {
          _L: /* CIL Label */ 
#line 5048
          if (startpos > 0) {
#line 5049
            return (-1);
          } else {
#line 5051
            range = 1;
          }
        }
      }
    }
  }
#line 5066
  if (fastmap) {
#line 5066
    if (! bufp->fastmap_accurate) {
      {
#line 5067
      tmp___0 = xre_compile_fastmap(bufp);
      }
#line 5067
      if (tmp___0 == -2) {
#line 5068
        return (-2);
      }
    }
  }
  {
#line 5146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5152
    if (fastmap) {
#line 5152
      if (startpos < total_size) {
#line 5152
        if (! bufp->can_be_null) {
#line 5154
          if (range > 0) {
#line 5157
            lim = 0;
#line 5158
            irange = range;
#line 5160
            if (startpos < size1) {
#line 5160
              if (startpos + range >= size1) {
#line 5161
                lim = range - (size1 - startpos);
              }
            }
#line 5163
            if (startpos >= size1) {
#line 5163
              tmp___1 = string2 - size1;
            } else {
#line 5163
              tmp___1 = string1;
            }
#line 5163
            d = tmp___1 + startpos;
#line 5167
            if (translate) {
              {
#line 5168
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 5168
                if (range > lim) {
#line 5168
                  tmp___2 = d;
#line 5168
                  d ++;
#line 5168
                  if (*(fastmap + (unsigned char )*(translate + (unsigned char )*tmp___2))) {
#line 5168
                    goto while_break___0;
                  }
                } else {
#line 5168
                  goto while_break___0;
                }
#line 5171
                range --;
              }
              while_break___0: /* CIL Label */ ;
              }
            } else {
              {
#line 5173
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 5173
                if (range > lim) {
#line 5173
                  tmp___3 = d;
#line 5173
                  d ++;
#line 5173
                  if (*(fastmap + (unsigned char )*tmp___3)) {
#line 5173
                    goto while_break___1;
                  }
                } else {
#line 5173
                  goto while_break___1;
                }
#line 5174
                range --;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 5176
            startpos += irange - range;
          } else {
#line 5180
            if (size1 == 0) {
#line 5180
              tmp___4 = (int const   )*(string2 + (startpos - size1));
            } else
#line 5180
            if (startpos >= size1) {
#line 5180
              tmp___4 = (int const   )*(string2 + (startpos - size1));
            } else {
#line 5180
              tmp___4 = (int const   )*(string1 + startpos);
            }
#line 5180
            c = (char )tmp___4;
#line 5184
            if (translate) {
#line 5184
              tmp___5 = (int )*(translate + (unsigned char )c);
            } else {
#line 5184
              tmp___5 = (int )c;
            }
#line 5184
            if (! *(fastmap + (unsigned char )tmp___5)) {
#line 5185
              goto advance;
            }
          }
        }
      }
    }
#line 5190
    if (range >= 0) {
#line 5190
      if (startpos == total_size) {
#line 5190
        if (fastmap) {
#line 5190
          if (! bufp->can_be_null) {
#line 5196
            return (-1);
          }
        }
      }
    }
    {
#line 5206
    val = byte_re_match_2_internal(bufp, string1, size1, string2, size2, startpos,
                                   regs, stop);
    }
#line 5216
    if (val >= 0) {
#line 5221
      return (startpos);
    }
#line 5224
    if (val == -2) {
#line 5229
      return (-2);
    }
    advance: 
#line 5233
    if (! range) {
#line 5234
      goto while_break;
    } else
#line 5235
    if (range > 0) {
#line 5237
      range --;
#line 5238
      startpos ++;
    } else {
#line 5242
      range ++;
#line 5243
      startpos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5249
  return (-1);
}
}
#line 5421
static boolean byte_group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                              byte_register_info_type *reg_info ) ;
#line 5424
static boolean byte_alt_match_null_string_p(unsigned char *p , unsigned char *end ,
                                            byte_register_info_type *reg_info ) ;
#line 5427
static boolean byte_common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                                  byte_register_info_type *reg_info ) ;
#line 5430
static int byte_bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) ;
#line 5542 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static int byte_re_match_2_internal(struct re_pattern_buffer *bufp , char const   *string1 ,
                                    int size1 , char const   *string2 , int size2 ,
                                    int pos , struct re_registers *regs , int stop ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  char const   *end1 ;
  char const   *end2 ;
  char const   *end_match_1 ;
  char const   *end_match_2 ;
  char const   *d ;
  char const   *dend ;
  unsigned char *p ;
  register unsigned char *pend ;
  unsigned char *just_past_start_mem ;
  char *translate ;
  byte_fail_stack_type fail_stack ;
  size_t num_regs ;
  active_reg_t lowest_active_reg ;
  active_reg_t highest_active_reg ;
  char const   **regstart ;
  char const   **regend ;
  char const   **old_regstart ;
  char const   **old_regend ;
  byte_register_info_type *reg_info ;
  unsigned int best_regs_set ;
  char const   **best_regstart ;
  char const   **best_regend ;
  char const   *match_end ;
  int set_regs_matched_done ;
  char const   **reg_dummy ;
  byte_register_info_type *reg_info_dummy ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  boolean same_str_p ;
  boolean best_match_p ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  xregoff_t tmp___18 ;
  xregoff_t tmp___19 ;
  xregoff_t tmp___20 ;
  size_t tmp___21 ;
  xregoff_t tmp___22 ;
  char const   *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  char const   *tmp___26 ;
  unsigned char *tmp___27 ;
  char const   *tmp___28 ;
  unsigned char *tmp___29 ;
  active_reg_t r ;
  unsigned int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  active_reg_t r___0 ;
  unsigned int tmp___33 ;
  register unsigned char c ;
  boolean negate ;
  active_reg_t r___1 ;
  unsigned int tmp___34 ;
  boolean tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  unsigned char r___2 ;
  boolean is_a_jump_n ;
  unsigned char *tmp___38 ;
  unsigned int r___3 ;
  char *destination ;
  active_reg_t this_reg ;
  void *tmp___39 ;
  void *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  unsigned int tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  register char const   *d2 ;
  register char const   *dend2 ;
  int regno ;
  unsigned char *tmp___50 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  active_reg_t r___4 ;
  unsigned int tmp___57 ;
  char const   *tmp___58 ;
  int tmp___59 ;
  char const   *tmp___60 ;
  char *destination___0 ;
  active_reg_t this_reg___0 ;
  void *tmp___61 ;
  void *tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  unsigned int tmp___65 ;
  unsigned int tmp___66 ;
  unsigned int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  char *destination___1 ;
  active_reg_t this_reg___1 ;
  void *tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  unsigned int tmp___76 ;
  unsigned int tmp___77 ;
  unsigned int tmp___78 ;
  unsigned int tmp___79 ;
  unsigned int tmp___80 ;
  unsigned int tmp___81 ;
  unsigned int tmp___82 ;
  register unsigned char *p2 ;
  register unsigned char c___0 ;
  int tmp___83 ;
  int negate___0 ;
  int idx___0 ;
  int idx___1 ;
  active_reg_t dummy_low_reg ;
  active_reg_t dummy_high_reg ;
  unsigned char *pdummy  __attribute__((__unused__)) ;
  char const   *sdummy  __attribute__((__unused__)) ;
  active_reg_t this_reg___2 ;
  unsigned char const   *string_temp ;
  char *destination___2 ;
  active_reg_t this_reg___3 ;
  void *tmp___84 ;
  void *tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  unsigned int tmp___88 ;
  unsigned int tmp___89 ;
  unsigned int tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  unsigned int tmp___93 ;
  unsigned int tmp___94 ;
  char *destination___3 ;
  active_reg_t this_reg___4 ;
  void *tmp___95 ;
  void *tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  unsigned int tmp___99 ;
  unsigned int tmp___100 ;
  unsigned int tmp___101 ;
  unsigned int tmp___102 ;
  unsigned int tmp___103 ;
  unsigned int tmp___104 ;
  unsigned int tmp___105 ;
  boolean prevchar ;
  boolean thischar ;
  char const   *tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  boolean prevchar___0 ;
  boolean thischar___0 ;
  char const   *tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  char const   *tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  char const   *tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  active_reg_t r___5 ;
  unsigned int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  active_reg_t r___6 ;
  unsigned int tmp___131 ;
  active_reg_t this_reg___5 ;
  unsigned char const   *string_temp___0 ;
  boolean is_a_jump_n___0 ;

  {
#line 5575
  p = bufp->buffer;
#line 5576
  pend = p + bufp->used;
#line 5581
  just_past_start_mem = (unsigned char *)0;
#line 5584
  translate = bufp->translate;
#line 5612
  num_regs = bufp->re_nsub + 1UL;
#line 5615
  lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 5616
  highest_active_reg = (active_reg_t )(1 << 8);
#line 5652
  best_regs_set = 0U;
#line 5665
  match_end = (char const   *)((void *)0);
#line 5668
  set_regs_matched_done = 0;
  {
#line 5683
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 5683
    tmp___0 = __builtin_alloca(5UL * sizeof(byte_fail_stack_elt_t ));
#line 5683
    fail_stack.stack = (byte_fail_stack_elt_t *)tmp___0;
    }
#line 5683
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 5683
      return (-2);
    }
#line 5683
    fail_stack.size = 5U;
#line 5683
    fail_stack.avail = 0U;
#line 5683
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5691
  if (bufp->re_nsub) {
    {
#line 5693
    tmp___1 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5693
    regstart = (char const   **)tmp___1;
#line 5694
    tmp___2 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5694
    regend = (char const   **)tmp___2;
#line 5695
    tmp___3 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5695
    old_regstart = (char const   **)tmp___3;
#line 5696
    tmp___4 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5696
    old_regend = (char const   **)tmp___4;
#line 5697
    tmp___5 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5697
    best_regstart = (char const   **)tmp___5;
#line 5698
    tmp___6 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5698
    best_regend = (char const   **)tmp___6;
#line 5699
    tmp___7 = __builtin_alloca(num_regs * sizeof(byte_register_info_type ));
#line 5699
    reg_info = (byte_register_info_type *)tmp___7;
#line 5700
    tmp___8 = __builtin_alloca(num_regs * sizeof(char const   *));
#line 5700
    reg_dummy = (char const   **)tmp___8;
#line 5701
    tmp___9 = __builtin_alloca(num_regs * sizeof(byte_register_info_type ));
#line 5701
    reg_info_dummy = (byte_register_info_type *)tmp___9;
    }
#line 5703
    if (regstart) {
#line 5703
      if (regend) {
#line 5703
        if (old_regstart) {
#line 5703
          if (old_regend) {
#line 5703
            if (reg_info) {
#line 5703
              if (best_regstart) {
#line 5703
                if (best_regend) {
#line 5703
                  if (reg_dummy) {
#line 5703
                    if (! reg_info_dummy) {
#line 5703
                      goto _L___6;
                    }
                  } else {
#line 5703
                    goto _L___6;
                  }
                } else {
#line 5703
                  goto _L___6;
                }
              } else {
#line 5703
                goto _L___6;
              }
            } else {
#line 5703
              goto _L___6;
            }
          } else {
#line 5703
            goto _L___6;
          }
        } else {
#line 5703
          goto _L___6;
        }
      } else {
#line 5703
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
      {
#line 5706
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5706
        regstart = (char const   **)((void *)0);
#line 5706
        regend = (char const   **)((void *)0);
#line 5706
        old_regstart = (char const   **)((void *)0);
#line 5706
        old_regend = (char const   **)((void *)0);
#line 5706
        best_regstart = (char const   **)((void *)0);
#line 5706
        best_regend = (char const   **)((void *)0);
#line 5706
        reg_info = (byte_register_info_type *)((void *)0);
#line 5706
        reg_dummy = (char const   **)((void *)0);
#line 5706
        reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5706
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 5707
      return (-2);
    }
  } else {
#line 5714
    reg_dummy = (char const   **)((void *)0);
#line 5714
    best_regend = reg_dummy;
#line 5714
    best_regstart = best_regend;
#line 5714
    old_regend = best_regstart;
#line 5714
    old_regstart = old_regend;
#line 5714
    regend = old_regstart;
#line 5714
    regstart = regend;
#line 5716
    reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5716
    reg_info = reg_info_dummy;
  }
#line 5724
  if (pos < 0) {
#line 5724
    goto _L___7;
  } else
#line 5724
  if (pos > size1 + size2) {
    _L___7: /* CIL Label */ 
    {
#line 5727
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5727
      regstart = (char const   **)((void *)0);
#line 5727
      regend = (char const   **)((void *)0);
#line 5727
      old_regstart = (char const   **)((void *)0);
#line 5727
      old_regend = (char const   **)((void *)0);
#line 5727
      best_regstart = (char const   **)((void *)0);
#line 5727
      best_regend = (char const   **)((void *)0);
#line 5727
      reg_info = (byte_register_info_type *)((void *)0);
#line 5727
      reg_dummy = (char const   **)((void *)0);
#line 5727
      reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5727
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5728
    return (-1);
  }
#line 5785
  mcnt = 1;
  {
#line 5785
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5785
    if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
#line 5785
      goto while_break___2;
    }
#line 5787
    tmp___12 = (char const   *)(& byte_reg_unset_dummy);
#line 5787
    *(old_regend + mcnt) = tmp___12;
#line 5787
    tmp___11 = tmp___12;
#line 5787
    *(old_regstart + mcnt) = tmp___11;
#line 5787
    tmp___10 = tmp___11;
#line 5787
    *(regend + mcnt) = tmp___10;
#line 5787
    *(regstart + mcnt) = tmp___10;
#line 5790
    (reg_info + mcnt)->bits.match_null_string_p = 3U;
#line 5791
    (reg_info + mcnt)->bits.is_active = 0U;
#line 5792
    (reg_info + mcnt)->bits.matched_something = 0U;
#line 5793
    (reg_info + mcnt)->bits.ever_matched_something = 0U;
#line 5785
    mcnt ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5798
  if (size2 == 0) {
#line 5798
    if ((unsigned long )string1 != (unsigned long )((void *)0)) {
#line 5800
      string2 = string1;
#line 5801
      size2 = size1;
#line 5802
      string1 = (char const   *)0;
#line 5803
      size1 = 0;
    }
  }
#line 5811
  end1 = string1 + size1;
#line 5812
  end2 = string2 + size2;
#line 5836
  if (stop <= size1) {
#line 5838
    end_match_1 = string1 + stop;
#line 5839
    end_match_2 = string2;
  } else {
#line 5843
    end_match_1 = end1;
#line 5844
    end_match_2 = (string2 + stop) - size1;
  }
#line 5874
  if (size1 > 0) {
#line 5874
    if (pos <= size1) {
#line 5876
      d = string1 + pos;
#line 5877
      dend = end_match_1;
    } else {
#line 5881
      d = (string2 + pos) - size1;
#line 5882
      dend = end_match_2;
    }
  } else {
#line 5881
    d = (string2 + pos) - size1;
#line 5882
    dend = end_match_2;
  }
  {
#line 5895
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 5903
    if ((unsigned long )p == (unsigned long )pend) {
#line 5909
      if ((unsigned long )d != (unsigned long )end_match_2) {
#line 5918
        if (size1) {
#line 5918
          if ((unsigned long )string1 <= (unsigned long )match_end) {
#line 5918
            if ((unsigned long )match_end <= (unsigned long )(string1 + size1)) {
#line 5918
              tmp___13 = 1;
            } else {
#line 5918
              tmp___13 = 0;
            }
          } else {
#line 5918
            tmp___13 = 0;
          }
        } else {
#line 5918
          tmp___13 = 0;
        }
#line 5918
        same_str_p = (boolean )(tmp___13 == ((unsigned long )dend == (unsigned long )end_match_1));
#line 5923
        if (same_str_p) {
#line 5924
          best_match_p = (boolean )((unsigned long )d > (unsigned long )match_end);
        } else {
#line 5926
          best_match_p = (boolean )(! ((unsigned long )dend == (unsigned long )end_match_1));
        }
#line 5930
        if (! (fail_stack.avail == 0U)) {
#line 5934
          if (! best_regs_set) {
#line 5934
            goto _L___8;
          } else
#line 5934
          if (best_match_p) {
            _L___8: /* CIL Label */ 
#line 5936
            best_regs_set = 1U;
#line 5937
            match_end = d;
#line 5941
            mcnt = 1;
            {
#line 5941
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 5941
              if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
#line 5941
                goto while_break___4;
              }
#line 5943
              *(best_regstart + mcnt) = *(regstart + mcnt);
#line 5944
              *(best_regend + mcnt) = *(regend + mcnt);
#line 5941
              mcnt ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 5947
          goto fail;
        } else
#line 5953
        if (best_regs_set) {
#line 5953
          if (! best_match_p) {
            restore_best_regs: 
#line 5963
            d = match_end;
#line 5964
            if ((unsigned long )d >= (unsigned long )string1) {
#line 5964
              if ((unsigned long )d <= (unsigned long )end1) {
#line 5964
                dend = end_match_1;
              } else {
#line 5964
                dend = end_match_2;
              }
            } else {
#line 5964
              dend = end_match_2;
            }
#line 5967
            mcnt = 1;
            {
#line 5967
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 5967
              if (! ((size_t )((unsigned int )mcnt) < num_regs)) {
#line 5967
                goto while_break___5;
              }
#line 5969
              *(regstart + mcnt) = *(best_regstart + mcnt);
#line 5970
              *(regend + mcnt) = *(best_regend + mcnt);
#line 5967
              mcnt ++;
            }
            while_break___5: /* CIL Label */ ;
            }
          }
        }
      }
      succeed_label: ;
#line 5978
      if (regs) {
#line 5978
        if (! bufp->no_sub) {
#line 5981
          if (bufp->regs_allocated == 0U) {
#line 5985
            if (30UL > num_regs + 1UL) {
#line 5985
              regs->num_regs = 30U;
            } else {
#line 5985
              regs->num_regs = (unsigned int )(num_regs + 1UL);
            }
            {
#line 5986
            tmp___14 = malloc((unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 5986
            regs->start = (xregoff_t *)tmp___14;
#line 5987
            tmp___15 = malloc((unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 5987
            regs->end = (xregoff_t *)tmp___15;
            }
#line 5988
            if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
#line 5988
              goto _L___9;
            } else
#line 5988
            if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
              _L___9: /* CIL Label */ 
              {
#line 5990
              while (1) {
                while_continue___6: /* CIL Label */ ;
#line 5990
                regstart = (char const   **)((void *)0);
#line 5990
                regend = (char const   **)((void *)0);
#line 5990
                old_regstart = (char const   **)((void *)0);
#line 5990
                old_regend = (char const   **)((void *)0);
#line 5990
                best_regstart = (char const   **)((void *)0);
#line 5990
                best_regend = (char const   **)((void *)0);
#line 5990
                reg_info = (byte_register_info_type *)((void *)0);
#line 5990
                reg_dummy = (char const   **)((void *)0);
#line 5990
                reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 5990
                goto while_break___6;
              }
              while_break___6: /* CIL Label */ ;
              }
#line 5991
              return (-2);
            }
#line 5993
            bufp->regs_allocated = 1U;
          } else
#line 5995
          if (bufp->regs_allocated == 1U) {
#line 5999
            if ((size_t )regs->num_regs < num_regs + 1UL) {
              {
#line 6001
              regs->num_regs = (unsigned int )(num_regs + 1UL);
#line 6002
              tmp___16 = realloc((void *)regs->start, (unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 6002
              regs->start = (xregoff_t *)tmp___16;
#line 6003
              tmp___17 = realloc((void *)regs->end, (unsigned long )regs->num_regs * sizeof(xregoff_t ));
#line 6003
              regs->end = (xregoff_t *)tmp___17;
              }
#line 6004
              if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
#line 6004
                goto _L___10;
              } else
#line 6004
              if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
                _L___10: /* CIL Label */ 
                {
#line 6006
                while (1) {
                  while_continue___7: /* CIL Label */ ;
#line 6006
                  regstart = (char const   **)((void *)0);
#line 6006
                  regend = (char const   **)((void *)0);
#line 6006
                  old_regstart = (char const   **)((void *)0);
#line 6006
                  old_regend = (char const   **)((void *)0);
#line 6006
                  best_regstart = (char const   **)((void *)0);
#line 6006
                  best_regend = (char const   **)((void *)0);
#line 6006
                  reg_info = (byte_register_info_type *)((void *)0);
#line 6006
                  reg_dummy = (char const   **)((void *)0);
#line 6006
                  reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 6006
                  goto while_break___7;
                }
                while_break___7: /* CIL Label */ ;
                }
#line 6007
                return (-2);
              }
            }
          }
#line 6021
          if (regs->num_regs > 0U) {
#line 6023
            *(regs->start + 0) = pos;
#line 6032
            if ((unsigned long )dend == (unsigned long )end_match_1) {
#line 6032
              *(regs->end + 0) = (xregoff_t )(d - string1);
            } else {
#line 6032
              *(regs->end + 0) = (xregoff_t )((d - string2) + (long )size1);
            }
          }
#line 6040
          mcnt = 1;
          {
#line 6040
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 6040
            if (num_regs < (size_t )regs->num_regs) {
#line 6040
              tmp___21 = num_regs;
            } else {
#line 6040
              tmp___21 = (size_t )regs->num_regs;
            }
#line 6040
            if (! ((size_t )((unsigned int )mcnt) < tmp___21)) {
#line 6040
              goto while_break___8;
            }
#line 6043
            if ((unsigned long )*(regstart + mcnt) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6044
              tmp___18 = -1;
#line 6044
              *(regs->end + mcnt) = tmp___18;
#line 6044
              *(regs->start + mcnt) = tmp___18;
            } else
#line 6043
            if ((unsigned long )*(regend + mcnt) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6044
              tmp___18 = -1;
#line 6044
              *(regs->end + mcnt) = tmp___18;
#line 6044
              *(regs->start + mcnt) = tmp___18;
            } else {
#line 6047
              if (size1) {
#line 6047
                if ((unsigned long )string1 <= (unsigned long )*(regstart + mcnt)) {
#line 6047
                  if ((unsigned long )*(regstart + mcnt) <= (unsigned long )(string1 + size1)) {
#line 6047
                    tmp___19 = (xregoff_t )(*(regstart + mcnt) - string1);
                  } else {
#line 6047
                    tmp___19 = (xregoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                  }
                } else {
#line 6047
                  tmp___19 = (xregoff_t )((*(regstart + mcnt) - string2) + (long )size1);
                }
              } else {
#line 6047
                tmp___19 = (xregoff_t )((*(regstart + mcnt) - string2) + (long )size1);
              }
#line 6047
              *(regs->start + mcnt) = tmp___19;
#line 6049
              if (size1) {
#line 6049
                if ((unsigned long )string1 <= (unsigned long )*(regend + mcnt)) {
#line 6049
                  if ((unsigned long )*(regend + mcnt) <= (unsigned long )(string1 + size1)) {
#line 6049
                    tmp___20 = (xregoff_t )(*(regend + mcnt) - string1);
                  } else {
#line 6049
                    tmp___20 = (xregoff_t )((*(regend + mcnt) - string2) + (long )size1);
                  }
                } else {
#line 6049
                  tmp___20 = (xregoff_t )((*(regend + mcnt) - string2) + (long )size1);
                }
              } else {
#line 6049
                tmp___20 = (xregoff_t )((*(regend + mcnt) - string2) + (long )size1);
              }
#line 6049
              *(regs->end + mcnt) = tmp___20;
            }
#line 6040
            mcnt ++;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 6059
          mcnt = (int )num_regs;
          {
#line 6059
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 6059
            if (! ((unsigned int )mcnt < regs->num_regs)) {
#line 6059
              goto while_break___9;
            }
#line 6060
            tmp___22 = -1;
#line 6060
            *(regs->end + mcnt) = tmp___22;
#line 6060
            *(regs->start + mcnt) = tmp___22;
#line 6059
            mcnt ++;
          }
          while_break___9: /* CIL Label */ ;
          }
        }
      }
#line 6076
      if ((unsigned long )dend == (unsigned long )end_match_1) {
#line 6076
        tmp___23 = string1;
      } else {
#line 6076
        tmp___23 = string2 - size1;
      }
#line 6076
      mcnt = (int )((d - pos) - tmp___23);
      {
#line 6083
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 6083
        regstart = (char const   **)((void *)0);
#line 6083
        regend = (char const   **)((void *)0);
#line 6083
        old_regstart = (char const   **)((void *)0);
#line 6083
        old_regend = (char const   **)((void *)0);
#line 6083
        best_regstart = (char const   **)((void *)0);
#line 6083
        best_regend = (char const   **)((void *)0);
#line 6083
        reg_info = (byte_register_info_type *)((void *)0);
#line 6083
        reg_dummy = (char const   **)((void *)0);
#line 6083
        reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 6083
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 6084
      return (mcnt);
    }
#line 6088
    tmp___24 = p;
#line 6088
    p ++;
    {
#line 6092
    if ((unsigned int )((re_opcode_t )*tmp___24) == 0U) {
#line 6092
      goto case_0;
    }
#line 6096
    if ((unsigned int )((re_opcode_t )*tmp___24) == 1U) {
#line 6096
      goto case_1;
    }
#line 6103
    if ((unsigned int )((re_opcode_t )*tmp___24) == 2U) {
#line 6103
      goto case_2;
    }
#line 6151
    if ((unsigned int )((re_opcode_t )*tmp___24) == 3U) {
#line 6151
      goto case_3;
    }
#line 6167
    if ((unsigned int )((re_opcode_t )*tmp___24) == 5U) {
#line 6167
      goto case_5;
    }
#line 6167
    if ((unsigned int )((re_opcode_t )*tmp___24) == 4U) {
#line 6167
      goto case_5;
    }
#line 6576
    if ((unsigned int )((re_opcode_t )*tmp___24) == 6U) {
#line 6576
      goto case_6;
    }
#line 6625
    if ((unsigned int )((re_opcode_t )*tmp___24) == 7U) {
#line 6625
      goto case_7;
    }
#line 6763
    if ((unsigned int )((re_opcode_t )*tmp___24) == 8U) {
#line 6763
      goto case_8;
    }
#line 6829
    if ((unsigned int )((re_opcode_t )*tmp___24) == 9U) {
#line 6829
      goto case_9;
    }
#line 6845
    if ((unsigned int )((re_opcode_t )*tmp___24) == 10U) {
#line 6845
      goto case_10;
    }
#line 6863
    if ((unsigned int )((re_opcode_t )*tmp___24) == 11U) {
#line 6863
      goto case_11;
    }
#line 6871
    if ((unsigned int )((re_opcode_t )*tmp___24) == 12U) {
#line 6871
      goto case_12;
    }
#line 6894
    if ((unsigned int )((re_opcode_t )*tmp___24) == 16U) {
#line 6894
      goto case_16;
    }
#line 6920
    if ((unsigned int )((re_opcode_t )*tmp___24) == 15U) {
#line 6920
      goto on_failure;
    }
#line 6967
    if ((unsigned int )((re_opcode_t )*tmp___24) == 18U) {
#line 6967
      goto case_18___0;
    }
#line 7135
    if ((unsigned int )((re_opcode_t )*tmp___24) == 17U) {
#line 7135
      goto case_17___0;
    }
#line 7162
    if ((unsigned int )((re_opcode_t )*tmp___24) == 13U) {
#line 7162
      goto case_13___0;
    }
#line 7176
    if ((unsigned int )((re_opcode_t )*tmp___24) == 14U) {
#line 7176
      goto case_14;
    }
#line 7186
    if ((unsigned int )((re_opcode_t )*tmp___24) == 19U) {
#line 7186
      goto case_19___0;
    }
#line 7199
    if ((unsigned int )((re_opcode_t )*tmp___24) == 20U) {
#line 7199
      goto case_20;
    }
#line 7208
    if ((unsigned int )((re_opcode_t )*tmp___24) == 21U) {
#line 7208
      goto case_21;
    }
#line 7247
    if ((unsigned int )((re_opcode_t )*tmp___24) == 22U) {
#line 7247
      goto case_22___0;
    }
#line 7271
    if ((unsigned int )((re_opcode_t )*tmp___24) == 23U) {
#line 7271
      goto case_23;
    }
#line 7305
    if ((unsigned int )((re_opcode_t )*tmp___24) == 28U) {
#line 7305
      goto case_28;
    }
#line 7320
    if ((unsigned int )((re_opcode_t )*tmp___24) == 29U) {
#line 7320
      goto case_29;
    }
#line 7336
    if ((unsigned int )((re_opcode_t )*tmp___24) == 26U) {
#line 7336
      goto case_26;
    }
#line 7343
    if ((unsigned int )((re_opcode_t )*tmp___24) == 27U) {
#line 7343
      goto case_27;
    }
#line 7404
    if ((unsigned int )((re_opcode_t )*tmp___24) == 24U) {
#line 7404
      goto case_24;
    }
#line 7413
    if ((unsigned int )((re_opcode_t )*tmp___24) == 25U) {
#line 7413
      goto case_25;
    }
#line 7423
    goto switch_default___0;
    case_0: /* CIL Label */ ;
#line 6094
    goto switch_break;
    case_1: /* CIL Label */ ;
#line 6098
    goto succeed_label;
    case_2: /* CIL Label */ 
#line 6107
    tmp___25 = p;
#line 6107
    p ++;
#line 6107
    mcnt = (int )*tmp___25;
#line 6112
    if (translate) {
      {
#line 6114
      while (1) {
        while_continue___11: /* CIL Label */ ;
        {
#line 6116
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 6116
          if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6116
            goto while_break___12;
          }
#line 6116
          if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6116
            goto fail;
          }
#line 6116
          d = string2;
#line 6116
          dend = end_match_2;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 6130
        tmp___26 = d;
#line 6130
        d ++;
#line 6130
        tmp___27 = p;
#line 6130
        p ++;
#line 6130
        if ((int )((unsigned char )*(translate + (unsigned char )*tmp___26)) != (int )*tmp___27) {
#line 6132
          goto fail;
        }
#line 6114
        mcnt --;
#line 6114
        if (! mcnt) {
#line 6114
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
    } else {
      {
#line 6139
      while (1) {
        while_continue___13: /* CIL Label */ ;
        {
#line 6141
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 6141
          if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6141
            goto while_break___14;
          }
#line 6141
          if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6141
            goto fail;
          }
#line 6141
          d = string2;
#line 6141
          dend = end_match_2;
        }
        while_break___14: /* CIL Label */ ;
        }
#line 6142
        tmp___28 = d;
#line 6142
        d ++;
#line 6142
        tmp___29 = p;
#line 6142
        p ++;
#line 6142
        if ((int const   )*tmp___28 != (int const   )((char )*tmp___29)) {
#line 6142
          goto fail;
        }
#line 6139
        mcnt --;
#line 6139
        if (! mcnt) {
#line 6139
          goto while_break___13;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
    }
    {
#line 6146
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 6146
      if (! set_regs_matched_done) {
#line 6146
        set_regs_matched_done = 1;
#line 6146
        r = lowest_active_reg;
        {
#line 6146
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 6146
          if (! (r <= highest_active_reg)) {
#line 6146
            goto while_break___16;
          }
#line 6146
          tmp___30 = 1U;
#line 6146
          (reg_info + r)->bits.ever_matched_something = tmp___30;
#line 6146
          (reg_info + r)->bits.matched_something = tmp___30;
#line 6146
          r ++;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
#line 6146
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 6147
    goto switch_break;
    case_3: /* CIL Label */ ;
    {
#line 6154
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 6154
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6154
        goto while_break___17;
      }
#line 6154
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6154
        goto fail;
      }
#line 6154
      d = string2;
#line 6154
      dend = end_match_2;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 6156
    if (! (bufp->syntax & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 6156
      if (translate) {
#line 6156
        tmp___31 = (int )*(translate + (unsigned char )*d);
      } else {
#line 6156
        tmp___31 = (int )((char )*d);
      }
#line 6156
      if (tmp___31 == 10) {
#line 6158
        goto fail;
      } else {
#line 6156
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 6156
    if (bufp->syntax & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 6156
      if (translate) {
#line 6156
        tmp___32 = (int )*(translate + (unsigned char )*d);
      } else {
#line 6156
        tmp___32 = (int )((char )*d);
      }
#line 6156
      if (tmp___32 == 0) {
#line 6158
        goto fail;
      }
    }
    {
#line 6160
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 6160
      if (! set_regs_matched_done) {
#line 6160
        set_regs_matched_done = 1;
#line 6160
        r___0 = lowest_active_reg;
        {
#line 6160
        while (1) {
          while_continue___19: /* CIL Label */ ;
#line 6160
          if (! (r___0 <= highest_active_reg)) {
#line 6160
            goto while_break___19;
          }
#line 6160
          tmp___33 = 1U;
#line 6160
          (reg_info + r___0)->bits.ever_matched_something = tmp___33;
#line 6160
          (reg_info + r___0)->bits.matched_something = tmp___33;
#line 6160
          r___0 ++;
        }
        while_break___19: /* CIL Label */ ;
        }
      }
#line 6160
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 6162
    d ++;
#line 6163
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 6180
    negate = (boolean )((unsigned int )((re_opcode_t )*(p - 1)) == 5U);
    {
#line 6183
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 6183
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6183
        goto while_break___20;
      }
#line 6183
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6183
        goto fail;
      }
#line 6183
      d = string2;
#line 6183
      dend = end_match_2;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 6184
    if (translate) {
#line 6184
      c = (unsigned char )*(translate + (unsigned char )*d);
    } else {
#line 6184
      c = (unsigned char )((char )*d);
    }
#line 6556
    if ((unsigned int )c < (unsigned int )((int )*p * 8)) {
#line 6556
      if ((int )*(p + (1 + (int )c / 8)) & (1 << (int )c % 8)) {
#line 6558
        negate = (boolean )(! negate);
      }
    }
#line 6560
    p += 1 + (int )*p;
#line 6562
    if (! negate) {
#line 6562
      goto fail;
    }
    {
#line 6565
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 6565
      if (! set_regs_matched_done) {
#line 6565
        set_regs_matched_done = 1;
#line 6565
        r___1 = lowest_active_reg;
        {
#line 6565
        while (1) {
          while_continue___22: /* CIL Label */ ;
#line 6565
          if (! (r___1 <= highest_active_reg)) {
#line 6565
            goto while_break___22;
          }
#line 6565
          tmp___34 = 1U;
#line 6565
          (reg_info + r___1)->bits.ever_matched_something = tmp___34;
#line 6565
          (reg_info + r___1)->bits.matched_something = tmp___34;
#line 6565
          r___1 ++;
        }
        while_break___22: /* CIL Label */ ;
        }
      }
#line 6565
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
#line 6566
    d ++;
#line 6567
    goto switch_break;
    case_6: /* CIL Label */ 
#line 6581
    p1 = p;
#line 6583
    if ((reg_info + *p)->bits.match_null_string_p == 3U) {
      {
#line 6584
      tmp___35 = byte_group_match_null_string_p(& p1, pend, reg_info);
#line 6584
      (reg_info + *p)->bits.match_null_string_p = (unsigned int )tmp___35;
      }
    }
#line 6592
    if ((reg_info + *p)->bits.match_null_string_p) {
#line 6592
      if ((unsigned long )*(regstart + *p) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6592
        tmp___36 = d;
      } else {
#line 6592
        tmp___36 = *(regstart + *p);
      }
#line 6592
      *(old_regstart + *p) = tmp___36;
    } else {
#line 6592
      *(old_regstart + *p) = *(regstart + *p);
    }
#line 6598
    *(regstart + *p) = d;
#line 6601
    (reg_info + *p)->bits.is_active = 1U;
#line 6602
    (reg_info + *p)->bits.matched_something = 0U;
#line 6605
    set_regs_matched_done = 0;
#line 6608
    highest_active_reg = (active_reg_t )*p;
#line 6612
    if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
#line 6613
      lowest_active_reg = (active_reg_t )*p;
    }
#line 6616
    p += 2;
#line 6617
    just_past_start_mem = p;
#line 6619
    goto switch_break;
    case_7: /* CIL Label */ ;
#line 6634
    if ((reg_info + *p)->bits.match_null_string_p) {
#line 6634
      if ((unsigned long )*(regend + *p) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6634
        tmp___37 = d;
      } else {
#line 6634
        tmp___37 = *(regend + *p);
      }
#line 6634
      *(old_regend + *p) = tmp___37;
    } else {
#line 6634
      *(old_regend + *p) = *(regend + *p);
    }
#line 6640
    *(regend + *p) = d;
#line 6644
    (reg_info + *p)->bits.is_active = 0U;
#line 6647
    set_regs_matched_done = 0;
#line 6651
    if (lowest_active_reg == highest_active_reg) {
#line 6653
      lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 6654
      highest_active_reg = (active_reg_t )(1 << 8);
    } else {
#line 6661
      r___2 = (unsigned char )((int )*p - 1);
      {
#line 6662
      while (1) {
        while_continue___23: /* CIL Label */ ;
#line 6662
        if ((int )r___2 > 0) {
#line 6662
          if (! (! (reg_info + r___2)->bits.is_active)) {
#line 6662
            goto while_break___23;
          }
        } else {
#line 6662
          goto while_break___23;
        }
#line 6663
        r___2 = (unsigned char )((int )r___2 - 1);
      }
      while_break___23: /* CIL Label */ ;
      }
#line 6672
      if ((int )r___2 == 0) {
#line 6674
        lowest_active_reg = (active_reg_t )((1 << 8) + 1);
#line 6675
        highest_active_reg = (active_reg_t )(1 << 8);
      } else {
#line 6678
        highest_active_reg = (active_reg_t )r___2;
      }
    }
#line 6686
    if (! (reg_info + *p)->bits.matched_something) {
#line 6686
      goto _L___12;
    } else
#line 6686
    if ((unsigned long )just_past_start_mem == (unsigned long )(p - 1)) {
      _L___12: /* CIL Label */ 
#line 6686
      if ((unsigned long )(p + 2) < (unsigned long )pend) {
#line 6690
        is_a_jump_n = (boolean )0;
#line 6692
        p1 = p + 2;
#line 6693
        mcnt = 0;
#line 6694
        tmp___38 = p1;
#line 6694
        p1 ++;
        {
#line 6696
        if ((unsigned int )((re_opcode_t )*tmp___38) == 22U) {
#line 6696
          goto case_22;
        }
#line 6701
        if ((unsigned int )((re_opcode_t )*tmp___38) == 19U) {
#line 6701
          goto case_19;
        }
#line 6701
        if ((unsigned int )((re_opcode_t )*tmp___38) == 13U) {
#line 6701
          goto case_19;
        }
#line 6701
        if ((unsigned int )((re_opcode_t )*tmp___38) == 18U) {
#line 6701
          goto case_19;
        }
#line 6701
        if ((unsigned int )((re_opcode_t )*tmp___38) == 17U) {
#line 6701
          goto case_19;
        }
#line 6707
        goto switch_default;
        case_22: /* CIL Label */ 
#line 6697
        is_a_jump_n = (boolean )1;
        case_19: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_17: /* CIL Label */ 
        {
#line 6702
        while (1) {
          while_continue___24: /* CIL Label */ ;
          {
#line 6702
          while (1) {
            while_continue___25: /* CIL Label */ ;
#line 6702
            mcnt = (int )*p1 & 255;
#line 6702
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 6702
            goto while_break___25;
          }
          while_break___25: /* CIL Label */ ;
          }
#line 6702
          p1 += 2;
#line 6702
          goto while_break___24;
        }
        while_break___24: /* CIL Label */ ;
        }
#line 6703
        if (is_a_jump_n) {
#line 6704
          p1 += 2;
        }
#line 6705
        goto switch_break___0;
        switch_default: /* CIL Label */ ;
        switch_break___0: /* CIL Label */ ;
        }
#line 6710
        p1 += mcnt;
#line 6717
        if (mcnt < 0) {
#line 6717
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 6717
            if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 6U) {
#line 6717
              if ((int )*(p1 + 4) == (int )*p) {
#line 6731
                if ((reg_info + *p)->bits.ever_matched_something) {
#line 6735
                  (reg_info + *p)->bits.ever_matched_something = 0U;
#line 6738
                  r___3 = (unsigned int )*p;
                  {
#line 6738
                  while (1) {
                    while_continue___26: /* CIL Label */ ;
#line 6738
                    if (! (r___3 < (unsigned int )*p + (unsigned int )*(p + 1))) {
#line 6738
                      goto while_break___26;
                    }
#line 6741
                    *(regstart + r___3) = *(old_regstart + r___3);
#line 6744
                    if ((unsigned long )*(old_regend + r___3) >= (unsigned long )*(regstart + r___3)) {
#line 6745
                      *(regend + r___3) = *(old_regend + r___3);
                    }
#line 6738
                    r___3 ++;
                  }
                  while_break___26: /* CIL Label */ ;
                  }
                }
#line 6748
                p1 ++;
                {
#line 6749
                while (1) {
                  while_continue___27: /* CIL Label */ ;
                  {
#line 6749
                  while (1) {
                    while_continue___28: /* CIL Label */ ;
#line 6749
                    mcnt = (int )*p1 & 255;
#line 6749
                    mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 6749
                    goto while_break___28;
                  }
                  while_break___28: /* CIL Label */ ;
                  }
#line 6749
                  p1 += 2;
#line 6749
                  goto while_break___27;
                }
                while_break___27: /* CIL Label */ ;
                }
                {
#line 6750
                while (1) {
                  while_continue___29: /* CIL Label */ ;
                  {
#line 6750
                  while (1) {
                    while_continue___30: /* CIL Label */ ;
#line 6750
                    if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 6750
                      goto while_break___30;
                    }
#line 6750
                    if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 6750
                      tmp___42 = 0;
                    } else {
                      {
#line 6750
                      tmp___39 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 6750
                      destination = (char *)tmp___39;
#line 6750
                      tmp___40 = memcpy((void */* __restrict  */)destination, (void const   */* __restrict  */)fail_stack.stack,
                                        (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 6750
                      fail_stack.stack = (byte_fail_stack_elt_t *)tmp___40;
                      }
#line 6750
                      if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 6750
                        tmp___41 = 0;
                      } else {
#line 6750
                        fail_stack.size <<= 1;
#line 6750
                        tmp___41 = 1;
                      }
#line 6750
                      tmp___42 = tmp___41;
                    }
#line 6750
                    if (! tmp___42) {
#line 6750
                      return (-2);
                    }
                  }
                  while_break___30: /* CIL Label */ ;
                  }
#line 6750
                  this_reg = lowest_active_reg;
                  {
#line 6750
                  while (1) {
                    while_continue___31: /* CIL Label */ ;
#line 6750
                    if (! (this_reg <= highest_active_reg)) {
#line 6750
                      goto while_break___31;
                    }
#line 6750
                    tmp___43 = fail_stack.avail;
#line 6750
                    (fail_stack.avail) ++;
#line 6750
                    (fail_stack.stack + tmp___43)->pointer = (unsigned char *)*(regstart + this_reg);
#line 6750
                    tmp___44 = fail_stack.avail;
#line 6750
                    (fail_stack.avail) ++;
#line 6750
                    (fail_stack.stack + tmp___44)->pointer = (unsigned char *)*(regend + this_reg);
#line 6750
                    tmp___45 = fail_stack.avail;
#line 6750
                    (fail_stack.avail) ++;
#line 6750
                    *(fail_stack.stack + tmp___45) = (reg_info + this_reg)->word;
#line 6750
                    this_reg ++;
                  }
                  while_break___31: /* CIL Label */ ;
                  }
#line 6750
                  tmp___46 = fail_stack.avail;
#line 6750
                  (fail_stack.avail) ++;
#line 6750
                  (fail_stack.stack + tmp___46)->integer = (int )lowest_active_reg;
#line 6750
                  tmp___47 = fail_stack.avail;
#line 6750
                  (fail_stack.avail) ++;
#line 6750
                  (fail_stack.stack + tmp___47)->integer = (int )highest_active_reg;
#line 6750
                  tmp___48 = fail_stack.avail;
#line 6750
                  (fail_stack.avail) ++;
#line 6750
                  (fail_stack.stack + tmp___48)->pointer = p1 + mcnt;
#line 6750
                  tmp___49 = fail_stack.avail;
#line 6750
                  (fail_stack.avail) ++;
#line 6750
                  (fail_stack.stack + tmp___49)->pointer = (unsigned char *)d;
#line 6750
                  goto while_break___29;
                }
                while_break___29: /* CIL Label */ ;
                }
#line 6752
                goto fail;
              }
            }
          }
        }
      }
    }
#line 6757
    p += 2;
#line 6758
    goto switch_break;
    case_8: /* CIL Label */ 
#line 6766
    tmp___50 = p;
#line 6766
    p ++;
#line 6766
    regno = (int )*tmp___50;
#line 6770
    if ((unsigned long )*(regstart + regno) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6771
      goto fail;
    } else
#line 6770
    if ((unsigned long )*(regend + regno) == (unsigned long )(& byte_reg_unset_dummy)) {
#line 6771
      goto fail;
    }
#line 6774
    d2 = *(regstart + regno);
#line 6781
    if (size1) {
#line 6781
      if ((unsigned long )string1 <= (unsigned long )*(regstart + regno)) {
#line 6781
        if ((unsigned long )*(regstart + regno) <= (unsigned long )(string1 + size1)) {
#line 6781
          tmp___52 = 1;
        } else {
#line 6781
          tmp___52 = 0;
        }
      } else {
#line 6781
        tmp___52 = 0;
      }
    } else {
#line 6781
      tmp___52 = 0;
    }
#line 6781
    if (size1) {
#line 6781
      if ((unsigned long )string1 <= (unsigned long )*(regend + regno)) {
#line 6781
        if ((unsigned long )*(regend + regno) <= (unsigned long )(string1 + size1)) {
#line 6781
          tmp___53 = 1;
        } else {
#line 6781
          tmp___53 = 0;
        }
      } else {
#line 6781
        tmp___53 = 0;
      }
    } else {
#line 6781
      tmp___53 = 0;
    }
#line 6781
    if (tmp___52 == tmp___53) {
#line 6781
      dend2 = *(regend + regno);
    } else {
#line 6781
      dend2 = end_match_1;
    }
    {
#line 6784
    while (1) {
      while_continue___32: /* CIL Label */ ;
      {
#line 6788
      while (1) {
        while_continue___33: /* CIL Label */ ;
#line 6788
        if (! ((unsigned long )d2 == (unsigned long )dend2)) {
#line 6788
          goto while_break___33;
        }
#line 6790
        if ((unsigned long )dend2 == (unsigned long )end_match_2) {
#line 6790
          goto while_break___33;
        }
#line 6791
        if ((unsigned long )dend2 == (unsigned long )*(regend + regno)) {
#line 6791
          goto while_break___33;
        }
#line 6794
        d2 = string2;
#line 6795
        dend2 = *(regend + regno);
      }
      while_break___33: /* CIL Label */ ;
      }
#line 6798
      if ((unsigned long )d2 == (unsigned long )dend2) {
#line 6798
        goto while_break___32;
      }
      {
#line 6801
      while (1) {
        while_continue___34: /* CIL Label */ ;
#line 6801
        if (! ((unsigned long )d == (unsigned long )dend)) {
#line 6801
          goto while_break___34;
        }
#line 6801
        if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 6801
          goto fail;
        }
#line 6801
        d = string2;
#line 6801
        dend = end_match_2;
      }
      while_break___34: /* CIL Label */ ;
      }
#line 6804
      mcnt = (int )(dend - d);
#line 6808
      if ((long )mcnt > dend2 - d2) {
#line 6809
        mcnt = (int )(dend2 - d2);
      }
#line 6813
      if (translate) {
        {
#line 6813
        tmp___54 = byte_bcmp_translate(d, d2, mcnt, translate);
#line 6813
        tmp___56 = tmp___54;
        }
      } else {
        {
#line 6813
        tmp___55 = memcmp((void const   *)d, (void const   *)d2, (unsigned long )mcnt * sizeof(unsigned char ));
#line 6813
        tmp___56 = tmp___55;
        }
      }
#line 6813
      if (tmp___56) {
#line 6816
        goto fail;
      }
#line 6817
      d += mcnt;
#line 6817
      d2 += mcnt;
      {
#line 6820
      while (1) {
        while_continue___35: /* CIL Label */ ;
#line 6820
        if (! set_regs_matched_done) {
#line 6820
          set_regs_matched_done = 1;
#line 6820
          r___4 = lowest_active_reg;
          {
#line 6820
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 6820
            if (! (r___4 <= highest_active_reg)) {
#line 6820
              goto while_break___36;
            }
#line 6820
            tmp___57 = 1U;
#line 6820
            (reg_info + r___4)->bits.ever_matched_something = tmp___57;
#line 6820
            (reg_info + r___4)->bits.matched_something = tmp___57;
#line 6820
            r___4 ++;
          }
          while_break___36: /* CIL Label */ ;
          }
        }
#line 6820
        goto while_break___35;
      }
      while_break___35: /* CIL Label */ ;
      }
    }
    while_break___32: /* CIL Label */ ;
    }
#line 6823
    goto switch_break;
    case_9: /* CIL Label */ ;
#line 6832
    if (size1) {
#line 6832
      tmp___58 = string1;
    } else {
#line 6832
      tmp___58 = string2;
    }
#line 6832
    if ((unsigned long )d == (unsigned long )tmp___58) {
#line 6832
      goto _L___13;
    } else
#line 6832
    if (! size2) {
      _L___13: /* CIL Label */ 
#line 6834
      if (! bufp->not_bol) {
#line 6834
        goto switch_break;
      }
    } else
#line 6836
    if ((int const   )*(d + -1) == 10) {
#line 6836
      if (bufp->newline_anchor) {
#line 6838
        goto switch_break;
      }
    }
#line 6841
    goto fail;
    case_10: /* CIL Label */ ;
#line 6848
    if ((unsigned long )d == (unsigned long )end2) {
#line 6850
      if (! bufp->not_eol) {
#line 6850
        goto switch_break;
      }
    } else {
#line 6854
      if ((unsigned long )d == (unsigned long )end1) {
#line 6854
        tmp___59 = (int const   )*string2;
      } else {
#line 6854
        tmp___59 = (int const   )*d;
      }
#line 6854
      if (tmp___59 == 10) {
#line 6854
        if (bufp->newline_anchor) {
#line 6857
          goto switch_break;
        }
      }
    }
#line 6859
    goto fail;
    case_11: /* CIL Label */ ;
#line 6865
    if (size1) {
#line 6865
      tmp___60 = string1;
    } else {
#line 6865
      tmp___60 = string2;
    }
#line 6865
    if ((unsigned long )d == (unsigned long )tmp___60) {
#line 6866
      goto switch_break;
    } else
#line 6865
    if (! size2) {
#line 6866
      goto switch_break;
    }
#line 6867
    goto fail;
    case_12: /* CIL Label */ ;
#line 6873
    if ((unsigned long )d == (unsigned long )end2) {
#line 6874
      goto switch_break;
    }
#line 6875
    goto fail;
    case_16: /* CIL Label */ ;
    {
#line 6897
    while (1) {
      while_continue___37: /* CIL Label */ ;
      {
#line 6897
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 6897
        mcnt = (int )*p & 255;
#line 6897
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 6897
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 6897
      p += 2;
#line 6897
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 6904
    while (1) {
      while_continue___39: /* CIL Label */ ;
      {
#line 6904
      while (1) {
        while_continue___40: /* CIL Label */ ;
#line 6904
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 6904
          goto while_break___40;
        }
#line 6904
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 6904
          tmp___64 = 0;
        } else {
          {
#line 6904
          tmp___61 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 6904
          destination___0 = (char *)tmp___61;
#line 6904
          tmp___62 = memcpy((void */* __restrict  */)destination___0, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 6904
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___62;
          }
#line 6904
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 6904
            tmp___63 = 0;
          } else {
#line 6904
            fail_stack.size <<= 1;
#line 6904
            tmp___63 = 1;
          }
#line 6904
          tmp___64 = tmp___63;
        }
#line 6904
        if (! tmp___64) {
#line 6904
          return (-2);
        }
      }
      while_break___40: /* CIL Label */ ;
      }
#line 6904
      this_reg___0 = lowest_active_reg;
      {
#line 6904
      while (1) {
        while_continue___41: /* CIL Label */ ;
#line 6904
        if (! (this_reg___0 <= highest_active_reg)) {
#line 6904
          goto while_break___41;
        }
#line 6904
        tmp___65 = fail_stack.avail;
#line 6904
        (fail_stack.avail) ++;
#line 6904
        (fail_stack.stack + tmp___65)->pointer = (unsigned char *)*(regstart + this_reg___0);
#line 6904
        tmp___66 = fail_stack.avail;
#line 6904
        (fail_stack.avail) ++;
#line 6904
        (fail_stack.stack + tmp___66)->pointer = (unsigned char *)*(regend + this_reg___0);
#line 6904
        tmp___67 = fail_stack.avail;
#line 6904
        (fail_stack.avail) ++;
#line 6904
        *(fail_stack.stack + tmp___67) = (reg_info + this_reg___0)->word;
#line 6904
        this_reg___0 ++;
      }
      while_break___41: /* CIL Label */ ;
      }
#line 6904
      tmp___68 = fail_stack.avail;
#line 6904
      (fail_stack.avail) ++;
#line 6904
      (fail_stack.stack + tmp___68)->integer = (int )lowest_active_reg;
#line 6904
      tmp___69 = fail_stack.avail;
#line 6904
      (fail_stack.avail) ++;
#line 6904
      (fail_stack.stack + tmp___69)->integer = (int )highest_active_reg;
#line 6904
      tmp___70 = fail_stack.avail;
#line 6904
      (fail_stack.avail) ++;
#line 6904
      (fail_stack.stack + tmp___70)->pointer = p + mcnt;
#line 6904
      tmp___71 = fail_stack.avail;
#line 6904
      (fail_stack.avail) ++;
#line 6904
      (fail_stack.stack + tmp___71)->pointer = (unsigned char *)((void *)0);
#line 6904
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
#line 6905
    goto switch_break;
    on_failure: 
    case_15: /* CIL Label */ ;
    {
#line 6924
    while (1) {
      while_continue___42: /* CIL Label */ ;
      {
#line 6924
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 6924
        mcnt = (int )*p & 255;
#line 6924
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 6924
        goto while_break___43;
      }
      while_break___43: /* CIL Label */ ;
      }
#line 6924
      p += 2;
#line 6924
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 6940
    p1 = p;
    {
#line 6946
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 6946
      if ((unsigned long )p1 < (unsigned long )pend) {
#line 6946
        if (! ((unsigned int )((re_opcode_t )*p1) == 0U)) {
#line 6946
          goto while_break___44;
        }
      } else {
#line 6946
        goto while_break___44;
      }
#line 6947
      p1 ++;
    }
    while_break___44: /* CIL Label */ ;
    }
#line 6949
    if ((unsigned long )p1 < (unsigned long )pend) {
#line 6949
      if ((unsigned int )((re_opcode_t )*p1) == 6U) {
#line 6955
        highest_active_reg = (active_reg_t )((int )*(p1 + 1) + (int )*(p1 + 2));
#line 6956
        if (lowest_active_reg == (active_reg_t )((1 << 8) + 1)) {
#line 6957
          lowest_active_reg = (active_reg_t )*(p1 + 1);
        }
      }
    }
    {
#line 6961
    while (1) {
      while_continue___45: /* CIL Label */ ;
      {
#line 6961
      while (1) {
        while_continue___46: /* CIL Label */ ;
#line 6961
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 6961
          goto while_break___46;
        }
#line 6961
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 6961
          tmp___75 = 0;
        } else {
          {
#line 6961
          tmp___72 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 6961
          destination___1 = (char *)tmp___72;
#line 6961
          tmp___73 = memcpy((void */* __restrict  */)destination___1, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 6961
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___73;
          }
#line 6961
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 6961
            tmp___74 = 0;
          } else {
#line 6961
            fail_stack.size <<= 1;
#line 6961
            tmp___74 = 1;
          }
#line 6961
          tmp___75 = tmp___74;
        }
#line 6961
        if (! tmp___75) {
#line 6961
          return (-2);
        }
      }
      while_break___46: /* CIL Label */ ;
      }
#line 6961
      this_reg___1 = lowest_active_reg;
      {
#line 6961
      while (1) {
        while_continue___47: /* CIL Label */ ;
#line 6961
        if (! (this_reg___1 <= highest_active_reg)) {
#line 6961
          goto while_break___47;
        }
#line 6961
        tmp___76 = fail_stack.avail;
#line 6961
        (fail_stack.avail) ++;
#line 6961
        (fail_stack.stack + tmp___76)->pointer = (unsigned char *)*(regstart + this_reg___1);
#line 6961
        tmp___77 = fail_stack.avail;
#line 6961
        (fail_stack.avail) ++;
#line 6961
        (fail_stack.stack + tmp___77)->pointer = (unsigned char *)*(regend + this_reg___1);
#line 6961
        tmp___78 = fail_stack.avail;
#line 6961
        (fail_stack.avail) ++;
#line 6961
        *(fail_stack.stack + tmp___78) = (reg_info + this_reg___1)->word;
#line 6961
        this_reg___1 ++;
      }
      while_break___47: /* CIL Label */ ;
      }
#line 6961
      tmp___79 = fail_stack.avail;
#line 6961
      (fail_stack.avail) ++;
#line 6961
      (fail_stack.stack + tmp___79)->integer = (int )lowest_active_reg;
#line 6961
      tmp___80 = fail_stack.avail;
#line 6961
      (fail_stack.avail) ++;
#line 6961
      (fail_stack.stack + tmp___80)->integer = (int )highest_active_reg;
#line 6961
      tmp___81 = fail_stack.avail;
#line 6961
      (fail_stack.avail) ++;
#line 6961
      (fail_stack.stack + tmp___81)->pointer = p + mcnt;
#line 6961
      tmp___82 = fail_stack.avail;
#line 6961
      (fail_stack.avail) ++;
#line 6961
      (fail_stack.stack + tmp___82)->pointer = (unsigned char *)d;
#line 6961
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
#line 6962
    goto switch_break;
    case_18___0: /* CIL Label */ 
    {
#line 6968
    while (1) {
      while_continue___48: /* CIL Label */ ;
      {
#line 6968
      while (1) {
        while_continue___49: /* CIL Label */ ;
#line 6968
        mcnt = (int )*p & 255;
#line 6968
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 6968
        goto while_break___49;
      }
      while_break___49: /* CIL Label */ ;
      }
#line 6968
      p += 2;
#line 6968
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
#line 6971
    p2 = p;
    {
#line 6990
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 6992
      if ((unsigned long )(p2 + 2) < (unsigned long )pend) {
#line 6992
        if ((unsigned int )((re_opcode_t )*p2) == 7U) {
#line 6995
          p2 += 3;
        } else
#line 6992
        if ((unsigned int )((re_opcode_t )*p2) == 6U) {
#line 6995
          p2 += 3;
        } else {
#line 6992
          goto _L___14;
        }
      } else
      _L___14: /* CIL Label */ 
#line 6996
      if ((unsigned long )((p2 + 2) + 4) < (unsigned long )pend) {
#line 6996
        if ((unsigned int )((re_opcode_t )*p2) == 19U) {
#line 6998
          p2 += 6;
        } else {
#line 7000
          goto while_break___50;
        }
      } else {
#line 7000
        goto while_break___50;
      }
    }
    while_break___50: /* CIL Label */ ;
    }
#line 7003
    p1 = p + mcnt;
#line 7009
    if ((unsigned long )p2 == (unsigned long )pend) {
#line 7014
      *(p + -3) = (unsigned char)17;
    } else
#line 7020
    if ((unsigned int )((re_opcode_t )*p2) == 2U) {
#line 7020
      goto _L___18;
    } else
#line 7020
    if (bufp->newline_anchor) {
#line 7020
      if ((unsigned int )((re_opcode_t )*p2) == 10U) {
        _L___18: /* CIL Label */ 
#line 7026
        if ((int )*p2 == 10) {
#line 7026
          tmp___83 = '\n';
        } else {
#line 7026
          tmp___83 = (int )*(p2 + 2);
        }
#line 7026
        c___0 = (unsigned char )tmp___83;
#line 7029
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
#line 7029
          if ((int )*(p1 + 5) != (int )c___0) {
#line 7035
            *(p + -3) = (unsigned char)17;
          } else {
#line 7029
            goto _L___16;
          }
        } else
        _L___16: /* CIL Label */ 
#line 7049
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
#line 7049
          goto _L___15;
        } else
#line 7049
        if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
          _L___15: /* CIL Label */ 
#line 7052
          negate___0 = (unsigned int )((re_opcode_t )*(p1 + 3)) == 5U;
#line 7054
          if ((unsigned int )c___0 < (unsigned int )((int )*(p1 + 4) * 8)) {
#line 7054
            if ((int )*(p1 + (5 + (int )c___0 / 8)) & (1 << (int )c___0 % 8)) {
#line 7056
              negate___0 = ! negate___0;
            }
          }
#line 7060
          if (! negate___0) {
#line 7062
            *(p + -3) = (unsigned char)17;
          }
        }
      } else {
#line 7020
        goto _L___19;
      }
    } else
    _L___19: /* CIL Label */ 
#line 7069
    if ((unsigned int )((re_opcode_t )*p2) == 4U) {
#line 7073
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 2U) {
#line 7073
        if ((int )*(p2 + 1) * 8 > (int )*(p1 + 5)) {
#line 7073
          if ((int )*(p2 + (2 + (int )*(p1 + 5) / 8)) & (1 << (int )*(p1 + 5) % 8)) {
#line 7073
            goto _L___17;
          } else {
#line 7078
            *(p + -3) = (unsigned char)17;
          }
        } else {
#line 7078
          *(p + -3) = (unsigned char)17;
        }
      } else
      _L___17: /* CIL Label */ 
#line 7082
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 5U) {
#line 7087
        idx___0 = 0;
        {
#line 7087
        while (1) {
          while_continue___51: /* CIL Label */ ;
#line 7087
          if (! (idx___0 < (int )*(p2 + 1))) {
#line 7087
            goto while_break___51;
          }
#line 7088
          if (! ((int )*(p2 + (2 + idx___0)) == 0)) {
#line 7088
            if (idx___0 < (int )*(p1 + 4)) {
#line 7088
              if (! (((int )*(p2 + (2 + idx___0)) & ~ ((int )*(p1 + (5 + idx___0)))) == 0)) {
#line 7091
                goto while_break___51;
              }
            } else {
#line 7091
              goto while_break___51;
            }
          }
#line 7087
          idx___0 ++;
        }
        while_break___51: /* CIL Label */ ;
        }
#line 7093
        if (idx___0 == (int )*(p2 + 1)) {
#line 7095
          *(p + -3) = (unsigned char)17;
        }
      } else
#line 7099
      if ((unsigned int )((re_opcode_t )*(p1 + 3)) == 4U) {
#line 7104
        idx___1 = 0;
        {
#line 7104
        while (1) {
          while_continue___52: /* CIL Label */ ;
#line 7104
          if (idx___1 < (int )*(p2 + 1)) {
#line 7104
            if (! (idx___1 < (int )*(p1 + 4))) {
#line 7104
              goto while_break___52;
            }
          } else {
#line 7104
            goto while_break___52;
          }
#line 7107
          if (((int )*(p2 + (2 + idx___1)) & (int )*(p1 + (5 + idx___1))) != 0) {
#line 7108
            goto while_break___52;
          }
#line 7104
          idx___1 ++;
        }
        while_break___52: /* CIL Label */ ;
        }
#line 7110
        if (idx___1 == (int )*(p2 + 1)) {
#line 7112
          *(p + -3) = (unsigned char)17;
        } else
#line 7110
        if (idx___1 == (int )*(p1 + 4)) {
#line 7112
          *(p + -3) = (unsigned char)17;
        }
      }
    }
#line 7119
    p -= 2;
#line 7120
    if ((unsigned int )((re_opcode_t )*(p + -1)) != 17U) {
#line 7122
      *(p + -1) = (unsigned char)13;
#line 7124
      goto unconditional_jump;
    }
    case_17___0: /* CIL Label */ 
#line 7143
    pdummy = (unsigned char *)((void *)0);
#line 7144
    sdummy = (char const   *)((void *)0);
#line 7147
    (fail_stack.avail) --;
#line 7147
    string_temp = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7147
    if ((unsigned long )string_temp != (unsigned long )((void *)0)) {
#line 7147
      sdummy = (char const   *)string_temp;
    }
#line 7147
    (fail_stack.avail) --;
#line 7147
    pdummy = (fail_stack.stack + fail_stack.avail)->pointer;
#line 7147
    (fail_stack.avail) --;
#line 7147
    dummy_high_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7147
    (fail_stack.avail) --;
#line 7147
    dummy_low_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7147
    this_reg___2 = dummy_high_reg;
    {
#line 7147
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 7147
      if (! (this_reg___2 >= dummy_low_reg)) {
#line 7147
        goto while_break___53;
      }
#line 7147
      (fail_stack.avail) --;
#line 7147
      (reg_info_dummy + this_reg___2)->word = *(fail_stack.stack + fail_stack.avail);
#line 7147
      (fail_stack.avail) --;
#line 7147
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7147
      (fail_stack.avail) --;
#line 7147
      *(reg_dummy + this_reg___2) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7147
      this_reg___2 --;
    }
    while_break___53: /* CIL Label */ ;
    }
#line 7147
    set_regs_matched_done = 0;
    unconditional_jump: ;
    case_13___0: /* CIL Label */ 
    {
#line 7163
    while (1) {
      while_continue___54: /* CIL Label */ ;
      {
#line 7163
      while (1) {
        while_continue___55: /* CIL Label */ ;
#line 7163
        mcnt = (int )*p & 255;
#line 7163
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 7163
        goto while_break___55;
      }
      while_break___55: /* CIL Label */ ;
      }
#line 7163
      p += 2;
#line 7163
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
#line 7165
    p += mcnt;
#line 7171
    goto switch_break;
    case_14: /* CIL Label */ ;
#line 7178
    goto unconditional_jump;
    case_19___0: /* CIL Label */ ;
    {
#line 7190
    while (1) {
      while_continue___56: /* CIL Label */ ;
      {
#line 7190
      while (1) {
        while_continue___57: /* CIL Label */ ;
#line 7190
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 7190
          goto while_break___57;
        }
#line 7190
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 7190
          tmp___87 = 0;
        } else {
          {
#line 7190
          tmp___84 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 7190
          destination___2 = (char *)tmp___84;
#line 7190
          tmp___85 = memcpy((void */* __restrict  */)destination___2, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 7190
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___85;
          }
#line 7190
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 7190
            tmp___86 = 0;
          } else {
#line 7190
            fail_stack.size <<= 1;
#line 7190
            tmp___86 = 1;
          }
#line 7190
          tmp___87 = tmp___86;
        }
#line 7190
        if (! tmp___87) {
#line 7190
          return (-2);
        }
      }
      while_break___57: /* CIL Label */ ;
      }
#line 7190
      this_reg___3 = lowest_active_reg;
      {
#line 7190
      while (1) {
        while_continue___58: /* CIL Label */ ;
#line 7190
        if (! (this_reg___3 <= highest_active_reg)) {
#line 7190
          goto while_break___58;
        }
#line 7190
        tmp___88 = fail_stack.avail;
#line 7190
        (fail_stack.avail) ++;
#line 7190
        (fail_stack.stack + tmp___88)->pointer = (unsigned char *)*(regstart + this_reg___3);
#line 7190
        tmp___89 = fail_stack.avail;
#line 7190
        (fail_stack.avail) ++;
#line 7190
        (fail_stack.stack + tmp___89)->pointer = (unsigned char *)*(regend + this_reg___3);
#line 7190
        tmp___90 = fail_stack.avail;
#line 7190
        (fail_stack.avail) ++;
#line 7190
        *(fail_stack.stack + tmp___90) = (reg_info + this_reg___3)->word;
#line 7190
        this_reg___3 ++;
      }
      while_break___58: /* CIL Label */ ;
      }
#line 7190
      tmp___91 = fail_stack.avail;
#line 7190
      (fail_stack.avail) ++;
#line 7190
      (fail_stack.stack + tmp___91)->integer = (int )lowest_active_reg;
#line 7190
      tmp___92 = fail_stack.avail;
#line 7190
      (fail_stack.avail) ++;
#line 7190
      (fail_stack.stack + tmp___92)->integer = (int )highest_active_reg;
#line 7190
      tmp___93 = fail_stack.avail;
#line 7190
      (fail_stack.avail) ++;
#line 7190
      (fail_stack.stack + tmp___93)->pointer = (unsigned char *)((void *)0);
#line 7190
      tmp___94 = fail_stack.avail;
#line 7190
      (fail_stack.avail) ++;
#line 7190
      (fail_stack.stack + tmp___94)->pointer = (unsigned char *)((void *)0);
#line 7190
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
#line 7191
    goto unconditional_jump;
    case_20: /* CIL Label */ ;
    {
#line 7203
    while (1) {
      while_continue___59: /* CIL Label */ ;
      {
#line 7203
      while (1) {
        while_continue___60: /* CIL Label */ ;
#line 7203
        if (! ((active_reg_t )(fail_stack.size - fail_stack.avail) < ((highest_active_reg - lowest_active_reg) + 1UL) * 3UL + 4UL)) {
#line 7203
          goto while_break___60;
        }
#line 7203
        if (fail_stack.size > (unsigned int )(xre_max_failures * 19)) {
#line 7203
          tmp___98 = 0;
        } else {
          {
#line 7203
          tmp___95 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(byte_fail_stack_elt_t ));
#line 7203
          destination___3 = (char *)tmp___95;
#line 7203
          tmp___96 = memcpy((void */* __restrict  */)destination___3, (void const   */* __restrict  */)fail_stack.stack,
                            (unsigned long )fail_stack.size * sizeof(byte_fail_stack_elt_t ));
#line 7203
          fail_stack.stack = (byte_fail_stack_elt_t *)tmp___96;
          }
#line 7203
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
#line 7203
            tmp___97 = 0;
          } else {
#line 7203
            fail_stack.size <<= 1;
#line 7203
            tmp___97 = 1;
          }
#line 7203
          tmp___98 = tmp___97;
        }
#line 7203
        if (! tmp___98) {
#line 7203
          return (-2);
        }
      }
      while_break___60: /* CIL Label */ ;
      }
#line 7203
      this_reg___4 = lowest_active_reg;
      {
#line 7203
      while (1) {
        while_continue___61: /* CIL Label */ ;
#line 7203
        if (! (this_reg___4 <= highest_active_reg)) {
#line 7203
          goto while_break___61;
        }
#line 7203
        tmp___99 = fail_stack.avail;
#line 7203
        (fail_stack.avail) ++;
#line 7203
        (fail_stack.stack + tmp___99)->pointer = (unsigned char *)*(regstart + this_reg___4);
#line 7203
        tmp___100 = fail_stack.avail;
#line 7203
        (fail_stack.avail) ++;
#line 7203
        (fail_stack.stack + tmp___100)->pointer = (unsigned char *)*(regend + this_reg___4);
#line 7203
        tmp___101 = fail_stack.avail;
#line 7203
        (fail_stack.avail) ++;
#line 7203
        *(fail_stack.stack + tmp___101) = (reg_info + this_reg___4)->word;
#line 7203
        this_reg___4 ++;
      }
      while_break___61: /* CIL Label */ ;
      }
#line 7203
      tmp___102 = fail_stack.avail;
#line 7203
      (fail_stack.avail) ++;
#line 7203
      (fail_stack.stack + tmp___102)->integer = (int )lowest_active_reg;
#line 7203
      tmp___103 = fail_stack.avail;
#line 7203
      (fail_stack.avail) ++;
#line 7203
      (fail_stack.stack + tmp___103)->integer = (int )highest_active_reg;
#line 7203
      tmp___104 = fail_stack.avail;
#line 7203
      (fail_stack.avail) ++;
#line 7203
      (fail_stack.stack + tmp___104)->pointer = (unsigned char *)((void *)0);
#line 7203
      tmp___105 = fail_stack.avail;
#line 7203
      (fail_stack.avail) ++;
#line 7203
      (fail_stack.stack + tmp___105)->pointer = (unsigned char *)((void *)0);
#line 7203
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
#line 7204
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 7209
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 7209
      mcnt = (int )*(p + 2) & 255;
#line 7209
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
#line 7209
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
#line 7214
    if (mcnt > 0) {
#line 7216
      mcnt --;
#line 7217
      p += 2;
      {
#line 7218
      while (1) {
        while_continue___63: /* CIL Label */ ;
        {
#line 7218
        while (1) {
          while_continue___64: /* CIL Label */ ;
#line 7218
          *(p + 0) = (unsigned char )(mcnt & 255);
#line 7218
          *(p + 1) = (unsigned char )(mcnt >> 8);
#line 7218
          goto while_break___64;
        }
        while_break___64: /* CIL Label */ ;
        }
#line 7218
        p += 2;
#line 7218
        goto while_break___63;
      }
      while_break___63: /* CIL Label */ ;
      }
    } else
#line 7227
    if (mcnt == 0) {
#line 7240
      *(p + 2) = (unsigned char)0;
#line 7241
      *(p + 3) = (unsigned char)0;
#line 7243
      goto on_failure;
    }
#line 7245
    goto switch_break;
    case_22___0: /* CIL Label */ 
    {
#line 7248
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 7248
      mcnt = (int )*(p + 2) & 255;
#line 7248
      mcnt += (int )((signed char )*((p + 2) + 1)) << 8;
#line 7248
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
#line 7252
    if (mcnt) {
#line 7254
      mcnt --;
      {
#line 7255
      while (1) {
        while_continue___66: /* CIL Label */ ;
#line 7255
        *((p + 2) + 0) = (unsigned char )(mcnt & 255);
#line 7255
        *((p + 2) + 1) = (unsigned char )(mcnt >> 8);
#line 7255
        goto while_break___66;
      }
      while_break___66: /* CIL Label */ ;
      }
#line 7264
      goto unconditional_jump;
    } else {
#line 7268
      p += 4;
    }
#line 7269
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 7275
    while (1) {
      while_continue___67: /* CIL Label */ ;
      {
#line 7275
      while (1) {
        while_continue___68: /* CIL Label */ ;
#line 7275
        mcnt = (int )*p & 255;
#line 7275
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 7275
        goto while_break___68;
      }
      while_break___68: /* CIL Label */ ;
      }
#line 7275
      p += 2;
#line 7275
      goto while_break___67;
    }
    while_break___67: /* CIL Label */ ;
    }
#line 7276
    p1 = p + mcnt;
    {
#line 7277
    while (1) {
      while_continue___69: /* CIL Label */ ;
      {
#line 7277
      while (1) {
        while_continue___70: /* CIL Label */ ;
#line 7277
        mcnt = (int )*p & 255;
#line 7277
        mcnt += (int )((signed char )*(p + 1)) << 8;
#line 7277
        goto while_break___70;
      }
      while_break___70: /* CIL Label */ ;
      }
#line 7277
      p += 2;
#line 7277
      goto while_break___69;
    }
    while_break___69: /* CIL Label */ ;
    }
    {
#line 7283
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 7283
      *(p1 + 0) = (unsigned char )(mcnt & 255);
#line 7283
      *(p1 + 1) = (unsigned char )(mcnt >> 8);
#line 7283
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
#line 7284
    goto switch_break;
    case_28: /* CIL Label */ 
#line 7310
    if (size1) {
#line 7310
      tmp___106 = string1;
    } else {
#line 7310
      tmp___106 = string2;
    }
#line 7310
    if ((unsigned long )d == (unsigned long )tmp___106) {
#line 7311
      goto switch_break;
    } else
#line 7310
    if (! size2) {
#line 7311
      goto switch_break;
    } else
#line 7310
    if ((unsigned long )d == (unsigned long )end2) {
#line 7311
      goto switch_break;
    }
#line 7313
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7313
      tmp___108 = (int const   )*string2;
    } else {
#line 7313
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7313
        tmp___107 = (int const   )*(end1 - 1);
      } else {
#line 7313
        tmp___107 = (int const   )*(d - 1);
      }
#line 7313
      tmp___108 = tmp___107;
    }
#line 7313
    prevchar = (boolean )((int )re_syntax_table[(unsigned char )tmp___108] == 1);
#line 7314
    if ((unsigned long )d == (unsigned long )end1) {
#line 7314
      tmp___110 = (int const   )*string2;
    } else {
#line 7314
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7314
        tmp___109 = (int const   )*(end1 - 1);
      } else {
#line 7314
        tmp___109 = (int const   )*d;
      }
#line 7314
      tmp___110 = tmp___109;
    }
#line 7314
    thischar = (boolean )((int )re_syntax_table[(unsigned char )tmp___110] == 1);
#line 7315
    if ((int )prevchar != (int )thischar) {
#line 7316
      goto switch_break;
    }
#line 7317
    goto fail;
    case_29: /* CIL Label */ 
#line 7325
    if (size1) {
#line 7325
      tmp___111 = string1;
    } else {
#line 7325
      tmp___111 = string2;
    }
#line 7325
    if ((unsigned long )d == (unsigned long )tmp___111) {
#line 7326
      goto fail;
    } else
#line 7325
    if (! size2) {
#line 7326
      goto fail;
    } else
#line 7325
    if ((unsigned long )d == (unsigned long )end2) {
#line 7326
      goto fail;
    }
#line 7328
    if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7328
      tmp___113 = (int const   )*string2;
    } else {
#line 7328
      if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7328
        tmp___112 = (int const   )*(end1 - 1);
      } else {
#line 7328
        tmp___112 = (int const   )*(d - 1);
      }
#line 7328
      tmp___113 = tmp___112;
    }
#line 7328
    prevchar___0 = (boolean )((int )re_syntax_table[(unsigned char )tmp___113] == 1);
#line 7329
    if ((unsigned long )d == (unsigned long )end1) {
#line 7329
      tmp___115 = (int const   )*string2;
    } else {
#line 7329
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7329
        tmp___114 = (int const   )*(end1 - 1);
      } else {
#line 7329
        tmp___114 = (int const   )*d;
      }
#line 7329
      tmp___115 = tmp___114;
    }
#line 7329
    thischar___0 = (boolean )((int )re_syntax_table[(unsigned char )tmp___115] == 1);
#line 7330
    if ((int )prevchar___0 != (int )thischar___0) {
#line 7331
      goto fail;
    }
#line 7332
    goto switch_break;
    case_26: /* CIL Label */ ;
#line 7338
    if (! ((unsigned long )d == (unsigned long )end2)) {
#line 7338
      if ((unsigned long )d == (unsigned long )end1) {
#line 7338
        tmp___117 = (int const   )*string2;
      } else {
#line 7338
        if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7338
          tmp___116 = (int const   )*(end1 - 1);
        } else {
#line 7338
          tmp___116 = (int const   )*d;
        }
#line 7338
        tmp___117 = tmp___116;
      }
#line 7338
      if ((int )re_syntax_table[(unsigned char )tmp___117] == 1) {
#line 7338
        if (size1) {
#line 7338
          tmp___118 = string1;
        } else {
#line 7338
          tmp___118 = string2;
        }
#line 7338
        if ((unsigned long )d == (unsigned long )tmp___118) {
#line 7340
          goto switch_break;
        } else
#line 7338
        if (! size2) {
#line 7340
          goto switch_break;
        } else {
#line 7338
          if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7338
            tmp___120 = (int const   )*string2;
          } else {
#line 7338
            if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7338
              tmp___119 = (int const   )*(end1 - 1);
            } else {
#line 7338
              tmp___119 = (int const   )*(d - 1);
            }
#line 7338
            tmp___120 = tmp___119;
          }
#line 7338
          if (! ((int )re_syntax_table[(unsigned char )tmp___120] == 1)) {
#line 7340
            goto switch_break;
          }
        }
      }
    }
#line 7341
    goto fail;
    case_27: /* CIL Label */ ;
#line 7345
    if (size1) {
#line 7345
      tmp___121 = string1;
    } else {
#line 7345
      tmp___121 = string2;
    }
#line 7345
    if (! ((unsigned long )d == (unsigned long )tmp___121)) {
#line 7345
      if (! (! size2)) {
#line 7345
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
#line 7345
          tmp___123 = (int const   )*string2;
        } else {
#line 7345
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
#line 7345
            tmp___122 = (int const   )*(end1 - 1);
          } else {
#line 7345
            tmp___122 = (int const   )*(d - 1);
          }
#line 7345
          tmp___123 = tmp___122;
        }
#line 7345
        if ((int )re_syntax_table[(unsigned char )tmp___123] == 1) {
#line 7345
          if ((unsigned long )d == (unsigned long )end2) {
#line 7347
            goto switch_break;
          } else {
#line 7345
            if ((unsigned long )d == (unsigned long )end1) {
#line 7345
              tmp___125 = (int const   )*string2;
            } else {
#line 7345
              if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7345
                tmp___124 = (int const   )*(end1 - 1);
              } else {
#line 7345
                tmp___124 = (int const   )*d;
              }
#line 7345
              tmp___125 = tmp___124;
            }
#line 7345
            if (! ((int )re_syntax_table[(unsigned char )tmp___125] == 1)) {
#line 7347
              goto switch_break;
            }
          }
        }
      }
    }
#line 7348
    goto fail;
    case_24: /* CIL Label */ ;
    {
#line 7406
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 7406
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 7406
        goto while_break___72;
      }
#line 7406
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 7406
        goto fail;
      }
#line 7406
      d = string2;
#line 7406
      dend = end_match_2;
    }
    while_break___72: /* CIL Label */ ;
    }
#line 7407
    if ((unsigned long )d == (unsigned long )end1) {
#line 7407
      tmp___127 = (int const   )*string2;
    } else {
#line 7407
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7407
        tmp___126 = (int const   )*(end1 - 1);
      } else {
#line 7407
        tmp___126 = (int const   )*d;
      }
#line 7407
      tmp___127 = tmp___126;
    }
#line 7407
    if (! ((int )re_syntax_table[(unsigned char )tmp___127] == 1)) {
#line 7408
      goto fail;
    }
    {
#line 7409
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 7409
      if (! set_regs_matched_done) {
#line 7409
        set_regs_matched_done = 1;
#line 7409
        r___5 = lowest_active_reg;
        {
#line 7409
        while (1) {
          while_continue___74: /* CIL Label */ ;
#line 7409
          if (! (r___5 <= highest_active_reg)) {
#line 7409
            goto while_break___74;
          }
#line 7409
          tmp___128 = 1U;
#line 7409
          (reg_info + r___5)->bits.ever_matched_something = tmp___128;
#line 7409
          (reg_info + r___5)->bits.matched_something = tmp___128;
#line 7409
          r___5 ++;
        }
        while_break___74: /* CIL Label */ ;
        }
      }
#line 7409
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
#line 7410
    d ++;
#line 7411
    goto switch_break;
    case_25: /* CIL Label */ ;
    {
#line 7415
    while (1) {
      while_continue___75: /* CIL Label */ ;
#line 7415
      if (! ((unsigned long )d == (unsigned long )dend)) {
#line 7415
        goto while_break___75;
      }
#line 7415
      if ((unsigned long )dend == (unsigned long )end_match_2) {
#line 7415
        goto fail;
      }
#line 7415
      d = string2;
#line 7415
      dend = end_match_2;
    }
    while_break___75: /* CIL Label */ ;
    }
#line 7416
    if ((unsigned long )d == (unsigned long )end1) {
#line 7416
      tmp___130 = (int const   )*string2;
    } else {
#line 7416
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
#line 7416
        tmp___129 = (int const   )*(end1 - 1);
      } else {
#line 7416
        tmp___129 = (int const   )*d;
      }
#line 7416
      tmp___130 = tmp___129;
    }
#line 7416
    if ((int )re_syntax_table[(unsigned char )tmp___130] == 1) {
#line 7417
      goto fail;
    }
    {
#line 7418
    while (1) {
      while_continue___76: /* CIL Label */ ;
#line 7418
      if (! set_regs_matched_done) {
#line 7418
        set_regs_matched_done = 1;
#line 7418
        r___6 = lowest_active_reg;
        {
#line 7418
        while (1) {
          while_continue___77: /* CIL Label */ ;
#line 7418
          if (! (r___6 <= highest_active_reg)) {
#line 7418
            goto while_break___77;
          }
#line 7418
          tmp___131 = 1U;
#line 7418
          (reg_info + r___6)->bits.ever_matched_something = tmp___131;
#line 7418
          (reg_info + r___6)->bits.matched_something = tmp___131;
#line 7418
          r___6 ++;
        }
        while_break___77: /* CIL Label */ ;
        }
      }
#line 7418
      goto while_break___76;
    }
    while_break___76: /* CIL Label */ ;
    }
#line 7419
    d ++;
#line 7420
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 7424
    abort();
    }
    switch_break: /* CIL Label */ ;
    }
#line 7426
    goto __Cont;
    fail: 
#line 7431
    if (! (fail_stack.avail == 0U)) {
#line 7434
      (fail_stack.avail) --;
#line 7434
      string_temp___0 = (unsigned char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7434
      if ((unsigned long )string_temp___0 != (unsigned long )((void *)0)) {
#line 7434
        d = (char const   *)string_temp___0;
      }
#line 7434
      (fail_stack.avail) --;
#line 7434
      p = (fail_stack.stack + fail_stack.avail)->pointer;
#line 7434
      (fail_stack.avail) --;
#line 7434
      highest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7434
      (fail_stack.avail) --;
#line 7434
      lowest_active_reg = (active_reg_t )(fail_stack.stack + fail_stack.avail)->integer;
#line 7434
      this_reg___5 = highest_active_reg;
      {
#line 7434
      while (1) {
        while_continue___78: /* CIL Label */ ;
#line 7434
        if (! (this_reg___5 >= lowest_active_reg)) {
#line 7434
          goto while_break___78;
        }
#line 7434
        (fail_stack.avail) --;
#line 7434
        (reg_info + this_reg___5)->word = *(fail_stack.stack + fail_stack.avail);
#line 7434
        (fail_stack.avail) --;
#line 7434
        *(regend + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7434
        (fail_stack.avail) --;
#line 7434
        *(regstart + this_reg___5) = (char const   *)(fail_stack.stack + fail_stack.avail)->pointer;
#line 7434
        this_reg___5 --;
      }
      while_break___78: /* CIL Label */ ;
      }
#line 7434
      set_regs_matched_done = 0;
#line 7439
      if (! p) {
#line 7440
        goto fail;
      }
#line 7444
      if ((unsigned long )p < (unsigned long )pend) {
#line 7446
        is_a_jump_n___0 = (boolean )0;
        {
#line 7452
        if ((unsigned int )((re_opcode_t )*p) == 22U) {
#line 7452
          goto case_22___1;
        }
#line 7456
        if ((unsigned int )((re_opcode_t )*p) == 13U) {
#line 7456
          goto case_13___1;
        }
#line 7456
        if ((unsigned int )((re_opcode_t )*p) == 17U) {
#line 7456
          goto case_13___1;
        }
#line 7456
        if ((unsigned int )((re_opcode_t )*p) == 18U) {
#line 7456
          goto case_13___1;
        }
#line 7466
        goto switch_default___1;
        case_22___1: /* CIL Label */ 
#line 7453
        is_a_jump_n___0 = (boolean )1;
        case_13___1: /* CIL Label */ 
        case_17___1: /* CIL Label */ 
        case_18___1: /* CIL Label */ 
#line 7457
        p1 = p + 1;
        {
#line 7458
        while (1) {
          while_continue___79: /* CIL Label */ ;
          {
#line 7458
          while (1) {
            while_continue___80: /* CIL Label */ ;
#line 7458
            mcnt = (int )*p1 & 255;
#line 7458
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7458
            goto while_break___80;
          }
          while_break___80: /* CIL Label */ ;
          }
#line 7458
          p1 += 2;
#line 7458
          goto while_break___79;
        }
        while_break___79: /* CIL Label */ ;
        }
#line 7459
        p1 += mcnt;
#line 7461
        if (is_a_jump_n___0) {
#line 7461
          if ((unsigned int )((re_opcode_t )*p1) == 21U) {
#line 7464
            goto fail;
          } else {
#line 7461
            goto _L___20;
          }
        } else
        _L___20: /* CIL Label */ 
#line 7461
        if (! is_a_jump_n___0) {
#line 7461
          if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 7464
            goto fail;
          }
        }
#line 7465
        goto switch_break___1;
        switch_default___1: /* CIL Label */ ;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 7471
      if ((unsigned long )d >= (unsigned long )string1) {
#line 7471
        if ((unsigned long )d <= (unsigned long )end1) {
#line 7472
          dend = end_match_1;
        }
      }
    } else {
#line 7475
      goto while_break___3;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 7478
  if (best_regs_set) {
#line 7479
    goto restore_best_regs;
  }
  {
#line 7481
  while (1) {
    while_continue___81: /* CIL Label */ ;
#line 7481
    regstart = (char const   **)((void *)0);
#line 7481
    regend = (char const   **)((void *)0);
#line 7481
    old_regstart = (char const   **)((void *)0);
#line 7481
    old_regend = (char const   **)((void *)0);
#line 7481
    best_regstart = (char const   **)((void *)0);
#line 7481
    best_regend = (char const   **)((void *)0);
#line 7481
    reg_info = (byte_register_info_type *)((void *)0);
#line 7481
    reg_dummy = (char const   **)((void *)0);
#line 7481
    reg_info_dummy = (byte_register_info_type *)((void *)0);
#line 7481
    goto while_break___81;
  }
  while_break___81: /* CIL Label */ ;
  }
#line 7483
  return (-1);
}
}
#line 7499 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static boolean byte_group_match_null_string_p(unsigned char **p , unsigned char *end ,
                                              byte_register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp___0 ;
  boolean tmp___1 ;
  boolean tmp___2 ;

  {
#line 7505
  p1 = *p + 2;
  {
#line 7507
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7507
    if (! ((unsigned long )p1 < (unsigned long )end)) {
#line 7507
      goto while_break;
    }
    {
#line 7516
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 7516
      goto case_15;
    }
#line 7590
    if ((unsigned int )((re_opcode_t )*p1) == 7U) {
#line 7590
      goto case_7;
    }
#line 7596
    goto switch_default;
    case_15: /* CIL Label */ 
#line 7517
    p1 ++;
    {
#line 7518
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 7518
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7518
        mcnt = (int )*p1 & 255;
#line 7518
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7518
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 7518
      p1 += 2;
#line 7518
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7523
    if (mcnt >= 0) {
      {
#line 7543
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 7543
        if (! ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) == 14U)) {
#line 7543
          goto while_break___2;
        }
        {
#line 7550
        tmp___0 = byte_alt_match_null_string_p(p1, (p1 + mcnt) - 3, reg_info);
        }
#line 7550
        if (! tmp___0) {
#line 7553
          return ((boolean )0);
        }
#line 7557
        p1 += mcnt;
#line 7561
        if ((unsigned int )((re_opcode_t )*p1) != 15U) {
#line 7562
          goto while_break___2;
        }
#line 7566
        p1 ++;
        {
#line 7567
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 7567
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 7567
            mcnt = (int )*p1 & 255;
#line 7567
            mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7567
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 7567
          p1 += 2;
#line 7567
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 7568
        if ((unsigned int )((re_opcode_t )*(p1 + (mcnt - 3))) != 14U) {
#line 7572
          p1 -= 3;
#line 7573
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 7580
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 7580
        mcnt = (int )*(p1 - 2) & 255;
#line 7580
        mcnt += (int )((signed char )*((p1 - 2) + 1)) << 8;
#line 7580
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 7582
      tmp___1 = byte_alt_match_null_string_p(p1, p1 + mcnt, reg_info);
      }
#line 7582
      if (! tmp___1) {
#line 7583
        return ((boolean )0);
      }
#line 7585
      p1 += mcnt;
    }
#line 7587
    goto switch_break;
    case_7: /* CIL Label */ 
#line 7592
    *p = p1 + 2;
#line 7593
    return ((boolean )1);
    switch_default: /* CIL Label */ 
    {
#line 7597
    tmp___2 = byte_common_op_match_null_string_p(& p1, end, reg_info);
    }
#line 7597
    if (! tmp___2) {
#line 7598
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7602
  return ((boolean )0);
}
}
#line 7610 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static boolean byte_alt_match_null_string_p(unsigned char *p , unsigned char *end ,
                                            byte_register_info_type *reg_info ) 
{ 
  int mcnt ;
  unsigned char *p1 ;
  boolean tmp___0 ;

  {
#line 7615
  p1 = p;
  {
#line 7617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7617
    if (! ((unsigned long )p1 < (unsigned long )end)) {
#line 7617
      goto while_break;
    }
    {
#line 7625
    if ((unsigned int )((re_opcode_t )*p1) == 15U) {
#line 7625
      goto case_15;
    }
#line 7631
    goto switch_default;
    case_15: /* CIL Label */ 
#line 7626
    p1 ++;
    {
#line 7627
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 7627
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 7627
        mcnt = (int )*p1 & 255;
#line 7627
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7627
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 7627
      p1 += 2;
#line 7627
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7628
    p1 += mcnt;
#line 7629
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 7632
    tmp___0 = byte_common_op_match_null_string_p(& p1, end, reg_info);
    }
#line 7632
    if (! tmp___0) {
#line 7633
      return ((boolean )0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 7637
  return ((boolean )1);
}
}
#line 7646 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static boolean byte_common_op_match_null_string_p(unsigned char **p , unsigned char *end ,
                                                  byte_register_info_type *reg_info ) 
{ 
  int mcnt ;
  boolean ret ;
  int reg_no ;
  unsigned char *p1 ;
  unsigned char *tmp___0 ;

  {
#line 7653
  p1 = *p;
#line 7655
  tmp___0 = p1;
#line 7655
  p1 ++;
  {
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 29U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 28U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 27U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 26U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 12U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 11U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 10U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 9U) {
#line 7665
    goto case_29;
  }
#line 7665
  if ((unsigned int )((re_opcode_t )*tmp___0) == 0U) {
#line 7665
    goto case_29;
  }
#line 7673
  if ((unsigned int )((re_opcode_t )*tmp___0) == 6U) {
#line 7673
    goto case_6;
  }
#line 7689
  if ((unsigned int )((re_opcode_t )*tmp___0) == 13U) {
#line 7689
    goto case_13;
  }
#line 7697
  if ((unsigned int )((re_opcode_t )*tmp___0) == 21U) {
#line 7697
    goto case_21;
  }
#line 7712
  if ((unsigned int )((re_opcode_t )*tmp___0) == 8U) {
#line 7712
    goto case_8;
  }
#line 7717
  if ((unsigned int )((re_opcode_t )*tmp___0) == 23U) {
#line 7717
    goto case_23;
  }
#line 7720
  goto switch_default;
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 7671
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 7674
  reg_no = (int )*p1;
#line 7676
  ret = byte_group_match_null_string_p(& p1, end, reg_info);
  }
#line 7681
  if ((reg_info + reg_no)->bits.match_null_string_p == 3U) {
#line 7682
    (reg_info + reg_no)->bits.match_null_string_p = (unsigned int )ret;
  }
#line 7684
  if (! ret) {
#line 7685
    return ((boolean )0);
  }
#line 7686
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 7690
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 7690
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7690
      mcnt = (int )*p1 & 255;
#line 7690
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7690
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 7690
    p1 += 2;
#line 7690
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 7691
  if (mcnt >= 0) {
#line 7692
    p1 += mcnt;
  } else {
#line 7694
    return ((boolean )0);
  }
#line 7695
  goto switch_break;
  case_21: /* CIL Label */ 
#line 7699
  p1 += 2;
  {
#line 7700
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 7700
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 7700
      mcnt = (int )*p1 & 255;
#line 7700
      mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7700
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 7700
    p1 += 2;
#line 7700
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 7702
  if (mcnt == 0) {
#line 7704
    p1 -= 4;
    {
#line 7705
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 7705
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 7705
        mcnt = (int )*p1 & 255;
#line 7705
        mcnt += (int )((signed char )*(p1 + 1)) << 8;
#line 7705
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 7705
      p1 += 2;
#line 7705
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 7706
    p1 += mcnt;
  } else {
#line 7709
    return ((boolean )0);
  }
#line 7710
  goto switch_break;
  case_8: /* CIL Label */ 
#line 7713
  if (! (reg_info + *p1)->bits.match_null_string_p) {
#line 7714
    return ((boolean )0);
  }
#line 7715
  goto switch_break;
  case_23: /* CIL Label */ 
#line 7718
  p1 += 4;
  switch_default: /* CIL Label */ 
#line 7722
  return ((boolean )0);
  switch_break: /* CIL Label */ ;
  }
#line 7725
  *p = p1;
#line 7726
  return ((boolean )1);
}
}
#line 7733 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static int byte_bcmp_translate(char const   *s1 , char const   *s2 , int len , char *translate ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
#line 7737
  p1 = (unsigned char const   *)s1;
#line 7738
  p2 = (unsigned char const   *)s2;
  {
#line 7739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7739
    if (! len) {
#line 7739
      goto while_break;
    }
#line 7746
    tmp___0 = p1;
#line 7746
    p1 ++;
#line 7746
    tmp___1 = p2;
#line 7746
    p2 ++;
#line 7746
    if ((int )*(translate + *tmp___0) != (int )*(translate + *tmp___1)) {
#line 7746
      return (1);
    }
#line 7748
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 7750
  return (0);
}
}
#line 1323 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
reg_syntax_t xre_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 1326
  ret = xre_syntax_options;
#line 1328
  xre_syntax_options = syntax;
#line 1335
  return (ret);
}
}
#line 1346 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static char const   *re_error_msgid[17]  = 
#line 1346
  {      "Success",      "No match",      "Invalid regular expression",      "Invalid collation character", 
        "Invalid character class name",      "Trailing backslash",      "Invalid back reference",      "Unmatched [ or [^", 
        "Unmatched ( or \\(",      "Unmatched \\{",      "Invalid content of \\{\\}",      "Invalid range end", 
        "Memory exhausted",      "Invalid preceding regular expression",      "Premature end of regular expression",      "Regular expression too big", 
        "Unmatched ) or \\)"};
#line 4326 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) 
{ 
  int this_element ;

  {
#line 4331
  this_element = (int )(compile_stack.avail - 1U);
  {
#line 4331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4331
    if (! (this_element >= 0)) {
#line 4331
      goto while_break;
    }
#line 4334
    if ((compile_stack.stack + this_element)->regnum == regnum) {
#line 4335
      return ((boolean )1);
    }
#line 4331
    this_element --;
  }
  while_break: /* CIL Label */ ;
  }
#line 4337
  return ((boolean )0);
}
}
#line 4859 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  int tmp___0 ;

  {
  {
#line 4867
  tmp___0 = byte_re_compile_fastmap(bufp);
  }
#line 4867
  return (tmp___0);
}
}
#line 4887 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
void xre_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                       unsigned int num_regs , xregoff_t *starts , xregoff_t *ends ) 
{ 
  xregoff_t *tmp___0 ;

  {
#line 4892
  if (num_regs) {
#line 4894
    bufp->regs_allocated = 1U;
#line 4895
    regs->num_regs = num_regs;
#line 4896
    regs->start = starts;
#line 4897
    regs->end = ends;
  } else {
#line 4901
    bufp->regs_allocated = 0U;
#line 4902
    regs->num_regs = 0U;
#line 4903
    tmp___0 = (xregoff_t *)0;
#line 4903
    regs->end = tmp___0;
#line 4903
    regs->start = tmp___0;
  }
#line 4905
  return;
}
}
#line 4915 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_search(struct re_pattern_buffer *bufp , char const   *string , int size ,
               int startpos , int range , struct re_registers *regs ) 
{ 
  int tmp___0 ;

  {
  {
#line 4919
  tmp___0 = xre_search_2(bufp, (char const   *)((void *)0), 0, string, size, startpos,
                         range, regs, size);
  }
#line 4919
  return (tmp___0);
}
}
#line 4948 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_search_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                 char const   *string2 , int size2 , int startpos , int range , struct re_registers *regs ,
                 int stop ) 
{ 
  int tmp___0 ;

  {
  {
#line 4959
  tmp___0 = byte_re_search_2(bufp, string1, size1, string2, size2, startpos, range,
                             regs, stop);
  }
#line 4959
  return (tmp___0);
}
}
#line 5392 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_match(struct re_pattern_buffer *bufp , char const   *string , int size , int pos ,
              struct re_registers *regs ) 
{ 
  int result ;

  {
  {
#line 5404
  result = byte_re_match_2_internal(bufp, (char const   *)((void *)0), 0, string,
                                    size, pos, regs, size);
  }
#line 5411
  return (result);
}
}
#line 5447 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_match_2(struct re_pattern_buffer *bufp , char const   *string1 , int size1 ,
                char const   *string2 , int size2 , int pos , struct re_registers *regs ,
                int stop ) 
{ 
  int result ;

  {
  {
#line 5460
  result = byte_re_match_2_internal(bufp, string1, size1, string2, size2, pos, regs,
                                    stop);
  }
#line 5468
  return (result);
}
}
#line 7767 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
char const   *xre_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;

  {
  {
#line 7775
  bufp->regs_allocated = 0U;
#line 7780
  bufp->no_sub = 0U;
#line 7783
  bufp->newline_anchor = 1U;
#line 7790
  ret = byte_regex_compile(pattern, length, xre_syntax_options, bufp);
  }
#line 7792
  if (! ret) {
#line 7793
    return ((char const   *)((void *)0));
  }
#line 7794
  return (re_error_msgid[(int )ret]);
}
}
#line 7806 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
static struct re_pattern_buffer re_comp_buf  ;
#line 7808 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
char *xre_comp(char const   *s ) 
{ 
  reg_errcode_t ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 7819
  if (! s) {
#line 7821
    if (! re_comp_buf.buffer) {
#line 7822
      return ((char *)"No previous regular expression");
    }
#line 7823
    return ((char *)0);
  }
#line 7826
  if (! re_comp_buf.buffer) {
    {
#line 7828
    tmp___0 = malloc((size_t )200);
#line 7828
    re_comp_buf.buffer = (unsigned char *)tmp___0;
    }
#line 7829
    if ((unsigned long )re_comp_buf.buffer == (unsigned long )((void *)0)) {
#line 7830
      return ((char *)re_error_msgid[12]);
    }
    {
#line 7831
    re_comp_buf.allocated = 200UL;
#line 7833
    tmp___1 = malloc((size_t )(1 << 8));
#line 7833
    re_comp_buf.fastmap = (char *)tmp___1;
    }
#line 7834
    if ((unsigned long )re_comp_buf.fastmap == (unsigned long )((void *)0)) {
#line 7835
      return ((char *)re_error_msgid[12]);
    }
  }
  {
#line 7842
  re_comp_buf.newline_anchor = 1U;
#line 7849
  tmp___2 = strlen(s);
#line 7849
  ret = byte_regex_compile(s, tmp___2, xre_syntax_options, & re_comp_buf);
  }
#line 7851
  if (! ret) {
#line 7852
    return ((char *)((void *)0));
  }
#line 7855
  return ((char *)re_error_msgid[(int )ret]);
}
}
#line 7859 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xre_exec(char const   *s ) 
{ 
  int len ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 7865
  tmp___0 = strlen(s);
#line 7865
  len = (int )tmp___0;
#line 7866
  tmp___1 = xre_search(& re_comp_buf, s, len, 0, len, (struct re_registers *)0);
  }
#line 7866
  return (0 <= tmp___1);
}
}
#line 7911 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xregcomp(regex_t * __restrict  preg , char const   * __restrict  pattern , int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  int i ;
  void *tmp___2 ;
  __int32_t const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;

  {
#line 7915
  if (cflags & 1) {
#line 7915
    tmp___0 = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 7915
    tmp___0 = ((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1);
  }
  {
#line 7915
  syntax = tmp___0;
#line 7920
  preg->buffer = (unsigned char *)0;
#line 7921
  preg->allocated = 0UL;
#line 7922
  preg->used = 0UL;
#line 7925
  tmp___1 = malloc((size_t )(1 << 8));
#line 7925
  preg->fastmap = (char *)tmp___1;
  }
#line 7927
  if (cflags & (1 << 1)) {
    {
#line 7931
    tmp___2 = malloc(256UL * sizeof(*((char *)0)));
#line 7931
    preg->translate = (char *)tmp___2;
    }
#line 7934
    if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
#line 7935
      return (12);
    }
#line 7938
    i = 0;
    {
#line 7938
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7938
      if (! (i < 256)) {
#line 7938
        goto while_break;
      }
      {
#line 7939
      tmp___4 = __ctype_b_loc();
      }
#line 7939
      if ((int const   )*(*tmp___4 + i) & 256) {
        {
#line 7939
        tmp___3 = __ctype_tolower_loc();
#line 7939
        *(preg->translate + i) = (char )((int )*(*tmp___3 + i));
        }
      } else {
#line 7939
        *(preg->translate + i) = (char )i;
      }
#line 7938
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 7942
    preg->translate = (char *)((void *)0);
  }
#line 7945
  if (cflags & ((1 << 1) << 1)) {
#line 7947
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 7948
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 7950
    preg->newline_anchor = 1U;
  } else {
#line 7953
    preg->newline_anchor = 0U;
  }
  {
#line 7955
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
#line 7964
  tmp___5 = strlen((char const   *)pattern);
#line 7964
  ret = byte_regex_compile((char const   *)pattern, tmp___5, syntax, (struct re_pattern_buffer *)preg);
  }
#line 7968
  if ((int )ret == 16) {
#line 7968
    ret = (reg_errcode_t )8;
  }
#line 7970
  if ((int )ret == 0) {
#line 7970
    if (preg->fastmap) {
      {
#line 7974
      tmp___6 = xre_compile_fastmap((struct re_pattern_buffer *)preg);
      }
#line 7974
      if (tmp___6 == -2) {
        {
#line 7978
        free((void *)preg->fastmap);
#line 7979
        preg->fastmap = (char *)((void *)0);
        }
      }
    }
  }
#line 7983
  return ((int )ret);
}
}
#line 8004 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
int xregexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
             size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  int ret ;
  struct re_registers regs ;
  regex_t private_preg ;
  int len ;
  size_t tmp___0 ;
  boolean want_reg_info ;
  int tmp___1 ;
  void *tmp___2 ;
  struct re_registers *tmp___3 ;
  unsigned int r ;
  int tmp___4 ;

  {
  {
#line 8011
  tmp___0 = strlen((char const   *)string);
#line 8011
  len = (int )tmp___0;
  }
#line 8012
  if (! preg->no_sub) {
#line 8012
    if (nmatch > 0UL) {
#line 8012
      tmp___1 = 1;
    } else {
#line 8012
      tmp___1 = 0;
    }
  } else {
#line 8012
    tmp___1 = 0;
  }
#line 8012
  want_reg_info = (boolean )tmp___1;
#line 8014
  private_preg = (regex_t )*preg;
#line 8016
  private_preg.not_bol = (unsigned int )(! (! (eflags & 1)));
#line 8017
  private_preg.not_eol = (unsigned int )(! (! (eflags & (1 << 1))));
#line 8022
  private_preg.regs_allocated = 2U;
#line 8024
  if (want_reg_info) {
    {
#line 8026
    regs.num_regs = (unsigned int )nmatch;
#line 8027
    tmp___2 = malloc((nmatch * 2UL) * sizeof(xregoff_t ));
#line 8027
    regs.start = (xregoff_t *)tmp___2;
    }
#line 8028
    if ((unsigned long )regs.start == (unsigned long )((void *)0)) {
#line 8029
      return (1);
    }
#line 8030
    regs.end = regs.start + nmatch;
  }
#line 8034
  if (want_reg_info) {
#line 8034
    tmp___3 = & regs;
  } else {
#line 8034
    tmp___3 = (struct re_registers *)0;
  }
  {
#line 8034
  ret = xre_search(& private_preg, (char const   *)string, len, 0, len, tmp___3);
  }
#line 8039
  if (want_reg_info) {
#line 8041
    if (ret >= 0) {
#line 8045
      r = 0U;
      {
#line 8045
      while (1) {
        while_continue: /* CIL Label */ ;
#line 8045
        if (! ((size_t )r < nmatch)) {
#line 8045
          goto while_break;
        }
#line 8047
        (pmatch + r)->rm_so = *(regs.start + r);
#line 8048
        (pmatch + r)->rm_eo = *(regs.end + r);
#line 8045
        r ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 8053
    free((void *)regs.start);
    }
  }
#line 8057
  if (ret >= 0) {
#line 8057
    tmp___4 = 0;
  } else {
#line 8057
    tmp___4 = 1;
  }
#line 8057
  return (tmp___4);
}
}
#line 8067 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
size_t xregerror(int errcode , regex_t const   *preg  __attribute__((__unused__)) ,
                 char *errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  size_t tmp___0 ;

  {
#line 8074
  if (errcode < 0) {
    {
#line 8081
    abort();
    }
  } else
#line 8074
  if (errcode >= (int )(sizeof(re_error_msgid) / sizeof(re_error_msgid[0]))) {
    {
#line 8081
    abort();
    }
  }
  {
#line 8083
  msg = re_error_msgid[errcode];
#line 8085
  tmp___0 = strlen(msg);
#line 8085
  msg_size = tmp___0 + 1UL;
  }
#line 8087
  if (errbuf_size != 0UL) {
#line 8089
    if (msg_size > errbuf_size) {
      {
#line 8094
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             errbuf_size - 1UL);
#line 8095
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
      }
    } else {
      {
#line 8099
      memcpy((void */* __restrict  */)errbuf, (void const   */* __restrict  */)msg,
             msg_size);
      }
    }
  }
#line 8102
  return (msg_size);
}
}
#line 8111 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./regex.c"
void xregfree(regex_t *preg ) 
{ 


  {
  {
#line 8114
  free((void *)preg->buffer);
#line 8115
  preg->buffer = (unsigned char *)((void *)0);
#line 8117
  preg->allocated = 0UL;
#line 8118
  preg->used = 0UL;
#line 8120
  free((void *)preg->fastmap);
#line 8121
  preg->fastmap = (char *)((void *)0);
#line 8122
  preg->fastmap_accurate = 0U;
#line 8124
  free((void *)preg->translate);
#line 8125
  preg->translate = (char *)((void *)0);
  }
#line 8126
  return;
}
}
#line 622 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 327 "./../include/libiberty.h"
double physmem_total(void) ;
#line 328
double physmem_available(void) ;
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./physmem.c"
double physmem_total(void) 
{ 
  double pages ;
  long tmp___0 ;
  double pagesize ;
  long tmp___1 ;

  {
  {
#line 87
  tmp___0 = sysconf(85);
#line 87
  pages = (double )tmp___0;
#line 88
  tmp___1 = sysconf(30);
#line 88
  pagesize = (double )tmp___1;
  }
#line 89
  if ((double )0 <= pages) {
#line 89
    if ((double )0 <= pagesize) {
#line 90
      return (pages * pagesize);
    }
  }
#line 182
  return ((double )0);
}
}
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./physmem.c"
double physmem_available(void) 
{ 
  double pages ;
  long tmp___0 ;
  double pagesize ;
  long tmp___1 ;
  double tmp___2 ;

  {
  {
#line 191
  tmp___0 = sysconf(86);
#line 191
  pages = (double )tmp___0;
#line 192
  tmp___1 = sysconf(30);
#line 192
  pagesize = (double )tmp___1;
  }
#line 193
  if ((double )0 <= pages) {
#line 193
    if ((double )0 <= pagesize) {
#line 194
      return (pages * pagesize);
    }
  }
  {
#line 283
  tmp___2 = physmem_total();
  }
#line 283
  return (tmp___2 / (double )4);
}
}
#line 401 "./../include/libiberty.h"
struct pex_obj *pex_init(int flags___1 , char const   *pname , char const   *tempbase ) ;
#line 496
char const   *pex_run(struct pex_obj *obj , int flags___1 , char const   *executable ,
                      char * const  *argv , char const   *orig_outname , char const   *errname ,
                      int *err ) ;
#line 552
int pex_get_status(struct pex_obj *obj , int count , int *vector ) ;
#line 573
void pex_free(struct pex_obj *obj ) ;
#line 605
int pexecute(char const   *program , char * const  *argv , char const   *pname , char const   *temp_base ,
             char **errmsg_fmt , char **errmsg_arg , int flags___1 ) ;
#line 610
int pwait(int pid , int *status , int flags___1  __attribute__((__unused__)) ) ;
#line 35 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pexecute.c"
static struct pex_obj *pex  ;
#line 36 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pexecute.c"
static int idx  ;
#line 38 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pexecute.c"
int pexecute(char const   *program , char * const  *argv , char const   *pname , char const   *temp_base ,
             char **errmsg_fmt , char **errmsg_arg , int flags___1 ) 
{ 
  char const   *errmsg ;
  int err ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 46
  if ((flags___1 & 1) != 0) {
#line 48
    if ((unsigned long )pex != (unsigned long )((void *)0)) {
#line 50
      *errmsg_fmt = (char *)"pexecute already in progress";
#line 51
      *errmsg_arg = (char *)((void *)0);
#line 52
      return (-1);
    }
    {
#line 54
    pex = pex_init(2, pname, temp_base);
#line 55
    idx = 0;
    }
  } else
#line 59
  if ((unsigned long )pex == (unsigned long )((void *)0)) {
#line 61
    *errmsg_fmt = (char *)"pexecute not in progress";
#line 62
    *errmsg_arg = (char *)((void *)0);
#line 63
    return (-1);
  }
#line 67
  if ((flags___1 & 2) != 0) {
#line 67
    tmp___0 = 1;
  } else {
#line 67
    tmp___0 = 0;
  }
#line 67
  if ((flags___1 & 4) != 0) {
#line 67
    tmp___1 = 2;
  } else {
#line 67
    tmp___1 = 0;
  }
  {
#line 67
  errmsg = pex_run(pex, tmp___0 | tmp___1, program, argv, (char const   *)((void *)0),
                   (char const   *)((void *)0), & err);
  }
#line 71
  if ((unsigned long )errmsg != (unsigned long )((void *)0)) {
#line 73
    *errmsg_fmt = (char *)errmsg;
#line 74
    *errmsg_arg = (char *)((void *)0);
#line 75
    return (-1);
  }
#line 81
  idx ++;
#line 81
  return (idx);
}
}
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pexecute.c"
int pwait(int pid , int *status , int flags___1  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;
  int *vector ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 88
  pid --;
#line 90
  if ((unsigned long )pex == (unsigned long )((void *)0)) {
#line 91
    return (-1);
  } else
#line 90
  if (pid < 0) {
#line 91
    return (-1);
  } else
#line 90
  if (pid >= idx) {
#line 91
    return (-1);
  }
#line 93
  if (pid == 0) {
#line 93
    if (idx == 1) {
      {
#line 95
      tmp___0 = pex_get_status(pex, 1, status);
      }
#line 95
      if (! tmp___0) {
#line 96
        return (-1);
      }
    } else {
#line 93
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 102
    tmp___1 = xmalloc(sizeof(int ) * (unsigned long )idx);
#line 102
    vector = (int *)tmp___1;
#line 103
    tmp___2 = pex_get_status(pex, idx, vector);
    }
#line 103
    if (! tmp___2) {
      {
#line 105
      free((void *)vector);
      }
#line 106
      return (-1);
    }
    {
#line 108
    *status = *(vector + pid);
#line 109
    free((void *)vector);
    }
  }
#line 116
  if (pid + 1 == idx) {
    {
#line 118
    pex_free(pex);
#line 119
    pex = (struct pex_obj *)((void *)0);
#line 120
    idx = 0;
    }
  }
#line 123
  return (pid + 1);
}
}
#line 265 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 150 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.h"
struct pex_obj *pex_init_common(int flags___1 , char const   *pname , char const   *tempbase ,
                                struct pex_funcs  const  *funcs___0 ) ;
#line 112 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 420
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 447
extern unsigned int sleep(unsigned int __seconds ) ;
#line 537
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 566
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 581
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 606
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 767
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) vfork)(void) ;
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 157
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 142
extern  __attribute__((__nothrow__)) __pid_t wait4(__pid_t __pid , int *__stat_loc ,
                                                   int __options , struct rusage *__usage ) ;
#line 120 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static pid_t pex_wait(struct pex_obj *obj  __attribute__((__unused__)) , pid_t pid ,
                      int *status , struct pex_time *time ) ;
#line 124 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static pid_t pex_wait(struct pex_obj *obj  __attribute__((__unused__)) , pid_t pid ,
                      int *status , struct pex_time *time ) 
{ 
  pid_t ret ;
  struct rusage r ;
  __pid_t tmp___0 ;

  {
#line 132
  if ((unsigned long )time == (unsigned long )((void *)0)) {
    {
#line 133
    tmp___0 = waitpid(pid, status, 0);
    }
#line 133
    return (tmp___0);
  }
  {
#line 136
  ret = wait4(pid, status, 0, & r);
  }
#line 138
  if ((unsigned long )time != (unsigned long )((void *)0)) {
#line 140
    time->user_seconds = (unsigned long )r.ru_utime.tv_sec;
#line 141
    time->user_microseconds = (unsigned long )r.ru_utime.tv_usec;
#line 142
    time->system_seconds = (unsigned long )r.ru_stime.tv_sec;
#line 143
    time->system_microseconds = (unsigned long )r.ru_stime.tv_usec;
  }
#line 146
  return (ret);
}
}
#line 301
static  __attribute__((__noreturn__)) void pex_child_error(struct pex_obj *obj , char const   *executable ,
                                                           char const   *errmsg ,
                                                           int err ) ;
#line 303
static int pex_unix_open_read(struct pex_obj *obj  __attribute__((__unused__)) , char const   *name___0 ,
                              int binary  __attribute__((__unused__)) ) ;
#line 304
static int pex_unix_open_write(struct pex_obj *obj  __attribute__((__unused__)) ,
                               char const   *name___0 , int binary  __attribute__((__unused__)) ) ;
#line 305
static pid_t pex_unix_exec_child(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                 char * const  *argv , char * const  *env , int in ,
                                 int out , int errdes , int toclose , char const   **errmsg ,
                                 int *err ) ;
#line 309
static int pex_unix_close(struct pex_obj *obj  __attribute__((__unused__)) , int fd ) ;
#line 310
static int pex_unix_wait(struct pex_obj *obj , pid_t pid , int *status , struct pex_time *time ,
                         int done___0 , char const   **errmsg , int *err ) ;
#line 312
static int pex_unix_pipe(struct pex_obj *obj  __attribute__((__unused__)) , int *p ,
                         int binary  __attribute__((__unused__)) ) ;
#line 313
static FILE *pex_unix_fdopenr(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) ;
#line 314
static FILE *pex_unix_fdopenw(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) ;
#line 315
static void pex_unix_cleanup(struct pex_obj *obj  __attribute__((__unused__)) ) ;
#line 319 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
struct pex_funcs  const  funcs  = 
#line 319
     {& pex_unix_open_read, & pex_unix_open_write, & pex_unix_exec_child, & pex_unix_close,
    & pex_unix_wait, & pex_unix_pipe, & pex_unix_fdopenr, & pex_unix_fdopenw, & pex_unix_cleanup};
#line 334 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
struct pex_obj *pex_init(int flags___1 , char const   *pname , char const   *tempbase ) 
{ 
  struct pex_obj *tmp___0 ;

  {
  {
#line 337
  tmp___0 = pex_init_common(flags___1, pname, tempbase, & funcs);
  }
#line 337
  return (tmp___0);
}
}
#line 342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static int pex_unix_open_read(struct pex_obj *obj  __attribute__((__unused__)) , char const   *name___0 ,
                              int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 346
  tmp___0 = open(name___0, 0);
  }
#line 346
  return (tmp___0);
}
}
#line 351 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static int pex_unix_open_write(struct pex_obj *obj  __attribute__((__unused__)) ,
                               char const   *name___0 , int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 357
  tmp___0 = open(name___0, 577, (((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
  }
#line 357
  return (tmp___0);
}
}
#line 362 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static int pex_unix_close(struct pex_obj *obj  __attribute__((__unused__)) , int fd ) 
{ 
  int tmp___0 ;

  {
  {
#line 365
  tmp___0 = close(fd);
  }
#line 365
  return (tmp___0);
}
}
#line 371
static  __attribute__((__noreturn__)) void pex_child_error(struct pex_obj *obj , char const   *executable ,
                                                           char const   *errmsg ,
                                                           int err ) ;
#line 371 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static void pex_child_error(struct pex_obj *obj , char const   *executable , char const   *errmsg ,
                            int err ) 
{ 
  int retval ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;
  size_t tmp___4 ;
  ssize_t tmp___5 ;
  size_t tmp___6 ;
  ssize_t tmp___7 ;
  size_t tmp___8 ;
  ssize_t tmp___9 ;
  size_t tmp___10 ;
  ssize_t tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *tmp___14 ;
  ssize_t tmp___15 ;
  size_t tmp___16 ;
  ssize_t tmp___17 ;
  int tmp___18 ;

  {
  {
#line 375
  retval = 0;
#line 377
  tmp___0 = strlen(obj->pname);
#line 377
  tmp___1 = write(2, (void const   *)obj->pname, tmp___0);
#line 377
  retval |= tmp___1 < 0L;
#line 378
  tmp___2 = strlen(": error trying to exec \'");
#line 378
  tmp___3 = write(2, (void const   *)": error trying to exec \'", tmp___2);
#line 378
  retval |= tmp___3 < 0L;
#line 379
  tmp___4 = strlen(executable);
#line 379
  tmp___5 = write(2, (void const   *)executable, tmp___4);
#line 379
  retval |= tmp___5 < 0L;
#line 380
  tmp___6 = strlen("\': ");
#line 380
  tmp___7 = write(2, (void const   *)"\': ", tmp___6);
#line 380
  retval |= tmp___7 < 0L;
#line 381
  tmp___8 = strlen(errmsg);
#line 381
  tmp___9 = write(2, (void const   *)errmsg, tmp___8);
#line 381
  retval |= tmp___9 < 0L;
#line 382
  tmp___10 = strlen(": ");
#line 382
  tmp___11 = write(2, (void const   *)": ", tmp___10);
#line 382
  retval |= tmp___11 < 0L;
#line 383
  tmp___12 = xstrerror(err);
#line 383
  tmp___13 = strlen((char const   *)tmp___12);
#line 383
  tmp___14 = xstrerror(err);
#line 383
  tmp___15 = write(2, (void const   *)tmp___14, tmp___13);
#line 383
  retval |= tmp___15 < 0L;
#line 384
  tmp___16 = strlen("\n");
#line 384
  tmp___17 = write(2, (void const   *)"\n", tmp___16);
#line 384
  retval |= tmp___17 < 0L;
  }
#line 387
  if (retval == 0) {
#line 387
    tmp___18 = -1;
  } else {
#line 387
    tmp___18 = -2;
  }
  {
#line 387
  _exit(tmp___18);
  }
}
}
#line 590 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static pid_t pex_unix_exec_child(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                 char * const  *argv , char * const  *env , int in ,
                                 int out , int errdes , int toclose , char const   **errmsg ,
                                 int *err ) 
{ 
  pid_t pid ;
  int volatile   sleep_interval ;
  int volatile   retries ;
  char **save_environ ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;

  {
#line 607
  save_environ = environ;
#line 609
  sleep_interval = (int volatile   )1;
#line 610
  pid = -1;
#line 611
  retries = (int volatile   )0;
  {
#line 611
  while (1) {
    while_continue: /* CIL Label */ ;
#line 611
    if (! (retries < (int volatile   )4)) {
#line 611
      goto while_break;
    }
    {
#line 613
    pid = vfork();
    }
#line 614
    if (pid >= 0) {
#line 615
      goto while_break;
    }
    {
#line 616
    sleep((unsigned int )sleep_interval);
#line 617
    sleep_interval *= (int volatile   )2;
#line 611
    retries += (int volatile   )1;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 622
  if (pid == -1) {
#line 622
    goto case_neg_1;
  }
#line 627
  if (pid == 0) {
#line 627
    goto case_0;
  }
#line 683
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 623
  tmp___0 = __errno_location();
#line 623
  *err = *tmp___0;
#line 624
  *errmsg = "vfork";
  }
#line 625
  return (-1);
  case_0: /* CIL Label */ 
#line 629
  if (in != 0) {
    {
#line 631
    tmp___2 = dup2(in, 0);
    }
#line 631
    if (tmp___2 < 0) {
      {
#line 632
      tmp___1 = __errno_location();
#line 632
      pex_child_error(obj, executable, "dup2", *tmp___1);
      }
    }
    {
#line 633
    tmp___4 = close(in);
    }
#line 633
    if (tmp___4 < 0) {
      {
#line 634
      tmp___3 = __errno_location();
#line 634
      pex_child_error(obj, executable, "close", *tmp___3);
      }
    }
  }
#line 636
  if (out != 1) {
    {
#line 638
    tmp___6 = dup2(out, 1);
    }
#line 638
    if (tmp___6 < 0) {
      {
#line 639
      tmp___5 = __errno_location();
#line 639
      pex_child_error(obj, executable, "dup2", *tmp___5);
      }
    }
    {
#line 640
    tmp___8 = close(out);
    }
#line 640
    if (tmp___8 < 0) {
      {
#line 641
      tmp___7 = __errno_location();
#line 641
      pex_child_error(obj, executable, "close", *tmp___7);
      }
    }
  }
#line 643
  if (errdes != 2) {
    {
#line 645
    tmp___10 = dup2(errdes, 2);
    }
#line 645
    if (tmp___10 < 0) {
      {
#line 646
      tmp___9 = __errno_location();
#line 646
      pex_child_error(obj, executable, "dup2", *tmp___9);
      }
    }
    {
#line 647
    tmp___12 = close(errdes);
    }
#line 647
    if (tmp___12 < 0) {
      {
#line 648
      tmp___11 = __errno_location();
#line 648
      pex_child_error(obj, executable, "close", *tmp___11);
      }
    }
  }
#line 650
  if (toclose >= 0) {
    {
#line 652
    tmp___14 = close(toclose);
    }
#line 652
    if (tmp___14 < 0) {
      {
#line 653
      tmp___13 = __errno_location();
#line 653
      pex_child_error(obj, executable, "close", *tmp___13);
      }
    }
  }
#line 655
  if ((flags___1 & 8) != 0) {
    {
#line 657
    tmp___16 = dup2(1, 2);
    }
#line 657
    if (tmp___16 < 0) {
      {
#line 658
      tmp___15 = __errno_location();
#line 658
      pex_child_error(obj, executable, "dup2", *tmp___15);
      }
    }
  }
#line 661
  if (env) {
#line 666
    environ = (char **)env;
  }
#line 669
  if ((flags___1 & 2) != 0) {
    {
#line 671
    execvp(executable, argv);
#line 672
    tmp___17 = __errno_location();
#line 672
    pex_child_error(obj, executable, "execvp", *tmp___17);
    }
  } else {
    {
#line 676
    execv(executable, argv);
#line 677
    tmp___18 = __errno_location();
#line 677
    pex_child_error(obj, executable, "execv", *tmp___18);
    }
  }
#line 681
  return (-1);
  switch_default: /* CIL Label */ 
#line 691
  environ = save_environ;
#line 693
  if (in != 0) {
    {
#line 695
    tmp___20 = close(in);
    }
#line 695
    if (tmp___20 < 0) {
      {
#line 697
      tmp___19 = __errno_location();
#line 697
      *err = *tmp___19;
#line 698
      *errmsg = "close";
      }
#line 699
      return (-1);
    }
  }
#line 702
  if (out != 1) {
    {
#line 704
    tmp___22 = close(out);
    }
#line 704
    if (tmp___22 < 0) {
      {
#line 706
      tmp___21 = __errno_location();
#line 706
      *err = *tmp___21;
#line 707
      *errmsg = "close";
      }
#line 708
      return (-1);
    }
  }
#line 711
  if (errdes != 2) {
    {
#line 713
    tmp___24 = close(errdes);
    }
#line 713
    if (tmp___24 < 0) {
      {
#line 715
      tmp___23 = __errno_location();
#line 715
      *err = *tmp___23;
#line 716
      *errmsg = "close";
      }
#line 717
      return (-1);
    }
  }
#line 721
  return (pid);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 728 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static int pex_unix_wait(struct pex_obj *obj , pid_t pid , int *status , struct pex_time *time ,
                         int done___0 , char const   **errmsg , int *err ) 
{ 
  int *tmp___0 ;
  pid_t tmp___1 ;

  {
#line 735
  if (done___0) {
    {
#line 736
    kill(pid, 15);
    }
  }
  {
#line 738
  tmp___1 = pex_wait(obj, pid, status, time);
  }
#line 738
  if (tmp___1 < 0) {
    {
#line 740
    tmp___0 = __errno_location();
#line 740
    *err = *tmp___0;
#line 741
    *errmsg = "wait";
    }
#line 742
    return (-1);
  }
#line 745
  return (0);
}
}
#line 750 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static int pex_unix_pipe(struct pex_obj *obj  __attribute__((__unused__)) , int *p ,
                         int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;

  {
  {
#line 754
  tmp___0 = pipe((int *)p);
  }
#line 754
  return (tmp___0);
}
}
#line 759 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static FILE *pex_unix_fdopenr(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) 
{ 
  FILE *tmp___0 ;

  {
  {
#line 763
  tmp___0 = fdopen(fd, "r");
  }
#line 763
  return (tmp___0);
}
}
#line 766 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static FILE *pex_unix_fdopenw(struct pex_obj *obj  __attribute__((__unused__)) , int fd ,
                              int binary  __attribute__((__unused__)) ) 
{ 
  int tmp___0 ;
  FILE *tmp___1 ;

  {
  {
#line 770
  tmp___0 = fcntl(fd, 2, 1);
  }
#line 770
  if (tmp___0 < 0) {
#line 771
    return ((FILE *)((void *)0));
  }
  {
#line 772
  tmp___1 = fdopen(fd, "w");
  }
#line 772
  return (tmp___1);
}
}
#line 775 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-unix.c"
static void pex_unix_cleanup(struct pex_obj *obj  __attribute__((__unused__)) ) 
{ 


  {
#line 790
  return;
}
}
#line 586 "./../include/libiberty.h"
char const   *pex_one(int flags___1 , char const   *executable , char * const  *argv ,
                      char const   *pname , char const   *outname , char const   *errname ,
                      int *status , int *err ) ;
#line 23 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-one.c"
char const   *pex_one(int flags___1 , char const   *executable , char * const  *argv ,
                      char const   *pname , char const   *outname , char const   *errname ,
                      int *status , int *err ) 
{ 
  struct pex_obj *obj ;
  char const   *errmsg ;
  int tmp___0 ;

  {
  {
#line 31
  obj = pex_init(0, pname, (char const   *)((void *)0));
#line 32
  errmsg = pex_run(obj, flags___1, executable, argv, outname, errname, err);
  }
#line 33
  if ((unsigned long )errmsg == (unsigned long )((void *)0)) {
    {
#line 35
    tmp___0 = pex_get_status(obj, 1, status);
    }
#line 35
    if (! tmp___0) {
#line 37
      *err = 0;
#line 38
      errmsg = "pex_get_status failed";
    }
  }
  {
#line 41
  pex_free(obj);
  }
#line 42
  return (errmsg);
}
}
#line 144 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 142 "./../include/libiberty.h"
char *concat(char const   *first  , ...)  __attribute__((__sentinel__, __malloc__)) ;
#line 233
char *make_temp_file(char const   *suffix )  __attribute__((__malloc__)) ;
#line 511
char const   *pex_run_in_environment(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                     char * const  *argv , char * const  *env , char const   *orig_outname ,
                                     char const   *errname , int *err ) ;
#line 522
FILE *pex_input_file(struct pex_obj *obj , int flags___1 , char const   *in_name ) ;
#line 530
FILE *pex_input_pipe(struct pex_obj *obj , int binary ) ;
#line 538
FILE *pex_read_output(struct pex_obj *obj , int binary ) ;
#line 546
FILE *pex_read_err(struct pex_obj *obj , int binary ) ;
#line 567
int pex_get_times(struct pex_obj *obj , int count , struct pex_time *vector ) ;
#line 707 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemps)(char *__template , int __suffixlen ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
static void pex_add_remove(struct pex_obj *obj , char const   *name___0 , int allocated ) ;
#line 47
static int pex_get_status_and_time(struct pex_obj *obj , int done___0 , char const   **errmsg ,
                                   int *err ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
struct pex_obj *pex_init_common(int flags___1 , char const   *pname , char const   *tempbase ,
                                struct pex_funcs  const  *funcs___0 ) 
{ 
  struct pex_obj *obj ;
  void *tmp___0 ;

  {
  {
#line 58
  tmp___0 = xmalloc(sizeof(struct pex_obj ));
#line 58
  obj = (struct pex_obj *)tmp___0;
#line 59
  obj->flags = flags___1;
#line 60
  obj->pname = pname;
#line 61
  obj->tempbase = tempbase;
#line 62
  obj->next_input = 0;
#line 63
  obj->next_input_name = (char *)((void *)0);
#line 64
  obj->next_input_name_allocated = 0;
#line 65
  obj->stderr_pipe = -1;
#line 66
  obj->count = 0;
#line 67
  obj->children = (pid_t *)((void *)0);
#line 68
  obj->status = (int *)((void *)0);
#line 69
  obj->time = (struct pex_time *)((void *)0);
#line 70
  obj->number_waited = 0;
#line 71
  obj->input_file = (FILE *)((void *)0);
#line 72
  obj->read_output = (FILE *)((void *)0);
#line 73
  obj->read_err = (FILE *)((void *)0);
#line 74
  obj->remove_count = 0;
#line 75
  obj->remove = (char **)((void *)0);
#line 76
  obj->funcs = funcs___0;
#line 77
  obj->sysdep = (void *)0;
  }
#line 78
  return (obj);
}
}
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
static void pex_add_remove(struct pex_obj *obj , char const   *name___0 , int allocated ) 
{ 
  char *add ;
  void *tmp___0 ;

  {
  {
#line 88
  (obj->remove_count) ++;
#line 89
  tmp___0 = xrealloc((void *)obj->remove, sizeof(char *) * (unsigned long )obj->remove_count);
#line 89
  obj->remove = (char **)tmp___0;
  }
#line 90
  if (allocated) {
#line 91
    add = (char *)name___0;
  } else {
    {
#line 93
    add = xstrdup(name___0);
    }
  }
#line 94
  *(obj->remove + (obj->remove_count - 1)) = add;
#line 95
  return;
}
}
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
static char *temp_file(struct pex_obj *obj , int flags___1 , char *name___0 ) 
{ 
  int len ;
  size_t tmp___0 ;
  int out ;
  int tmp___1 ;

  {
#line 105
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 107
    if ((unsigned long )obj->tempbase == (unsigned long )((void *)0)) {
      {
#line 109
      name___0 = make_temp_file((char const   *)((void *)0));
      }
    } else {
      {
#line 113
      tmp___0 = strlen(obj->tempbase);
#line 113
      len = (int )tmp___0;
      }
#line 116
      if (len >= 6) {
        {
#line 116
        tmp___1 = strcmp((obj->tempbase + len) - 6, "XXXXXX");
        }
#line 116
        if (tmp___1 == 0) {
          {
#line 118
          name___0 = xstrdup(obj->tempbase);
          }
        } else {
          {
#line 120
          name___0 = concat(obj->tempbase, "XXXXXX", (void *)0);
          }
        }
      } else {
        {
#line 120
        name___0 = concat(obj->tempbase, "XXXXXX", (void *)0);
        }
      }
      {
#line 122
      out = mkstemps(name___0, 0);
      }
#line 123
      if (out < 0) {
        {
#line 125
        free((void *)name___0);
        }
#line 126
        return ((char *)((void *)0));
      }
      {
#line 133
      close(out);
      }
    }
  } else
#line 136
  if ((flags___1 & 4) != 0) {
#line 138
    if ((unsigned long )obj->tempbase == (unsigned long )((void *)0)) {
      {
#line 139
      name___0 = make_temp_file((char const   *)name___0);
      }
    } else {
      {
#line 141
      name___0 = concat(obj->tempbase, name___0, (void *)0);
      }
    }
  }
#line 144
  return (name___0);
}
}
#line 151 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
char const   *pex_run_in_environment(struct pex_obj *obj , int flags___1 , char const   *executable ,
                                     char * const  *argv , char * const  *env , char const   *orig_outname ,
                                     char const   *errname , int *err ) 
{ 
  char const   *errmsg ;
  int in ;
  int out ;
  int errdes ;
  char *outname ;
  int outname_allocated ;
  int p[2] ;
  int toclose ;
  pid_t pid ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  void *tmp___9 ;

  {
#line 165
  in = -1;
#line 166
  out = -1;
#line 167
  errdes = -1;
#line 168
  outname = (char *)orig_outname;
#line 169
  outname_allocated = 0;
#line 172
  if (obj->input_file) {
    {
#line 174
    tmp___0 = fclose(obj->input_file);
    }
#line 174
    if (tmp___0 == -1) {
#line 176
      errmsg = "closing pipeline input file";
#line 177
      goto error_exit;
    }
#line 179
    obj->input_file = (FILE *)((void *)0);
  }
#line 184
  if ((unsigned long )obj->next_input_name != (unsigned long )((void *)0)) {
    {
#line 188
    tmp___1 = pex_get_status_and_time(obj, 0, & errmsg, err);
    }
#line 188
    if (! tmp___1) {
#line 189
      goto error_exit;
    }
    {
#line 191
    in = (*((obj->funcs)->open_read))(obj, (char const   *)obj->next_input_name, (flags___1 & 16) != 0);
    }
#line 193
    if (in < 0) {
      {
#line 195
      tmp___2 = __errno_location();
#line 195
      *err = *tmp___2;
#line 196
      errmsg = "open temporary file";
      }
#line 197
      goto error_exit;
    }
#line 199
    if (obj->next_input_name_allocated) {
      {
#line 201
      free((void *)obj->next_input_name);
#line 202
      obj->next_input_name_allocated = 0;
      }
    }
#line 204
    obj->next_input_name = (char *)((void *)0);
  } else {
#line 208
    in = obj->next_input;
#line 209
    if (in < 0) {
#line 211
      *err = 0;
#line 212
      errmsg = "pipeline already complete";
#line 213
      goto error_exit;
    }
  }
#line 219
  if ((flags___1 & 1) != 0) {
#line 221
    if ((unsigned long )outname == (unsigned long )((void *)0)) {
#line 222
      out = 1;
    } else
#line 223
    if ((flags___1 & 4) != 0) {
      {
#line 225
      outname = concat(obj->tempbase, outname, (void *)0);
#line 226
      outname_allocated = 1;
      }
    }
#line 228
    obj->next_input = -1;
  } else
#line 230
  if ((obj->flags & 2) == 0) {
    {
#line 232
    outname = temp_file(obj, flags___1, outname);
    }
#line 233
    if (! outname) {
#line 235
      *err = 0;
#line 236
      errmsg = "could not create temporary file";
#line 237
      goto error_exit;
    }
#line 240
    if ((unsigned long )outname != (unsigned long )orig_outname) {
#line 241
      outname_allocated = 1;
    }
#line 243
    if ((obj->flags & 4) == 0) {
      {
#line 245
      pex_add_remove(obj, (char const   *)outname, outname_allocated);
#line 246
      outname_allocated = 0;
      }
    }
#line 250
    obj->next_input_name = outname;
#line 251
    obj->next_input_name_allocated = outname_allocated;
#line 252
    outname_allocated = 0;
  } else {
    {
#line 256
    tmp___4 = (*((obj->funcs)->pipe))(obj, p, (flags___1 & 32) != 0);
    }
#line 256
    if (tmp___4 < 0) {
      {
#line 258
      tmp___3 = __errno_location();
#line 258
      *err = *tmp___3;
#line 259
      errmsg = "pipe";
      }
#line 260
      goto error_exit;
    }
#line 263
    out = p[1];
#line 264
    obj->next_input = p[0];
  }
#line 267
  if (out < 0) {
    {
#line 269
    out = (*((obj->funcs)->open_write))(obj, (char const   *)outname, (flags___1 & 32) != 0);
    }
#line 271
    if (out < 0) {
      {
#line 273
      tmp___5 = __errno_location();
#line 273
      *err = *tmp___5;
#line 274
      errmsg = "open temporary output file";
      }
#line 275
      goto error_exit;
    }
  }
#line 279
  if (outname_allocated) {
    {
#line 281
    free((void *)outname);
#line 282
    outname_allocated = 0;
    }
  }
#line 287
  if ((unsigned long )errname != (unsigned long )((void *)0)) {
#line 287
    if ((flags___1 & 64) != 0) {
#line 289
      *err = 0;
#line 290
      errmsg = "both ERRNAME and PEX_STDERR_TO_PIPE specified.";
#line 291
      goto error_exit;
    }
  }
#line 294
  if (obj->stderr_pipe != -1) {
#line 296
    *err = 0;
#line 297
    errmsg = "PEX_STDERR_TO_PIPE used in the middle of pipeline";
#line 298
    goto error_exit;
  }
#line 301
  if ((unsigned long )errname == (unsigned long )((void *)0)) {
#line 303
    if (flags___1 & 64) {
      {
#line 305
      tmp___7 = (*((obj->funcs)->pipe))(obj, p, (flags___1 & 128) != 0);
      }
#line 305
      if (tmp___7 < 0) {
        {
#line 307
        tmp___6 = __errno_location();
#line 307
        *err = *tmp___6;
#line 308
        errmsg = "pipe";
        }
#line 309
        goto error_exit;
      }
#line 312
      errdes = p[1];
#line 313
      obj->stderr_pipe = p[0];
    } else {
#line 317
      errdes = 2;
    }
  } else {
    {
#line 322
    errdes = (*((obj->funcs)->open_write))(obj, errname, (flags___1 & 128) != 0);
    }
#line 324
    if (errdes < 0) {
      {
#line 326
      tmp___8 = __errno_location();
#line 326
      *err = *tmp___8;
#line 327
      errmsg = "open error file";
      }
#line 328
      goto error_exit;
    }
  }
#line 335
  if ((obj->flags & 2) == 0) {
#line 336
    toclose = -1;
  } else {
#line 338
    toclose = obj->next_input;
  }
  {
#line 342
  pid = (*((obj->funcs)->exec_child))(obj, flags___1, executable, argv, env, in, out,
                                      errdes, toclose, & errmsg, err);
  }
#line 344
  if (pid < 0) {
#line 345
    goto error_exit;
  }
  {
#line 347
  (obj->count) ++;
#line 348
  tmp___9 = xrealloc((void *)obj->children, sizeof(pid_t ) * (unsigned long )obj->count);
#line 348
  obj->children = (pid_t *)tmp___9;
#line 349
  *(obj->children + (obj->count - 1)) = pid;
  }
#line 351
  return ((char const   *)((void *)0));
  error_exit: 
#line 354
  if (in >= 0) {
#line 354
    if (in != 0) {
      {
#line 355
      (*((obj->funcs)->close))(obj, in);
      }
    }
  }
#line 356
  if (out >= 0) {
#line 356
    if (out != 1) {
      {
#line 357
      (*((obj->funcs)->close))(obj, out);
      }
    }
  }
#line 358
  if (errdes >= 0) {
#line 358
    if (errdes != 2) {
      {
#line 359
      (*((obj->funcs)->close))(obj, errdes);
      }
    }
  }
#line 360
  if (outname_allocated) {
    {
#line 361
    free((void *)outname);
    }
  }
#line 362
  return (errmsg);
}
}
#line 367 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
char const   *pex_run(struct pex_obj *obj , int flags___1 , char const   *executable ,
                      char * const  *argv , char const   *orig_outname , char const   *errname ,
                      int *err ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 372
  tmp___0 = pex_run_in_environment(obj, flags___1, executable, argv, (char * const  *)((void *)0),
                                   orig_outname, errname, err);
  }
#line 372
  return (tmp___0);
}
}
#line 378 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
FILE *pex_input_file(struct pex_obj *obj , int flags___1 , char const   *in_name ) 
{ 
  char *name___0 ;
  FILE *f ;
  int *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 381
  name___0 = (char *)in_name;
#line 386
  if (obj->count != 0) {
    {
#line 390
    tmp___0 = __errno_location();
#line 390
    *tmp___0 = 22;
    }
#line 391
    return ((FILE *)((void *)0));
  } else
#line 386
  if (obj->next_input >= 0) {
#line 386
    if (obj->next_input != 0) {
      {
#line 390
      tmp___0 = __errno_location();
#line 390
      *tmp___0 = 22;
      }
#line 391
      return ((FILE *)((void *)0));
    } else {
#line 386
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 386
  if (obj->next_input_name) {
    {
#line 390
    tmp___0 = __errno_location();
#line 390
    *tmp___0 = 22;
    }
#line 391
    return ((FILE *)((void *)0));
  }
  {
#line 394
  name___0 = temp_file(obj, flags___1, name___0);
  }
#line 395
  if (! name___0) {
#line 396
    return ((FILE *)((void *)0));
  }
#line 398
  if (flags___1 & 32) {
#line 398
    tmp___1 = "wb";
  } else {
#line 398
    tmp___1 = "w";
  }
  {
#line 398
  f = fopen((char const   */* __restrict  */)name___0, (char const   */* __restrict  */)tmp___1);
  }
#line 399
  if (! f) {
    {
#line 401
    free((void *)name___0);
    }
#line 402
    return ((FILE *)((void *)0));
  }
#line 405
  obj->input_file = f;
#line 406
  obj->next_input_name = name___0;
#line 407
  obj->next_input_name_allocated = (unsigned long )name___0 != (unsigned long )in_name;
#line 409
  return (f);
}
}
#line 414 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
FILE *pex_input_pipe(struct pex_obj *obj , int binary ) 
{ 
  int p[2] ;
  FILE *f ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 421
  if (obj->count > 0) {
#line 422
    goto usage_error;
  }
#line 426
  if (! (obj->flags & 2)) {
#line 427
    goto usage_error;
  }
#line 431
  if (obj->next_input >= 0) {
#line 431
    if (obj->next_input != 0) {
#line 433
      goto usage_error;
    } else {
#line 431
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 431
  if (obj->next_input_name) {
#line 433
    goto usage_error;
  }
  {
#line 435
  tmp___0 = (*((obj->funcs)->pipe))(obj, p, binary != 0);
  }
#line 435
  if (tmp___0 < 0) {
#line 436
    return ((FILE *)((void *)0));
  }
  {
#line 438
  f = (*((obj->funcs)->fdopenw))(obj, p[1], binary != 0);
  }
#line 439
  if (! f) {
    {
#line 441
    tmp___1 = __errno_location();
#line 441
    saved_errno = *tmp___1;
#line 442
    (*((obj->funcs)->close))(obj, p[0]);
#line 443
    (*((obj->funcs)->close))(obj, p[1]);
#line 444
    tmp___2 = __errno_location();
#line 444
    *tmp___2 = saved_errno;
    }
#line 445
    return ((FILE *)((void *)0));
  }
#line 448
  obj->next_input = p[0];
#line 450
  return (f);
  usage_error: 
  {
#line 453
  tmp___3 = __errno_location();
#line 453
  *tmp___3 = 22;
  }
#line 454
  return ((FILE *)((void *)0));
}
}
#line 460 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
FILE *pex_read_output(struct pex_obj *obj , int binary ) 
{ 
  char const   *errmsg ;
  int err ;
  int *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int o ;

  {
#line 463
  if ((unsigned long )obj->next_input_name != (unsigned long )((void *)0)) {
    {
#line 470
    tmp___1 = pex_get_status_and_time(obj, 0, & errmsg, & err);
    }
#line 470
    if (! tmp___1) {
      {
#line 472
      tmp___0 = __errno_location();
#line 472
      *tmp___0 = err;
      }
#line 473
      return ((FILE *)((void *)0));
    }
#line 476
    if (binary) {
#line 476
      tmp___2 = "rb";
    } else {
#line 476
      tmp___2 = "r";
    }
    {
#line 476
    obj->read_output = fopen((char const   */* __restrict  */)obj->next_input_name,
                             (char const   */* __restrict  */)tmp___2);
    }
#line 478
    if (obj->next_input_name_allocated) {
      {
#line 480
      free((void *)obj->next_input_name);
#line 481
      obj->next_input_name_allocated = 0;
      }
    }
#line 483
    obj->next_input_name = (char *)((void *)0);
  } else {
#line 489
    o = obj->next_input;
#line 490
    if (o < 0) {
#line 491
      return ((FILE *)((void *)0));
    } else
#line 490
    if (o == 0) {
#line 491
      return ((FILE *)((void *)0));
    }
    {
#line 492
    obj->read_output = (*((obj->funcs)->fdopenr))(obj, o, binary);
#line 493
    obj->next_input = -1;
    }
  }
#line 496
  return (obj->read_output);
}
}
#line 499 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
FILE *pex_read_err(struct pex_obj *obj , int binary ) 
{ 
  int o ;

  {
#line 504
  o = obj->stderr_pipe;
#line 505
  if (o < 0) {
#line 506
    return ((FILE *)((void *)0));
  } else
#line 505
  if (o == 0) {
#line 506
    return ((FILE *)((void *)0));
  }
  {
#line 507
  obj->read_err = (*((obj->funcs)->fdopenr))(obj, o, binary);
#line 508
  obj->stderr_pipe = -1;
  }
#line 509
  return (obj->read_err);
}
}
#line 515 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
static int pex_get_status_and_time(struct pex_obj *obj , int done___0 , char const   **errmsg ,
                                   int *err ) 
{ 
  int ret ;
  int i ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct pex_time *tmp___2 ;
  pid_t tmp___3 ;

  {
#line 522
  if (obj->number_waited == obj->count) {
#line 523
    return (1);
  }
  {
#line 525
  tmp___0 = xrealloc((void *)obj->status, sizeof(int ) * (unsigned long )obj->count);
#line 525
  obj->status = (int *)tmp___0;
  }
#line 526
  if ((obj->flags & 1) != 0) {
    {
#line 527
    tmp___1 = xrealloc((void *)obj->time, sizeof(struct pex_time ) * (unsigned long )obj->count);
#line 527
    obj->time = (struct pex_time *)tmp___1;
    }
  }
#line 529
  ret = 1;
#line 530
  i = obj->number_waited;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! (i < obj->count)) {
#line 530
      goto while_break;
    }
#line 532
    if ((unsigned long )obj->time == (unsigned long )((void *)0)) {
#line 532
      tmp___2 = (struct pex_time *)((void *)0);
    } else {
#line 532
      tmp___2 = obj->time + i;
    }
    {
#line 532
    tmp___3 = (*((obj->funcs)->wait))(obj, *(obj->children + i), obj->status + i,
                                      tmp___2, done___0, errmsg, err);
    }
#line 532
    if (tmp___3 < 0) {
#line 535
      ret = 0;
    }
#line 530
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 537
  obj->number_waited = i;
#line 539
  return (ret);
}
}
#line 544 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
int pex_get_status(struct pex_obj *obj , int count , int *vector ) 
{ 
  char const   *errmsg ;
  int err ;
  int tmp___0 ;

  {
#line 547
  if ((unsigned long )obj->status == (unsigned long )((void *)0)) {
    {
#line 552
    tmp___0 = pex_get_status_and_time(obj, 0, & errmsg, & err);
    }
#line 552
    if (! tmp___0) {
#line 553
      return (0);
    }
  }
#line 556
  if (count > obj->count) {
    {
#line 558
    memset((void *)(vector + obj->count), 0, (unsigned long )(count - obj->count) * sizeof(int ));
#line 559
    count = obj->count;
    }
  }
  {
#line 562
  memcpy((void */* __restrict  */)vector, (void const   */* __restrict  */)obj->status,
         (unsigned long )count * sizeof(int ));
  }
#line 564
  return (1);
}
}
#line 569 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
int pex_get_times(struct pex_obj *obj , int count , struct pex_time *vector ) 
{ 
  char const   *errmsg ;
  int err ;
  int tmp___0 ;

  {
#line 572
  if ((unsigned long )obj->status == (unsigned long )((void *)0)) {
    {
#line 577
    tmp___0 = pex_get_status_and_time(obj, 0, & errmsg, & err);
    }
#line 577
    if (! tmp___0) {
#line 578
      return (0);
    }
  }
#line 581
  if ((unsigned long )obj->time == (unsigned long )((void *)0)) {
#line 582
    return (0);
  }
#line 584
  if (count > obj->count) {
    {
#line 586
    memset((void *)(vector + obj->count), 0, (unsigned long )(count - obj->count) * sizeof(struct pex_time ));
#line 588
    count = obj->count;
    }
  }
  {
#line 591
  memcpy((void */* __restrict  */)vector, (void const   */* __restrict  */)obj->time,
         (unsigned long )count * sizeof(struct pex_time ));
  }
#line 593
  return (1);
}
}
#line 598 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./pex-common.c"
void pex_free(struct pex_obj *obj ) 
{ 
  char const   *errmsg ;
  int err ;
  int i ;

  {
#line 604
  if (obj->next_input >= 0) {
#line 604
    if (obj->next_input != 0) {
      {
#line 605
      (*((obj->funcs)->close))(obj, obj->next_input);
      }
    }
  }
#line 606
  if (obj->stderr_pipe >= 0) {
#line 606
    if (obj->stderr_pipe != 0) {
      {
#line 607
      (*((obj->funcs)->close))(obj, obj->stderr_pipe);
      }
    }
  }
#line 608
  if ((unsigned long )obj->read_output != (unsigned long )((void *)0)) {
    {
#line 609
    fclose(obj->read_output);
    }
  }
#line 610
  if ((unsigned long )obj->read_err != (unsigned long )((void *)0)) {
    {
#line 611
    fclose(obj->read_err);
    }
  }
#line 615
  if ((unsigned long )obj->status == (unsigned long )((void *)0)) {
    {
#line 620
    obj->flags &= -2;
#line 621
    pex_get_status_and_time(obj, 1, & errmsg, & err);
    }
  }
#line 624
  if (obj->next_input_name_allocated) {
    {
#line 625
    free((void *)obj->next_input_name);
    }
  }
  {
#line 626
  free((void *)obj->children);
#line 627
  free((void *)obj->status);
#line 628
  free((void *)obj->time);
  }
#line 630
  if (obj->remove_count > 0) {
#line 634
    i = 0;
    {
#line 634
    while (1) {
      while_continue: /* CIL Label */ ;
#line 634
      if (! (i < obj->remove_count)) {
#line 634
        goto while_break;
      }
      {
#line 636
      remove((char const   *)*(obj->remove + i));
#line 637
      free((void *)*(obj->remove + i));
#line 634
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 639
    free((void *)obj->remove);
    }
  }
#line 642
  if ((unsigned long )(obj->funcs)->cleanup != (unsigned long )((void *)0)) {
    {
#line 643
    (*((obj->funcs)->cleanup))(obj);
    }
  }
  {
#line 645
  free((void *)obj);
  }
#line 646
  return;
}
}
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 67 "./../include/partition.h"
partition partition_new(int num_elements ) ;
#line 68
void partition_delete(partition part ) ;
#line 69
int partition_union(partition part , int elem1 , int elem2 ) ;
#line 70
void partition_print(partition part , FILE *fp ) ;
#line 37 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./partition.c"
static int elem_compare(void const   *elem1 , void const   *elem2 ) ;
#line 42 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./partition.c"
partition partition_new(int num_elements ) 
{ 
  int e ;
  partition part ;
  void *tmp___0 ;

  {
  {
#line 47
  tmp___0 = xmalloc(sizeof(struct partition_def ) + (unsigned long )(num_elements - 1) * sizeof(struct partition_elem ));
#line 47
  part = (partition )tmp___0;
#line 50
  part->num_elements = num_elements;
#line 51
  e = 0;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! (e < num_elements)) {
#line 51
      goto while_break;
    }
#line 53
    part->elements[e].class_element = e;
#line 54
    part->elements[e].next = & part->elements[e];
#line 55
    part->elements[e].class_count = 1U;
#line 51
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (part);
}
}
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./partition.c"
void partition_delete(partition part ) 
{ 


  {
  {
#line 66
  free((void *)part);
  }
#line 67
  return;
}
}
#line 74 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./partition.c"
int partition_union(partition part , int elem1 , int elem2 ) 
{ 
  struct partition_elem *elements ;
  struct partition_elem *e1 ;
  struct partition_elem *e2 ;
  struct partition_elem *p ;
  struct partition_elem *old_next ;
  int class_element ;
  int temp ;

  {
#line 77
  elements = part->elements;
#line 83
  class_element = (elements + elem1)->class_element;
#line 86
  if (class_element == (elements + elem2)->class_element) {
#line 87
    return (class_element);
  }
#line 91
  if ((elements + elem1)->class_count < (elements + elem2)->class_count) {
#line 93
    temp = elem1;
#line 94
    elem1 = elem2;
#line 95
    elem2 = temp;
#line 96
    class_element = (elements + elem1)->class_element;
  }
#line 99
  e1 = elements + elem1;
#line 100
  e2 = elements + elem2;
#line 103
  (elements + class_element)->class_count += (elements + e2->class_element)->class_count;
#line 107
  e2->class_element = class_element;
#line 108
  p = e2->next;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! ((unsigned long )p != (unsigned long )e2)) {
#line 108
      goto while_break;
    }
#line 109
    p->class_element = class_element;
#line 108
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  old_next = e1->next;
#line 114
  e1->next = e2->next;
#line 115
  e2->next = old_next;
#line 117
  return (class_element);
}
}
#line 123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./partition.c"
static int elem_compare(void const   *elem1 , void const   *elem2 ) 
{ 
  int e1 ;
  int e2 ;

  {
#line 126
  e1 = (int )*((int const   *)elem1);
#line 127
  e2 = (int )*((int const   *)elem2);
#line 128
  if (e1 < e2) {
#line 129
    return (-1);
  } else
#line 130
  if (e1 > e2) {
#line 131
    return (1);
  } else {
#line 133
    return (0);
  }
}
}
#line 139 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./partition.c"
void partition_print(partition part , FILE *fp ) 
{ 
  char *done___0 ;
  int num_elements ;
  struct partition_elem *elements ;
  int *class_elements ;
  int e ;
  void *tmp___0 ;
  void *tmp___1 ;
  int c ;
  int count ;
  int i ;
  char const   *tmp___2 ;

  {
  {
#line 143
  num_elements = part->num_elements;
#line 144
  elements = part->elements;
#line 149
  tmp___0 = xmalloc((size_t )num_elements);
#line 149
  done___0 = (char *)tmp___0;
#line 150
  memset((void *)done___0, 0, (size_t )num_elements);
#line 153
  tmp___1 = xmalloc((unsigned long )num_elements * sizeof(int ));
#line 153
  class_elements = (int *)tmp___1;
#line 155
  fputc('[', fp);
#line 156
  e = 0;
  }
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (e < num_elements)) {
#line 156
      goto while_break;
    }
#line 158
    if (! *(done___0 + e)) {
#line 160
      c = e;
#line 161
      count = (int )(elements + (elements + e)->class_element)->class_count;
#line 165
      i = 0;
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 165
        if (! (i < count)) {
#line 165
          goto while_break___0;
        }
#line 166
        *(class_elements + i) = c;
#line 167
        *(done___0 + c) = (char)1;
#line 168
        c = (int )((elements + c)->next - elements);
#line 165
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 171
      qsort((void *)class_elements, (size_t )count, sizeof(int ), & elem_compare);
#line 173
      fputc('(', fp);
#line 174
      i = 0;
      }
      {
#line 174
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 174
        if (! (i < count)) {
#line 174
          goto while_break___1;
        }
#line 175
        if (i == 0) {
#line 175
          tmp___2 = "%d";
        } else {
#line 175
          tmp___2 = " %d";
        }
        {
#line 175
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)tmp___2,
                *(class_elements + i));
#line 174
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 176
      fputc(')', fp);
      }
    }
#line 156
    e ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 178
  fputc(']', fp);
#line 180
  free((void *)class_elements);
#line 181
  free((void *)done___0);
  }
#line 182
  return;
}
}
#line 67 "./../include/objalloc.h"
struct objalloc *objalloc_create(void) ;
#line 72
void *_objalloc_alloc(struct objalloc *o , unsigned long len ) ;
#line 108
void objalloc_free(struct objalloc *o ) ;
#line 113
void objalloc_free_block(struct objalloc *o , void *block ) ;
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./objalloc.c"
struct objalloc *objalloc_create(void) 
{ 
  struct objalloc *ret ;
  struct objalloc_chunk *chunk ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 91
  tmp___0 = malloc(sizeof(*ret));
#line 91
  ret = (struct objalloc *)tmp___0;
  }
#line 92
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 93
    return ((struct objalloc *)((void *)0));
  }
  {
#line 95
  tmp___1 = malloc((size_t )4064);
#line 95
  ret->chunks = tmp___1;
  }
#line 96
  if ((unsigned long )ret->chunks == (unsigned long )((void *)0)) {
    {
#line 98
    free((void *)ret);
    }
#line 99
    return ((struct objalloc *)((void *)0));
  }
#line 102
  chunk = (struct objalloc_chunk *)ret->chunks;
#line 103
  chunk->next = (struct objalloc_chunk *)((void *)0);
#line 104
  chunk->current_ptr = (char *)((void *)0);
#line 106
  ret->current_ptr = (char *)chunk + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL));
#line 107
  ret->current_space = (unsigned int )(4064UL - (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)));
#line 109
  return (ret);
}
}
#line 114 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./objalloc.c"
void *_objalloc_alloc(struct objalloc *o , unsigned long len ) 
{ 
  char *ret ;
  struct objalloc_chunk *chunk ;
  void *tmp___0 ;
  struct objalloc_chunk *chunk___0 ;
  void *tmp___1 ;
  struct objalloc *__o ;
  unsigned long __len ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 119
  if (len == 0UL) {
#line 120
    len = 1UL;
  }
#line 122
  len = ((len + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL);
#line 124
  if (len <= (unsigned long )o->current_space) {
#line 126
    o->current_ptr += len;
#line 127
    o->current_space = (unsigned int )((unsigned long )o->current_space - len);
#line 128
    return ((void *)(o->current_ptr - len));
  }
#line 131
  if (len >= 512UL) {
    {
#line 136
    tmp___0 = malloc((((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)) + len);
#line 136
    ret = (char *)tmp___0;
    }
#line 137
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 138
      return ((void *)0);
    }
#line 140
    chunk = (struct objalloc_chunk *)ret;
#line 141
    chunk->next = (struct objalloc_chunk *)o->chunks;
#line 142
    chunk->current_ptr = o->current_ptr;
#line 144
    o->chunks = (void *)chunk;
#line 146
    return ((void *)(ret + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL))));
  } else {
    {
#line 152
    tmp___1 = malloc((size_t )4064);
#line 152
    chunk___0 = (struct objalloc_chunk *)tmp___1;
    }
#line 153
    if ((unsigned long )chunk___0 == (unsigned long )((void *)0)) {
#line 154
      return ((void *)0);
    }
#line 155
    chunk___0->next = (struct objalloc_chunk *)o->chunks;
#line 156
    chunk___0->current_ptr = (char *)((void *)0);
#line 158
    o->current_ptr = (char *)chunk___0 + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL));
#line 159
    o->current_space = (unsigned int )(4064UL - (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)));
#line 161
    o->chunks = (void *)chunk___0;
#line 163
    __o = o;
#line 163
    __len = len;
#line 163
    if (__len == 0UL) {
#line 163
      __len = 1UL;
    }
#line 163
    __len = ((__len + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL);
#line 163
    if (__len <= (unsigned long )__o->current_space) {
#line 163
      __o->current_ptr += __len;
#line 163
      __o->current_space = (unsigned int )((unsigned long )__o->current_space - __len);
#line 163
      tmp___3 = (void *)(__o->current_ptr - __len);
    } else {
      {
#line 163
      tmp___2 = _objalloc_alloc(__o, __len);
#line 163
      tmp___3 = tmp___2;
      }
    }
#line 163
    return (tmp___3);
  }
}
}
#line 169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./objalloc.c"
void objalloc_free(struct objalloc *o ) 
{ 
  struct objalloc_chunk *l ;
  struct objalloc_chunk *next ;

  {
#line 174
  l = (struct objalloc_chunk *)o->chunks;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 175
      goto while_break;
    }
    {
#line 179
    next = l->next;
#line 180
    free((void *)l);
#line 181
    l = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 184
  free((void *)o);
  }
#line 185
  return;
}
}
#line 190 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./objalloc.c"
void objalloc_free_block(struct objalloc *o , void *block ) 
{ 
  struct objalloc_chunk *p ;
  struct objalloc_chunk *small ;
  char *b ;
  struct objalloc_chunk *q ;
  struct objalloc_chunk *first ;
  struct objalloc_chunk *next ;
  struct objalloc_chunk *q___0 ;
  char *current_ptr ;
  struct objalloc_chunk *next___0 ;

  {
#line 194
  b = (char *)block;
#line 198
  small = (struct objalloc_chunk *)((void *)0);
#line 199
  p = (struct objalloc_chunk *)o->chunks;
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 199
      goto while_break;
    }
#line 201
    if ((unsigned long )p->current_ptr == (unsigned long )((void *)0)) {
#line 203
      if ((unsigned long )b > (unsigned long )((char *)p)) {
#line 203
        if ((unsigned long )b < (unsigned long )((char *)p + 4064)) {
#line 204
          goto while_break;
        }
      }
#line 205
      small = p;
    } else
#line 209
    if ((unsigned long )b == (unsigned long )((char *)p + (((sizeof(struct objalloc_chunk ) + (unsigned long )(& ((struct objalloc_align *)0)->d)) - 1UL) & ~ ((unsigned long )(& ((struct objalloc_align *)0)->d) - 1UL)))) {
#line 210
      goto while_break;
    }
#line 199
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 216
    abort();
    }
  }
#line 218
  if ((unsigned long )p->current_ptr == (unsigned long )((void *)0)) {
#line 230
    first = (struct objalloc_chunk *)((void *)0);
#line 231
    q = (struct objalloc_chunk *)o->chunks;
    {
#line 232
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 232
      if (! ((unsigned long )q != (unsigned long )p)) {
#line 232
        goto while_break___0;
      }
#line 236
      next = q->next;
#line 237
      if ((unsigned long )small != (unsigned long )((void *)0)) {
#line 239
        if ((unsigned long )small == (unsigned long )q) {
#line 240
          small = (struct objalloc_chunk *)((void *)0);
        }
        {
#line 241
        free((void *)q);
        }
      } else
#line 243
      if ((unsigned long )q->current_ptr > (unsigned long )b) {
        {
#line 244
        free((void *)q);
        }
      } else
#line 245
      if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 246
        first = q;
      }
#line 248
      q = next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 251
    if ((unsigned long )first == (unsigned long )((void *)0)) {
#line 252
      first = p;
    }
#line 253
    o->chunks = (void *)first;
#line 256
    o->current_ptr = b;
#line 257
    o->current_space = (unsigned int )(((char *)p + 4064) - b);
  } else {
#line 270
    current_ptr = p->current_ptr;
#line 271
    p = p->next;
#line 273
    q___0 = (struct objalloc_chunk *)o->chunks;
    {
#line 274
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 274
      if (! ((unsigned long )q___0 != (unsigned long )p)) {
#line 274
        goto while_break___1;
      }
      {
#line 278
      next___0 = q___0->next;
#line 279
      free((void *)q___0);
#line 280
      q___0 = next___0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 283
    o->chunks = (void *)p;
    {
#line 285
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 285
      if (! ((unsigned long )p->current_ptr != (unsigned long )((void *)0))) {
#line 285
        goto while_break___2;
      }
#line 286
      p = p->next;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 288
    o->current_ptr = current_ptr;
#line 289
    o->current_space = (unsigned int )(((char *)p + 4064) - current_ptr);
  }
#line 291
  return;
}
}
#line 99 "./../include/md5.h"
void md5_init_ctx(struct md5_ctx *ctx ) ;
#line 105
void md5_process_block(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) ;
#line 112
void md5_process_bytes(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) ;
#line 122
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) ;
#line 131
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) ;
#line 137
int md5_stream(FILE *stream , void *resblock ) ;
#line 143
void *md5_buffer(char const   *buffer___2 , size_t len , void *resblock ) ;
#line 59 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
void md5_init_ctx(struct md5_ctx *ctx ) 
{ 
  md5_uint32 tmp___0 ;

  {
#line 67
  ctx->A = (md5_uint32 )1732584193;
#line 68
  ctx->B = 4023233417U;
#line 69
  ctx->C = 2562383102U;
#line 70
  ctx->D = (md5_uint32 )271733878;
#line 72
  tmp___0 = (md5_uint32 )0;
#line 72
  ctx->total[1] = tmp___0;
#line 72
  ctx->total[0] = tmp___0;
#line 73
  ctx->buflen = (md5_uint32 )0;
#line 74
  return;
}
}
#line 81 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
void *md5_read_ctx(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  md5_uint32 buffer___2[4] ;

  {
  {
#line 86
  buffer___2[0] = (md5_uint32 )ctx->A;
#line 87
  buffer___2[1] = (md5_uint32 )ctx->B;
#line 88
  buffer___2[2] = (md5_uint32 )ctx->C;
#line 89
  buffer___2[3] = (md5_uint32 )ctx->D;
#line 91
  memcpy((void */* __restrict  */)resbuf, (void const   */* __restrict  */)(buffer___2),
         (size_t )16);
  }
#line 93
  return (resbuf);
}
}
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
void *md5_finish_ctx(struct md5_ctx *ctx , void *resbuf ) 
{ 
  md5_uint32 bytes ;
  md5_uint32 swap_bytes ;
  size_t pad ;
  void *tmp___0 ;

  {
#line 105
  bytes = ctx->buflen;
#line 110
  ctx->total[0] += bytes;
#line 111
  if (ctx->total[0] < bytes) {
#line 112
    (ctx->total[1]) ++;
  }
#line 114
  if (bytes >= 56U) {
#line 114
    pad = (size_t )(120U - bytes);
  } else {
#line 114
    pad = (size_t )(56U - bytes);
  }
  {
#line 115
  memcpy((void */* __restrict  */)(& ctx->buffer[bytes]), (void const   */* __restrict  */)(fillbuf___0),
         pad);
#line 120
  swap_bytes = ctx->total[0] << 3;
#line 121
  memcpy((void */* __restrict  */)(& ctx->buffer[(size_t )bytes + pad]), (void const   */* __restrict  */)(& swap_bytes),
         sizeof(swap_bytes));
#line 122
  swap_bytes = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 123
  memcpy((void */* __restrict  */)(& ctx->buffer[((size_t )bytes + pad) + 4UL]), (void const   */* __restrict  */)(& swap_bytes),
         sizeof(swap_bytes));
#line 126
  md5_process_block((void const   *)(ctx->buffer), ((size_t )bytes + pad) + 8UL, ctx);
#line 128
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
  }
#line 128
  return (tmp___0);
}
}
#line 134 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
int md5_stream(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  char buffer___2[4168] ;
  size_t sum ;
  size_t n ;
  int tmp___0 ;

  {
  {
#line 144
  md5_init_ctx(& ctx);
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    sum = (size_t )0;
    {
#line 156
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 158
      n = fread((void */* __restrict  */)(buffer___2 + sum), (size_t )1, 4096UL - sum,
                (FILE */* __restrict  */)stream);
#line 160
      sum += n;
      }
#line 156
      if (sum < 4096UL) {
#line 156
        if (! (n != 0UL)) {
#line 156
          goto while_break___0;
        }
      } else {
#line 156
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 163
    if (n == 0UL) {
      {
#line 163
      tmp___0 = ferror(stream);
      }
#line 163
      if (tmp___0) {
#line 164
        return (1);
      }
    }
#line 167
    if (n == 0UL) {
#line 168
      goto while_break;
    }
    {
#line 173
    md5_process_block((void const   *)(buffer___2), (size_t )4096, & ctx);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  if (sum > 0UL) {
    {
#line 178
    md5_process_bytes((void const   *)(buffer___2), sum, & ctx);
    }
  }
  {
#line 181
  md5_finish_ctx(& ctx, resblock);
  }
#line 182
  return (0);
}
}
#line 189 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
void *md5_buffer(char const   *buffer___2 , size_t len , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp___0 ;

  {
  {
#line 195
  md5_init_ctx(& ctx);
#line 198
  md5_process_bytes((void const   *)buffer___2, len, & ctx);
#line 201
  tmp___0 = md5_finish_ctx(& ctx, resblock);
  }
#line 201
  return (tmp___0);
}
}
#line 205 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
void md5_process_bytes(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp___0 ;

  {
#line 210
  if (ctx->buflen != 0U) {
#line 212
    left_over = (size_t )ctx->buflen;
#line 213
    if (128UL - left_over > len) {
#line 213
      tmp___0 = len;
    } else {
#line 213
      tmp___0 = 128UL - left_over;
    }
    {
#line 213
    add = tmp___0;
#line 215
    memcpy((void */* __restrict  */)(& ctx->buffer[left_over]), (void const   */* __restrict  */)buffer___2,
           add);
#line 216
    ctx->buflen = (md5_uint32 )((size_t )ctx->buflen + add);
    }
#line 218
    if (left_over + add > 64UL) {
      {
#line 220
      md5_process_block((void const   *)(ctx->buffer), (left_over + add) & 0xffffffffffffffc0UL,
                        ctx);
#line 222
      memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)(& ctx->buffer[(left_over + add) & 0xffffffffffffffc0UL]),
             (left_over + add) & 63UL);
#line 224
      ctx->buflen = (md5_uint32 )((left_over + add) & 63UL);
      }
    }
#line 227
    buffer___2 = (void const   *)((char const   *)buffer___2 + add);
#line 228
    len -= add;
  }
#line 232
  if (len > 64UL) {
#line 242
    if ((md5_uintptr )buffer___2 % __alignof__(md5_uint32 ) != 0UL) {
      {
#line 243
      while (1) {
        while_continue: /* CIL Label */ ;
#line 243
        if (! (len > 64UL)) {
#line 243
          goto while_break;
        }
        {
#line 245
        memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer___2,
               (size_t )64);
#line 246
        md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 247
        buffer___2 = (void const   *)((char const   *)buffer___2 + 64);
#line 248
        len -= 64UL;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 253
      md5_process_block(buffer___2, len & 0xffffffffffffffc0UL, ctx);
#line 254
      buffer___2 = (void const   *)((char const   *)buffer___2 + (len & 0xffffffffffffffc0UL));
#line 255
      len &= 63UL;
      }
    }
  }
#line 260
  if (len > 0UL) {
    {
#line 262
    memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)buffer___2,
           len);
#line 263
    ctx->buflen = (md5_uint32 )len;
    }
  }
#line 265
  return;
}
}
#line 280 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./md5.c"
void md5_process_block(void const   *buffer___2 , size_t len , struct md5_ctx *ctx ) 
{ 
  md5_uint32 correct_words[16] ;
  md5_uint32 const   *words ;
  size_t nwords ;
  md5_uint32 const   *endp ;
  md5_uint32 A ;
  md5_uint32 B ;
  md5_uint32 C ;
  md5_uint32 D ;
  md5_uint32 *cwp ;
  md5_uint32 A_save ;
  md5_uint32 B_save ;
  md5_uint32 C_save ;
  md5_uint32 D_save ;
  md5_uint32 *tmp___0 ;
  md5_uint32 tmp___1 ;
  md5_uint32 *tmp___2 ;
  md5_uint32 tmp___3 ;
  md5_uint32 *tmp___4 ;
  md5_uint32 tmp___5 ;
  md5_uint32 *tmp___6 ;
  md5_uint32 tmp___7 ;
  md5_uint32 *tmp___8 ;
  md5_uint32 tmp___9 ;
  md5_uint32 *tmp___10 ;
  md5_uint32 tmp___11 ;
  md5_uint32 *tmp___12 ;
  md5_uint32 tmp___13 ;
  md5_uint32 *tmp___14 ;
  md5_uint32 tmp___15 ;
  md5_uint32 *tmp___16 ;
  md5_uint32 tmp___17 ;
  md5_uint32 *tmp___18 ;
  md5_uint32 tmp___19 ;
  md5_uint32 *tmp___20 ;
  md5_uint32 tmp___21 ;
  md5_uint32 *tmp___22 ;
  md5_uint32 tmp___23 ;
  md5_uint32 *tmp___24 ;
  md5_uint32 tmp___25 ;
  md5_uint32 *tmp___26 ;
  md5_uint32 tmp___27 ;
  md5_uint32 *tmp___28 ;
  md5_uint32 tmp___29 ;
  md5_uint32 *tmp___30 ;
  md5_uint32 tmp___31 ;

  {
#line 284
  words = (md5_uint32 const   *)buffer___2;
#line 285
  nwords = len / sizeof(md5_uint32 );
#line 286
  endp = words + nwords;
#line 287
  A = ctx->A;
#line 288
  B = ctx->B;
#line 289
  C = ctx->C;
#line 290
  D = ctx->D;
#line 295
  ctx->total[0] = (md5_uint32 )((size_t )ctx->total[0] + len);
#line 296
  if ((size_t )ctx->total[0] < len) {
#line 297
    (ctx->total[1]) ++;
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! ((unsigned long )words < (unsigned long )endp)) {
#line 301
      goto while_break;
    }
#line 303
    cwp = correct_words;
#line 304
    A_save = A;
#line 305
    B_save = B;
#line 306
    C_save = C;
#line 307
    D_save = D;
    {
#line 337
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 337
      tmp___0 = cwp;
#line 337
      cwp ++;
#line 337
      tmp___1 = (md5_uint32 )*words;
#line 337
      *tmp___0 = tmp___1;
#line 337
      A += ((D ^ (B & (C ^ D))) + tmp___1) + 3614090360U;
#line 337
      words ++;
#line 337
      A = (A << 7) | (A >> 25);
#line 337
      A += B;
#line 337
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 338
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 338
      tmp___2 = cwp;
#line 338
      cwp ++;
#line 338
      tmp___3 = (md5_uint32 )*words;
#line 338
      *tmp___2 = tmp___3;
#line 338
      D += ((C ^ (A & (B ^ C))) + tmp___3) + 3905402710U;
#line 338
      words ++;
#line 338
      D = (D << 12) | (D >> 20);
#line 338
      D += A;
#line 338
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 339
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 339
      tmp___4 = cwp;
#line 339
      cwp ++;
#line 339
      tmp___5 = (md5_uint32 )*words;
#line 339
      *tmp___4 = tmp___5;
#line 339
      C += ((B ^ (D & (A ^ B))) + tmp___5) + 606105819U;
#line 339
      words ++;
#line 339
      C = (C << 17) | (C >> 15);
#line 339
      C += D;
#line 339
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 340
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 340
      tmp___6 = cwp;
#line 340
      cwp ++;
#line 340
      tmp___7 = (md5_uint32 )*words;
#line 340
      *tmp___6 = tmp___7;
#line 340
      B += ((A ^ (C & (D ^ A))) + tmp___7) + 3250441966U;
#line 340
      words ++;
#line 340
      B = (B << 22) | (B >> 10);
#line 340
      B += C;
#line 340
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 341
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 341
      tmp___8 = cwp;
#line 341
      cwp ++;
#line 341
      tmp___9 = (md5_uint32 )*words;
#line 341
      *tmp___8 = tmp___9;
#line 341
      A += ((D ^ (B & (C ^ D))) + tmp___9) + 4118548399U;
#line 341
      words ++;
#line 341
      A = (A << 7) | (A >> 25);
#line 341
      A += B;
#line 341
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 342
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 342
      tmp___10 = cwp;
#line 342
      cwp ++;
#line 342
      tmp___11 = (md5_uint32 )*words;
#line 342
      *tmp___10 = tmp___11;
#line 342
      D += ((C ^ (A & (B ^ C))) + tmp___11) + 1200080426U;
#line 342
      words ++;
#line 342
      D = (D << 12) | (D >> 20);
#line 342
      D += A;
#line 342
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 343
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 343
      tmp___12 = cwp;
#line 343
      cwp ++;
#line 343
      tmp___13 = (md5_uint32 )*words;
#line 343
      *tmp___12 = tmp___13;
#line 343
      C += ((B ^ (D & (A ^ B))) + tmp___13) + 2821735955U;
#line 343
      words ++;
#line 343
      C = (C << 17) | (C >> 15);
#line 343
      C += D;
#line 343
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    {
#line 344
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 344
      tmp___14 = cwp;
#line 344
      cwp ++;
#line 344
      tmp___15 = (md5_uint32 )*words;
#line 344
      *tmp___14 = tmp___15;
#line 344
      B += ((A ^ (C & (D ^ A))) + tmp___15) + 4249261313U;
#line 344
      words ++;
#line 344
      B = (B << 22) | (B >> 10);
#line 344
      B += C;
#line 344
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 345
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 345
      tmp___16 = cwp;
#line 345
      cwp ++;
#line 345
      tmp___17 = (md5_uint32 )*words;
#line 345
      *tmp___16 = tmp___17;
#line 345
      A += ((D ^ (B & (C ^ D))) + tmp___17) + 1770035416U;
#line 345
      words ++;
#line 345
      A = (A << 7) | (A >> 25);
#line 345
      A += B;
#line 345
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 346
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 346
      tmp___18 = cwp;
#line 346
      cwp ++;
#line 346
      tmp___19 = (md5_uint32 )*words;
#line 346
      *tmp___18 = tmp___19;
#line 346
      D += ((C ^ (A & (B ^ C))) + tmp___19) + 2336552879U;
#line 346
      words ++;
#line 346
      D = (D << 12) | (D >> 20);
#line 346
      D += A;
#line 346
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 347
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 347
      tmp___20 = cwp;
#line 347
      cwp ++;
#line 347
      tmp___21 = (md5_uint32 )*words;
#line 347
      *tmp___20 = tmp___21;
#line 347
      C += ((B ^ (D & (A ^ B))) + tmp___21) + 4294925233U;
#line 347
      words ++;
#line 347
      C = (C << 17) | (C >> 15);
#line 347
      C += D;
#line 347
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
    {
#line 348
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 348
      tmp___22 = cwp;
#line 348
      cwp ++;
#line 348
      tmp___23 = (md5_uint32 )*words;
#line 348
      *tmp___22 = tmp___23;
#line 348
      B += ((A ^ (C & (D ^ A))) + tmp___23) + 2304563134U;
#line 348
      words ++;
#line 348
      B = (B << 22) | (B >> 10);
#line 348
      B += C;
#line 348
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 349
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 349
      tmp___24 = cwp;
#line 349
      cwp ++;
#line 349
      tmp___25 = (md5_uint32 )*words;
#line 349
      *tmp___24 = tmp___25;
#line 349
      A += ((D ^ (B & (C ^ D))) + tmp___25) + 1804603682U;
#line 349
      words ++;
#line 349
      A = (A << 7) | (A >> 25);
#line 349
      A += B;
#line 349
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
    {
#line 350
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 350
      tmp___26 = cwp;
#line 350
      cwp ++;
#line 350
      tmp___27 = (md5_uint32 )*words;
#line 350
      *tmp___26 = tmp___27;
#line 350
      D += ((C ^ (A & (B ^ C))) + tmp___27) + 4254626195U;
#line 350
      words ++;
#line 350
      D = (D << 12) | (D >> 20);
#line 350
      D += A;
#line 350
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 351
      tmp___28 = cwp;
#line 351
      cwp ++;
#line 351
      tmp___29 = (md5_uint32 )*words;
#line 351
      *tmp___28 = tmp___29;
#line 351
      C += ((B ^ (D & (A ^ B))) + tmp___29) + 2792965006U;
#line 351
      words ++;
#line 351
      C = (C << 17) | (C >> 15);
#line 351
      C += D;
#line 351
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
    {
#line 352
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 352
      tmp___30 = cwp;
#line 352
      cwp ++;
#line 352
      tmp___31 = (md5_uint32 )*words;
#line 352
      *tmp___30 = tmp___31;
#line 352
      B += ((A ^ (C & (D ^ A))) + tmp___31) + 1236535329U;
#line 352
      words ++;
#line 352
      B = (B << 22) | (B >> 10);
#line 352
      B += C;
#line 352
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    {
#line 370
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 370
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 370
      A = (A << 5) | (A >> 27);
#line 370
      A += B;
#line 370
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 371
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 371
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 371
      D = (D << 9) | (D >> 23);
#line 371
      D += A;
#line 371
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    {
#line 372
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 372
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 372
      C = (C << 14) | (C >> 18);
#line 372
      C += D;
#line 372
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 373
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 373
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 373
      B = (B << 20) | (B >> 12);
#line 373
      B += C;
#line 373
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    {
#line 374
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 374
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 374
      A = (A << 5) | (A >> 27);
#line 374
      A += B;
#line 374
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
#line 375
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 375
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 375
      D = (D << 9) | (D >> 23);
#line 375
      D += A;
#line 375
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    {
#line 376
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 376
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 376
      C = (C << 14) | (C >> 18);
#line 376
      C += D;
#line 376
      goto while_break___22;
    }
    while_break___22: /* CIL Label */ ;
    }
    {
#line 377
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 377
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 377
      B = (B << 20) | (B >> 12);
#line 377
      B += C;
#line 377
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    {
#line 378
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 378
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 378
      A = (A << 5) | (A >> 27);
#line 378
      A += B;
#line 378
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    {
#line 379
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 379
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 379
      D = (D << 9) | (D >> 23);
#line 379
      D += A;
#line 379
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    {
#line 380
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 380
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 380
      C = (C << 14) | (C >> 18);
#line 380
      C += D;
#line 380
      goto while_break___26;
    }
    while_break___26: /* CIL Label */ ;
    }
    {
#line 381
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 381
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 381
      B = (B << 20) | (B >> 12);
#line 381
      B += C;
#line 381
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
    {
#line 382
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 382
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 382
      A = (A << 5) | (A >> 27);
#line 382
      A += B;
#line 382
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    {
#line 383
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 383
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 383
      D = (D << 9) | (D >> 23);
#line 383
      D += A;
#line 383
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    {
#line 384
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 384
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 384
      C = (C << 14) | (C >> 18);
#line 384
      C += D;
#line 384
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    {
#line 385
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 385
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 385
      B = (B << 20) | (B >> 12);
#line 385
      B += C;
#line 385
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    {
#line 391
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 391
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 391
      A = (A << 4) | (A >> 28);
#line 391
      A += B;
#line 391
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    {
#line 392
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 392
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 392
      D = (D << 11) | (D >> 21);
#line 392
      D += A;
#line 392
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    {
#line 393
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 393
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 393
      C = (C << 16) | (C >> 16);
#line 393
      C += D;
#line 393
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    {
#line 394
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 394
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 394
      B = (B << 23) | (B >> 9);
#line 394
      B += C;
#line 394
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    {
#line 395
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 395
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 395
      A = (A << 4) | (A >> 28);
#line 395
      A += B;
#line 395
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    {
#line 396
    while (1) {
      while_continue___37: /* CIL Label */ ;
#line 396
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 396
      D = (D << 11) | (D >> 21);
#line 396
      D += A;
#line 396
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
    {
#line 397
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 397
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 397
      C = (C << 16) | (C >> 16);
#line 397
      C += D;
#line 397
      goto while_break___38;
    }
    while_break___38: /* CIL Label */ ;
    }
    {
#line 398
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 398
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 398
      B = (B << 23) | (B >> 9);
#line 398
      B += C;
#line 398
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 399
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 399
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 399
      A = (A << 4) | (A >> 28);
#line 399
      A += B;
#line 399
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    {
#line 400
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 400
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 400
      D = (D << 11) | (D >> 21);
#line 400
      D += A;
#line 400
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    {
#line 401
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 401
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 401
      C = (C << 16) | (C >> 16);
#line 401
      C += D;
#line 401
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    {
#line 402
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 402
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 402
      B = (B << 23) | (B >> 9);
#line 402
      B += C;
#line 402
      goto while_break___43;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 403
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 403
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 403
      A = (A << 4) | (A >> 28);
#line 403
      A += B;
#line 403
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
    {
#line 404
    while (1) {
      while_continue___45: /* CIL Label */ ;
#line 404
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 404
      D = (D << 11) | (D >> 21);
#line 404
      D += A;
#line 404
      goto while_break___45;
    }
    while_break___45: /* CIL Label */ ;
    }
    {
#line 405
    while (1) {
      while_continue___46: /* CIL Label */ ;
#line 405
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 405
      C = (C << 16) | (C >> 16);
#line 405
      C += D;
#line 405
      goto while_break___46;
    }
    while_break___46: /* CIL Label */ ;
    }
    {
#line 406
    while (1) {
      while_continue___47: /* CIL Label */ ;
#line 406
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 406
      B = (B << 23) | (B >> 9);
#line 406
      B += C;
#line 406
      goto while_break___47;
    }
    while_break___47: /* CIL Label */ ;
    }
    {
#line 412
    while (1) {
      while_continue___48: /* CIL Label */ ;
#line 412
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 412
      A = (A << 6) | (A >> 26);
#line 412
      A += B;
#line 412
      goto while_break___48;
    }
    while_break___48: /* CIL Label */ ;
    }
    {
#line 413
    while (1) {
      while_continue___49: /* CIL Label */ ;
#line 413
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 413
      D = (D << 10) | (D >> 22);
#line 413
      D += A;
#line 413
      goto while_break___49;
    }
    while_break___49: /* CIL Label */ ;
    }
    {
#line 414
    while (1) {
      while_continue___50: /* CIL Label */ ;
#line 414
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 414
      C = (C << 15) | (C >> 17);
#line 414
      C += D;
#line 414
      goto while_break___50;
    }
    while_break___50: /* CIL Label */ ;
    }
    {
#line 415
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 415
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 415
      B = (B << 21) | (B >> 11);
#line 415
      B += C;
#line 415
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
    {
#line 416
    while (1) {
      while_continue___52: /* CIL Label */ ;
#line 416
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 416
      A = (A << 6) | (A >> 26);
#line 416
      A += B;
#line 416
      goto while_break___52;
    }
    while_break___52: /* CIL Label */ ;
    }
    {
#line 417
    while (1) {
      while_continue___53: /* CIL Label */ ;
#line 417
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 417
      D = (D << 10) | (D >> 22);
#line 417
      D += A;
#line 417
      goto while_break___53;
    }
    while_break___53: /* CIL Label */ ;
    }
    {
#line 418
    while (1) {
      while_continue___54: /* CIL Label */ ;
#line 418
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 418
      C = (C << 15) | (C >> 17);
#line 418
      C += D;
#line 418
      goto while_break___54;
    }
    while_break___54: /* CIL Label */ ;
    }
    {
#line 419
    while (1) {
      while_continue___55: /* CIL Label */ ;
#line 419
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 419
      B = (B << 21) | (B >> 11);
#line 419
      B += C;
#line 419
      goto while_break___55;
    }
    while_break___55: /* CIL Label */ ;
    }
    {
#line 420
    while (1) {
      while_continue___56: /* CIL Label */ ;
#line 420
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 420
      A = (A << 6) | (A >> 26);
#line 420
      A += B;
#line 420
      goto while_break___56;
    }
    while_break___56: /* CIL Label */ ;
    }
    {
#line 421
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 421
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 421
      D = (D << 10) | (D >> 22);
#line 421
      D += A;
#line 421
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    {
#line 422
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 422
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 422
      C = (C << 15) | (C >> 17);
#line 422
      C += D;
#line 422
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    {
#line 423
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 423
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 423
      B = (B << 21) | (B >> 11);
#line 423
      B += C;
#line 423
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    {
#line 424
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 424
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 424
      A = (A << 6) | (A >> 26);
#line 424
      A += B;
#line 424
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    {
#line 425
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 425
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 425
      D = (D << 10) | (D >> 22);
#line 425
      D += A;
#line 425
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    {
#line 426
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 426
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 426
      C = (C << 15) | (C >> 17);
#line 426
      C += D;
#line 426
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    {
#line 427
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 427
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 427
      B = (B << 21) | (B >> 11);
#line 427
      B += C;
#line 427
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
#line 430
    A += A_save;
#line 431
    B += B_save;
#line 432
    C += C_save;
#line 433
    D += D_save;
  }
  while_break: /* CIL Label */ ;
  }
#line 437
  ctx->A = A;
#line 438
  ctx->B = B;
#line 439
  ctx->C = C;
#line 440
  ctx->D = D;
#line 441
  return;
}
}
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
__inline static char const   *try_dir(char const   *dir , char const   *base ) ;
#line 73 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
__inline static char const   *try_dir(char const   *dir , char const   *base ) 
{ 
  int tmp___0 ;

  {
#line 76
  if ((unsigned long )base != (unsigned long )((char const   *)0)) {
#line 77
    return (base);
  }
#line 78
  if ((unsigned long )dir != (unsigned long )((char const   *)0)) {
    {
#line 78
    tmp___0 = access(dir, 7);
    }
#line 78
    if (tmp___0 == 0) {
#line 80
      return (dir);
    }
  }
#line 81
  return ((char const   *)0);
}
}
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
static char const   tmp[5]  = {      (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )0};
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
static char const   usrtmp[9]  = 
#line 85
  {      (char const   )'/',      (char const   )'u',      (char const   )'s',      (char const   )'r', 
        (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )0};
#line 87 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
static char const   vartmp[9]  = 
#line 87
  {      (char const   )'/',      (char const   )'v',      (char const   )'a',      (char const   )'r', 
        (char const   )'/',      (char const   )'t',      (char const   )'m',      (char const   )'p', 
        (char const   )0};
#line 92 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
static char *memoized_tmpdir  ;
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
char *choose_tmpdir(void) 
{ 
  char const   *base ;
  char *tmpdir ;
  unsigned int len ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;

  {
#line 108
  if (! memoized_tmpdir) {
    {
#line 111
    base = (char const   *)0;
#line 119
    tmp___0 = getenv("TMPDIR");
#line 119
    base = try_dir((char const   *)tmp___0, base);
#line 120
    tmp___1 = getenv("TMP");
#line 120
    base = try_dir((char const   *)tmp___1, base);
#line 121
    tmp___2 = getenv("TEMP");
#line 121
    base = try_dir((char const   *)tmp___2, base);
#line 127
    tmp___3 = strcmp("/tmp", "\\");
    }
#line 127
    if (tmp___3 == 0) {
      {
#line 128
      base = try_dir("\\.", base);
      }
    } else {
      {
#line 130
      base = try_dir("/tmp", base);
      }
    }
    {
#line 134
    base = try_dir(vartmp, base);
#line 135
    base = try_dir(usrtmp, base);
#line 136
    base = try_dir(tmp, base);
    }
#line 139
    if ((unsigned long )base == (unsigned long )((char const   *)0)) {
#line 140
      base = ".";
    }
    {
#line 143
    tmp___4 = strlen(base);
#line 143
    len = (unsigned int )tmp___4;
#line 144
    tmp___5 = xmalloc(sizeof(char ) * (unsigned long )(len + 2U));
#line 144
    tmpdir = (char *)tmp___5;
#line 145
    strcpy((char */* __restrict  */)tmpdir, (char const   */* __restrict  */)base);
#line 146
    *(tmpdir + len) = (char )'/';
#line 147
    *(tmpdir + (len + 1U)) = (char )'\000';
#line 148
    memoized_tmpdir = tmpdir;
    }
  }
#line 169
  return (memoized_tmpdir);
}
}
#line 184
char *make_temp_file(char const   *suffix )  __attribute__((__malloc__)) ;
#line 184 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-temp-file.c"
char *make_temp_file(char const   *suffix ) 
{ 
  char const   *base ;
  char *tmp___0 ;
  char *temp_filename ;
  int base_len ;
  int suffix_len ;
  int fd ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 187
  tmp___0 = choose_tmpdir();
#line 187
  base = (char const   *)tmp___0;
  }
#line 192
  if ((unsigned long )suffix == (unsigned long )((char const   *)0)) {
#line 193
    suffix = "";
  }
  {
#line 195
  tmp___1 = strlen(base);
#line 195
  base_len = (int )tmp___1;
#line 196
  tmp___2 = strlen(suffix);
#line 196
  suffix_len = (int )tmp___2;
#line 198
  tmp___3 = xmalloc(sizeof(char ) * ((((unsigned long )base_len + (sizeof("ccXXXXXX") - 1UL)) + (unsigned long )suffix_len) + 1UL));
#line 198
  temp_filename = (char *)tmp___3;
#line 201
  strcpy((char */* __restrict  */)temp_filename, (char const   */* __restrict  */)base);
#line 202
  strcpy((char */* __restrict  */)(temp_filename + base_len), (char const   */* __restrict  */)"ccXXXXXX");
#line 203
  strcpy((char */* __restrict  */)((temp_filename + base_len) + (sizeof("ccXXXXXX") - 1UL)),
         (char const   */* __restrict  */)suffix);
#line 205
  fd = mkstemps(temp_filename, suffix_len);
  }
#line 207
  if (fd == -1) {
    {
#line 209
    tmp___4 = __errno_location();
#line 209
    tmp___5 = strerror(*tmp___4);
#line 209
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot create temporary file in %s: %s\n",
            base, tmp___5);
#line 211
    abort();
    }
  }
  {
#line 214
  tmp___6 = close(fd);
  }
#line 214
  if (tmp___6) {
    {
#line 215
    abort();
    }
  }
#line 216
  return (temp_filename);
}
}
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 166
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 121 "./../include/libiberty.h"
char const   *lbasename(char const   *name___0 ) ;
#line 136
char *lrealpath(char const   *filename ) ;
#line 217
char *make_relative_prefix(char const   *progname , char const   *bin_prefix , char const   *prefix )  __attribute__((__malloc__)) ;
#line 224
char *make_relative_prefix_ignore_links(char const   *progname , char const   *bin_prefix ,
                                        char const   *prefix )  __attribute__((__malloc__)) ;
#line 102 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
static char *save_string(char const   *s , int len ) ;
#line 103
static char **split_directories(char const   *name___0 , int *ptr_num_dirs ) ;
#line 104
static void free_split_directories(char **dirs ) ;
#line 106 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
static char *save_string(char const   *s , int len ) 
{ 
  char *result ;
  void *tmp___0 ;

  {
  {
#line 109
  tmp___0 = malloc((size_t )(len + 1));
#line 109
  result = (char *)tmp___0;
#line 111
  memcpy((void */* __restrict  */)result, (void const   */* __restrict  */)s, (size_t )len);
#line 112
  *(result + len) = (char)0;
  }
#line 113
  return (result);
}
}
#line 118 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
static char **split_directories(char const   *name___0 , int *ptr_num_dirs ) 
{ 
  int num_dirs ;
  char **dirs ;
  char const   *p ;
  char const   *q ;
  int ch ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
#line 121
  num_dirs = 0;
#line 128
  p = name___0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    tmp___0 = p;
#line 137
    p ++;
#line 137
    ch = (int )*tmp___0;
#line 137
    if (! (ch != 0)) {
#line 137
      goto while_break;
    }
#line 139
    if (ch == 47) {
#line 141
      num_dirs ++;
      {
#line 142
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 142
        if (! ((int const   )*p == 47)) {
#line 142
          goto while_break___0;
        }
#line 143
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  tmp___1 = malloc(sizeof(char *) * (unsigned long )(num_dirs + 2));
#line 147
  dirs = (char **)tmp___1;
  }
#line 148
  if ((unsigned long )dirs == (unsigned long )((void *)0)) {
#line 149
    return ((char **)((void *)0));
  }
#line 152
  num_dirs = 0;
#line 153
  p = name___0;
#line 167
  q = p;
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 168
    tmp___3 = p;
#line 168
    p ++;
#line 168
    ch = (int )*tmp___3;
#line 168
    if (! (ch != 0)) {
#line 168
      goto while_break___1;
    }
#line 170
    if (ch == 47) {
      {
#line 172
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 172
        if (! ((int const   )*p == 47)) {
#line 172
          goto while_break___2;
        }
#line 173
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 175
      tmp___2 = num_dirs;
#line 175
      num_dirs ++;
#line 175
      *(dirs + tmp___2) = save_string(q, (int )(p - q));
      }
#line 176
      if ((unsigned long )*(dirs + (num_dirs - 1)) == (unsigned long )((void *)0)) {
        {
#line 178
        *(dirs + num_dirs) = (char *)((void *)0);
#line 179
        free_split_directories(dirs);
        }
#line 180
        return ((char **)((void *)0));
      }
#line 182
      q = p;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 186
  if ((p - 1) - q > 0L) {
    {
#line 187
    tmp___4 = num_dirs;
#line 187
    num_dirs ++;
#line 187
    *(dirs + tmp___4) = save_string(q, (int )((p - 1) - q));
    }
  }
#line 188
  *(dirs + num_dirs) = (char *)((void *)0);
#line 190
  if ((unsigned long )*(dirs + (num_dirs - 1)) == (unsigned long )((void *)0)) {
    {
#line 192
    free_split_directories(dirs);
    }
#line 193
    return ((char **)((void *)0));
  }
#line 196
  if (ptr_num_dirs) {
#line 197
    *ptr_num_dirs = num_dirs;
  }
#line 198
  return (dirs);
}
}
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
static void free_split_directories(char **dirs ) 
{ 
  int i ;
  int tmp___0 ;

  {
#line 206
  i = 0;
#line 208
  if ((unsigned long )dirs != (unsigned long )((void *)0)) {
    {
#line 210
    while (1) {
      while_continue: /* CIL Label */ ;
#line 210
      if (! ((unsigned long )*(dirs + i) != (unsigned long )((void *)0))) {
#line 210
        goto while_break;
      }
      {
#line 211
      tmp___0 = i;
#line 211
      i ++;
#line 211
      free((void *)*(dirs + tmp___0));
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 213
    free((void *)((char *)dirs));
    }
  }
#line 215
  return;
}
}
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
static char *make_relative_prefix_1(char const   *progname , char const   *bin_prefix ,
                                    char const   *prefix , int const   resolve_links ) 
{ 
  char **prog_dirs ;
  char **bin_dirs ;
  char **prefix_dirs ;
  int prog_num ;
  int bin_num ;
  int prefix_num ;
  int i ;
  int n ;
  int common ;
  int needed_len ;
  char *ret ;
  char *ptr ;
  char *full_progname ;
  char *temp ;
  char *startp ;
  char *endp ;
  char *nstore ;
  size_t prefixlen ;
  size_t tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  struct stat st ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;

  {
#line 231
  prog_dirs = (char **)((void *)0);
#line 231
  bin_dirs = (char **)((void *)0);
#line 231
  prefix_dirs = (char **)((void *)0);
#line 235
  ret = (char *)((void *)0);
#line 237
  if ((unsigned long )progname == (unsigned long )((void *)0)) {
#line 238
    return ((char *)((void *)0));
  } else
#line 237
  if ((unsigned long )bin_prefix == (unsigned long )((void *)0)) {
#line 238
    return ((char *)((void *)0));
  } else
#line 237
  if ((unsigned long )prefix == (unsigned long )((void *)0)) {
#line 238
    return ((char *)((void *)0));
  }
  {
#line 242
  tmp___5 = lbasename(progname);
  }
#line 242
  if ((unsigned long )tmp___5 == (unsigned long )progname) {
    {
#line 246
    temp = getenv("PATH");
    }
#line 247
    if (temp) {
      {
#line 250
      tmp___0 = strlen((char const   *)temp);
#line 250
      prefixlen = tmp___0 + 1UL;
      }
#line 252
      if (prefixlen < 2UL) {
#line 253
        prefixlen = (size_t )2;
      }
      {
#line 255
      tmp___1 = strlen(progname);
#line 255
      len = (prefixlen + tmp___1) + 1UL;
#line 259
      tmp___2 = __builtin_alloca(len);
#line 259
      nstore = (char *)tmp___2;
#line 261
      endp = temp;
#line 261
      startp = endp;
      }
      {
#line 262
      while (1) {
        while_continue: /* CIL Label */ ;
#line 264
        if ((int )*endp == 58) {
#line 264
          goto _L;
        } else
#line 264
        if ((int )*endp == 0) {
          _L: /* CIL Label */ 
#line 266
          if ((unsigned long )endp == (unsigned long )startp) {
#line 268
            *(nstore + 0) = (char )'.';
#line 269
            *(nstore + 1) = (char )'/';
#line 270
            *(nstore + 2) = (char )'\000';
          } else {
            {
#line 274
            memcpy((void */* __restrict  */)nstore, (void const   */* __restrict  */)startp,
                   (size_t )(endp - startp));
            }
#line 275
            if (! ((int )*(endp + -1) == 47)) {
#line 277
              *(nstore + (endp - startp)) = (char )'/';
#line 278
              *(nstore + ((endp - startp) + 1L)) = (char)0;
            } else {
#line 281
              *(nstore + (endp - startp)) = (char)0;
            }
          }
          {
#line 283
          strcat((char */* __restrict  */)nstore, (char const   */* __restrict  */)progname);
#line 284
          tmp___4 = access((char const   *)nstore, 1);
          }
#line 284
          if (! tmp___4) {
            {
#line 292
            tmp___3 = stat((char const   */* __restrict  */)nstore, (struct stat */* __restrict  */)(& st));
            }
#line 292
            if (tmp___3 >= 0) {
#line 292
              if ((st.st_mode & 61440U) == 32768U) {
#line 295
                progname = (char const   *)nstore;
#line 296
                goto while_break;
              }
            }
          }
#line 300
          if ((int )*endp == 0) {
#line 301
            goto while_break;
          }
#line 302
          startp = endp + 1;
#line 302
          endp = startp;
        } else {
#line 305
          endp ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 310
  if (resolve_links) {
    {
#line 311
    full_progname = lrealpath(progname);
    }
  } else {
    {
#line 313
    full_progname = strdup(progname);
    }
  }
#line 314
  if ((unsigned long )full_progname == (unsigned long )((void *)0)) {
#line 315
    return ((char *)((void *)0));
  }
  {
#line 317
  prog_dirs = split_directories((char const   *)full_progname, & prog_num);
#line 318
  free((void *)full_progname);
  }
#line 319
  if ((unsigned long )prog_dirs == (unsigned long )((void *)0)) {
#line 320
    return ((char *)((void *)0));
  }
  {
#line 322
  bin_dirs = split_directories(bin_prefix, & bin_num);
  }
#line 323
  if ((unsigned long )bin_dirs == (unsigned long )((void *)0)) {
#line 324
    goto bailout;
  }
#line 327
  prog_num --;
#line 333
  if (prog_num == bin_num) {
#line 335
    i = 0;
    {
#line 335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! (i < bin_num)) {
#line 335
        goto while_break___0;
      }
      {
#line 337
      tmp___6 = strcmp((char const   *)*(prog_dirs + i), (char const   *)*(bin_dirs + i));
      }
#line 337
      if (tmp___6 != 0) {
#line 338
        goto while_break___0;
      }
#line 335
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    if (prog_num <= 0) {
#line 342
      goto bailout;
    } else
#line 341
    if (i == bin_num) {
#line 342
      goto bailout;
    }
  }
  {
#line 345
  prefix_dirs = split_directories(prefix, & prefix_num);
  }
#line 346
  if ((unsigned long )prefix_dirs == (unsigned long )((void *)0)) {
#line 347
    goto bailout;
  }
#line 350
  if (prefix_num < bin_num) {
#line 350
    n = prefix_num;
  } else {
#line 350
    n = bin_num;
  }
#line 351
  common = 0;
  {
#line 351
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 351
    if (! (common < n)) {
#line 351
      goto while_break___1;
    }
    {
#line 353
    tmp___7 = strcmp((char const   *)*(bin_dirs + common), (char const   *)*(prefix_dirs + common));
    }
#line 353
    if (tmp___7 != 0) {
#line 354
      goto while_break___1;
    }
#line 351
    common ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 358
  if (common == 0) {
#line 359
    goto bailout;
  }
#line 363
  needed_len = 0;
#line 364
  i = 0;
  {
#line 364
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 364
    if (! (i < prog_num)) {
#line 364
      goto while_break___2;
    }
    {
#line 365
    tmp___8 = strlen((char const   *)*(prog_dirs + i));
#line 365
    needed_len = (int )((size_t )needed_len + tmp___8);
#line 364
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 366
  needed_len = (int )((unsigned long )needed_len + sizeof("..") * (unsigned long )(bin_num - common));
#line 367
  i = common;
  {
#line 367
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 367
    if (! (i < prefix_num)) {
#line 367
      goto while_break___3;
    }
    {
#line 368
    tmp___9 = strlen((char const   *)*(prefix_dirs + i));
#line 368
    needed_len = (int )((size_t )needed_len + tmp___9);
#line 367
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 369
  needed_len ++;
#line 371
  tmp___10 = malloc((size_t )needed_len);
#line 371
  ret = (char *)tmp___10;
  }
#line 372
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 373
    goto bailout;
  }
#line 376
  *ret = (char )'\000';
#line 377
  i = 0;
  {
#line 377
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 377
    if (! (i < prog_num)) {
#line 377
      goto while_break___4;
    }
    {
#line 378
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)*(prog_dirs + i));
#line 377
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 381
  tmp___11 = strlen((char const   *)ret);
#line 381
  ptr = ret + tmp___11;
#line 382
  i = common;
  }
  {
#line 382
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 382
    if (! (i < bin_num)) {
#line 382
      goto while_break___5;
    }
    {
#line 384
    strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)"..");
#line 385
    ptr += sizeof("..") - 1UL;
#line 386
    tmp___12 = ptr;
#line 386
    ptr ++;
#line 386
    *tmp___12 = (char )'/';
#line 382
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 388
  *ptr = (char )'\000';
#line 391
  i = common;
  {
#line 391
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 391
    if (! (i < prefix_num)) {
#line 391
      goto while_break___6;
    }
    {
#line 392
    strcat((char */* __restrict  */)ret, (char const   */* __restrict  */)*(prefix_dirs + i));
#line 391
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
  bailout: 
  {
#line 395
  free_split_directories(prog_dirs);
#line 396
  free_split_directories(bin_dirs);
#line 397
  free_split_directories(prefix_dirs);
  }
#line 399
  return (ret);
}
}
#line 408
char *make_relative_prefix(char const   *progname , char const   *bin_prefix , char const   *prefix )  __attribute__((__malloc__)) ;
#line 408 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
char *make_relative_prefix(char const   *progname , char const   *bin_prefix , char const   *prefix ) 
{ 
  char *tmp___0 ;

  {
  {
#line 412
  tmp___0 = make_relative_prefix_1(progname, bin_prefix, prefix, (int const   )1);
  }
#line 412
  return (tmp___0);
}
}
#line 420
char *make_relative_prefix_ignore_links(char const   *progname , char const   *bin_prefix ,
                                        char const   *prefix )  __attribute__((__malloc__)) ;
#line 420 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./make-relative-prefix.c"
char *make_relative_prefix_ignore_links(char const   *progname , char const   *bin_prefix ,
                                        char const   *prefix ) 
{ 
  char *tmp___0 ;

  {
  {
#line 425
  tmp___0 = make_relative_prefix_1(progname, bin_prefix, prefix, (int const   )0);
  }
#line 425
  return (tmp___0);
}
}
#line 797 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 615 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 56 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./lrealpath.c"
extern char *canonicalize_file_name(char const   * ) ;
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./lrealpath.c"
char *lrealpath(char const   *filename ) 
{ 
  char buf___4[4096] ;
  char const   *rp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *rp___0 ;
  char *tmp___2 ;
  char *tmp___3 ;
  long path_max ;
  long tmp___4 ;
  char *buf___5 ;
  char *rp___1 ;
  char *ret ;
  void *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 85
  tmp___0 = realpath((char const   */* __restrict  */)filename, (char */* __restrict  */)(buf___4));
#line 85
  rp = (char const   *)tmp___0;
  }
#line 86
  if ((unsigned long )rp == (unsigned long )((void *)0)) {
#line 87
    rp = filename;
  }
  {
#line 88
  tmp___1 = strdup(rp);
  }
#line 88
  return (tmp___1);
  {
#line 97
  tmp___2 = canonicalize_file_name(filename);
#line 97
  rp___0 = tmp___2;
  }
#line 98
  if ((unsigned long )rp___0 == (unsigned long )((void *)0)) {
    {
#line 99
    tmp___3 = strdup(filename);
    }
#line 99
    return (tmp___3);
  } else {
#line 101
    return (rp___0);
  }
  {
#line 115
  tmp___4 = pathconf("/", 4);
#line 115
  path_max = tmp___4;
  }
#line 116
  if (path_max > 0L) {
    {
#line 120
    tmp___5 = malloc((size_t )path_max);
#line 120
    buf___5 = (char *)tmp___5;
    }
#line 121
    if ((unsigned long )buf___5 == (unsigned long )((void *)0)) {
#line 122
      return ((char *)((void *)0));
    }
    {
#line 123
    rp___1 = realpath((char const   */* __restrict  */)filename, (char */* __restrict  */)buf___5);
    }
#line 124
    if (rp___1) {
#line 124
      tmp___6 = (char const   *)rp___1;
    } else {
#line 124
      tmp___6 = filename;
    }
    {
#line 124
    ret = strdup(tmp___6);
#line 125
    free((void *)buf___5);
    }
#line 126
    return (ret);
  }
  {
#line 156
  tmp___7 = strdup(filename);
  }
#line 156
  return (tmp___7);
}
}
#line 126 "./../include/libiberty.h"
char const   *dos_lbasename(char const   *name___0 ) ;
#line 132
char const   *unix_lbasename(char const   *name___0 ) ;
#line 48 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./lbasename.c"
char const   *unix_lbasename(char const   *name___0 ) 
{ 
  char const   *base ;

  {
#line 53
  base = name___0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! *name___0) {
#line 53
      goto while_break;
    }
#line 54
    if ((int const   )*name___0 == 47) {
#line 55
      base = name___0 + 1;
    } else
#line 54
    if ((int const   )*name___0 == 92) {

    }
#line 53
    name___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return (base);
}
}
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./lbasename.c"
char const   *dos_lbasename(char const   *name___0 ) 
{ 
  char const   *base ;

  {
#line 66
  if ((int const   )_sch_istable[(int const   )*(name___0 + 0) & 255] & 136) {
#line 66
    if ((int const   )*(name___0 + 1) == 58) {
#line 67
      name___0 += 2;
    }
  }
#line 69
  base = name___0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! *name___0) {
#line 69
      goto while_break;
    }
#line 70
    if ((int const   )*name___0 == 47) {
#line 71
      base = name___0 + 1;
    } else
#line 70
    if ((int const   )*name___0 == 92) {
#line 71
      base = name___0 + 1;
    }
#line 69
    name___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (base);
}
}
#line 76 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./lbasename.c"
char const   *lbasename(char const   *name___0 ) 
{ 
  char const   *tmp___0 ;

  {
  {
#line 82
  tmp___0 = unix_lbasename(name___0);
  }
#line 82
  return (tmp___0);
}
}
#line 375 "./../include/libiberty.h"
unsigned char const   _hex_value[256] ;
#line 376
void hex_init(void) ;
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hex.c"
unsigned char const   _hex_value[256]  = 
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hex.c"
  {      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )10,      (unsigned char const   )11,      (unsigned char const   )12, 
        (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99, 
        (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99,      (unsigned char const   )99};
#line 158 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hex.c"
void hex_init(void) 
{ 


  {
#line 192
  return;
}
}
#line 151 "./../include/hashtab.h"
htab_t htab_create_alloc(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                          void const   * ) ,
                         void (*del_f)(void * ) , void *(*alloc_f)(size_t  , size_t  ) ,
                         void (*free_f)(void * ) ) ;
#line 155
htab_t htab_create_alloc_ex(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                             void const   * ) ,
                            void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                        size_t  ,
                                                                                        size_t  ) ,
                            void (*free_f)(void * , void * ) ) ;
#line 160
htab_t htab_create_typed_alloc(size_t size , hashval_t (*hash_f)(void const   * ) ,
                               int (*eq_f)(void const   * , void const   * ) , void (*del_f)(void * ) ,
                               void *(*alloc_tab_f)(size_t  , size_t  ) , void *(*alloc_f)(size_t  ,
                                                                                           size_t  ) ,
                               void (*free_f)(void * ) ) ;
#line 164
htab_t htab_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                    void const   * ) ,
                   void (*del_f)(void * ) ) ;
#line 165
htab_t htab_try_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                        void const   * ) ,
                       void (*del_f)(void * ) ) ;
#line 167
void htab_set_functions_ex(htab_t htab , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                            void const   * ) ,
                           void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                       size_t  ,
                                                                                       size_t  ) ,
                           void (*free_f)(void * , void * ) ) ;
#line 172
void htab_delete(htab_t htab ) ;
#line 173
void htab_empty(htab_t htab ) ;
#line 175
void *htab_find(htab_t htab , void const   *element ) ;
#line 176
void **htab_find_slot(htab_t htab , void const   *element , enum insert_option insert ) ;
#line 177
void *htab_find_with_hash(htab_t htab , void const   *element , hashval_t hash ) ;
#line 178
void **htab_find_slot_with_hash(htab_t htab , void const   *element , hashval_t hash ,
                                enum insert_option insert ) ;
#line 180
void htab_clear_slot(htab_t htab , void **slot ) ;
#line 181
void htab_remove_elt(htab_t htab , void *element ) ;
#line 182
void htab_remove_elt_with_hash(htab_t htab , void *element , hashval_t hash ) ;
#line 184
void htab_traverse(htab_t htab , int (*callback)(void ** , void * ) , void *info ) ;
#line 185
void htab_traverse_noresize(htab_t htab , int (*callback)(void ** , void * ) , void *info ) ;
#line 187
size_t htab_size(htab_t htab ) ;
#line 188
size_t htab_elements(htab_t htab ) ;
#line 189
double htab_collisions(htab_t htab ) ;
#line 192
hashval_t (*htab_hash_pointer)(void const   * ) ;
#line 195
int (*htab_eq_pointer)(void const   * , void const   * ) ;
#line 198
hashval_t htab_hash_string(void const   *p ) ;
#line 201
hashval_t iterative_hash(void const   *k_in , size_t length , hashval_t initval ) ;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static unsigned int higher_prime_index(unsigned long n ) ;
#line 71
__inline static hashval_t htab_mod_1(hashval_t x , hashval_t y , hashval_t inv , int shift ) ;
#line 72
__inline static hashval_t htab_mod(hashval_t hash , htab_t htab ) ;
#line 73
__inline static hashval_t htab_mod_m2(hashval_t hash , htab_t htab ) ;
#line 74
static hashval_t hash_pointer(void const   *p ) ;
#line 75
static int eq_pointer(void const   *p1 , void const   *p2 ) ;
#line 76
static int htab_expand(htab_t htab ) ;
#line 77
static void **find_empty_slot_for_expand(htab_t htab , hashval_t hash ) ;
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
hashval_t (*htab_hash_pointer)(void const   * )  =    & hash_pointer;
#line 83 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
int (*htab_eq_pointer)(void const   * , void const   * )  =    & eq_pointer;
#line 135 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static struct prime_ent  const  prime_tab[30]  = 
#line 135
  {      {(hashval_t )7, (hashval_t )613566757, 2576980379U, (hashval_t )2}, 
        {(hashval_t )13, (hashval_t )991146300, (hashval_t )1952257863, (hashval_t )3}, 
        {(hashval_t )31,
      (hashval_t )138547333, (hashval_t )444306962, (hashval_t )4}, 
        {(hashval_t )61, (hashval_t )211227900, (hashval_t )363980280, (hashval_t )5}, 
        {(hashval_t )127,
      (hashval_t )33818641, (hashval_t )103079216, (hashval_t )6}, 
        {(hashval_t )251, (hashval_t )85557118, (hashval_t )120742053, (hashval_t )7}, 
        {(hashval_t )509,
      (hashval_t )25314150, (hashval_t )42356680, (hashval_t )8}, 
        {(hashval_t )1021, (hashval_t )12619885, (hashval_t )21074423, (hashval_t )9}, 
        {(hashval_t )2039,
      (hashval_t )18957679, (hashval_t )23193246, (hashval_t )10}, 
        {(hashval_t )4093, (hashval_t )3148034, (hashval_t )5249288, (hashval_t )11}, 
        {(hashval_t )8191,
      (hashval_t )524353, (hashval_t )1573441, (hashval_t )12}, 
        {(hashval_t )16381, (hashval_t )786577, (hashval_t )1311121, (hashval_t )13}, 
        {(hashval_t )32749,
      (hashval_t )2491813, (hashval_t )2754278, (hashval_t )14}, 
        {(hashval_t )65521, (hashval_t )983266, (hashval_t )1114402, (hashval_t )15}, 
        {(hashval_t )131071,
      (hashval_t )32769, (hashval_t )98307, (hashval_t )16}, 
        {(hashval_t )262139, (hashval_t )81922, (hashval_t )114692, (hashval_t )17}, 
        {(hashval_t )524287, (hashval_t )8193, (hashval_t )24577, (hashval_t )18}, 
        {(hashval_t )1048573, (hashval_t )12289, (hashval_t )20481, (hashval_t )19}, 
        {(hashval_t )2097143, (hashval_t )18433, (hashval_t )22529, (hashval_t )20}, 
        {(hashval_t )4194301, (hashval_t )3073, (hashval_t )5121, (hashval_t )21}, 
        {(hashval_t )8388593, (hashval_t )7681, (hashval_t )8705, (hashval_t )22}, 
        {(hashval_t )16777213, (hashval_t )769, (hashval_t )1281, (hashval_t )23}, 
        {(hashval_t )33554393, (hashval_t )4993, (hashval_t )5249, (hashval_t )24}, 
        {(hashval_t )67108859, (hashval_t )321, (hashval_t )449, (hashval_t )25}, 
        {(hashval_t )134217689, (hashval_t )1249, (hashval_t )1313, (hashval_t )26}, 
        {(hashval_t )268435399, (hashval_t )913, (hashval_t )945, (hashval_t )27}, 
        {(hashval_t )536870909, (hashval_t )25, (hashval_t )41, (hashval_t )28}, 
        {(hashval_t )1073741789, (hashval_t )141, (hashval_t )149, (hashval_t )29}, 
        {(hashval_t )2147483647, (hashval_t )3, (hashval_t )7, (hashval_t )30}, 
        {4294967291U, (hashval_t )6, (hashval_t )8, (hashval_t )31}};
#line 172 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static unsigned int higher_prime_index(unsigned long n ) 
{ 
  unsigned int low ;
  unsigned int high ;
  unsigned int mid ;

  {
#line 175
  low = 0U;
#line 176
  high = (unsigned int )(sizeof(prime_tab) / sizeof(prime_tab[0]));
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (low != high)) {
#line 178
      goto while_break;
    }
#line 180
    mid = low + (high - low) / 2U;
#line 181
    if (n > (unsigned long )prime_tab[mid].prime) {
#line 182
      low = mid + 1U;
    } else {
#line 184
      high = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if (n > (unsigned long )prime_tab[low].prime) {
    {
#line 190
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot find prime bigger than %lu\n",
            n);
#line 191
    abort();
    }
  }
#line 194
  return (low);
}
}
#line 199 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static hashval_t hash_pointer(void const   *p ) 
{ 


  {
#line 202
  return ((hashval_t )((intptr_t )p >> 3));
}
}
#line 207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static int eq_pointer(void const   *p1 , void const   *p2 ) 
{ 


  {
#line 210
  return ((unsigned long )p1 == (unsigned long )p2);
}
}
#line 223 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
size_t htab_size(htab_t htab ) 
{ 


  {
#line 226
  return (htab->size);
}
}
#line 233 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
size_t htab_elements(htab_t htab ) 
{ 


  {
#line 236
  return (htab->n_elements - htab->n_deleted);
}
}
#line 241 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
__inline static hashval_t htab_mod_1(hashval_t x , hashval_t y , hashval_t inv , int shift ) 
{ 
  hashval_t t1 ;
  hashval_t t2 ;
  hashval_t t3 ;
  hashval_t t4 ;
  hashval_t q ;
  hashval_t r ;

  {
#line 248
  if (sizeof(hashval_t ) * 8UL <= 32UL) {
#line 252
    t1 = (hashval_t )((ull )x * (ull )inv >> 32);
#line 253
    t2 = x - t1;
#line 254
    t3 = t2 >> 1;
#line 255
    t4 = t1 + t3;
#line 256
    q = t4 >> shift;
#line 257
    r = x - q * y;
#line 259
    return (r);
  }
#line 264
  return (x % y);
}
}
#line 269 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
__inline static hashval_t htab_mod(hashval_t hash , htab_t htab ) 
{ 
  struct prime_ent  const  *p ;
  hashval_t tmp___0 ;

  {
  {
#line 272
  p = & prime_tab[htab->size_prime_index];
#line 273
  tmp___0 = htab_mod_1(hash, (hashval_t )p->prime, (hashval_t )p->inv, (int )p->shift);
  }
#line 273
  return (tmp___0);
}
}
#line 278 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
__inline static hashval_t htab_mod_m2(hashval_t hash , htab_t htab ) 
{ 
  struct prime_ent  const  *p ;
  hashval_t tmp___0 ;

  {
  {
#line 281
  p = & prime_tab[htab->size_prime_index];
#line 282
  tmp___0 = htab_mod_1(hash, (hashval_t )(p->prime - 2U), (hashval_t )p->inv_m2, (int )p->shift);
  }
#line 282
  return (1U + tmp___0);
}
}
#line 290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
htab_t htab_create_alloc(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                          void const   * ) ,
                         void (*del_f)(void * ) , void *(*alloc_f)(size_t  , size_t  ) ,
                         void (*free_f)(void * ) ) 
{ 
  htab_t tmp___0 ;

  {
  {
#line 294
  tmp___0 = htab_create_typed_alloc(size, hash_f, eq_f, del_f, alloc_f, alloc_f, free_f);
  }
#line 294
  return (tmp___0);
}
}
#line 301 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
htab_t htab_create_alloc_ex(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                             void const   * ) ,
                            void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                        size_t  ,
                                                                                        size_t  ) ,
                            void (*free_f)(void * , void * ) ) 
{ 
  htab_t result ;
  unsigned int size_prime_index ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 310
  size_prime_index = higher_prime_index(size);
#line 311
  size = (size_t )prime_tab[size_prime_index].prime;
#line 313
  tmp___0 = (*alloc_f)(alloc_arg, (size_t )1, sizeof(struct htab ));
#line 313
  result = (htab_t )tmp___0;
  }
#line 314
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 315
    return ((htab_t )((void *)0));
  }
  {
#line 316
  tmp___1 = (*alloc_f)(alloc_arg, size, sizeof(void *));
#line 316
  result->entries = (void **)tmp___1;
  }
#line 317
  if ((unsigned long )result->entries == (unsigned long )((void *)0)) {
#line 319
    if ((unsigned long )free_f != (unsigned long )((void *)0)) {
      {
#line 320
      (*free_f)(alloc_arg, (void *)result);
      }
    }
#line 321
    return ((htab_t )((void *)0));
  }
#line 323
  result->size = size;
#line 324
  result->size_prime_index = size_prime_index;
#line 325
  result->hash_f = hash_f;
#line 326
  result->eq_f = eq_f;
#line 327
  result->del_f = del_f;
#line 328
  result->alloc_arg = alloc_arg;
#line 329
  result->alloc_with_arg_f = alloc_f;
#line 330
  result->free_with_arg_f = free_f;
#line 331
  return (result);
}
}
#line 355 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
htab_t htab_create_typed_alloc(size_t size , hashval_t (*hash_f)(void const   * ) ,
                               int (*eq_f)(void const   * , void const   * ) , void (*del_f)(void * ) ,
                               void *(*alloc_tab_f)(size_t  , size_t  ) , void *(*alloc_f)(size_t  ,
                                                                                           size_t  ) ,
                               void (*free_f)(void * ) ) 
{ 
  htab_t result ;
  unsigned int size_prime_index ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 363
  size_prime_index = higher_prime_index(size);
#line 364
  size = (size_t )prime_tab[size_prime_index].prime;
#line 366
  tmp___0 = (*alloc_tab_f)((size_t )1, sizeof(struct htab ));
#line 366
  result = (htab_t )tmp___0;
  }
#line 367
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 368
    return ((htab_t )((void *)0));
  }
  {
#line 369
  tmp___1 = (*alloc_f)(size, sizeof(void *));
#line 369
  result->entries = (void **)tmp___1;
  }
#line 370
  if ((unsigned long )result->entries == (unsigned long )((void *)0)) {
#line 372
    if ((unsigned long )free_f != (unsigned long )((void *)0)) {
      {
#line 373
      (*free_f)((void *)result);
      }
    }
#line 374
    return ((htab_t )((void *)0));
  }
#line 376
  result->size = size;
#line 377
  result->size_prime_index = size_prime_index;
#line 378
  result->hash_f = hash_f;
#line 379
  result->eq_f = eq_f;
#line 380
  result->del_f = del_f;
#line 381
  result->alloc_f = alloc_f;
#line 382
  result->free_f = free_f;
#line 383
  return (result);
}
}
#line 389 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_set_functions_ex(htab_t htab , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                            void const   * ) ,
                           void (*del_f)(void * ) , void *alloc_arg , void *(*alloc_f)(void * ,
                                                                                       size_t  ,
                                                                                       size_t  ) ,
                           void (*free_f)(void * , void * ) ) 
{ 


  {
#line 394
  htab->hash_f = hash_f;
#line 395
  htab->eq_f = eq_f;
#line 396
  htab->del_f = del_f;
#line 397
  htab->alloc_arg = alloc_arg;
#line 398
  htab->alloc_with_arg_f = alloc_f;
#line 399
  htab->free_with_arg_f = free_f;
#line 400
  return;
}
}
#line 405 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
htab_t htab_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                    void const   * ) ,
                   void (*del_f)(void * ) ) 
{ 
  htab_t tmp___0 ;

  {
  {
#line 408
  tmp___0 = htab_create_alloc(size, hash_f, eq_f, del_f, & xcalloc, (void (*)(void * ))(& free));
  }
#line 408
  return (tmp___0);
}
}
#line 411 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
htab_t htab_try_create(size_t size , hashval_t (*hash_f)(void const   * ) , int (*eq_f)(void const   * ,
                                                                                        void const   * ) ,
                       void (*del_f)(void * ) ) 
{ 
  htab_t tmp___0 ;

  {
  {
#line 414
  tmp___0 = htab_create_alloc(size, hash_f, eq_f, del_f, (void *(*)(size_t  , size_t  ))(& calloc),
                              (void (*)(void * ))(& free));
  }
#line 414
  return (tmp___0);
}
}
#line 420 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_delete(htab_t htab ) 
{ 
  size_t size ;
  void **entries ;
  int i ;

  {
#line 423
  size = htab->size;
#line 424
  entries = htab->entries;
#line 427
  if (htab->del_f) {
#line 428
    i = (int )(size - 1UL);
    {
#line 428
    while (1) {
      while_continue: /* CIL Label */ ;
#line 428
      if (! (i >= 0)) {
#line 428
        goto while_break;
      }
#line 429
      if ((unsigned long )*(entries + i) != (unsigned long )((void *)0)) {
#line 429
        if ((unsigned long )*(entries + i) != (unsigned long )((void *)1)) {
          {
#line 430
          (*(htab->del_f))(*(entries + i));
          }
        }
      }
#line 428
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 432
  if ((unsigned long )htab->free_f != (unsigned long )((void *)0)) {
    {
#line 434
    (*(htab->free_f))((void *)entries);
#line 435
    (*(htab->free_f))((void *)htab);
    }
  } else
#line 437
  if ((unsigned long )htab->free_with_arg_f != (unsigned long )((void *)0)) {
    {
#line 439
    (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)entries);
#line 440
    (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)htab);
    }
  }
#line 442
  return;
}
}
#line 446 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_empty(htab_t htab ) 
{ 
  size_t size ;
  void **entries ;
  int i ;
  int nindex ;
  unsigned int tmp___0 ;
  int nsize ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 449
  size = htab->size;
#line 450
  entries = htab->entries;
#line 453
  if (htab->del_f) {
#line 454
    i = (int )(size - 1UL);
    {
#line 454
    while (1) {
      while_continue: /* CIL Label */ ;
#line 454
      if (! (i >= 0)) {
#line 454
        goto while_break;
      }
#line 455
      if ((unsigned long )*(entries + i) != (unsigned long )((void *)0)) {
#line 455
        if ((unsigned long )*(entries + i) != (unsigned long )((void *)1)) {
          {
#line 456
          (*(htab->del_f))(*(entries + i));
          }
        }
      }
#line 454
      i --;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 459
  if (size > 1048576UL / sizeof(void *)) {
    {
#line 461
    tmp___0 = higher_prime_index(1024UL / sizeof(void *));
#line 461
    nindex = (int )tmp___0;
#line 462
    nsize = (int )prime_tab[nindex].prime;
    }
#line 464
    if ((unsigned long )htab->free_f != (unsigned long )((void *)0)) {
      {
#line 465
      (*(htab->free_f))((void *)htab->entries);
      }
    } else
#line 466
    if ((unsigned long )htab->free_with_arg_f != (unsigned long )((void *)0)) {
      {
#line 467
      (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)htab->entries);
      }
    }
#line 468
    if ((unsigned long )htab->alloc_with_arg_f != (unsigned long )((void *)0)) {
      {
#line 469
      tmp___1 = (*(htab->alloc_with_arg_f))(htab->alloc_arg, (size_t )nsize, sizeof(void **));
#line 469
      htab->entries = (void **)tmp___1;
      }
    } else {
      {
#line 472
      tmp___2 = (*(htab->alloc_f))((size_t )nsize, sizeof(void **));
#line 472
      htab->entries = (void **)tmp___2;
      }
    }
#line 473
    htab->size = (size_t )nsize;
#line 474
    htab->size_prime_index = (unsigned int )nindex;
  } else {
    {
#line 477
    memset((void *)entries, 0, size * sizeof(void *));
    }
  }
#line 478
  htab->n_deleted = (size_t )0;
#line 479
  htab->n_elements = (size_t )0;
#line 480
  return;
}
}
#line 489 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static void **find_empty_slot_for_expand(htab_t htab , hashval_t hash ) 
{ 
  hashval_t index___0 ;
  hashval_t tmp___0 ;
  size_t size ;
  void **slot ;
  hashval_t hash2 ;

  {
  {
#line 492
  tmp___0 = htab_mod(hash, htab);
#line 492
  index___0 = tmp___0;
#line 493
  size = htab->size;
#line 494
  slot = htab->entries + index___0;
  }
#line 497
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 498
    return (slot);
  } else
#line 499
  if ((unsigned long )*slot == (unsigned long )((void *)1)) {
    {
#line 500
    abort();
    }
  }
  {
#line 502
  hash2 = htab_mod_m2(hash, htab);
  }
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    index___0 += hash2;
#line 506
    if ((size_t )index___0 >= size) {
#line 507
      index___0 = (hashval_t )((size_t )index___0 - size);
    }
#line 509
    slot = htab->entries + index___0;
#line 510
    if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 511
      return (slot);
    } else
#line 512
    if ((unsigned long )*slot == (unsigned long )((void *)1)) {
      {
#line 513
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 525 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
static int htab_expand(htab_t htab ) 
{ 
  void **oentries ;
  void **olimit ;
  void **p ;
  void **nentries ;
  size_t nsize ;
  size_t osize ;
  size_t elts ;
  unsigned int oindex ;
  unsigned int nindex ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *x ;
  void **q ;
  hashval_t tmp___2 ;
  void **tmp___3 ;

  {
#line 535
  oentries = htab->entries;
#line 536
  oindex = htab->size_prime_index;
#line 537
  osize = htab->size;
#line 538
  olimit = oentries + osize;
#line 539
  elts = htab->n_elements - htab->n_deleted;
#line 543
  if (elts * 2UL > osize) {
    {
#line 545
    nindex = higher_prime_index(elts * 2UL);
#line 546
    nsize = (size_t )prime_tab[nindex].prime;
    }
  } else
#line 543
  if (elts * 8UL < osize) {
#line 543
    if (osize > 32UL) {
      {
#line 545
      nindex = higher_prime_index(elts * 2UL);
#line 546
      nsize = (size_t )prime_tab[nindex].prime;
      }
    } else {
#line 550
      nindex = oindex;
#line 551
      nsize = osize;
    }
  } else {
#line 550
    nindex = oindex;
#line 551
    nsize = osize;
  }
#line 554
  if ((unsigned long )htab->alloc_with_arg_f != (unsigned long )((void *)0)) {
    {
#line 555
    tmp___0 = (*(htab->alloc_with_arg_f))(htab->alloc_arg, nsize, sizeof(void **));
#line 555
    nentries = (void **)tmp___0;
    }
  } else {
    {
#line 558
    tmp___1 = (*(htab->alloc_f))(nsize, sizeof(void **));
#line 558
    nentries = (void **)tmp___1;
    }
  }
#line 559
  if ((unsigned long )nentries == (unsigned long )((void *)0)) {
#line 560
    return (0);
  }
#line 561
  htab->entries = nentries;
#line 562
  htab->size = nsize;
#line 563
  htab->size_prime_index = nindex;
#line 564
  htab->n_elements -= htab->n_deleted;
#line 565
  htab->n_deleted = (size_t )0;
#line 567
  p = oentries;
  {
#line 568
  while (1) {
    while_continue: /* CIL Label */ ;
#line 570
    x = *p;
#line 572
    if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 572
      if ((unsigned long )x != (unsigned long )((void *)1)) {
        {
#line 574
        tmp___2 = (*(htab->hash_f))((void const   *)x);
#line 574
        tmp___3 = find_empty_slot_for_expand(htab, tmp___2);
#line 574
        q = tmp___3;
#line 576
        *q = x;
        }
      }
    }
#line 579
    p ++;
#line 568
    if (! ((unsigned long )p < (unsigned long )olimit)) {
#line 568
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 583
  if ((unsigned long )htab->free_f != (unsigned long )((void *)0)) {
    {
#line 584
    (*(htab->free_f))((void *)oentries);
    }
  } else
#line 585
  if ((unsigned long )htab->free_with_arg_f != (unsigned long )((void *)0)) {
    {
#line 586
    (*(htab->free_with_arg_f))(htab->alloc_arg, (void *)oentries);
    }
  }
#line 587
  return (1);
}
}
#line 593 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void *htab_find_with_hash(htab_t htab , void const   *element , hashval_t hash ) 
{ 
  hashval_t index___0 ;
  hashval_t hash2 ;
  size_t size ;
  void *entry ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 600
  (htab->searches) ++;
#line 601
  size = htab->size;
#line 602
  index___0 = htab_mod(hash, htab);
#line 604
  entry = *(htab->entries + index___0);
  }
#line 605
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 607
    return (entry);
  } else
#line 605
  if ((unsigned long )entry != (unsigned long )((void *)1)) {
    {
#line 605
    tmp___0 = (*(htab->eq_f))((void const   *)entry, element);
    }
#line 605
    if (tmp___0) {
#line 607
      return (entry);
    }
  }
  {
#line 609
  hash2 = htab_mod_m2(hash, htab);
  }
  {
#line 610
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    (htab->collisions) ++;
#line 613
    index___0 += hash2;
#line 614
    if ((size_t )index___0 >= size) {
#line 615
      index___0 = (hashval_t )((size_t )index___0 - size);
    }
#line 617
    entry = *(htab->entries + index___0);
#line 618
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 620
      return (entry);
    } else
#line 618
    if ((unsigned long )entry != (unsigned long )((void *)1)) {
      {
#line 618
      tmp___1 = (*(htab->eq_f))((void const   *)entry, element);
      }
#line 618
      if (tmp___1) {
#line 620
        return (entry);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 627 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void *htab_find(htab_t htab , void const   *element ) 
{ 
  hashval_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 630
  tmp___0 = (*(htab->hash_f))(element);
#line 630
  tmp___1 = htab_find_with_hash(htab, element, tmp___0);
  }
#line 630
  return (tmp___1);
}
}
#line 641 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void **htab_find_slot_with_hash(htab_t htab , void const   *element , hashval_t hash ,
                                enum insert_option insert ) 
{ 
  void **first_deleted_slot ;
  hashval_t index___0 ;
  hashval_t hash2 ;
  size_t size ;
  void *entry ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 650
  size = htab->size;
#line 651
  if ((unsigned int )insert == 1U) {
#line 651
    if (size * 3UL <= htab->n_elements * 4UL) {
      {
#line 653
      tmp___0 = htab_expand(htab);
      }
#line 653
      if (tmp___0 == 0) {
#line 654
        return ((void **)((void *)0));
      }
#line 655
      size = htab->size;
    }
  }
  {
#line 658
  index___0 = htab_mod(hash, htab);
#line 660
  (htab->searches) ++;
#line 661
  first_deleted_slot = (void **)((void *)0);
#line 663
  entry = *(htab->entries + index___0);
  }
#line 664
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 665
    goto empty_entry;
  } else
#line 666
  if ((unsigned long )entry == (unsigned long )((void *)1)) {
#line 667
    first_deleted_slot = htab->entries + index___0;
  } else {
    {
#line 668
    tmp___1 = (*(htab->eq_f))((void const   *)entry, element);
    }
#line 668
    if (tmp___1) {
#line 669
      return (htab->entries + index___0);
    }
  }
  {
#line 671
  hash2 = htab_mod_m2(hash, htab);
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    (htab->collisions) ++;
#line 675
    index___0 += hash2;
#line 676
    if ((size_t )index___0 >= size) {
#line 677
      index___0 = (hashval_t )((size_t )index___0 - size);
    }
#line 679
    entry = *(htab->entries + index___0);
#line 680
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 681
      goto empty_entry;
    } else
#line 682
    if ((unsigned long )entry == (unsigned long )((void *)1)) {
#line 684
      if (! first_deleted_slot) {
#line 685
        first_deleted_slot = htab->entries + index___0;
      }
    } else {
      {
#line 687
      tmp___2 = (*(htab->eq_f))((void const   *)entry, element);
      }
#line 687
      if (tmp___2) {
#line 688
        return (htab->entries + index___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  empty_entry: 
#line 692
  if ((unsigned int )insert == 0U) {
#line 693
    return ((void **)((void *)0));
  }
#line 695
  if (first_deleted_slot) {
#line 697
    (htab->n_deleted) --;
#line 698
    *first_deleted_slot = (void *)0;
#line 699
    return (first_deleted_slot);
  }
#line 702
  (htab->n_elements) ++;
#line 703
  return (htab->entries + index___0);
}
}
#line 709 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void **htab_find_slot(htab_t htab , void const   *element , enum insert_option insert ) 
{ 
  hashval_t tmp___0 ;
  void **tmp___1 ;

  {
  {
#line 712
  tmp___0 = (*(htab->hash_f))(element);
#line 712
  tmp___1 = htab_find_slot_with_hash(htab, element, tmp___0, insert);
  }
#line 712
  return (tmp___1);
}
}
#line 720 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_remove_elt(htab_t htab , void *element ) 
{ 
  hashval_t tmp___0 ;

  {
  {
#line 723
  tmp___0 = (*(htab->hash_f))((void const   *)element);
#line 723
  htab_remove_elt_with_hash(htab, element, tmp___0);
  }
#line 724
  return;
}
}
#line 731 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_remove_elt_with_hash(htab_t htab , void *element , hashval_t hash ) 
{ 
  void **slot ;

  {
  {
#line 736
  slot = htab_find_slot_with_hash(htab, (void const   *)element, hash, (enum insert_option )0);
  }
#line 737
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
#line 738
    return;
  }
#line 740
  if (htab->del_f) {
    {
#line 741
    (*(htab->del_f))(*slot);
    }
  }
#line 743
  *slot = (void *)1;
#line 744
  (htab->n_deleted) ++;
#line 745
  return;
}
}
#line 751 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_clear_slot(htab_t htab , void **slot ) 
{ 


  {
#line 754
  if ((unsigned long )slot < (unsigned long )htab->entries) {
    {
#line 756
    abort();
    }
  } else
#line 754
  if ((unsigned long )slot >= (unsigned long )(htab->entries + htab->size)) {
    {
#line 756
    abort();
    }
  } else
#line 754
  if ((unsigned long )*slot == (unsigned long )((void *)0)) {
    {
#line 756
    abort();
    }
  } else
#line 754
  if ((unsigned long )*slot == (unsigned long )((void *)1)) {
    {
#line 756
    abort();
    }
  }
#line 758
  if (htab->del_f) {
    {
#line 759
    (*(htab->del_f))(*slot);
    }
  }
#line 761
  *slot = (void *)1;
#line 762
  (htab->n_deleted) ++;
#line 763
  return;
}
}
#line 770 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_traverse_noresize(htab_t htab , int (*callback)(void ** , void * ) , void *info ) 
{ 
  void **slot ;
  void **limit ;
  void *x ;
  int tmp___0 ;

  {
#line 776
  slot = htab->entries;
#line 777
  limit = slot + htab->size;
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    x = *slot;
#line 783
    if ((unsigned long )x != (unsigned long )((void *)0)) {
#line 783
      if ((unsigned long )x != (unsigned long )((void *)1)) {
        {
#line 784
        tmp___0 = (*callback)(slot, info);
        }
#line 784
        if (! tmp___0) {
#line 785
          goto while_break;
        }
      }
    }
#line 779
    slot ++;
#line 779
    if (! ((unsigned long )slot < (unsigned long )limit)) {
#line 779
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 788
  return;
}
}
#line 793 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
void htab_traverse(htab_t htab , int (*callback)(void ** , void * ) , void *info ) 
{ 
  size_t size ;

  {
#line 796
  size = htab->size;
#line 797
  if ((htab->n_elements - htab->n_deleted) * 8UL < size) {
#line 797
    if (size > 32UL) {
      {
#line 798
      htab_expand(htab);
      }
    }
  }
  {
#line 800
  htab_traverse_noresize(htab, callback, info);
  }
#line 801
  return;
}
}
#line 806 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
double htab_collisions(htab_t htab ) 
{ 


  {
#line 809
  if (htab->searches == 0U) {
#line 810
    return (0.0);
  }
#line 812
  return ((double )htab->collisions / (double )htab->searches);
}
}
#line 840 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
hashval_t htab_hash_string(void const   *p ) 
{ 
  unsigned char const   *str ;
  hashval_t r ;
  unsigned char c ;
  unsigned char const   *tmp___0 ;

  {
#line 843
  str = (unsigned char const   *)p;
#line 844
  r = (hashval_t )0;
  {
#line 847
  while (1) {
    while_continue: /* CIL Label */ ;
#line 847
    tmp___0 = str;
#line 847
    str ++;
#line 847
    c = (unsigned char )*tmp___0;
#line 847
    if (! ((int )c != 0)) {
#line 847
      goto while_break;
    }
#line 848
    r = (r * 67U + (hashval_t )c) - 113U;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return (r);
}
}
#line 930 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./hashtab.c"
hashval_t iterative_hash(void const   *k_in , size_t length , hashval_t initval ) 
{ 
  register unsigned char const   *k ;
  register hashval_t a ;
  register hashval_t b ;
  register hashval_t c ;
  register hashval_t len ;

  {
#line 936
  k = (unsigned char const   *)k_in;
#line 940
  len = (hashval_t )length;
#line 941
  b = 2654435769U;
#line 941
  a = b;
#line 942
  c = initval;
#line 949
  if (sizeof(hashval_t ) == 4UL) {
#line 949
    if (((size_t )k & 3UL) == 0UL) {
      {
#line 950
      while (1) {
        while_continue: /* CIL Label */ ;
#line 950
        if (! (len >= 12U)) {
#line 950
          goto while_break;
        }
#line 952
        a += *((hashval_t *)(k + 0));
#line 953
        b += *((hashval_t *)(k + 4));
#line 954
        c += *((hashval_t *)(k + 8));
#line 955
        a -= b;
#line 955
        a -= c;
#line 955
        a ^= c >> 13;
#line 955
        b -= c;
#line 955
        b -= a;
#line 955
        b ^= a << 8;
#line 955
        c -= a;
#line 955
        c -= b;
#line 955
        c ^= (b & 4294967295U) >> 13;
#line 955
        a -= b;
#line 955
        a -= c;
#line 955
        a ^= (c & 4294967295U) >> 12;
#line 955
        b -= c;
#line 955
        b -= a;
#line 955
        b = (b ^ (a << 16)) & 4294967295U;
#line 955
        c -= a;
#line 955
        c -= b;
#line 955
        c = (c ^ (b >> 5)) & 4294967295U;
#line 955
        a -= b;
#line 955
        a -= c;
#line 955
        a = (a ^ (c >> 3)) & 4294967295U;
#line 955
        b -= c;
#line 955
        b -= a;
#line 955
        b = (b ^ (a << 10)) & 4294967295U;
#line 955
        c -= a;
#line 955
        c -= b;
#line 955
        c = (c ^ (b >> 15)) & 4294967295U;
#line 956
        k += 12;
#line 956
        len -= 12U;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 949
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 960
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 960
      if (! (len >= 12U)) {
#line 960
        goto while_break___0;
      }
#line 962
      a += (((hashval_t )*(k + 0) + ((hashval_t )*(k + 1) << 8)) + ((hashval_t )*(k + 2) << 16)) + ((hashval_t )*(k + 3) << 24);
#line 963
      b += (((hashval_t )*(k + 4) + ((hashval_t )*(k + 5) << 8)) + ((hashval_t )*(k + 6) << 16)) + ((hashval_t )*(k + 7) << 24);
#line 964
      c += (((hashval_t )*(k + 8) + ((hashval_t )*(k + 9) << 8)) + ((hashval_t )*(k + 10) << 16)) + ((hashval_t )*(k + 11) << 24);
#line 965
      a -= b;
#line 965
      a -= c;
#line 965
      a ^= c >> 13;
#line 965
      b -= c;
#line 965
      b -= a;
#line 965
      b ^= a << 8;
#line 965
      c -= a;
#line 965
      c -= b;
#line 965
      c ^= (b & 4294967295U) >> 13;
#line 965
      a -= b;
#line 965
      a -= c;
#line 965
      a ^= (c & 4294967295U) >> 12;
#line 965
      b -= c;
#line 965
      b -= a;
#line 965
      b = (b ^ (a << 16)) & 4294967295U;
#line 965
      c -= a;
#line 965
      c -= b;
#line 965
      c = (c ^ (b >> 5)) & 4294967295U;
#line 965
      a -= b;
#line 965
      a -= c;
#line 965
      a = (a ^ (c >> 3)) & 4294967295U;
#line 965
      b -= c;
#line 965
      b -= a;
#line 965
      b = (b ^ (a << 10)) & 4294967295U;
#line 965
      c -= a;
#line 965
      c -= b;
#line 965
      c = (c ^ (b >> 15)) & 4294967295U;
#line 966
      k += 12;
#line 966
      len -= 12U;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 970
  c = (hashval_t )((size_t )c + length);
  {
#line 973
  if (len == 11U) {
#line 973
    goto case_11;
  }
#line 974
  if (len == 10U) {
#line 974
    goto case_10;
  }
#line 975
  if (len == 9U) {
#line 975
    goto case_9;
  }
#line 977
  if (len == 8U) {
#line 977
    goto case_8;
  }
#line 978
  if (len == 7U) {
#line 978
    goto case_7;
  }
#line 979
  if (len == 6U) {
#line 979
    goto case_6;
  }
#line 980
  if (len == 5U) {
#line 980
    goto case_5;
  }
#line 981
  if (len == 4U) {
#line 981
    goto case_4;
  }
#line 982
  if (len == 3U) {
#line 982
    goto case_3;
  }
#line 983
  if (len == 2U) {
#line 983
    goto case_2;
  }
#line 984
  if (len == 1U) {
#line 984
    goto case_1;
  }
#line 971
  goto switch_break;
  case_11: /* CIL Label */ 
#line 973
  c += (hashval_t )*(k + 10) << 24;
  case_10: /* CIL Label */ 
#line 974
  c += (hashval_t )*(k + 9) << 16;
  case_9: /* CIL Label */ 
#line 975
  c += (hashval_t )*(k + 8) << 8;
  case_8: /* CIL Label */ 
#line 977
  b += (hashval_t )*(k + 7) << 24;
  case_7: /* CIL Label */ 
#line 978
  b += (hashval_t )*(k + 6) << 16;
  case_6: /* CIL Label */ 
#line 979
  b += (hashval_t )*(k + 5) << 8;
  case_5: /* CIL Label */ 
#line 980
  b += (hashval_t )*(k + 4);
  case_4: /* CIL Label */ 
#line 981
  a += (hashval_t )*(k + 3) << 24;
  case_3: /* CIL Label */ 
#line 982
  a += (hashval_t )*(k + 2) << 16;
  case_2: /* CIL Label */ 
#line 983
  a += (hashval_t )*(k + 1) << 8;
  case_1: /* CIL Label */ 
#line 984
  a += (hashval_t )*(k + 0);
  switch_break: /* CIL Label */ ;
  }
#line 987
  a -= b;
#line 987
  a -= c;
#line 987
  a ^= c >> 13;
#line 987
  b -= c;
#line 987
  b -= a;
#line 987
  b ^= a << 8;
#line 987
  c -= a;
#line 987
  c -= b;
#line 987
  c ^= (b & 4294967295U) >> 13;
#line 987
  a -= b;
#line 987
  a -= c;
#line 987
  a ^= (c & 4294967295U) >> 12;
#line 987
  b -= c;
#line 987
  b -= a;
#line 987
  b = (b ^ (a << 16)) & 4294967295U;
#line 987
  c -= a;
#line 987
  c -= b;
#line 987
  c = (c ^ (b >> 5)) & 4294967295U;
#line 987
  a -= b;
#line 987
  a -= c;
#line 987
  a = (a ^ (c >> 3)) & 4294967295U;
#line 987
  b -= c;
#line 987
  b -= a;
#line 987
  b = (b ^ (a << 10)) & 4294967295U;
#line 987
  c -= a;
#line 987
  c -= b;
#line 987
  c = (c ^ (b >> 15)) & 4294967295U;
#line 989
  return (c);
}
}
#line 212 "./../include/libiberty.h"
long get_run_time(void) ;
#line 87 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 92 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./getruntime.c"
long get_run_time(void) 
{ 
  struct rusage rusage ;

  {
  {
#line 98
  getrusage(0, & rusage);
  }
#line 99
  return (((rusage.ru_utime.tv_sec * 1000000L + rusage.ru_utime.tv_usec) + rusage.ru_stime.tv_sec * 1000000L) + rusage.ru_stime.tv_usec);
}
}
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 199 "./../include/libiberty.h"
char *getpwd(void) ;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./getpwd.c"
static char *pwd  ;
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./getpwd.c"
static int failure_errno  ;
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./getpwd.c"
char *getpwd(void) 
{ 
  char *p ;
  size_t s ;
  struct stat dotstat ;
  struct stat pwdstat ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 73
  p = pwd;
#line 77
  if (! p) {
    {
#line 77
    tmp___6 = __errno_location();
#line 77
    tmp___7 = failure_errno;
#line 77
    *tmp___6 = tmp___7;
    }
#line 77
    if (! tmp___7) {
      {
#line 79
      p = getenv("PWD");
      }
#line 79
      if ((unsigned long )p != (unsigned long )((char *)0)) {
#line 79
        if ((int )*p == 47) {
          {
#line 79
          tmp___4 = stat((char const   */* __restrict  */)p, (struct stat */* __restrict  */)(& pwdstat));
          }
#line 79
          if (tmp___4 == 0) {
            {
#line 79
            tmp___5 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& dotstat));
            }
#line 79
            if (tmp___5 == 0) {
#line 79
              if (dotstat.st_ino == pwdstat.st_ino) {
#line 79
                if (! (dotstat.st_dev == pwdstat.st_dev)) {
#line 79
                  goto _L___3;
                }
              } else {
#line 79
                goto _L___3;
              }
            } else {
#line 79
              goto _L___3;
            }
          } else {
#line 79
            goto _L___3;
          }
        } else {
#line 79
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 87
        s = (size_t )4097;
        {
#line 87
        while (1) {
          while_continue: /* CIL Label */ ;
          {
#line 87
          tmp___2 = xmalloc(sizeof(char ) * s);
#line 87
          p = (char *)tmp___2;
#line 87
          tmp___3 = getcwd(p, s);
          }
#line 87
          if (tmp___3) {
#line 87
            goto while_break;
          }
          {
#line 89
          tmp___0 = __errno_location();
#line 89
          e = *tmp___0;
#line 90
          free((void *)p);
          }
#line 92
          if (e != 34) {
            {
#line 95
            tmp___1 = __errno_location();
#line 95
            failure_errno = e;
#line 95
            *tmp___1 = failure_errno;
#line 96
            p = (char *)0;
            }
#line 97
            goto while_break;
          }
#line 87
          s *= 2UL;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 103
      pwd = p;
    }
  }
#line 105
  return (p);
}
}
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 238
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 82 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fsetlocking)(FILE *__fp ,
                                                                                    int __type ) ;
#line 56 "./../include/libiberty.h"
void unlock_stream(FILE *fp ) ;
#line 62
void unlock_std_streams(void) ;
#line 68
FILE *fopen_unlocked(char const   *path , char const   *mode ) ;
#line 69
FILE *fdopen_unlocked(int fildes , char const   *mode ) ;
#line 70
FILE *freopen_unlocked(char const   *path , char const   *mode , FILE *stream ) ;
#line 84 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fopen_unlocked.c"
__inline static void unlock_1(FILE * const  fp  __attribute__((__unused__)) ) 
{ 


  {
#line 88
  if (fp) {
    {
#line 89
    __fsetlocking((FILE *)fp, 2);
    }
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fopen_unlocked.c"
void unlock_stream(FILE *fp ) 
{ 


  {
  {
#line 96
  unlock_1((FILE */* const  */)fp);
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fopen_unlocked.c"
void unlock_std_streams(void) 
{ 


  {
  {
#line 102
  unlock_1((FILE */* const  */)stdin);
#line 103
  unlock_1((FILE */* const  */)stdout);
#line 104
  unlock_1((FILE */* const  */)stderr);
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fopen_unlocked.c"
FILE *fopen_unlocked(char const   *path , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;

  {
  {
#line 110
  tmp___0 = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)mode);
#line 110
  fp = tmp___0;
#line 111
  unlock_1((FILE */* const  */)fp);
  }
#line 112
  return (fp);
}
}
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fopen_unlocked.c"
FILE *fdopen_unlocked(int fildes , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;

  {
  {
#line 118
  tmp___0 = fdopen(fildes, mode);
#line 118
  fp = tmp___0;
#line 119
  unlock_1((FILE */* const  */)fp);
  }
#line 120
  return (fp);
}
}
#line 123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fopen_unlocked.c"
FILE *freopen_unlocked(char const   *path , char const   *mode , FILE *stream ) 
{ 
  FILE *fp ;
  FILE *tmp___0 ;

  {
  {
#line 126
  tmp___0 = freopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)mode,
                    (FILE */* __restrict  */)stream);
#line 126
  fp = tmp___0;
#line 127
  unlock_1((FILE */* const  */)fp);
  }
#line 128
  return (fp);
}
}
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#line 98 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 101
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 99 "./../include/floatformat.h"
struct floatformat  const  floatformat_ieee_half_big ;
#line 100
struct floatformat  const  floatformat_ieee_half_little ;
#line 101
struct floatformat  const  floatformat_ieee_single_big ;
#line 102
struct floatformat  const  floatformat_ieee_single_little ;
#line 103
struct floatformat  const  floatformat_ieee_double_big ;
#line 104
struct floatformat  const  floatformat_ieee_double_little ;
#line 108
struct floatformat  const  floatformat_ieee_double_littlebyte_bigword ;
#line 112
struct floatformat  const  floatformat_vax_f ;
#line 113
struct floatformat  const  floatformat_vax_d ;
#line 114
struct floatformat  const  floatformat_vax_g ;
#line 118
struct floatformat  const  floatformat_i387_ext ;
#line 119
struct floatformat  const  floatformat_m68881_ext ;
#line 120
struct floatformat  const  floatformat_i960_ext ;
#line 121
struct floatformat  const  floatformat_m88110_ext ;
#line 122
struct floatformat  const  floatformat_m88110_harris_ext ;
#line 123
struct floatformat  const  floatformat_arm_ext_big ;
#line 124
struct floatformat  const  floatformat_arm_ext_littlebyte_bigword ;
#line 126
struct floatformat  const  floatformat_ia64_spill_big ;
#line 127
struct floatformat  const  floatformat_ia64_spill_little ;
#line 128
struct floatformat  const  floatformat_ia64_quad_big ;
#line 129
struct floatformat  const  floatformat_ia64_quad_little ;
#line 131
struct floatformat  const  floatformat_ibm_long_double ;
#line 137
void floatformat_to_double(struct floatformat  const  *fmt , void const   *from ,
                           double *to ) ;
#line 143
void floatformat_from_double(struct floatformat  const  *fmt , double const   *from ,
                             void *to ) ;
#line 148
int floatformat_is_valid(struct floatformat  const  *fmt , void const   *from ) ;
#line 59 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static int mant_bits_set(struct floatformat  const  *fmt , unsigned char const   *ufrom ) ;
#line 60
static unsigned long get_field(unsigned char const   *data , enum floatformat_byteorders order ,
                               unsigned int total_len , unsigned int start , unsigned int len ) ;
#line 65
static int floatformat_always_valid(struct floatformat  const  *fmt  __attribute__((__unused__)) ,
                                    void const   *from  __attribute__((__unused__)) ) ;
#line 68 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static int floatformat_always_valid(struct floatformat  const  *fmt  __attribute__((__unused__)) ,
                                    void const   *from  __attribute__((__unused__)) ) 
{ 


  {
#line 72
  return (1);
}
}
#line 81 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_half_big  = 
#line 81
     {(enum floatformat_byteorders )1, 16U, 0U, 1U, 5U, 15, 31U, 6U, 10U, (enum floatformat_intbit )1,
    "floatformat_ieee_half_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 89 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_half_little  = 
#line 89
     {(enum floatformat_byteorders )0, 16U, 0U, 1U, 5U, 15, 31U, 6U, 10U, (enum floatformat_intbit )1,
    "floatformat_ieee_half_little", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_single_big  = 
#line 97
     {(enum floatformat_byteorders )1, 32U, 0U, 1U, 8U, 127, 255U, 9U, 23U, (enum floatformat_intbit )1,
    "floatformat_ieee_single_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_single_little  = 
#line 105
     {(enum floatformat_byteorders )0, 32U, 0U, 1U, 8U, 127, 255U, 9U, 23U, (enum floatformat_intbit )1,
    "floatformat_ieee_single_little", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 113 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_double_big  = 
#line 113
     {(enum floatformat_byteorders )1, 64U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ieee_double_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 121 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_double_little  = 
#line 121
     {(enum floatformat_byteorders )0, 64U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ieee_double_little", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 133 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ieee_double_littlebyte_bigword  = 
#line 133
     {(enum floatformat_byteorders )2, 64U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ieee_double_littlebyte_bigword", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 144 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_vax_f  = 
#line 144
     {(enum floatformat_byteorders )3, 32U, 0U, 1U, 8U, 129, 0U, 9U, 23U, (enum floatformat_intbit )1,
    "floatformat_vax_f", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 152 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_vax_d  = 
#line 152
     {(enum floatformat_byteorders )3, 64U, 0U, 1U, 8U, 129, 0U, 9U, 55U, (enum floatformat_intbit )1,
    "floatformat_vax_d", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 160 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_vax_g  = 
#line 160
     {(enum floatformat_byteorders )3, 64U, 0U, 1U, 11U, 1025, 0U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_vax_g", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 169
static int floatformat_i387_ext_is_valid(struct floatformat  const  *fmt , void const   *from ) ;
#line 172 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static int floatformat_i387_ext_is_valid(struct floatformat  const  *fmt , void const   *from ) 
{ 
  unsigned long exponent ;
  unsigned long int_bit ;
  unsigned char const   *ufrom ;

  {
  {
#line 180
  ufrom = (unsigned char const   *)from;
#line 182
  exponent = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                       (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len);
#line 184
  int_bit = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                      (unsigned int )fmt->man_start, 1U);
  }
#line 187
  if ((exponent == 0UL) != (int_bit == 0UL)) {
#line 188
    return (0);
  } else {
#line 190
    return (1);
  }
}
}
#line 193 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_i387_ext  = 
#line 193
     {(enum floatformat_byteorders )0, 80U, 0U, 1U, 15U, 16383, 32767U, 16U, 64U, (enum floatformat_intbit )0,
    "floatformat_i387_ext", & floatformat_i387_ext_is_valid, (struct floatformat  const  *)((void *)0)};
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_m68881_ext  = 
#line 201
     {(enum floatformat_byteorders )1, 96U, 0U, 1U, 15U, 16383, 32767U, 32U, 64U, (enum floatformat_intbit )0,
    "floatformat_m68881_ext", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_i960_ext  = 
#line 210
     {(enum floatformat_byteorders )0, 96U, 16U, 17U, 15U, 16383, 32767U, 32U, 64U,
    (enum floatformat_intbit )0, "floatformat_i960_ext", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 219 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_m88110_ext  = 
#line 219
     {(enum floatformat_byteorders )1, 80U, 0U, 1U, 15U, 16383, 32767U, 16U, 64U, (enum floatformat_intbit )0,
    "floatformat_m88110_ext", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 227 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_m88110_harris_ext  = 
#line 227
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_m88110_ext_harris", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 237 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_arm_ext_big  = 
#line 237
     {(enum floatformat_byteorders )1, 96U, 0U, 17U, 15U, 16383, 32767U, 32U, 64U, (enum floatformat_intbit )0,
    "floatformat_arm_ext_big", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 246 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_arm_ext_littlebyte_bigword  = 
#line 246
     {(enum floatformat_byteorders )2, 96U, 0U, 17U, 15U, 16383, 32767U, 32U, 64U, (enum floatformat_intbit )0,
    "floatformat_arm_ext_littlebyte_bigword", & floatformat_always_valid, (struct floatformat  const  *)((void *)0)};
#line 255 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_spill_big  = 
#line 255
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 17U, 65535, 131071U, 18U, 64U,
    (enum floatformat_intbit )0, "floatformat_ia64_spill_big", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 263 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_spill_little  = 
#line 263
     {(enum floatformat_byteorders )0, 128U, 0U, 1U, 17U, 65535, 131071U, 18U, 64U,
    (enum floatformat_intbit )0, "floatformat_ia64_spill_little", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 271 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_quad_big  = 
#line 271
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 15U, 16383, 32767U, 16U, 112U,
    (enum floatformat_intbit )1, "floatformat_ia64_quad_big", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ia64_quad_little  = 
#line 279
     {(enum floatformat_byteorders )0, 128U, 0U, 1U, 15U, 16383, 32767U, 16U, 112U,
    (enum floatformat_intbit )1, "floatformat_ia64_quad_little", & floatformat_always_valid,
    (struct floatformat  const  *)((void *)0)};
#line 288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static int floatformat_ibm_long_double_is_valid(struct floatformat  const  *fmt ,
                                                void const   *from ) 
{ 
  unsigned char const   *ufrom ;
  struct floatformat  const  *hfmt ;
  long top_exp ;
  long bot_exp ;
  int top_nan ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int first_bit ;
  int second_bit ;
  int cur_bit ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 292
  ufrom = (unsigned char const   *)from;
#line 293
  hfmt = (struct floatformat  const  *)fmt->split_half;
#line 295
  top_nan = 0;
#line 297
  tmp___0 = get_field(ufrom, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                      (unsigned int )hfmt->exp_start, (unsigned int )hfmt->exp_len);
#line 297
  top_exp = (long )tmp___0;
#line 299
  tmp___1 = get_field(ufrom + 8, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                      (unsigned int )hfmt->exp_start, (unsigned int )hfmt->exp_len);
#line 299
  bot_exp = (long )tmp___1;
  }
#line 302
  if ((unsigned long )top_exp == (unsigned long )hfmt->exp_nan) {
    {
#line 303
    top_nan = mant_bits_set(hfmt, ufrom);
    }
  }
#line 306
  if (top_nan) {
#line 307
    return (1);
  }
#line 311
  if ((unsigned long )top_exp == (unsigned long )hfmt->exp_nan) {
#line 311
    goto _L;
  } else
#line 311
  if (top_exp == 0L) {
    _L: /* CIL Label */ 
#line 313
    if (bot_exp != 0L) {
#line 314
      return (0);
    }
    {
#line 316
    tmp___2 = mant_bits_set(hfmt, ufrom + 8);
    }
#line 316
    if (tmp___2) {
#line 316
      tmp___3 = 0;
    } else {
#line 316
      tmp___3 = 1;
    }
#line 316
    return (tmp___3);
  }
#line 325
  if (bot_exp < top_exp - 53L) {
#line 326
    return (1);
  }
#line 327
  if (bot_exp > top_exp - 53L) {
#line 327
    if (bot_exp != 0L) {
#line 328
      return (0);
    }
  }
#line 329
  if (bot_exp == 0L) {
#line 333
    first_bit = -1;
#line 333
    second_bit = -1;
#line 334
    cur_bit = 0;
    {
#line 334
    while (1) {
      while_continue: /* CIL Label */ ;
#line 334
      if (! ((unsigned int )cur_bit < (unsigned int )hfmt->man_len)) {
#line 334
        goto while_break;
      }
      {
#line 335
      tmp___4 = get_field(ufrom + 8, (enum floatformat_byteorders )hfmt->byteorder,
                          (unsigned int )hfmt->totalsize, (unsigned int )(hfmt->man_start + (unsigned int const   )cur_bit),
                          1U);
      }
#line 335
      if (tmp___4) {
#line 338
        if (first_bit == -1) {
#line 339
          first_bit = cur_bit;
        } else {
#line 342
          second_bit = cur_bit;
#line 343
          goto while_break;
        }
      }
#line 334
      cur_bit ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 347
    if (first_bit == -1) {
#line 348
      return (1);
    }
#line 350
    if ((long )(- first_bit) < top_exp - 53L) {
#line 351
      return (1);
    }
#line 352
    if ((long )(- first_bit) > top_exp - 53L) {
#line 353
      return (0);
    }
#line 357
    if (second_bit != -1) {
#line 358
      return (0);
    }
    {
#line 359
    tmp___5 = get_field(ufrom, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                        (unsigned int )((hfmt->man_start + hfmt->man_len) - 1U), 1U);
    }
#line 359
    if (tmp___5) {
#line 359
      tmp___6 = 0;
    } else {
#line 359
      tmp___6 = 1;
    }
#line 359
    return (tmp___6);
  } else {
    {
#line 367
    tmp___7 = get_field(ufrom, (enum floatformat_byteorders )hfmt->byteorder, (unsigned int )hfmt->totalsize,
                        (unsigned int )((hfmt->man_start + hfmt->man_len) - 1U), 1U);
    }
#line 367
    if (tmp___7) {
#line 369
      return (0);
    }
    {
#line 370
    tmp___8 = mant_bits_set(hfmt, ufrom + 8);
    }
#line 370
    if (tmp___8) {
#line 370
      tmp___9 = 0;
    } else {
#line 370
      tmp___9 = 1;
    }
#line 370
    return (tmp___9);
  }
}
}
#line 374 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
struct floatformat  const  floatformat_ibm_long_double  = 
#line 374
     {(enum floatformat_byteorders )1, 128U, 0U, 1U, 11U, 1023, 2047U, 12U, 52U, (enum floatformat_intbit )1,
    "floatformat_ibm_long_double", & floatformat_ibm_long_double_is_valid, & floatformat_ieee_double_big};
#line 390 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static int mant_bits_set(struct floatformat  const  *fmt , unsigned char const   *ufrom ) 
{ 
  unsigned int mant_bits ;
  unsigned int mant_off ;
  int mant_bits_left ;
  unsigned long tmp___0 ;

  {
#line 396
  mant_off = (unsigned int )fmt->man_start;
#line 397
  mant_bits_left = (int )fmt->man_len;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (mant_bits_left > 0)) {
#line 398
      goto while_break;
    }
#line 400
    if (mant_bits_left < 32) {
#line 400
      mant_bits = (unsigned int )mant_bits_left;
    } else {
#line 400
      mant_bits = 32U;
    }
    {
#line 402
    tmp___0 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                        mant_off, mant_bits);
    }
#line 402
    if (tmp___0 != 0UL) {
#line 404
      return (1);
    }
#line 406
    mant_off += mant_bits;
#line 407
    mant_bits_left = (int )((unsigned int )mant_bits_left - mant_bits);
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  return (0);
}
}
#line 414 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static unsigned long get_field(unsigned char const   *data , enum floatformat_byteorders order ,
                               unsigned int total_len , unsigned int start , unsigned int len ) 
{ 
  unsigned long result ;
  unsigned int cur_byte ;
  int lo_bit ;
  int hi_bit ;
  int cur_bitshift ;
  int nextbyte ;
  int tmp___0 ;
  unsigned int shifted ;
  unsigned int bits ;
  unsigned int mask ;

  {
#line 418
  result = 0UL;
#line 420
  cur_bitshift = 0;
#line 421
  if ((unsigned int )order == 0U) {
#line 421
    tmp___0 = 1;
  } else {
#line 421
    tmp___0 = -1;
  }
#line 421
  nextbyte = tmp___0;
#line 424
  start = total_len - (start + len);
#line 427
  if ((unsigned int )order == 0U) {
#line 428
    cur_byte = start / 8U;
  } else {
#line 430
    cur_byte = ((total_len - start) - 1U) / 8U;
  }
#line 432
  lo_bit = (int )(start % 8U);
#line 433
  if ((unsigned int )lo_bit + len < 8U) {
#line 433
    hi_bit = (int )((unsigned int )lo_bit + len);
  } else {
#line 433
    hi_bit = 8;
  }
  {
#line 435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    shifted = (unsigned int )((int const   )*(data + cur_byte) >> lo_bit);
#line 438
    bits = (unsigned int )(hi_bit - lo_bit);
#line 439
    mask = (unsigned int )((1 << bits) - 1);
#line 440
    result |= (unsigned long )((shifted & mask) << cur_bitshift);
#line 441
    len -= bits;
#line 442
    cur_bitshift = (int )((unsigned int )cur_bitshift + bits);
#line 443
    cur_byte += (unsigned int )nextbyte;
#line 444
    lo_bit = 0;
#line 445
    if (len < 8U) {
#line 445
      hi_bit = (int )len;
    } else {
#line 445
      hi_bit = 8;
    }
#line 435
    if (! (len != 0U)) {
#line 435
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 449
  return (result);
}
}
#line 456 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
void floatformat_to_double(struct floatformat  const  *fmt , void const   *from ,
                           double *to ) 
{ 
  unsigned char const   *ufrom ;
  double dto ;
  long exponent ;
  unsigned long mant ;
  unsigned int mant_bits ;
  unsigned int mant_off ;
  int mant_bits_left ;
  int special_exponent ;
  unsigned long tmp___0 ;
  int nan___0 ;
  int tmp___1 ;
  float tmp___2 ;
  float tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  unsigned long tmp___8 ;

  {
  {
#line 460
  ufrom = (unsigned char const   *)from;
#line 472
  tmp___0 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                      (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len);
#line 472
  exponent = (long )tmp___0;
  }
#line 478
  if ((unsigned long )exponent == (unsigned long )fmt->exp_nan) {
    {
#line 480
    tmp___1 = mant_bits_set(fmt, ufrom);
#line 480
    nan___0 = tmp___1;
    }
#line 489
    if (nan___0) {
      {
#line 490
      tmp___2 = __builtin_nanf("");
#line 490
      dto = (double )tmp___2;
      }
    } else {
      {
#line 492
      tmp___3 = __builtin_inff();
#line 492
      dto = (double )tmp___3;
      }
    }
    {
#line 494
    tmp___4 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                        (unsigned int )fmt->sign_start, 1U);
    }
#line 494
    if (tmp___4) {
#line 495
      dto = - dto;
    }
#line 497
    *to = dto;
#line 499
    return;
  }
#line 502
  mant_bits_left = (int )fmt->man_len;
#line 503
  mant_off = (unsigned int )fmt->man_start;
#line 504
  dto = 0.0;
#line 506
  if (exponent == 0L) {
#line 506
    tmp___5 = 1;
  } else
#line 506
  if ((unsigned long )exponent == (unsigned long )fmt->exp_nan) {
#line 506
    tmp___5 = 1;
  } else {
#line 506
    tmp___5 = 0;
  }
#line 506
  special_exponent = tmp___5;
#line 509
  if (! special_exponent) {
#line 510
    exponent -= (long )fmt->exp_bias;
  }
#line 518
  if (! special_exponent) {
#line 520
    if ((unsigned int const   )fmt->intbit == 1U) {
      {
#line 521
      dto = ldexp(1.0, (int )exponent);
      }
    } else {
#line 523
      exponent ++;
    }
  }
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 526
    if (! (mant_bits_left > 0)) {
#line 526
      goto while_break;
    }
#line 528
    if (mant_bits_left < 32) {
#line 528
      mant_bits = (unsigned int )mant_bits_left;
    } else {
#line 528
      mant_bits = 32U;
    }
    {
#line 530
    mant = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                     mant_off, mant_bits);
    }
#line 535
    if (special_exponent) {
#line 535
      if (exponent == 0L) {
#line 535
        if (mant != 0UL) {
          {
#line 536
          tmp___6 = ldexp((double )mant, (int )((((unsigned int )(- fmt->exp_bias) - mant_bits) - (mant_off - (unsigned int )fmt->man_start)) + 1U));
#line 536
          dto += tmp___6;
          }
        } else {
          {
#line 542
          tmp___7 = ldexp((double )mant, (int )(exponent - (long )mant_bits));
#line 542
          dto += tmp___7;
          }
        }
      } else {
        {
#line 542
        tmp___7 = ldexp((double )mant, (int )(exponent - (long )mant_bits));
#line 542
        dto += tmp___7;
        }
      }
    } else {
      {
#line 542
      tmp___7 = ldexp((double )mant, (int )(exponent - (long )mant_bits));
#line 542
      dto += tmp___7;
      }
    }
#line 543
    if (exponent != 0L) {
#line 544
      exponent -= (long )mant_bits;
    }
#line 545
    mant_off += mant_bits;
#line 546
    mant_bits_left = (int )((unsigned int )mant_bits_left - mant_bits);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  tmp___8 = get_field(ufrom, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
                      (unsigned int )fmt->sign_start, 1U);
  }
#line 550
  if (tmp___8) {
#line 551
    dto = - dto;
  }
#line 552
  *to = dto;
#line 553
  return;
}
}
#line 555
static void put_field(unsigned char *data , enum floatformat_byteorders order , unsigned int total_len ,
                      unsigned int start , unsigned int len , unsigned long stuff_to_put ) ;
#line 563 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
static void put_field(unsigned char *data , enum floatformat_byteorders order , unsigned int total_len ,
                      unsigned int start , unsigned int len , unsigned long stuff_to_put ) 
{ 
  unsigned int cur_byte ;
  int lo_bit ;
  int hi_bit ;
  int nextbyte ;
  int tmp___0 ;
  unsigned char *byte_ptr ;
  unsigned int bits ;
  unsigned int mask ;

  {
#line 570
  if ((unsigned int )order == 0U) {
#line 570
    tmp___0 = 1;
  } else {
#line 570
    tmp___0 = -1;
  }
#line 570
  nextbyte = tmp___0;
#line 573
  start = total_len - (start + len);
#line 576
  if ((unsigned int )order == 0U) {
#line 577
    cur_byte = start / 8U;
  } else {
#line 579
    cur_byte = ((total_len - start) - 1U) / 8U;
  }
#line 581
  lo_bit = (int )(start % 8U);
#line 582
  if ((unsigned int )lo_bit + len < 8U) {
#line 582
    hi_bit = (int )((unsigned int )lo_bit + len);
  } else {
#line 582
    hi_bit = 8;
  }
  {
#line 584
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    byte_ptr = data + cur_byte;
#line 587
    bits = (unsigned int )(hi_bit - lo_bit);
#line 588
    mask = (unsigned int )(((1 << bits) - 1) << lo_bit);
#line 589
    *byte_ptr = (unsigned char )((unsigned long )((unsigned int )*byte_ptr & ~ mask) | ((stuff_to_put << lo_bit) & (unsigned long )mask));
#line 590
    stuff_to_put >>= bits;
#line 591
    len -= bits;
#line 592
    cur_byte += (unsigned int )nextbyte;
#line 593
    lo_bit = 0;
#line 594
    if (len < 8U) {
#line 594
      hi_bit = (int )len;
    } else {
#line 594
      hi_bit = 8;
    }
#line 584
    if (! (len != 0U)) {
#line 584
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 597
  return;
}
}
#line 603 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
void floatformat_from_double(struct floatformat  const  *fmt , double const   *from ,
                             void *to ) 
{ 
  double dfrom ;
  int exponent ;
  double mant ;
  unsigned int mant_bits ;
  unsigned int mant_off ;
  int mant_bits_left ;
  unsigned char *uto ;
  unsigned long mant_long ;

  {
  {
#line 612
  uto = (unsigned char *)to;
#line 614
  dfrom = (double )*from;
#line 615
  memset((void *)uto, 0, (size_t )(fmt->totalsize / 8U));
  }
#line 622
  if (dfrom < (double )0) {
    {
#line 624
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->sign_start, 1U, 1UL);
#line 625
    dfrom = - dfrom;
    }
  }
#line 628
  if (dfrom == (double )0) {
#line 631
    return;
  }
#line 634
  if (dfrom != dfrom) {
    {
#line 637
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, (unsigned long )fmt->exp_nan);
#line 640
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->man_start, 32U, 1UL);
    }
#line 642
    return;
  }
#line 645
  if (dfrom + dfrom == dfrom) {
    {
#line 649
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, (unsigned long )fmt->exp_nan);
    }
#line 651
    return;
  }
  {
#line 654
  mant = frexp(dfrom, & exponent);
  }
#line 655
  if ((exponent + (int )fmt->exp_bias) - 1 > 0) {
    {
#line 656
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, (unsigned long )((exponent + (int )fmt->exp_bias) - 1));
    }
  } else {
    {
#line 662
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              (unsigned int )fmt->exp_start, (unsigned int )fmt->exp_len, 0UL);
#line 664
    mant = ldexp(mant, (exponent + (int )fmt->exp_bias) - 1);
    }
  }
#line 667
  mant_bits_left = (int )fmt->man_len;
#line 668
  mant_off = (unsigned int )fmt->man_start;
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! (mant_bits_left > 0)) {
#line 669
      goto while_break;
    }
#line 672
    if (mant_bits_left < 32) {
#line 672
      mant_bits = (unsigned int )mant_bits_left;
    } else {
#line 672
      mant_bits = 32U;
    }
#line 674
    mant *= 4294967296.0;
#line 675
    mant_long = (unsigned long )mant;
#line 676
    mant -= (double )mant_long;
#line 680
    if ((unsigned int )mant_bits_left == (unsigned int )fmt->man_len) {
#line 680
      if ((unsigned int const   )fmt->intbit == 1U) {
#line 680
        if ((exponent + (int )fmt->exp_bias) - 1 > 0) {
#line 684
          mant_long &= 2147483647UL;
#line 685
          mant_bits --;
        } else {
#line 680
          goto _L___0;
        }
      } else {
#line 680
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 687
    if (mant_bits < 32U) {
#line 691
      mant_long >>= 32U - mant_bits;
    }
    {
#line 694
    put_field(uto, (enum floatformat_byteorders )fmt->byteorder, (unsigned int )fmt->totalsize,
              mant_off, mant_bits, mant_long);
#line 696
    mant_off += mant_bits;
#line 697
    mant_bits_left = (int )((unsigned int )mant_bits_left - mant_bits);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  return;
}
}
#line 703 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./floatformat.c"
int floatformat_is_valid(struct floatformat  const  *fmt , void const   *from ) 
{ 
  int tmp___0 ;

  {
  {
#line 706
  tmp___0 = (*(fmt->is_valid))(fmt, from);
  }
#line 706
  return (tmp___0);
}
}
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 83 "./../include/filenames.h"
int filename_cmp(char const   *s1 , char const   *s2 ) ;
#line 86
int filename_ncmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 89
hashval_t filename_hash(void const   *s ) ;
#line 91
int filename_eq(void const   *s1 , void const   *s2 ) ;
#line 50 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./filename_cmp.c"
int filename_cmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp___0 ;

  {
  {
#line 55
  tmp___0 = strcmp(s1, s2);
  }
#line 55
  return (tmp___0);
}
}
#line 108 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./filename_cmp.c"
int filename_ncmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  int tmp___0 ;

  {
  {
#line 113
  tmp___0 = strncmp(s1, s2, n);
  }
#line 113
  return (tmp___0);
}
}
#line 157 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./filename_cmp.c"
hashval_t filename_hash(void const   *s ) 
{ 
  unsigned char const   *str ;
  hashval_t r ;
  unsigned char c ;
  unsigned char const   *tmp___0 ;

  {
#line 161
  str = (unsigned char const   *)s;
#line 162
  r = (hashval_t )0;
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    tmp___0 = str;
#line 165
    str ++;
#line 165
    c = (unsigned char )*tmp___0;
#line 165
    if (! ((int )c != 0)) {
#line 165
      goto while_break;
    }
#line 167
    if ((int )c == 92) {
#line 168
      c = (unsigned char )'/';
    }
#line 169
    c = (unsigned char )_sch_tolower[(int )c & 255];
#line 170
    r = (r * 67U + (hashval_t )c) - 113U;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (r);
}
}
#line 187 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./filename_cmp.c"
int filename_eq(void const   *s1 , void const   *s2 ) 
{ 
  int tmp___0 ;

  {
  {
#line 191
  tmp___0 = filename_cmp((char const   *)s1, (char const   *)s2);
  }
#line 191
  return (tmp___0 == 0);
}
}
#line 76 "./../include/fibheap.h"
fibheap_t fibheap_new(void) ;
#line 77
fibnode_t fibheap_insert(fibheap_t heap , fibheapkey_t key , void *data ) ;
#line 78
int fibheap_empty(fibheap_t heap ) ;
#line 79
fibheapkey_t fibheap_min_key(fibheap_t heap ) ;
#line 80
fibheapkey_t fibheap_replace_key(fibheap_t heap , fibnode_t node , fibheapkey_t key ) ;
#line 82
void *fibheap_replace_key_data(fibheap_t heap , fibnode_t node , fibheapkey_t key ,
                               void *data ) ;
#line 84
void *fibheap_extract_min(fibheap_t heap ) ;
#line 85
void *fibheap_min(fibheap_t heap ) ;
#line 86
void *fibheap_replace_data(fibheap_t heap , fibnode_t node , void *data ) ;
#line 87
void *fibheap_delete_node(fibheap_t heap , fibnode_t node ) ;
#line 88
void fibheap_delete(fibheap_t heap ) ;
#line 89
fibheap_t fibheap_union(fibheap_t heapa , fibheap_t heapb ) ;
#line 40 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_ins_root(fibheap_t heap , fibnode_t node ) ;
#line 41
static void fibheap_rem_root(fibheap_t heap , fibnode_t node ) ;
#line 42
static void fibheap_consolidate(fibheap_t heap ) ;
#line 43
static void fibheap_link(fibheap_t heap  __attribute__((__unused__)) , fibnode_t node ,
                         fibnode_t parent ) ;
#line 44
static void fibheap_cut(fibheap_t heap , fibnode_t node , fibnode_t parent ) ;
#line 45
static void fibheap_cascading_cut(fibheap_t heap , fibnode_t y ) ;
#line 46
static fibnode_t fibheap_extr_min_node(fibheap_t heap ) ;
#line 47
__inline static int fibheap_compare(fibheap_t heap  __attribute__((__unused__)) ,
                                    fibnode_t a , fibnode_t b ) ;
#line 48
__inline static int fibheap_comp_data(fibheap_t heap , fibheapkey_t key , void *data ,
                                      fibnode_t b ) ;
#line 49
static fibnode_t fibnode_new(void) ;
#line 50
static void fibnode_insert_after(fibnode_t a , fibnode_t b ) ;
#line 52
static fibnode_t fibnode_remove(fibnode_t node ) ;
#line 56 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
fibheap_t fibheap_new(void) 
{ 
  void *tmp___0 ;

  {
  {
#line 59
  tmp___0 = xcalloc((size_t )1, sizeof(struct fibheap ));
  }
#line 59
  return ((fibheap_t )tmp___0);
}
}
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static fibnode_t fibnode_new(void) 
{ 
  fibnode_t node ;
  void *tmp___0 ;

  {
  {
#line 68
  tmp___0 = xcalloc((size_t )1, sizeof(*node));
#line 68
  node = (fibnode_t )tmp___0;
#line 69
  node->left = node;
#line 70
  node->right = node;
  }
#line 72
  return (node);
}
}
#line 75 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
__inline static int fibheap_compare(fibheap_t heap  __attribute__((__unused__)) ,
                                    fibnode_t a , fibnode_t b ) 
{ 


  {
#line 78
  if (a->key < b->key) {
#line 79
    return (-1);
  }
#line 80
  if (a->key > b->key) {
#line 81
    return (1);
  }
#line 82
  return (0);
}
}
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
__inline static int fibheap_comp_data(fibheap_t heap , fibheapkey_t key , void *data ,
                                      fibnode_t b ) 
{ 
  struct fibnode a ;
  int tmp___0 ;

  {
  {
#line 90
  a.key = key;
#line 91
  a.data = data;
#line 93
  tmp___0 = fibheap_compare(heap, & a, b);
  }
#line 93
  return (tmp___0);
}
}
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
fibnode_t fibheap_insert(fibheap_t heap , fibheapkey_t key , void *data ) 
{ 
  fibnode_t node ;

  {
  {
#line 103
  node = fibnode_new();
#line 106
  node->data = data;
#line 107
  node->key = key;
#line 110
  fibheap_ins_root(heap, node);
  }
#line 114
  if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 115
    heap->min = node;
  } else
#line 114
  if (node->key < (heap->min)->key) {
#line 115
    heap->min = node;
  }
#line 117
  (heap->nodes) ++;
#line 119
  return (node);
}
}
#line 123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
void *fibheap_min(fibheap_t heap ) 
{ 


  {
#line 127
  if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 128
    return ((void *)0);
  }
#line 129
  return ((heap->min)->data);
}
}
#line 133 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
fibheapkey_t fibheap_min_key(fibheap_t heap ) 
{ 


  {
#line 137
  if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 138
    return ((fibheapkey_t )0);
  }
#line 139
  return ((heap->min)->key);
}
}
#line 143 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
fibheap_t fibheap_union(fibheap_t heapa , fibheap_t heapb ) 
{ 
  fibnode_t a_root ;
  fibnode_t b_root ;
  fibnode_t temp ;
  int tmp___0 ;

  {
#line 149
  a_root = heapa->root;
#line 149
  if ((unsigned long )a_root == (unsigned long )((void *)0)) {
    {
#line 151
    free((void *)heapa);
    }
#line 152
    return (heapb);
  }
#line 154
  b_root = heapb->root;
#line 154
  if ((unsigned long )b_root == (unsigned long )((void *)0)) {
    {
#line 156
    free((void *)heapb);
    }
#line 157
    return (heapa);
  }
  {
#line 161
  (a_root->left)->right = b_root;
#line 162
  (b_root->left)->right = a_root;
#line 163
  temp = a_root->left;
#line 164
  a_root->left = b_root->left;
#line 165
  b_root->left = temp;
#line 166
  heapa->nodes += heapb->nodes;
#line 169
  tmp___0 = fibheap_compare(heapa, heapb->min, heapa->min);
  }
#line 169
  if (tmp___0 < 0) {
#line 170
    heapa->min = heapb->min;
  }
  {
#line 172
  free((void *)heapb);
  }
#line 173
  return (heapa);
}
}
#line 177 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
void *fibheap_extract_min(fibheap_t heap ) 
{ 
  fibnode_t z ;
  void *ret ;

  {
#line 181
  ret = (void *)0;
#line 184
  if ((unsigned long )heap->min != (unsigned long )((void *)0)) {
    {
#line 188
    z = fibheap_extr_min_node(heap);
#line 189
    ret = z->data;
#line 190
    free((void *)z);
    }
  }
#line 193
  return (ret);
}
}
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
void *fibheap_replace_key_data(fibheap_t heap , fibnode_t node , fibheapkey_t key ,
                               void *data ) 
{ 
  void *odata ;
  fibheapkey_t okey ;
  fibnode_t y ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 208
  tmp___0 = fibheap_comp_data(heap, key, data, node);
  }
#line 208
  if (tmp___0 > 0) {
#line 209
    return ((void *)0);
  }
#line 211
  odata = node->data;
#line 212
  okey = node->key;
#line 213
  node->data = data;
#line 214
  node->key = key;
#line 215
  y = node->parent;
#line 220
  if (okey == key) {
#line 220
    if (okey != (-0x7FFFFFFFFFFFFFFF-1)) {
#line 221
      return (odata);
    }
  }
#line 226
  if ((unsigned long )y != (unsigned long )((void *)0)) {
    {
#line 226
    tmp___1 = fibheap_compare(heap, node, y);
    }
#line 226
    if (tmp___1 <= 0) {
      {
#line 228
      fibheap_cut(heap, node, y);
#line 229
      fibheap_cascading_cut(heap, y);
      }
    }
  }
  {
#line 232
  tmp___2 = fibheap_compare(heap, node, heap->min);
  }
#line 232
  if (tmp___2 <= 0) {
#line 233
    heap->min = node;
  }
#line 235
  return (odata);
}
}
#line 239 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
void *fibheap_replace_data(fibheap_t heap , fibnode_t node , void *data ) 
{ 
  void *tmp___0 ;

  {
  {
#line 242
  tmp___0 = fibheap_replace_key_data(heap, node, node->key, data);
  }
#line 242
  return (tmp___0);
}
}
#line 246 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
fibheapkey_t fibheap_replace_key(fibheap_t heap , fibnode_t node , fibheapkey_t key ) 
{ 
  int okey ;

  {
  {
#line 249
  okey = (int )node->key;
#line 250
  fibheap_replace_key_data(heap, node, key, node->data);
  }
#line 251
  return ((fibheapkey_t )okey);
}
}
#line 255 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
void *fibheap_delete_node(fibheap_t heap , fibnode_t node ) 
{ 
  void *ret ;

  {
  {
#line 258
  ret = node->data;
#line 261
  fibheap_replace_key(heap, node, (-0x7FFFFFFFFFFFFFFF-1));
  }
#line 262
  if ((unsigned long )node != (unsigned long )heap->min) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t force minimum on fibheap.\n");
#line 265
    abort();
    }
  }
  {
#line 267
  fibheap_extract_min(heap);
  }
#line 269
  return (ret);
}
}
#line 273 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
void fibheap_delete(fibheap_t heap ) 
{ 
  fibnode_t tmp___0 ;

  {
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! ((unsigned long )heap->min != (unsigned long )((void *)0))) {
#line 276
      goto while_break;
    }
    {
#line 277
    tmp___0 = fibheap_extr_min_node(heap);
#line 277
    free((void *)tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  free((void *)heap);
  }
#line 280
  return;
}
}
#line 283 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
int fibheap_empty(fibheap_t heap ) 
{ 


  {
#line 286
  return (heap->nodes == 0UL);
}
}
#line 290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static fibnode_t fibheap_extr_min_node(fibheap_t heap ) 
{ 
  fibnode_t ret ;
  fibnode_t x ;
  fibnode_t y ;
  fibnode_t orig ;

  {
#line 293
  ret = heap->min;
#line 298
  x = ret->child;
#line 298
  orig = (fibnode_t )((void *)0);
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if ((unsigned long )x != (unsigned long )orig) {
#line 298
      if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 298
        goto while_break;
      }
    } else {
#line 298
      goto while_break;
    }
#line 300
    if ((unsigned long )orig == (unsigned long )((void *)0)) {
#line 301
      orig = x;
    }
    {
#line 302
    y = x->right;
#line 303
    x->parent = (struct fibnode *)((void *)0);
#line 304
    fibheap_ins_root(heap, x);
#line 298
    x = y;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  fibheap_rem_root(heap, ret);
#line 309
  (heap->nodes) --;
  }
#line 312
  if (heap->nodes == 0UL) {
#line 313
    heap->min = (struct fibnode *)((void *)0);
  } else {
    {
#line 318
    heap->min = ret->right;
#line 319
    fibheap_consolidate(heap);
    }
  }
#line 322
  return (ret);
}
}
#line 326 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_ins_root(fibheap_t heap , fibnode_t node ) 
{ 


  {
#line 331
  if ((unsigned long )heap->root == (unsigned long )((void *)0)) {
#line 333
    heap->root = node;
#line 334
    node->left = node;
#line 335
    node->right = node;
#line 336
    return;
  }
  {
#line 341
  fibnode_insert_after(heap->root, node);
  }
#line 342
  return;
}
}
#line 345 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_rem_root(fibheap_t heap , fibnode_t node ) 
{ 


  {
#line 348
  if ((unsigned long )node->left == (unsigned long )node) {
#line 349
    heap->root = (struct fibnode *)((void *)0);
  } else {
    {
#line 351
    heap->root = fibnode_remove(node);
    }
  }
#line 352
  return;
}
}
#line 355 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_consolidate(fibheap_t heap ) 
{ 
  fibnode_t a[1UL + 8UL * sizeof(long )] ;
  fibnode_t w ;
  fibnode_t y ;
  fibnode_t x ;
  int i ;
  int d ;
  int D ;
  fibnode_t temp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 366
  D = (int )(1UL + 8UL * sizeof(long ));
#line 368
  memset((void *)(a), 0, sizeof(fibnode_t ) * (unsigned long )D);
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    w = heap->root;
#line 370
    if (! ((unsigned long )w != (unsigned long )((void *)0))) {
#line 370
      goto while_break;
    }
    {
#line 372
    x = w;
#line 373
    fibheap_rem_root(heap, w);
#line 374
    d = (int )x->degree;
    }
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 375
      if (! ((unsigned long )a[d] != (unsigned long )((void *)0))) {
#line 375
        goto while_break___0;
      }
      {
#line 377
      y = a[d];
#line 378
      tmp___0 = fibheap_compare(heap, x, y);
      }
#line 378
      if (tmp___0 > 0) {
#line 381
        temp = x;
#line 382
        x = y;
#line 383
        y = temp;
      }
      {
#line 385
      fibheap_link(heap, y, x);
#line 386
      a[d] = (fibnode_t )((void *)0);
#line 387
      d ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 389
    a[d] = x;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  heap->min = (struct fibnode *)((void *)0);
#line 392
  i = 0;
  {
#line 392
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 392
    if (! (i < D)) {
#line 392
      goto while_break___1;
    }
#line 393
    if ((unsigned long )a[i] != (unsigned long )((void *)0)) {
      {
#line 395
      fibheap_ins_root(heap, a[i]);
      }
#line 396
      if ((unsigned long )heap->min == (unsigned long )((void *)0)) {
#line 397
        heap->min = a[i];
      } else {
        {
#line 396
        tmp___1 = fibheap_compare(heap, a[i], heap->min);
        }
#line 396
        if (tmp___1 < 0) {
#line 397
          heap->min = a[i];
        }
      }
    }
#line 392
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 399
  return;
}
}
#line 402 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_link(fibheap_t heap  __attribute__((__unused__)) , fibnode_t node ,
                         fibnode_t parent ) 
{ 


  {
#line 406
  if ((unsigned long )parent->child == (unsigned long )((void *)0)) {
#line 407
    parent->child = node;
  } else {
    {
#line 409
    fibnode_insert_after((parent->child)->left, node);
    }
  }
#line 410
  node->parent = parent;
#line 411
  (parent->degree) ++;
#line 412
  node->mark = 0U;
#line 413
  return;
}
}
#line 416 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_cut(fibheap_t heap , fibnode_t node , fibnode_t parent ) 
{ 


  {
  {
#line 419
  fibnode_remove(node);
#line 420
  (parent->degree) --;
#line 421
  fibheap_ins_root(heap, node);
#line 422
  node->parent = (struct fibnode *)((void *)0);
#line 423
  node->mark = 0U;
  }
#line 424
  return;
}
}
#line 426 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibheap_cascading_cut(fibheap_t heap , fibnode_t y ) 
{ 
  fibnode_t z ;

  {
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    z = y->parent;
#line 431
    if (! ((unsigned long )z != (unsigned long )((void *)0))) {
#line 431
      goto while_break;
    }
#line 433
    if (y->mark == 0U) {
#line 435
      y->mark = 1U;
#line 436
      return;
    } else {
      {
#line 440
      fibheap_cut(heap, y, z);
#line 441
      y = z;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  return;
}
}
#line 446 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static void fibnode_insert_after(fibnode_t a , fibnode_t b ) 
{ 


  {
#line 449
  if ((unsigned long )a == (unsigned long )a->right) {
#line 451
    a->right = b;
#line 452
    a->left = b;
#line 453
    b->right = a;
#line 454
    b->left = a;
  } else {
#line 458
    b->right = a->right;
#line 459
    (a->right)->left = b;
#line 460
    a->right = b;
#line 461
    b->left = a;
  }
#line 463
  return;
}
}
#line 465 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fibheap.c"
static fibnode_t fibnode_remove(fibnode_t node ) 
{ 
  fibnode_t ret ;

  {
#line 470
  if ((unsigned long )node == (unsigned long )node->left) {
#line 471
    ret = (fibnode_t )((void *)0);
  } else {
#line 473
    ret = node->left;
  }
#line 475
  if ((unsigned long )node->parent != (unsigned long )((void *)0)) {
#line 475
    if ((unsigned long )(node->parent)->child == (unsigned long )node) {
#line 476
      (node->parent)->child = ret;
    }
  }
#line 478
  (node->right)->left = node->left;
#line 479
  (node->left)->right = node->right;
#line 481
  node->parent = (struct fibnode *)((void *)0);
#line 482
  node->left = node;
#line 483
  node->right = node;
#line 485
  return (ret);
}
}
#line 187 "./../include/libiberty.h"
int fdmatch(int fd1 , int fd2 ) ;
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 52 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./fdmatch.c"
int fdmatch(int fd1 , int fd2 ) 
{ 
  struct stat sbuf1 ;
  struct stat sbuf2 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 57
  tmp___0 = fstat(fd1, & sbuf1);
  }
#line 57
  if (tmp___0 == 0) {
    {
#line 57
    tmp___1 = fstat(fd2, & sbuf2);
    }
#line 57
    if (tmp___1 == 0) {
#line 57
      if (sbuf1.st_dev == sbuf2.st_dev) {
#line 57
        if (sbuf1.st_ino == sbuf2.st_ino) {
#line 62
          return (1);
        } else {
#line 66
          return (0);
        }
      } else {
#line 66
        return (0);
      }
    } else {
#line 66
      return (0);
    }
  } else {
#line 66
    return (0);
  }
}
}
#line 50 "./../include/dyn-string.h"
int dyn_string_init(struct dyn_string *ds_struct_ptr , int space ) ;
#line 51
dyn_string_t dyn_string_new(int space ) ;
#line 52
void dyn_string_delete(dyn_string_t ds ) ;
#line 53
char *dyn_string_release(dyn_string_t ds ) ;
#line 54
dyn_string_t dyn_string_resize(dyn_string_t ds , int space ) ;
#line 55
void dyn_string_clear(dyn_string_t ds ) ;
#line 56
int dyn_string_copy(dyn_string_t dest , dyn_string_t src ) ;
#line 57
int dyn_string_copy_cstr(dyn_string_t dest , char const   *src ) ;
#line 58
int dyn_string_prepend(dyn_string_t dest , dyn_string_t src ) ;
#line 59
int dyn_string_prepend_cstr(dyn_string_t dest , char const   *src ) ;
#line 60
int dyn_string_insert(dyn_string_t dest , int pos , dyn_string_t src ) ;
#line 61
int dyn_string_insert_cstr(dyn_string_t dest , int pos , char const   *src ) ;
#line 62
int dyn_string_insert_char(dyn_string_t dest , int pos , int c ) ;
#line 63
int dyn_string_append(dyn_string_t dest , dyn_string_t s ) ;
#line 64
int dyn_string_append_cstr(dyn_string_t dest , char const   *s ) ;
#line 65
int dyn_string_append_char(dyn_string_t dest , int c ) ;
#line 66
int dyn_string_substring(dyn_string_t dest , dyn_string_t src , int start , int end ) ;
#line 67
int dyn_string_eq(dyn_string_t ds1 , dyn_string_t ds2 ) ;
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_init(struct dyn_string *ds_struct_ptr , int space ) 
{ 
  void *tmp___0 ;

  {
#line 62
  if (space == 0) {
#line 63
    space = 1;
  }
  {
#line 70
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )space);
#line 70
  ds_struct_ptr->s = (char *)tmp___0;
#line 72
  ds_struct_ptr->allocated = space;
#line 73
  ds_struct_ptr->length = 0;
#line 74
  *(ds_struct_ptr->s + 0) = (char )'\000';
  }
#line 76
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
dyn_string_t dyn_string_new(int space ) 
{ 
  dyn_string_t result ;
  void *tmp___0 ;

  {
  {
#line 99
  tmp___0 = xmalloc(sizeof(struct dyn_string ));
#line 99
  result = (struct dyn_string *)tmp___0;
#line 100
  dyn_string_init(result, space);
  }
#line 102
  return (result);
}
}
#line 107 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
void dyn_string_delete(dyn_string_t ds ) 
{ 


  {
  {
#line 110
  free((void *)ds->s);
#line 111
  free((void *)ds);
  }
#line 112
  return;
}
}
#line 118 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
char *dyn_string_release(dyn_string_t ds ) 
{ 
  char *result ;

  {
  {
#line 122
  result = ds->s;
#line 124
  ds->s = (char *)((void *)0);
#line 126
  free((void *)ds);
  }
#line 128
  return (result);
}
}
#line 138 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
dyn_string_t dyn_string_resize(dyn_string_t ds , int space ) 
{ 
  int new_allocated ;
  void *tmp___0 ;

  {
#line 141
  new_allocated = ds->allocated;
#line 144
  space ++;
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    if (! (space > new_allocated)) {
#line 147
      goto while_break;
    }
#line 148
    new_allocated *= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  if (new_allocated != ds->allocated) {
    {
#line 152
    ds->allocated = new_allocated;
#line 162
    tmp___0 = xrealloc((void *)ds->s, sizeof(char ) * (unsigned long )ds->allocated);
#line 162
    ds->s = (char *)tmp___0;
    }
  }
#line 166
  return (ds);
}
}
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
void dyn_string_clear(dyn_string_t ds ) 
{ 


  {
#line 175
  *(ds->s + 0) = (char )'\000';
#line 176
  ds->length = 0;
#line 177
  return;
}
}
#line 183 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_copy(dyn_string_t dest , dyn_string_t src ) 
{ 
  dyn_string_t tmp___0 ;

  {
#line 186
  if ((unsigned long )dest == (unsigned long )src) {
    {
#line 187
    abort();
    }
  }
  {
#line 190
  tmp___0 = dyn_string_resize(dest, src->length);
  }
#line 190
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 191
    return (0);
  }
  {
#line 193
  strcpy((char */* __restrict  */)dest->s, (char const   */* __restrict  */)src->s);
#line 195
  dest->length = src->length;
  }
#line 196
  return (1);
}
}
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_copy_cstr(dyn_string_t dest , char const   *src ) 
{ 
  int length ;
  size_t tmp___0 ;
  dyn_string_t tmp___1 ;

  {
  {
#line 206
  tmp___0 = strlen(src);
#line 206
  length = (int )tmp___0;
#line 208
  tmp___1 = dyn_string_resize(dest, length);
  }
#line 208
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 209
    return (0);
  }
  {
#line 211
  strcpy((char */* __restrict  */)dest->s, (char const   */* __restrict  */)src);
#line 213
  dest->length = length;
  }
#line 214
  return (1);
}
}
#line 222 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_prepend(dyn_string_t dest , dyn_string_t src ) 
{ 
  int tmp___0 ;

  {
  {
#line 225
  tmp___0 = dyn_string_insert(dest, 0, src);
  }
#line 225
  return (tmp___0);
}
}
#line 232 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_prepend_cstr(dyn_string_t dest , char const   *src ) 
{ 
  int tmp___0 ;

  {
  {
#line 235
  tmp___0 = dyn_string_insert_cstr(dest, 0, src);
  }
#line 235
  return (tmp___0);
}
}
#line 243 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_insert(dyn_string_t dest , int pos , dyn_string_t src ) 
{ 
  int i ;
  dyn_string_t tmp___0 ;

  {
#line 248
  if ((unsigned long )src == (unsigned long )dest) {
    {
#line 249
    abort();
    }
  }
  {
#line 251
  tmp___0 = dyn_string_resize(dest, dest->length + src->length);
  }
#line 251
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 252
    return (0);
  }
#line 254
  i = dest->length;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i >= pos)) {
#line 254
      goto while_break;
    }
#line 255
    *(dest->s + (i + src->length)) = *(dest->s + i);
#line 254
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  strncpy((char */* __restrict  */)(dest->s + pos), (char const   */* __restrict  */)src->s,
          (size_t )src->length);
#line 259
  dest->length += src->length;
  }
#line 260
  return (1);
}
}
#line 268 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_insert_cstr(dyn_string_t dest , int pos , char const   *src ) 
{ 
  int i ;
  int length ;
  size_t tmp___0 ;
  dyn_string_t tmp___1 ;

  {
  {
#line 272
  tmp___0 = strlen(src);
#line 272
  length = (int )tmp___0;
#line 274
  tmp___1 = dyn_string_resize(dest, dest->length + length);
  }
#line 274
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 275
    return (0);
  }
#line 277
  i = dest->length;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! (i >= pos)) {
#line 277
      goto while_break;
    }
#line 278
    *(dest->s + (i + length)) = *(dest->s + i);
#line 277
    i --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 280
  strncpy((char */* __restrict  */)(dest->s + pos), (char const   */* __restrict  */)src,
          (size_t )length);
#line 282
  dest->length += length;
  }
#line 283
  return (1);
}
}
#line 290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_insert_char(dyn_string_t dest , int pos , int c ) 
{ 
  int i ;
  dyn_string_t tmp___0 ;

  {
  {
#line 295
  tmp___0 = dyn_string_resize(dest, dest->length + 1);
  }
#line 295
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 296
    return (0);
  }
#line 298
  i = dest->length;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! (i >= pos)) {
#line 298
      goto while_break;
    }
#line 299
    *(dest->s + (i + 1)) = *(dest->s + i);
#line 298
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  *(dest->s + pos) = (char )c;
#line 303
  (dest->length) ++;
#line 304
  return (1);
}
}
#line 311 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_append(dyn_string_t dest , dyn_string_t s ) 
{ 
  dyn_string_t tmp___0 ;

  {
  {
#line 314
  tmp___0 = dyn_string_resize(dest, dest->length + s->length);
  }
#line 314
  if ((unsigned long )tmp___0 == (unsigned long )((dyn_string_t )0)) {
#line 315
    return (0);
  }
  {
#line 316
  strcpy((char */* __restrict  */)(dest->s + dest->length), (char const   */* __restrict  */)s->s);
#line 317
  dest->length += s->length;
  }
#line 318
  return (1);
}
}
#line 325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_append_cstr(dyn_string_t dest , char const   *s ) 
{ 
  int len ;
  size_t tmp___0 ;
  dyn_string_t tmp___1 ;

  {
  {
#line 328
  tmp___0 = strlen(s);
#line 328
  len = (int )tmp___0;
#line 332
  tmp___1 = dyn_string_resize(dest, dest->length + len);
  }
#line 332
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 333
    return (0);
  }
  {
#line 334
  strcpy((char */* __restrict  */)(dest->s + dest->length), (char const   */* __restrict  */)s);
#line 335
  dest->length += len;
  }
#line 336
  return (1);
}
}
#line 342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_append_char(dyn_string_t dest , int c ) 
{ 
  dyn_string_t tmp___0 ;

  {
  {
#line 346
  tmp___0 = dyn_string_resize(dest, dest->length + 1);
  }
#line 346
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 347
    return (0);
  }
#line 349
  *(dest->s + dest->length) = (char )c;
#line 351
  *(dest->s + (dest->length + 1)) = (char )'\000';
#line 353
  (dest->length) ++;
#line 354
  return (1);
}
}
#line 363 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_substring(dyn_string_t dest , dyn_string_t src , int start , int end ) 
{ 
  int i ;
  int length ;
  dyn_string_t tmp___0 ;

  {
#line 368
  length = end - start;
#line 370
  if (start > end) {
    {
#line 371
    abort();
    }
  } else
#line 370
  if (start > src->length) {
    {
#line 371
    abort();
    }
  } else
#line 370
  if (end > src->length) {
    {
#line 371
    abort();
    }
  }
  {
#line 374
  tmp___0 = dyn_string_resize(dest, length);
  }
#line 374
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 375
    return (0);
  }
#line 377
  i = length;
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    i --;
#line 377
    if (! (i >= 0)) {
#line 377
      goto while_break;
    }
#line 378
    *(dest->s + i) = *(src->s + (start + i));
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  *(dest->s + length) = (char )'\000';
#line 382
  dest->length = length;
#line 384
  return (1);
}
}
#line 389 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./dyn-string.c"
int dyn_string_eq(dyn_string_t ds1 , dyn_string_t ds2 ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 393
  if (ds1->length != ds2->length) {
#line 394
    return (0);
  } else {
    {
#line 396
    tmp___0 = strcmp((char const   *)ds1->s, (char const   *)ds2->s);
    }
#line 396
    if (tmp___0) {
#line 396
      tmp___1 = 0;
    } else {
#line 396
      tmp___1 = 1;
    }
#line 396
    return (tmp___1);
  }
}
}
#line 375 "./../include/dwarf2.h"
char const   *get_DW_TAG_name(unsigned int tag ) ;
#line 379
char const   *get_DW_AT_name(unsigned int attr ) ;
#line 383
char const   *get_DW_FORM_name(unsigned int form ) ;
#line 387
char const   *get_DW_OP_name(unsigned int op ) ;
#line 391
char const   *get_DW_ATE_name(unsigned int enc ) ;
#line 395
char const   *get_DW_CFA_name(unsigned int opc ) ;
#line 73 "./../include/dwarf2.def"
char const   *get_DW_TAG_name(unsigned int tag ) 
{ 


  {
  {
#line 73
  if (tag == 0U) {
#line 73
    goto case_0;
  }
#line 74
  if (tag == 1U) {
#line 74
    goto case_1;
  }
#line 75
  if (tag == 2U) {
#line 75
    goto case_2;
  }
#line 76
  if (tag == 3U) {
#line 76
    goto case_3;
  }
#line 77
  if (tag == 4U) {
#line 77
    goto case_4;
  }
#line 78
  if (tag == 5U) {
#line 78
    goto case_5;
  }
#line 79
  if (tag == 8U) {
#line 79
    goto case_8;
  }
#line 80
  if (tag == 10U) {
#line 80
    goto case_10;
  }
#line 81
  if (tag == 11U) {
#line 81
    goto case_11;
  }
#line 82
  if (tag == 13U) {
#line 82
    goto case_13;
  }
#line 83
  if (tag == 15U) {
#line 83
    goto case_15;
  }
#line 84
  if (tag == 16U) {
#line 84
    goto case_16;
  }
#line 85
  if (tag == 17U) {
#line 85
    goto case_17;
  }
#line 86
  if (tag == 18U) {
#line 86
    goto case_18;
  }
#line 87
  if (tag == 19U) {
#line 87
    goto case_19;
  }
#line 88
  if (tag == 21U) {
#line 88
    goto case_21;
  }
#line 89
  if (tag == 22U) {
#line 89
    goto case_22;
  }
#line 90
  if (tag == 23U) {
#line 90
    goto case_23;
  }
#line 91
  if (tag == 24U) {
#line 91
    goto case_24;
  }
#line 92
  if (tag == 25U) {
#line 92
    goto case_25;
  }
#line 93
  if (tag == 26U) {
#line 93
    goto case_26;
  }
#line 94
  if (tag == 27U) {
#line 94
    goto case_27;
  }
#line 95
  if (tag == 28U) {
#line 95
    goto case_28;
  }
#line 96
  if (tag == 29U) {
#line 96
    goto case_29;
  }
#line 97
  if (tag == 30U) {
#line 97
    goto case_30;
  }
#line 98
  if (tag == 31U) {
#line 98
    goto case_31;
  }
#line 99
  if (tag == 32U) {
#line 99
    goto case_32;
  }
#line 100
  if (tag == 33U) {
#line 100
    goto case_33;
  }
#line 101
  if (tag == 34U) {
#line 101
    goto case_34;
  }
#line 102
  if (tag == 35U) {
#line 102
    goto case_35;
  }
#line 103
  if (tag == 36U) {
#line 103
    goto case_36;
  }
#line 104
  if (tag == 37U) {
#line 104
    goto case_37;
  }
#line 105
  if (tag == 38U) {
#line 105
    goto case_38;
  }
#line 106
  if (tag == 39U) {
#line 106
    goto case_39;
  }
#line 107
  if (tag == 40U) {
#line 107
    goto case_40;
  }
#line 108
  if (tag == 41U) {
#line 108
    goto case_41;
  }
#line 109
  if (tag == 42U) {
#line 109
    goto case_42;
  }
#line 110
  if (tag == 43U) {
#line 110
    goto case_43;
  }
#line 111
  if (tag == 44U) {
#line 111
    goto case_44;
  }
#line 112
  if (tag == 45U) {
#line 112
    goto case_45;
  }
#line 113
  if (tag == 46U) {
#line 113
    goto case_46;
  }
#line 114
  if (tag == 47U) {
#line 114
    goto case_47;
  }
#line 115
  if (tag == 48U) {
#line 115
    goto case_48;
  }
#line 116
  if (tag == 49U) {
#line 116
    goto case_49;
  }
#line 117
  if (tag == 50U) {
#line 117
    goto case_50;
  }
#line 118
  if (tag == 51U) {
#line 118
    goto case_51;
  }
#line 119
  if (tag == 52U) {
#line 119
    goto case_52;
  }
#line 120
  if (tag == 53U) {
#line 120
    goto case_53;
  }
#line 122
  if (tag == 54U) {
#line 122
    goto case_54;
  }
#line 123
  if (tag == 55U) {
#line 123
    goto case_55;
  }
#line 124
  if (tag == 56U) {
#line 124
    goto case_56;
  }
#line 125
  if (tag == 57U) {
#line 125
    goto case_57;
  }
#line 126
  if (tag == 58U) {
#line 126
    goto case_58;
  }
#line 127
  if (tag == 59U) {
#line 127
    goto case_59;
  }
#line 128
  if (tag == 60U) {
#line 128
    goto case_60;
  }
#line 129
  if (tag == 61U) {
#line 129
    goto case_61;
  }
#line 130
  if (tag == 63U) {
#line 130
    goto case_63;
  }
#line 131
  if (tag == 64U) {
#line 131
    goto case_64;
  }
#line 133
  if (tag == 65U) {
#line 133
    goto case_65;
  }
#line 134
  if (tag == 66U) {
#line 134
    goto case_66;
  }
#line 135
  if (tag == 67U) {
#line 135
    goto case_67;
  }
#line 141
  if (tag == 16513U) {
#line 141
    goto case_16513;
  }
#line 144
  if (tag == 16528U) {
#line 144
    goto case_16528;
  }
#line 145
  if (tag == 16529U) {
#line 145
    goto case_16529;
  }
#line 146
  if (tag == 16530U) {
#line 146
    goto case_16530;
  }
#line 149
  if (tag == 16641U) {
#line 149
    goto case_16641;
  }
#line 150
  if (tag == 16642U) {
#line 150
    goto case_16642;
  }
#line 151
  if (tag == 16643U) {
#line 151
    goto case_16643;
  }
#line 152
  if (tag == 16644U) {
#line 152
    goto case_16644;
  }
#line 153
  if (tag == 16645U) {
#line 153
    goto case_16645;
  }
#line 156
  if (tag == 16646U) {
#line 156
    goto case_16646;
  }
#line 162
  if (tag == 16647U) {
#line 162
    goto case_16647;
  }
#line 163
  if (tag == 16648U) {
#line 163
    goto case_16648;
  }
#line 168
  if (tag == 16649U) {
#line 168
    goto case_16649;
  }
#line 169
  if (tag == 16650U) {
#line 169
    goto case_16650;
  }
#line 171
  if (tag == 34661U) {
#line 171
    goto case_34661;
  }
#line 172
  if (tag == 34662U) {
#line 172
    goto case_34662;
  }
#line 173
  if (tag == 34663U) {
#line 173
    goto case_34663;
  }
#line 175
  if (tag == 40960U) {
#line 175
    goto case_40960;
  }
#line 176
  if (tag == 40992U) {
#line 176
    goto case_40992;
  }
#line 73
  goto switch_break;
  case_0: /* CIL Label */ 
#line 73
  return ("DW_TAG_padding");
  case_1: /* CIL Label */ 
#line 74
  return ("DW_TAG_array_type");
  case_2: /* CIL Label */ 
#line 75
  return ("DW_TAG_class_type");
  case_3: /* CIL Label */ 
#line 76
  return ("DW_TAG_entry_point");
  case_4: /* CIL Label */ 
#line 77
  return ("DW_TAG_enumeration_type");
  case_5: /* CIL Label */ 
#line 78
  return ("DW_TAG_formal_parameter");
  case_8: /* CIL Label */ 
#line 79
  return ("DW_TAG_imported_declaration");
  case_10: /* CIL Label */ 
#line 80
  return ("DW_TAG_label");
  case_11: /* CIL Label */ 
#line 81
  return ("DW_TAG_lexical_block");
  case_13: /* CIL Label */ 
#line 82
  return ("DW_TAG_member");
  case_15: /* CIL Label */ 
#line 83
  return ("DW_TAG_pointer_type");
  case_16: /* CIL Label */ 
#line 84
  return ("DW_TAG_reference_type");
  case_17: /* CIL Label */ 
#line 85
  return ("DW_TAG_compile_unit");
  case_18: /* CIL Label */ 
#line 86
  return ("DW_TAG_string_type");
  case_19: /* CIL Label */ 
#line 87
  return ("DW_TAG_structure_type");
  case_21: /* CIL Label */ 
#line 88
  return ("DW_TAG_subroutine_type");
  case_22: /* CIL Label */ 
#line 89
  return ("DW_TAG_typedef");
  case_23: /* CIL Label */ 
#line 90
  return ("DW_TAG_union_type");
  case_24: /* CIL Label */ 
#line 91
  return ("DW_TAG_unspecified_parameters");
  case_25: /* CIL Label */ 
#line 92
  return ("DW_TAG_variant");
  case_26: /* CIL Label */ 
#line 93
  return ("DW_TAG_common_block");
  case_27: /* CIL Label */ 
#line 94
  return ("DW_TAG_common_inclusion");
  case_28: /* CIL Label */ 
#line 95
  return ("DW_TAG_inheritance");
  case_29: /* CIL Label */ 
#line 96
  return ("DW_TAG_inlined_subroutine");
  case_30: /* CIL Label */ 
#line 97
  return ("DW_TAG_module");
  case_31: /* CIL Label */ 
#line 98
  return ("DW_TAG_ptr_to_member_type");
  case_32: /* CIL Label */ 
#line 99
  return ("DW_TAG_set_type");
  case_33: /* CIL Label */ 
#line 100
  return ("DW_TAG_subrange_type");
  case_34: /* CIL Label */ 
#line 101
  return ("DW_TAG_with_stmt");
  case_35: /* CIL Label */ 
#line 102
  return ("DW_TAG_access_declaration");
  case_36: /* CIL Label */ 
#line 103
  return ("DW_TAG_base_type");
  case_37: /* CIL Label */ 
#line 104
  return ("DW_TAG_catch_block");
  case_38: /* CIL Label */ 
#line 105
  return ("DW_TAG_const_type");
  case_39: /* CIL Label */ 
#line 106
  return ("DW_TAG_constant");
  case_40: /* CIL Label */ 
#line 107
  return ("DW_TAG_enumerator");
  case_41: /* CIL Label */ 
#line 108
  return ("DW_TAG_file_type");
  case_42: /* CIL Label */ 
#line 109
  return ("DW_TAG_friend");
  case_43: /* CIL Label */ 
#line 110
  return ("DW_TAG_namelist");
  case_44: /* CIL Label */ 
#line 111
  return ("DW_TAG_namelist_item");
  case_45: /* CIL Label */ 
#line 112
  return ("DW_TAG_packed_type");
  case_46: /* CIL Label */ 
#line 113
  return ("DW_TAG_subprogram");
  case_47: /* CIL Label */ 
#line 114
  return ("DW_TAG_template_type_param");
  case_48: /* CIL Label */ 
#line 115
  return ("DW_TAG_template_value_param");
  case_49: /* CIL Label */ 
#line 116
  return ("DW_TAG_thrown_type");
  case_50: /* CIL Label */ 
#line 117
  return ("DW_TAG_try_block");
  case_51: /* CIL Label */ 
#line 118
  return ("DW_TAG_variant_part");
  case_52: /* CIL Label */ 
#line 119
  return ("DW_TAG_variable");
  case_53: /* CIL Label */ 
#line 120
  return ("DW_TAG_volatile_type");
  case_54: /* CIL Label */ 
#line 122
  return ("DW_TAG_dwarf_procedure");
  case_55: /* CIL Label */ 
#line 123
  return ("DW_TAG_restrict_type");
  case_56: /* CIL Label */ 
#line 124
  return ("DW_TAG_interface_type");
  case_57: /* CIL Label */ 
#line 125
  return ("DW_TAG_namespace");
  case_58: /* CIL Label */ 
#line 126
  return ("DW_TAG_imported_module");
  case_59: /* CIL Label */ 
#line 127
  return ("DW_TAG_unspecified_type");
  case_60: /* CIL Label */ 
#line 128
  return ("DW_TAG_partial_unit");
  case_61: /* CIL Label */ 
#line 129
  return ("DW_TAG_imported_unit");
  case_63: /* CIL Label */ 
#line 130
  return ("DW_TAG_condition");
  case_64: /* CIL Label */ 
#line 131
  return ("DW_TAG_shared_type");
  case_65: /* CIL Label */ 
#line 133
  return ("DW_TAG_type_unit");
  case_66: /* CIL Label */ 
#line 134
  return ("DW_TAG_rvalue_reference_type");
  case_67: /* CIL Label */ 
#line 135
  return ("DW_TAG_template_alias");
  case_16513: /* CIL Label */ 
#line 141
  return ("DW_TAG_MIPS_loop");
  case_16528: /* CIL Label */ 
#line 144
  return ("DW_TAG_HP_array_descriptor");
  case_16529: /* CIL Label */ 
#line 145
  return ("DW_TAG_HP_Bliss_field");
  case_16530: /* CIL Label */ 
#line 146
  return ("DW_TAG_HP_Bliss_field_set");
  case_16641: /* CIL Label */ 
#line 149
  return ("DW_TAG_format_label");
  case_16642: /* CIL Label */ 
#line 150
  return ("DW_TAG_function_template");
  case_16643: /* CIL Label */ 
#line 151
  return ("DW_TAG_class_template");
  case_16644: /* CIL Label */ 
#line 152
  return ("DW_TAG_GNU_BINCL");
  case_16645: /* CIL Label */ 
#line 153
  return ("DW_TAG_GNU_EINCL");
  case_16646: /* CIL Label */ 
#line 156
  return ("DW_TAG_GNU_template_template_param");
  case_16647: /* CIL Label */ 
#line 162
  return ("DW_TAG_GNU_template_parameter_pack");
  case_16648: /* CIL Label */ 
#line 163
  return ("DW_TAG_GNU_formal_parameter_pack");
  case_16649: /* CIL Label */ 
#line 168
  return ("DW_TAG_GNU_call_site");
  case_16650: /* CIL Label */ 
#line 169
  return ("DW_TAG_GNU_call_site_parameter");
  case_34661: /* CIL Label */ 
#line 171
  return ("DW_TAG_upc_shared_type");
  case_34662: /* CIL Label */ 
#line 172
  return ("DW_TAG_upc_strict_type");
  case_34663: /* CIL Label */ 
#line 173
  return ("DW_TAG_upc_relaxed_type");
  case_40960: /* CIL Label */ 
#line 175
  return ("DW_TAG_PGI_kanji_type");
  case_40992: /* CIL Label */ 
#line 176
  return ("DW_TAG_PGI_interface_block");
  switch_break: /* CIL Label */ ;
  }
#line 177
  return ((char const   *)0);
}
}
#line 179 "./../include/dwarf2.def"
char const   *get_DW_FORM_name(unsigned int form ) 
{ 


  {
  {
#line 179
  if (form == 1U) {
#line 179
    goto case_1;
  }
#line 180
  if (form == 3U) {
#line 180
    goto case_3;
  }
#line 181
  if (form == 4U) {
#line 181
    goto case_4;
  }
#line 182
  if (form == 5U) {
#line 182
    goto case_5;
  }
#line 183
  if (form == 6U) {
#line 183
    goto case_6;
  }
#line 184
  if (form == 7U) {
#line 184
    goto case_7;
  }
#line 185
  if (form == 8U) {
#line 185
    goto case_8;
  }
#line 186
  if (form == 9U) {
#line 186
    goto case_9;
  }
#line 187
  if (form == 10U) {
#line 187
    goto case_10;
  }
#line 188
  if (form == 11U) {
#line 188
    goto case_11;
  }
#line 189
  if (form == 12U) {
#line 189
    goto case_12;
  }
#line 190
  if (form == 13U) {
#line 190
    goto case_13;
  }
#line 191
  if (form == 14U) {
#line 191
    goto case_14;
  }
#line 192
  if (form == 15U) {
#line 192
    goto case_15;
  }
#line 193
  if (form == 16U) {
#line 193
    goto case_16;
  }
#line 194
  if (form == 17U) {
#line 194
    goto case_17;
  }
#line 195
  if (form == 18U) {
#line 195
    goto case_18;
  }
#line 196
  if (form == 19U) {
#line 196
    goto case_19;
  }
#line 197
  if (form == 20U) {
#line 197
    goto case_20;
  }
#line 198
  if (form == 21U) {
#line 198
    goto case_21;
  }
#line 199
  if (form == 22U) {
#line 199
    goto case_22;
  }
#line 201
  if (form == 23U) {
#line 201
    goto case_23;
  }
#line 202
  if (form == 24U) {
#line 202
    goto case_24;
  }
#line 203
  if (form == 25U) {
#line 203
    goto case_25;
  }
#line 204
  if (form == 32U) {
#line 204
    goto case_32;
  }
#line 206
  if (form == 7937U) {
#line 206
    goto case_7937;
  }
#line 207
  if (form == 7938U) {
#line 207
    goto case_7938;
  }
#line 210
  if (form == 7968U) {
#line 210
    goto case_7968;
  }
#line 211
  if (form == 7969U) {
#line 211
    goto case_7969;
  }
#line 179
  goto switch_break;
  case_1: /* CIL Label */ 
#line 179
  return ("DW_FORM_addr");
  case_3: /* CIL Label */ 
#line 180
  return ("DW_FORM_block2");
  case_4: /* CIL Label */ 
#line 181
  return ("DW_FORM_block4");
  case_5: /* CIL Label */ 
#line 182
  return ("DW_FORM_data2");
  case_6: /* CIL Label */ 
#line 183
  return ("DW_FORM_data4");
  case_7: /* CIL Label */ 
#line 184
  return ("DW_FORM_data8");
  case_8: /* CIL Label */ 
#line 185
  return ("DW_FORM_string");
  case_9: /* CIL Label */ 
#line 186
  return ("DW_FORM_block");
  case_10: /* CIL Label */ 
#line 187
  return ("DW_FORM_block1");
  case_11: /* CIL Label */ 
#line 188
  return ("DW_FORM_data1");
  case_12: /* CIL Label */ 
#line 189
  return ("DW_FORM_flag");
  case_13: /* CIL Label */ 
#line 190
  return ("DW_FORM_sdata");
  case_14: /* CIL Label */ 
#line 191
  return ("DW_FORM_strp");
  case_15: /* CIL Label */ 
#line 192
  return ("DW_FORM_udata");
  case_16: /* CIL Label */ 
#line 193
  return ("DW_FORM_ref_addr");
  case_17: /* CIL Label */ 
#line 194
  return ("DW_FORM_ref1");
  case_18: /* CIL Label */ 
#line 195
  return ("DW_FORM_ref2");
  case_19: /* CIL Label */ 
#line 196
  return ("DW_FORM_ref4");
  case_20: /* CIL Label */ 
#line 197
  return ("DW_FORM_ref8");
  case_21: /* CIL Label */ 
#line 198
  return ("DW_FORM_ref_udata");
  case_22: /* CIL Label */ 
#line 199
  return ("DW_FORM_indirect");
  case_23: /* CIL Label */ 
#line 201
  return ("DW_FORM_sec_offset");
  case_24: /* CIL Label */ 
#line 202
  return ("DW_FORM_exprloc");
  case_25: /* CIL Label */ 
#line 203
  return ("DW_FORM_flag_present");
  case_32: /* CIL Label */ 
#line 204
  return ("DW_FORM_ref_sig8");
  case_7937: /* CIL Label */ 
#line 206
  return ("DW_FORM_GNU_addr_index");
  case_7938: /* CIL Label */ 
#line 207
  return ("DW_FORM_GNU_str_index");
  case_7968: /* CIL Label */ 
#line 210
  return ("DW_FORM_GNU_ref_alt");
  case_7969: /* CIL Label */ 
#line 211
  return ("DW_FORM_GNU_strp_alt");
  switch_break: /* CIL Label */ ;
  }
#line 212
  return ((char const   *)0);
}
}
#line 214 "./../include/dwarf2.def"
char const   *get_DW_AT_name(unsigned int attr ) 
{ 


  {
  {
#line 214
  if (attr == 1U) {
#line 214
    goto case_1;
  }
#line 215
  if (attr == 2U) {
#line 215
    goto case_2;
  }
#line 216
  if (attr == 3U) {
#line 216
    goto case_3;
  }
#line 217
  if (attr == 9U) {
#line 217
    goto case_9;
  }
#line 218
  if (attr == 10U) {
#line 218
    goto case_10;
  }
#line 219
  if (attr == 11U) {
#line 219
    goto case_11;
  }
#line 220
  if (attr == 12U) {
#line 220
    goto case_12;
  }
#line 221
  if (attr == 13U) {
#line 221
    goto case_13;
  }
#line 222
  if (attr == 15U) {
#line 222
    goto case_15;
  }
#line 223
  if (attr == 16U) {
#line 223
    goto case_16;
  }
#line 224
  if (attr == 17U) {
#line 224
    goto case_17;
  }
#line 225
  if (attr == 18U) {
#line 225
    goto case_18;
  }
#line 226
  if (attr == 19U) {
#line 226
    goto case_19;
  }
#line 227
  if (attr == 20U) {
#line 227
    goto case_20;
  }
#line 228
  if (attr == 21U) {
#line 228
    goto case_21;
  }
#line 229
  if (attr == 22U) {
#line 229
    goto case_22;
  }
#line 230
  if (attr == 23U) {
#line 230
    goto case_23;
  }
#line 231
  if (attr == 24U) {
#line 231
    goto case_24;
  }
#line 232
  if (attr == 25U) {
#line 232
    goto case_25;
  }
#line 233
  if (attr == 26U) {
#line 233
    goto case_26;
  }
#line 234
  if (attr == 27U) {
#line 234
    goto case_27;
  }
#line 235
  if (attr == 28U) {
#line 235
    goto case_28;
  }
#line 236
  if (attr == 29U) {
#line 236
    goto case_29;
  }
#line 237
  if (attr == 30U) {
#line 237
    goto case_30;
  }
#line 238
  if (attr == 32U) {
#line 238
    goto case_32;
  }
#line 239
  if (attr == 33U) {
#line 239
    goto case_33;
  }
#line 240
  if (attr == 34U) {
#line 240
    goto case_34;
  }
#line 241
  if (attr == 37U) {
#line 241
    goto case_37;
  }
#line 242
  if (attr == 39U) {
#line 242
    goto case_39;
  }
#line 243
  if (attr == 42U) {
#line 243
    goto case_42;
  }
#line 244
  if (attr == 44U) {
#line 244
    goto case_44;
  }
#line 245
  if (attr == 46U) {
#line 245
    goto case_46;
  }
#line 246
  if (attr == 47U) {
#line 246
    goto case_47;
  }
#line 247
  if (attr == 49U) {
#line 247
    goto case_49;
  }
#line 248
  if (attr == 50U) {
#line 248
    goto case_50;
  }
#line 249
  if (attr == 51U) {
#line 249
    goto case_51;
  }
#line 250
  if (attr == 52U) {
#line 250
    goto case_52;
  }
#line 251
  if (attr == 53U) {
#line 251
    goto case_53;
  }
#line 252
  if (attr == 54U) {
#line 252
    goto case_54;
  }
#line 253
  if (attr == 55U) {
#line 253
    goto case_55;
  }
#line 254
  if (attr == 56U) {
#line 254
    goto case_56;
  }
#line 255
  if (attr == 57U) {
#line 255
    goto case_57;
  }
#line 256
  if (attr == 58U) {
#line 256
    goto case_58;
  }
#line 257
  if (attr == 59U) {
#line 257
    goto case_59;
  }
#line 258
  if (attr == 60U) {
#line 258
    goto case_60;
  }
#line 259
  if (attr == 61U) {
#line 259
    goto case_61;
  }
#line 260
  if (attr == 62U) {
#line 260
    goto case_62;
  }
#line 261
  if (attr == 63U) {
#line 261
    goto case_63;
  }
#line 262
  if (attr == 64U) {
#line 262
    goto case_64;
  }
#line 263
  if (attr == 65U) {
#line 263
    goto case_65;
  }
#line 264
  if (attr == 66U) {
#line 264
    goto case_66;
  }
#line 265
  if (attr == 67U) {
#line 265
    goto case_67;
  }
#line 266
  if (attr == 68U) {
#line 266
    goto case_68;
  }
#line 267
  if (attr == 69U) {
#line 267
    goto case_69;
  }
#line 268
  if (attr == 70U) {
#line 268
    goto case_70;
  }
#line 269
  if (attr == 71U) {
#line 269
    goto case_71;
  }
#line 270
  if (attr == 72U) {
#line 270
    goto case_72;
  }
#line 271
  if (attr == 73U) {
#line 271
    goto case_73;
  }
#line 272
  if (attr == 74U) {
#line 272
    goto case_74;
  }
#line 273
  if (attr == 75U) {
#line 273
    goto case_75;
  }
#line 274
  if (attr == 76U) {
#line 274
    goto case_76;
  }
#line 275
  if (attr == 77U) {
#line 275
    goto case_77;
  }
#line 277
  if (attr == 78U) {
#line 277
    goto case_78;
  }
#line 278
  if (attr == 79U) {
#line 278
    goto case_79;
  }
#line 279
  if (attr == 80U) {
#line 279
    goto case_80;
  }
#line 280
  if (attr == 81U) {
#line 280
    goto case_81;
  }
#line 281
  if (attr == 82U) {
#line 281
    goto case_82;
  }
#line 282
  if (attr == 83U) {
#line 282
    goto case_83;
  }
#line 283
  if (attr == 84U) {
#line 283
    goto case_84;
  }
#line 284
  if (attr == 85U) {
#line 284
    goto case_85;
  }
#line 285
  if (attr == 86U) {
#line 285
    goto case_86;
  }
#line 286
  if (attr == 87U) {
#line 286
    goto case_87;
  }
#line 287
  if (attr == 88U) {
#line 287
    goto case_88;
  }
#line 288
  if (attr == 89U) {
#line 288
    goto case_89;
  }
#line 289
  if (attr == 90U) {
#line 289
    goto case_90;
  }
#line 290
  if (attr == 91U) {
#line 290
    goto case_91;
  }
#line 291
  if (attr == 92U) {
#line 291
    goto case_92;
  }
#line 292
  if (attr == 93U) {
#line 292
    goto case_93;
  }
#line 293
  if (attr == 94U) {
#line 293
    goto case_94;
  }
#line 294
  if (attr == 95U) {
#line 294
    goto case_95;
  }
#line 295
  if (attr == 96U) {
#line 295
    goto case_96;
  }
#line 296
  if (attr == 97U) {
#line 296
    goto case_97;
  }
#line 297
  if (attr == 98U) {
#line 297
    goto case_98;
  }
#line 298
  if (attr == 99U) {
#line 298
    goto case_99;
  }
#line 299
  if (attr == 100U) {
#line 299
    goto case_100;
  }
#line 300
  if (attr == 101U) {
#line 300
    goto case_101;
  }
#line 301
  if (attr == 102U) {
#line 301
    goto case_102;
  }
#line 302
  if (attr == 103U) {
#line 302
    goto case_103;
  }
#line 303
  if (attr == 104U) {
#line 303
    goto case_104;
  }
#line 305
  if (attr == 105U) {
#line 305
    goto case_105;
  }
#line 306
  if (attr == 106U) {
#line 306
    goto case_106;
  }
#line 307
  if (attr == 107U) {
#line 307
    goto case_107;
  }
#line 308
  if (attr == 108U) {
#line 308
    goto case_108;
  }
#line 309
  if (attr == 109U) {
#line 309
    goto case_109;
  }
#line 310
  if (attr == 110U) {
#line 310
    goto case_110;
  }
#line 316
  if (attr == 8193U) {
#line 316
    goto case_8193;
  }
#line 317
  if (attr == 8194U) {
#line 317
    goto case_8194;
  }
#line 318
  if (attr == 8195U) {
#line 318
    goto case_8195;
  }
#line 319
  if (attr == 8196U) {
#line 319
    goto case_8196;
  }
#line 320
  if (attr == 8197U) {
#line 320
    goto case_8197;
  }
#line 321
  if (attr == 8198U) {
#line 321
    goto case_8198;
  }
#line 322
  if (attr == 8199U) {
#line 322
    goto case_8199;
  }
#line 323
  if (attr == 8200U) {
#line 323
    goto case_8200;
  }
#line 324
  if (attr == 8201U) {
#line 324
    goto case_8201;
  }
#line 325
  if (attr == 8202U) {
#line 325
    goto case_8202;
  }
#line 326
  if (attr == 8203U) {
#line 326
    goto case_8203;
  }
#line 328
  if (attr == 8192U) {
#line 328
    goto case_8192;
  }
#line 332
  if (attr == 8208U) {
#line 332
    goto case_8208;
  }
#line 333
  if (attr == 8209U) {
#line 333
    goto case_8209;
  }
#line 334
  if (attr == 8210U) {
#line 334
    goto case_8210;
  }
#line 335
  if (attr == 8211U) {
#line 335
    goto case_8211;
  }
#line 336
  if (attr == 8212U) {
#line 336
    goto case_8212;
  }
#line 337
  if (attr == 8213U) {
#line 337
    goto case_8213;
  }
#line 338
  if (attr == 8214U) {
#line 338
    goto case_8214;
  }
#line 339
  if (attr == 8215U) {
#line 339
    goto case_8215;
  }
#line 340
  if (attr == 8216U) {
#line 340
    goto case_8216;
  }
#line 341
  if (attr == 8217U) {
#line 341
    goto case_8217;
  }
#line 342
  if (attr == 8218U) {
#line 342
    goto case_8218;
  }
#line 343
  if (attr == 8219U) {
#line 343
    goto case_8219;
  }
#line 344
  if (attr == 8223U) {
#line 344
    goto case_8223;
  }
#line 345
  if (attr == 8224U) {
#line 345
    goto case_8224;
  }
#line 346
  if (attr == 8225U) {
#line 346
    goto case_8225;
  }
#line 347
  if (attr == 8226U) {
#line 347
    goto case_8226;
  }
#line 348
  if (attr == 8227U) {
#line 348
    goto case_8227;
  }
#line 349
  if (attr == 8233U) {
#line 349
    goto case_8233;
  }
#line 352
  if (attr == 8449U) {
#line 352
    goto case_8449;
  }
#line 353
  if (attr == 8450U) {
#line 353
    goto case_8450;
  }
#line 354
  if (attr == 8451U) {
#line 354
    goto case_8451;
  }
#line 355
  if (attr == 8452U) {
#line 355
    goto case_8452;
  }
#line 356
  if (attr == 8453U) {
#line 356
    goto case_8453;
  }
#line 357
  if (attr == 8454U) {
#line 357
    goto case_8454;
  }
#line 358
  if (attr == 8455U) {
#line 358
    goto case_8455;
  }
#line 361
  if (attr == 8456U) {
#line 361
    goto case_8456;
  }
#line 362
  if (attr == 8457U) {
#line 362
    goto case_8457;
  }
#line 363
  if (attr == 8458U) {
#line 363
    goto case_8458;
  }
#line 364
  if (attr == 8459U) {
#line 364
    goto case_8459;
  }
#line 365
  if (attr == 8460U) {
#line 365
    goto case_8460;
  }
#line 366
  if (attr == 8461U) {
#line 366
    goto case_8461;
  }
#line 367
  if (attr == 8462U) {
#line 367
    goto case_8462;
  }
#line 370
  if (attr == 8463U) {
#line 370
    goto case_8463;
  }
#line 373
  if (attr == 8464U) {
#line 373
    goto case_8464;
  }
#line 376
  if (attr == 8465U) {
#line 376
    goto case_8465;
  }
#line 377
  if (attr == 8466U) {
#line 377
    goto case_8466;
  }
#line 378
  if (attr == 8467U) {
#line 378
    goto case_8467;
  }
#line 379
  if (attr == 8468U) {
#line 379
    goto case_8468;
  }
#line 380
  if (attr == 8469U) {
#line 380
    goto case_8469;
  }
#line 381
  if (attr == 8470U) {
#line 381
    goto case_8470;
  }
#line 382
  if (attr == 8471U) {
#line 382
    goto case_8471;
  }
#line 383
  if (attr == 8472U) {
#line 383
    goto case_8472;
  }
#line 385
  if (attr == 8473U) {
#line 385
    goto case_8473;
  }
#line 387
  if (attr == 8496U) {
#line 387
    goto case_8496;
  }
#line 388
  if (attr == 8497U) {
#line 388
    goto case_8497;
  }
#line 389
  if (attr == 8498U) {
#line 389
    goto case_8498;
  }
#line 390
  if (attr == 8499U) {
#line 390
    goto case_8499;
  }
#line 391
  if (attr == 8500U) {
#line 391
    goto case_8500;
  }
#line 392
  if (attr == 8501U) {
#line 392
    goto case_8501;
  }
#line 394
  if (attr == 8705U) {
#line 394
    goto case_8705;
  }
#line 398
  if (attr == 8961U) {
#line 398
    goto case_8961;
  }
#line 399
  if (attr == 8962U) {
#line 399
    goto case_8962;
  }
#line 401
  if (attr == 12816U) {
#line 401
    goto case_12816;
  }
#line 403
  if (attr == 14848U) {
#line 403
    goto case_14848;
  }
#line 404
  if (attr == 14849U) {
#line 404
    goto case_14849;
  }
#line 405
  if (attr == 14850U) {
#line 405
    goto case_14850;
  }
#line 214
  goto switch_break;
  case_1: /* CIL Label */ 
#line 214
  return ("DW_AT_sibling");
  case_2: /* CIL Label */ 
#line 215
  return ("DW_AT_location");
  case_3: /* CIL Label */ 
#line 216
  return ("DW_AT_name");
  case_9: /* CIL Label */ 
#line 217
  return ("DW_AT_ordering");
  case_10: /* CIL Label */ 
#line 218
  return ("DW_AT_subscr_data");
  case_11: /* CIL Label */ 
#line 219
  return ("DW_AT_byte_size");
  case_12: /* CIL Label */ 
#line 220
  return ("DW_AT_bit_offset");
  case_13: /* CIL Label */ 
#line 221
  return ("DW_AT_bit_size");
  case_15: /* CIL Label */ 
#line 222
  return ("DW_AT_element_list");
  case_16: /* CIL Label */ 
#line 223
  return ("DW_AT_stmt_list");
  case_17: /* CIL Label */ 
#line 224
  return ("DW_AT_low_pc");
  case_18: /* CIL Label */ 
#line 225
  return ("DW_AT_high_pc");
  case_19: /* CIL Label */ 
#line 226
  return ("DW_AT_language");
  case_20: /* CIL Label */ 
#line 227
  return ("DW_AT_member");
  case_21: /* CIL Label */ 
#line 228
  return ("DW_AT_discr");
  case_22: /* CIL Label */ 
#line 229
  return ("DW_AT_discr_value");
  case_23: /* CIL Label */ 
#line 230
  return ("DW_AT_visibility");
  case_24: /* CIL Label */ 
#line 231
  return ("DW_AT_import");
  case_25: /* CIL Label */ 
#line 232
  return ("DW_AT_string_length");
  case_26: /* CIL Label */ 
#line 233
  return ("DW_AT_common_reference");
  case_27: /* CIL Label */ 
#line 234
  return ("DW_AT_comp_dir");
  case_28: /* CIL Label */ 
#line 235
  return ("DW_AT_const_value");
  case_29: /* CIL Label */ 
#line 236
  return ("DW_AT_containing_type");
  case_30: /* CIL Label */ 
#line 237
  return ("DW_AT_default_value");
  case_32: /* CIL Label */ 
#line 238
  return ("DW_AT_inline");
  case_33: /* CIL Label */ 
#line 239
  return ("DW_AT_is_optional");
  case_34: /* CIL Label */ 
#line 240
  return ("DW_AT_lower_bound");
  case_37: /* CIL Label */ 
#line 241
  return ("DW_AT_producer");
  case_39: /* CIL Label */ 
#line 242
  return ("DW_AT_prototyped");
  case_42: /* CIL Label */ 
#line 243
  return ("DW_AT_return_addr");
  case_44: /* CIL Label */ 
#line 244
  return ("DW_AT_start_scope");
  case_46: /* CIL Label */ 
#line 245
  return ("DW_AT_bit_stride");
  case_47: /* CIL Label */ 
#line 246
  return ("DW_AT_upper_bound");
  case_49: /* CIL Label */ 
#line 247
  return ("DW_AT_abstract_origin");
  case_50: /* CIL Label */ 
#line 248
  return ("DW_AT_accessibility");
  case_51: /* CIL Label */ 
#line 249
  return ("DW_AT_address_class");
  case_52: /* CIL Label */ 
#line 250
  return ("DW_AT_artificial");
  case_53: /* CIL Label */ 
#line 251
  return ("DW_AT_base_types");
  case_54: /* CIL Label */ 
#line 252
  return ("DW_AT_calling_convention");
  case_55: /* CIL Label */ 
#line 253
  return ("DW_AT_count");
  case_56: /* CIL Label */ 
#line 254
  return ("DW_AT_data_member_location");
  case_57: /* CIL Label */ 
#line 255
  return ("DW_AT_decl_column");
  case_58: /* CIL Label */ 
#line 256
  return ("DW_AT_decl_file");
  case_59: /* CIL Label */ 
#line 257
  return ("DW_AT_decl_line");
  case_60: /* CIL Label */ 
#line 258
  return ("DW_AT_declaration");
  case_61: /* CIL Label */ 
#line 259
  return ("DW_AT_discr_list");
  case_62: /* CIL Label */ 
#line 260
  return ("DW_AT_encoding");
  case_63: /* CIL Label */ 
#line 261
  return ("DW_AT_external");
  case_64: /* CIL Label */ 
#line 262
  return ("DW_AT_frame_base");
  case_65: /* CIL Label */ 
#line 263
  return ("DW_AT_friend");
  case_66: /* CIL Label */ 
#line 264
  return ("DW_AT_identifier_case");
  case_67: /* CIL Label */ 
#line 265
  return ("DW_AT_macro_info");
  case_68: /* CIL Label */ 
#line 266
  return ("DW_AT_namelist_items");
  case_69: /* CIL Label */ 
#line 267
  return ("DW_AT_priority");
  case_70: /* CIL Label */ 
#line 268
  return ("DW_AT_segment");
  case_71: /* CIL Label */ 
#line 269
  return ("DW_AT_specification");
  case_72: /* CIL Label */ 
#line 270
  return ("DW_AT_static_link");
  case_73: /* CIL Label */ 
#line 271
  return ("DW_AT_type");
  case_74: /* CIL Label */ 
#line 272
  return ("DW_AT_use_location");
  case_75: /* CIL Label */ 
#line 273
  return ("DW_AT_variable_parameter");
  case_76: /* CIL Label */ 
#line 274
  return ("DW_AT_virtuality");
  case_77: /* CIL Label */ 
#line 275
  return ("DW_AT_vtable_elem_location");
  case_78: /* CIL Label */ 
#line 277
  return ("DW_AT_allocated");
  case_79: /* CIL Label */ 
#line 278
  return ("DW_AT_associated");
  case_80: /* CIL Label */ 
#line 279
  return ("DW_AT_data_location");
  case_81: /* CIL Label */ 
#line 280
  return ("DW_AT_byte_stride");
  case_82: /* CIL Label */ 
#line 281
  return ("DW_AT_entry_pc");
  case_83: /* CIL Label */ 
#line 282
  return ("DW_AT_use_UTF8");
  case_84: /* CIL Label */ 
#line 283
  return ("DW_AT_extension");
  case_85: /* CIL Label */ 
#line 284
  return ("DW_AT_ranges");
  case_86: /* CIL Label */ 
#line 285
  return ("DW_AT_trampoline");
  case_87: /* CIL Label */ 
#line 286
  return ("DW_AT_call_column");
  case_88: /* CIL Label */ 
#line 287
  return ("DW_AT_call_file");
  case_89: /* CIL Label */ 
#line 288
  return ("DW_AT_call_line");
  case_90: /* CIL Label */ 
#line 289
  return ("DW_AT_description");
  case_91: /* CIL Label */ 
#line 290
  return ("DW_AT_binary_scale");
  case_92: /* CIL Label */ 
#line 291
  return ("DW_AT_decimal_scale");
  case_93: /* CIL Label */ 
#line 292
  return ("DW_AT_small");
  case_94: /* CIL Label */ 
#line 293
  return ("DW_AT_decimal_sign");
  case_95: /* CIL Label */ 
#line 294
  return ("DW_AT_digit_count");
  case_96: /* CIL Label */ 
#line 295
  return ("DW_AT_picture_string");
  case_97: /* CIL Label */ 
#line 296
  return ("DW_AT_mutable");
  case_98: /* CIL Label */ 
#line 297
  return ("DW_AT_threads_scaled");
  case_99: /* CIL Label */ 
#line 298
  return ("DW_AT_explicit");
  case_100: /* CIL Label */ 
#line 299
  return ("DW_AT_object_pointer");
  case_101: /* CIL Label */ 
#line 300
  return ("DW_AT_endianity");
  case_102: /* CIL Label */ 
#line 301
  return ("DW_AT_elemental");
  case_103: /* CIL Label */ 
#line 302
  return ("DW_AT_pure");
  case_104: /* CIL Label */ 
#line 303
  return ("DW_AT_recursive");
  case_105: /* CIL Label */ 
#line 305
  return ("DW_AT_signature");
  case_106: /* CIL Label */ 
#line 306
  return ("DW_AT_main_subprogram");
  case_107: /* CIL Label */ 
#line 307
  return ("DW_AT_data_bit_offset");
  case_108: /* CIL Label */ 
#line 308
  return ("DW_AT_const_expr");
  case_109: /* CIL Label */ 
#line 309
  return ("DW_AT_enum_class");
  case_110: /* CIL Label */ 
#line 310
  return ("DW_AT_linkage_name");
  case_8193: /* CIL Label */ 
#line 316
  return ("DW_AT_MIPS_fde");
  case_8194: /* CIL Label */ 
#line 317
  return ("DW_AT_MIPS_loop_begin");
  case_8195: /* CIL Label */ 
#line 318
  return ("DW_AT_MIPS_tail_loop_begin");
  case_8196: /* CIL Label */ 
#line 319
  return ("DW_AT_MIPS_epilog_begin");
  case_8197: /* CIL Label */ 
#line 320
  return ("DW_AT_MIPS_loop_unroll_factor");
  case_8198: /* CIL Label */ 
#line 321
  return ("DW_AT_MIPS_software_pipeline_depth");
  case_8199: /* CIL Label */ 
#line 322
  return ("DW_AT_MIPS_linkage_name");
  case_8200: /* CIL Label */ 
#line 323
  return ("DW_AT_MIPS_stride");
  case_8201: /* CIL Label */ 
#line 324
  return ("DW_AT_MIPS_abstract_name");
  case_8202: /* CIL Label */ 
#line 325
  return ("DW_AT_MIPS_clone_origin");
  case_8203: /* CIL Label */ 
#line 326
  return ("DW_AT_MIPS_has_inlines");
  case_8192: /* CIL Label */ 
#line 328
  return ("DW_AT_HP_block_index");
  case_8208: /* CIL Label */ 
#line 332
  return ("DW_AT_HP_actuals_stmt_list");
  case_8209: /* CIL Label */ 
#line 333
  return ("DW_AT_HP_proc_per_section");
  case_8210: /* CIL Label */ 
#line 334
  return ("DW_AT_HP_raw_data_ptr");
  case_8211: /* CIL Label */ 
#line 335
  return ("DW_AT_HP_pass_by_reference");
  case_8212: /* CIL Label */ 
#line 336
  return ("DW_AT_HP_opt_level");
  case_8213: /* CIL Label */ 
#line 337
  return ("DW_AT_HP_prof_version_id");
  case_8214: /* CIL Label */ 
#line 338
  return ("DW_AT_HP_opt_flags");
  case_8215: /* CIL Label */ 
#line 339
  return ("DW_AT_HP_cold_region_low_pc");
  case_8216: /* CIL Label */ 
#line 340
  return ("DW_AT_HP_cold_region_high_pc");
  case_8217: /* CIL Label */ 
#line 341
  return ("DW_AT_HP_all_variables_modifiable");
  case_8218: /* CIL Label */ 
#line 342
  return ("DW_AT_HP_linkage_name");
  case_8219: /* CIL Label */ 
#line 343
  return ("DW_AT_HP_prof_flags");
  case_8223: /* CIL Label */ 
#line 344
  return ("DW_AT_HP_unit_name");
  case_8224: /* CIL Label */ 
#line 345
  return ("DW_AT_HP_unit_size");
  case_8225: /* CIL Label */ 
#line 346
  return ("DW_AT_HP_widened_byte_size");
  case_8226: /* CIL Label */ 
#line 347
  return ("DW_AT_HP_definition_points");
  case_8227: /* CIL Label */ 
#line 348
  return ("DW_AT_HP_default_location");
  case_8233: /* CIL Label */ 
#line 349
  return ("DW_AT_HP_is_result_param");
  case_8449: /* CIL Label */ 
#line 352
  return ("DW_AT_sf_names");
  case_8450: /* CIL Label */ 
#line 353
  return ("DW_AT_src_info");
  case_8451: /* CIL Label */ 
#line 354
  return ("DW_AT_mac_info");
  case_8452: /* CIL Label */ 
#line 355
  return ("DW_AT_src_coords");
  case_8453: /* CIL Label */ 
#line 356
  return ("DW_AT_body_begin");
  case_8454: /* CIL Label */ 
#line 357
  return ("DW_AT_body_end");
  case_8455: /* CIL Label */ 
#line 358
  return ("DW_AT_GNU_vector");
  case_8456: /* CIL Label */ 
#line 361
  return ("DW_AT_GNU_guarded_by");
  case_8457: /* CIL Label */ 
#line 362
  return ("DW_AT_GNU_pt_guarded_by");
  case_8458: /* CIL Label */ 
#line 363
  return ("DW_AT_GNU_guarded");
  case_8459: /* CIL Label */ 
#line 364
  return ("DW_AT_GNU_pt_guarded");
  case_8460: /* CIL Label */ 
#line 365
  return ("DW_AT_GNU_locks_excluded");
  case_8461: /* CIL Label */ 
#line 366
  return ("DW_AT_GNU_exclusive_locks_required");
  case_8462: /* CIL Label */ 
#line 367
  return ("DW_AT_GNU_shared_locks_required");
  case_8463: /* CIL Label */ 
#line 370
  return ("DW_AT_GNU_odr_signature");
  case_8464: /* CIL Label */ 
#line 373
  return ("DW_AT_GNU_template_name");
  case_8465: /* CIL Label */ 
#line 376
  return ("DW_AT_GNU_call_site_value");
  case_8466: /* CIL Label */ 
#line 377
  return ("DW_AT_GNU_call_site_data_value");
  case_8467: /* CIL Label */ 
#line 378
  return ("DW_AT_GNU_call_site_target");
  case_8468: /* CIL Label */ 
#line 379
  return ("DW_AT_GNU_call_site_target_clobbered");
  case_8469: /* CIL Label */ 
#line 380
  return ("DW_AT_GNU_tail_call");
  case_8470: /* CIL Label */ 
#line 381
  return ("DW_AT_GNU_all_tail_call_sites");
  case_8471: /* CIL Label */ 
#line 382
  return ("DW_AT_GNU_all_call_sites");
  case_8472: /* CIL Label */ 
#line 383
  return ("DW_AT_GNU_all_source_call_sites");
  case_8473: /* CIL Label */ 
#line 385
  return ("DW_AT_GNU_macros");
  case_8496: /* CIL Label */ 
#line 387
  return ("DW_AT_GNU_dwo_name");
  case_8497: /* CIL Label */ 
#line 388
  return ("DW_AT_GNU_dwo_id");
  case_8498: /* CIL Label */ 
#line 389
  return ("DW_AT_GNU_ranges_base");
  case_8499: /* CIL Label */ 
#line 390
  return ("DW_AT_GNU_addr_base");
  case_8500: /* CIL Label */ 
#line 391
  return ("DW_AT_GNU_pubnames");
  case_8501: /* CIL Label */ 
#line 392
  return ("DW_AT_GNU_pubtypes");
  case_8705: /* CIL Label */ 
#line 394
  return ("DW_AT_VMS_rtnbeg_pd_address");
  case_8961: /* CIL Label */ 
#line 398
  return ("DW_AT_use_GNAT_descriptive_type");
  case_8962: /* CIL Label */ 
#line 399
  return ("DW_AT_GNAT_descriptive_type");
  case_12816: /* CIL Label */ 
#line 401
  return ("DW_AT_upc_threads_scaled");
  case_14848: /* CIL Label */ 
#line 403
  return ("DW_AT_PGI_lbase");
  case_14849: /* CIL Label */ 
#line 404
  return ("DW_AT_PGI_soffset");
  case_14850: /* CIL Label */ 
#line 405
  return ("DW_AT_PGI_lstride");
  switch_break: /* CIL Label */ ;
  }
#line 406
  return ((char const   *)0);
}
}
#line 408 "./../include/dwarf2.def"
char const   *get_DW_OP_name(unsigned int op ) 
{ 


  {
  {
#line 408
  if (op == 3U) {
#line 408
    goto case_3;
  }
#line 409
  if (op == 6U) {
#line 409
    goto case_6;
  }
#line 410
  if (op == 8U) {
#line 410
    goto case_8;
  }
#line 411
  if (op == 9U) {
#line 411
    goto case_9;
  }
#line 412
  if (op == 10U) {
#line 412
    goto case_10;
  }
#line 413
  if (op == 11U) {
#line 413
    goto case_11;
  }
#line 414
  if (op == 12U) {
#line 414
    goto case_12;
  }
#line 415
  if (op == 13U) {
#line 415
    goto case_13;
  }
#line 416
  if (op == 14U) {
#line 416
    goto case_14;
  }
#line 417
  if (op == 15U) {
#line 417
    goto case_15;
  }
#line 418
  if (op == 16U) {
#line 418
    goto case_16;
  }
#line 419
  if (op == 17U) {
#line 419
    goto case_17;
  }
#line 420
  if (op == 18U) {
#line 420
    goto case_18;
  }
#line 421
  if (op == 19U) {
#line 421
    goto case_19;
  }
#line 422
  if (op == 20U) {
#line 422
    goto case_20;
  }
#line 423
  if (op == 21U) {
#line 423
    goto case_21;
  }
#line 424
  if (op == 22U) {
#line 424
    goto case_22;
  }
#line 425
  if (op == 23U) {
#line 425
    goto case_23;
  }
#line 426
  if (op == 24U) {
#line 426
    goto case_24;
  }
#line 427
  if (op == 25U) {
#line 427
    goto case_25;
  }
#line 428
  if (op == 26U) {
#line 428
    goto case_26;
  }
#line 429
  if (op == 27U) {
#line 429
    goto case_27;
  }
#line 430
  if (op == 28U) {
#line 430
    goto case_28;
  }
#line 431
  if (op == 29U) {
#line 431
    goto case_29;
  }
#line 432
  if (op == 30U) {
#line 432
    goto case_30;
  }
#line 433
  if (op == 31U) {
#line 433
    goto case_31;
  }
#line 434
  if (op == 32U) {
#line 434
    goto case_32;
  }
#line 435
  if (op == 33U) {
#line 435
    goto case_33;
  }
#line 436
  if (op == 34U) {
#line 436
    goto case_34;
  }
#line 437
  if (op == 35U) {
#line 437
    goto case_35;
  }
#line 438
  if (op == 36U) {
#line 438
    goto case_36;
  }
#line 439
  if (op == 37U) {
#line 439
    goto case_37;
  }
#line 440
  if (op == 38U) {
#line 440
    goto case_38;
  }
#line 441
  if (op == 39U) {
#line 441
    goto case_39;
  }
#line 442
  if (op == 40U) {
#line 442
    goto case_40;
  }
#line 443
  if (op == 41U) {
#line 443
    goto case_41;
  }
#line 444
  if (op == 42U) {
#line 444
    goto case_42;
  }
#line 445
  if (op == 43U) {
#line 445
    goto case_43;
  }
#line 446
  if (op == 44U) {
#line 446
    goto case_44;
  }
#line 447
  if (op == 45U) {
#line 447
    goto case_45;
  }
#line 448
  if (op == 46U) {
#line 448
    goto case_46;
  }
#line 449
  if (op == 47U) {
#line 449
    goto case_47;
  }
#line 450
  if (op == 48U) {
#line 450
    goto case_48;
  }
#line 451
  if (op == 49U) {
#line 451
    goto case_49;
  }
#line 452
  if (op == 50U) {
#line 452
    goto case_50;
  }
#line 453
  if (op == 51U) {
#line 453
    goto case_51;
  }
#line 454
  if (op == 52U) {
#line 454
    goto case_52;
  }
#line 455
  if (op == 53U) {
#line 455
    goto case_53;
  }
#line 456
  if (op == 54U) {
#line 456
    goto case_54;
  }
#line 457
  if (op == 55U) {
#line 457
    goto case_55;
  }
#line 458
  if (op == 56U) {
#line 458
    goto case_56;
  }
#line 459
  if (op == 57U) {
#line 459
    goto case_57;
  }
#line 460
  if (op == 58U) {
#line 460
    goto case_58;
  }
#line 461
  if (op == 59U) {
#line 461
    goto case_59;
  }
#line 462
  if (op == 60U) {
#line 462
    goto case_60;
  }
#line 463
  if (op == 61U) {
#line 463
    goto case_61;
  }
#line 464
  if (op == 62U) {
#line 464
    goto case_62;
  }
#line 465
  if (op == 63U) {
#line 465
    goto case_63;
  }
#line 466
  if (op == 64U) {
#line 466
    goto case_64;
  }
#line 467
  if (op == 65U) {
#line 467
    goto case_65;
  }
#line 468
  if (op == 66U) {
#line 468
    goto case_66;
  }
#line 469
  if (op == 67U) {
#line 469
    goto case_67;
  }
#line 470
  if (op == 68U) {
#line 470
    goto case_68;
  }
#line 471
  if (op == 69U) {
#line 471
    goto case_69;
  }
#line 472
  if (op == 70U) {
#line 472
    goto case_70;
  }
#line 473
  if (op == 71U) {
#line 473
    goto case_71;
  }
#line 474
  if (op == 72U) {
#line 474
    goto case_72;
  }
#line 475
  if (op == 73U) {
#line 475
    goto case_73;
  }
#line 476
  if (op == 74U) {
#line 476
    goto case_74;
  }
#line 477
  if (op == 75U) {
#line 477
    goto case_75;
  }
#line 478
  if (op == 76U) {
#line 478
    goto case_76;
  }
#line 479
  if (op == 77U) {
#line 479
    goto case_77;
  }
#line 480
  if (op == 78U) {
#line 480
    goto case_78;
  }
#line 481
  if (op == 79U) {
#line 481
    goto case_79;
  }
#line 482
  if (op == 80U) {
#line 482
    goto case_80;
  }
#line 483
  if (op == 81U) {
#line 483
    goto case_81;
  }
#line 484
  if (op == 82U) {
#line 484
    goto case_82;
  }
#line 485
  if (op == 83U) {
#line 485
    goto case_83;
  }
#line 486
  if (op == 84U) {
#line 486
    goto case_84;
  }
#line 487
  if (op == 85U) {
#line 487
    goto case_85;
  }
#line 488
  if (op == 86U) {
#line 488
    goto case_86;
  }
#line 489
  if (op == 87U) {
#line 489
    goto case_87;
  }
#line 490
  if (op == 88U) {
#line 490
    goto case_88;
  }
#line 491
  if (op == 89U) {
#line 491
    goto case_89;
  }
#line 492
  if (op == 90U) {
#line 492
    goto case_90;
  }
#line 493
  if (op == 91U) {
#line 493
    goto case_91;
  }
#line 494
  if (op == 92U) {
#line 494
    goto case_92;
  }
#line 495
  if (op == 93U) {
#line 495
    goto case_93;
  }
#line 496
  if (op == 94U) {
#line 496
    goto case_94;
  }
#line 497
  if (op == 95U) {
#line 497
    goto case_95;
  }
#line 498
  if (op == 96U) {
#line 498
    goto case_96;
  }
#line 499
  if (op == 97U) {
#line 499
    goto case_97;
  }
#line 500
  if (op == 98U) {
#line 500
    goto case_98;
  }
#line 501
  if (op == 99U) {
#line 501
    goto case_99;
  }
#line 502
  if (op == 100U) {
#line 502
    goto case_100;
  }
#line 503
  if (op == 101U) {
#line 503
    goto case_101;
  }
#line 504
  if (op == 102U) {
#line 504
    goto case_102;
  }
#line 505
  if (op == 103U) {
#line 505
    goto case_103;
  }
#line 506
  if (op == 104U) {
#line 506
    goto case_104;
  }
#line 507
  if (op == 105U) {
#line 507
    goto case_105;
  }
#line 508
  if (op == 106U) {
#line 508
    goto case_106;
  }
#line 509
  if (op == 107U) {
#line 509
    goto case_107;
  }
#line 510
  if (op == 108U) {
#line 510
    goto case_108;
  }
#line 511
  if (op == 109U) {
#line 511
    goto case_109;
  }
#line 512
  if (op == 110U) {
#line 512
    goto case_110;
  }
#line 513
  if (op == 111U) {
#line 513
    goto case_111;
  }
#line 514
  if (op == 112U) {
#line 514
    goto case_112;
  }
#line 515
  if (op == 113U) {
#line 515
    goto case_113;
  }
#line 516
  if (op == 114U) {
#line 516
    goto case_114;
  }
#line 517
  if (op == 115U) {
#line 517
    goto case_115;
  }
#line 518
  if (op == 116U) {
#line 518
    goto case_116;
  }
#line 519
  if (op == 117U) {
#line 519
    goto case_117;
  }
#line 520
  if (op == 118U) {
#line 520
    goto case_118;
  }
#line 521
  if (op == 119U) {
#line 521
    goto case_119;
  }
#line 522
  if (op == 120U) {
#line 522
    goto case_120;
  }
#line 523
  if (op == 121U) {
#line 523
    goto case_121;
  }
#line 524
  if (op == 122U) {
#line 524
    goto case_122;
  }
#line 525
  if (op == 123U) {
#line 525
    goto case_123;
  }
#line 526
  if (op == 124U) {
#line 526
    goto case_124;
  }
#line 527
  if (op == 125U) {
#line 527
    goto case_125;
  }
#line 528
  if (op == 126U) {
#line 528
    goto case_126;
  }
#line 529
  if (op == 127U) {
#line 529
    goto case_127;
  }
#line 530
  if (op == 128U) {
#line 530
    goto case_128;
  }
#line 531
  if (op == 129U) {
#line 531
    goto case_129;
  }
#line 532
  if (op == 130U) {
#line 532
    goto case_130;
  }
#line 533
  if (op == 131U) {
#line 533
    goto case_131;
  }
#line 534
  if (op == 132U) {
#line 534
    goto case_132;
  }
#line 535
  if (op == 133U) {
#line 535
    goto case_133;
  }
#line 536
  if (op == 134U) {
#line 536
    goto case_134;
  }
#line 537
  if (op == 135U) {
#line 537
    goto case_135;
  }
#line 538
  if (op == 136U) {
#line 538
    goto case_136;
  }
#line 539
  if (op == 137U) {
#line 539
    goto case_137;
  }
#line 540
  if (op == 138U) {
#line 540
    goto case_138;
  }
#line 541
  if (op == 139U) {
#line 541
    goto case_139;
  }
#line 542
  if (op == 140U) {
#line 542
    goto case_140;
  }
#line 543
  if (op == 141U) {
#line 543
    goto case_141;
  }
#line 544
  if (op == 142U) {
#line 544
    goto case_142;
  }
#line 545
  if (op == 143U) {
#line 545
    goto case_143;
  }
#line 546
  if (op == 144U) {
#line 546
    goto case_144;
  }
#line 547
  if (op == 145U) {
#line 547
    goto case_145;
  }
#line 548
  if (op == 146U) {
#line 548
    goto case_146;
  }
#line 549
  if (op == 147U) {
#line 549
    goto case_147;
  }
#line 550
  if (op == 148U) {
#line 550
    goto case_148;
  }
#line 551
  if (op == 149U) {
#line 551
    goto case_149;
  }
#line 552
  if (op == 150U) {
#line 552
    goto case_150;
  }
#line 554
  if (op == 151U) {
#line 554
    goto case_151;
  }
#line 555
  if (op == 152U) {
#line 555
    goto case_152;
  }
#line 556
  if (op == 153U) {
#line 556
    goto case_153;
  }
#line 557
  if (op == 154U) {
#line 557
    goto case_154;
  }
#line 558
  if (op == 155U) {
#line 558
    goto case_155;
  }
#line 559
  if (op == 156U) {
#line 559
    goto case_156;
  }
#line 560
  if (op == 157U) {
#line 560
    goto case_157;
  }
#line 563
  if (op == 158U) {
#line 563
    goto case_158;
  }
#line 564
  if (op == 159U) {
#line 564
    goto case_159;
  }
#line 570
  if (op == 224U) {
#line 570
    goto case_224;
  }
#line 572
  if (op == 240U) {
#line 572
    goto case_240;
  }
#line 573
  if (op == 241U) {
#line 573
    goto case_241;
  }
#line 576
  if (op == 242U) {
#line 576
    goto case_242;
  }
#line 579
  if (op == 243U) {
#line 579
    goto case_243;
  }
#line 582
  if (op == 244U) {
#line 582
    goto case_244;
  }
#line 583
  if (op == 245U) {
#line 583
    goto case_245;
  }
#line 584
  if (op == 246U) {
#line 584
    goto case_246;
  }
#line 585
  if (op == 247U) {
#line 585
    goto case_247;
  }
#line 586
  if (op == 249U) {
#line 586
    goto case_249;
  }
#line 588
  if (op == 250U) {
#line 588
    goto case_250;
  }
#line 590
  if (op == 251U) {
#line 590
    goto case_251;
  }
#line 591
  if (op == 252U) {
#line 591
    goto case_252;
  }
#line 594
  if (op == 225U) {
#line 594
    goto case_225;
  }
#line 595
  if (op == 226U) {
#line 595
    goto case_226;
  }
#line 596
  if (op == 227U) {
#line 596
    goto case_227;
  }
#line 597
  if (op == 228U) {
#line 597
    goto case_228;
  }
#line 598
  if (op == 229U) {
#line 598
    goto case_229;
  }
#line 599
  if (op == 230U) {
#line 599
    goto case_230;
  }
#line 601
  if (op == 248U) {
#line 601
    goto case_248;
  }
#line 408
  goto switch_break;
  case_3: /* CIL Label */ 
#line 408
  return ("DW_OP_addr");
  case_6: /* CIL Label */ 
#line 409
  return ("DW_OP_deref");
  case_8: /* CIL Label */ 
#line 410
  return ("DW_OP_const1u");
  case_9: /* CIL Label */ 
#line 411
  return ("DW_OP_const1s");
  case_10: /* CIL Label */ 
#line 412
  return ("DW_OP_const2u");
  case_11: /* CIL Label */ 
#line 413
  return ("DW_OP_const2s");
  case_12: /* CIL Label */ 
#line 414
  return ("DW_OP_const4u");
  case_13: /* CIL Label */ 
#line 415
  return ("DW_OP_const4s");
  case_14: /* CIL Label */ 
#line 416
  return ("DW_OP_const8u");
  case_15: /* CIL Label */ 
#line 417
  return ("DW_OP_const8s");
  case_16: /* CIL Label */ 
#line 418
  return ("DW_OP_constu");
  case_17: /* CIL Label */ 
#line 419
  return ("DW_OP_consts");
  case_18: /* CIL Label */ 
#line 420
  return ("DW_OP_dup");
  case_19: /* CIL Label */ 
#line 421
  return ("DW_OP_drop");
  case_20: /* CIL Label */ 
#line 422
  return ("DW_OP_over");
  case_21: /* CIL Label */ 
#line 423
  return ("DW_OP_pick");
  case_22: /* CIL Label */ 
#line 424
  return ("DW_OP_swap");
  case_23: /* CIL Label */ 
#line 425
  return ("DW_OP_rot");
  case_24: /* CIL Label */ 
#line 426
  return ("DW_OP_xderef");
  case_25: /* CIL Label */ 
#line 427
  return ("DW_OP_abs");
  case_26: /* CIL Label */ 
#line 428
  return ("DW_OP_and");
  case_27: /* CIL Label */ 
#line 429
  return ("DW_OP_div");
  case_28: /* CIL Label */ 
#line 430
  return ("DW_OP_minus");
  case_29: /* CIL Label */ 
#line 431
  return ("DW_OP_mod");
  case_30: /* CIL Label */ 
#line 432
  return ("DW_OP_mul");
  case_31: /* CIL Label */ 
#line 433
  return ("DW_OP_neg");
  case_32: /* CIL Label */ 
#line 434
  return ("DW_OP_not");
  case_33: /* CIL Label */ 
#line 435
  return ("DW_OP_or");
  case_34: /* CIL Label */ 
#line 436
  return ("DW_OP_plus");
  case_35: /* CIL Label */ 
#line 437
  return ("DW_OP_plus_uconst");
  case_36: /* CIL Label */ 
#line 438
  return ("DW_OP_shl");
  case_37: /* CIL Label */ 
#line 439
  return ("DW_OP_shr");
  case_38: /* CIL Label */ 
#line 440
  return ("DW_OP_shra");
  case_39: /* CIL Label */ 
#line 441
  return ("DW_OP_xor");
  case_40: /* CIL Label */ 
#line 442
  return ("DW_OP_bra");
  case_41: /* CIL Label */ 
#line 443
  return ("DW_OP_eq");
  case_42: /* CIL Label */ 
#line 444
  return ("DW_OP_ge");
  case_43: /* CIL Label */ 
#line 445
  return ("DW_OP_gt");
  case_44: /* CIL Label */ 
#line 446
  return ("DW_OP_le");
  case_45: /* CIL Label */ 
#line 447
  return ("DW_OP_lt");
  case_46: /* CIL Label */ 
#line 448
  return ("DW_OP_ne");
  case_47: /* CIL Label */ 
#line 449
  return ("DW_OP_skip");
  case_48: /* CIL Label */ 
#line 450
  return ("DW_OP_lit0");
  case_49: /* CIL Label */ 
#line 451
  return ("DW_OP_lit1");
  case_50: /* CIL Label */ 
#line 452
  return ("DW_OP_lit2");
  case_51: /* CIL Label */ 
#line 453
  return ("DW_OP_lit3");
  case_52: /* CIL Label */ 
#line 454
  return ("DW_OP_lit4");
  case_53: /* CIL Label */ 
#line 455
  return ("DW_OP_lit5");
  case_54: /* CIL Label */ 
#line 456
  return ("DW_OP_lit6");
  case_55: /* CIL Label */ 
#line 457
  return ("DW_OP_lit7");
  case_56: /* CIL Label */ 
#line 458
  return ("DW_OP_lit8");
  case_57: /* CIL Label */ 
#line 459
  return ("DW_OP_lit9");
  case_58: /* CIL Label */ 
#line 460
  return ("DW_OP_lit10");
  case_59: /* CIL Label */ 
#line 461
  return ("DW_OP_lit11");
  case_60: /* CIL Label */ 
#line 462
  return ("DW_OP_lit12");
  case_61: /* CIL Label */ 
#line 463
  return ("DW_OP_lit13");
  case_62: /* CIL Label */ 
#line 464
  return ("DW_OP_lit14");
  case_63: /* CIL Label */ 
#line 465
  return ("DW_OP_lit15");
  case_64: /* CIL Label */ 
#line 466
  return ("DW_OP_lit16");
  case_65: /* CIL Label */ 
#line 467
  return ("DW_OP_lit17");
  case_66: /* CIL Label */ 
#line 468
  return ("DW_OP_lit18");
  case_67: /* CIL Label */ 
#line 469
  return ("DW_OP_lit19");
  case_68: /* CIL Label */ 
#line 470
  return ("DW_OP_lit20");
  case_69: /* CIL Label */ 
#line 471
  return ("DW_OP_lit21");
  case_70: /* CIL Label */ 
#line 472
  return ("DW_OP_lit22");
  case_71: /* CIL Label */ 
#line 473
  return ("DW_OP_lit23");
  case_72: /* CIL Label */ 
#line 474
  return ("DW_OP_lit24");
  case_73: /* CIL Label */ 
#line 475
  return ("DW_OP_lit25");
  case_74: /* CIL Label */ 
#line 476
  return ("DW_OP_lit26");
  case_75: /* CIL Label */ 
#line 477
  return ("DW_OP_lit27");
  case_76: /* CIL Label */ 
#line 478
  return ("DW_OP_lit28");
  case_77: /* CIL Label */ 
#line 479
  return ("DW_OP_lit29");
  case_78: /* CIL Label */ 
#line 480
  return ("DW_OP_lit30");
  case_79: /* CIL Label */ 
#line 481
  return ("DW_OP_lit31");
  case_80: /* CIL Label */ 
#line 482
  return ("DW_OP_reg0");
  case_81: /* CIL Label */ 
#line 483
  return ("DW_OP_reg1");
  case_82: /* CIL Label */ 
#line 484
  return ("DW_OP_reg2");
  case_83: /* CIL Label */ 
#line 485
  return ("DW_OP_reg3");
  case_84: /* CIL Label */ 
#line 486
  return ("DW_OP_reg4");
  case_85: /* CIL Label */ 
#line 487
  return ("DW_OP_reg5");
  case_86: /* CIL Label */ 
#line 488
  return ("DW_OP_reg6");
  case_87: /* CIL Label */ 
#line 489
  return ("DW_OP_reg7");
  case_88: /* CIL Label */ 
#line 490
  return ("DW_OP_reg8");
  case_89: /* CIL Label */ 
#line 491
  return ("DW_OP_reg9");
  case_90: /* CIL Label */ 
#line 492
  return ("DW_OP_reg10");
  case_91: /* CIL Label */ 
#line 493
  return ("DW_OP_reg11");
  case_92: /* CIL Label */ 
#line 494
  return ("DW_OP_reg12");
  case_93: /* CIL Label */ 
#line 495
  return ("DW_OP_reg13");
  case_94: /* CIL Label */ 
#line 496
  return ("DW_OP_reg14");
  case_95: /* CIL Label */ 
#line 497
  return ("DW_OP_reg15");
  case_96: /* CIL Label */ 
#line 498
  return ("DW_OP_reg16");
  case_97: /* CIL Label */ 
#line 499
  return ("DW_OP_reg17");
  case_98: /* CIL Label */ 
#line 500
  return ("DW_OP_reg18");
  case_99: /* CIL Label */ 
#line 501
  return ("DW_OP_reg19");
  case_100: /* CIL Label */ 
#line 502
  return ("DW_OP_reg20");
  case_101: /* CIL Label */ 
#line 503
  return ("DW_OP_reg21");
  case_102: /* CIL Label */ 
#line 504
  return ("DW_OP_reg22");
  case_103: /* CIL Label */ 
#line 505
  return ("DW_OP_reg23");
  case_104: /* CIL Label */ 
#line 506
  return ("DW_OP_reg24");
  case_105: /* CIL Label */ 
#line 507
  return ("DW_OP_reg25");
  case_106: /* CIL Label */ 
#line 508
  return ("DW_OP_reg26");
  case_107: /* CIL Label */ 
#line 509
  return ("DW_OP_reg27");
  case_108: /* CIL Label */ 
#line 510
  return ("DW_OP_reg28");
  case_109: /* CIL Label */ 
#line 511
  return ("DW_OP_reg29");
  case_110: /* CIL Label */ 
#line 512
  return ("DW_OP_reg30");
  case_111: /* CIL Label */ 
#line 513
  return ("DW_OP_reg31");
  case_112: /* CIL Label */ 
#line 514
  return ("DW_OP_breg0");
  case_113: /* CIL Label */ 
#line 515
  return ("DW_OP_breg1");
  case_114: /* CIL Label */ 
#line 516
  return ("DW_OP_breg2");
  case_115: /* CIL Label */ 
#line 517
  return ("DW_OP_breg3");
  case_116: /* CIL Label */ 
#line 518
  return ("DW_OP_breg4");
  case_117: /* CIL Label */ 
#line 519
  return ("DW_OP_breg5");
  case_118: /* CIL Label */ 
#line 520
  return ("DW_OP_breg6");
  case_119: /* CIL Label */ 
#line 521
  return ("DW_OP_breg7");
  case_120: /* CIL Label */ 
#line 522
  return ("DW_OP_breg8");
  case_121: /* CIL Label */ 
#line 523
  return ("DW_OP_breg9");
  case_122: /* CIL Label */ 
#line 524
  return ("DW_OP_breg10");
  case_123: /* CIL Label */ 
#line 525
  return ("DW_OP_breg11");
  case_124: /* CIL Label */ 
#line 526
  return ("DW_OP_breg12");
  case_125: /* CIL Label */ 
#line 527
  return ("DW_OP_breg13");
  case_126: /* CIL Label */ 
#line 528
  return ("DW_OP_breg14");
  case_127: /* CIL Label */ 
#line 529
  return ("DW_OP_breg15");
  case_128: /* CIL Label */ 
#line 530
  return ("DW_OP_breg16");
  case_129: /* CIL Label */ 
#line 531
  return ("DW_OP_breg17");
  case_130: /* CIL Label */ 
#line 532
  return ("DW_OP_breg18");
  case_131: /* CIL Label */ 
#line 533
  return ("DW_OP_breg19");
  case_132: /* CIL Label */ 
#line 534
  return ("DW_OP_breg20");
  case_133: /* CIL Label */ 
#line 535
  return ("DW_OP_breg21");
  case_134: /* CIL Label */ 
#line 536
  return ("DW_OP_breg22");
  case_135: /* CIL Label */ 
#line 537
  return ("DW_OP_breg23");
  case_136: /* CIL Label */ 
#line 538
  return ("DW_OP_breg24");
  case_137: /* CIL Label */ 
#line 539
  return ("DW_OP_breg25");
  case_138: /* CIL Label */ 
#line 540
  return ("DW_OP_breg26");
  case_139: /* CIL Label */ 
#line 541
  return ("DW_OP_breg27");
  case_140: /* CIL Label */ 
#line 542
  return ("DW_OP_breg28");
  case_141: /* CIL Label */ 
#line 543
  return ("DW_OP_breg29");
  case_142: /* CIL Label */ 
#line 544
  return ("DW_OP_breg30");
  case_143: /* CIL Label */ 
#line 545
  return ("DW_OP_breg31");
  case_144: /* CIL Label */ 
#line 546
  return ("DW_OP_regx");
  case_145: /* CIL Label */ 
#line 547
  return ("DW_OP_fbreg");
  case_146: /* CIL Label */ 
#line 548
  return ("DW_OP_bregx");
  case_147: /* CIL Label */ 
#line 549
  return ("DW_OP_piece");
  case_148: /* CIL Label */ 
#line 550
  return ("DW_OP_deref_size");
  case_149: /* CIL Label */ 
#line 551
  return ("DW_OP_xderef_size");
  case_150: /* CIL Label */ 
#line 552
  return ("DW_OP_nop");
  case_151: /* CIL Label */ 
#line 554
  return ("DW_OP_push_object_address");
  case_152: /* CIL Label */ 
#line 555
  return ("DW_OP_call2");
  case_153: /* CIL Label */ 
#line 556
  return ("DW_OP_call4");
  case_154: /* CIL Label */ 
#line 557
  return ("DW_OP_call_ref");
  case_155: /* CIL Label */ 
#line 558
  return ("DW_OP_form_tls_address");
  case_156: /* CIL Label */ 
#line 559
  return ("DW_OP_call_frame_cfa");
  case_157: /* CIL Label */ 
#line 560
  return ("DW_OP_bit_piece");
  case_158: /* CIL Label */ 
#line 563
  return ("DW_OP_implicit_value");
  case_159: /* CIL Label */ 
#line 564
  return ("DW_OP_stack_value");
  case_224: /* CIL Label */ 
#line 570
  return ("DW_OP_GNU_push_tls_address");
  case_240: /* CIL Label */ 
#line 572
  return ("DW_OP_GNU_uninit");
  case_241: /* CIL Label */ 
#line 573
  return ("DW_OP_GNU_encoded_addr");
  case_242: /* CIL Label */ 
#line 576
  return ("DW_OP_GNU_implicit_pointer");
  case_243: /* CIL Label */ 
#line 579
  return ("DW_OP_GNU_entry_value");
  case_244: /* CIL Label */ 
#line 582
  return ("DW_OP_GNU_const_type");
  case_245: /* CIL Label */ 
#line 583
  return ("DW_OP_GNU_regval_type");
  case_246: /* CIL Label */ 
#line 584
  return ("DW_OP_GNU_deref_type");
  case_247: /* CIL Label */ 
#line 585
  return ("DW_OP_GNU_convert");
  case_249: /* CIL Label */ 
#line 586
  return ("DW_OP_GNU_reinterpret");
  case_250: /* CIL Label */ 
#line 588
  return ("DW_OP_GNU_parameter_ref");
  case_251: /* CIL Label */ 
#line 590
  return ("DW_OP_GNU_addr_index");
  case_252: /* CIL Label */ 
#line 591
  return ("DW_OP_GNU_const_index");
  case_225: /* CIL Label */ 
#line 594
  return ("DW_OP_HP_is_value");
  case_226: /* CIL Label */ 
#line 595
  return ("DW_OP_HP_fltconst4");
  case_227: /* CIL Label */ 
#line 596
  return ("DW_OP_HP_fltconst8");
  case_228: /* CIL Label */ 
#line 597
  return ("DW_OP_HP_mod_range");
  case_229: /* CIL Label */ 
#line 598
  return ("DW_OP_HP_unmod_range");
  case_230: /* CIL Label */ 
#line 599
  return ("DW_OP_HP_tls");
  case_248: /* CIL Label */ 
#line 601
  return ("DW_OP_PGI_omp_thread_num");
  switch_break: /* CIL Label */ ;
  }
#line 602
  return ((char const   *)0);
}
}
#line 604 "./../include/dwarf2.def"
char const   *get_DW_ATE_name(unsigned int enc ) 
{ 


  {
  {
#line 604
  if (enc == 0U) {
#line 604
    goto case_0;
  }
#line 605
  if (enc == 1U) {
#line 605
    goto case_1;
  }
#line 606
  if (enc == 2U) {
#line 606
    goto case_2;
  }
#line 607
  if (enc == 3U) {
#line 607
    goto case_3;
  }
#line 608
  if (enc == 4U) {
#line 608
    goto case_4;
  }
#line 609
  if (enc == 5U) {
#line 609
    goto case_5;
  }
#line 610
  if (enc == 6U) {
#line 610
    goto case_6;
  }
#line 611
  if (enc == 7U) {
#line 611
    goto case_7;
  }
#line 612
  if (enc == 8U) {
#line 612
    goto case_8;
  }
#line 614
  if (enc == 9U) {
#line 614
    goto case_9;
  }
#line 615
  if (enc == 10U) {
#line 615
    goto case_10;
  }
#line 616
  if (enc == 11U) {
#line 616
    goto case_11;
  }
#line 617
  if (enc == 12U) {
#line 617
    goto case_12;
  }
#line 618
  if (enc == 13U) {
#line 618
    goto case_13;
  }
#line 619
  if (enc == 14U) {
#line 619
    goto case_14;
  }
#line 620
  if (enc == 15U) {
#line 620
    goto case_15;
  }
#line 622
  if (enc == 16U) {
#line 622
    goto case_16;
  }
#line 628
  if (enc == 128U) {
#line 628
    goto case_128;
  }
#line 629
  if (enc == 129U) {
#line 629
    goto case_129;
  }
#line 630
  if (enc == 130U) {
#line 630
    goto case_130;
  }
#line 631
  if (enc == 131U) {
#line 631
    goto case_131;
  }
#line 632
  if (enc == 132U) {
#line 632
    goto case_132;
  }
#line 633
  if (enc == 133U) {
#line 633
    goto case_133;
  }
#line 634
  if (enc == 134U) {
#line 634
    goto case_134;
  }
#line 635
  if (enc == 136U) {
#line 635
    goto case_136;
  }
#line 636
  if (enc == 137U) {
#line 636
    goto case_137;
  }
#line 637
  if (enc == 138U) {
#line 637
    goto case_138;
  }
#line 638
  if (enc == 139U) {
#line 638
    goto case_139;
  }
#line 639
  if (enc == 140U) {
#line 639
    goto case_140;
  }
#line 640
  if (enc == 141U) {
#line 640
    goto case_141;
  }
#line 641
  if (enc == 142U) {
#line 641
    goto case_142;
  }
#line 642
  if (enc == 143U) {
#line 642
    goto case_143;
  }
#line 643
  if (enc == 144U) {
#line 643
    goto case_144;
  }
#line 604
  goto switch_break;
  case_0: /* CIL Label */ 
#line 604
  return ("DW_ATE_void");
  case_1: /* CIL Label */ 
#line 605
  return ("DW_ATE_address");
  case_2: /* CIL Label */ 
#line 606
  return ("DW_ATE_boolean");
  case_3: /* CIL Label */ 
#line 607
  return ("DW_ATE_complex_float");
  case_4: /* CIL Label */ 
#line 608
  return ("DW_ATE_float");
  case_5: /* CIL Label */ 
#line 609
  return ("DW_ATE_signed");
  case_6: /* CIL Label */ 
#line 610
  return ("DW_ATE_signed_char");
  case_7: /* CIL Label */ 
#line 611
  return ("DW_ATE_unsigned");
  case_8: /* CIL Label */ 
#line 612
  return ("DW_ATE_unsigned_char");
  case_9: /* CIL Label */ 
#line 614
  return ("DW_ATE_imaginary_float");
  case_10: /* CIL Label */ 
#line 615
  return ("DW_ATE_packed_decimal");
  case_11: /* CIL Label */ 
#line 616
  return ("DW_ATE_numeric_string");
  case_12: /* CIL Label */ 
#line 617
  return ("DW_ATE_edited");
  case_13: /* CIL Label */ 
#line 618
  return ("DW_ATE_signed_fixed");
  case_14: /* CIL Label */ 
#line 619
  return ("DW_ATE_unsigned_fixed");
  case_15: /* CIL Label */ 
#line 620
  return ("DW_ATE_decimal_float");
  case_16: /* CIL Label */ 
#line 622
  return ("DW_ATE_UTF");
  case_128: /* CIL Label */ 
#line 628
  return ("DW_ATE_HP_float80");
  case_129: /* CIL Label */ 
#line 629
  return ("DW_ATE_HP_complex_float80");
  case_130: /* CIL Label */ 
#line 630
  return ("DW_ATE_HP_float128");
  case_131: /* CIL Label */ 
#line 631
  return ("DW_ATE_HP_complex_float128");
  case_132: /* CIL Label */ 
#line 632
  return ("DW_ATE_HP_floathpintel");
  case_133: /* CIL Label */ 
#line 633
  return ("DW_ATE_HP_imaginary_float80");
  case_134: /* CIL Label */ 
#line 634
  return ("DW_ATE_HP_imaginary_float128");
  case_136: /* CIL Label */ 
#line 635
  return ("DW_ATE_HP_VAX_float");
  case_137: /* CIL Label */ 
#line 636
  return ("DW_ATE_HP_VAX_float_d");
  case_138: /* CIL Label */ 
#line 637
  return ("DW_ATE_HP_packed_decimal");
  case_139: /* CIL Label */ 
#line 638
  return ("DW_ATE_HP_zoned_decimal");
  case_140: /* CIL Label */ 
#line 639
  return ("DW_ATE_HP_edited");
  case_141: /* CIL Label */ 
#line 640
  return ("DW_ATE_HP_signed_fixed");
  case_142: /* CIL Label */ 
#line 641
  return ("DW_ATE_HP_unsigned_fixed");
  case_143: /* CIL Label */ 
#line 642
  return ("DW_ATE_HP_VAX_complex_float");
  case_144: /* CIL Label */ 
#line 643
  return ("DW_ATE_HP_VAX_complex_float_d");
  switch_break: /* CIL Label */ ;
  }
#line 645
  return ((char const   *)0);
}
}
#line 647 "./../include/dwarf2.def"
char const   *get_DW_CFA_name(unsigned int opc ) 
{ 


  {
  {
#line 647
  if (opc == 64U) {
#line 647
    goto case_64;
  }
#line 648
  if (opc == 128U) {
#line 648
    goto case_128;
  }
#line 649
  if (opc == 192U) {
#line 649
    goto case_192;
  }
#line 650
  if (opc == 0U) {
#line 650
    goto case_0;
  }
#line 651
  if (opc == 1U) {
#line 651
    goto case_1;
  }
#line 652
  if (opc == 2U) {
#line 652
    goto case_2;
  }
#line 653
  if (opc == 3U) {
#line 653
    goto case_3;
  }
#line 654
  if (opc == 4U) {
#line 654
    goto case_4;
  }
#line 655
  if (opc == 5U) {
#line 655
    goto case_5;
  }
#line 656
  if (opc == 6U) {
#line 656
    goto case_6;
  }
#line 657
  if (opc == 7U) {
#line 657
    goto case_7;
  }
#line 658
  if (opc == 8U) {
#line 658
    goto case_8;
  }
#line 659
  if (opc == 9U) {
#line 659
    goto case_9;
  }
#line 660
  if (opc == 10U) {
#line 660
    goto case_10;
  }
#line 661
  if (opc == 11U) {
#line 661
    goto case_11;
  }
#line 662
  if (opc == 12U) {
#line 662
    goto case_12;
  }
#line 663
  if (opc == 13U) {
#line 663
    goto case_13;
  }
#line 664
  if (opc == 14U) {
#line 664
    goto case_14;
  }
#line 666
  if (opc == 15U) {
#line 666
    goto case_15;
  }
#line 667
  if (opc == 16U) {
#line 667
    goto case_16;
  }
#line 668
  if (opc == 17U) {
#line 668
    goto case_17;
  }
#line 669
  if (opc == 18U) {
#line 669
    goto case_18;
  }
#line 670
  if (opc == 19U) {
#line 670
    goto case_19;
  }
#line 671
  if (opc == 20U) {
#line 671
    goto case_20;
  }
#line 672
  if (opc == 21U) {
#line 672
    goto case_21;
  }
#line 673
  if (opc == 22U) {
#line 673
    goto case_22;
  }
#line 675
  if (opc == 28U) {
#line 675
    goto case_28;
  }
#line 676
  if (opc == 63U) {
#line 676
    goto case_63;
  }
#line 679
  if (opc == 29U) {
#line 679
    goto case_29;
  }
#line 681
  if (opc == 45U) {
#line 681
    goto case_45;
  }
#line 682
  if (opc == 46U) {
#line 682
    goto case_46;
  }
#line 683
  if (opc == 47U) {
#line 683
    goto case_47;
  }
#line 647
  goto switch_break;
  case_64: /* CIL Label */ 
#line 647
  return ("DW_CFA_advance_loc");
  case_128: /* CIL Label */ 
#line 648
  return ("DW_CFA_offset");
  case_192: /* CIL Label */ 
#line 649
  return ("DW_CFA_restore");
  case_0: /* CIL Label */ 
#line 650
  return ("DW_CFA_nop");
  case_1: /* CIL Label */ 
#line 651
  return ("DW_CFA_set_loc");
  case_2: /* CIL Label */ 
#line 652
  return ("DW_CFA_advance_loc1");
  case_3: /* CIL Label */ 
#line 653
  return ("DW_CFA_advance_loc2");
  case_4: /* CIL Label */ 
#line 654
  return ("DW_CFA_advance_loc4");
  case_5: /* CIL Label */ 
#line 655
  return ("DW_CFA_offset_extended");
  case_6: /* CIL Label */ 
#line 656
  return ("DW_CFA_restore_extended");
  case_7: /* CIL Label */ 
#line 657
  return ("DW_CFA_undefined");
  case_8: /* CIL Label */ 
#line 658
  return ("DW_CFA_same_value");
  case_9: /* CIL Label */ 
#line 659
  return ("DW_CFA_register");
  case_10: /* CIL Label */ 
#line 660
  return ("DW_CFA_remember_state");
  case_11: /* CIL Label */ 
#line 661
  return ("DW_CFA_restore_state");
  case_12: /* CIL Label */ 
#line 662
  return ("DW_CFA_def_cfa");
  case_13: /* CIL Label */ 
#line 663
  return ("DW_CFA_def_cfa_register");
  case_14: /* CIL Label */ 
#line 664
  return ("DW_CFA_def_cfa_offset");
  case_15: /* CIL Label */ 
#line 666
  return ("DW_CFA_def_cfa_expression");
  case_16: /* CIL Label */ 
#line 667
  return ("DW_CFA_expression");
  case_17: /* CIL Label */ 
#line 668
  return ("DW_CFA_offset_extended_sf");
  case_18: /* CIL Label */ 
#line 669
  return ("DW_CFA_def_cfa_sf");
  case_19: /* CIL Label */ 
#line 670
  return ("DW_CFA_def_cfa_offset_sf");
  case_20: /* CIL Label */ 
#line 671
  return ("DW_CFA_val_offset");
  case_21: /* CIL Label */ 
#line 672
  return ("DW_CFA_val_offset_sf");
  case_22: /* CIL Label */ 
#line 673
  return ("DW_CFA_val_expression");
  case_28: /* CIL Label */ 
#line 675
  return ("DW_CFA_lo_user");
  case_63: /* CIL Label */ 
#line 676
  return ("DW_CFA_hi_user");
  case_29: /* CIL Label */ 
#line 679
  return ("DW_CFA_MIPS_advance_loc8");
  case_45: /* CIL Label */ 
#line 681
  return ("DW_CFA_GNU_window_save");
  case_46: /* CIL Label */ 
#line 682
  return ("DW_CFA_GNU_args_size");
  case_47: /* CIL Label */ 
#line 683
  return ("DW_CFA_GNU_negative_offset_extended");
  switch_break: /* CIL Label */ ;
  }
#line 685
  return ((char const   *)0);
}
}
#line 331 "./../include/libiberty.h"
unsigned int xcrc32(unsigned char const   *buf___4 , int len , unsigned int init ) ;
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./crc32.c"
static unsigned int const   crc32_table[256]  = 
#line 71 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./crc32.c"
  {      (unsigned int const   )0,      (unsigned int const   )79764919,      (unsigned int const   )159529838,      (unsigned int const   )222504665, 
        (unsigned int const   )319059676,      (unsigned int const   )398814059,      (unsigned int const   )445009330,      (unsigned int const   )507990021, 
        (unsigned int const   )638119352,      (unsigned int const   )583659535,      (unsigned int const   )797628118,      (unsigned int const   )726387553, 
        (unsigned int const   )890018660,      (unsigned int const   )835552979,      (unsigned int const   )1015980042,      (unsigned int const   )944750013, 
        (unsigned int const   )1276238704,      (unsigned int const   )1221641927,      (unsigned int const   )1167319070,      (unsigned int const   )1095957929, 
        (unsigned int const   )1595256236,      (unsigned int const   )1540665371,      (unsigned int const   )1452775106,      (unsigned int const   )1381403509, 
        (unsigned int const   )1780037320,      (unsigned int const   )1859660671,      (unsigned int const   )1671105958,      (unsigned int const   )1733955601, 
        (unsigned int const   )2031960084,      (unsigned int const   )2111593891,      (unsigned int const   )1889500026,      (unsigned int const   )1952343757, 
        (unsigned int const   )2552477408U,      (unsigned int const   )2632100695U,      (unsigned int const   )2443283854U,      (unsigned int const   )2506133561U, 
        (unsigned int const   )2334638140U,      (unsigned int const   )2414271883U,      (unsigned int const   )2191915858U,      (unsigned int const   )2254759653U, 
        (unsigned int const   )3190512472U,      (unsigned int const   )3135915759U,      (unsigned int const   )3081330742U,      (unsigned int const   )3009969537U, 
        (unsigned int const   )2905550212U,      (unsigned int const   )2850959411U,      (unsigned int const   )2762807018U,      (unsigned int const   )2691435357U, 
        (unsigned int const   )3560074640U,      (unsigned int const   )3505614887U,      (unsigned int const   )3719321342U,      (unsigned int const   )3648080713U, 
        (unsigned int const   )3342211916U,      (unsigned int const   )3287746299U,      (unsigned int const   )3467911202U,      (unsigned int const   )3396681109U, 
        (unsigned int const   )4063920168U,      (unsigned int const   )4143685023U,      (unsigned int const   )4223187782U,      (unsigned int const   )4286162673U, 
        (unsigned int const   )3779000052U,      (unsigned int const   )3858754371U,      (unsigned int const   )3904687514U,      (unsigned int const   )3967668269U, 
        (unsigned int const   )881225847,      (unsigned int const   )809987520,      (unsigned int const   )1023691545,      (unsigned int const   )969234094, 
        (unsigned int const   )662832811,      (unsigned int const   )591600412,      (unsigned int const   )771767749,      (unsigned int const   )717299826, 
        (unsigned int const   )311336399,      (unsigned int const   )374308984,      (unsigned int const   )453813921,      (unsigned int const   )533576470, 
        (unsigned int const   )25881363,      (unsigned int const   )88864420,      (unsigned int const   )134795389,      (unsigned int const   )214552010, 
        (unsigned int const   )2023205639,      (unsigned int const   )2086057648,      (unsigned int const   )1897238633,      (unsigned int const   )1976864222, 
        (unsigned int const   )1804852699,      (unsigned int const   )1867694188,      (unsigned int const   )1645340341,      (unsigned int const   )1724971778, 
        (unsigned int const   )1587496639,      (unsigned int const   )1516133128,      (unsigned int const   )1461550545,      (unsigned int const   )1406951526, 
        (unsigned int const   )1302016099,      (unsigned int const   )1230646740,      (unsigned int const   )1142491917,      (unsigned int const   )1087903418, 
        (unsigned int const   )2896545431U,      (unsigned int const   )2825181984U,      (unsigned int const   )2770861561U,      (unsigned int const   )2716262478U, 
        (unsigned int const   )3215044683U,      (unsigned int const   )3143675388U,      (unsigned int const   )3055782693U,      (unsigned int const   )3001194130U, 
        (unsigned int const   )2326604591U,      (unsigned int const   )2389456536U,      (unsigned int const   )2200899649U,      (unsigned int const   )2280525302U, 
        (unsigned int const   )2578013683U,      (unsigned int const   )2640855108U,      (unsigned int const   )2418763421U,      (unsigned int const   )2498394922U, 
        (unsigned int const   )3769900519U,      (unsigned int const   )3832873040U,      (unsigned int const   )3912640137U,      (unsigned int const   )3992402750U, 
        (unsigned int const   )4088425275U,      (unsigned int const   )4151408268U,      (unsigned int const   )4197601365U,      (unsigned int const   )4277358050U, 
        (unsigned int const   )3334271071U,      (unsigned int const   )3263032808U,      (unsigned int const   )3476998961U,      (unsigned int const   )3422541446U, 
        (unsigned int const   )3585640067U,      (unsigned int const   )3514407732U,      (unsigned int const   )3694837229U,      (unsigned int const   )3640369242U, 
        (unsigned int const   )1762451694,      (unsigned int const   )1842216281,      (unsigned int const   )1619975040,      (unsigned int const   )1682949687, 
        (unsigned int const   )2047383090,      (unsigned int const   )2127137669,      (unsigned int const   )1938468188,      (unsigned int const   )2001449195, 
        (unsigned int const   )1325665622,      (unsigned int const   )1271206113,      (unsigned int const   )1183200824,      (unsigned int const   )1111960463, 
        (unsigned int const   )1543535498,      (unsigned int const   )1489069629,      (unsigned int const   )1434599652,      (unsigned int const   )1363369299, 
        (unsigned int const   )622672798,      (unsigned int const   )568075817,      (unsigned int const   )748617968,      (unsigned int const   )677256519, 
        (unsigned int const   )907627842,      (unsigned int const   )853037301,      (unsigned int const   )1067152940,      (unsigned int const   )995781531, 
        (unsigned int const   )51762726,      (unsigned int const   )131386257,      (unsigned int const   )177728840,      (unsigned int const   )240578815, 
        (unsigned int const   )269590778,      (unsigned int const   )349224269,      (unsigned int const   )429104020,      (unsigned int const   )491947555, 
        (unsigned int const   )4046411278U,      (unsigned int const   )4126034873U,      (unsigned int const   )4172115296U,      (unsigned int const   )4234965207U, 
        (unsigned int const   )3794477266U,      (unsigned int const   )3874110821U,      (unsigned int const   )3953728444U,      (unsigned int const   )4016571915U, 
        (unsigned int const   )3609705398U,      (unsigned int const   )3555108353U,      (unsigned int const   )3735388376U,      (unsigned int const   )3664026991U, 
        (unsigned int const   )3290680682U,      (unsigned int const   )3236090077U,      (unsigned int const   )3449943556U,      (unsigned int const   )3378572211U, 
        (unsigned int const   )3174993278U,      (unsigned int const   )3120533705U,      (unsigned int const   )3032266256U,      (unsigned int const   )2961025959U, 
        (unsigned int const   )2923101090U,      (unsigned int const   )2868635157U,      (unsigned int const   )2813903052U,      (unsigned int const   )2742672763U, 
        (unsigned int const   )2604032198U,      (unsigned int const   )2683796849U,      (unsigned int const   )2461293480U,      (unsigned int const   )2524268063U, 
        (unsigned int const   )2284983834U,      (unsigned int const   )2364738477U,      (unsigned int const   )2175806836U,      (unsigned int const   )2238787779U, 
        (unsigned int const   )1569362073,      (unsigned int const   )1498123566,      (unsigned int const   )1409854455,      (unsigned int const   )1355396672, 
        (unsigned int const   )1317987909,      (unsigned int const   )1246755826,      (unsigned int const   )1192025387,      (unsigned int const   )1137557660, 
        (unsigned int const   )2072149281,      (unsigned int const   )2135122070,      (unsigned int const   )1912620623,      (unsigned int const   )1992383480, 
        (unsigned int const   )1753615357,      (unsigned int const   )1816598090,      (unsigned int const   )1627664531,      (unsigned int const   )1707420964, 
        (unsigned int const   )295390185,      (unsigned int const   )358241886,      (unsigned int const   )404320391,      (unsigned int const   )483945776, 
        (unsigned int const   )43990325,      (unsigned int const   )106832002,      (unsigned int const   )186451547,      (unsigned int const   )266083308, 
        (unsigned int const   )932423249,      (unsigned int const   )861060070,      (unsigned int const   )1041341759,      (unsigned int const   )986742920, 
        (unsigned int const   )613929101,      (unsigned int const   )542559546,      (unsigned int const   )756411363,      (unsigned int const   )701822548, 
        (unsigned int const   )3316196985U,      (unsigned int const   )3244833742U,      (unsigned int const   )3425377559U,      (unsigned int const   )3370778784U, 
        (unsigned int const   )3601682597U,      (unsigned int const   )3530312978U,      (unsigned int const   )3744426955U,      (unsigned int const   )3689838204U, 
        (unsigned int const   )3819031489U,      (unsigned int const   )3881883254U,      (unsigned int const   )3928223919U,      (unsigned int const   )4007849240U, 
        (unsigned int const   )4037393693U,      (unsigned int const   )4100235434U,      (unsigned int const   )4180117107U,      (unsigned int const   )4259748804U, 
        (unsigned int const   )2310601993U,      (unsigned int const   )2373574846U,      (unsigned int const   )2151335527U,      (unsigned int const   )2231098320U, 
        (unsigned int const   )2596047829U,      (unsigned int const   )2659030626U,      (unsigned int const   )2470359227U,      (unsigned int const   )2550115596U, 
        (unsigned int const   )2947551409U,      (unsigned int const   )2876312838U,      (unsigned int const   )2788305887U,      (unsigned int const   )2733848168U, 
        (unsigned int const   )3165939309U,      (unsigned int const   )3094707162U,      (unsigned int const   )3040238851U,      (unsigned int const   )2985771188U};
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./crc32.c"
unsigned int xcrc32(unsigned char const   *buf___4 , int len , unsigned int init ) 
{ 
  unsigned int crc ;
  int tmp___0 ;

  {
#line 174
  crc = init;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    tmp___0 = len;
#line 175
    len --;
#line 175
    if (! tmp___0) {
#line 175
      goto while_break;
    }
#line 177
    crc = (crc << 8) ^ (unsigned int )crc32_table[((crc >> 24) ^ (unsigned int )*buf___4) & 255U];
#line 178
    buf___4 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return (crc);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 272
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 78 "./../include/demangle.h"
enum demangling_styles current_demangling_style ;
#line 122
struct demangler_engine  const  libiberty_demanglers[11] ;
#line 129
char *cplus_demangle(char const   *mangled , int options___0 ) ;
#line 132
int cplus_demangle_opname(char const   *opname , char *result , int options___0 ) ;
#line 135
char const   *cplus_mangle_opname(char const   *opname , int options___0 ) ;
#line 140
void set_cplus_marker_for_demangling(int ch ) ;
#line 143
enum demangling_styles cplus_demangle_set_style(enum demangling_styles style ) ;
#line 146
enum demangling_styles cplus_demangle_name_to_style(char const   *name___0 ) ;
#line 159
char *cplus_demangle_v3(char const   *mangled , int options___0 ) ;
#line 166
char *java_demangle_v3(char const   *mangled ) ;
#line 169
char *ada_demangle(char const   *mangled , int option  __attribute__((__unused__)) ) ;
#line 93 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
enum demangling_styles current_demangling_style  =    (enum demangling_styles )256;
#line 95 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char cplus_markers[4]  = {      (char )'$',      (char )'.',      (char )'$',      (char )'\000'};
#line 97 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char char_str[2]  = {      (char )'\000',      (char )'\000'};
#line 99 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
void set_cplus_marker_for_demangling(int ch ) 
{ 


  {
#line 102
  cplus_markers[0] = (char )ch;
#line 103
  return;
}
}
#line 145 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static struct optable  const  optable[79]  = 
#line 145
  {      {(char const   */* const  */)"nw", (char const   */* const  */)" new", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"dl",
      (char const   */* const  */)" delete", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"new", (char const   */* const  */)" new", (int const   )0}, 
        {(char const   */* const  */)"delete",
      (char const   */* const  */)" delete", (int const   )0}, 
        {(char const   */* const  */)"vn", (char const   */* const  */)" new []", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"vd",
      (char const   */* const  */)" delete []", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"as", (char const   */* const  */)"=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ne",
      (char const   */* const  */)"!=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"eq", (char const   */* const  */)"==", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ge",
      (char const   */* const  */)">=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"gt", (char const   */* const  */)">", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"le",
      (char const   */* const  */)"<=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"lt", (char const   */* const  */)"<", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"plus",
      (char const   */* const  */)"+", (int const   )0}, 
        {(char const   */* const  */)"pl", (char const   */* const  */)"+", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"apl",
      (char const   */* const  */)"+=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"minus", (char const   */* const  */)"-", (int const   )0}, 
        {(char const   */* const  */)"mi",
      (char const   */* const  */)"-", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ami", (char const   */* const  */)"-=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"mult",
      (char const   */* const  */)"*", (int const   )0}, 
        {(char const   */* const  */)"ml", (char const   */* const  */)"*", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"amu",
      (char const   */* const  */)"*=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aml", (char const   */* const  */)"*=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"convert",
      (char const   */* const  */)"+", (int const   )0}, 
        {(char const   */* const  */)"negate", (char const   */* const  */)"-", (int const   )0}, 
        {(char const   */* const  */)"trunc_mod",
      (char const   */* const  */)"%", (int const   )0}, 
        {(char const   */* const  */)"md", (char const   */* const  */)"%", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"amd",
      (char const   */* const  */)"%=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"trunc_div", (char const   */* const  */)"/", (int const   )0}, 
        {(char const   */* const  */)"dv",
      (char const   */* const  */)"/", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"adv", (char const   */* const  */)"/=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_andif",
      (char const   */* const  */)"&&", (int const   )0}, 
        {(char const   */* const  */)"aa", (char const   */* const  */)"&&", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_orif",
      (char const   */* const  */)"||", (int const   )0}, 
        {(char const   */* const  */)"oo", (char const   */* const  */)"||", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"truth_not",
      (char const   */* const  */)"!", (int const   )0}, 
        {(char const   */* const  */)"nt", (char const   */* const  */)"!", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"postincrement",
      (char const   */* const  */)"++", (int const   )0}, 
        {(char const   */* const  */)"pp", (char const   */* const  */)"++", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"postdecrement",
      (char const   */* const  */)"--", (int const   )0}, 
        {(char const   */* const  */)"mm", (char const   */* const  */)"--", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_ior",
      (char const   */* const  */)"|", (int const   )0}, 
        {(char const   */* const  */)"or", (char const   */* const  */)"|", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aor",
      (char const   */* const  */)"|=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_xor", (char const   */* const  */)"^", (int const   )0}, 
        {(char const   */* const  */)"er",
      (char const   */* const  */)"^", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aer", (char const   */* const  */)"^=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_and",
      (char const   */* const  */)"&", (int const   )0}, 
        {(char const   */* const  */)"ad", (char const   */* const  */)"&", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"aad",
      (char const   */* const  */)"&=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"bit_not", (char const   */* const  */)"~", (int const   )0}, 
        {(char const   */* const  */)"co",
      (char const   */* const  */)"~", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"call", (char const   */* const  */)"()", (int const   )0}, 
        {(char const   */* const  */)"cl",
      (char const   */* const  */)"()", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"alshift", (char const   */* const  */)"<<", (int const   )0}, 
        {(char const   */* const  */)"ls",
      (char const   */* const  */)"<<", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"als", (char const   */* const  */)"<<=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"arshift",
      (char const   */* const  */)">>", (int const   )0}, 
        {(char const   */* const  */)"rs", (char const   */* const  */)">>", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"ars",
      (char const   */* const  */)">>=", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"component", (char const   */* const  */)"->", (int const   )0}, 
        {(char const   */* const  */)"pt",
      (char const   */* const  */)"->", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"rf", (char const   */* const  */)"->", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"indirect",
      (char const   */* const  */)"*", (int const   )0}, 
        {(char const   */* const  */)"method_call", (char const   */* const  */)"->()",
      (int const   )0}, 
        {(char const   */* const  */)"addr", (char const   */* const  */)"&", (int const   )0}, 
        {(char const   */* const  */)"array",
      (char const   */* const  */)"[]", (int const   )0}, 
        {(char const   */* const  */)"vc", (char const   */* const  */)"[]", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"compound",
      (char const   */* const  */)", ", (int const   )0}, 
        {(char const   */* const  */)"cm", (char const   */* const  */)", ", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"cond",
      (char const   */* const  */)"?:", (int const   )0}, 
        {(char const   */* const  */)"cn", (char const   */* const  */)"?:", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"max",
      (char const   */* const  */)">?", (int const   )0}, 
        {(char const   */* const  */)"mx", (char const   */* const  */)">?", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"min",
      (char const   */* const  */)"<?", (int const   )0}, 
        {(char const   */* const  */)"mn", (char const   */* const  */)"<?", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"nop",
      (char const   */* const  */)"", (int const   )0}, 
        {(char const   */* const  */)"rm", (char const   */* const  */)"->*", (int const   )(1 << 1)}, 
        {(char const   */* const  */)"sz",
      (char const   */* const  */)"sizeof ", (int const   )(1 << 1)}};
#line 246 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
struct demangler_engine  const  libiberty_demanglers[11]  = 
#line 246
  {      {(char const   */* const  */)"none", (enum demangling_styles  const  )-1, (char const   */* const  */)"Demangling disabled"}, 
        {(char const   */* const  */)"auto",
      (enum demangling_styles  const  )256, (char const   */* const  */)"Automatic selection based on executable"}, 
        {(char const   */* const  */)"gnu",
      (enum demangling_styles  const  )512, (char const   */* const  */)"GNU (g++) style demangling"}, 
        {(char const   */* const  */)"lucid",
      (enum demangling_styles  const  )1024, (char const   */* const  */)"Lucid (lcc) style demangling"}, 
        {(char const   */* const  */)"arm",
      (enum demangling_styles  const  )2048, (char const   */* const  */)"ARM style demangling"}, 
        {(char const   */* const  */)"hp",
      (enum demangling_styles  const  )4096, (char const   */* const  */)"HP (aCC) style demangling"}, 
        {(char const   */* const  */)"edg",
      (enum demangling_styles  const  )8192, (char const   */* const  */)"EDG style demangling"}, 
        {(char const   */* const  */)"gnu-v3",
      (enum demangling_styles  const  )16384, (char const   */* const  */)"GNU (g++) V3 ABI-style demangling"}, 
        {(char const   */* const  */)"java",
      (enum demangling_styles  const  )4, (char const   */* const  */)"Java style demangling"}, 
        {(char const   */* const  */)"gnat",
      (enum demangling_styles  const  )32768, (char const   */* const  */)"GNAT style demangling"}, 
        {(char const   */* const  */)((void *)0),
      (enum demangling_styles  const  )0, (char const   */* const  */)((void *)0)}};
#line 327
static void delete_work_stuff(struct work_stuff *work ) ;
#line 329
static void delete_non_B_K_work_stuff(struct work_stuff *work ) ;
#line 331
static char *mop_up(struct work_stuff *work , string *declp , int success ) ;
#line 333
static void squangle_mop_up(struct work_stuff *work ) ;
#line 335
static void work_stuff_copy_to_from(struct work_stuff *to , struct work_stuff *from ) ;
#line 342
static char *internal_cplus_demangle(struct work_stuff *work , char const   *mangled ) ;
#line 345
static int demangle_template_template_parm(struct work_stuff *work , char const   **mangled ,
                                           string *tname ) ;
#line 349
static int demangle_template(struct work_stuff *work , char const   **mangled , string *tname ,
                             string *trawname , int is_type , int remember ) ;
#line 353
static int arm_pt(struct work_stuff *work , char const   *mangled , int n , char const   **anchor ,
                  char const   **args ) ;
#line 357
static int demangle_class_name(struct work_stuff *work , char const   **mangled ,
                               string *declp ) ;
#line 360
static int demangle_qualified(struct work_stuff *work , char const   **mangled , string *result ,
                              int isfuncname , int append ) ;
#line 364
static int demangle_class(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 366
static int demangle_fund_type(struct work_stuff *work , char const   **mangled , string *result ) ;
#line 368
static int demangle_signature(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 370
static int demangle_prefix(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 372
static int gnu_special(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 374
static int arm_special(char const   **mangled , string *declp ) ;
#line 376
static void string_need(string *s , int n ) ;
#line 378
static void string_delete(string *s ) ;
#line 380
static void string_init(string *s ) ;
#line 383
static void string_clear(string *s ) ;
#line 389
static void string_append(string *p , char const   *s ) ;
#line 391
static void string_appends(string *p , string *s ) ;
#line 393
static void string_appendn(string *p , char const   *s , int n ) ;
#line 395
static void string_prepend(string *p , char const   *s ) ;
#line 397
static void string_prependn(string *p , char const   *s , int n ) ;
#line 399
static void string_append_template_idx(string *s , int idx___0 ) ;
#line 401
static int get_count(char const   **type , int *count ) ;
#line 403
static int consume_count(char const   **type ) ;
#line 405
static int consume_count_with_underscores(char const   **mangled ) ;
#line 407
static int demangle_args(struct work_stuff *work , char const   **mangled , string *declp ) ;
#line 409
static int demangle_nested_args(struct work_stuff *work , char const   **mangled ,
                                string *declp ) ;
#line 411
static int do_type(struct work_stuff *work , char const   **mangled , string *result ) ;
#line 413
static int do_arg(struct work_stuff *work , char const   **mangled , string *result ) ;
#line 415
static int demangle_function_name(struct work_stuff *work , char const   **mangled ,
                                  string *declp , char const   *scan ) ;
#line 419
static int iterate_demangle_function(struct work_stuff *work , char const   **mangled ,
                                     string *declp , char const   *scan ) ;
#line 423
static void remember_type(struct work_stuff *work , char const   *start , int len ) ;
#line 425
static void remember_Btype(struct work_stuff *work , char const   *start , int len ,
                           int index___0 ) ;
#line 427
static int register_Btype(struct work_stuff *work ) ;
#line 429
static void remember_Ktype(struct work_stuff *work , char const   *start , int len ) ;
#line 431
static void forget_types(struct work_stuff *work ) ;
#line 433
static void forget_B_and_K_types(struct work_stuff *work ) ;
#line 435
static void string_prepends(string *p , string *s ) ;
#line 437
static int demangle_template_value_parm(struct work_stuff *work , char const   **mangled ,
                                        string *s , type_kind_t tk ) ;
#line 441
static int do_hpacc_template_const_value(struct work_stuff *work  __attribute__((__unused__)) ,
                                         char const   **mangled , string *result ) ;
#line 444
static int do_hpacc_template_literal(struct work_stuff *work , char const   **mangled ,
                                     string *result ) ;
#line 447
static int snarf_numeric_literal(char const   **args , string *arg ) ;
#line 458
static int code_for_qualifier(int c ) ;
#line 460
static char const   *qualifier_string(int type_quals ) ;
#line 462
static char const   *demangle_qualifier(int c ) ;
#line 464
static int demangle_expression(struct work_stuff *work , char const   **mangled ,
                               string *s , type_kind_t tk ) ;
#line 467
static int demangle_integral_value(struct work_stuff *work , char const   **mangled ,
                                   string *s ) ;
#line 470
static int demangle_real_value(struct work_stuff *work , char const   **mangled ,
                               string *s ) ;
#line 473
static void demangle_arm_hp_template(struct work_stuff *work , char const   **mangled ,
                                     int n , string *declp ) ;
#line 476
static void recursively_demangle(struct work_stuff *work , char const   **mangled ,
                                 string *result , int namelength ) ;
#line 487 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int consume_count(char const   **type ) 
{ 
  int count ;

  {
#line 490
  count = 0;
#line 492
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 493
    return (-1);
  }
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 495
      goto while_break;
    }
#line 497
    count *= 10;
#line 504
    if (count % 10 != 0) {
      {
#line 506
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 506
        if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 506
          goto while_break___0;
        }
#line 507
        (*type) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 508
      return (-1);
    }
#line 511
    count += (int )((int const   )*(*type) - 48);
#line 512
    (*type) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  if (count < 0) {
#line 516
    count = -1;
  }
#line 518
  return (count);
}
}
#line 526 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int consume_count_with_underscores(char const   **mangled ) 
{ 
  int idx___0 ;

  {
#line 531
  if ((int const   )*(*mangled) == 95) {
#line 533
    (*mangled) ++;
#line 534
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 535
      return (-1);
    }
    {
#line 537
    idx___0 = consume_count(mangled);
    }
#line 538
    if ((int const   )*(*mangled) != 95) {
#line 540
      return (-1);
    }
#line 542
    (*mangled) ++;
  } else {
#line 546
    if ((int const   )*(*mangled) < 48) {
#line 547
      return (-1);
    } else
#line 546
    if ((int const   )*(*mangled) > 57) {
#line 547
      return (-1);
    }
#line 549
    idx___0 = (int )((int const   )*(*mangled) - 48);
#line 550
    (*mangled) ++;
  }
#line 553
  return (idx___0);
}
}
#line 559 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int code_for_qualifier(int c ) 
{ 


  {
  {
#line 564
  if (c == 67) {
#line 564
    goto case_67;
  }
#line 567
  if (c == 86) {
#line 567
    goto case_86;
  }
#line 570
  if (c == 117) {
#line 570
    goto case_117;
  }
#line 573
  goto switch_default;
  case_67: /* CIL Label */ 
#line 565
  return (1);
  case_86: /* CIL Label */ 
#line 568
  return (2);
  case_117: /* CIL Label */ 
#line 571
  return (4);
  switch_default: /* CIL Label */ 
#line 574
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 578
  abort();
  }
}
}
#line 584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char const   *qualifier_string(int type_quals ) 
{ 


  {
  {
#line 589
  if (type_quals == 0) {
#line 589
    goto case_0;
  }
#line 592
  if (type_quals == 1) {
#line 592
    goto case_1;
  }
#line 595
  if (type_quals == 2) {
#line 595
    goto case_2;
  }
#line 598
  if (type_quals == 4) {
#line 598
    goto case_4;
  }
#line 601
  if (type_quals == 3) {
#line 601
    goto case_3;
  }
#line 604
  if (type_quals == 5) {
#line 604
    goto case_5;
  }
#line 607
  if (type_quals == 6) {
#line 607
    goto case_6;
  }
#line 610
  if (type_quals == 7) {
#line 610
    goto case_7;
  }
#line 613
  goto switch_default;
  case_0: /* CIL Label */ 
#line 590
  return ("");
  case_1: /* CIL Label */ 
#line 593
  return ("const");
  case_2: /* CIL Label */ 
#line 596
  return ("volatile");
  case_4: /* CIL Label */ 
#line 599
  return ("__restrict");
  case_3: /* CIL Label */ 
#line 602
  return ("const volatile");
  case_5: /* CIL Label */ 
#line 605
  return ("const __restrict");
  case_6: /* CIL Label */ 
#line 608
  return ("volatile __restrict");
  case_7: /* CIL Label */ 
#line 611
  return ("const volatile __restrict");
  switch_default: /* CIL Label */ 
#line 614
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 618
  abort();
  }
}
}
#line 625 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char const   *demangle_qualifier(int c ) 
{ 
  int tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 628
  tmp___0 = code_for_qualifier(c);
#line 628
  tmp___1 = qualifier_string(tmp___0);
  }
#line 628
  return (tmp___1);
}
}
#line 631 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
int cplus_demangle_opname(char const   *opname , char *result , int options___0 ) 
{ 
  int len ;
  int len1 ;
  int ret ;
  string type ;
  struct work_stuff work[1] ;
  char const   *tem ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t i ;
  size_t tmp___2 ;
  int tmp___3 ;
  size_t i___0 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t i___1 ;
  size_t tmp___6 ;
  int tmp___7 ;
  size_t i___2 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 639
  tmp___0 = strlen(opname);
#line 639
  len = (int )tmp___0;
#line 640
  *(result + 0) = (char )'\000';
#line 641
  ret = 0;
#line 642
  memset((void *)((char *)(work)), 0, sizeof(work));
#line 643
  work[0].options = options___0;
  }
#line 645
  if ((int const   )*(opname + 0) == 95) {
#line 645
    if ((int const   )*(opname + 1) == 95) {
#line 645
      if ((int const   )*(opname + 2) == 111) {
#line 645
        if ((int const   )*(opname + 3) == 112) {
          {
#line 650
          tem = opname + 4;
#line 651
          tmp___1 = do_type(work, & tem, & type);
          }
#line 651
          if (tmp___1) {
            {
#line 653
            strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator ");
#line 654
            strncat((char */* __restrict  */)result, (char const   */* __restrict  */)type.b,
                    (size_t )(type.p - type.b));
#line 655
            string_delete(& type);
#line 656
            ret = 1;
            }
          }
        } else {
#line 645
          goto _L___8;
        }
      } else {
#line 645
        goto _L___8;
      }
    } else {
#line 645
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 659
  if ((int const   )*(opname + 0) == 95) {
#line 659
    if ((int const   )*(opname + 1) == 95) {
#line 659
      if ((int const   )_sch_istable[(int )((unsigned char )*(opname + 2)) & 255] & 8) {
#line 659
        if ((int const   )_sch_istable[(int )((unsigned char )*(opname + 3)) & 255] & 8) {
#line 663
          if ((int const   )*(opname + 4) == 0) {
#line 667
            i = (size_t )0;
            {
#line 667
            while (1) {
              while_continue: /* CIL Label */ ;
#line 667
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 667
                goto while_break;
              }
              {
#line 669
              tmp___2 = strlen((char const   *)optable[i].in);
              }
#line 669
              if (tmp___2 == 2UL) {
                {
#line 669
                tmp___3 = memcmp((void const   *)optable[i].in, (void const   *)(opname + 2),
                                 (size_t )2);
                }
#line 669
                if (tmp___3 == 0) {
                  {
#line 672
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 673
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i].out);
#line 674
                  ret = 1;
                  }
#line 675
                  goto while_break;
                }
              }
#line 667
              i ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else
#line 681
          if ((int const   )*(opname + 2) == 97) {
#line 681
            if ((int const   )*(opname + 5) == 0) {
#line 685
              i___0 = (size_t )0;
              {
#line 685
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 685
                if (! (i___0 < sizeof(optable) / sizeof(optable[0]))) {
#line 685
                  goto while_break___0;
                }
                {
#line 687
                tmp___4 = strlen((char const   *)optable[i___0].in);
                }
#line 687
                if (tmp___4 == 3UL) {
                  {
#line 687
                  tmp___5 = memcmp((void const   *)optable[i___0].in, (void const   *)(opname + 2),
                                   (size_t )3);
                  }
#line 687
                  if (tmp___5 == 0) {
                    {
#line 690
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 691
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___0].out);
#line 692
                    ret = 1;
                    }
#line 693
                    goto while_break___0;
                  }
                }
#line 685
                i___0 ++;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
          }
        } else {
#line 659
          goto _L___5;
        }
      } else {
#line 659
        goto _L___5;
      }
    } else {
#line 659
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 699
  if (len >= 3) {
#line 699
    if ((int const   )*(opname + 0) == 111) {
#line 699
      if ((int const   )*(opname + 1) == 112) {
        {
#line 699
        tmp___14 = strchr((char const   *)(cplus_markers), (int )*(opname + 2));
        }
#line 699
        if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 705
          if (len >= 10) {
            {
#line 705
            tmp___10 = memcmp((void const   *)(opname + 3), (void const   *)"assign_",
                              (size_t )7);
            }
#line 705
            if (tmp___10 == 0) {
#line 709
              i___1 = (size_t )0;
              {
#line 709
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 709
                if (! (i___1 < sizeof(optable) / sizeof(optable[0]))) {
#line 709
                  goto while_break___1;
                }
                {
#line 711
                len1 = len - 10;
#line 712
                tmp___6 = strlen((char const   *)optable[i___1].in);
                }
#line 712
                if ((int )tmp___6 == len1) {
                  {
#line 712
                  tmp___7 = memcmp((void const   *)optable[i___1].in, (void const   *)(opname + 10),
                                   (size_t )len1);
                  }
#line 712
                  if (tmp___7 == 0) {
                    {
#line 715
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 716
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___1].out);
#line 717
                    strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"=");
#line 718
                    ret = 1;
                    }
#line 719
                    goto while_break___1;
                  }
                }
#line 709
                i___1 ++;
              }
              while_break___1: /* CIL Label */ ;
              }
            } else {
#line 705
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 726
            i___2 = (size_t )0;
            {
#line 726
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 726
              if (! (i___2 < sizeof(optable) / sizeof(optable[0]))) {
#line 726
                goto while_break___2;
              }
              {
#line 728
              len1 = len - 3;
#line 729
              tmp___8 = strlen((char const   *)optable[i___2].in);
              }
#line 729
              if ((int )tmp___8 == len1) {
                {
#line 729
                tmp___9 = memcmp((void const   *)optable[i___2].in, (void const   *)(opname + 3),
                                 (size_t )len1);
                }
#line 729
                if (tmp___9 == 0) {
                  {
#line 732
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator");
#line 733
                  strcat((char */* __restrict  */)result, (char const   */* __restrict  */)optable[i___2].out);
#line 734
                  ret = 1;
                  }
#line 735
                  goto while_break___2;
                }
              }
#line 726
              i___2 ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
#line 699
          goto _L___2;
        }
      } else {
#line 699
        goto _L___2;
      }
    } else {
#line 699
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 740
  if (len >= 5) {
    {
#line 740
    tmp___12 = memcmp((void const   *)opname, (void const   *)"type", (size_t )4);
    }
#line 740
    if (tmp___12 == 0) {
      {
#line 740
      tmp___13 = strchr((char const   *)(cplus_markers), (int )*(opname + 4));
      }
#line 740
      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
        {
#line 744
        tem = opname + 5;
#line 745
        tmp___11 = do_type(work, & tem, & type);
        }
#line 745
        if (tmp___11) {
          {
#line 747
          strcat((char */* __restrict  */)result, (char const   */* __restrict  */)"operator ");
#line 748
          strncat((char */* __restrict  */)result, (char const   */* __restrict  */)type.b,
                  (size_t )(type.p - type.b));
#line 749
          string_delete(& type);
#line 750
          ret = 1;
          }
        }
      }
    }
  }
  {
#line 753
  squangle_mop_up(work);
  }
#line 754
  return (ret);
}
}
#line 764 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
char const   *cplus_mangle_opname(char const   *opname , int options___0 ) 
{ 
  size_t i ;
  int len ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 770
  tmp___0 = strlen(opname);
#line 770
  len = (int )tmp___0;
#line 771
  i = (size_t )0;
  }
  {
#line 771
  while (1) {
    while_continue: /* CIL Label */ ;
#line 771
    if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 771
      goto while_break;
    }
    {
#line 773
    tmp___1 = strlen((char const   *)optable[i].out);
    }
#line 773
    if ((int )tmp___1 == len) {
#line 773
      if ((options___0 & (1 << 1)) == (int )(optable[i].flags & (int const   )(1 << 1))) {
        {
#line 773
        tmp___2 = memcmp((void const   *)optable[i].out, (void const   *)opname, (size_t )len);
        }
#line 773
        if (tmp___2 == 0) {
#line 776
          return ((char const   *)optable[i].in);
        }
      }
    }
#line 771
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  return ((char const   *)0);
}
}
#line 784 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
enum demangling_styles cplus_demangle_set_style(enum demangling_styles style ) 
{ 
  struct demangler_engine  const  *demangler ;

  {
#line 787
  demangler = libiberty_demanglers;
  {
#line 789
  while (1) {
    while_continue: /* CIL Label */ ;
#line 789
    if (! ((int const   )demangler->demangling_style != 0)) {
#line 789
      goto while_break;
    }
#line 790
    if ((int )style == (int )demangler->demangling_style) {
#line 792
      current_demangling_style = style;
#line 793
      return (current_demangling_style);
    }
#line 789
    demangler ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 796
  return ((enum demangling_styles )0);
}
}
#line 801 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
enum demangling_styles cplus_demangle_name_to_style(char const   *name___0 ) 
{ 
  struct demangler_engine  const  *demangler ;
  int tmp___0 ;

  {
#line 804
  demangler = libiberty_demanglers;
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if (! ((int const   )demangler->demangling_style != 0)) {
#line 806
      goto while_break;
    }
    {
#line 807
    tmp___0 = strcmp(name___0, (char const   *)demangler->demangling_style_name);
    }
#line 807
    if (tmp___0 == 0) {
#line 808
      return ((enum demangling_styles )demangler->demangling_style);
    }
#line 806
    demangler ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 810
  return ((enum demangling_styles )0);
}
}
#line 841 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
char *cplus_demangle(char const   *mangled , int options___0 ) 
{ 
  char *ret ;
  struct work_stuff work[1] ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 847
  if ((int )current_demangling_style == -1) {
    {
#line 848
    tmp___0 = xstrdup(mangled);
    }
#line 848
    return (tmp___0);
  }
  {
#line 850
  memset((void *)((char *)(work)), 0, sizeof(work));
#line 851
  work[0].options = options___0;
  }
#line 852
  if ((work[0].options & (((((((((1 << 8) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 14)) | (1 << 2)) | (1 << 15))) == 0) {
#line 853
    work[0].options |= (int )current_demangling_style & (((((((((1 << 8) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12)) | (1 << 13)) | (1 << 14)) | (1 << 2)) | (1 << 15));
  }
#line 856
  if (work[0].options & (1 << 14)) {
#line 856
    goto _L;
  } else
#line 856
  if (work[0].options & (1 << 8)) {
    _L: /* CIL Label */ 
    {
#line 858
    ret = cplus_demangle_v3(mangled, work[0].options);
    }
#line 859
    if (ret) {
#line 860
      return (ret);
    } else
#line 859
    if (work[0].options & (1 << 14)) {
#line 860
      return (ret);
    }
  }
#line 863
  if (work[0].options & (1 << 2)) {
    {
#line 865
    ret = java_demangle_v3(mangled);
    }
#line 866
    if (ret) {
#line 867
      return (ret);
    }
  }
#line 870
  if (work[0].options & (1 << 15)) {
    {
#line 871
    tmp___1 = ada_demangle(mangled, options___0);
    }
#line 871
    return (tmp___1);
  }
  {
#line 873
  ret = internal_cplus_demangle(work, mangled);
#line 874
  squangle_mop_up(work);
  }
#line 875
  return (ret);
}
}
#line 920 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char const   * const  operators[20][2]  = 
#line 920
  { {        (char const   */* const  */)"Oabs",        (char const   */* const  */)"abs"}, 
   {        (char const   */* const  */)"Oand",        (char const   */* const  */)"and"}, 
   {        (char const   */* const  */)"Omod",        (char const   */* const  */)"mod"}, 
   {        (char const   */* const  */)"Onot",        (char const   */* const  */)"not"}, 
   {        (char const   */* const  */)"Oor",        (char const   */* const  */)"or"}, 
   {        (char const   */* const  */)"Orem",        (char const   */* const  */)"rem"}, 
   {        (char const   */* const  */)"Oxor",        (char const   */* const  */)"xor"}, 
   {        (char const   */* const  */)"Oeq",        (char const   */* const  */)"="}, 
   {        (char const   */* const  */)"One",        (char const   */* const  */)"/="}, 
   {        (char const   */* const  */)"Olt",        (char const   */* const  */)"<"}, 
   {        (char const   */* const  */)"Ole",        (char const   */* const  */)"<="}, 
   {        (char const   */* const  */)"Ogt",        (char const   */* const  */)">"}, 
   {        (char const   */* const  */)"Oge",        (char const   */* const  */)">="}, 
   {        (char const   */* const  */)"Oadd",        (char const   */* const  */)"+"}, 
   {        (char const   */* const  */)"Osubtract",        (char const   */* const  */)"-"}, 
   {        (char const   */* const  */)"Oconcat",        (char const   */* const  */)"&"}, 
   {        (char const   */* const  */)"Omultiply",        (char const   */* const  */)"*"}, 
   {        (char const   */* const  */)"Odivide",        (char const   */* const  */)"/"}, 
   {        (char const   */* const  */)"Oexpon",        (char const   */* const  */)"**"}, 
   {        (char const   */* const  */)((void *)0),        (char const   */* const  */)((void *)0)}};
#line 1064 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char const   * const  special[6][2]  = { {        (char const   */* const  */)"_elabb",        (char const   */* const  */)"\'Elab_Body"}, 
   {        (char const   */* const  */)"_elabs",        (char const   */* const  */)"\'Elab_Spec"}, 
   {        (char const   */* const  */)"_size",        (char const   */* const  */)"\'Size"}, 
   {        (char const   */* const  */)"_alignment",        (char const   */* const  */)"\'Alignment"}, 
   {        (char const   */* const  */)"_assign",        (char const   */* const  */)".\":=\""}, 
   {        (char const   */* const  */)((void *)0),        (char const   */* const  */)((void *)0)}};
#line 880 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
char *ada_demangle(char const   *mangled , int option  __attribute__((__unused__)) ) 
{ 
  int len0 ;
  char const   *p ;
  char *d ;
  char *demangled ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  int k ;
  size_t slen ;
  size_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char const   *name___0 ;
  size_t tmp___10 ;
  char const   *name___1 ;
  size_t tmp___11 ;
  int k___0 ;
  size_t slen___0 ;
  size_t tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  void *tmp___16 ;

  {
  {
#line 889
  tmp___0 = strncmp(mangled, "_ada_", (size_t )5);
  }
#line 889
  if (tmp___0 == 0) {
#line 890
    mangled += 5;
  }
#line 893
  if (! ((int const   )_sch_istable[(int const   )*(mangled + 0) & 255] & 8)) {
#line 894
    goto unknown;
  }
  {
#line 901
  tmp___1 = strlen(mangled);
#line 901
  len0 = (int )((tmp___1 + 7UL) + 1UL);
#line 902
  tmp___2 = xmalloc(sizeof(char ) * (unsigned long )len0);
#line 902
  demangled = (char *)tmp___2;
#line 904
  d = demangled;
#line 905
  p = mangled;
  }
  {
#line 906
  while (1) {
    while_continue: /* CIL Label */ ;
#line 909
    if ((int const   )_sch_istable[(int const   )*p & 255] & 8) {
      {
#line 912
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 913
        tmp___3 = d;
#line 913
        d ++;
#line 913
        tmp___4 = p;
#line 913
        p ++;
#line 913
        *tmp___3 = (char )*tmp___4;
#line 912
        if (! ((int const   )_sch_istable[(int const   )*p & 255] & 8)) {
#line 912
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 912
            if ((int const   )*(p + 0) == 95) {
#line 912
              if (! ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 8)) {
#line 912
                if (! ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4)) {
#line 912
                  goto while_break___0;
                }
              }
            } else {
#line 912
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 917
    if ((int const   )*(p + 0) == 79) {
#line 930
      k = 0;
      {
#line 930
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 930
        if (! ((unsigned long )operators[k][0] != (unsigned long )((void *)0))) {
#line 930
          goto while_break___1;
        }
        {
#line 932
        tmp___5 = strlen((char const   *)operators[k][0]);
#line 932
        slen = tmp___5;
#line 933
        tmp___8 = strncmp(p, (char const   *)operators[k][0], slen);
        }
#line 933
        if (tmp___8 == 0) {
          {
#line 935
          p += slen;
#line 936
          slen = strlen((char const   *)operators[k][1]);
#line 937
          tmp___6 = d;
#line 937
          d ++;
#line 937
          *tmp___6 = (char )'\"';
#line 938
          memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)operators[k][1],
                 slen);
#line 939
          d += slen;
#line 940
          tmp___7 = d;
#line 940
          d ++;
#line 940
          *tmp___7 = (char )'\"';
          }
#line 941
          goto while_break___1;
        }
#line 930
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 945
      if ((unsigned long )operators[k][0] == (unsigned long )((void *)0)) {
#line 946
        goto unknown;
      }
    } else {
#line 951
      goto unknown;
    }
#line 955
    if ((int const   )*(p + 0) == 84) {
#line 955
      if ((int const   )*(p + 1) == 75) {
#line 958
        if ((int const   )*(p + 2) == 66) {
#line 958
          if ((int const   )*(p + 3) == 0) {
#line 961
            goto while_break;
          } else {
#line 958
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 963
        if ((int const   )*(p + 2) == 95) {
#line 963
          if ((int const   )*(p + 3) == 95) {
#line 966
            p += 4;
#line 967
            tmp___9 = d;
#line 967
            d ++;
#line 967
            *tmp___9 = (char )'.';
#line 968
            goto while_continue;
          } else {
#line 971
            goto unknown;
          }
        } else {
#line 971
          goto unknown;
        }
      }
    }
#line 973
    if ((int const   )*(p + 0) == 69) {
#line 973
      if ((int const   )*(p + 1) == 0) {
#line 976
        goto unknown;
      }
    }
#line 978
    if ((int const   )*(p + 0) == 80) {
#line 978
      goto _L___0;
    } else
#line 978
    if ((int const   )*(p + 0) == 78) {
      _L___0: /* CIL Label */ 
#line 978
      if ((int const   )*(p + 1) == 0) {
#line 981
        goto while_break;
      }
    }
#line 983
    if ((int const   )*p == 78) {
#line 983
      goto _L___1;
    } else
#line 983
    if ((int const   )*p == 83) {
      _L___1: /* CIL Label */ 
#line 983
      if ((int const   )*(p + 1) == 0) {
#line 986
        goto unknown;
      }
    }
#line 988
    if ((int const   )*(p + 0) == 88) {
#line 991
      p ++;
      {
#line 992
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 992
        if (! ((int const   )*(p + 0) == 110)) {
#line 992
          if (! ((int const   )*(p + 0) == 98)) {
#line 992
            goto while_break___2;
          }
        }
#line 993
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 995
    if ((int const   )*(p + 0) == 83) {
#line 995
      if ((int const   )*(p + 1) != 0) {
#line 995
        if ((int const   )*(p + 2) == 95) {
#line 995
          goto _L___3;
        } else
#line 995
        if ((int const   )*(p + 2) == 0) {
          _L___3: /* CIL Label */ 
          {
#line 1001
          if ((int const   )*(p + 1) == 82) {
#line 1001
            goto case_82;
          }
#line 1004
          if ((int const   )*(p + 1) == 87) {
#line 1004
            goto case_87;
          }
#line 1007
          if ((int const   )*(p + 1) == 73) {
#line 1007
            goto case_73;
          }
#line 1010
          if ((int const   )*(p + 1) == 79) {
#line 1010
            goto case_79;
          }
#line 1013
          goto switch_default;
          case_82: /* CIL Label */ 
#line 1002
          name___0 = "\'Read";
#line 1003
          goto switch_break;
          case_87: /* CIL Label */ 
#line 1005
          name___0 = "\'Write";
#line 1006
          goto switch_break;
          case_73: /* CIL Label */ 
#line 1008
          name___0 = "\'Input";
#line 1009
          goto switch_break;
          case_79: /* CIL Label */ 
#line 1011
          name___0 = "\'Output";
#line 1012
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 1014
          goto unknown;
          switch_break: /* CIL Label */ ;
          }
          {
#line 1016
          p += 2;
#line 1017
          strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)name___0);
#line 1018
          tmp___10 = strlen(name___0);
#line 1018
          d += tmp___10;
          }
        } else {
#line 995
          goto _L___4;
        }
      } else {
#line 995
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1020
    if ((int const   )*(p + 0) == 68) {
      {
#line 1026
      if ((int const   )*(p + 1) == 70) {
#line 1026
        goto case_70;
      }
#line 1029
      if ((int const   )*(p + 1) == 65) {
#line 1029
        goto case_65;
      }
#line 1032
      goto switch_default___0;
      case_70: /* CIL Label */ 
#line 1027
      name___1 = ".Finalize";
#line 1028
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 1030
      name___1 = ".Adjust";
#line 1031
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1033
      goto unknown;
      switch_break___0: /* CIL Label */ ;
      }
      {
#line 1035
      strcpy((char */* __restrict  */)d, (char const   */* __restrict  */)name___1);
#line 1036
      tmp___11 = strlen(name___1);
#line 1036
      d += tmp___11;
      }
#line 1037
      goto while_break;
    }
#line 1040
    if ((int const   )*(p + 0) == 95) {
#line 1043
      if ((int const   )*(p + 1) == 95) {
#line 1046
        p += 2;
#line 1048
        if ((int const   )_sch_istable[(int const   )*p & 255] & 4) {
          {
#line 1051
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1052
            p ++;
#line 1051
            if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1051
              if ((int const   )*(p + 0) == 95) {
#line 1051
                if (! ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4)) {
#line 1051
                  goto while_break___3;
                }
              } else {
#line 1051
                goto while_break___3;
              }
            }
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1054
          if ((int const   )*p == 88) {
#line 1056
            p ++;
            {
#line 1057
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1057
              if (! ((int const   )*(p + 0) == 110)) {
#line 1057
                if (! ((int const   )*(p + 0) == 98)) {
#line 1057
                  goto while_break___4;
                }
              }
#line 1058
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
        } else
#line 1061
        if ((int const   )*(p + 0) == 95) {
#line 1061
          if ((int const   )*(p + 1) != 95) {
#line 1074
            k___0 = 0;
            {
#line 1074
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 1074
              if (! ((unsigned long )special[k___0][0] != (unsigned long )((void *)0))) {
#line 1074
                goto while_break___5;
              }
              {
#line 1076
              tmp___12 = strlen((char const   *)special[k___0][0]);
#line 1076
              slen___0 = tmp___12;
#line 1077
              tmp___13 = strncmp(p, (char const   *)special[k___0][0], slen___0);
              }
#line 1077
              if (tmp___13 == 0) {
                {
#line 1079
                p += slen___0;
#line 1080
                slen___0 = strlen((char const   *)special[k___0][1]);
#line 1081
                memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)special[k___0][1],
                       slen___0);
#line 1082
                d += slen___0;
                }
#line 1083
                goto while_break___5;
              }
#line 1074
              k___0 ++;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 1086
            if ((unsigned long )special[k___0][0] != (unsigned long )((void *)0)) {
#line 1087
              goto while_break;
            } else {
#line 1089
              goto unknown;
            }
          } else {
#line 1093
            tmp___14 = d;
#line 1093
            d ++;
#line 1093
            *tmp___14 = (char )'.';
#line 1094
            goto while_continue;
          }
        } else {
#line 1093
          tmp___14 = d;
#line 1093
          d ++;
#line 1093
          *tmp___14 = (char )'.';
#line 1094
          goto while_continue;
        }
      } else
#line 1097
      if ((int const   )*(p + 1) == 66) {
#line 1097
        goto _L___5;
      } else
#line 1097
      if ((int const   )*(p + 1) == 69) {
        _L___5: /* CIL Label */ 
#line 1100
        p += 2;
        {
#line 1101
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1101
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1101
            goto while_break___6;
          }
#line 1102
          p ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 1103
        if ((int const   )*(p + 0) == 115) {
#line 1103
          if ((int const   )*(p + 1) == 0) {
#line 1104
            goto while_break;
          } else {
#line 1106
            goto unknown;
          }
        } else {
#line 1106
          goto unknown;
        }
      } else {
#line 1109
        goto unknown;
      }
    }
#line 1112
    if ((int const   )*(p + 0) == 46) {
#line 1112
      if ((int const   )_sch_istable[(int const   )*(p + 1) & 255] & 4) {
#line 1115
        p += 2;
        {
#line 1116
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1116
          if (! ((int const   )_sch_istable[(int const   )*p & 255] & 4)) {
#line 1116
            goto while_break___7;
          }
#line 1117
          p ++;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
#line 1119
    if ((int const   )*p == 0) {
#line 1122
      goto while_break;
    } else {
#line 1125
      goto unknown;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  *d = (char)0;
#line 1128
  return (demangled);
  unknown: 
  {
#line 1131
  tmp___15 = strlen(mangled);
#line 1131
  len0 = (int )tmp___15;
#line 1132
  tmp___16 = xmalloc(sizeof(char ) * (unsigned long )(len0 + 3));
#line 1132
  demangled = (char *)tmp___16;
  }
#line 1134
  if ((int const   )*(mangled + 0) == 60) {
    {
#line 1135
    strcpy((char */* __restrict  */)demangled, (char const   */* __restrict  */)mangled);
    }
  } else {
    {
#line 1137
    sprintf((char */* __restrict  */)demangled, (char const   */* __restrict  */)"<%s>",
            mangled);
    }
  }
#line 1139
  return (demangled);
}
}
#line 1148 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char *internal_cplus_demangle(struct work_stuff *work , char const   *mangled ) 
{ 
  string decl ;
  int success ;
  char *demangled ;
  int s1 ;
  int s2 ;
  int s3 ;
  int s4 ;
  int tmp___0 ;

  {
#line 1153
  success = 0;
#line 1154
  demangled = (char *)((void *)0);
#line 1156
  s1 = work->constructor;
#line 1157
  s2 = work->destructor;
#line 1158
  s3 = work->static_type;
#line 1159
  s4 = work->type_quals;
#line 1160
  tmp___0 = 0;
#line 1160
  work->destructor = tmp___0;
#line 1160
  work->constructor = tmp___0;
#line 1161
  work->type_quals = 0;
#line 1162
  work->dllimported = 0;
#line 1164
  if ((unsigned long )mangled != (unsigned long )((void *)0)) {
#line 1164
    if ((int const   )*mangled != 0) {
      {
#line 1166
      string_init(& decl);
      }
#line 1175
      if (work->options & (1 << 8)) {
        {
#line 1177
        success = gnu_special(work, & mangled, & decl);
        }
      } else
#line 1175
      if (work->options & (1 << 9)) {
        {
#line 1177
        success = gnu_special(work, & mangled, & decl);
        }
      }
#line 1179
      if (! success) {
        {
#line 1181
        success = demangle_prefix(work, & mangled, & decl);
        }
      }
#line 1183
      if (success) {
#line 1183
        if ((int const   )*mangled != 0) {
          {
#line 1185
          success = demangle_signature(work, & mangled, & decl);
          }
        }
      }
#line 1187
      if (work->constructor == 2) {
        {
#line 1189
        string_prepend(& decl, "global constructors keyed to ");
#line 1190
        work->constructor = 0;
        }
      } else
#line 1192
      if (work->destructor == 2) {
        {
#line 1194
        string_prepend(& decl, "global destructors keyed to ");
#line 1195
        work->destructor = 0;
        }
      } else
#line 1197
      if (work->dllimported == 1) {
        {
#line 1199
        string_prepend(& decl, "import stub for ");
#line 1200
        work->dllimported = 0;
        }
      }
      {
#line 1202
      demangled = mop_up(work, & decl, success);
      }
    }
  }
#line 1204
  work->constructor = s1;
#line 1205
  work->destructor = s2;
#line 1206
  work->static_type = s3;
#line 1207
  work->type_quals = s4;
#line 1208
  return (demangled);
}
}
#line 1213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void squangle_mop_up(struct work_stuff *work ) 
{ 


  {
  {
#line 1217
  forget_B_and_K_types(work);
  }
#line 1218
  if ((unsigned long )work->btypevec != (unsigned long )((void *)0)) {
    {
#line 1220
    free((void *)((char *)work->btypevec));
    }
  }
#line 1222
  if ((unsigned long )work->ktypevec != (unsigned long )((void *)0)) {
    {
#line 1224
    free((void *)((char *)work->ktypevec));
    }
  }
#line 1226
  return;
}
}
#line 1231 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void work_stuff_copy_to_from(struct work_stuff *to , struct work_stuff *from ) 
{ 
  int i ;
  void *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int len___0 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int len___1 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int len___2 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;

  {
  {
#line 1236
  delete_work_stuff(to);
#line 1239
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, sizeof(*to));
  }
#line 1242
  if (from->typevec_size) {
    {
#line 1243
    tmp___0 = xmalloc(sizeof(char *) * (unsigned long )from->typevec_size);
#line 1243
    to->typevec = (char **)tmp___0;
    }
  }
#line 1245
  i = 0;
  {
#line 1245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1245
    if (! (i < from->ntypes)) {
#line 1245
      goto while_break;
    }
    {
#line 1247
    tmp___1 = strlen((char const   *)*(from->typevec + i));
#line 1247
    len = (int )(tmp___1 + 1UL);
#line 1249
    tmp___2 = xmalloc(sizeof(char ) * (unsigned long )len);
#line 1249
    *(to->typevec + i) = (char *)tmp___2;
#line 1250
    memcpy((void */* __restrict  */)*(to->typevec + i), (void const   */* __restrict  */)*(from->typevec + i),
           (size_t )len);
#line 1245
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  if (from->ksize) {
    {
#line 1254
    tmp___3 = xmalloc(sizeof(char *) * (unsigned long )from->ksize);
#line 1254
    to->ktypevec = (char **)tmp___3;
    }
  }
#line 1256
  i = 0;
  {
#line 1256
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1256
    if (! (i < from->numk)) {
#line 1256
      goto while_break___0;
    }
    {
#line 1258
    tmp___4 = strlen((char const   *)*(from->ktypevec + i));
#line 1258
    len___0 = (int )(tmp___4 + 1UL);
#line 1260
    tmp___5 = xmalloc(sizeof(char ) * (unsigned long )len___0);
#line 1260
    *(to->ktypevec + i) = (char *)tmp___5;
#line 1261
    memcpy((void */* __restrict  */)*(to->ktypevec + i), (void const   */* __restrict  */)*(from->ktypevec + i),
           (size_t )len___0);
#line 1256
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1264
  if (from->bsize) {
    {
#line 1265
    tmp___6 = xmalloc(sizeof(char *) * (unsigned long )from->bsize);
#line 1265
    to->btypevec = (char **)tmp___6;
    }
  }
#line 1267
  i = 0;
  {
#line 1267
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1267
    if (! (i < from->numb)) {
#line 1267
      goto while_break___1;
    }
    {
#line 1269
    tmp___7 = strlen((char const   *)*(from->btypevec + i));
#line 1269
    len___1 = (int )(tmp___7 + 1UL);
#line 1271
    tmp___8 = xmalloc(sizeof(char ) * (unsigned long )len___1);
#line 1271
    *(to->btypevec + i) = (char *)tmp___8;
#line 1272
    memcpy((void */* __restrict  */)*(to->btypevec + i), (void const   */* __restrict  */)*(from->btypevec + i),
           (size_t )len___1);
#line 1267
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1275
  if (from->ntmpl_args) {
    {
#line 1276
    tmp___9 = xmalloc(sizeof(char *) * (unsigned long )from->ntmpl_args);
#line 1276
    to->tmpl_argvec = (char **)tmp___9;
    }
  }
#line 1278
  i = 0;
  {
#line 1278
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1278
    if (! (i < from->ntmpl_args)) {
#line 1278
      goto while_break___2;
    }
    {
#line 1280
    tmp___10 = strlen((char const   *)*(from->tmpl_argvec + i));
#line 1280
    len___2 = (int )(tmp___10 + 1UL);
#line 1282
    tmp___11 = xmalloc(sizeof(char ) * (unsigned long )len___2);
#line 1282
    *(to->tmpl_argvec + i) = (char *)tmp___11;
#line 1283
    memcpy((void */* __restrict  */)*(to->tmpl_argvec + i), (void const   */* __restrict  */)*(from->tmpl_argvec + i),
           (size_t )len___2);
#line 1278
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1286
  if (from->previous_argument) {
    {
#line 1288
    tmp___12 = xmalloc(sizeof(string ));
#line 1288
    to->previous_argument = (string *)tmp___12;
#line 1289
    string_init(to->previous_argument);
#line 1290
    string_appends(to->previous_argument, from->previous_argument);
    }
  }
#line 1292
  return;
}
}
#line 1297 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void delete_non_B_K_work_stuff(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 1302
  forget_types(work);
  }
#line 1303
  if ((unsigned long )work->typevec != (unsigned long )((void *)0)) {
    {
#line 1305
    free((void *)((char *)work->typevec));
#line 1306
    work->typevec = (char **)((void *)0);
#line 1307
    work->typevec_size = 0;
    }
  }
#line 1309
  if (work->tmpl_argvec) {
#line 1313
    i = 0;
    {
#line 1313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1313
      if (! (i < work->ntmpl_args)) {
#line 1313
        goto while_break;
      }
      {
#line 1314
      free((void *)*(work->tmpl_argvec + i));
#line 1313
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1316
    free((void *)((char *)work->tmpl_argvec));
#line 1317
    work->tmpl_argvec = (char **)((void *)0);
    }
  }
#line 1319
  if (work->previous_argument) {
    {
#line 1321
    string_delete(work->previous_argument);
#line 1322
    free((void *)((char *)work->previous_argument));
#line 1323
    work->previous_argument = (string *)((void *)0);
    }
  }
#line 1325
  return;
}
}
#line 1329 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void delete_work_stuff(struct work_stuff *work ) 
{ 


  {
  {
#line 1332
  delete_non_B_K_work_stuff(work);
#line 1333
  squangle_mop_up(work);
  }
#line 1334
  return;
}
}
#line 1339 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static char *mop_up(struct work_stuff *work , string *declp , int success ) 
{ 
  char *demangled ;

  {
  {
#line 1342
  demangled = (char *)((void *)0);
#line 1344
  delete_non_B_K_work_stuff(work);
  }
#line 1349
  if (! success) {
    {
#line 1351
    string_delete(declp);
    }
  } else {
    {
#line 1355
    string_appendn(declp, "", 1);
#line 1356
    demangled = declp->b;
    }
  }
#line 1358
  return (demangled);
}
}
#line 1391 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_signature(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int success ;
  int func_done ;
  int expect_func ;
  int expect_return_type ;
  char const   *oldmangled ;
  string trawname ;
  string tname ;
  int tmp___0 ;
  string s ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  string return_type ;
  char const   *tmp___3 ;

  {
#line 1395
  success = 1;
#line 1396
  func_done = 0;
#line 1397
  expect_func = 0;
#line 1398
  expect_return_type = 0;
#line 1399
  oldmangled = (char const   *)((void *)0);
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    if (success) {
#line 1403
      if (! ((int const   )*(*mangled) != 0)) {
#line 1403
        goto while_break;
      }
    } else {
#line 1403
      goto while_break;
    }
    {
#line 1407
    if ((int const   )*(*mangled) == 81) {
#line 1407
      goto case_81;
    }
#line 1417
    if ((int const   )*(*mangled) == 75) {
#line 1417
      goto case_75;
    }
#line 1427
    if ((int const   )*(*mangled) == 83) {
#line 1427
      goto case_83;
    }
#line 1439
    if ((int const   )*(*mangled) == 117) {
#line 1439
      goto case_117;
    }
#line 1439
    if ((int const   )*(*mangled) == 86) {
#line 1439
      goto case_117;
    }
#line 1439
    if ((int const   )*(*mangled) == 67) {
#line 1439
      goto case_117;
    }
#line 1448
    if ((int const   )*(*mangled) == 76) {
#line 1448
      goto case_76;
    }
#line 1464
    if ((int const   )*(*mangled) == 57) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 56) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 55) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 54) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 53) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 52) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 51) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 50) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 49) {
#line 1464
      goto case_57;
    }
#line 1464
    if ((int const   )*(*mangled) == 48) {
#line 1464
      goto case_57;
    }
#line 1485
    if ((int const   )*(*mangled) == 66) {
#line 1485
      goto case_66;
    }
#line 1500
    if ((int const   )*(*mangled) == 70) {
#line 1500
      goto case_70;
    }
#line 1534
    if ((int const   )*(*mangled) == 116) {
#line 1534
      goto case_116;
    }
#line 1568
    if ((int const   )*(*mangled) == 95) {
#line 1568
      goto case_95;
    }
#line 1601
    if ((int const   )*(*mangled) == 72) {
#line 1601
      goto case_72;
    }
#line 1616
    goto switch_default;
    case_81: /* CIL Label */ 
    {
#line 1408
    oldmangled = *mangled;
#line 1409
    success = demangle_qualified(work, mangled, declp, 1, 0);
    }
#line 1410
    if (success) {
      {
#line 1411
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1412
    if (work->options & (1 << 8)) {
#line 1413
      expect_func = 1;
    } else
#line 1412
    if (work->options & (1 << 9)) {
#line 1413
      expect_func = 1;
    }
#line 1414
    oldmangled = (char const   *)((void *)0);
#line 1415
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1418
    oldmangled = *mangled;
#line 1419
    success = demangle_qualified(work, mangled, declp, 1, 0);
    }
#line 1420
    if (work->options & (1 << 8)) {
#line 1422
      expect_func = 1;
    } else
#line 1420
    if (work->options & (1 << 9)) {
#line 1422
      expect_func = 1;
    }
#line 1424
    oldmangled = (char const   *)((void *)0);
#line 1425
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1429
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1431
      oldmangled = *mangled;
    }
#line 1433
    (*mangled) ++;
#line 1434
    work->static_type = 1;
#line 1435
    goto switch_break;
    case_117: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_67: /* CIL Label */ 
    {
#line 1440
    tmp___0 = code_for_qualifier((int )*(*mangled));
#line 1440
    work->type_quals |= tmp___0;
    }
#line 1443
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1444
      oldmangled = *mangled;
    }
#line 1445
    (*mangled) ++;
#line 1446
    goto switch_break;
    case_76: /* CIL Label */ 
#line 1450
    if (work->options & (1 << 12)) {
      {
#line 1452
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1452
        if (*(*mangled)) {
#line 1452
          if (! ((int const   )*(*mangled) != 95)) {
#line 1452
            goto while_break___0;
          }
        } else {
#line 1452
          goto while_break___0;
        }
#line 1453
        (*mangled) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1454
      if (! *(*mangled)) {
#line 1455
        success = 0;
      } else {
#line 1457
        (*mangled) ++;
      }
    } else {
#line 1460
      success = 0;
    }
#line 1461
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 1465
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1467
      oldmangled = *mangled;
    }
    {
#line 1469
    work->temp_start = -1;
#line 1470
    success = demangle_class(work, mangled, declp);
    }
#line 1471
    if (success) {
      {
#line 1473
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1475
    if (work->options & (1 << 8)) {
#line 1475
      goto _L;
    } else
#line 1475
    if (work->options & (1 << 9)) {
#line 1475
      goto _L;
    } else
#line 1475
    if (work->options & (1 << 13)) {
      _L: /* CIL Label */ 
#line 1479
      if ((int const   )*(*mangled) != 70) {
#line 1480
        expect_func = 1;
      }
    }
#line 1482
    oldmangled = (char const   *)((void *)0);
#line 1483
    goto switch_break;
    case_66: /* CIL Label */ 
    {
#line 1488
    success = do_type(work, mangled, & s);
    }
#line 1489
    if (success) {
#line 1491
      if (work->options & (1 << 2)) {
#line 1491
        tmp___1 = ".";
      } else {
#line 1491
        tmp___1 = "::";
      }
      {
#line 1491
      string_append(& s, tmp___1);
#line 1492
      string_prepends(declp, & s);
#line 1493
      string_delete(& s);
      }
    }
#line 1495
    oldmangled = (char const   *)((void *)0);
#line 1496
    expect_func = 1;
#line 1498
    goto switch_break;
    case_70: /* CIL Label */ 
#line 1507
    oldmangled = (char const   *)((void *)0);
#line 1508
    func_done = 1;
#line 1509
    (*mangled) ++;
#line 1516
    if (work->options & (1 << 10)) {
      {
#line 1518
      forget_types(work);
      }
    } else
#line 1516
    if (work->options & (1 << 11)) {
      {
#line 1518
      forget_types(work);
      }
    } else
#line 1516
    if (work->options & (1 << 12)) {
      {
#line 1518
      forget_types(work);
      }
    } else
#line 1516
    if (work->options & (1 << 13)) {
      {
#line 1518
      forget_types(work);
      }
    }
    {
#line 1520
    success = demangle_args(work, mangled, declp);
    }
#line 1524
    if (success) {
#line 1524
      if (work->options & (1 << 8)) {
#line 1524
        goto _L___0;
      } else
#line 1524
      if (work->options & (1 << 13)) {
        _L___0: /* CIL Label */ 
#line 1524
        if ((int const   )*(*mangled) == 95) {
          {
#line 1526
          (*mangled) ++;
#line 1528
          success = do_type(work, mangled, & tname);
#line 1529
          string_delete(& tname);
          }
        }
      }
    }
#line 1532
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 1536
    string_init(& trawname);
#line 1537
    string_init(& tname);
    }
#line 1538
    if ((unsigned long )oldmangled == (unsigned long )((void *)0)) {
#line 1540
      oldmangled = *mangled;
    }
    {
#line 1542
    success = demangle_template(work, mangled, & tname, & trawname, 1, 1);
    }
#line 1544
    if (success) {
      {
#line 1546
      remember_type(work, oldmangled, (int )(*mangled - oldmangled));
      }
    }
#line 1548
    if (work->options & (1 << 2)) {
#line 1548
      tmp___2 = ".";
    } else {
#line 1548
      tmp___2 = "::";
    }
    {
#line 1548
    string_append(& tname, tmp___2);
#line 1550
    string_prepends(declp, & tname);
    }
#line 1551
    if (work->destructor & 1) {
      {
#line 1553
      string_prepend(& trawname, "~");
#line 1554
      string_appends(declp, & trawname);
#line 1555
      (work->destructor) --;
      }
    }
#line 1557
    if (work->constructor & 1) {
      {
#line 1559
      string_appends(declp, & trawname);
#line 1560
      (work->constructor) --;
      }
    } else
#line 1557
    if (work->destructor & 1) {
      {
#line 1559
      string_appends(declp, & trawname);
#line 1560
      (work->constructor) --;
      }
    }
    {
#line 1562
    string_delete(& trawname);
#line 1563
    string_delete(& tname);
#line 1564
    oldmangled = (char const   *)((void *)0);
#line 1565
    expect_func = 1;
    }
#line 1566
    goto switch_break;
    case_95: /* CIL Label */ 
#line 1569
    if (work->options & (1 << 8)) {
#line 1569
      goto _L___2;
    } else
#line 1569
    if (work->options & (1 << 9)) {
      _L___2: /* CIL Label */ 
#line 1569
      if (expect_return_type) {
        {
#line 1574
        (*mangled) ++;
#line 1575
        success = do_type(work, mangled, & return_type);
        }
#line 1576
        if (! ((unsigned long )return_type.b == (unsigned long )return_type.p)) {
          {
#line 1576
          string_append(& return_type, " ");
          }
        }
        {
#line 1578
        string_prepends(declp, & return_type);
#line 1579
        string_delete(& return_type);
        }
#line 1580
        goto switch_break;
      } else {
#line 1569
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1591
    if (work->options & (1 << 12)) {
#line 1593
      (*mangled) ++;
      {
#line 1594
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1594
        if (*(*mangled)) {
#line 1594
          if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1594
            goto while_break___1;
          }
        } else {
#line 1594
          goto while_break___1;
        }
#line 1595
        (*mangled) ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
#line 1598
      success = 0;
    }
#line 1599
    goto switch_break;
    case_72: /* CIL Label */ 
#line 1602
    if (work->options & (1 << 8)) {
#line 1602
      goto _L___3;
    } else
#line 1602
    if (work->options & (1 << 9)) {
      _L___3: /* CIL Label */ 
      {
#line 1605
      success = demangle_template(work, mangled, declp, (string *)0, 0, 0);
      }
#line 1607
      if (! (work->constructor & 1)) {
#line 1608
        expect_return_type = 1;
      }
#line 1609
      (*mangled) ++;
#line 1610
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 1617
    if (work->options & (1 << 8)) {
      {
#line 1621
      func_done = 1;
#line 1622
      success = demangle_args(work, mangled, declp);
      }
    } else
#line 1617
    if (work->options & (1 << 9)) {
      {
#line 1621
      func_done = 1;
#line 1622
      success = demangle_args(work, mangled, declp);
      }
    } else {
#line 1630
      success = 0;
    }
#line 1632
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1638
    if (success) {
#line 1638
      if (expect_func) {
#line 1640
        func_done = 1;
#line 1641
        if (work->options & (1 << 10)) {
          {
#line 1643
          forget_types(work);
          }
        } else
#line 1641
        if (work->options & (1 << 11)) {
          {
#line 1643
          forget_types(work);
          }
        } else
#line 1641
        if (work->options & (1 << 13)) {
          {
#line 1643
          forget_types(work);
          }
        }
        {
#line 1645
        success = demangle_args(work, mangled, declp);
#line 1649
        expect_func = 0;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1653
  if (success) {
#line 1653
    if (! func_done) {
#line 1655
      if (work->options & (1 << 8)) {
        {
#line 1663
        success = demangle_args(work, mangled, declp);
        }
      } else
#line 1655
      if (work->options & (1 << 9)) {
        {
#line 1663
        success = demangle_args(work, mangled, declp);
        }
      }
    }
  }
#line 1666
  if (success) {
#line 1666
    if (work->options & 1) {
#line 1668
      if (work->static_type) {
        {
#line 1669
        string_append(declp, " static");
        }
      }
#line 1670
      if (work->type_quals != 0) {
#line 1672
        if (! ((unsigned long )declp->b == (unsigned long )declp->p)) {
          {
#line 1672
          string_append(declp, " ");
          }
        }
        {
#line 1673
        tmp___3 = qualifier_string(work->type_quals);
#line 1673
        string_append(declp, tmp___3);
        }
      }
    }
  }
#line 1677
  return (success);
}
}
#line 1703 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_template_template_parm(struct work_stuff *work , char const   **mangled ,
                                           string *tname ) 
{ 
  int i ;
  int r ;
  int need_comma ;
  int success ;
  string temp ;
  int tmp___0 ;

  {
  {
#line 1709
  need_comma = 0;
#line 1710
  success = 1;
#line 1713
  string_append(tname, "template <");
#line 1715
  tmp___0 = get_count(mangled, & r);
  }
#line 1715
  if (tmp___0) {
#line 1717
    i = 0;
    {
#line 1717
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1717
      if (! (i < r)) {
#line 1717
        goto while_break;
      }
#line 1719
      if (need_comma) {
        {
#line 1721
        string_append(tname, ", ");
        }
      }
#line 1725
      if ((int const   )*(*mangled) == 90) {
        {
#line 1727
        (*mangled) ++;
#line 1728
        string_append(tname, "class");
        }
      } else
#line 1731
      if ((int const   )*(*mangled) == 122) {
        {
#line 1733
        (*mangled) ++;
#line 1734
        success = demangle_template_template_parm(work, mangled, tname);
        }
#line 1736
        if (! success) {
#line 1738
          goto while_break;
        }
      } else {
        {
#line 1744
        success = do_type(work, mangled, & temp);
        }
#line 1745
        if (success) {
          {
#line 1747
          string_appends(tname, & temp);
          }
        }
        {
#line 1749
        string_delete(& temp);
        }
#line 1750
        if (! success) {
#line 1752
          goto while_break;
        }
      }
#line 1755
      need_comma = 1;
#line 1717
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1759
  if ((int )*(tname->p + -1) == 62) {
    {
#line 1760
    string_append(tname, " ");
    }
  }
  {
#line 1761
  string_append(tname, "> class");
  }
#line 1762
  return (success);
}
}
#line 1765 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_expression(struct work_stuff *work , char const   **mangled ,
                               string *s , type_kind_t tk ) 
{ 
  int need_operator ;
  int success ;
  size_t i ;
  size_t len ;
  size_t l ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1769
  need_operator = 0;
#line 1772
  success = 1;
#line 1773
  string_appendn(s, "(", 1);
#line 1774
  (*mangled) ++;
  }
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1775
    if (success) {
#line 1775
      if ((int const   )*(*mangled) != 87) {
#line 1775
        if (! ((int const   )*(*mangled) != 0)) {
#line 1775
          goto while_break;
        }
      } else {
#line 1775
        goto while_break;
      }
    } else {
#line 1775
      goto while_break;
    }
#line 1777
    if (need_operator) {
      {
#line 1782
      success = 0;
#line 1784
      len = strlen(*mangled);
#line 1786
      i = (size_t )0;
      }
      {
#line 1786
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1786
        if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 1786
          goto while_break___0;
        }
        {
#line 1788
        tmp___0 = strlen((char const   *)optable[i].in);
#line 1788
        l = tmp___0;
        }
#line 1790
        if (l <= len) {
          {
#line 1790
          tmp___1 = memcmp((void const   *)optable[i].in, (void const   *)*mangled,
                           l);
          }
#line 1790
          if (tmp___1 == 0) {
            {
#line 1793
            string_appendn(s, " ", 1);
#line 1794
            string_append(s, (char const   *)optable[i].out);
#line 1795
            string_appendn(s, " ", 1);
#line 1796
            success = 1;
#line 1797
            *mangled += l;
            }
#line 1798
            goto while_break___0;
          }
        }
#line 1786
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1802
      if (! success) {
#line 1803
        goto while_break;
      }
    } else {
#line 1806
      need_operator = 1;
    }
    {
#line 1808
    success = demangle_template_value_parm(work, mangled, s, tk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1811
  if ((int const   )*(*mangled) != 87) {
#line 1812
    success = 0;
  } else {
    {
#line 1815
    string_appendn(s, ")", 1);
#line 1816
    (*mangled) ++;
    }
  }
#line 1819
  return (success);
}
}
#line 1822 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_integral_value(struct work_stuff *work , char const   **mangled ,
                                   string *s ) 
{ 
  int success ;
  int value ;
  int multidigit_without_leading_underscore ;
  int leave_following_underscore ;
  char buf___4[32] ;

  {
#line 1828
  if ((int const   )*(*mangled) == 69) {
    {
#line 1829
    success = demangle_expression(work, mangled, s, (type_kind_t )3);
    }
  } else
#line 1830
  if ((int const   )*(*mangled) == 81) {
    {
#line 1831
    success = demangle_qualified(work, mangled, s, 0, 1);
    }
  } else
#line 1830
  if ((int const   )*(*mangled) == 75) {
    {
#line 1831
    success = demangle_qualified(work, mangled, s, 0, 1);
    }
  } else {
#line 1838
    multidigit_without_leading_underscore = 0;
#line 1839
    leave_following_underscore = 0;
#line 1841
    success = 0;
#line 1843
    if ((int const   )*(*mangled) == 95) {
#line 1845
      if ((int const   )*(*(mangled + 0) + 1) == 109) {
        {
#line 1851
        multidigit_without_leading_underscore = 1;
#line 1852
        string_appendn(s, "-", 1);
#line 1853
        *mangled += 2;
        }
      } else {
#line 1860
        leave_following_underscore = 1;
      }
    } else {
#line 1866
      if ((int const   )*(*mangled) == 109) {
        {
#line 1868
        string_appendn(s, "-", 1);
#line 1869
        (*mangled) ++;
        }
      }
#line 1875
      multidigit_without_leading_underscore = 1;
#line 1878
      leave_following_underscore = 1;
    }
#line 1885
    if (multidigit_without_leading_underscore) {
      {
#line 1886
      value = consume_count(mangled);
      }
    } else {
      {
#line 1888
      value = consume_count_with_underscores(mangled);
      }
    }
#line 1890
    if (value != -1) {
      {
#line 1893
      sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%d",
              value);
#line 1894
      string_append(s, (char const   *)(buf___4));
      }
#line 1903
      if (value > 9) {
#line 1903
        goto _L;
      } else
#line 1903
      if (multidigit_without_leading_underscore) {
        _L: /* CIL Label */ 
#line 1903
        if (! leave_following_underscore) {
#line 1903
          if ((int const   )*(*mangled) == 95) {
#line 1906
            (*mangled) ++;
          }
        }
      }
#line 1909
      success = 1;
    }
  }
#line 1913
  return (success);
}
}
#line 1918 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_real_value(struct work_stuff *work , char const   **mangled ,
                               string *s ) 
{ 
  int tmp___0 ;

  {
#line 1922
  if ((int const   )*(*mangled) == 69) {
    {
#line 1923
    tmp___0 = demangle_expression(work, mangled, s, (type_kind_t )6);
    }
#line 1923
    return (tmp___0);
  }
#line 1925
  if ((int const   )*(*mangled) == 109) {
    {
#line 1927
    string_appendn(s, "-", 1);
#line 1928
    (*mangled) ++;
    }
  }
  {
#line 1930
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1930
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1930
      goto while_break;
    }
    {
#line 1932
    string_appendn(s, *mangled, 1);
#line 1933
    (*mangled) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1935
  if ((int const   )*(*mangled) == 46) {
    {
#line 1937
    string_appendn(s, ".", 1);
#line 1938
    (*mangled) ++;
    }
    {
#line 1939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1939
      if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1939
        goto while_break___0;
      }
      {
#line 1941
      string_appendn(s, *mangled, 1);
#line 1942
      (*mangled) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1945
  if ((int const   )*(*mangled) == 101) {
    {
#line 1947
    string_appendn(s, "e", 1);
#line 1948
    (*mangled) ++;
    }
    {
#line 1949
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1949
      if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 1949
        goto while_break___1;
      }
      {
#line 1951
      string_appendn(s, *mangled, 1);
#line 1952
      (*mangled) ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1956
  return (1);
}
}
#line 1959 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_template_value_parm(struct work_stuff *work , char const   **mangled ,
                                        string *s , type_kind_t tk ) 
{ 
  int success ;
  int idx___0 ;
  int tmp___0 ;
  char tmp___1[2] ;
  int val ;
  int val___0 ;
  int tmp___2 ;
  int symbol_len ;
  int tmp___3 ;
  char *p ;
  void *tmp___4 ;
  char *q ;

  {
#line 1963
  success = 1;
#line 1965
  if ((int const   )*(*mangled) == 89) {
    {
#line 1970
    (*mangled) ++;
#line 1971
    idx___0 = consume_count_with_underscores(mangled);
    }
#line 1972
    if (idx___0 == -1) {
#line 1975
      return (-1);
    } else
#line 1972
    if (work->tmpl_argvec) {
#line 1972
      if (idx___0 >= work->ntmpl_args) {
#line 1975
        return (-1);
      } else {
#line 1972
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1972
      tmp___0 = consume_count_with_underscores(mangled);
      }
#line 1972
      if (tmp___0 == -1) {
#line 1975
        return (-1);
      }
    }
#line 1976
    if (work->tmpl_argvec) {
      {
#line 1977
      string_append(s, (char const   *)*(work->tmpl_argvec + idx___0));
      }
    } else {
      {
#line 1979
      string_append_template_idx(s, idx___0);
      }
    }
  } else
#line 1981
  if ((unsigned int )tk == 3U) {
    {
#line 1982
    success = demangle_integral_value(work, mangled, s);
    }
  } else
#line 1983
  if ((unsigned int )tk == 5U) {
#line 1987
    if ((int const   )*(*mangled) == 109) {
      {
#line 1989
      string_appendn(s, "-", 1);
#line 1990
      (*mangled) ++;
      }
    }
    {
#line 1992
    string_appendn(s, "\'", 1);
#line 1993
    val = consume_count(mangled);
    }
#line 1994
    if (val <= 0) {
#line 1995
      success = 0;
    } else {
      {
#line 1998
      tmp___1[0] = (char )val;
#line 1999
      tmp___1[1] = (char )'\000';
#line 2000
      string_appendn(s, (char const   *)(& tmp___1[0]), 1);
#line 2001
      string_appendn(s, "\'", 1);
      }
    }
  } else
#line 2004
  if ((unsigned int )tk == 4U) {
    {
#line 2006
    tmp___2 = consume_count(mangled);
#line 2006
    val___0 = tmp___2;
    }
#line 2007
    if (val___0 == 0) {
      {
#line 2008
      string_appendn(s, "false", 5);
      }
    } else
#line 2009
    if (val___0 == 1) {
      {
#line 2010
      string_appendn(s, "true", 4);
      }
    } else {
#line 2012
      success = 0;
    }
  } else
#line 2014
  if ((unsigned int )tk == 6U) {
    {
#line 2015
    success = demangle_real_value(work, mangled, s);
    }
  } else
#line 2016
  if ((unsigned int )tk == 1U) {
#line 2016
    goto _L___0;
  } else
#line 2016
  if ((unsigned int )tk == 2U) {
    _L___0: /* CIL Label */ 
#line 2018
    if ((int const   )*(*mangled) == 81) {
      {
#line 2019
      success = demangle_qualified(work, mangled, s, 0, 1);
      }
    } else {
      {
#line 2024
      tmp___3 = consume_count(mangled);
#line 2024
      symbol_len = tmp___3;
      }
#line 2025
      if (symbol_len == -1) {
#line 2026
        return (-1);
      }
#line 2027
      if (symbol_len == 0) {
        {
#line 2028
        string_appendn(s, "0", 1);
        }
      } else {
        {
#line 2031
        tmp___4 = xmalloc(sizeof(char ) * (unsigned long )(symbol_len + 1));
#line 2031
        p = (char *)tmp___4;
#line 2032
        strncpy((char */* __restrict  */)p, (char const   */* __restrict  */)*mangled,
                (size_t )symbol_len);
#line 2033
        *(p + symbol_len) = (char )'\000';
#line 2039
        q = cplus_demangle((char const   *)p, work->options);
        }
#line 2040
        if ((unsigned int )tk == 1U) {
          {
#line 2041
          string_appendn(s, "&", 1);
          }
        }
#line 2044
        if (q) {
          {
#line 2046
          string_append(s, (char const   *)q);
#line 2047
          free((void *)q);
          }
        } else {
          {
#line 2050
          string_append(s, (char const   *)p);
          }
        }
        {
#line 2051
        free((void *)p);
        }
      }
#line 2053
      *mangled += symbol_len;
    }
  }
#line 2057
  return (success);
}
}
#line 2068 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_template(struct work_stuff *work , char const   **mangled , string *tname ,
                             string *trawname , int is_type , int remember ) 
{ 
  int i ;
  int r ;
  int need_comma ;
  int success ;
  int is_java_array ;
  string temp ;
  int idx___0 ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int len ;
  void *tmp___6 ;
  int r2 ;
  int len___0 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  string param ;
  string *s ;
  int len___1 ;
  void *tmp___9 ;
  int bindex ;
  int tmp___10 ;
  long tmp___11 ;

  {
#line 2075
  need_comma = 0;
#line 2076
  success = 0;
#line 2077
  is_java_array = 0;
#line 2080
  (*mangled) ++;
#line 2081
  if (is_type) {
#line 2084
    if ((int const   )*(*mangled) == 122) {
      {
#line 2087
      (*mangled) ++;
#line 2088
      (*mangled) ++;
#line 2090
      idx___0 = consume_count_with_underscores(mangled);
      }
#line 2091
      if (idx___0 == -1) {
#line 2094
        return (0);
      } else
#line 2091
      if (work->tmpl_argvec) {
#line 2091
        if (idx___0 >= work->ntmpl_args) {
#line 2094
          return (0);
        } else {
#line 2091
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 2091
        tmp___0 = consume_count_with_underscores(mangled);
        }
#line 2091
        if (tmp___0 == -1) {
#line 2094
          return (0);
        }
      }
#line 2096
      if (work->tmpl_argvec) {
        {
#line 2098
        string_append(tname, (char const   *)*(work->tmpl_argvec + idx___0));
        }
#line 2099
        if (trawname) {
          {
#line 2100
          string_append(trawname, (char const   *)*(work->tmpl_argvec + idx___0));
          }
        }
      } else {
        {
#line 2104
        string_append_template_idx(tname, idx___0);
        }
#line 2105
        if (trawname) {
          {
#line 2106
          string_append_template_idx(trawname, idx___0);
          }
        }
      }
    } else {
      {
#line 2111
      r = consume_count(mangled);
      }
#line 2111
      if (r <= 0) {
#line 2114
        return (0);
      } else {
        {
#line 2111
        tmp___1 = strlen(*mangled);
        }
#line 2111
        if ((int )tmp___1 < r) {
#line 2114
          return (0);
        }
      }
#line 2116
      if (work->options & (1 << 2)) {
        {
#line 2116
        tmp___2 = strncmp(*mangled, "JArray1Z", (size_t )8);
        }
#line 2116
        if (tmp___2 == 0) {
#line 2116
          tmp___3 = 1;
        } else {
#line 2116
          tmp___3 = 0;
        }
      } else {
#line 2116
        tmp___3 = 0;
      }
#line 2116
      is_java_array = tmp___3;
#line 2118
      if (! is_java_array) {
        {
#line 2120
        string_appendn(tname, *mangled, r);
        }
      }
#line 2122
      if (trawname) {
        {
#line 2123
        string_appendn(trawname, *mangled, r);
        }
      }
#line 2124
      *mangled += r;
    }
  }
#line 2127
  if (! is_java_array) {
    {
#line 2128
    string_append(tname, "<");
    }
  }
  {
#line 2130
  tmp___4 = get_count(mangled, & r);
  }
#line 2130
  if (! tmp___4) {
#line 2132
    return (0);
  }
#line 2134
  if (! is_type) {
    {
#line 2137
    tmp___5 = xmalloc(sizeof(char *) * (unsigned long )r);
#line 2137
    work->tmpl_argvec = (char **)tmp___5;
#line 2138
    work->ntmpl_args = r;
#line 2139
    i = 0;
    }
    {
#line 2139
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2139
      if (! (i < r)) {
#line 2139
        goto while_break;
      }
#line 2140
      *(work->tmpl_argvec + i) = (char *)0;
#line 2139
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2142
  i = 0;
  {
#line 2142
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2142
    if (! (i < r)) {
#line 2142
      goto while_break___0;
    }
#line 2144
    if (need_comma) {
      {
#line 2146
      string_append(tname, ", ");
      }
    }
#line 2149
    if ((int const   )*(*mangled) == 90) {
      {
#line 2151
      (*mangled) ++;
#line 2153
      success = do_type(work, mangled, & temp);
      }
#line 2154
      if (success) {
        {
#line 2156
        string_appends(tname, & temp);
        }
#line 2158
        if (! is_type) {
          {
#line 2161
          len = (int )(temp.p - temp.b);
#line 2162
          tmp___6 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 2162
          *(work->tmpl_argvec + i) = (char *)tmp___6;
#line 2163
          memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)temp.b,
                 (size_t )len);
#line 2164
          *(*(work->tmpl_argvec + i) + len) = (char )'\000';
          }
        }
      }
      {
#line 2167
      string_delete(& temp);
      }
#line 2168
      if (! success) {
#line 2170
        goto while_break___0;
      }
    } else
#line 2174
    if ((int const   )*(*mangled) == 122) {
      {
#line 2177
      (*mangled) ++;
#line 2178
      success = demangle_template_template_parm(work, mangled, tname);
      }
#line 2180
      if (success) {
        {
#line 2180
        r2 = consume_count(mangled);
        }
#line 2180
        if (r2 > 0) {
          {
#line 2180
          tmp___8 = strlen(*mangled);
          }
#line 2180
          if ((int )tmp___8 >= r2) {
            {
#line 2184
            string_append(tname, " ");
#line 2185
            string_appendn(tname, *mangled, r2);
            }
#line 2186
            if (! is_type) {
              {
#line 2189
              len___0 = r2;
#line 2190
              tmp___7 = xmalloc(sizeof(char ) * (unsigned long )(len___0 + 1));
#line 2190
              *(work->tmpl_argvec + i) = (char *)tmp___7;
#line 2191
              memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)*mangled,
                     (size_t )len___0);
#line 2192
              *(*(work->tmpl_argvec + i) + len___0) = (char )'\000';
              }
            }
#line 2194
            *mangled += r2;
          }
        }
      }
#line 2196
      if (! success) {
#line 2198
        goto while_break___0;
      }
    } else {
      {
#line 2209
      success = do_type(work, mangled, & temp);
#line 2210
      string_delete(& temp);
      }
#line 2211
      if (! success) {
#line 2212
        goto while_break___0;
      }
#line 2214
      if (! is_type) {
        {
#line 2216
        s = & param;
#line 2217
        string_init(s);
        }
      } else {
#line 2220
        s = tname;
      }
      {
#line 2222
      success = demangle_template_value_parm(work, mangled, s, (type_kind_t )success);
      }
#line 2225
      if (! success) {
#line 2227
        if (! is_type) {
          {
#line 2228
          string_delete(s);
          }
        }
#line 2229
        success = 0;
#line 2230
        goto while_break___0;
      }
#line 2233
      if (! is_type) {
        {
#line 2235
        len___1 = (int )(s->p - s->b);
#line 2236
        tmp___9 = xmalloc(sizeof(char ) * (unsigned long )(len___1 + 1));
#line 2236
        *(work->tmpl_argvec + i) = (char *)tmp___9;
#line 2237
        memcpy((void */* __restrict  */)*(work->tmpl_argvec + i), (void const   */* __restrict  */)s->b,
               (size_t )len___1);
#line 2238
        *(*(work->tmpl_argvec + i) + len___1) = (char )'\000';
#line 2240
        string_appends(tname, s);
#line 2241
        string_delete(s);
        }
      }
    }
#line 2244
    need_comma = 1;
#line 2142
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2246
  if (is_java_array) {
    {
#line 2248
    string_append(tname, "[]");
    }
  } else {
#line 2252
    if ((int )*(tname->p + -1) == 62) {
      {
#line 2253
      string_append(tname, " ");
      }
    }
    {
#line 2254
    string_append(tname, ">");
    }
  }
#line 2257
  if (is_type) {
#line 2257
    if (remember) {
      {
#line 2259
      tmp___10 = register_Btype(work);
#line 2259
      bindex = tmp___10;
      }
#line 2260
      if ((unsigned long )tname->b == (unsigned long )tname->p) {
#line 2260
        tmp___11 = 0L;
      } else {
#line 2260
        tmp___11 = tname->p - tname->b;
      }
      {
#line 2260
      remember_Btype(work, (char const   *)tname->b, (int )tmp___11, bindex);
      }
    }
  }
#line 2276
  return (success);
}
}
#line 2279 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int arm_pt(struct work_stuff *work , char const   *mangled , int n , char const   **anchor ,
                  char const   **args ) 
{ 
  int len ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int len___0 ;
  int len___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
#line 2285
  if (work->options & (1 << 11)) {
#line 2285
    goto _L;
  } else
#line 2285
  if (work->options & (1 << 12)) {
    _L: /* CIL Label */ 
    {
#line 2285
    tmp___1 = strstr(mangled, "__pt__");
#line 2285
    tmp___0 = (char const   *)tmp___1;
#line 2285
    *anchor = tmp___0;
    }
#line 2285
    if (tmp___0) {
      {
#line 2288
      *args = *anchor + 6;
#line 2289
      len = consume_count(args);
      }
#line 2290
      if (len == -1) {
#line 2291
        return (0);
      }
#line 2292
      if ((unsigned long )(*args + len) == (unsigned long )(mangled + n)) {
#line 2292
        if ((int const   )*(*args) == 95) {
#line 2294
          (*args) ++;
#line 2295
          return (1);
        }
      }
    }
  }
#line 2298
  if (work->options & (1 << 8)) {
#line 2298
    goto _L___1;
  } else
#line 2298
  if (work->options & (1 << 13)) {
    _L___1: /* CIL Label */ 
    {
#line 2300
    tmp___5 = strstr(mangled, "__tm__");
#line 2300
    tmp___4 = (char const   *)tmp___5;
#line 2300
    *anchor = tmp___4;
    }
#line 2300
    if (tmp___4) {
#line 2300
      goto _L___0;
    } else {
      {
#line 2300
      tmp___7 = strstr(mangled, "__ps__");
#line 2300
      tmp___6 = (char const   *)tmp___7;
#line 2300
      *anchor = tmp___6;
      }
#line 2300
      if (tmp___6) {
#line 2300
        goto _L___0;
      } else {
        {
#line 2300
        tmp___9 = strstr(mangled, "__pt__");
#line 2300
        tmp___8 = (char const   *)tmp___9;
#line 2300
        *anchor = tmp___8;
        }
#line 2300
        if (tmp___8) {
          _L___0: /* CIL Label */ 
          {
#line 2305
          *args = *anchor + 6;
#line 2306
          len___0 = consume_count(args);
          }
#line 2307
          if (len___0 == -1) {
#line 2308
            return (0);
          }
#line 2309
          if ((unsigned long )(*args + len___0) == (unsigned long )(mangled + n)) {
#line 2309
            if ((int const   )*(*args) == 95) {
#line 2311
              (*args) ++;
#line 2312
              return (1);
            }
          }
        } else {
          {
#line 2315
          tmp___3 = strstr(mangled, "__S");
#line 2315
          tmp___2 = (char const   *)tmp___3;
#line 2315
          *anchor = tmp___2;
          }
#line 2315
          if (tmp___2) {
            {
#line 2318
            *args = *anchor + 3;
#line 2319
            len___1 = consume_count(args);
            }
#line 2320
            if (len___1 == -1) {
#line 2321
              return (0);
            }
#line 2322
            if ((unsigned long )(*args + len___1) == (unsigned long )(mangled + n)) {
#line 2322
              if ((int const   )*(*args) == 95) {
#line 2324
                (*args) ++;
#line 2325
                return (1);
              }
            }
          }
        }
      }
    }
  }
#line 2330
  return (0);
}
}
#line 2333 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void demangle_arm_hp_template(struct work_stuff *work , char const   **mangled ,
                                     int n , string *declp ) 
{ 
  char const   *p ;
  char const   *args ;
  char const   *e ;
  string arg ;
  char *start_spec_args ;
  int hold_options ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int hold_options___0 ;
  string type_str ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char const   *old_args ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
#line 2339
  e = *mangled + n;
#line 2344
  if (work->options & (1 << 12)) {
#line 2344
    if ((int const   )*(*mangled + n) == 88) {
      {
#line 2346
      start_spec_args = (char *)((void *)0);
#line 2351
      start_spec_args = strchr(*mangled, '<');
      }
#line 2352
      if (start_spec_args) {
#line 2352
        if (start_spec_args - (char *)*mangled < (long )n) {
          {
#line 2353
          string_appendn(declp, *mangled, (int )(start_spec_args - (char *)*mangled));
          }
        } else {
          {
#line 2355
          string_appendn(declp, *mangled, n);
          }
        }
      } else {
        {
#line 2355
        string_appendn(declp, *mangled, n);
        }
      }
      {
#line 2356
      *mangled += n + 1;
#line 2357
      string_init(& arg);
      }
#line 2358
      if (work->temp_start == -1) {
#line 2359
        work->temp_start = (int )(declp->p - declp->b);
      }
      {
#line 2363
      hold_options = work->options;
#line 2364
      work->options |= 1;
#line 2366
      string_append(declp, "<");
      }
      {
#line 2367
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 2369
        string_delete(& arg);
        }
        {
#line 2372
        if ((int const   )*(*mangled) == 84) {
#line 2372
          goto case_84;
        }
#line 2380
        if ((int const   )*(*mangled) == 83) {
#line 2380
          goto case_83;
        }
#line 2380
        if ((int const   )*(*mangled) == 85) {
#line 2380
          goto case_83;
        }
#line 2386
        if ((int const   )*(*mangled) == 65) {
#line 2386
          goto case_65;
        }
#line 2392
        goto switch_default;
        case_84: /* CIL Label */ 
        {
#line 2374
        (*mangled) ++;
#line 2375
        tmp___0 = do_type(work, mangled, & arg);
        }
#line 2375
        if (! tmp___0) {
#line 2376
          goto hpacc_template_args_done;
        }
#line 2377
        goto switch_break;
        case_83: /* CIL Label */ 
        case_85: /* CIL Label */ 
        {
#line 2382
        tmp___1 = do_hpacc_template_const_value(work, mangled, & arg);
        }
#line 2382
        if (! tmp___1) {
#line 2383
          goto hpacc_template_args_done;
        }
#line 2384
        goto switch_break;
        case_65: /* CIL Label */ 
        {
#line 2388
        tmp___2 = do_hpacc_template_literal(work, mangled, & arg);
        }
#line 2388
        if (! tmp___2) {
#line 2389
          goto hpacc_template_args_done;
        }
#line 2390
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2396
        goto hpacc_template_args_done;
        switch_break: /* CIL Label */ ;
        }
        {
#line 2398
        string_appends(declp, & arg);
        }
#line 2402
        if ((int const   )*(*mangled) == 0) {
#line 2403
          goto while_break;
        } else
#line 2402
        if ((int const   )*(*mangled) == 95) {
#line 2403
          goto while_break;
        } else {
          {
#line 2405
          string_append(declp, ",");
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      hpacc_template_args_done: 
      {
#line 2408
      string_append(declp, ">");
#line 2409
      string_delete(& arg);
      }
#line 2410
      if ((int const   )*(*mangled) == 95) {
#line 2411
        (*mangled) ++;
      }
#line 2412
      work->options = hold_options;
#line 2413
      return;
    } else {
#line 2344
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 2416
    tmp___9 = arm_pt(work, *mangled, n, & p, & args);
    }
#line 2416
    if (tmp___9) {
      {
#line 2421
      string_init(& arg);
#line 2422
      string_appendn(declp, *mangled, (int )(p - *mangled));
      }
#line 2423
      if (work->temp_start == -1) {
#line 2424
        work->temp_start = (int )(declp->p - declp->b);
      }
      {
#line 2428
      hold_options___0 = work->options;
#line 2429
      work->options |= 1;
#line 2431
      string_append(declp, "<");
      }
      {
#line 2433
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2433
        if (! ((unsigned long )args < (unsigned long )e)) {
#line 2433
          goto while_break___0;
        }
        {
#line 2434
        string_delete(& arg);
        }
        {
#line 2442
        if ((int const   )*args == 88) {
#line 2442
          goto case_88;
        }
#line 2459
        if ((int const   )*args == 76) {
#line 2459
          goto case_76;
        }
#line 2465
        goto switch_default___0;
        case_88: /* CIL Label */ 
        {
#line 2444
        args ++;
#line 2445
        tmp___3 = do_type(work, & args, & type_str);
        }
#line 2445
        if (! tmp___3) {
#line 2446
          goto cfront_template_args_done;
        }
        {
#line 2447
        string_append(& arg, "(");
#line 2448
        string_appends(& arg, & type_str);
#line 2449
        string_delete(& type_str);
#line 2450
        string_append(& arg, ")");
        }
#line 2451
        if ((int const   )*args != 76) {
#line 2452
          goto cfront_template_args_done;
        }
        {
#line 2453
        args ++;
#line 2455
        tmp___4 = snarf_numeric_literal(& args, & arg);
        }
#line 2455
        if (! tmp___4) {
#line 2456
          goto cfront_template_args_done;
        }
#line 2457
        goto switch_break___0;
        case_76: /* CIL Label */ 
        {
#line 2461
        args ++;
#line 2462
        tmp___5 = snarf_numeric_literal(& args, & arg);
        }
#line 2462
        if (! tmp___5) {
#line 2463
          goto cfront_template_args_done;
        }
#line 2464
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 2468
        old_args = args;
#line 2469
        tmp___6 = do_type(work, & args, & arg);
        }
#line 2469
        if (! tmp___6) {
#line 2470
          goto cfront_template_args_done;
        }
#line 2473
        if ((unsigned long )args == (unsigned long )old_args) {
#line 2475
          work->options = hold_options___0;
#line 2476
          return;
        }
        switch_break___0: /* CIL Label */ ;
        }
        {
#line 2480
        string_appends(declp, & arg);
#line 2481
        string_append(declp, ",");
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      cfront_template_args_done: 
      {
#line 2484
      string_delete(& arg);
      }
#line 2485
      if ((unsigned long )args >= (unsigned long )e) {
#line 2486
        (declp->p) --;
      }
      {
#line 2487
      string_append(declp, ">");
#line 2488
      work->options = hold_options___0;
      }
    } else
#line 2490
    if (n > 10) {
      {
#line 2490
      tmp___7 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
      }
#line 2490
      if (tmp___7 == 0) {
#line 2490
        if ((int const   )*(*mangled + 9) == 78) {
#line 2490
          if ((int const   )*(*mangled + 8) == (int const   )*(*mangled + 10)) {
            {
#line 2490
            tmp___8 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
            }
#line 2490
            if (tmp___8) {
              {
#line 2496
              string_append(declp, "{anonymous}");
              }
            } else {
#line 2490
              goto _L___2;
            }
          } else {
#line 2490
            goto _L___2;
          }
        } else {
#line 2490
          goto _L___2;
        }
      } else {
#line 2490
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 2500
      if (work->temp_start == -1) {
#line 2501
        work->temp_start = 0;
      }
      {
#line 2502
      string_appendn(declp, *mangled, n);
      }
    }
  }
#line 2504
  *mangled += n;
#line 2505
  return;
}
}
#line 2511 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_class_name(struct work_stuff *work , char const   **mangled ,
                               string *declp ) 
{ 
  int n ;
  int success ;
  size_t tmp___0 ;

  {
  {
#line 2516
  success = 0;
#line 2518
  n = consume_count(mangled);
  }
#line 2519
  if (n == -1) {
#line 2520
    return (0);
  }
  {
#line 2521
  tmp___0 = strlen(*mangled);
  }
#line 2521
  if ((int )tmp___0 >= n) {
    {
#line 2523
    demangle_arm_hp_template(work, mangled, n, declp);
#line 2524
    success = 1;
    }
  }
#line 2527
  return (success);
}
}
#line 2565 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_class(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int success ;
  int btype ;
  string class_name ;
  char *save_class_name_end ;
  long tmp___0 ;
  long tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2568
  success = 0;
#line 2571
  save_class_name_end = (char *)0;
#line 2573
  string_init(& class_name);
#line 2574
  btype = register_Btype(work);
#line 2575
  tmp___3 = demangle_class_name(work, mangled, & class_name);
  }
#line 2575
  if (tmp___3) {
#line 2577
    save_class_name_end = class_name.p;
#line 2578
    if (work->constructor & 1) {
#line 2578
      goto _L;
    } else
#line 2578
    if (work->destructor & 1) {
      _L: /* CIL Label */ 
#line 2581
      if (work->temp_start) {
#line 2581
        if (work->temp_start != -1) {
#line 2583
          class_name.p = class_name.b + work->temp_start;
        }
      }
      {
#line 2585
      string_prepends(declp, & class_name);
      }
#line 2586
      if (work->destructor & 1) {
        {
#line 2588
        string_prepend(declp, "~");
#line 2589
        (work->destructor) --;
        }
      } else {
#line 2593
        (work->constructor) --;
      }
    }
#line 2596
    class_name.p = save_class_name_end;
#line 2597
    if ((unsigned long )class_name.b == (unsigned long )class_name.p) {
#line 2597
      tmp___0 = 0L;
    } else {
#line 2597
      tmp___0 = class_name.p - class_name.b;
    }
    {
#line 2597
    remember_Ktype(work, (char const   *)class_name.b, (int )tmp___0);
    }
#line 2598
    if ((unsigned long )class_name.b == (unsigned long )class_name.p) {
#line 2598
      tmp___1 = 0L;
    } else {
#line 2598
      tmp___1 = class_name.p - class_name.b;
    }
    {
#line 2598
    remember_Btype(work, (char const   *)class_name.b, (int )tmp___1, btype);
    }
#line 2599
    if (work->options & (1 << 2)) {
#line 2599
      tmp___2 = ".";
    } else {
#line 2599
      tmp___2 = "::";
    }
    {
#line 2599
    string_prepend(declp, tmp___2);
#line 2600
    string_prepends(declp, & class_name);
#line 2601
    success = 1;
    }
  }
  {
#line 2603
  string_delete(& class_name);
  }
#line 2604
  return (success);
}
}
#line 2617 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int iterate_demangle_function(struct work_stuff *work , char const   **mangled ,
                                     string *declp , char const   *scan ) 
{ 
  char const   *mangle_init ;
  int success ;
  string decl_init ;
  struct work_stuff work_init ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 2621
  mangle_init = *mangled;
#line 2622
  success = 0;
#line 2626
  if ((int const   )*(scan + 2) == 0) {
#line 2627
    return (0);
  }
#line 2631
  if (work->options & (1 << 11)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else
#line 2631
  if (work->options & (1 << 10)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else
#line 2631
  if (work->options & (1 << 12)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else
#line 2631
  if (work->options & (1 << 13)) {
    {
#line 2633
    tmp___0 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2633
    return (tmp___0);
  } else {
    {
#line 2631
    tmp___1 = strstr(scan + 2, "__");
    }
#line 2631
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 2633
      tmp___0 = demangle_function_name(work, mangled, declp, scan);
      }
#line 2633
      return (tmp___0);
    }
  }
  {
#line 2637
  string_init(& decl_init);
#line 2638
  string_appends(& decl_init, declp);
#line 2639
  memset((void *)(& work_init), 0, sizeof(work_init));
#line 2640
  work_stuff_copy_to_from(& work_init, work);
  }
  {
#line 2648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2648
    if (! *(scan + 2)) {
#line 2648
      goto while_break;
    }
    {
#line 2650
    tmp___2 = demangle_function_name(work, mangled, declp, scan);
    }
#line 2650
    if (tmp___2) {
      {
#line 2652
      success = demangle_signature(work, mangled, declp);
      }
#line 2653
      if (success) {
#line 2654
        goto while_break;
      }
    }
    {
#line 2658
    *mangled = mangle_init;
#line 2659
    string_clear(declp);
#line 2660
    string_appends(declp, & decl_init);
#line 2661
    work_stuff_copy_to_from(work, & work_init);
#line 2664
    scan += 2;
    }
    {
#line 2667
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2667
      if (*scan) {
#line 2667
        if (! ((int const   )*(scan + 0) != 95)) {
#line 2667
          if (! ((int const   )*(scan + 1) != 95)) {
#line 2667
            goto while_break___0;
          }
        }
      } else {
#line 2667
        goto while_break___0;
      }
#line 2668
      scan ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2671
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2671
      if (*scan) {
#line 2671
        if (! ((int const   )*scan == 95)) {
#line 2671
          goto while_break___1;
        }
      } else {
#line 2671
        goto while_break___1;
      }
#line 2672
      scan ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2673
    scan -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2677
  delete_work_stuff(& work_init);
#line 2678
  string_delete(& decl_init);
  }
#line 2680
  return (success);
}
}
#line 2716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_prefix(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int success ;
  char const   *scan ;
  int i ;
  char *marker ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  size_t tmp___19 ;

  {
  {
#line 2720
  success = 1;
#line 2724
  tmp___7 = strlen(*mangled);
  }
#line 2724
  if (tmp___7 > 6UL) {
    {
#line 2724
    tmp___8 = strncmp(*mangled, "_imp__", (size_t )6);
    }
#line 2724
    if (tmp___8 == 0) {
#line 2731
      *mangled += 6;
#line 2732
      work->dllimported = 1;
    } else {
      {
#line 2724
      tmp___9 = strncmp(*mangled, "__imp_", (size_t )6);
      }
#line 2724
      if (tmp___9 == 0) {
#line 2731
        *mangled += 6;
#line 2732
        work->dllimported = 1;
      } else {
#line 2724
        goto _L___3;
      }
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 2734
    tmp___5 = strlen(*mangled);
    }
#line 2734
    if (tmp___5 >= 11UL) {
      {
#line 2734
      tmp___6 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
      }
#line 2734
      if (tmp___6 == 0) {
        {
#line 2736
        tmp___0 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
#line 2736
        marker = tmp___0;
        }
#line 2737
        if ((unsigned long )marker != (unsigned long )((void *)0)) {
#line 2737
          if ((int )*marker == (int )*(*mangled + 10)) {
#line 2739
            if ((int const   )*(*mangled + 9) == 68) {
              {
#line 2742
              *mangled += 11;
#line 2743
              work->destructor = 2;
#line 2744
              tmp___1 = gnu_special(work, mangled, declp);
              }
#line 2744
              if (tmp___1) {
#line 2745
                return (success);
              }
            } else
#line 2747
            if ((int const   )*(*mangled + 9) == 73) {
              {
#line 2750
              *mangled += 11;
#line 2751
              work->constructor = 2;
#line 2752
              tmp___2 = gnu_special(work, mangled, declp);
              }
#line 2752
              if (tmp___2) {
#line 2753
                return (success);
              }
            }
          }
        }
      } else {
#line 2734
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2757
    if (work->options & (1 << 11)) {
#line 2757
      goto _L___1;
    } else
#line 2757
    if (work->options & (1 << 12)) {
#line 2757
      goto _L___1;
    } else
#line 2757
    if (work->options & (1 << 13)) {
      _L___1: /* CIL Label */ 
      {
#line 2757
      tmp___4 = strncmp(*mangled, "__std__", (size_t )7);
      }
#line 2757
      if (tmp___4 == 0) {
#line 2760
        *mangled += 7;
#line 2761
        work->destructor = 2;
      } else {
#line 2757
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2763
    if (work->options & (1 << 11)) {
#line 2763
      goto _L;
    } else
#line 2763
    if (work->options & (1 << 12)) {
#line 2763
      goto _L;
    } else
#line 2763
    if (work->options & (1 << 13)) {
      _L: /* CIL Label */ 
      {
#line 2763
      tmp___3 = strncmp(*mangled, "__sti__", (size_t )7);
      }
#line 2763
      if (tmp___3 == 0) {
#line 2766
        *mangled += 7;
#line 2767
        work->constructor = 2;
      }
    }
  }
#line 2775
  scan = *mangled;
  {
#line 2777
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2778
    tmp___10 = strchr(scan, '_');
#line 2778
    scan = (char const   *)tmp___10;
    }
#line 2777
    if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 2777
      scan ++;
#line 2777
      if (! ((int const   )*scan != 95)) {
#line 2777
        goto while_break;
      }
    } else {
#line 2777
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2781
  if ((unsigned long )scan != (unsigned long )((void *)0)) {
#line 2781
    scan --;
  }
#line 2784
  if ((unsigned long )scan != (unsigned long )((void *)0)) {
    {
#line 2788
    tmp___11 = strspn(scan, "_");
#line 2788
    i = (int )tmp___11;
    }
#line 2789
    if (i > 2) {
#line 2791
      scan += i - 2;
    }
  }
#line 2795
  if ((unsigned long )scan == (unsigned long )((void *)0)) {
#line 2797
    success = 0;
  } else
#line 2799
  if (work->static_type) {
#line 2801
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(scan + 0)) & 255] & 4)) {
#line 2801
      if ((int const   )*(scan + 0) != 116) {
#line 2803
        success = 0;
      }
    }
  } else
#line 2806
  if ((unsigned long )scan == (unsigned long )*mangled) {
#line 2806
    if ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 81) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 116) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 75) {
#line 2806
      goto _L___16;
    } else
#line 2806
    if ((int const   )*(scan + 2) == 72) {
      _L___16: /* CIL Label */ 
#line 2813
      if (work->options & (1 << 10)) {
#line 2813
        goto _L___5;
      } else
#line 2813
      if (work->options & (1 << 11)) {
#line 2813
        goto _L___5;
      } else
#line 2813
      if (work->options & (1 << 12)) {
        _L___5: /* CIL Label */ 
#line 2813
        if ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4) {
          {
#line 2816
          *mangled = scan + 2;
#line 2817
          consume_count(mangled);
#line 2818
          string_append(declp, *mangled);
#line 2819
          tmp___12 = strlen(*mangled);
#line 2819
          *mangled += tmp___12;
#line 2820
          success = 1;
          }
        } else {
#line 2813
          goto _L___4;
        }
      } else {
        _L___4: /* CIL Label */ 
#line 2828
        if (! (work->options & (1 << 10))) {
#line 2828
          if (! (work->options & (1 << 11))) {
#line 2828
            if (! (work->options & (1 << 12))) {
#line 2828
              if (! (work->options & (1 << 13))) {
#line 2829
                (work->constructor) ++;
              }
            }
          }
        }
#line 2830
        *mangled = scan + 2;
      }
    } else {
#line 2806
      goto _L___15;
    }
  } else
  _L___15: /* CIL Label */ 
#line 2833
  if (work->options & (1 << 11)) {
#line 2833
    if ((int const   )*(scan + 2) == 112) {
#line 2833
      if ((int const   )*(scan + 3) == 116) {
        {
#line 2836
        success = 1;
#line 2839
        tmp___13 = strlen(*mangled);
#line 2839
        demangle_arm_hp_template(work, mangled, (int )tmp___13, declp);
        }
      } else {
#line 2833
        goto _L___14;
      }
    } else {
#line 2833
      goto _L___14;
    }
  } else
  _L___14: /* CIL Label */ 
#line 2841
  if (work->options & (1 << 13)) {
#line 2841
    if ((int const   )*(scan + 2) == 116) {
#line 2841
      if ((int const   )*(scan + 3) == 109) {
        {
#line 2846
        success = 1;
#line 2849
        tmp___14 = strlen(*mangled);
#line 2849
        demangle_arm_hp_template(work, mangled, (int )tmp___14, declp);
        }
      } else {
#line 2841
        goto _L___12;
      }
    } else
    _L___12: /* CIL Label */ 
#line 2841
    if ((int const   )*(scan + 2) == 112) {
#line 2841
      if ((int const   )*(scan + 3) == 115) {
        {
#line 2846
        success = 1;
#line 2849
        tmp___14 = strlen(*mangled);
#line 2849
        demangle_arm_hp_template(work, mangled, (int )tmp___14, declp);
        }
      } else {
#line 2841
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 2841
    if ((int const   )*(scan + 2) == 112) {
#line 2841
      if ((int const   )*(scan + 3) == 116) {
        {
#line 2846
        success = 1;
#line 2849
        tmp___14 = strlen(*mangled);
#line 2849
        demangle_arm_hp_template(work, mangled, (int )tmp___14, declp);
        }
      } else {
#line 2841
        goto _L___10;
      }
    } else {
#line 2841
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 2851
  if ((unsigned long )scan == (unsigned long )*mangled) {
#line 2851
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(scan + 2)) & 255] & 4)) {
#line 2851
      if ((int const   )*(scan + 2) != 116) {
#line 2857
        if (work->options & (1 << 11)) {
#line 2857
          goto _L___7;
        } else
#line 2857
        if (work->options & (1 << 10)) {
#line 2857
          goto _L___7;
        } else
#line 2857
        if (work->options & (1 << 12)) {
#line 2857
          goto _L___7;
        } else
#line 2857
        if (work->options & (1 << 13)) {
          _L___7: /* CIL Label */ 
          {
#line 2857
          tmp___17 = arm_special(mangled, declp);
          }
#line 2857
          if (tmp___17 == 0) {
            _L___6: /* CIL Label */ 
            {
#line 2860
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 2860
              if (! ((int const   )*scan == 95)) {
#line 2860
                goto while_break___0;
              }
#line 2862
              scan ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 2864
            tmp___16 = strstr(scan, "__");
#line 2864
            scan = (char const   *)tmp___16;
            }
#line 2864
            if ((unsigned long )scan == (unsigned long )((void *)0)) {
#line 2868
              success = 0;
            } else
#line 2864
            if ((int const   )*(scan + 2) == 0) {
#line 2868
              success = 0;
            } else {
              {
#line 2871
              tmp___15 = iterate_demangle_function(work, mangled, declp, scan);
              }
#line 2871
              return (tmp___15);
            }
          }
        } else {
#line 2857
          goto _L___6;
        }
      } else {
#line 2851
        goto _L___9;
      }
    } else {
#line 2851
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2874
  if ((int const   )*(scan + 2) != 0) {
    {
#line 2880
    tmp___18 = iterate_demangle_function(work, mangled, declp, scan);
    }
#line 2880
    return (tmp___18);
  } else {
#line 2885
    success = 0;
  }
#line 2888
  if (! success) {
#line 2888
    if (work->constructor == 2) {
      {
#line 2890
      string_append(declp, *mangled);
#line 2891
      tmp___19 = strlen(*mangled);
#line 2891
      *mangled += tmp___19;
#line 2892
      success = 1;
      }
    } else
#line 2888
    if (work->destructor == 2) {
      {
#line 2890
      string_append(declp, *mangled);
#line 2891
      tmp___19 = strlen(*mangled);
#line 2891
      *mangled += tmp___19;
#line 2892
      success = 1;
      }
    }
  }
#line 2894
  return (success);
}
}
#line 2925 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int gnu_special(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  int n ;
  int success ;
  char const   *p ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  size_t tmp___9 ;
  int delta ;
  char *method ;
  char *tmp___10 ;
  char buf___4[50] ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 2929
  success = 1;
#line 2932
  if ((int const   )*(*mangled + 0) == 95) {
    {
#line 2932
    tmp___17 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 1));
    }
#line 2932
    if ((unsigned long )tmp___17 != (unsigned long )((void *)0)) {
#line 2932
      if ((int const   )*(*mangled + 2) == 95) {
#line 2937
        *mangled += 3;
#line 2938
        (work->destructor) ++;
      } else {
#line 2932
        goto _L___9;
      }
    } else {
#line 2932
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2940
  if ((int const   )*(*mangled + 0) == 95) {
#line 2940
    if ((int const   )*(*mangled + 1) == 95) {
#line 2940
      if ((int const   )*(*mangled + 2) == 118) {
#line 2940
        if ((int const   )*(*mangled + 3) == 116) {
#line 2940
          if ((int const   )*(*mangled + 4) == 95) {
#line 2940
            goto _L___4;
          } else {
#line 2940
            goto _L___7;
          }
        } else {
#line 2940
          goto _L___7;
        }
      } else {
#line 2940
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 2940
    if ((int const   )*(*mangled + 1) == 118) {
#line 2940
      if ((int const   )*(*mangled + 2) == 116) {
        {
#line 2940
        tmp___16 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 3));
        }
#line 2940
        if ((unsigned long )tmp___16 != (unsigned long )((void *)0)) {
          _L___4: /* CIL Label */ 
#line 2953
          if ((int const   )*(*mangled + 2) == 118) {
#line 2954
            *mangled += 5;
          } else {
#line 2956
            *mangled += 4;
          }
          {
#line 2957
          while (1) {
            while_continue: /* CIL Label */ ;
#line 2957
            if (! ((int const   )*(*mangled) != 0)) {
#line 2957
              goto while_break;
            }
            {
#line 2962
            if ((int const   )*(*mangled) == 75) {
#line 2962
              goto case_75;
            }
#line 2962
            if ((int const   )*(*mangled) == 81) {
#line 2962
              goto case_75;
            }
#line 2965
            if ((int const   )*(*mangled) == 116) {
#line 2965
              goto case_116;
            }
#line 2969
            goto switch_default;
            case_75: /* CIL Label */ 
            case_81: /* CIL Label */ 
            {
#line 2963
            success = demangle_qualified(work, mangled, declp, 0, 1);
            }
#line 2964
            goto switch_break;
            case_116: /* CIL Label */ 
            {
#line 2966
            success = demangle_template(work, mangled, declp, (string *)0, 1, 1);
            }
#line 2968
            goto switch_break;
            switch_default: /* CIL Label */ 
#line 2970
            if ((int const   )_sch_istable[(int )((unsigned char )*(*(mangled + 0))) & 255] & 4) {
              {
#line 2972
              n = consume_count(mangled);
#line 2977
              tmp___0 = strlen(*mangled);
              }
#line 2977
              if (n > (int )tmp___0) {
#line 2979
                success = 1;
#line 2980
                goto switch_break;
              }
            } else {
              {
#line 2985
              tmp___1 = strcspn(*mangled, (char const   *)(cplus_markers));
#line 2985
              n = (int )tmp___1;
              }
            }
            {
#line 2987
            string_appendn(declp, *mangled, n);
#line 2988
            *mangled += n;
            }
            switch_break: /* CIL Label */ ;
            }
            {
#line 2991
            tmp___2 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 2991
            p = (char const   *)tmp___2;
            }
#line 2992
            if (success) {
#line 2992
              if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2992
                goto _L;
              } else
#line 2992
              if ((unsigned long )p == (unsigned long )*mangled) {
                _L: /* CIL Label */ 
#line 2994
                if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 2996
                  if (work->options & (1 << 2)) {
#line 2996
                    tmp___3 = ".";
                  } else {
#line 2996
                    tmp___3 = "::";
                  }
                  {
#line 2996
                  string_append(declp, tmp___3);
#line 2997
                  (*mangled) ++;
                  }
                }
              } else {
#line 3002
                success = 0;
#line 3003
                goto while_break;
              }
            } else {
#line 3002
              success = 0;
#line 3003
              goto while_break;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 3006
          if (success) {
            {
#line 3007
            string_append(declp, " virtual table");
            }
          }
        } else {
#line 2940
          goto _L___3;
        }
      } else {
#line 2940
        goto _L___3;
      }
    } else {
#line 2940
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 3009
  if ((int const   )*(*mangled + 0) == 95) {
    {
#line 3009
    tmp___14 = strchr("0123456789Qt", (int )*(*mangled + 1));
    }
#line 3009
    if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
      {
#line 3009
      tmp___15 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 3009
      p = (char const   *)tmp___15;
      }
#line 3009
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 3014
        (*mangled) ++;
        {
#line 3018
        if ((int const   )*(*mangled) == 75) {
#line 3018
          goto case_75___0;
        }
#line 3018
        if ((int const   )*(*mangled) == 81) {
#line 3018
          goto case_75___0;
        }
#line 3021
        if ((int const   )*(*mangled) == 116) {
#line 3021
          goto case_116___0;
        }
#line 3024
        goto switch_default___0;
        case_75___0: /* CIL Label */ 
        case_81___0: /* CIL Label */ 
        {
#line 3019
        success = demangle_qualified(work, mangled, declp, 0, 1);
        }
#line 3020
        goto switch_break___0;
        case_116___0: /* CIL Label */ 
        {
#line 3022
        success = demangle_template(work, mangled, declp, (string *)0, 1, 1);
        }
#line 3023
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 3025
        n = consume_count(mangled);
        }
#line 3026
        if (n < 0) {
#line 3028
          success = 0;
#line 3029
          goto switch_break___0;
        } else {
          {
#line 3026
          tmp___4 = strlen(*mangled);
          }
#line 3026
          if ((long )n > (long )tmp___4) {
#line 3028
            success = 0;
#line 3029
            goto switch_break___0;
          }
        }
#line 3032
        if (n > 10) {
          {
#line 3032
          tmp___6 = strncmp(*mangled, "_GLOBAL_", (size_t )8);
          }
#line 3032
          if (tmp___6 == 0) {
#line 3032
            if ((int const   )*(*mangled + 9) == 78) {
#line 3032
              if ((int const   )*(*mangled + 8) == (int const   )*(*mangled + 10)) {
                {
#line 3032
                tmp___7 = strchr((char const   *)(cplus_markers), (int )*(*mangled + 8));
                }
#line 3032
                if (tmp___7) {
                  {
#line 3041
                  string_append(declp, "{anonymous}");
#line 3042
                  *mangled += n;
#line 3046
                  tmp___5 = strpbrk(*mangled, (char const   *)(cplus_markers));
#line 3046
                  p = (char const   *)tmp___5;
                  }
#line 3047
                  goto switch_break___0;
                }
              }
            }
          }
        }
        {
#line 3050
        string_appendn(declp, *mangled, n);
#line 3051
        *mangled += n;
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 3053
        if (success) {
#line 3053
          if ((unsigned long )p == (unsigned long )*mangled) {
#line 3057
            (*mangled) ++;
#line 3058
            if (work->options & (1 << 2)) {
#line 3058
              tmp___8 = ".";
            } else {
#line 3058
              tmp___8 = "::";
            }
            {
#line 3058
            string_append(declp, tmp___8);
#line 3059
            tmp___9 = strlen(*mangled);
#line 3059
            n = (int )tmp___9;
#line 3060
            string_appendn(declp, *mangled, n);
#line 3061
            *mangled += n;
            }
          } else {
#line 3065
            success = 0;
          }
        } else {
#line 3065
          success = 0;
        }
      } else {
#line 3009
        goto _L___2;
      }
    } else {
#line 3009
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 3068
    tmp___13 = strncmp(*mangled, "__thunk_", (size_t )8);
    }
#line 3068
    if (tmp___13 == 0) {
      {
#line 3072
      *mangled += 8;
#line 3073
      delta = consume_count(mangled);
      }
#line 3074
      if (delta == -1) {
#line 3075
        success = 0;
      } else {
        {
#line 3078
        (*mangled) ++;
#line 3078
        tmp___10 = internal_cplus_demangle(work, *mangled);
#line 3078
        method = tmp___10;
        }
#line 3080
        if (method) {
          {
#line 3083
          sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"virtual function thunk (delta:%d) for ",
                  - delta);
#line 3084
          string_append(declp, (char const   *)(buf___4));
#line 3085
          string_append(declp, (char const   *)method);
#line 3086
          free((void *)method);
#line 3087
          tmp___11 = strlen(*mangled);
#line 3087
          n = (int )tmp___11;
#line 3088
          *mangled += n;
          }
        } else {
#line 3092
          success = 0;
        }
      }
    } else {
      {
#line 3096
      tmp___12 = strncmp(*mangled, "__t", (size_t )3);
      }
#line 3096
      if (tmp___12 == 0) {
#line 3096
        if ((int const   )*(*mangled + 3) == 105) {
#line 3096
          goto _L___0;
        } else
#line 3096
        if ((int const   )*(*mangled + 3) == 102) {
          _L___0: /* CIL Label */ 
#line 3099
          if ((int const   )*(*mangled + 3) == 105) {
#line 3099
            p = " type_info node";
          } else {
#line 3099
            p = " type_info function";
          }
#line 3100
          *mangled += 4;
          {
#line 3104
          if ((int const   )*(*mangled) == 75) {
#line 3104
            goto case_75___1;
          }
#line 3104
          if ((int const   )*(*mangled) == 81) {
#line 3104
            goto case_75___1;
          }
#line 3107
          if ((int const   )*(*mangled) == 116) {
#line 3107
            goto case_116___1;
          }
#line 3110
          goto switch_default___1;
          case_75___1: /* CIL Label */ 
          case_81___1: /* CIL Label */ 
          {
#line 3105
          success = demangle_qualified(work, mangled, declp, 0, 1);
          }
#line 3106
          goto switch_break___1;
          case_116___1: /* CIL Label */ 
          {
#line 3108
          success = demangle_template(work, mangled, declp, (string *)0, 1, 1);
          }
#line 3109
          goto switch_break___1;
          switch_default___1: /* CIL Label */ 
          {
#line 3111
          success = do_type(work, mangled, declp);
          }
#line 3112
          goto switch_break___1;
          switch_break___1: /* CIL Label */ ;
          }
#line 3114
          if (success) {
#line 3114
            if ((int const   )*(*mangled) != 0) {
#line 3115
              success = 0;
            }
          }
#line 3116
          if (success) {
            {
#line 3117
            string_append(declp, p);
            }
          }
        } else {
#line 3121
          success = 0;
        }
      } else {
#line 3121
        success = 0;
      }
    }
  }
#line 3123
  return (success);
}
}
#line 3126 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void recursively_demangle(struct work_stuff *work , char const   **mangled ,
                                 string *result , int namelength ) 
{ 
  char *recurse ;
  char *recurse_dem ;
  void *tmp___0 ;

  {
  {
#line 3130
  recurse = (char *)((void *)0);
#line 3131
  recurse_dem = (char *)((void *)0);
#line 3133
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )(namelength + 1));
#line 3133
  recurse = (char *)tmp___0;
#line 3134
  memcpy((void */* __restrict  */)recurse, (void const   */* __restrict  */)*mangled,
         (size_t )namelength);
#line 3135
  *(recurse + namelength) = (char )'\000';
#line 3137
  recurse_dem = cplus_demangle((char const   *)recurse, work->options);
  }
#line 3139
  if (recurse_dem) {
    {
#line 3141
    string_append(result, (char const   *)recurse_dem);
#line 3142
    free((void *)recurse_dem);
    }
  } else {
    {
#line 3146
    string_appendn(result, *mangled, namelength);
    }
  }
  {
#line 3148
  free((void *)recurse);
#line 3149
  *mangled += namelength;
  }
#line 3150
  return;
}
}
#line 3175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int arm_special(char const   **mangled , string *declp ) 
{ 
  int n ;
  int success ;
  char const   *scan ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3179
  success = 1;
#line 3182
  tmp___1 = strncmp(*mangled, "__vtbl__", (size_t )8);
  }
#line 3182
  if (tmp___1 == 0) {
#line 3188
    scan = *mangled + 8;
    {
#line 3189
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3189
      if (! ((int const   )*scan != 0)) {
#line 3189
        goto while_break;
      }
      {
#line 3191
      n = consume_count(& scan);
      }
#line 3192
      if (n == -1) {
#line 3194
        return (0);
      }
#line 3196
      scan += n;
#line 3197
      if ((int const   )*(scan + 0) == 95) {
#line 3197
        if ((int const   )*(scan + 1) == 95) {
#line 3199
          scan += 2;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3202
    *mangled += 8;
    {
#line 3203
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3203
      if (! ((int const   )*(*mangled) != 0)) {
#line 3203
        goto while_break___0;
      }
      {
#line 3205
      n = consume_count(mangled);
      }
#line 3206
      if (n == -1) {
#line 3208
        return (0);
      } else {
        {
#line 3206
        tmp___0 = strlen(*mangled);
        }
#line 3206
        if ((long )n > (long )tmp___0) {
#line 3208
          return (0);
        }
      }
      {
#line 3209
      string_prependn(declp, *mangled, n);
#line 3210
      *mangled += n;
      }
#line 3211
      if ((int const   )*(*mangled + 0) == 95) {
#line 3211
        if ((int const   )*(*mangled + 1) == 95) {
          {
#line 3213
          string_prepend(declp, "::");
#line 3214
          *mangled += 2;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3217
    string_append(declp, " virtual table");
    }
  } else {
#line 3221
    success = 0;
  }
#line 3223
  return (success);
}
}
#line 3258 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_qualified(struct work_stuff *work , char const   **mangled , string *result ,
                              int isfuncname , int append ) 
{ 
  int qualifiers ;
  int success ;
  char num[2] ;
  string temp ;
  string last_name ;
  int bindex ;
  int tmp___0 ;
  int tmp___1 ;
  int idx___0 ;
  int remember_K ;
  int idx___1 ;
  int namelength ;
  long tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 3262
  qualifiers = 0;
#line 3263
  success = 1;
#line 3267
  tmp___0 = register_Btype(work);
#line 3267
  bindex = tmp___0;
  }
#line 3271
  if (isfuncname) {
#line 3271
    if (work->constructor & 1) {
#line 3271
      tmp___1 = 1;
    } else
#line 3271
    if (work->destructor & 1) {
#line 3271
      tmp___1 = 1;
    } else {
#line 3271
      tmp___1 = 0;
    }
  } else {
#line 3271
    tmp___1 = 0;
  }
  {
#line 3271
  isfuncname = tmp___1;
#line 3274
  string_init(& temp);
#line 3275
  string_init(& last_name);
  }
#line 3277
  if ((int const   )*(*mangled + 0) == 75) {
    {
#line 3281
    (*mangled) ++;
#line 3282
    idx___0 = consume_count_with_underscores(mangled);
    }
#line 3283
    if (idx___0 == -1) {
#line 3284
      success = 0;
    } else
#line 3283
    if (idx___0 >= work->numk) {
#line 3284
      success = 0;
    } else {
      {
#line 3286
      string_append(& temp, (char const   *)*(work->ktypevec + idx___0));
      }
    }
  } else {
    {
#line 3291
    if ((int const   )*(*mangled + 1) == 95) {
#line 3291
      goto case_95;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 57) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 56) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 55) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 54) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 53) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 52) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 51) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 50) {
#line 3309
      goto case_57;
    }
#line 3309
    if ((int const   )*(*mangled + 1) == 49) {
#line 3309
      goto case_57;
    }
#line 3326
    goto switch_default;
    case_95: /* CIL Label */ 
    {
#line 3295
    (*mangled) ++;
#line 3296
    qualifiers = consume_count_with_underscores(mangled);
    }
#line 3297
    if (qualifiers == -1) {
#line 3298
      success = 0;
    }
#line 3299
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    {
#line 3311
    num[0] = (char )*(*mangled + 1);
#line 3312
    num[1] = (char )'\000';
#line 3313
    qualifiers = atoi((char const   *)(num));
    }
#line 3318
    if ((int const   )*(*mangled + 2) == 95) {
#line 3320
      (*mangled) ++;
    }
#line 3322
    *mangled += 2;
#line 3323
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3327
    success = 0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 3330
  if (! success) {
#line 3331
    return (success);
  }
  {
#line 3336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3336
    tmp___4 = qualifiers;
#line 3336
    qualifiers --;
#line 3336
    if (! (tmp___4 > 0)) {
#line 3336
      goto while_break;
    }
    {
#line 3338
    remember_K = 1;
#line 3339
    string_clear(& last_name);
    }
#line 3341
    if ((int const   )*(*(mangled + 0)) == 95) {
#line 3342
      (*mangled) ++;
    }
#line 3344
    if ((int const   )*(*(mangled + 0)) == 116) {
      {
#line 3352
      success = demangle_template(work, mangled, & temp, & last_name, 1, 0);
      }
#line 3354
      if (! success) {
#line 3355
        goto while_break;
      }
    } else
#line 3357
    if ((int const   )*(*(mangled + 0)) == 75) {
      {
#line 3360
      (*mangled) ++;
#line 3361
      idx___1 = consume_count_with_underscores(mangled);
      }
#line 3362
      if (idx___1 == -1) {
#line 3363
        success = 0;
      } else
#line 3362
      if (idx___1 >= work->numk) {
#line 3363
        success = 0;
      } else {
        {
#line 3365
        string_append(& temp, (char const   *)*(work->ktypevec + idx___1));
        }
      }
#line 3366
      remember_K = 0;
#line 3368
      if (! success) {
#line 3368
        goto while_break;
      }
    } else
#line 3372
    if (work->options & (1 << 13)) {
      {
#line 3378
      namelength = consume_count(mangled);
      }
#line 3379
      if (namelength == -1) {
#line 3381
        success = 0;
#line 3382
        goto while_break;
      }
      {
#line 3384
      recursively_demangle(work, mangled, & temp, namelength);
      }
    } else {
      {
#line 3388
      string_delete(& last_name);
#line 3389
      success = do_type(work, mangled, & last_name);
      }
#line 3390
      if (! success) {
#line 3391
        goto while_break;
      }
      {
#line 3392
      string_appends(& temp, & last_name);
      }
    }
#line 3396
    if (remember_K) {
#line 3397
      if ((unsigned long )temp.b == (unsigned long )temp.p) {
#line 3397
        tmp___2 = 0L;
      } else {
#line 3397
        tmp___2 = temp.p - temp.b;
      }
      {
#line 3397
      remember_Ktype(work, (char const   *)temp.b, (int )tmp___2);
      }
    }
#line 3399
    if (qualifiers > 0) {
#line 3400
      if (work->options & (1 << 2)) {
#line 3400
        tmp___3 = ".";
      } else {
#line 3400
        tmp___3 = "::";
      }
      {
#line 3400
      string_append(& temp, tmp___3);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3403
  if ((unsigned long )temp.b == (unsigned long )temp.p) {
#line 3403
    tmp___5 = 0L;
  } else {
#line 3403
    tmp___5 = temp.p - temp.b;
  }
  {
#line 3403
  remember_Btype(work, (char const   *)temp.b, (int )tmp___5, bindex);
  }
#line 3410
  if (isfuncname) {
#line 3412
    if (work->options & (1 << 2)) {
#line 3412
      tmp___6 = ".";
    } else {
#line 3412
      tmp___6 = "::";
    }
    {
#line 3412
    string_append(& temp, tmp___6);
    }
#line 3413
    if (work->destructor & 1) {
      {
#line 3414
      string_append(& temp, "~");
      }
    }
    {
#line 3415
    string_appends(& temp, & last_name);
    }
  }
#line 3421
  if (append) {
    {
#line 3422
    string_appends(result, & temp);
    }
  } else {
#line 3425
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
#line 3426
      if (work->options & (1 << 2)) {
#line 3426
        tmp___7 = ".";
      } else {
#line 3426
        tmp___7 = "::";
      }
      {
#line 3426
      string_append(& temp, tmp___7);
      }
    }
    {
#line 3427
    string_prepends(result, & temp);
    }
  }
  {
#line 3430
  string_delete(& last_name);
#line 3431
  string_delete(& temp);
  }
#line 3432
  return (success);
}
}
#line 3481 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int get_count(char const   **type , int *count ) 
{ 
  char const   *p ;
  int n ;

  {
#line 3487
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4)) {
#line 3488
    return (0);
  } else {
#line 3491
    *count = (int )((int const   )*(*type) - 48);
#line 3492
    (*type) ++;
#line 3493
    if ((int const   )_sch_istable[(int )((unsigned char )*(*type)) & 255] & 4) {
#line 3495
      p = *type;
#line 3496
      n = *count;
      {
#line 3497
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3499
        n *= 10;
#line 3500
        n += (int )((int const   )*p - 48);
#line 3501
        p ++;
#line 3497
        if (! ((int const   )_sch_istable[(int )((unsigned char )*p) & 255] & 4)) {
#line 3497
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 3504
      if ((int const   )*p == 95) {
#line 3506
        *type = p + 1;
#line 3507
        *count = n;
      }
    }
  }
#line 3511
  return (1);
}
}
#line 3517 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int do_type(struct work_stuff *work , char const   **mangled , string *result ) 
{ 
  int n ;
  int done___0 ;
  int success ;
  string decl ;
  char const   *remembered_type ;
  int type_quals ;
  type_kind_t tk ;
  int member ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  string temp ;
  string temp___0 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int idx___0 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
  {
#line 3526
  tk = (type_kind_t )0;
#line 3528
  string_init(& decl);
#line 3529
  string_init(result);
#line 3531
  done___0 = 0;
#line 3532
  success = 1;
  }
  {
#line 3533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3533
    if (success) {
#line 3533
      if (! (! done___0)) {
#line 3533
        goto while_break;
      }
    } else {
#line 3533
      goto while_break;
    }
    {
#line 3541
    if ((int const   )*(*mangled) == 112) {
#line 3541
      goto case_112;
    }
#line 3541
    if ((int const   )*(*mangled) == 80) {
#line 3541
      goto case_112;
    }
#line 3550
    if ((int const   )*(*mangled) == 82) {
#line 3550
      goto case_82;
    }
#line 3558
    if ((int const   )*(*mangled) == 65) {
#line 3558
      goto case_65;
    }
#line 3578
    if ((int const   )*(*mangled) == 84) {
#line 3578
      goto case_84;
    }
#line 3592
    if ((int const   )*(*mangled) == 70) {
#line 3592
      goto case_70;
    }
#line 3614
    if ((int const   )*(*mangled) == 79) {
#line 3614
      goto case_79;
    }
#line 3614
    if ((int const   )*(*mangled) == 77) {
#line 3614
      goto case_79;
    }
#line 3715
    if ((int const   )*(*mangled) == 71) {
#line 3715
      goto case_71;
    }
#line 3721
    if ((int const   )*(*mangled) == 117) {
#line 3721
      goto case_117___0;
    }
#line 3721
    if ((int const   )*(*mangled) == 86) {
#line 3721
      goto case_117___0;
    }
#line 3721
    if ((int const   )*(*mangled) == 67) {
#line 3721
      goto case_117___0;
    }
#line 3736
    goto switch_default___0;
    case_112: /* CIL Label */ 
    case_80: /* CIL Label */ 
#line 3542
    (*mangled) ++;
#line 3543
    if (! (work->options & (1 << 2))) {
      {
#line 3544
      string_prepend(& decl, "*");
      }
    }
#line 3545
    if ((unsigned int )tk == 0U) {
#line 3546
      tk = (type_kind_t )1;
    }
#line 3547
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 3551
    (*mangled) ++;
#line 3552
    string_prepend(& decl, "&");
    }
#line 3553
    if ((unsigned int )tk == 0U) {
#line 3554
      tk = (type_kind_t )2;
    }
#line 3555
    goto switch_break;
    case_65: /* CIL Label */ 
#line 3560
    (*mangled) ++;
#line 3561
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
#line 3561
      if ((int )*(decl.b + 0) == 42) {
        {
#line 3564
        string_prepend(& decl, "(");
#line 3565
        string_append(& decl, ")");
        }
      } else
#line 3561
      if ((int )*(decl.b + 0) == 38) {
        {
#line 3564
        string_prepend(& decl, "(");
#line 3565
        string_append(& decl, ")");
        }
      }
    }
    {
#line 3567
    string_append(& decl, "[");
    }
#line 3568
    if ((int const   )*(*mangled) != 95) {
      {
#line 3569
      success = demangle_template_value_parm(work, mangled, & decl, (type_kind_t )3);
      }
    }
#line 3571
    if ((int const   )*(*mangled) == 95) {
#line 3572
      (*mangled) ++;
    }
    {
#line 3573
    string_append(& decl, "]");
    }
#line 3574
    goto switch_break;
    case_84: /* CIL Label */ 
    {
#line 3579
    (*mangled) ++;
#line 3580
    tmp___0 = get_count(mangled, & n);
    }
#line 3580
    if (tmp___0) {
#line 3580
      if (n >= work->ntypes) {
#line 3582
        success = 0;
      } else {
#line 3586
        remembered_type = (char const   *)*(work->typevec + n);
#line 3587
        mangled = & remembered_type;
      }
    } else {
#line 3582
      success = 0;
    }
#line 3589
    goto switch_break;
    case_70: /* CIL Label */ 
#line 3593
    (*mangled) ++;
#line 3594
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
#line 3594
      if ((int )*(decl.b + 0) == 42) {
        {
#line 3597
        string_prepend(& decl, "(");
#line 3598
        string_append(& decl, ")");
        }
      } else
#line 3594
      if ((int )*(decl.b + 0) == 38) {
        {
#line 3597
        string_prepend(& decl, "(");
#line 3598
        string_append(& decl, ")");
        }
      }
    }
    {
#line 3603
    tmp___1 = demangle_nested_args(work, mangled, & decl);
    }
#line 3603
    if (tmp___1) {
#line 3603
      if ((int const   )*(*mangled) != 95) {
#line 3603
        if ((int const   )*(*mangled) != 0) {
#line 3606
          success = 0;
#line 3607
          goto switch_break;
        }
      }
    } else {
#line 3606
      success = 0;
#line 3607
      goto switch_break;
    }
#line 3609
    if (success) {
#line 3609
      if ((int const   )*(*mangled) == 95) {
#line 3610
        (*mangled) ++;
      }
    }
#line 3611
    goto switch_break;
    case_79: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 3616
    type_quals = 0;
#line 3618
    member = (int const   )*(*mangled) == 77;
#line 3619
    (*mangled) ++;
#line 3621
    string_append(& decl, ")");
    }
#line 3625
    if ((int const   )*(*mangled) != 81) {
#line 3626
      if (work->options & (1 << 2)) {
#line 3626
        tmp___2 = ".";
      } else {
#line 3626
        tmp___2 = "::";
      }
      {
#line 3626
      string_prepend(& decl, tmp___2);
      }
    }
#line 3628
    if ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4) {
      {
#line 3630
      n = consume_count(mangled);
      }
#line 3631
      if (n == -1) {
#line 3634
        success = 0;
#line 3635
        goto switch_break;
      } else {
        {
#line 3631
        tmp___3 = strlen(*mangled);
        }
#line 3631
        if ((int )tmp___3 < n) {
#line 3634
          success = 0;
#line 3635
          goto switch_break;
        }
      }
      {
#line 3637
      string_prependn(& decl, *mangled, n);
#line 3638
      *mangled += n;
      }
    } else
#line 3640
    if ((int const   )*(*mangled) == 88) {
      {
#line 3643
      do_type(work, mangled, & temp);
#line 3644
      string_prepends(& decl, & temp);
#line 3645
      string_delete(& temp);
      }
    } else
#line 3640
    if ((int const   )*(*mangled) == 89) {
      {
#line 3643
      do_type(work, mangled, & temp);
#line 3644
      string_prepends(& decl, & temp);
#line 3645
      string_delete(& temp);
      }
    } else
#line 3647
    if ((int const   )*(*mangled) == 116) {
      {
#line 3650
      string_init(& temp___0);
#line 3651
      success = demangle_template(work, mangled, & temp___0, (string *)((void *)0),
                                  1, 1);
      }
#line 3653
      if (success) {
        {
#line 3655
        string_prependn(& decl, (char const   *)temp___0.b, (int )(temp___0.p - temp___0.b));
#line 3656
        string_delete(& temp___0);
        }
      } else {
#line 3659
        goto switch_break;
      }
    } else
#line 3661
    if ((int const   )*(*mangled) == 81) {
      {
#line 3663
      success = demangle_qualified(work, mangled, & decl, 0, 0);
      }
#line 3666
      if (! success) {
#line 3667
        goto switch_break;
      }
    } else {
#line 3671
      success = 0;
#line 3672
      goto switch_break;
    }
    {
#line 3675
    string_prepend(& decl, "(");
    }
#line 3676
    if (member) {
      {
#line 3682
      if ((int const   )*(*mangled) == 117) {
#line 3682
        goto case_117;
      }
#line 3682
      if ((int const   )*(*mangled) == 86) {
#line 3682
        goto case_117;
      }
#line 3682
      if ((int const   )*(*mangled) == 67) {
#line 3682
        goto case_117;
      }
#line 3687
      goto switch_default;
      case_117: /* CIL Label */ 
      case_86: /* CIL Label */ 
      case_67: /* CIL Label */ 
      {
#line 3683
      tmp___4 = code_for_qualifier((int )*(*mangled));
#line 3683
      type_quals |= tmp___4;
#line 3684
      (*mangled) ++;
      }
#line 3685
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 3688
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3691
      tmp___5 = *mangled;
#line 3691
      (*mangled) ++;
#line 3691
      if ((int const   )*tmp___5 != 70) {
#line 3693
        success = 0;
#line 3694
        goto switch_break;
      }
    }
#line 3697
    if (member) {
      {
#line 3697
      tmp___6 = demangle_nested_args(work, mangled, & decl);
      }
#line 3697
      if (tmp___6) {
#line 3697
        goto _L;
      } else {
#line 3700
        success = 0;
#line 3701
        goto switch_break;
      }
    } else
    _L: /* CIL Label */ 
#line 3697
    if ((int const   )*(*mangled) != 95) {
#line 3700
      success = 0;
#line 3701
      goto switch_break;
    }
#line 3703
    (*mangled) ++;
#line 3704
    if (! (work->options & (1 << 1))) {
#line 3706
      goto switch_break;
    }
#line 3708
    if (type_quals != 0) {
#line 3710
      if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
        {
#line 3710
        string_append(& decl, " ");
        }
      }
      {
#line 3711
      tmp___7 = qualifier_string(type_quals);
#line 3711
      string_append(& decl, tmp___7);
      }
    }
#line 3713
    goto switch_break;
    case_71: /* CIL Label */ 
#line 3716
    (*mangled) ++;
#line 3717
    goto switch_break;
    case_117___0: /* CIL Label */ 
    case_86___0: /* CIL Label */ 
    case_67___0: /* CIL Label */ 
#line 3722
    if (work->options & (1 << 1)) {
#line 3724
      if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
        {
#line 3725
        string_prepend(& decl, " ");
        }
      }
      {
#line 3727
      tmp___8 = demangle_qualifier((int )*(*mangled));
#line 3727
      string_prepend(& decl, tmp___8);
      }
    }
#line 3729
    (*mangled) ++;
#line 3730
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 3737
    done___0 = 1;
#line 3738
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3742
  if (success) {
    {
#line 3746
    if ((int const   )*(*mangled) == 75) {
#line 3746
      goto case_75;
    }
#line 3746
    if ((int const   )*(*mangled) == 81) {
#line 3746
      goto case_75;
    }
#line 3753
    if ((int const   )*(*mangled) == 66) {
#line 3753
      goto case_66;
    }
#line 3762
    if ((int const   )*(*mangled) == 89) {
#line 3762
      goto case_89;
    }
#line 3762
    if ((int const   )*(*mangled) == 88) {
#line 3762
      goto case_89;
    }
#line 3787
    goto switch_default___1;
    case_75: /* CIL Label */ 
    case_81: /* CIL Label */ 
    {
#line 3748
    success = demangle_qualified(work, mangled, result, 0, 1);
    }
#line 3749
    goto switch_break___1;
    case_66: /* CIL Label */ 
    {
#line 3754
    (*mangled) ++;
#line 3755
    tmp___9 = get_count(mangled, & n);
    }
#line 3755
    if (tmp___9) {
#line 3755
      if (n >= work->numb) {
#line 3756
        success = 0;
      } else {
        {
#line 3758
        string_append(result, (char const   *)*(work->btypevec + n));
        }
      }
    } else {
#line 3756
      success = 0;
    }
#line 3759
    goto switch_break___1;
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    {
#line 3767
    (*mangled) ++;
#line 3768
    idx___0 = consume_count_with_underscores(mangled);
    }
#line 3770
    if (idx___0 == -1) {
#line 3774
      success = 0;
#line 3775
      goto switch_break___1;
    } else
#line 3770
    if (work->tmpl_argvec) {
#line 3770
      if (idx___0 >= work->ntmpl_args) {
#line 3774
        success = 0;
#line 3775
        goto switch_break___1;
      } else {
#line 3770
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 3770
      tmp___10 = consume_count_with_underscores(mangled);
      }
#line 3770
      if (tmp___10 == -1) {
#line 3774
        success = 0;
#line 3775
        goto switch_break___1;
      }
    }
#line 3778
    if (work->tmpl_argvec) {
      {
#line 3779
      string_append(result, (char const   *)*(work->tmpl_argvec + idx___0));
      }
    } else {
      {
#line 3781
      string_append_template_idx(result, idx___0);
      }
    }
#line 3783
    success = 1;
#line 3785
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 3788
    success = demangle_fund_type(work, mangled, result);
    }
#line 3789
    if ((unsigned int )tk == 0U) {
#line 3790
      tk = (type_kind_t )success;
    }
#line 3791
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
#line 3794
  if (success) {
#line 3796
    if (! ((unsigned long )decl.b == (unsigned long )decl.p)) {
      {
#line 3798
      string_append(result, " ");
#line 3799
      string_appends(result, & decl);
      }
    }
  } else {
    {
#line 3803
    string_delete(result);
    }
  }
  {
#line 3804
  string_delete(& decl);
  }
#line 3806
  if (success) {
#line 3808
    if ((unsigned int )tk == 0U) {
#line 3808
      tmp___11 = 3U;
    } else {
#line 3808
      tmp___11 = (unsigned int )tk;
    }
#line 3808
    return ((int )tmp___11);
  } else {
#line 3810
    return (0);
  }
}
}
#line 3826 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_fund_type(struct work_stuff *work , char const   **mangled , string *result ) 
{ 
  int done___0 ;
  int success ;
  char buf___4[37] ;
  unsigned int dec ;
  type_kind_t tk ;
  char const   *tmp___0 ;
  int i ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  int bindex ;
  int tmp___4 ;
  string btype ;
  long tmp___5 ;
  int tmp___6 ;
  string btype___0 ;
  int tmp___7 ;

  {
#line 3830
  done___0 = 0;
#line 3831
  success = 1;
#line 3833
  dec = 0U;
#line 3834
  tk = (type_kind_t )3;
  {
#line 3838
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3838
    if (! (! done___0)) {
#line 3838
      goto while_break;
    }
    {
#line 3844
    if ((int const   )*(*mangled) == 117) {
#line 3844
      goto case_117;
    }
#line 3844
    if ((int const   )*(*mangled) == 86) {
#line 3844
      goto case_117;
    }
#line 3844
    if ((int const   )*(*mangled) == 67) {
#line 3844
      goto case_117;
    }
#line 3853
    if ((int const   )*(*mangled) == 85) {
#line 3853
      goto case_85;
    }
#line 3858
    if ((int const   )*(*mangled) == 83) {
#line 3858
      goto case_83;
    }
#line 3863
    if ((int const   )*(*mangled) == 74) {
#line 3863
      goto case_74;
    }
#line 3868
    goto switch_default;
    case_117: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 3845
    if (work->options & (1 << 1)) {
#line 3847
      if (! ((unsigned long )result->b == (unsigned long )result->p)) {
        {
#line 3848
        string_prepend(result, " ");
        }
      }
      {
#line 3849
      tmp___0 = demangle_qualifier((int )*(*mangled));
#line 3849
      string_prepend(result, tmp___0);
      }
    }
#line 3851
    (*mangled) ++;
#line 3852
    goto switch_break;
    case_85: /* CIL Label */ 
#line 3854
    (*mangled) ++;
#line 3855
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3855
      string_append(result, " ");
      }
    }
    {
#line 3856
    string_append(result, "unsigned");
    }
#line 3857
    goto switch_break;
    case_83: /* CIL Label */ 
#line 3859
    (*mangled) ++;
#line 3860
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3860
      string_append(result, " ");
      }
    }
    {
#line 3861
    string_append(result, "signed");
    }
#line 3862
    goto switch_break;
    case_74: /* CIL Label */ 
#line 3864
    (*mangled) ++;
#line 3865
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3865
      string_append(result, " ");
      }
    }
    {
#line 3866
    string_append(result, "__complex");
    }
#line 3867
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3869
    done___0 = 1;
#line 3870
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3879
  if ((int const   )*(*mangled) == 95) {
#line 3879
    goto case_95;
  }
#line 3879
  if ((int const   )*(*mangled) == 0) {
#line 3879
    goto case_95;
  }
#line 3881
  if ((int const   )*(*mangled) == 118) {
#line 3881
    goto case_118;
  }
#line 3886
  if ((int const   )*(*mangled) == 120) {
#line 3886
    goto case_120;
  }
#line 3891
  if ((int const   )*(*mangled) == 108) {
#line 3891
    goto case_108;
  }
#line 3896
  if ((int const   )*(*mangled) == 105) {
#line 3896
    goto case_105;
  }
#line 3901
  if ((int const   )*(*mangled) == 115) {
#line 3901
    goto case_115;
  }
#line 3906
  if ((int const   )*(*mangled) == 98) {
#line 3906
    goto case_98;
  }
#line 3912
  if ((int const   )*(*mangled) == 99) {
#line 3912
    goto case_99;
  }
#line 3918
  if ((int const   )*(*mangled) == 119) {
#line 3918
    goto case_119;
  }
#line 3924
  if ((int const   )*(*mangled) == 114) {
#line 3924
    goto case_114;
  }
#line 3930
  if ((int const   )*(*mangled) == 100) {
#line 3930
    goto case_100;
  }
#line 3936
  if ((int const   )*(*mangled) == 102) {
#line 3936
    goto case_102;
  }
#line 3942
  if ((int const   )*(*mangled) == 71) {
#line 3942
    goto case_71;
  }
#line 3949
  if ((int const   )*(*mangled) == 73) {
#line 3949
    goto case_73;
  }
#line 3990
  if ((int const   )*(*mangled) == 57) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 56) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 55) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 54) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 53) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 52) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 51) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 50) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 49) {
#line 3990
    goto case_57;
  }
#line 3990
  if ((int const   )*(*mangled) == 48) {
#line 3990
    goto case_57;
  }
#line 4005
  if ((int const   )*(*mangled) == 116) {
#line 4005
    goto case_116;
  }
#line 4014
  goto switch_default___0;
  case_95: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 3880
  goto switch_break___0;
  case_118: /* CIL Label */ 
#line 3882
  (*mangled) ++;
#line 3883
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3883
    string_append(result, " ");
    }
  }
  {
#line 3884
  string_append(result, "void");
  }
#line 3885
  goto switch_break___0;
  case_120: /* CIL Label */ 
#line 3887
  (*mangled) ++;
#line 3888
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3888
    string_append(result, " ");
    }
  }
  {
#line 3889
  string_append(result, "long long");
  }
#line 3890
  goto switch_break___0;
  case_108: /* CIL Label */ 
#line 3892
  (*mangled) ++;
#line 3893
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3893
    string_append(result, " ");
    }
  }
  {
#line 3894
  string_append(result, "long");
  }
#line 3895
  goto switch_break___0;
  case_105: /* CIL Label */ 
#line 3897
  (*mangled) ++;
#line 3898
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3898
    string_append(result, " ");
    }
  }
  {
#line 3899
  string_append(result, "int");
  }
#line 3900
  goto switch_break___0;
  case_115: /* CIL Label */ 
#line 3902
  (*mangled) ++;
#line 3903
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3903
    string_append(result, " ");
    }
  }
  {
#line 3904
  string_append(result, "short");
  }
#line 3905
  goto switch_break___0;
  case_98: /* CIL Label */ 
#line 3907
  (*mangled) ++;
#line 3908
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3908
    string_append(result, " ");
    }
  }
  {
#line 3909
  string_append(result, "bool");
#line 3910
  tk = (type_kind_t )4;
  }
#line 3911
  goto switch_break___0;
  case_99: /* CIL Label */ 
#line 3913
  (*mangled) ++;
#line 3914
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3914
    string_append(result, " ");
    }
  }
  {
#line 3915
  string_append(result, "char");
#line 3916
  tk = (type_kind_t )5;
  }
#line 3917
  goto switch_break___0;
  case_119: /* CIL Label */ 
#line 3919
  (*mangled) ++;
#line 3920
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3920
    string_append(result, " ");
    }
  }
  {
#line 3921
  string_append(result, "wchar_t");
#line 3922
  tk = (type_kind_t )5;
  }
#line 3923
  goto switch_break___0;
  case_114: /* CIL Label */ 
#line 3925
  (*mangled) ++;
#line 3926
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3926
    string_append(result, " ");
    }
  }
  {
#line 3927
  string_append(result, "long double");
#line 3928
  tk = (type_kind_t )6;
  }
#line 3929
  goto switch_break___0;
  case_100: /* CIL Label */ 
#line 3931
  (*mangled) ++;
#line 3932
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3932
    string_append(result, " ");
    }
  }
  {
#line 3933
  string_append(result, "double");
#line 3934
  tk = (type_kind_t )6;
  }
#line 3935
  goto switch_break___0;
  case_102: /* CIL Label */ 
#line 3937
  (*mangled) ++;
#line 3938
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3938
    string_append(result, " ");
    }
  }
  {
#line 3939
  string_append(result, "float");
#line 3940
  tk = (type_kind_t )6;
  }
#line 3941
  goto switch_break___0;
  case_71: /* CIL Label */ 
#line 3943
  (*mangled) ++;
#line 3944
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 3946
    success = 0;
#line 3947
    goto switch_break___0;
  }
  case_73: /* CIL Label */ 
#line 3950
  (*mangled) ++;
#line 3951
  if ((int const   )*(*mangled) == 95) {
#line 3954
    (*mangled) ++;
#line 3955
    i = 0;
    {
#line 3955
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3955
      if ((long )i < (long )sizeof(buf___4) - 1L) {
#line 3955
        if (*(*mangled)) {
#line 3955
          if (! ((int const   )*(*mangled) != 95)) {
#line 3955
            goto while_break___0;
          }
        } else {
#line 3955
          goto while_break___0;
        }
      } else {
#line 3955
        goto while_break___0;
      }
#line 3958
      buf___4[i] = (char )*(*mangled);
#line 3955
      (*mangled) ++;
#line 3955
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3959
    if ((int const   )*(*mangled) != 95) {
#line 3961
      success = 0;
#line 3962
      goto switch_break___0;
    }
#line 3964
    buf___4[i] = (char )'\000';
#line 3965
    (*mangled) ++;
  } else {
    {
#line 3969
    strncpy((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)*mangled,
            (size_t )2);
#line 3970
    buf___4[2] = (char )'\000';
#line 3971
    tmp___3 = strlen(*mangled);
    }
#line 3971
    if (tmp___3 < 2UL) {
      {
#line 3971
      tmp___1 = strlen(*mangled);
#line 3971
      tmp___2 = tmp___1;
      }
    } else {
#line 3971
      tmp___2 = (size_t )2;
    }
#line 3971
    *mangled += tmp___2;
  }
  {
#line 3973
  sscanf((char const   */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%x",
         & dec);
#line 3974
  sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"int%u_t",
          dec);
  }
#line 3975
  if (! ((unsigned long )result->b == (unsigned long )result->p)) {
    {
#line 3975
    string_append(result, " ");
    }
  }
  {
#line 3976
  string_append(result, (char const   *)(buf___4));
  }
#line 3977
  goto switch_break___0;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 3992
  tmp___4 = register_Btype(work);
#line 3992
  bindex = tmp___4;
#line 3994
  string_init(& btype);
#line 3995
  tmp___6 = demangle_class_name(work, mangled, & btype);
  }
#line 3995
  if (tmp___6) {
#line 3996
    if ((unsigned long )btype.b == (unsigned long )btype.p) {
#line 3996
      tmp___5 = 0L;
    } else {
#line 3996
      tmp___5 = btype.p - btype.b;
    }
    {
#line 3996
    remember_Btype(work, (char const   *)btype.b, (int )tmp___5, bindex);
    }
#line 3997
    if (! ((unsigned long )result->b == (unsigned long )result->p)) {
      {
#line 3997
      string_append(result, " ");
      }
    }
    {
#line 3998
    string_appends(result, & btype);
    }
  } else {
#line 4001
    success = 0;
  }
  {
#line 4002
  string_delete(& btype);
  }
#line 4003
  goto switch_break___0;
  case_116: /* CIL Label */ 
  {
#line 4008
  string_init(& btype___0);
#line 4009
  success = demangle_template(work, mangled, & btype___0, (string *)0, 1, 1);
#line 4010
  string_appends(result, & btype___0);
#line 4011
  string_delete(& btype___0);
  }
#line 4012
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 4015
  success = 0;
#line 4016
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 4019
  if (success) {
#line 4019
    tmp___7 = (int )tk;
  } else {
#line 4019
    tmp___7 = 0;
  }
#line 4019
  return (tmp___7);
}
}
#line 4026 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int do_hpacc_template_const_value(struct work_stuff *work  __attribute__((__unused__)) ,
                                         char const   **mangled , string *result ) 
{ 
  int unsigned_const ;

  {
#line 4032
  if ((int const   )*(*mangled) != 85) {
#line 4032
    if ((int const   )*(*mangled) != 83) {
#line 4033
      return (0);
    }
  }
#line 4035
  unsigned_const = (int const   )*(*mangled) == 85;
#line 4037
  (*mangled) ++;
  {
#line 4041
  if ((int const   )*(*mangled) == 78) {
#line 4041
    goto case_78;
  }
#line 4044
  if ((int const   )*(*mangled) == 80) {
#line 4044
    goto case_80;
  }
#line 4047
  if ((int const   )*(*mangled) == 77) {
#line 4047
    goto case_77;
  }
#line 4052
  goto switch_default;
  case_78: /* CIL Label */ 
  {
#line 4042
  string_append(result, "-");
  }
  case_80: /* CIL Label */ 
#line 4045
  (*mangled) ++;
#line 4046
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 4049
  string_append(result, "-2147483648");
#line 4050
  (*mangled) ++;
  }
#line 4051
  return (1);
  switch_default: /* CIL Label */ 
#line 4053
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 4057
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 4058
    return (0);
  }
  {
#line 4062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4062
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*mangled)) & 255] & 4)) {
#line 4062
      goto while_break;
    }
    {
#line 4064
    char_str[0] = (char )*(*mangled);
#line 4065
    string_append(result, (char const   *)(char_str));
#line 4066
    (*mangled) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4069
  if (unsigned_const) {
    {
#line 4070
    string_append(result, "U");
    }
  }
#line 4075
  return (1);
}
}
#line 4081 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int do_hpacc_template_literal(struct work_stuff *work , char const   **mangled ,
                                     string *result ) 
{ 
  int literal_len ;
  char *recurse ;
  char *recurse_dem ;
  void *tmp___0 ;

  {
#line 4085
  literal_len = 0;
#line 4089
  if ((int const   )*(*mangled) != 65) {
#line 4090
    return (0);
  }
  {
#line 4092
  (*mangled) ++;
#line 4094
  literal_len = consume_count(mangled);
  }
#line 4096
  if (literal_len <= 0) {
#line 4097
    return (0);
  }
  {
#line 4101
  string_append(result, "&");
#line 4104
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )(literal_len + 1));
#line 4104
  recurse = (char *)tmp___0;
#line 4105
  memcpy((void */* __restrict  */)recurse, (void const   */* __restrict  */)*mangled,
         (size_t )literal_len);
#line 4106
  *(recurse + literal_len) = (char )'\000';
#line 4108
  recurse_dem = cplus_demangle((char const   *)recurse, work->options);
  }
#line 4110
  if (recurse_dem) {
    {
#line 4112
    string_append(result, (char const   *)recurse_dem);
#line 4113
    free((void *)recurse_dem);
    }
  } else {
    {
#line 4117
    string_appendn(result, *mangled, literal_len);
    }
  }
  {
#line 4119
  *mangled += literal_len;
#line 4120
  free((void *)recurse);
  }
#line 4122
  return (1);
}
}
#line 4125 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int snarf_numeric_literal(char const   **args , string *arg ) 
{ 


  {
#line 4128
  if ((int const   )*(*args) == 45) {
    {
#line 4130
    char_str[0] = (char )'-';
#line 4131
    string_append(arg, (char const   *)(char_str));
#line 4132
    (*args) ++;
    }
  } else
#line 4134
  if ((int const   )*(*args) == 43) {
#line 4135
    (*args) ++;
  }
#line 4137
  if (! ((int const   )_sch_istable[(int )((unsigned char )*(*args)) & 255] & 4)) {
#line 4138
    return (0);
  }
  {
#line 4140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4140
    if (! ((int const   )_sch_istable[(int )((unsigned char )*(*args)) & 255] & 4)) {
#line 4140
      goto while_break;
    }
    {
#line 4142
    char_str[0] = (char )*(*args);
#line 4143
    string_append(arg, (char const   *)(char_str));
#line 4144
    (*args) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4147
  return (1);
}
}
#line 4154 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int do_arg(struct work_stuff *work , char const   **mangled , string *result ) 
{ 
  char const   *start ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 4159
  start = *mangled;
#line 4161
  string_init(result);
  }
#line 4163
  if (work->nrepeats > 0) {
#line 4165
    (work->nrepeats) --;
#line 4167
    if ((unsigned long )work->previous_argument == (unsigned long )((string *)0)) {
#line 4168
      return (0);
    }
    {
#line 4171
    string_appends(result, work->previous_argument);
    }
#line 4172
    return (1);
  }
#line 4175
  if ((int const   )*(*mangled) == 110) {
    {
#line 4178
    (*mangled) ++;
#line 4179
    work->nrepeats = consume_count(mangled);
    }
#line 4181
    if (work->nrepeats <= 0) {
#line 4183
      return (0);
    }
#line 4185
    if (work->nrepeats > 9) {
#line 4187
      if ((int const   )*(*mangled) != 95) {
#line 4190
        return (0);
      } else {
#line 4192
        (*mangled) ++;
      }
    }
    {
#line 4196
    tmp___0 = do_arg(work, mangled, result);
    }
#line 4196
    return (tmp___0);
  }
#line 4203
  if (work->previous_argument) {
    {
#line 4204
    string_delete(work->previous_argument);
    }
  } else {
    {
#line 4206
    tmp___1 = xmalloc(sizeof(string ));
#line 4206
    work->previous_argument = (string *)tmp___1;
    }
  }
  {
#line 4208
  tmp___2 = do_type(work, mangled, work->previous_argument);
  }
#line 4208
  if (! tmp___2) {
#line 4209
    return (0);
  }
  {
#line 4211
  string_appends(result, work->previous_argument);
#line 4213
  remember_type(work, start, (int )(*mangled - start));
  }
#line 4214
  return (1);
}
}
#line 4217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void remember_type(struct work_stuff *work , char const   *start , int len ) 
{ 
  char *tem ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 4222
  if (work->forgetting_types) {
#line 4223
    return;
  }
#line 4225
  if (work->ntypes >= work->typevec_size) {
#line 4227
    if (work->typevec_size == 0) {
      {
#line 4229
      work->typevec_size = 3;
#line 4230
      tmp___0 = xmalloc(sizeof(char *) * (unsigned long )work->typevec_size);
#line 4230
      work->typevec = (char **)tmp___0;
      }
    } else {
      {
#line 4234
      work->typevec_size *= 2;
#line 4235
      tmp___1 = xrealloc((void *)work->typevec, sizeof(char *) * (unsigned long )work->typevec_size);
#line 4235
      work->typevec = (char **)tmp___1;
      }
    }
  }
  {
#line 4239
  tmp___2 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4239
  tem = (char *)tmp___2;
#line 4240
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4241
  *(tem + len) = (char )'\000';
#line 4242
  tmp___3 = work->ntypes;
#line 4242
  (work->ntypes) ++;
#line 4242
  *(work->typevec + tmp___3) = tem;
  }
#line 4243
  return;
}
}
#line 4247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void remember_Ktype(struct work_stuff *work , char const   *start , int len ) 
{ 
  char *tem ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 4252
  if (work->numk >= work->ksize) {
#line 4254
    if (work->ksize == 0) {
      {
#line 4256
      work->ksize = 5;
#line 4257
      tmp___0 = xmalloc(sizeof(char *) * (unsigned long )work->ksize);
#line 4257
      work->ktypevec = (char **)tmp___0;
      }
    } else {
      {
#line 4261
      work->ksize *= 2;
#line 4262
      tmp___1 = xrealloc((void *)work->ktypevec, sizeof(char *) * (unsigned long )work->ksize);
#line 4262
      work->ktypevec = (char **)tmp___1;
      }
    }
  }
  {
#line 4266
  tmp___2 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4266
  tem = (char *)tmp___2;
#line 4267
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4268
  *(tem + len) = (char )'\000';
#line 4269
  tmp___3 = work->numk;
#line 4269
  (work->numk) ++;
#line 4269
  *(work->ktypevec + tmp___3) = tem;
  }
#line 4270
  return;
}
}
#line 4276 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int register_Btype(struct work_stuff *work ) 
{ 
  int ret ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 4281
  if (work->numb >= work->bsize) {
#line 4283
    if (work->bsize == 0) {
      {
#line 4285
      work->bsize = 5;
#line 4286
      tmp___0 = xmalloc(sizeof(char *) * (unsigned long )work->bsize);
#line 4286
      work->btypevec = (char **)tmp___0;
      }
    } else {
      {
#line 4290
      work->bsize *= 2;
#line 4291
      tmp___1 = xrealloc((void *)work->btypevec, sizeof(char *) * (unsigned long )work->bsize);
#line 4291
      work->btypevec = (char **)tmp___1;
      }
    }
  }
#line 4295
  tmp___2 = work->numb;
#line 4295
  (work->numb) ++;
#line 4295
  ret = tmp___2;
#line 4296
  *(work->btypevec + ret) = (char *)((void *)0);
#line 4297
  return (ret);
}
}
#line 4302 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void remember_Btype(struct work_stuff *work , char const   *start , int len ,
                           int index___0 ) 
{ 
  char *tem ;
  void *tmp___0 ;

  {
  {
#line 4308
  tmp___0 = xmalloc(sizeof(char ) * (unsigned long )(len + 1));
#line 4308
  tem = (char *)tmp___0;
#line 4309
  memcpy((void */* __restrict  */)tem, (void const   */* __restrict  */)start, (size_t )len);
#line 4310
  *(tem + len) = (char )'\000';
#line 4311
  *(work->btypevec + index___0) = tem;
  }
#line 4312
  return;
}
}
#line 4315 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void forget_B_and_K_types(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 4320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4320
    if (! (work->numk > 0)) {
#line 4320
      goto while_break;
    }
#line 4322
    (work->numk) --;
#line 4322
    i = work->numk;
#line 4323
    if ((unsigned long )*(work->ktypevec + i) != (unsigned long )((void *)0)) {
      {
#line 4325
      free((void *)*(work->ktypevec + i));
#line 4326
      *(work->ktypevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4330
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4330
    if (! (work->numb > 0)) {
#line 4330
      goto while_break___0;
    }
#line 4332
    (work->numb) --;
#line 4332
    i = work->numb;
#line 4333
    if ((unsigned long )*(work->btypevec + i) != (unsigned long )((void *)0)) {
      {
#line 4335
      free((void *)*(work->btypevec + i));
#line 4336
      *(work->btypevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 4339
  return;
}
}
#line 4342 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void forget_types(struct work_stuff *work ) 
{ 
  int i ;

  {
  {
#line 4347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4347
    if (! (work->ntypes > 0)) {
#line 4347
      goto while_break;
    }
#line 4349
    (work->ntypes) --;
#line 4349
    i = work->ntypes;
#line 4350
    if ((unsigned long )*(work->typevec + i) != (unsigned long )((void *)0)) {
      {
#line 4352
      free((void *)*(work->typevec + i));
#line 4353
      *(work->typevec + i) = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4356
  return;
}
}
#line 4400 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_args(struct work_stuff *work , char const   **mangled , string *declp ) 
{ 
  string arg ;
  int need_comma ;
  int r ;
  int t ;
  char const   *tem ;
  char temptype ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 4405
  need_comma = 0;
#line 4411
  if (work->options & 1) {
    {
#line 4413
    string_append(declp, "(");
    }
#line 4414
    if ((int const   )*(*mangled) == 0) {
      {
#line 4416
      string_append(declp, "void");
      }
    }
  }
  {
#line 4420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4420
    if ((int const   )*(*mangled) != 95) {
#line 4420
      if ((int const   )*(*mangled) != 0) {
#line 4420
        if (! ((int const   )*(*mangled) != 101)) {
#line 4420
          goto _L___3;
        }
      } else {
#line 4420
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 4420
    if (! (work->nrepeats > 0)) {
#line 4420
      goto while_break;
    }
#line 4423
    if ((int const   )*(*mangled) == 78) {
#line 4423
      goto _L___1;
    } else
#line 4423
    if ((int const   )*(*mangled) == 84) {
      _L___1: /* CIL Label */ 
#line 4425
      tmp___0 = *mangled;
#line 4425
      (*mangled) ++;
#line 4425
      temptype = (char )*tmp___0;
#line 4427
      if ((int )temptype == 78) {
        {
#line 4429
        tmp___1 = get_count(mangled, & r);
        }
#line 4429
        if (! tmp___1) {
#line 4431
          return (0);
        }
      } else {
#line 4436
        r = 1;
      }
#line 4438
      if (work->options & (1 << 12)) {
#line 4438
        goto _L___0;
      } else
#line 4438
      if (work->options & (1 << 11)) {
#line 4438
        goto _L___0;
      } else
#line 4438
      if (work->options & (1 << 13)) {
        _L___0: /* CIL Label */ 
#line 4438
        if (work->ntypes >= 10) {
          {
#line 4446
          t = consume_count(mangled);
          }
#line 4446
          if (t <= 0) {
#line 4448
            return (0);
          }
        } else {
#line 4438
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 4453
        tmp___2 = get_count(mangled, & t);
        }
#line 4453
        if (! tmp___2) {
#line 4455
          return (0);
        }
      }
#line 4458
      if (work->options & (1 << 10)) {
#line 4460
        t --;
      } else
#line 4458
      if (work->options & (1 << 11)) {
#line 4460
        t --;
      } else
#line 4458
      if (work->options & (1 << 12)) {
#line 4460
        t --;
      } else
#line 4458
      if (work->options & (1 << 13)) {
#line 4460
        t --;
      }
#line 4464
      if (t < 0) {
#line 4466
        return (0);
      } else
#line 4464
      if (t >= work->ntypes) {
#line 4466
        return (0);
      }
      {
#line 4468
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4468
        if (! (work->nrepeats > 0)) {
#line 4468
          r --;
#line 4468
          if (! (r >= 0)) {
#line 4468
            goto while_break___0;
          }
        }
#line 4470
        tem = (char const   *)*(work->typevec + t);
#line 4471
        if (need_comma) {
#line 4471
          if (work->options & 1) {
            {
#line 4473
            string_append(declp, ", ");
            }
          }
        }
        {
#line 4475
        tmp___3 = do_arg(work, & tem, & arg);
        }
#line 4475
        if (! tmp___3) {
#line 4477
          return (0);
        }
#line 4479
        if (work->options & 1) {
          {
#line 4481
          string_appends(declp, & arg);
          }
        }
        {
#line 4483
        string_delete(& arg);
#line 4484
        need_comma = 1;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 4489
      if (need_comma) {
#line 4489
        if (work->options & 1) {
          {
#line 4490
          string_append(declp, ", ");
          }
        }
      }
      {
#line 4491
      tmp___4 = do_arg(work, mangled, & arg);
      }
#line 4491
      if (! tmp___4) {
#line 4492
        return (0);
      }
#line 4493
      if (work->options & 1) {
        {
#line 4494
        string_appends(declp, & arg);
        }
      }
      {
#line 4495
      string_delete(& arg);
#line 4496
      need_comma = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4500
  if ((int const   )*(*mangled) == 101) {
#line 4502
    (*mangled) ++;
#line 4503
    if (work->options & 1) {
#line 4505
      if (need_comma) {
        {
#line 4507
        string_append(declp, ",");
        }
      }
      {
#line 4509
      string_append(declp, "...");
      }
    }
  }
#line 4513
  if (work->options & 1) {
    {
#line 4515
    string_append(declp, ")");
    }
  }
#line 4517
  return (1);
}
}
#line 4523 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_nested_args(struct work_stuff *work , char const   **mangled ,
                                string *declp ) 
{ 
  string *saved_previous_argument ;
  int result ;
  int saved_nrepeats ;

  {
  {
#line 4535
  (work->forgetting_types) ++;
#line 4539
  saved_previous_argument = work->previous_argument;
#line 4540
  saved_nrepeats = work->nrepeats;
#line 4541
  work->previous_argument = (string *)0;
#line 4542
  work->nrepeats = 0;
#line 4545
  result = demangle_args(work, mangled, declp);
  }
#line 4548
  if (work->previous_argument) {
    {
#line 4550
    string_delete(work->previous_argument);
#line 4551
    free((void *)((char *)work->previous_argument));
    }
  }
#line 4553
  work->previous_argument = saved_previous_argument;
#line 4554
  (work->forgetting_types) --;
#line 4555
  work->nrepeats = saved_nrepeats;
#line 4557
  return (result);
}
}
#line 4562 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static int demangle_function_name(struct work_stuff *work , char const   **mangled ,
                                  string *declp , char const   *scan ) 
{ 
  size_t i ;
  string type ;
  char const   *tem ;
  int tmp___0 ;
  int tmp___1 ;
  int len ;
  size_t tmp___2 ;
  int tmp___3 ;
  int len___0 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  long tmp___16 ;

  {
  {
#line 4570
  string_appendn(declp, *mangled, (int )(scan - *mangled));
#line 4571
  string_need(declp, 1);
#line 4572
  *(declp->p) = (char )'\000';
#line 4578
  *mangled = scan + 2;
  }
#line 4584
  if (work->options & (1 << 12)) {
#line 4584
    if ((int const   )*(*mangled) == 88) {
      {
#line 4586
      demangle_arm_hp_template(work, mangled, 0, declp);
      }
    }
  }
#line 4590
  if (work->options & (1 << 10)) {
#line 4590
    goto _L;
  } else
#line 4590
  if (work->options & (1 << 11)) {
#line 4590
    goto _L;
  } else
#line 4590
  if (work->options & (1 << 12)) {
#line 4590
    goto _L;
  } else
#line 4590
  if (work->options & (1 << 13)) {
    _L: /* CIL Label */ 
    {
#line 4598
    tmp___1 = strcmp((char const   *)declp->b, "__ct");
    }
#line 4598
    if (tmp___1 == 0) {
      {
#line 4600
      (work->constructor) ++;
#line 4601
      string_clear(declp);
      }
#line 4602
      return (1);
    } else {
      {
#line 4604
      tmp___0 = strcmp((char const   *)declp->b, "__dt");
      }
#line 4604
      if (tmp___0 == 0) {
        {
#line 4606
        (work->destructor) ++;
#line 4607
        string_clear(declp);
        }
#line 4608
        return (1);
      }
    }
  }
#line 4612
  if (declp->p - declp->b >= 3L) {
#line 4612
    if ((int )*(declp->b + 0) == 111) {
#line 4612
      if ((int )*(declp->b + 1) == 112) {
        {
#line 4612
        tmp___15 = strchr((char const   *)(cplus_markers), (int )*(declp->b + 2));
        }
#line 4612
        if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 4618
          if (declp->p - declp->b >= 10L) {
            {
#line 4618
            tmp___6 = memcmp((void const   *)(declp->b + 3), (void const   *)"assign_",
                             (size_t )7);
            }
#line 4618
            if (tmp___6 == 0) {
#line 4621
              i = (size_t )0;
              {
#line 4621
              while (1) {
                while_continue: /* CIL Label */ ;
#line 4621
                if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4621
                  goto while_break;
                }
                {
#line 4623
                len = (int )((declp->p - declp->b) - 10L);
#line 4624
                tmp___2 = strlen((char const   *)optable[i].in);
                }
#line 4624
                if ((int )tmp___2 == len) {
                  {
#line 4624
                  tmp___3 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 10),
                                   (size_t )len);
                  }
#line 4624
                  if (tmp___3 == 0) {
                    {
#line 4627
                    string_clear(declp);
#line 4628
                    string_append(declp, "operator");
#line 4629
                    string_append(declp, (char const   *)optable[i].out);
#line 4630
                    string_append(declp, "=");
                    }
#line 4631
                    goto while_break;
                  }
                }
#line 4621
                i ++;
              }
              while_break: /* CIL Label */ ;
              }
            } else {
#line 4618
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 4637
            i = (size_t )0;
            {
#line 4637
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 4637
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4637
                goto while_break___0;
              }
              {
#line 4639
              len___0 = (int )((declp->p - declp->b) - 3L);
#line 4640
              tmp___4 = strlen((char const   *)optable[i].in);
              }
#line 4640
              if ((int )tmp___4 == len___0) {
                {
#line 4640
                tmp___5 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 3),
                                 (size_t )len___0);
                }
#line 4640
                if (tmp___5 == 0) {
                  {
#line 4643
                  string_clear(declp);
#line 4644
                  string_append(declp, "operator");
#line 4645
                  string_append(declp, (char const   *)optable[i].out);
                  }
#line 4646
                  goto while_break___0;
                }
              }
#line 4637
              i ++;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        } else {
#line 4612
          goto _L___8;
        }
      } else {
#line 4612
        goto _L___8;
      }
    } else {
#line 4612
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 4651
  if (declp->p - declp->b >= 5L) {
    {
#line 4651
    tmp___13 = memcmp((void const   *)declp->b, (void const   *)"type", (size_t )4);
    }
#line 4651
    if (tmp___13 == 0) {
      {
#line 4651
      tmp___14 = strchr((char const   *)(cplus_markers), (int )*(declp->b + 4));
      }
#line 4651
      if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
        {
#line 4655
        tem = (char const   *)(declp->b + 5);
#line 4656
        tmp___7 = do_type(work, & tem, & type);
        }
#line 4656
        if (tmp___7) {
          {
#line 4658
          string_clear(declp);
#line 4659
          string_append(declp, "operator ");
#line 4660
          string_appends(declp, & type);
#line 4661
          string_delete(& type);
          }
        }
      } else {
#line 4651
        goto _L___5;
      }
    } else {
#line 4651
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 4664
  if ((int )*(declp->b + 0) == 95) {
#line 4664
    if ((int )*(declp->b + 1) == 95) {
#line 4664
      if ((int )*(declp->b + 2) == 111) {
#line 4664
        if ((int )*(declp->b + 3) == 112) {
          {
#line 4669
          tem = (char const   *)(declp->b + 4);
#line 4670
          tmp___8 = do_type(work, & tem, & type);
          }
#line 4670
          if (tmp___8) {
            {
#line 4672
            string_clear(declp);
#line 4673
            string_append(declp, "operator ");
#line 4674
            string_appends(declp, & type);
#line 4675
            string_delete(& type);
            }
          }
        } else {
#line 4664
          goto _L___3;
        }
      } else {
#line 4664
        goto _L___3;
      }
    } else {
#line 4664
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 4678
  if ((int )*(declp->b + 0) == 95) {
#line 4678
    if ((int )*(declp->b + 1) == 95) {
#line 4678
      if ((int const   )_sch_istable[(int )((unsigned char )*(declp->b + 2)) & 255] & 8) {
#line 4678
        if ((int const   )_sch_istable[(int )((unsigned char )*(declp->b + 3)) & 255] & 8) {
#line 4682
          if ((int )*(declp->b + 4) == 0) {
#line 4685
            i = (size_t )0;
            {
#line 4685
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4685
              if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4685
                goto while_break___1;
              }
              {
#line 4687
              tmp___9 = strlen((char const   *)optable[i].in);
              }
#line 4687
              if (tmp___9 == 2UL) {
                {
#line 4687
                tmp___10 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 2),
                                  (size_t )2);
                }
#line 4687
                if (tmp___10 == 0) {
                  {
#line 4690
                  string_clear(declp);
#line 4691
                  string_append(declp, "operator");
#line 4692
                  string_append(declp, (char const   *)optable[i].out);
                  }
#line 4693
                  goto while_break___1;
                }
              }
#line 4685
              i ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          } else
#line 4699
          if ((int )*(declp->b + 2) == 97) {
#line 4699
            if ((int )*(declp->b + 5) == 0) {
#line 4702
              i = (size_t )0;
              {
#line 4702
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 4702
                if (! (i < sizeof(optable) / sizeof(optable[0]))) {
#line 4702
                  goto while_break___2;
                }
                {
#line 4704
                tmp___11 = strlen((char const   *)optable[i].in);
                }
#line 4704
                if (tmp___11 == 3UL) {
                  {
#line 4704
                  tmp___12 = memcmp((void const   *)optable[i].in, (void const   *)(declp->b + 2),
                                    (size_t )3);
                  }
#line 4704
                  if (tmp___12 == 0) {
                    {
#line 4707
                    string_clear(declp);
#line 4708
                    string_append(declp, "operator");
#line 4709
                    string_append(declp, (char const   *)optable[i].out);
                    }
#line 4710
                    goto while_break___2;
                  }
                }
#line 4702
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
  }
#line 4719
  if ((unsigned long )declp->b == (unsigned long )declp->p) {
#line 4719
    tmp___16 = 0L;
  } else {
#line 4719
    tmp___16 = declp->p - declp->b;
  }
#line 4719
  if (tmp___16 == 1L) {
#line 4719
    if ((int )*(declp->b + 0) == 46) {
#line 4720
      return (0);
    } else {
#line 4722
      return (1);
    }
  } else {
#line 4722
    return (1);
  }
}
}
#line 4727 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_need(string *s , int n ) 
{ 
  int tem ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 4732
  if ((unsigned long )s->b == (unsigned long )((void *)0)) {
#line 4734
    if (n < 32) {
#line 4736
      n = 32;
    }
    {
#line 4738
    tmp___1 = xmalloc(sizeof(char ) * (unsigned long )n);
#line 4738
    tmp___0 = (char *)tmp___1;
#line 4738
    s->b = tmp___0;
#line 4738
    s->p = tmp___0;
#line 4739
    s->e = s->b + n;
    }
  } else
#line 4741
  if (s->e - s->p < (long )n) {
    {
#line 4743
    tem = (int )(s->p - s->b);
#line 4744
    n += tem;
#line 4745
    n *= 2;
#line 4746
    tmp___2 = xrealloc((void *)s->b, sizeof(char ) * (unsigned long )n);
#line 4746
    s->b = (char *)tmp___2;
#line 4747
    s->p = s->b + tem;
#line 4748
    s->e = s->b + n;
    }
  }
#line 4750
  return;
}
}
#line 4752 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_delete(string *s ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 4755
  if ((unsigned long )s->b != (unsigned long )((void *)0)) {
    {
#line 4757
    free((void *)s->b);
#line 4758
    tmp___1 = (char *)((void *)0);
#line 4758
    s->p = tmp___1;
#line 4758
    tmp___0 = tmp___1;
#line 4758
    s->e = tmp___0;
#line 4758
    s->b = tmp___0;
    }
  }
#line 4760
  return;
}
}
#line 4762 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_init(string *s ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 4765
  tmp___1 = (char *)((void *)0);
#line 4765
  s->e = tmp___1;
#line 4765
  tmp___0 = tmp___1;
#line 4765
  s->p = tmp___0;
#line 4765
  s->b = tmp___0;
#line 4766
  return;
}
}
#line 4768 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_clear(string *s ) 
{ 


  {
#line 4771
  s->p = s->b;
#line 4772
  return;
}
}
#line 4784 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_append(string *p , char const   *s ) 
{ 
  int n ;
  size_t tmp___0 ;

  {
#line 4788
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 4789
    return;
  } else
#line 4788
  if ((int const   )*s == 0) {
#line 4789
    return;
  }
  {
#line 4790
  tmp___0 = strlen(s);
#line 4790
  n = (int )tmp___0;
#line 4791
  string_need(p, n);
#line 4792
  memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s, (size_t )n);
#line 4793
  p->p += n;
  }
#line 4794
  return;
}
}
#line 4796 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_appends(string *p , string *s ) 
{ 
  int n ;

  {
#line 4801
  if ((unsigned long )s->b != (unsigned long )s->p) {
    {
#line 4803
    n = (int )(s->p - s->b);
#line 4804
    string_need(p, n);
#line 4805
    memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s->b, (size_t )n);
#line 4806
    p->p += n;
    }
  }
#line 4808
  return;
}
}
#line 4810 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_appendn(string *p , char const   *s , int n ) 
{ 


  {
#line 4813
  if (n != 0) {
    {
#line 4815
    string_need(p, n);
#line 4816
    memcpy((void */* __restrict  */)p->p, (void const   */* __restrict  */)s, (size_t )n);
#line 4817
    p->p += n;
    }
  }
#line 4819
  return;
}
}
#line 4821 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_prepend(string *p , char const   *s ) 
{ 
  size_t tmp___0 ;

  {
#line 4824
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 4824
    if ((int const   )*s != 0) {
      {
#line 4826
      tmp___0 = strlen(s);
#line 4826
      string_prependn(p, s, (int )tmp___0);
      }
    }
  }
#line 4828
  return;
}
}
#line 4830 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_prepends(string *p , string *s ) 
{ 


  {
#line 4833
  if ((unsigned long )s->b != (unsigned long )s->p) {
    {
#line 4835
    string_prependn(p, (char const   *)s->b, (int )(s->p - s->b));
    }
  }
#line 4837
  return;
}
}
#line 4839 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_prependn(string *p , char const   *s , int n ) 
{ 
  char *q ;

  {
#line 4844
  if (n != 0) {
    {
#line 4846
    string_need(p, n);
#line 4847
    q = p->p - 1;
    }
    {
#line 4847
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4847
      if (! ((unsigned long )q >= (unsigned long )p->b)) {
#line 4847
        goto while_break;
      }
#line 4849
      *(q + n) = *(q + 0);
#line 4847
      q --;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4851
    memcpy((void */* __restrict  */)p->b, (void const   */* __restrict  */)s, (size_t )n);
#line 4852
    p->p += n;
    }
  }
#line 4854
  return;
}
}
#line 4856 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cplus-dem.c"
static void string_append_template_idx(string *s , int idx___0 ) 
{ 
  char buf___4[33] ;

  {
  {
#line 4860
  sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"T%d",
          idx___0);
#line 4861
  string_append(s, (char const   *)(buf___4));
  }
#line 4862
  return;
}
}
#line 552 "./../include/demangle.h"
int cplus_demangle_fill_component(struct demangle_component *p , enum demangle_component_type type ,
                                  struct demangle_component *left , struct demangle_component *right ) ;
#line 569
int cplus_demangle_fill_builtin_type(struct demangle_component *p , char const   *type_name ) ;
#line 579
int cplus_demangle_fill_operator(struct demangle_component *p , char const   *opname ,
                                 int args ) ;
#line 616
struct demangle_component *cplus_demangle_v3_components(char const   *mangled , int options___0 ,
                                                        void **mem ) ;
#line 148 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.h"
struct demangle_operator_info  const  cplus_demangle_operators[62] ;
#line 153
struct demangle_builtin_type_info  const  cplus_demangle_builtin_types[33] ;
#line 157
struct demangle_component *cplus_demangle_mangled_name(struct d_info *di , int top_level ) ;
#line 161
struct demangle_component *cplus_demangle_type(struct d_info *di ) ;
#line 165
void cplus_demangle_init_info(char const   *mangled , int options___0 , size_t len ,
                              struct d_info *di ) ;
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demint.c"
int cplus_demangle_fill_component(struct demangle_component *p , enum demangle_component_type type ,
                                  struct demangle_component *left , struct demangle_component *right ) 
{ 


  {
#line 64
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 65
    return (0);
  }
  {
#line 86
  if ((unsigned int )type == 56U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 55U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 54U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 53U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 52U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 51U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 50U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 49U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 43U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 42U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 39U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 38U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 37U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 29U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 11U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 4U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 3U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 2U) {
#line 86
    goto case_56;
  }
#line 86
  if ((unsigned int )type == 1U) {
#line 86
    goto case_56;
  }
#line 112
  if ((unsigned int )type == 47U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 36U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 34U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 33U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 31U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 30U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 28U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 27U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 26U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 25U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 24U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 23U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 20U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 19U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 18U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 17U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 16U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 15U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 14U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 13U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 12U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 10U) {
#line 112
    goto case_47;
  }
#line 112
  if ((unsigned int )type == 9U) {
#line 112
    goto case_47;
  }
#line 117
  goto switch_default;
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 87
  goto switch_break;
  case_47: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 113
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 114
    return (0);
  }
#line 115
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 119
  return (0);
  switch_break: /* CIL Label */ ;
  }
#line 122
  p->type = type;
#line 123
  p->u.s_binary.left = left;
#line 124
  p->u.s_binary.right = right;
#line 126
  return (1);
}
}
#line 131 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demint.c"
int cplus_demangle_fill_builtin_type(struct demangle_component *p , char const   *type_name ) 
{ 
  int len ;
  unsigned int i ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 138
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 139
    return (0);
  } else
#line 138
  if ((unsigned long )type_name == (unsigned long )((void *)0)) {
#line 139
    return (0);
  }
  {
#line 140
  tmp___0 = strlen(type_name);
#line 140
  len = (int )tmp___0;
#line 141
  i = 0U;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < 33U)) {
#line 141
      goto while_break;
    }
#line 143
    if (len == (int )cplus_demangle_builtin_types[i].len) {
      {
#line 143
      tmp___1 = strcmp(type_name, (char const   *)cplus_demangle_builtin_types[i].name);
      }
#line 143
      if (tmp___1 == 0) {
#line 146
        p->type = (enum demangle_component_type )35;
#line 147
        p->u.s_builtin.type = & cplus_demangle_builtin_types[i];
#line 148
        return (1);
      }
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  return (0);
}
}
#line 156 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demint.c"
int cplus_demangle_fill_operator(struct demangle_component *p , char const   *opname ,
                                 int args ) 
{ 
  int len ;
  unsigned int i ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 163
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 164
    return (0);
  } else
#line 163
  if ((unsigned long )opname == (unsigned long )((void *)0)) {
#line 164
    return (0);
  }
  {
#line 165
  tmp___0 = strlen(opname);
#line 165
  len = (int )tmp___0;
#line 166
  i = 0U;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned long )cplus_demangle_operators[i].name != (unsigned long )((void *)0))) {
#line 166
      goto while_break;
    }
#line 168
    if (len == (int )cplus_demangle_operators[i].len) {
#line 168
      if (args == (int )cplus_demangle_operators[i].args) {
        {
#line 168
        tmp___1 = strcmp(opname, (char const   *)cplus_demangle_operators[i].name);
        }
#line 168
        if (tmp___1 == 0) {
#line 172
          p->type = (enum demangle_component_type )45;
#line 173
          p->u.s_operator.op = & cplus_demangle_operators[i];
#line 174
          return (1);
        }
      }
    }
#line 166
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (0);
}
}
#line 182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demint.c"
struct demangle_component *cplus_demangle_v3_components(char const   *mangled , int options___0 ,
                                                        void **mem ) 
{ 
  size_t len ;
  int type ;
  struct d_info di ;
  struct demangle_component *dc ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 190
  len = strlen(mangled);
  }
#line 192
  if ((int const   )*(mangled + 0) == 95) {
#line 192
    if ((int const   )*(mangled + 1) == 90) {
#line 193
      type = 0;
    } else {
#line 192
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 196
    if ((options___0 & (1 << 4)) == 0) {
#line 197
      return ((struct demangle_component *)((void *)0));
    }
#line 198
    type = 1;
  }
  {
#line 201
  cplus_demangle_init_info(mangled, options___0, len, & di);
#line 203
  tmp___0 = malloc((unsigned long )di.num_comps * sizeof(struct demangle_component ));
#line 203
  di.comps = (struct demangle_component *)tmp___0;
#line 205
  tmp___1 = malloc((unsigned long )di.num_subs * sizeof(struct demangle_component *));
#line 205
  di.subs = (struct demangle_component **)tmp___1;
  }
#line 207
  if ((unsigned long )di.comps == (unsigned long )((void *)0)) {
    {
#line 209
    free((void *)di.comps);
#line 210
    free((void *)di.subs);
    }
#line 211
    return ((struct demangle_component *)((void *)0));
  } else
#line 207
  if ((unsigned long )di.subs == (unsigned long )((void *)0)) {
    {
#line 209
    free((void *)di.comps);
#line 210
    free((void *)di.subs);
    }
#line 211
    return ((struct demangle_component *)((void *)0));
  }
#line 214
  if (! type) {
    {
#line 215
    dc = cplus_demangle_mangled_name(& di, 1);
    }
  } else {
    {
#line 217
    dc = cplus_demangle_type(& di);
    }
  }
#line 221
  if ((options___0 & 1) != 0) {
#line 221
    if ((int const   )*(di.n) != 0) {
#line 222
      dc = (struct demangle_component *)((void *)0);
    }
  }
  {
#line 224
  free((void *)di.subs);
  }
#line 226
  if ((unsigned long )dc != (unsigned long )((void *)0)) {
#line 227
    *mem = (void *)di.comps;
  } else {
    {
#line 229
    free((void *)di.comps);
    }
  }
#line 231
  return (dc);
}
}
#line 155 "./../include/demangle.h"
int cplus_demangle_v3_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) ;
#line 162
int java_demangle_v3_callback(char const   *mangled , void (*callback)(char const   * ,
                                                                       size_t  , void * ) ,
                              void *opaque ) ;
#line 183
enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor(char const   *name___0 ) ;
#line 198
enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor(char const   *name___0 ) ;
#line 561
int cplus_demangle_fill_name(struct demangle_component *p , char const   *s , int len ) ;
#line 587
int cplus_demangle_fill_extended_operator(struct demangle_component *p , int args ,
                                          struct demangle_component *name___0 ) ;
#line 595
int cplus_demangle_fill_ctor(struct demangle_component *p , enum gnu_v3_ctor_kinds kind ,
                             struct demangle_component *name___0 ) ;
#line 603
int cplus_demangle_fill_dtor(struct demangle_component *p , enum gnu_v3_dtor_kinds kind ,
                             struct demangle_component *name___0 ) ;
#line 631
char *cplus_demangle_print(int options___0 , struct demangle_component  const  *dc ,
                           int estimate , size_t *palc ) ;
#line 651
int cplus_demangle_print_callback(int options___0 , struct demangle_component  const  *dc ,
                                  void (*callback)(char const   * , size_t  , void * ) ,
                                  void *opaque ) ;
#line 311 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_empty(struct d_info *di ) ;
#line 314
static struct demangle_component *d_make_comp(struct d_info *di , enum demangle_component_type type ,
                                              struct demangle_component *left , struct demangle_component *right ) ;
#line 319
static struct demangle_component *d_make_name(struct d_info *di , char const   *s ,
                                              int len ) ;
#line 322
static struct demangle_component *d_make_demangle_mangled_name(struct d_info *di ,
                                                               char const   *s ) ;
#line 325
static struct demangle_component *d_make_builtin_type(struct d_info *di , struct demangle_builtin_type_info  const  *type ) ;
#line 329
static struct demangle_component *d_make_operator(struct d_info *di , struct demangle_operator_info  const  *op ) ;
#line 333
static struct demangle_component *d_make_extended_operator(struct d_info *di , int args ,
                                                           struct demangle_component *name___0 ) ;
#line 337
static struct demangle_component *d_make_ctor(struct d_info *di , enum gnu_v3_ctor_kinds kind ,
                                              struct demangle_component *name___0 ) ;
#line 341
static struct demangle_component *d_make_dtor(struct d_info *di , enum gnu_v3_dtor_kinds kind ,
                                              struct demangle_component *name___0 ) ;
#line 345
static struct demangle_component *d_make_template_param(struct d_info *di , long i ) ;
#line 348
static struct demangle_component *d_make_sub(struct d_info *di , char const   *name___0 ,
                                             int len ) ;
#line 351
static int has_return_type(struct demangle_component *dc ) ;
#line 354
static int is_ctor_dtor_or_conversion(struct demangle_component *dc ) ;
#line 357
static struct demangle_component *d_encoding(struct d_info *di , int top_level ) ;
#line 359
static struct demangle_component *d_name(struct d_info *di ) ;
#line 361
static struct demangle_component *d_nested_name(struct d_info *di ) ;
#line 363
static struct demangle_component *d_prefix(struct d_info *di ) ;
#line 365
static struct demangle_component *d_unqualified_name(struct d_info *di ) ;
#line 367
static struct demangle_component *d_source_name(struct d_info *di ) ;
#line 369
static long d_number(struct d_info *di ) ;
#line 371
static struct demangle_component *d_identifier(struct d_info *di , int len ) ;
#line 373
static struct demangle_component *d_operator_name(struct d_info *di ) ;
#line 375
static struct demangle_component *d_special_name(struct d_info *di ) ;
#line 377
static int d_call_offset(struct d_info *di , int c ) ;
#line 379
static struct demangle_component *d_ctor_dtor_name(struct d_info *di ) ;
#line 381
static struct demangle_component **d_cv_qualifiers(struct d_info *di , struct demangle_component **pret ,
                                                   int member_fn ) ;
#line 384
static struct demangle_component *d_function_type(struct d_info *di ) ;
#line 387
static struct demangle_component *d_bare_function_type(struct d_info *di , int has_return_type___0 ) ;
#line 390
static struct demangle_component *d_class_enum_type(struct d_info *di ) ;
#line 393
static struct demangle_component *d_array_type(struct d_info *di ) ;
#line 395
static struct demangle_component *d_vector_type(struct d_info *di ) ;
#line 397
static struct demangle_component *d_pointer_to_member_type(struct d_info *di ) ;
#line 400
static struct demangle_component *d_template_param(struct d_info *di ) ;
#line 403
static struct demangle_component *d_template_args(struct d_info *di ) ;
#line 405
static struct demangle_component *d_template_arg(struct d_info *di ) ;
#line 408
static struct demangle_component *d_expression(struct d_info *di ) ;
#line 410
static struct demangle_component *d_expr_primary(struct d_info *di ) ;
#line 412
static struct demangle_component *d_local_name(struct d_info *di ) ;
#line 414
static int d_discriminator(struct d_info *di ) ;
#line 416
static struct demangle_component *d_lambda(struct d_info *di ) ;
#line 418
static struct demangle_component *d_unnamed_type(struct d_info *di ) ;
#line 420
static struct demangle_component *d_clone_suffix(struct d_info *di , struct demangle_component *encoding ) ;
#line 423
static int d_add_substitution(struct d_info *di , struct demangle_component *dc ) ;
#line 426
static struct demangle_component *d_substitution(struct d_info *di , int prefix ) ;
#line 428
static void d_growable_string_init(struct d_growable_string *dgs , size_t estimate ) ;
#line 430
__inline static void d_growable_string_resize(struct d_growable_string *dgs , size_t need ) ;
#line 433
__inline static void d_growable_string_append_buffer(struct d_growable_string *dgs ,
                                                     char const   *s , size_t l ) ;
#line 436
static void d_growable_string_callback_adapter(char const   *s , size_t l , void *opaque ) ;
#line 439
static void d_print_init(struct d_print_info *dpi , void (*callback)(char const   * ,
                                                                     size_t  , void * ) ,
                         void *opaque ) ;
#line 442
__inline static void d_print_error(struct d_print_info *dpi ) ;
#line 444
__inline static int d_print_saw_error(struct d_print_info *dpi ) ;
#line 446
__inline static void d_print_flush(struct d_print_info *dpi ) ;
#line 448
__inline static void d_append_char(struct d_print_info *dpi , char c ) ;
#line 450
__inline static void d_append_buffer(struct d_print_info *dpi , char const   *s ,
                                     size_t l ) ;
#line 453
__inline static void d_append_string(struct d_print_info *dpi , char const   *s ) ;
#line 455
__inline static char d_last_char(struct d_print_info *dpi ) ;
#line 457
static void d_print_comp(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) ;
#line 460
static void d_print_java_identifier(struct d_print_info *dpi , char const   *name___0 ,
                                    int len ) ;
#line 463
static void d_print_mod_list(struct d_print_info *dpi , int options___0 , struct d_print_mod *mods ,
                             int suffix ) ;
#line 466
static void d_print_mod(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *mod ) ;
#line 469
static void d_print_function_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                                  struct d_print_mod *mods ) ;
#line 474
static void d_print_array_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                               struct d_print_mod *mods ) ;
#line 479
static void d_print_expr_op(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) ;
#line 482
static void d_print_cast(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) ;
#line 485
static int d_demangle_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) ;
#line 487
static char *d_demangle(char const   *mangled , int options___0 , size_t *palc ) ;
#line 710 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int cplus_demangle_fill_name(struct demangle_component *p , char const   *s , int len ) 
{ 


  {
#line 713
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 714
    return (0);
  } else
#line 713
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 714
    return (0);
  } else
#line 713
  if (len == 0) {
#line 714
    return (0);
  }
#line 715
  p->type = (enum demangle_component_type )0;
#line 716
  p->u.s_name.s = s;
#line 717
  p->u.s_name.len = len;
#line 718
  return (1);
}
}
#line 724 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int cplus_demangle_fill_extended_operator(struct demangle_component *p , int args ,
                                          struct demangle_component *name___0 ) 
{ 


  {
#line 728
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 729
    return (0);
  } else
#line 728
  if (args < 0) {
#line 729
    return (0);
  } else
#line 728
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 729
    return (0);
  }
#line 730
  p->type = (enum demangle_component_type )46;
#line 731
  p->u.s_extended_operator.args = args;
#line 732
  p->u.s_extended_operator.name = name___0;
#line 733
  return (1);
}
}
#line 739 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int cplus_demangle_fill_ctor(struct demangle_component *p , enum gnu_v3_ctor_kinds kind ,
                             struct demangle_component *name___0 ) 
{ 


  {
#line 744
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 748
    return (0);
  } else
#line 744
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 748
    return (0);
  } else
#line 744
  if ((int )kind < 1) {
#line 748
    return (0);
  } else
#line 744
  if ((int )kind > 4) {
#line 748
    return (0);
  }
#line 749
  p->type = (enum demangle_component_type )7;
#line 750
  p->u.s_ctor.kind = kind;
#line 751
  p->u.s_ctor.name = name___0;
#line 752
  return (1);
}
}
#line 758 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int cplus_demangle_fill_dtor(struct demangle_component *p , enum gnu_v3_dtor_kinds kind ,
                             struct demangle_component *name___0 ) 
{ 


  {
#line 763
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 767
    return (0);
  } else
#line 763
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
#line 767
    return (0);
  } else
#line 763
  if ((int )kind < 1) {
#line 767
    return (0);
  } else
#line 763
  if ((int )kind > 4) {
#line 767
    return (0);
  }
#line 768
  p->type = (enum demangle_component_type )8;
#line 769
  p->u.s_dtor.kind = kind;
#line 770
  p->u.s_dtor.name = name___0;
#line 771
  return (1);
}
}
#line 776 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_empty(struct d_info *di ) 
{ 
  struct demangle_component *p ;

  {
#line 781
  if (di->next_comp >= di->num_comps) {
#line 782
    return ((struct demangle_component *)((void *)0));
  }
#line 783
  p = di->comps + di->next_comp;
#line 784
  (di->next_comp) ++;
#line 785
  return (p);
}
}
#line 790 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_comp(struct d_info *di , enum demangle_component_type type ,
                                              struct demangle_component *left , struct demangle_component *right ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 819
  if ((unsigned int )type == 70U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 41U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 58U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 56U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 55U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 53U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 52U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 51U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 50U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 49U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 39U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 29U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 11U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 4U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 3U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 2U) {
#line 819
    goto case_70;
  }
#line 819
  if ((unsigned int )type == 1U) {
#line 819
    goto case_70;
  }
#line 852
  if ((unsigned int )type == 54U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 48U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 63U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 62U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 69U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 61U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 57U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 47U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 36U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 34U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 33U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 32U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 31U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 30U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 68U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 67U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 21U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 20U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 19U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 18U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 17U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 16U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 15U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 14U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 13U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 12U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 10U) {
#line 852
    goto case_54;
  }
#line 852
  if ((unsigned int )type == 9U) {
#line 852
    goto case_54;
  }
#line 860
  if ((unsigned int )type == 44U) {
#line 860
    goto case_44;
  }
#line 860
  if ((unsigned int )type == 38U) {
#line 860
    goto case_44;
  }
#line 875
  if ((unsigned int )type == 43U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 42U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 28U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 27U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 26U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 25U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 24U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 23U) {
#line 875
    goto case_43;
  }
#line 875
  if ((unsigned int )type == 37U) {
#line 875
    goto case_43;
  }
#line 879
  goto switch_default;
  case_70: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 820
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 821
    return ((struct demangle_component *)((void *)0));
  } else
#line 820
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 821
    return ((struct demangle_component *)((void *)0));
  }
#line 822
  goto switch_break;
  case_54: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 853
  if ((unsigned long )left == (unsigned long )((void *)0)) {
#line 854
    return ((struct demangle_component *)((void *)0));
  }
#line 855
  goto switch_break;
  case_44: /* CIL Label */ 
  case_38: /* CIL Label */ 
#line 861
  if ((unsigned long )right == (unsigned long )((void *)0)) {
#line 862
    return ((struct demangle_component *)((void *)0));
  }
#line 863
  goto switch_break;
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_37: /* CIL Label */ 
#line 876
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 880
  return ((struct demangle_component *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
  {
#line 883
  p = d_make_empty(di);
  }
#line 884
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 886
    p->type = type;
#line 887
    p->u.s_binary.left = left;
#line 888
    p->u.s_binary.right = right;
  }
#line 890
  return (p);
}
}
#line 895 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_demangle_mangled_name(struct d_info *di ,
                                                               char const   *s ) 
{ 
  size_t tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 898
  if ((int const   )*(di->n) != 95) {
    {
#line 899
    tmp___0 = strlen(s);
#line 899
    tmp___1 = d_make_name(di, s, (int )tmp___0);
    }
#line 899
    return (tmp___1);
  } else
#line 898
  if ((int const   )*(di->n + 1) != 90) {
    {
#line 899
    tmp___0 = strlen(s);
#line 899
    tmp___1 = d_make_name(di, s, (int )tmp___0);
    }
#line 899
    return (tmp___1);
  }
  {
#line 900
  di->n += 2;
#line 901
  tmp___2 = d_encoding(di, 0);
  }
#line 901
  return (tmp___2);
}
}
#line 906 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_name(struct d_info *di , char const   *s ,
                                              int len ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 911
  p = d_make_empty(di);
#line 912
  tmp___0 = cplus_demangle_fill_name(p, s, len);
  }
#line 912
  if (! tmp___0) {
#line 913
    return ((struct demangle_component *)((void *)0));
  }
#line 914
  return (p);
}
}
#line 919 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_builtin_type(struct d_info *di , struct demangle_builtin_type_info  const  *type ) 
{ 
  struct demangle_component *p ;

  {
#line 925
  if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 926
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 927
  p = d_make_empty(di);
  }
#line 928
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 930
    p->type = (enum demangle_component_type )35;
#line 931
    p->u.s_builtin.type = type;
  }
#line 933
  return (p);
}
}
#line 938 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_operator(struct d_info *di , struct demangle_operator_info  const  *op ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 943
  p = d_make_empty(di);
  }
#line 944
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 946
    p->type = (enum demangle_component_type )45;
#line 947
    p->u.s_operator.op = op;
  }
#line 949
  return (p);
}
}
#line 954 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_extended_operator(struct d_info *di , int args ,
                                                           struct demangle_component *name___0 ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 960
  p = d_make_empty(di);
#line 961
  tmp___0 = cplus_demangle_fill_extended_operator(p, args, name___0);
  }
#line 961
  if (! tmp___0) {
#line 962
    return ((struct demangle_component *)((void *)0));
  }
#line 963
  return (p);
}
}
#line 966 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_default_arg(struct d_info *di , int num ,
                                                     struct demangle_component *sub ) 
{ 
  struct demangle_component *p ;
  struct demangle_component *tmp___0 ;

  {
  {
#line 970
  tmp___0 = d_make_empty(di);
#line 970
  p = tmp___0;
  }
#line 971
  if (p) {
#line 973
    p->type = (enum demangle_component_type )65;
#line 974
    p->u.s_unary_num.num = num;
#line 975
    p->u.s_unary_num.sub = sub;
  }
#line 977
  return (p);
}
}
#line 982 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_ctor(struct d_info *di , enum gnu_v3_ctor_kinds kind ,
                                              struct demangle_component *name___0 ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 988
  p = d_make_empty(di);
#line 989
  tmp___0 = cplus_demangle_fill_ctor(p, kind, name___0);
  }
#line 989
  if (! tmp___0) {
#line 990
    return ((struct demangle_component *)((void *)0));
  }
#line 991
  return (p);
}
}
#line 996 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_dtor(struct d_info *di , enum gnu_v3_dtor_kinds kind ,
                                              struct demangle_component *name___0 ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;

  {
  {
#line 1002
  p = d_make_empty(di);
#line 1003
  tmp___0 = cplus_demangle_fill_dtor(p, kind, name___0);
  }
#line 1003
  if (! tmp___0) {
#line 1004
    return ((struct demangle_component *)((void *)0));
  }
#line 1005
  return (p);
}
}
#line 1010 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_template_param(struct d_info *di , long i ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1015
  p = d_make_empty(di);
  }
#line 1016
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1018
    p->type = (enum demangle_component_type )5;
#line 1019
    p->u.s_number.number = i;
  }
#line 1021
  return (p);
}
}
#line 1026 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_function_param(struct d_info *di , long i ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1031
  p = d_make_empty(di);
  }
#line 1032
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1034
    p->type = (enum demangle_component_type )6;
#line 1035
    p->u.s_number.number = i;
  }
#line 1037
  return (p);
}
}
#line 1042 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_sub(struct d_info *di , char const   *name___0 ,
                                             int len ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1047
  p = d_make_empty(di);
  }
#line 1048
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1050
    p->type = (enum demangle_component_type )22;
#line 1051
    p->u.s_string.string = name___0;
#line 1052
    p->u.s_string.len = len;
  }
#line 1054
  return (p);
}
}
#line 1062 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct demangle_component *cplus_demangle_mangled_name(struct d_info *di , int top_level ) 
{ 
  struct demangle_component *p ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1067
  if ((int const   )*(di->n) == 95) {
#line 1067
    (di->n) ++;
#line 1067
    tmp___0 = 1;
  } else {
#line 1067
    tmp___0 = 0;
  }
#line 1067
  if (! tmp___0) {
#line 1067
    if (top_level) {
#line 1072
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 1073
  if ((int const   )*(di->n) == 90) {
#line 1073
    (di->n) ++;
#line 1073
    tmp___1 = 1;
  } else {
#line 1073
    tmp___1 = 0;
  }
#line 1073
  if (! tmp___1) {
#line 1074
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1075
  p = d_encoding(di, top_level);
  }
#line 1079
  if (top_level) {
#line 1079
    if ((di->options & 1) != 0) {
      {
#line 1080
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1080
        if ((int const   )*(di->n) == 46) {
#line 1080
          if ((int const   )*(di->n + 1) >= 97) {
#line 1080
            if (! ((int const   )*(di->n + 1) <= 122)) {
#line 1080
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1080
          if (! ((int const   )*(di->n + 1) == 95)) {
#line 1080
            if ((int const   )*(di->n + 1) >= 48) {
#line 1080
              if (! ((int const   )*(di->n + 1) <= 57)) {
#line 1080
                goto while_break;
              }
            } else {
#line 1080
              goto while_break;
            }
          }
        } else {
#line 1080
          goto while_break;
        }
        {
#line 1084
        p = d_clone_suffix(di, p);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1086
  return (p);
}
}
#line 1098 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int has_return_type(struct demangle_component *dc ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1101
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 1102
    return (0);
  }
  {
#line 1107
  if ((unsigned int )dc->type == 4U) {
#line 1107
    goto case_4;
  }
#line 1111
  if ((unsigned int )dc->type == 28U) {
#line 1111
    goto case_28;
  }
#line 1111
  if ((unsigned int )dc->type == 27U) {
#line 1111
    goto case_28;
  }
#line 1111
  if ((unsigned int )dc->type == 26U) {
#line 1111
    goto case_28;
  }
#line 1105
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1106
  return (0);
  case_4: /* CIL Label */ 
  {
#line 1108
  tmp___0 = is_ctor_dtor_or_conversion(dc->u.s_binary.left);
  }
#line 1108
  if (tmp___0) {
#line 1108
    tmp___1 = 0;
  } else {
#line 1108
    tmp___1 = 1;
  }
#line 1108
  return (tmp___1);
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  {
#line 1112
  tmp___2 = has_return_type(dc->u.s_binary.left);
  }
#line 1112
  return (tmp___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1119 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int is_ctor_dtor_or_conversion(struct demangle_component *dc ) 
{ 
  int tmp___0 ;

  {
#line 1122
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 1123
    return (0);
  }
  {
#line 1129
  if ((unsigned int )dc->type == 2U) {
#line 1129
    goto case_2;
  }
#line 1129
  if ((unsigned int )dc->type == 1U) {
#line 1129
    goto case_2;
  }
#line 1133
  if ((unsigned int )dc->type == 47U) {
#line 1133
    goto case_47;
  }
#line 1133
  if ((unsigned int )dc->type == 8U) {
#line 1133
    goto case_47;
  }
#line 1133
  if ((unsigned int )dc->type == 7U) {
#line 1133
    goto case_47;
  }
#line 1126
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1127
  return (0);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1130
  tmp___0 = is_ctor_dtor_or_conversion(dc->u.s_binary.right);
  }
#line 1130
  return (tmp___0);
  case_47: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 1134
  return (1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1147 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_encoding(struct d_info *di , int top_level ) 
{ 
  char peek ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *dc ;
  struct demangle_component *dcr ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
#line 1150
  peek = (char )*(di->n);
#line 1152
  if ((int )peek == 71) {
    {
#line 1153
    tmp___0 = d_special_name(di);
    }
#line 1153
    return (tmp___0);
  } else
#line 1152
  if ((int )peek == 84) {
    {
#line 1153
    tmp___0 = d_special_name(di);
    }
#line 1153
    return (tmp___0);
  } else {
    {
#line 1158
    dc = d_name(di);
    }
#line 1160
    if ((unsigned long )dc != (unsigned long )((void *)0)) {
#line 1160
      if (top_level) {
#line 1160
        if ((di->options & 1) == 0) {
          {
#line 1165
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1165
            if (! ((unsigned int )dc->type == 26U)) {
#line 1165
              if (! ((unsigned int )dc->type == 27U)) {
#line 1165
                if (! ((unsigned int )dc->type == 28U)) {
#line 1165
                  goto while_break;
                }
              }
            }
#line 1168
            dc = dc->u.s_binary.left;
          }
          while_break: /* CIL Label */ ;
          }
#line 1174
          if ((unsigned int )dc->type == 2U) {
#line 1178
            dcr = dc->u.s_binary.right;
            {
#line 1179
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1179
              if (! ((unsigned int )dcr->type == 26U)) {
#line 1179
                if (! ((unsigned int )dcr->type == 27U)) {
#line 1179
                  if (! ((unsigned int )dcr->type == 28U)) {
#line 1179
                    goto while_break___0;
                  }
                }
              }
#line 1182
              dcr = dcr->u.s_binary.left;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1183
            dc->u.s_binary.right = dcr;
          }
#line 1186
          return (dc);
        }
      }
    }
#line 1189
    peek = (char )*(di->n);
#line 1190
    if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 1191
      return (dc);
    } else
#line 1190
    if ((int )peek == 0) {
#line 1191
      return (dc);
    } else
#line 1190
    if ((int )peek == 69) {
#line 1191
      return (dc);
    }
    {
#line 1192
    tmp___1 = has_return_type(dc);
#line 1192
    tmp___2 = d_bare_function_type(di, tmp___1);
#line 1192
    tmp___3 = d_make_comp(di, (enum demangle_component_type )3, dc, tmp___2);
    }
#line 1192
    return (tmp___3);
  }
}
}
#line 1209 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_name(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *dc ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;
  int subst ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  int tmp___5 ;
  struct demangle_component *tmp___6 ;
  int tmp___7 ;
  struct demangle_component *tmp___8 ;

  {
#line 1212
  peek = (char )*(di->n);
  {
#line 1217
  if ((int )peek == 78) {
#line 1217
    goto case_78;
  }
#line 1220
  if ((int )peek == 90) {
#line 1220
    goto case_90;
  }
#line 1224
  if ((int )peek == 85) {
#line 1224
    goto case_85;
  }
#line 1224
  if ((int )peek == 76) {
#line 1224
    goto case_85;
  }
#line 1227
  if ((int )peek == 83) {
#line 1227
    goto case_83;
  }
#line 1270
  goto switch_default;
  case_78: /* CIL Label */ 
  {
#line 1218
  tmp___0 = d_nested_name(di);
  }
#line 1218
  return (tmp___0);
  case_90: /* CIL Label */ 
  {
#line 1221
  tmp___1 = d_local_name(di);
  }
#line 1221
  return (tmp___1);
  case_85: /* CIL Label */ 
  case_76: /* CIL Label */ 
  {
#line 1225
  tmp___2 = d_unqualified_name(di);
  }
#line 1225
  return (tmp___2);
  case_83: /* CIL Label */ 
#line 1231
  if ((int const   )*(di->n + 1) != 116) {
    {
#line 1233
    dc = d_substitution(di, 0);
#line 1234
    subst = 1;
    }
  } else {
    {
#line 1238
    di->n += 2;
#line 1239
    tmp___3 = d_unqualified_name(di);
#line 1239
    tmp___4 = d_make_name(di, "std", 3);
#line 1239
    dc = d_make_comp(di, (enum demangle_component_type )1, tmp___4, tmp___3);
#line 1242
    di->expansion += 3;
#line 1243
    subst = 0;
    }
  }
#line 1246
  if (! ((int const   )*(di->n) != 73)) {
#line 1258
    if (! subst) {
      {
#line 1260
      tmp___5 = d_add_substitution(di, dc);
      }
#line 1260
      if (! tmp___5) {
#line 1261
        return ((struct demangle_component *)((void *)0));
      }
    }
    {
#line 1263
    tmp___6 = d_template_args(di);
#line 1263
    dc = d_make_comp(di, (enum demangle_component_type )4, dc, tmp___6);
    }
  }
#line 1267
  return (dc);
  switch_default: /* CIL Label */ 
  {
#line 1271
  dc = d_unqualified_name(di);
  }
#line 1272
  if ((int const   )*(di->n) == 73) {
    {
#line 1277
    tmp___7 = d_add_substitution(di, dc);
    }
#line 1277
    if (! tmp___7) {
#line 1278
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1279
    tmp___8 = d_template_args(di);
#line 1279
    dc = d_make_comp(di, (enum demangle_component_type )4, dc, tmp___8);
    }
  }
#line 1282
  return (dc);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_nested_name(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  struct demangle_component **pret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1296
  if ((int const   )*(di->n) == 78) {
#line 1296
    (di->n) ++;
#line 1296
    tmp___0 = 1;
  } else {
#line 1296
    tmp___0 = 0;
  }
#line 1296
  if (! tmp___0) {
#line 1297
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1299
  pret = d_cv_qualifiers(di, & ret, 1);
  }
#line 1300
  if ((unsigned long )pret == (unsigned long )((void *)0)) {
#line 1301
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1303
  *pret = d_prefix(di);
  }
#line 1304
  if ((unsigned long )*pret == (unsigned long )((void *)0)) {
#line 1305
    return ((struct demangle_component *)((void *)0));
  }
#line 1307
  if ((int const   )*(di->n) == 69) {
#line 1307
    (di->n) ++;
#line 1307
    tmp___1 = 1;
  } else {
#line 1307
    tmp___1 = 0;
  }
#line 1307
  if (! tmp___1) {
#line 1308
    return ((struct demangle_component *)((void *)0));
  }
#line 1310
  return (ret);
}
}
#line 1325 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_prefix(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  char peek ;
  enum demangle_component_type comb_type ;
  struct demangle_component *dc ;
  char peek2 ;
  int tmp___0 ;

  {
#line 1328
  ret = (struct demangle_component *)((void *)0);
  {
#line 1330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1336
    peek = (char )*(di->n);
#line 1337
    if ((int )peek == 0) {
#line 1338
      return ((struct demangle_component *)((void *)0));
    }
#line 1344
    comb_type = (enum demangle_component_type )1;
#line 1345
    if ((int )peek == 68) {
#line 1347
      peek2 = (char )*(di->n + 1);
#line 1348
      if ((int )peek2 == 84) {
        {
#line 1350
        dc = cplus_demangle_type(di);
        }
      } else
#line 1348
      if ((int )peek2 == 116) {
        {
#line 1350
        dc = cplus_demangle_type(di);
        }
      } else {
        {
#line 1353
        dc = d_unqualified_name(di);
        }
      }
    } else
#line 1355
    if ((int )peek >= 48) {
#line 1355
      if ((int )peek <= 57) {
        {
#line 1360
        dc = d_unqualified_name(di);
        }
      } else {
#line 1355
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1355
    if ((int )peek >= 97) {
#line 1355
      if ((int )peek <= 122) {
        {
#line 1360
        dc = d_unqualified_name(di);
        }
      } else {
#line 1355
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1355
    if ((int )peek == 67) {
      {
#line 1360
      dc = d_unqualified_name(di);
      }
    } else
#line 1355
    if ((int )peek == 85) {
      {
#line 1360
      dc = d_unqualified_name(di);
      }
    } else
#line 1355
    if ((int )peek == 76) {
      {
#line 1360
      dc = d_unqualified_name(di);
      }
    } else
#line 1361
    if ((int )peek == 83) {
      {
#line 1362
      dc = d_substitution(di, 1);
      }
    } else
#line 1363
    if ((int )peek == 73) {
#line 1365
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1366
        return ((struct demangle_component *)((void *)0));
      }
      {
#line 1367
      comb_type = (enum demangle_component_type )4;
#line 1368
      dc = d_template_args(di);
      }
    } else
#line 1370
    if ((int )peek == 84) {
      {
#line 1371
      dc = d_template_param(di);
      }
    } else
#line 1372
    if ((int )peek == 69) {
#line 1373
      return (ret);
    } else
#line 1374
    if ((int )peek == 77) {
#line 1379
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1380
        return ((struct demangle_component *)((void *)0));
      }
#line 1381
      (di->n) ++;
#line 1382
      goto while_continue;
    } else {
#line 1385
      return ((struct demangle_component *)((void *)0));
    }
#line 1387
    if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 1388
      ret = dc;
    } else {
      {
#line 1390
      ret = d_make_comp(di, comb_type, ret, dc);
      }
    }
#line 1392
    if ((int )peek != 83) {
#line 1392
      if ((int const   )*(di->n) != 69) {
        {
#line 1394
        tmp___0 = d_add_substitution(di, ret);
        }
#line 1394
        if (! tmp___0) {
#line 1395
          return ((struct demangle_component *)((void *)0));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1408 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_unqualified_name(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *ret ;
  struct demangle_component *tmp___1 ;
  int tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *ret___0 ;
  int tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;

  {
#line 1413
  peek = (char )*(di->n);
#line 1414
  if ((int )peek >= 48) {
#line 1414
    if ((int )peek <= 57) {
      {
#line 1415
      tmp___0 = d_source_name(di);
      }
#line 1415
      return (tmp___0);
    } else {
#line 1414
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1416
  if ((int )peek >= 97) {
#line 1416
    if ((int )peek <= 122) {
      {
#line 1420
      ret = d_operator_name(di);
      }
#line 1421
      if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 1421
        if ((unsigned int )ret->type == 45U) {
          {
#line 1423
          di->expansion = (int )((unsigned long )di->expansion + ((sizeof("operator") + (unsigned long )(ret->u.s_operator.op)->len) - 2UL));
#line 1424
          tmp___2 = strcmp((char const   *)(ret->u.s_operator.op)->code, "li");
          }
#line 1424
          if (! tmp___2) {
            {
#line 1425
            tmp___1 = d_source_name(di);
#line 1425
            ret = d_make_comp(di, (enum demangle_component_type )49, ret, tmp___1);
            }
          }
        }
      }
#line 1428
      return (ret);
    } else {
#line 1416
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1430
  if ((int )peek == 67) {
    {
#line 1431
    tmp___3 = d_ctor_dtor_name(di);
    }
#line 1431
    return (tmp___3);
  } else
#line 1430
  if ((int )peek == 68) {
    {
#line 1431
    tmp___3 = d_ctor_dtor_name(di);
    }
#line 1431
    return (tmp___3);
  } else
#line 1432
  if ((int )peek == 76) {
    {
#line 1436
    (di->n) ++;
#line 1438
    ret___0 = d_source_name(di);
    }
#line 1439
    if ((unsigned long )ret___0 == (unsigned long )((void *)0)) {
#line 1440
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1441
    tmp___4 = d_discriminator(di);
    }
#line 1441
    if (! tmp___4) {
#line 1442
      return ((struct demangle_component *)((void *)0));
    }
#line 1443
    return (ret___0);
  } else
#line 1445
  if ((int )peek == 85) {
    {
#line 1449
    if ((int const   )*(di->n + 1) == 108) {
#line 1449
      goto case_108;
    }
#line 1451
    if ((int const   )*(di->n + 1) == 116) {
#line 1451
      goto case_116;
    }
#line 1453
    goto switch_default;
    case_108: /* CIL Label */ 
    {
#line 1450
    tmp___5 = d_lambda(di);
    }
#line 1450
    return (tmp___5);
    case_116: /* CIL Label */ 
    {
#line 1452
    tmp___6 = d_unnamed_type(di);
    }
#line 1452
    return (tmp___6);
    switch_default: /* CIL Label */ 
#line 1454
    return ((struct demangle_component *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1458
    return ((struct demangle_component *)((void *)0));
  }
}
}
#line 1463 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_source_name(struct d_info *di ) 
{ 
  long len ;
  struct demangle_component *ret ;

  {
  {
#line 1469
  len = d_number(di);
  }
#line 1470
  if (len <= 0L) {
#line 1471
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 1472
  ret = d_identifier(di, (int )len);
#line 1473
  di->last_name = ret;
  }
#line 1474
  return (ret);
}
}
#line 1479 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static long d_number(struct d_info *di ) 
{ 
  int negative ;
  char peek ;
  long ret ;

  {
#line 1486
  negative = 0;
#line 1487
  peek = (char )*(di->n);
#line 1488
  if ((int )peek == 110) {
#line 1490
    negative = 1;
#line 1491
    (di->n) ++;
#line 1492
    peek = (char )*(di->n);
  }
#line 1495
  ret = 0L;
  {
#line 1496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1498
    if ((int )peek >= 48) {
#line 1498
      if (! ((int )peek <= 57)) {
#line 1498
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 1500
      if (negative) {
#line 1501
        ret = - ret;
      }
#line 1502
      return (ret);
    }
#line 1504
    ret = (ret * 10L + (long )peek) - 48L;
#line 1505
    (di->n) ++;
#line 1506
    peek = (char )*(di->n);
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1512 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_number_component(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  struct demangle_component *tmp___0 ;

  {
  {
#line 1515
  tmp___0 = d_make_empty(di);
#line 1515
  ret = tmp___0;
  }
#line 1516
  if (ret) {
    {
#line 1518
    ret->type = (enum demangle_component_type )60;
#line 1519
    ret->u.s_number.number = d_number(di);
    }
  }
#line 1521
  return (ret);
}
}
#line 1526 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_identifier(struct d_info *di , int len ) 
{ 
  char const   *name___0 ;
  char const   *s ;
  struct demangle_component *tmp___0 ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 1531
  name___0 = di->n;
#line 1533
  if (di->send - name___0 < (long )len) {
#line 1534
    return ((struct demangle_component *)((void *)0));
  }
#line 1536
  di->n += len;
#line 1541
  if ((di->options & (1 << 2)) != 0) {
#line 1541
    if ((int const   )*(di->n) == 36) {
#line 1543
      (di->n) ++;
    }
  }
#line 1548
  if (len >= (int )(sizeof("_GLOBAL_") - 1UL) + 2) {
    {
#line 1548
    tmp___1 = memcmp((void const   *)name___0, (void const   *)"_GLOBAL_", sizeof("_GLOBAL_") - 1UL);
    }
#line 1548
    if (tmp___1 == 0) {
#line 1554
      s = name___0 + (sizeof("_GLOBAL_") - 1UL);
#line 1555
      if ((int const   )*s == 46) {
#line 1555
        goto _L;
      } else
#line 1555
      if ((int const   )*s == 95) {
#line 1555
        goto _L;
      } else
#line 1555
      if ((int const   )*s == 36) {
        _L: /* CIL Label */ 
#line 1555
        if ((int const   )*(s + 1) == 78) {
          {
#line 1558
          di->expansion = (int )((unsigned long )di->expansion - ((unsigned long )len - sizeof("(anonymous namespace)")));
#line 1559
          tmp___0 = d_make_name(di, "(anonymous namespace)", (int )(sizeof("(anonymous namespace)") - 1UL));
          }
#line 1559
          return (tmp___0);
        }
      }
    }
  }
  {
#line 1564
  tmp___2 = d_make_name(di, name___0, len);
  }
#line 1564
  return (tmp___2);
}
}
#line 1576 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct demangle_operator_info  const  cplus_demangle_operators[62]  = 
#line 1576
  {      {"aN", "&=", (int )(sizeof("&=") - 1UL), 2}, 
        {"aS", "=", (int )(sizeof("=") - 1UL), 2}, 
        {"aa", "&&", (int )(sizeof("&&") - 1UL), 2}, 
        {"ad", "&", (int )(sizeof("&") - 1UL), 1}, 
        {"an", "&", (int )(sizeof("&") - 1UL), 2}, 
        {"at", "alignof ", (int )(sizeof("alignof ") - 1UL), 1}, 
        {"az", "alignof ", (int )(sizeof("alignof ") - 1UL), 1}, 
        {"cc", "const_cast", (int )(sizeof("const_cast") - 1UL), 2}, 
        {"cl", "()", (int )(sizeof("()") - 1UL), 2}, 
        {"cm", ",", (int )(sizeof(",") - 1UL), 2}, 
        {"co", "~", (int )(sizeof("~") - 1UL), 1}, 
        {"dV", "/=", (int )(sizeof("/=") - 1UL), 2}, 
        {"da", "delete[] ", (int )(sizeof("delete[] ") - 1UL), 1}, 
        {"dc", "dynamic_cast", (int )(sizeof("dynamic_cast") - 1UL), 2}, 
        {"de", "*", (int )(sizeof("*") - 1UL), 1}, 
        {"dl", "delete ", (int )(sizeof("delete ") - 1UL), 1}, 
        {"ds", ".*", (int )(sizeof(".*") - 1UL), 2}, 
        {"dt", ".", (int )(sizeof(".") - 1UL), 2}, 
        {"dv", "/", (int )(sizeof("/") - 1UL), 2}, 
        {"eO", "^=", (int )(sizeof("^=") - 1UL), 2}, 
        {"eo", "^", (int )(sizeof("^") - 1UL), 2}, 
        {"eq", "==", (int )(sizeof("==") - 1UL), 2}, 
        {"ge", ">=", (int )(sizeof(">=") - 1UL), 2}, 
        {"gs", "::", (int )(sizeof("::") - 1UL), 1}, 
        {"gt", ">", (int )(sizeof(">") - 1UL), 2}, 
        {"ix", "[]", (int )(sizeof("[]") - 1UL), 2}, 
        {"lS", "<<=", (int )(sizeof("<<=") - 1UL), 2}, 
        {"le", "<=", (int )(sizeof("<=") - 1UL), 2}, 
        {"li", "operator\"\" ", (int )(sizeof("operator\"\" ") - 1UL), 1}, 
        {"ls", "<<", (int )(sizeof("<<") - 1UL), 2}, 
        {"lt", "<", (int )(sizeof("<") - 1UL), 2}, 
        {"mI", "-=", (int )(sizeof("-=") - 1UL), 2}, 
        {"mL", "*=", (int )(sizeof("*=") - 1UL), 2}, 
        {"mi", "-", (int )(sizeof("-") - 1UL), 2}, 
        {"ml", "*", (int )(sizeof("*") - 1UL), 2}, 
        {"mm", "--", (int )(sizeof("--") - 1UL), 1}, 
        {"na", "new[]", (int )(sizeof("new[]") - 1UL), 3}, 
        {"ne", "!=", (int )(sizeof("!=") - 1UL), 2}, 
        {"ng", "-", (int )(sizeof("-") - 1UL), 1}, 
        {"nt", "!", (int )(sizeof("!") - 1UL), 1}, 
        {"nw", "new", (int )(sizeof("new") - 1UL), 3}, 
        {"oR", "|=", (int )(sizeof("|=") - 1UL), 2}, 
        {"oo", "||", (int )(sizeof("||") - 1UL), 2}, 
        {"or", "|", (int )(sizeof("|") - 1UL), 2}, 
        {"pL", "+=", (int )(sizeof("+=") - 1UL), 2}, 
        {"pl", "+", (int )(sizeof("+") - 1UL), 2}, 
        {"pm", "->*", (int )(sizeof("->*") - 1UL), 2}, 
        {"pp", "++", (int )(sizeof("++") - 1UL), 1}, 
        {"ps", "+", (int )(sizeof("+") - 1UL), 1}, 
        {"pt", "->", (int )(sizeof("->") - 1UL), 2}, 
        {"qu", "?", (int )(sizeof("?") - 1UL), 3}, 
        {"rM", "%=", (int )(sizeof("%=") - 1UL), 2}, 
        {"rS", ">>=", (int )(sizeof(">>=") - 1UL), 2}, 
        {"rc", "reinterpret_cast", (int )(sizeof("reinterpret_cast") - 1UL), 2}, 
        {"rm", "%", (int )(sizeof("%") - 1UL), 2}, 
        {"rs", ">>", (int )(sizeof(">>") - 1UL), 2}, 
        {"sc", "static_cast", (int )(sizeof("static_cast") - 1UL), 2}, 
        {"st", "sizeof ", (int )(sizeof("sizeof ") - 1UL), 1}, 
        {"sz", "sizeof ", (int )(sizeof("sizeof ") - 1UL), 1}, 
        {"tr", "throw", (int )(sizeof("throw") - 1UL), 0}, 
        {"tw", "throw ", (int )(sizeof("throw ") - 1UL), 1}, 
        {(char const   *)((void *)0), (char const   *)((void *)0), 0, 0}};
#line 1642 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_operator_name(struct d_info *di ) 
{ 
  char c1 ;
  char c2 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  int low ;
  int high ;
  int i ;
  struct demangle_operator_info  const  *p ;
  struct demangle_component *tmp___6 ;

  {
#line 1648
  if ((int const   )*(di->n) == 0) {
#line 1648
    c1 = (char )'\000';
  } else {
#line 1648
    tmp___0 = di->n;
#line 1648
    (di->n) ++;
#line 1648
    c1 = (char )*tmp___0;
  }
#line 1649
  if ((int const   )*(di->n) == 0) {
#line 1649
    c2 = (char )'\000';
  } else {
#line 1649
    tmp___1 = di->n;
#line 1649
    (di->n) ++;
#line 1649
    c2 = (char )*tmp___1;
  }
#line 1650
  if ((int )c1 == 118) {
#line 1650
    if ((int )c2 >= 48) {
#line 1650
      if ((int )c2 <= 57) {
        {
#line 1651
        tmp___2 = d_source_name(di);
#line 1651
        tmp___3 = d_make_extended_operator(di, (int )c2 - 48, tmp___2);
        }
#line 1651
        return (tmp___3);
      } else {
#line 1650
        goto _L___0;
      }
    } else {
#line 1650
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1652
  if ((int )c1 == 99) {
#line 1652
    if ((int )c2 == 118) {
      {
#line 1653
      tmp___4 = cplus_demangle_type(di);
#line 1653
      tmp___5 = d_make_comp(di, (enum demangle_component_type )47, tmp___4, (struct demangle_component *)((void *)0));
      }
#line 1653
      return (tmp___5);
    } else {
#line 1652
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1658
    low = 0;
#line 1661
    high = (int )(sizeof(cplus_demangle_operators) / sizeof(cplus_demangle_operators[0]) - 1UL);
    {
#line 1665
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1670
      i = low + (high - low) / 2;
#line 1671
      p = cplus_demangle_operators + i;
#line 1673
      if ((int )c1 == (int )*(p->code + 0)) {
#line 1673
        if ((int )c2 == (int )*(p->code + 1)) {
          {
#line 1674
          tmp___6 = d_make_operator(di, p);
          }
#line 1674
          return (tmp___6);
        }
      }
#line 1676
      if ((int )c1 < (int )*(p->code + 0)) {
#line 1677
        high = i;
      } else
#line 1676
      if ((int )c1 == (int )*(p->code + 0)) {
#line 1676
        if ((int )c2 < (int )*(p->code + 1)) {
#line 1677
          high = i;
        } else {
#line 1679
          low = i + 1;
        }
      } else {
#line 1679
        low = i + 1;
      }
#line 1680
      if (low == high) {
#line 1681
        return ((struct demangle_component *)((void *)0));
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
}
}
#line 1686 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_make_character(struct d_info *di , int c ) 
{ 
  struct demangle_component *p ;

  {
  {
#line 1690
  p = d_make_empty(di);
  }
#line 1691
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1693
    p->type = (enum demangle_component_type )59;
#line 1694
    p->u.s_character.character = c;
  }
#line 1696
  return (p);
}
}
#line 1699 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_java_resource(struct d_info *di ) 
{ 
  struct demangle_component *p ;
  struct demangle_component *next ;
  long len ;
  long i ;
  char c ;
  char const   *str ;
  char const   *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 1702
  p = (struct demangle_component *)((void *)0);
#line 1703
  next = (struct demangle_component *)((void *)0);
#line 1708
  len = d_number(di);
  }
#line 1709
  if (len <= 1L) {
#line 1710
    return ((struct demangle_component *)((void *)0));
  }
#line 1713
  if ((int const   )*(di->n) == 0) {
#line 1713
    tmp___1 = '\000';
  } else {
#line 1713
    tmp___0 = di->n;
#line 1713
    (di->n) ++;
#line 1713
    tmp___1 = (int )*tmp___0;
  }
#line 1713
  if (tmp___1 != 95) {
#line 1714
    return ((struct demangle_component *)((void *)0));
  }
#line 1715
  len --;
#line 1717
  str = di->n;
#line 1718
  i = 0L;
  {
#line 1720
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1720
    if (! (len > 0L)) {
#line 1720
      goto while_break;
    }
#line 1722
    c = (char )*(str + i);
#line 1723
    if (! c) {
#line 1724
      return ((struct demangle_component *)((void *)0));
    }
#line 1727
    if ((int )c == 36) {
#line 1729
      i ++;
#line 1730
      tmp___2 = i;
#line 1730
      i ++;
      {
#line 1732
      if ((int const   )*(str + tmp___2) == 83) {
#line 1732
        goto case_83;
      }
#line 1735
      if ((int const   )*(str + tmp___2) == 95) {
#line 1735
        goto case_95;
      }
#line 1738
      if ((int const   )*(str + tmp___2) == 36) {
#line 1738
        goto case_36;
      }
#line 1741
      goto switch_default;
      case_83: /* CIL Label */ 
#line 1733
      c = (char )'/';
#line 1734
      goto switch_break;
      case_95: /* CIL Label */ 
#line 1736
      c = (char )'.';
#line 1737
      goto switch_break;
      case_36: /* CIL Label */ 
#line 1739
      c = (char )'$';
#line 1740
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1742
      return ((struct demangle_component *)((void *)0));
      switch_break: /* CIL Label */ ;
      }
      {
#line 1744
      next = d_make_character(di, (int )c);
#line 1745
      di->n += i;
#line 1746
      str = di->n;
#line 1747
      len -= i;
#line 1748
      i = 0L;
      }
#line 1749
      if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 1750
        return ((struct demangle_component *)((void *)0));
      }
    } else {
      {
#line 1755
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1755
        if (i < len) {
#line 1755
          if (*(str + i)) {
#line 1755
            if (! ((int const   )*(str + i) != 36)) {
#line 1755
              goto while_break___0;
            }
          } else {
#line 1755
            goto while_break___0;
          }
        } else {
#line 1755
          goto while_break___0;
        }
#line 1756
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1758
      next = d_make_name(di, str, (int )i);
#line 1759
      di->n += i;
#line 1760
      str = di->n;
#line 1761
      len -= i;
#line 1762
      i = 0L;
      }
#line 1763
      if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 1764
        return ((struct demangle_component *)((void *)0));
      }
    }
#line 1767
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1768
      p = next;
    } else {
      {
#line 1771
      p = d_make_comp(di, (enum demangle_component_type )58, p, next);
      }
#line 1772
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1773
        return ((struct demangle_component *)((void *)0));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1777
  p = d_make_comp(di, (enum demangle_component_type )57, p, (struct demangle_component *)((void *)0));
  }
#line 1779
  return (p);
}
}
#line 1800 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_special_name(struct d_info *di ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;
  struct demangle_component *tmp___7 ;
  struct demangle_component *tmp___8 ;
  struct demangle_component *tmp___9 ;
  int tmp___10 ;
  struct demangle_component *tmp___11 ;
  struct demangle_component *tmp___12 ;
  int tmp___13 ;
  struct demangle_component *tmp___14 ;
  struct demangle_component *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  struct demangle_component *tmp___18 ;
  struct demangle_component *tmp___19 ;
  struct demangle_component *derived_type ;
  long offset ;
  struct demangle_component *base_type ;
  int tmp___20 ;
  struct demangle_component *tmp___21 ;
  struct demangle_component *tmp___22 ;
  struct demangle_component *tmp___23 ;
  struct demangle_component *tmp___24 ;
  struct demangle_component *tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  struct demangle_component *tmp___28 ;
  struct demangle_component *tmp___29 ;
  struct demangle_component *name___0 ;
  struct demangle_component *tmp___30 ;
  struct demangle_component *tmp___31 ;
  struct demangle_component *tmp___32 ;
  struct demangle_component *tmp___33 ;
  struct demangle_component *tmp___34 ;
  char const   *tmp___35 ;
  int tmp___36 ;
  struct demangle_component *tmp___37 ;
  struct demangle_component *tmp___38 ;
  struct demangle_component *tmp___39 ;
  struct demangle_component *tmp___40 ;
  struct demangle_component *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;

  {
#line 1803
  di->expansion += 20;
#line 1804
  if ((int const   )*(di->n) == 84) {
#line 1804
    (di->n) ++;
#line 1804
    tmp___43 = 1;
  } else {
#line 1804
    tmp___43 = 0;
  }
#line 1804
  if (tmp___43) {
#line 1806
    if ((int const   )*(di->n) == 0) {
#line 1806
      tmp___1 = '\000';
    } else {
#line 1806
      tmp___0 = di->n;
#line 1806
      (di->n) ++;
#line 1806
      tmp___1 = (int )*tmp___0;
    }
    {
#line 1808
    if (tmp___1 == 86) {
#line 1808
      goto case_86;
    }
#line 1812
    if (tmp___1 == 84) {
#line 1812
      goto case_84;
    }
#line 1816
    if (tmp___1 == 73) {
#line 1816
      goto case_73;
    }
#line 1819
    if (tmp___1 == 83) {
#line 1819
      goto case_83;
    }
#line 1823
    if (tmp___1 == 104) {
#line 1823
      goto case_104;
    }
#line 1829
    if (tmp___1 == 118) {
#line 1829
      goto case_118;
    }
#line 1835
    if (tmp___1 == 99) {
#line 1835
      goto case_99;
    }
#line 1843
    if (tmp___1 == 67) {
#line 1843
      goto case_67;
    }
#line 1863
    if (tmp___1 == 70) {
#line 1863
      goto case_70;
    }
#line 1866
    if (tmp___1 == 74) {
#line 1866
      goto case_74;
    }
#line 1870
    goto switch_default;
    case_86: /* CIL Label */ 
    {
#line 1809
    di->expansion -= 5;
#line 1810
    tmp___2 = cplus_demangle_type(di);
#line 1810
    tmp___3 = d_make_comp(di, (enum demangle_component_type )9, tmp___2, (struct demangle_component *)((void *)0));
    }
#line 1810
    return (tmp___3);
    case_84: /* CIL Label */ 
    {
#line 1813
    di->expansion -= 10;
#line 1814
    tmp___4 = cplus_demangle_type(di);
#line 1814
    tmp___5 = d_make_comp(di, (enum demangle_component_type )10, tmp___4, (struct demangle_component *)((void *)0));
    }
#line 1814
    return (tmp___5);
    case_73: /* CIL Label */ 
    {
#line 1817
    tmp___6 = cplus_demangle_type(di);
#line 1817
    tmp___7 = d_make_comp(di, (enum demangle_component_type )12, tmp___6, (struct demangle_component *)((void *)0));
    }
#line 1817
    return (tmp___7);
    case_83: /* CIL Label */ 
    {
#line 1820
    tmp___8 = cplus_demangle_type(di);
#line 1820
    tmp___9 = d_make_comp(di, (enum demangle_component_type )13, tmp___8, (struct demangle_component *)((void *)0));
    }
#line 1820
    return (tmp___9);
    case_104: /* CIL Label */ 
    {
#line 1824
    tmp___10 = d_call_offset(di, 'h');
    }
#line 1824
    if (! tmp___10) {
#line 1825
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1826
    tmp___11 = d_encoding(di, 0);
#line 1826
    tmp___12 = d_make_comp(di, (enum demangle_component_type )15, tmp___11, (struct demangle_component *)((void *)0));
    }
#line 1826
    return (tmp___12);
    case_118: /* CIL Label */ 
    {
#line 1830
    tmp___13 = d_call_offset(di, 'v');
    }
#line 1830
    if (! tmp___13) {
#line 1831
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1832
    tmp___14 = d_encoding(di, 0);
#line 1832
    tmp___15 = d_make_comp(di, (enum demangle_component_type )16, tmp___14, (struct demangle_component *)((void *)0));
    }
#line 1832
    return (tmp___15);
    case_99: /* CIL Label */ 
    {
#line 1836
    tmp___16 = d_call_offset(di, '\000');
    }
#line 1836
    if (! tmp___16) {
#line 1837
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1838
    tmp___17 = d_call_offset(di, '\000');
    }
#line 1838
    if (! tmp___17) {
#line 1839
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1840
    tmp___18 = d_encoding(di, 0);
#line 1840
    tmp___19 = d_make_comp(di, (enum demangle_component_type )17, tmp___18, (struct demangle_component *)((void *)0));
    }
#line 1840
    return (tmp___19);
    case_67: /* CIL Label */ 
    {
#line 1849
    derived_type = cplus_demangle_type(di);
#line 1850
    offset = d_number(di);
    }
#line 1851
    if (offset < 0L) {
#line 1852
      return ((struct demangle_component *)((void *)0));
    }
#line 1853
    if ((int const   )*(di->n) == 95) {
#line 1853
      (di->n) ++;
#line 1853
      tmp___20 = 1;
    } else {
#line 1853
      tmp___20 = 0;
    }
#line 1853
    if (! tmp___20) {
#line 1854
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 1855
    base_type = cplus_demangle_type(di);
#line 1858
    di->expansion += 5;
#line 1859
    tmp___21 = d_make_comp(di, (enum demangle_component_type )11, base_type, derived_type);
    }
#line 1859
    return (tmp___21);
    case_70: /* CIL Label */ 
    {
#line 1864
    tmp___22 = cplus_demangle_type(di);
#line 1864
    tmp___23 = d_make_comp(di, (enum demangle_component_type )14, tmp___22, (struct demangle_component *)((void *)0));
    }
#line 1864
    return (tmp___23);
    case_74: /* CIL Label */ 
    {
#line 1867
    tmp___24 = cplus_demangle_type(di);
#line 1867
    tmp___25 = d_make_comp(di, (enum demangle_component_type )18, tmp___24, (struct demangle_component *)((void *)0));
    }
#line 1867
    return (tmp___25);
    switch_default: /* CIL Label */ 
#line 1871
    return ((struct demangle_component *)((void *)0));
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1874
    if ((int const   )*(di->n) == 71) {
#line 1874
      (di->n) ++;
#line 1874
      tmp___42 = 1;
    } else {
#line 1874
      tmp___42 = 0;
    }
#line 1874
    if (tmp___42) {
#line 1876
      if ((int const   )*(di->n) == 0) {
#line 1876
        tmp___27 = '\000';
      } else {
#line 1876
        tmp___26 = di->n;
#line 1876
        (di->n) ++;
#line 1876
        tmp___27 = (int )*tmp___26;
      }
      {
#line 1878
      if (tmp___27 == 86) {
#line 1878
        goto case_86___0;
      }
#line 1881
      if (tmp___27 == 82) {
#line 1881
        goto case_82;
      }
#line 1888
      if (tmp___27 == 65) {
#line 1888
        goto case_65;
      }
#line 1892
      if (tmp___27 == 84) {
#line 1892
        goto case_84___0;
      }
#line 1909
      if (tmp___27 == 114) {
#line 1909
        goto case_114;
      }
#line 1912
      goto switch_default___1;
      case_86___0: /* CIL Label */ 
      {
#line 1879
      tmp___28 = d_name(di);
#line 1879
      tmp___29 = d_make_comp(di, (enum demangle_component_type )19, tmp___28, (struct demangle_component *)((void *)0));
      }
#line 1879
      return (tmp___29);
      case_82: /* CIL Label */ 
      {
#line 1883
      tmp___30 = d_name(di);
#line 1883
      name___0 = tmp___30;
#line 1884
      tmp___31 = d_number_component(di);
#line 1884
      tmp___32 = d_make_comp(di, (enum demangle_component_type )20, name___0, tmp___31);
      }
#line 1884
      return (tmp___32);
      case_65: /* CIL Label */ 
      {
#line 1889
      tmp___33 = d_encoding(di, 0);
#line 1889
      tmp___34 = d_make_comp(di, (enum demangle_component_type )21, tmp___33, (struct demangle_component *)((void *)0));
      }
#line 1889
      return (tmp___34);
      case_84___0: /* CIL Label */ 
#line 1893
      if ((int const   )*(di->n) == 0) {
#line 1893
        tmp___36 = '\000';
      } else {
#line 1893
        tmp___35 = di->n;
#line 1893
        (di->n) ++;
#line 1893
        tmp___36 = (int )*tmp___35;
      }
      {
#line 1895
      if (tmp___36 == 110) {
#line 1895
        goto case_110;
      }
#line 1898
      goto switch_default___0;
      case_110: /* CIL Label */ 
      {
#line 1896
      tmp___37 = d_encoding(di, 0);
#line 1896
      tmp___38 = d_make_comp(di, (enum demangle_component_type )68, tmp___37, (struct demangle_component *)((void *)0));
      }
#line 1896
      return (tmp___38);
      switch_default___0: /* CIL Label */ 
      {
#line 1905
      tmp___39 = d_encoding(di, 0);
#line 1905
      tmp___40 = d_make_comp(di, (enum demangle_component_type )67, tmp___39, (struct demangle_component *)((void *)0));
      }
#line 1905
      return (tmp___40);
      switch_break___1: /* CIL Label */ ;
      }
      case_114: /* CIL Label */ 
      {
#line 1910
      tmp___41 = d_java_resource(di);
      }
#line 1910
      return (tmp___41);
      switch_default___1: /* CIL Label */ 
#line 1913
      return ((struct demangle_component *)((void *)0));
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 1917
      return ((struct demangle_component *)((void *)0));
    }
  }
}
}
#line 1933 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int d_call_offset(struct d_info *di , int c ) 
{ 
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1936
  if (c == 0) {
#line 1937
    if ((int const   )*(di->n) == 0) {
#line 1937
      c = '\000';
    } else {
#line 1937
      tmp___0 = di->n;
#line 1937
      (di->n) ++;
#line 1937
      c = (int )*tmp___0;
    }
  }
#line 1939
  if (c == 104) {
    {
#line 1940
    d_number(di);
    }
  } else
#line 1941
  if (c == 118) {
    {
#line 1943
    d_number(di);
    }
#line 1944
    if ((int const   )*(di->n) == 95) {
#line 1944
      (di->n) ++;
#line 1944
      tmp___1 = 1;
    } else {
#line 1944
      tmp___1 = 0;
    }
#line 1944
    if (! tmp___1) {
#line 1945
      return (0);
    }
    {
#line 1946
    d_number(di);
    }
  } else {
#line 1949
    return (0);
  }
#line 1951
  if ((int const   )*(di->n) == 95) {
#line 1951
    (di->n) ++;
#line 1951
    tmp___2 = 1;
  } else {
#line 1951
    tmp___2 = 0;
  }
#line 1951
  if (! tmp___2) {
#line 1952
    return (0);
  }
#line 1954
  return (1);
}
}
#line 1965 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_ctor_dtor_name(struct d_info *di ) 
{ 
  enum gnu_v3_ctor_kinds kind ;
  struct demangle_component *tmp___0 ;
  enum gnu_v3_dtor_kinds kind___0 ;
  struct demangle_component *tmp___1 ;

  {
#line 1968
  if ((unsigned long )di->last_name != (unsigned long )((void *)0)) {
#line 1970
    if ((unsigned int )(di->last_name)->type == 0U) {
#line 1971
      di->expansion += (di->last_name)->u.s_name.len;
    } else
#line 1972
    if ((unsigned int )(di->last_name)->type == 22U) {
#line 1973
      di->expansion += (di->last_name)->u.s_string.len;
    }
  }
  {
#line 1977
  if ((int const   )*(di->n) == 67) {
#line 1977
    goto case_67;
  }
#line 2002
  if ((int const   )*(di->n) == 68) {
#line 2002
    goto case_68;
  }
#line 2027
  goto switch_default___1;
  case_67: /* CIL Label */ 
  {
#line 1983
  if ((int const   )*(di->n + 1) == 49) {
#line 1983
    goto case_49;
  }
#line 1986
  if ((int const   )*(di->n + 1) == 50) {
#line 1986
    goto case_50;
  }
#line 1989
  if ((int const   )*(di->n + 1) == 51) {
#line 1989
    goto case_51;
  }
#line 1992
  if ((int const   )*(di->n + 1) == 53) {
#line 1992
    goto case_53;
  }
#line 1995
  goto switch_default;
  case_49: /* CIL Label */ 
#line 1984
  kind = (enum gnu_v3_ctor_kinds )1;
#line 1985
  goto switch_break___0;
  case_50: /* CIL Label */ 
#line 1987
  kind = (enum gnu_v3_ctor_kinds )2;
#line 1988
  goto switch_break___0;
  case_51: /* CIL Label */ 
#line 1990
  kind = (enum gnu_v3_ctor_kinds )3;
#line 1991
  goto switch_break___0;
  case_53: /* CIL Label */ 
#line 1993
  kind = (enum gnu_v3_ctor_kinds )4;
#line 1994
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 1996
  return ((struct demangle_component *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 1998
  di->n += 2;
#line 1999
  tmp___0 = d_make_ctor(di, kind, di->last_name);
  }
#line 1999
  return (tmp___0);
  case_68: /* CIL Label */ 
  {
#line 2008
  if ((int const   )*(di->n + 1) == 48) {
#line 2008
    goto case_48;
  }
#line 2011
  if ((int const   )*(di->n + 1) == 49) {
#line 2011
    goto case_49___0;
  }
#line 2014
  if ((int const   )*(di->n + 1) == 50) {
#line 2014
    goto case_50___0;
  }
#line 2017
  if ((int const   )*(di->n + 1) == 53) {
#line 2017
    goto case_53___0;
  }
#line 2020
  goto switch_default___0;
  case_48: /* CIL Label */ 
#line 2009
  kind___0 = (enum gnu_v3_dtor_kinds )1;
#line 2010
  goto switch_break___1;
  case_49___0: /* CIL Label */ 
#line 2012
  kind___0 = (enum gnu_v3_dtor_kinds )2;
#line 2013
  goto switch_break___1;
  case_50___0: /* CIL Label */ 
#line 2015
  kind___0 = (enum gnu_v3_dtor_kinds )3;
#line 2016
  goto switch_break___1;
  case_53___0: /* CIL Label */ 
#line 2018
  kind___0 = (enum gnu_v3_dtor_kinds )4;
#line 2019
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
#line 2021
  return ((struct demangle_component *)((void *)0));
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 2023
  di->n += 2;
#line 2024
  tmp___1 = d_make_dtor(di, kind___0, di->last_name);
  }
#line 2024
  return (tmp___1);
  switch_default___1: /* CIL Label */ 
#line 2028
  return ((struct demangle_component *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2053 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct demangle_builtin_type_info  const  cplus_demangle_builtin_types[33]  = 
#line 2053
  {      {"signed char", (int )(sizeof("signed char") - 1UL), "signed char", (int )(sizeof("signed char") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"bool", (int )(sizeof("bool") - 1UL), "boolean", (int )(sizeof("boolean") - 1UL),
      (enum d_builtin_type_print )7}, 
        {"char", (int )(sizeof("char") - 1UL), "byte", (int )(sizeof("byte") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"double", (int )(sizeof("double") - 1UL), "double", (int )(sizeof("double") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"long double", (int )(sizeof("long double") - 1UL), "long double", (int )(sizeof("long double") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"float", (int )(sizeof("float") - 1UL), "float", (int )(sizeof("float") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"__float128", (int )(sizeof("__float128") - 1UL), "__float128", (int )(sizeof("__float128") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"unsigned char", (int )(sizeof("unsigned char") - 1UL), "unsigned char", (int )(sizeof("unsigned char") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"int", (int )(sizeof("int") - 1UL), "int", (int )(sizeof("int") - 1UL), (enum d_builtin_type_print )1}, 
        {"unsigned int",
      (int )(sizeof("unsigned int") - 1UL), "unsigned", (int )(sizeof("unsigned") - 1UL),
      (enum d_builtin_type_print )2}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {"long",
      (int )(sizeof("long") - 1UL), "long", (int )(sizeof("long") - 1UL), (enum d_builtin_type_print )3}, 
        {"unsigned long",
      (int )(sizeof("unsigned long") - 1UL), "unsigned long", (int )(sizeof("unsigned long") - 1UL),
      (enum d_builtin_type_print )4}, 
        {"__int128", (int )(sizeof("__int128") - 1UL), "__int128", (int )(sizeof("__int128") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"unsigned __int128", (int )(sizeof("unsigned __int128") - 1UL), "unsigned __int128",
      (int )(sizeof("unsigned __int128") - 1UL), (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0),
      0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {"short",
      (int )(sizeof("short") - 1UL), "short", (int )(sizeof("short") - 1UL), (enum d_builtin_type_print )0}, 
        {"unsigned short",
      (int )(sizeof("unsigned short") - 1UL), "unsigned short", (int )(sizeof("unsigned short") - 1UL),
      (enum d_builtin_type_print )0}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, (enum d_builtin_type_print )0}, 
        {"void",
      (int )(sizeof("void") - 1UL), "void", (int )(sizeof("void") - 1UL), (enum d_builtin_type_print )9}, 
        {"wchar_t",
      (int )(sizeof("wchar_t") - 1UL), "char", (int )(sizeof("char") - 1UL), (enum d_builtin_type_print )0}, 
        {"long long",
      (int )(sizeof("long long") - 1UL), "long", (int )(sizeof("long") - 1UL), (enum d_builtin_type_print )5}, 
        {"unsigned long long",
      (int )(sizeof("unsigned long long") - 1UL), "unsigned long long", (int )(sizeof("unsigned long long") - 1UL),
      (enum d_builtin_type_print )6}, 
        {"...", (int )(sizeof("...") - 1UL), "...", (int )(sizeof("...") - 1UL), (enum d_builtin_type_print )0}, 
        {"decimal32",
      (int )(sizeof("decimal32") - 1UL), "decimal32", (int )(sizeof("decimal32") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"decimal64", (int )(sizeof("decimal64") - 1UL), "decimal64", (int )(sizeof("decimal64") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"decimal128", (int )(sizeof("decimal128") - 1UL), "decimal128", (int )(sizeof("decimal128") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"half", (int )(sizeof("half") - 1UL), "half", (int )(sizeof("half") - 1UL),
      (enum d_builtin_type_print )8}, 
        {"char16_t", (int )(sizeof("char16_t") - 1UL), "char16_t", (int )(sizeof("char16_t") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"char32_t", (int )(sizeof("char32_t") - 1UL), "char32_t", (int )(sizeof("char32_t") - 1UL),
      (enum d_builtin_type_print )0}, 
        {"decltype(nullptr)", (int )(sizeof("decltype(nullptr)") - 1UL), "decltype(nullptr)",
      (int )(sizeof("decltype(nullptr)") - 1UL), (enum d_builtin_type_print )0}};
#line 2095 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
struct demangle_component *cplus_demangle_type(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *ret ;
  int can_subst ;
  struct demangle_component **pret ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;
  int tmp___2 ;
  struct demangle_component *tmp___3 ;
  char peek_next ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;
  struct demangle_component *tmp___7 ;
  struct demangle_component *tmp___8 ;
  struct demangle_component *tmp___9 ;
  struct demangle_component *tmp___10 ;
  char const   *tmp___11 ;
  struct demangle_component *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  struct demangle_component *tmp___15 ;
  short tmp___16 ;
  int tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;

  {
#line 2117
  peek = (char )*(di->n);
#line 2118
  if ((int )peek == 114) {
#line 2118
    goto _L;
  } else
#line 2118
  if ((int )peek == 86) {
#line 2118
    goto _L;
  } else
#line 2118
  if ((int )peek == 75) {
    _L: /* CIL Label */ 
    {
#line 2122
    pret = d_cv_qualifiers(di, & ret, 0);
    }
#line 2123
    if ((unsigned long )pret == (unsigned long )((void *)0)) {
#line 2124
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2125
    *pret = cplus_demangle_type(di);
    }
#line 2126
    if (! *pret) {
#line 2127
      return ((struct demangle_component *)((void *)0));
    } else {
      {
#line 2126
      tmp___0 = d_add_substitution(di, ret);
      }
#line 2126
      if (! tmp___0) {
#line 2127
        return ((struct demangle_component *)((void *)0));
      }
    }
#line 2128
    return (ret);
  }
#line 2131
  can_subst = 1;
  {
#line 2138
  if ((int )peek == 122) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 121) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 120) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 119) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 118) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 116) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 115) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 111) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 110) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 109) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 108) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 106) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 105) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 104) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 103) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 102) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 101) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 100) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 99) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 98) {
#line 2138
    goto case_122;
  }
#line 2138
  if ((int )peek == 97) {
#line 2138
    goto case_122;
  }
#line 2146
  if ((int )peek == 117) {
#line 2146
    goto case_117;
  }
#line 2152
  if ((int )peek == 70) {
#line 2152
    goto case_70;
  }
#line 2159
  if ((int )peek == 90) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 78) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 57) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 56) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 55) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 54) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 53) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 52) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 51) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 50) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 49) {
#line 2159
    goto case_90;
  }
#line 2159
  if ((int )peek == 48) {
#line 2159
    goto case_90;
  }
#line 2163
  if ((int )peek == 65) {
#line 2163
    goto case_65;
  }
#line 2167
  if ((int )peek == 77) {
#line 2167
    goto case_77;
  }
#line 2171
  if ((int )peek == 84) {
#line 2171
    goto case_84;
  }
#line 2185
  if ((int )peek == 83) {
#line 2185
    goto case_83;
  }
#line 2218
  if ((int )peek == 79) {
#line 2218
    goto case_79;
  }
#line 2224
  if ((int )peek == 80) {
#line 2224
    goto case_80;
  }
#line 2230
  if ((int )peek == 82) {
#line 2230
    goto case_82;
  }
#line 2236
  if ((int )peek == 67) {
#line 2236
    goto case_67;
  }
#line 2242
  if ((int )peek == 71) {
#line 2242
    goto case_71;
  }
#line 2248
  if ((int )peek == 85) {
#line 2248
    goto case_85;
  }
#line 2255
  if ((int )peek == 68) {
#line 2255
    goto case_68;
  }
#line 2345
  goto switch_default___0;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  {
#line 2139
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[(int )peek - 97]);
#line 2141
  di->expansion += (int )(ret->u.s_builtin.type)->len;
#line 2142
  can_subst = 0;
#line 2143
  (di->n) ++;
  }
#line 2144
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 2147
  (di->n) ++;
#line 2148
  tmp___1 = d_source_name(di);
#line 2148
  ret = d_make_comp(di, (enum demangle_component_type )36, tmp___1, (struct demangle_component *)((void *)0));
  }
#line 2150
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 2153
  ret = d_function_type(di);
  }
#line 2154
  goto switch_break;
  case_90: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 2160
  ret = d_class_enum_type(di);
  }
#line 2161
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 2164
  ret = d_array_type(di);
  }
#line 2165
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 2168
  ret = d_pointer_to_member_type(di);
  }
#line 2169
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 2172
  ret = d_template_param(di);
  }
#line 2173
  if ((int const   )*(di->n) == 73) {
    {
#line 2178
    tmp___2 = d_add_substitution(di, ret);
    }
#line 2178
    if (! tmp___2) {
#line 2179
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2180
    tmp___3 = d_template_args(di);
#line 2180
    ret = d_make_comp(di, (enum demangle_component_type )4, ret, tmp___3);
    }
  }
#line 2183
  goto switch_break;
  case_83: /* CIL Label */ 
#line 2191
  peek_next = (char )*(di->n + 1);
#line 2192
  if ((int )peek_next >= 48) {
#line 2192
    if ((int )peek_next <= 57) {
#line 2192
      goto _L___0;
    } else {
#line 2192
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2192
  if ((int )peek_next == 95) {
#line 2192
    goto _L___0;
  } else
#line 2192
  if ((int )peek_next >= 65) {
#line 2192
    if ((int )peek_next <= 90) {
      _L___0: /* CIL Label */ 
      {
#line 2196
      ret = d_substitution(di, 0);
      }
#line 2199
      if ((int const   )*(di->n) == 73) {
        {
#line 2200
        tmp___4 = d_template_args(di);
#line 2200
        ret = d_make_comp(di, (enum demangle_component_type )4, ret, tmp___4);
        }
      } else {
#line 2203
        can_subst = 0;
      }
    } else {
#line 2192
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 2207
    ret = d_class_enum_type(di);
    }
#line 2212
    if ((unsigned long )ret != (unsigned long )((void *)0)) {
#line 2212
      if ((unsigned int )ret->type == 22U) {
#line 2213
        can_subst = 0;
      }
    }
  }
#line 2216
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 2219
  (di->n) ++;
#line 2220
  tmp___5 = cplus_demangle_type(di);
#line 2220
  ret = d_make_comp(di, (enum demangle_component_type )32, tmp___5, (struct demangle_component *)((void *)0));
  }
#line 2222
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 2225
  (di->n) ++;
#line 2226
  tmp___6 = cplus_demangle_type(di);
#line 2226
  ret = d_make_comp(di, (enum demangle_component_type )30, tmp___6, (struct demangle_component *)((void *)0));
  }
#line 2228
  goto switch_break;
  case_82: /* CIL Label */ 
  {
#line 2231
  (di->n) ++;
#line 2232
  tmp___7 = cplus_demangle_type(di);
#line 2232
  ret = d_make_comp(di, (enum demangle_component_type )31, tmp___7, (struct demangle_component *)((void *)0));
  }
#line 2234
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 2237
  (di->n) ++;
#line 2238
  tmp___8 = cplus_demangle_type(di);
#line 2238
  ret = d_make_comp(di, (enum demangle_component_type )33, tmp___8, (struct demangle_component *)((void *)0));
  }
#line 2240
  goto switch_break;
  case_71: /* CIL Label */ 
  {
#line 2243
  (di->n) ++;
#line 2244
  tmp___9 = cplus_demangle_type(di);
#line 2244
  ret = d_make_comp(di, (enum demangle_component_type )34, tmp___9, (struct demangle_component *)((void *)0));
  }
#line 2246
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 2249
  (di->n) ++;
#line 2250
  ret = d_source_name(di);
#line 2251
  tmp___10 = cplus_demangle_type(di);
#line 2251
  ret = d_make_comp(di, (enum demangle_component_type )29, tmp___10, ret);
  }
#line 2253
  goto switch_break;
  case_68: /* CIL Label */ 
#line 2256
  can_subst = 0;
#line 2257
  (di->n) ++;
#line 2258
  if ((int const   )*(di->n) == 0) {
#line 2258
    peek = (char )'\000';
  } else {
#line 2258
    tmp___11 = di->n;
#line 2258
    (di->n) ++;
#line 2258
    peek = (char )*tmp___11;
  }
  {
#line 2262
  if ((int )peek == 116) {
#line 2262
    goto case_116___0;
  }
#line 2262
  if ((int )peek == 84) {
#line 2262
    goto case_116___0;
  }
#line 2271
  if ((int )peek == 112) {
#line 2271
    goto case_112;
  }
#line 2278
  if ((int )peek == 97) {
#line 2278
    goto case_97___0;
  }
#line 2283
  if ((int )peek == 102) {
#line 2283
    goto case_102___0;
  }
#line 2288
  if ((int )peek == 100) {
#line 2288
    goto case_100___0;
  }
#line 2293
  if ((int )peek == 101) {
#line 2293
    goto case_101___0;
  }
#line 2298
  if ((int )peek == 104) {
#line 2298
    goto case_104___0;
  }
#line 2303
  if ((int )peek == 115) {
#line 2303
    goto case_115___0;
  }
#line 2308
  if ((int )peek == 105) {
#line 2308
    goto case_105___0;
  }
#line 2314
  if ((int )peek == 70) {
#line 2314
    goto case_70___0;
  }
#line 2329
  if ((int )peek == 118) {
#line 2329
    goto case_118___0;
  }
#line 2334
  if ((int )peek == 110) {
#line 2334
    goto case_110___0;
  }
#line 2340
  goto switch_default;
  case_116___0: /* CIL Label */ 
  case_84___0: /* CIL Label */ 
  {
#line 2264
  tmp___12 = d_expression(di);
#line 2264
  ret = d_make_comp(di, (enum demangle_component_type )61, tmp___12, (struct demangle_component *)((void *)0));
  }
#line 2266
  if (ret) {
#line 2266
    if ((int const   )*(di->n) == 0) {
#line 2266
      tmp___14 = '\000';
    } else {
#line 2266
      tmp___13 = di->n;
#line 2266
      (di->n) ++;
#line 2266
      tmp___14 = (int )*tmp___13;
    }
#line 2266
    if (tmp___14 != 69) {
#line 2267
      ret = (struct demangle_component *)((void *)0);
    }
  }
#line 2268
  can_subst = 1;
#line 2269
  goto switch_break___0;
  case_112: /* CIL Label */ 
  {
#line 2273
  tmp___15 = cplus_demangle_type(di);
#line 2273
  ret = d_make_comp(di, (enum demangle_component_type )69, tmp___15, (struct demangle_component *)((void *)0));
#line 2275
  can_subst = 1;
  }
#line 2276
  goto switch_break___0;
  case_97___0: /* CIL Label */ 
  {
#line 2280
  ret = d_make_name(di, "auto", 4);
  }
#line 2281
  goto switch_break___0;
  case_102___0: /* CIL Label */ 
  {
#line 2285
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[26]);
#line 2286
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2287
  goto switch_break___0;
  case_100___0: /* CIL Label */ 
  {
#line 2290
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[27]);
#line 2291
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2292
  goto switch_break___0;
  case_101___0: /* CIL Label */ 
  {
#line 2295
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[28]);
#line 2296
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2297
  goto switch_break___0;
  case_104___0: /* CIL Label */ 
  {
#line 2300
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[29]);
#line 2301
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2302
  goto switch_break___0;
  case_115___0: /* CIL Label */ 
  {
#line 2305
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[30]);
#line 2306
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2307
  goto switch_break___0;
  case_105___0: /* CIL Label */ 
  {
#line 2310
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[31]);
#line 2311
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2312
  goto switch_break___0;
  case_70___0: /* CIL Label */ 
  {
#line 2316
  ret = d_make_empty(di);
#line 2317
  ret->type = (enum demangle_component_type )40;
  }
#line 2318
  if ((int const   )*(di->n) >= 48) {
#line 2318
    if ((int const   )*(di->n) <= 57) {
#line 2318
      tmp___17 = 1;
    } else {
#line 2318
      tmp___17 = 0;
    }
  } else {
#line 2318
    tmp___17 = 0;
  }
#line 2318
  tmp___16 = (short )tmp___17;
#line 2318
  ret->u.s_fixed.accum = tmp___16;
#line 2318
  if (tmp___16) {
    {
#line 2320
    d_number(di);
    }
  }
  {
#line 2321
  ret->u.s_fixed.length = cplus_demangle_type(di);
  }
#line 2322
  if ((unsigned long )ret->u.s_fixed.length == (unsigned long )((void *)0)) {
#line 2323
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2324
  d_number(di);
  }
#line 2325
  if ((int const   )*(di->n) == 0) {
#line 2325
    peek = (char )'\000';
  } else {
#line 2325
    tmp___18 = di->n;
#line 2325
    (di->n) ++;
#line 2325
    peek = (char )*tmp___18;
  }
#line 2326
  ret->u.s_fixed.sat = (short )((int )peek == 115);
#line 2327
  goto switch_break___0;
  case_118___0: /* CIL Label */ 
  {
#line 2330
  ret = d_vector_type(di);
#line 2331
  can_subst = 1;
  }
#line 2332
  goto switch_break___0;
  case_110___0: /* CIL Label */ 
  {
#line 2336
  ret = d_make_builtin_type(di, & cplus_demangle_builtin_types[32]);
#line 2337
  di->expansion += (int )(ret->u.s_builtin.type)->len;
  }
#line 2338
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 2341
  return ((struct demangle_component *)((void *)0));
  switch_break___0: /* CIL Label */ ;
  }
#line 2343
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 2346
  return ((struct demangle_component *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 2349
  if (can_subst) {
    {
#line 2351
    tmp___19 = d_add_substitution(di, ret);
    }
#line 2351
    if (! tmp___19) {
#line 2352
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 2355
  return (ret);
}
}
#line 2360 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component **d_cv_qualifiers(struct d_info *di , struct demangle_component **pret ,
                                                   int member_fn ) 
{ 
  struct demangle_component **pstart ;
  char peek ;
  enum demangle_component_type t ;

  {
#line 2367
  pstart = pret;
#line 2368
  peek = (char )*(di->n);
  {
#line 2369
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2369
    if (! ((int )peek == 114)) {
#line 2369
      if (! ((int )peek == 86)) {
#line 2369
        if (! ((int )peek == 75)) {
#line 2369
          goto while_break;
        }
      }
    }
#line 2373
    (di->n) ++;
#line 2374
    if ((int )peek == 114) {
#line 2376
      if (member_fn) {
#line 2376
        t = (enum demangle_component_type )26;
      } else {
#line 2376
        t = (enum demangle_component_type )23;
      }
#line 2379
      di->expansion = (int )((unsigned long )di->expansion + sizeof("restrict"));
    } else
#line 2381
    if ((int )peek == 86) {
#line 2383
      if (member_fn) {
#line 2383
        t = (enum demangle_component_type )27;
      } else {
#line 2383
        t = (enum demangle_component_type )24;
      }
#line 2386
      di->expansion = (int )((unsigned long )di->expansion + sizeof("volatile"));
    } else {
#line 2390
      if (member_fn) {
#line 2390
        t = (enum demangle_component_type )28;
      } else {
#line 2390
        t = (enum demangle_component_type )25;
      }
#line 2393
      di->expansion = (int )((unsigned long )di->expansion + sizeof("const"));
    }
    {
#line 2396
    *pret = d_make_comp(di, t, (struct demangle_component *)((void *)0), (struct demangle_component *)((void *)0));
    }
#line 2397
    if ((unsigned long )*pret == (unsigned long )((void *)0)) {
#line 2398
      return ((struct demangle_component **)((void *)0));
    }
#line 2399
    pret = & (*pret)->u.s_binary.left;
#line 2401
    peek = (char )*(di->n);
  }
  while_break: /* CIL Label */ ;
  }
#line 2404
  if (! member_fn) {
#line 2404
    if ((int )peek == 70) {
      {
#line 2406
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2406
        if (! ((unsigned long )pstart != (unsigned long )pret)) {
#line 2406
          goto while_break___0;
        }
        {
#line 2410
        if ((unsigned int )(*pstart)->type == 23U) {
#line 2410
          goto case_23;
        }
#line 2413
        if ((unsigned int )(*pstart)->type == 24U) {
#line 2413
          goto case_24;
        }
#line 2416
        if ((unsigned int )(*pstart)->type == 25U) {
#line 2416
          goto case_25;
        }
#line 2419
        goto switch_default;
        case_23: /* CIL Label */ 
#line 2411
        (*pstart)->type = (enum demangle_component_type )26;
#line 2412
        goto switch_break;
        case_24: /* CIL Label */ 
#line 2414
        (*pstart)->type = (enum demangle_component_type )27;
#line 2415
        goto switch_break;
        case_25: /* CIL Label */ 
#line 2417
        (*pstart)->type = (enum demangle_component_type )28;
#line 2418
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 2420
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 2422
        pstart = & (*pstart)->u.s_binary.left;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 2426
  return (pret);
}
}
#line 2431 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_function_type(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2436
  if ((int const   )*(di->n) == 70) {
#line 2436
    (di->n) ++;
#line 2436
    tmp___0 = 1;
  } else {
#line 2436
    tmp___0 = 0;
  }
#line 2436
  if (! tmp___0) {
#line 2437
    return ((struct demangle_component *)((void *)0));
  }
#line 2438
  if ((int const   )*(di->n) == 89) {
#line 2442
    (di->n) ++;
  }
  {
#line 2444
  ret = d_bare_function_type(di, 1);
  }
#line 2445
  if ((int const   )*(di->n) == 69) {
#line 2445
    (di->n) ++;
#line 2445
    tmp___1 = 1;
  } else {
#line 2445
    tmp___1 = 0;
  }
#line 2445
  if (! tmp___1) {
#line 2446
    return ((struct demangle_component *)((void *)0));
  }
#line 2447
  return (ret);
}
}
#line 2452 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_parmlist(struct d_info *di ) 
{ 
  struct demangle_component *tl ;
  struct demangle_component **ptl ;
  struct demangle_component *type ;
  char peek ;

  {
#line 2458
  tl = (struct demangle_component *)((void *)0);
#line 2459
  ptl = & tl;
  {
#line 2460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2464
    peek = (char )*(di->n);
#line 2465
    if ((int )peek == 0) {
#line 2466
      goto while_break;
    } else
#line 2465
    if ((int )peek == 69) {
#line 2466
      goto while_break;
    } else
#line 2465
    if ((int )peek == 46) {
#line 2466
      goto while_break;
    }
    {
#line 2467
    type = cplus_demangle_type(di);
    }
#line 2468
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 2469
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2470
    *ptl = d_make_comp(di, (enum demangle_component_type )42, type, (struct demangle_component *)((void *)0));
    }
#line 2471
    if ((unsigned long )*ptl == (unsigned long )((void *)0)) {
#line 2472
      return ((struct demangle_component *)((void *)0));
    }
#line 2473
    ptl = & (*ptl)->u.s_binary.right;
  }
  while_break: /* CIL Label */ ;
  }
#line 2479
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 2480
    return ((struct demangle_component *)((void *)0));
  }
#line 2483
  if ((unsigned long )tl->u.s_binary.right == (unsigned long )((void *)0)) {
#line 2483
    if ((unsigned int )(tl->u.s_binary.left)->type == 35U) {
#line 2483
      if ((unsigned int const   )((tl->u.s_binary.left)->u.s_builtin.type)->print == 9U) {
#line 2487
        di->expansion -= (int )((tl->u.s_binary.left)->u.s_builtin.type)->len;
#line 2488
        tl->u.s_binary.left = (struct demangle_component *)((void *)0);
      }
    }
  }
#line 2491
  return (tl);
}
}
#line 2496 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_bare_function_type(struct d_info *di , int has_return_type___0 ) 
{ 
  struct demangle_component *return_type ;
  struct demangle_component *tl ;
  char peek ;
  struct demangle_component *tmp___0 ;

  {
#line 2505
  peek = (char )*(di->n);
#line 2506
  if ((int )peek == 74) {
#line 2508
    (di->n) ++;
#line 2509
    has_return_type___0 = 1;
  }
#line 2512
  if (has_return_type___0) {
    {
#line 2514
    return_type = cplus_demangle_type(di);
    }
#line 2515
    if ((unsigned long )return_type == (unsigned long )((void *)0)) {
#line 2516
      return ((struct demangle_component *)((void *)0));
    }
  } else {
#line 2519
    return_type = (struct demangle_component *)((void *)0);
  }
  {
#line 2521
  tl = d_parmlist(di);
  }
#line 2522
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 2523
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2525
  tmp___0 = d_make_comp(di, (enum demangle_component_type )37, return_type, tl);
  }
#line 2525
  return (tmp___0);
}
}
#line 2531 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_class_enum_type(struct d_info *di ) 
{ 
  struct demangle_component *tmp___0 ;

  {
  {
#line 2534
  tmp___0 = d_name(di);
  }
#line 2534
  return (tmp___0);
}
}
#line 2541 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_array_type(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *dim ;
  int tmp___0 ;
  char const   *s ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
#line 2547
  if ((int const   )*(di->n) == 65) {
#line 2547
    (di->n) ++;
#line 2547
    tmp___0 = 1;
  } else {
#line 2547
    tmp___0 = 0;
  }
#line 2547
  if (! tmp___0) {
#line 2548
    return ((struct demangle_component *)((void *)0));
  }
#line 2550
  peek = (char )*(di->n);
#line 2551
  if ((int )peek == 95) {
#line 2552
    dim = (struct demangle_component *)((void *)0);
  } else
#line 2553
  if ((int )peek >= 48) {
#line 2553
    if ((int )peek <= 57) {
#line 2557
      s = di->n;
      {
#line 2558
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2560
        (di->n) ++;
#line 2561
        peek = (char )*(di->n);
#line 2558
        if ((int )peek >= 48) {
#line 2558
          if (! ((int )peek <= 57)) {
#line 2558
            goto while_break;
          }
        } else {
#line 2558
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2564
      dim = d_make_name(di, s, (int )(di->n - s));
      }
#line 2565
      if ((unsigned long )dim == (unsigned long )((void *)0)) {
#line 2566
        return ((struct demangle_component *)((void *)0));
      }
    } else {
#line 2553
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2570
    dim = d_expression(di);
    }
#line 2571
    if ((unsigned long )dim == (unsigned long )((void *)0)) {
#line 2572
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 2575
  if ((int const   )*(di->n) == 95) {
#line 2575
    (di->n) ++;
#line 2575
    tmp___1 = 1;
  } else {
#line 2575
    tmp___1 = 0;
  }
#line 2575
  if (! tmp___1) {
#line 2576
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2578
  tmp___2 = cplus_demangle_type(di);
#line 2578
  tmp___3 = d_make_comp(di, (enum demangle_component_type )38, dim, tmp___2);
  }
#line 2578
  return (tmp___3);
}
}
#line 2585 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_vector_type(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *dim ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 2591
  peek = (char )*(di->n);
#line 2592
  if ((int )peek == 95) {
    {
#line 2594
    (di->n) ++;
#line 2595
    dim = d_expression(di);
    }
  } else {
    {
#line 2598
    dim = d_number_component(di);
    }
  }
#line 2600
  if ((unsigned long )dim == (unsigned long )((void *)0)) {
#line 2601
    return ((struct demangle_component *)((void *)0));
  }
#line 2603
  if ((int const   )*(di->n) == 95) {
#line 2603
    (di->n) ++;
#line 2603
    tmp___0 = 1;
  } else {
#line 2603
    tmp___0 = 0;
  }
#line 2603
  if (! tmp___0) {
#line 2604
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2606
  tmp___1 = cplus_demangle_type(di);
#line 2606
  tmp___2 = d_make_comp(di, (enum demangle_component_type )41, dim, tmp___1);
  }
#line 2606
  return (tmp___2);
}
}
#line 2612 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_pointer_to_member_type(struct d_info *di ) 
{ 
  struct demangle_component *cl ;
  struct demangle_component *mem ;
  struct demangle_component **pmem ;
  int tmp___0 ;
  int tmp___1 ;
  struct demangle_component *tmp___2 ;

  {
#line 2619
  if ((int const   )*(di->n) == 77) {
#line 2619
    (di->n) ++;
#line 2619
    tmp___0 = 1;
  } else {
#line 2619
    tmp___0 = 0;
  }
#line 2619
  if (! tmp___0) {
#line 2620
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2622
  cl = cplus_demangle_type(di);
#line 2640
  pmem = d_cv_qualifiers(di, & mem, 1);
  }
#line 2641
  if ((unsigned long )pmem == (unsigned long )((void *)0)) {
#line 2642
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2643
  *pmem = cplus_demangle_type(di);
  }
#line 2644
  if ((unsigned long )*pmem == (unsigned long )((void *)0)) {
#line 2645
    return ((struct demangle_component *)((void *)0));
  }
#line 2647
  if ((unsigned long )pmem != (unsigned long )(& mem)) {
#line 2647
    if ((unsigned int )(*pmem)->type != 37U) {
      {
#line 2649
      tmp___1 = d_add_substitution(di, mem);
      }
#line 2649
      if (! tmp___1) {
#line 2650
        return ((struct demangle_component *)((void *)0));
      }
    }
  }
  {
#line 2653
  tmp___2 = d_make_comp(di, (enum demangle_component_type )39, cl, mem);
  }
#line 2653
  return (tmp___2);
}
}
#line 2658 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static long d_compact_number(struct d_info *di ) 
{ 
  long num ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 2662
  if ((int const   )*(di->n) == 95) {
#line 2663
    num = 0L;
  } else
#line 2664
  if ((int const   )*(di->n) == 110) {
#line 2665
    return (-1L);
  } else {
    {
#line 2667
    tmp___0 = d_number(di);
#line 2667
    num = tmp___0 + 1L;
    }
  }
#line 2669
  if ((int const   )*(di->n) == 95) {
#line 2669
    (di->n) ++;
#line 2669
    tmp___1 = 1;
  } else {
#line 2669
    tmp___1 = 0;
  }
#line 2669
  if (! tmp___1) {
#line 2670
    return (-1L);
  }
#line 2671
  return (num);
}
}
#line 2678 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_template_param(struct d_info *di ) 
{ 
  long param ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;

  {
#line 2683
  if ((int const   )*(di->n) == 84) {
#line 2683
    (di->n) ++;
#line 2683
    tmp___0 = 1;
  } else {
#line 2683
    tmp___0 = 0;
  }
#line 2683
  if (! tmp___0) {
#line 2684
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2686
  param = d_compact_number(di);
  }
#line 2687
  if (param < 0L) {
#line 2688
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 2690
  (di->did_subs) ++;
#line 2692
  tmp___1 = d_make_template_param(di, param);
  }
#line 2692
  return (tmp___1);
}
}
#line 2697 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_template_args(struct d_info *di ) 
{ 
  struct demangle_component *hold_last_name ;
  struct demangle_component *al ;
  struct demangle_component **pal ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *a ;

  {
#line 2707
  hold_last_name = di->last_name;
#line 2709
  if ((int const   )*(di->n) != 73) {
#line 2709
    if ((int const   )*(di->n) != 74) {
#line 2711
      return ((struct demangle_component *)((void *)0));
    }
  }
#line 2712
  (di->n) ++;
#line 2714
  if ((int const   )*(di->n) == 69) {
    {
#line 2717
    (di->n) ++;
#line 2718
    tmp___0 = d_make_comp(di, (enum demangle_component_type )43, (struct demangle_component *)((void *)0),
                          (struct demangle_component *)((void *)0));
    }
#line 2718
    return (tmp___0);
  }
#line 2721
  al = (struct demangle_component *)((void *)0);
#line 2722
  pal = & al;
  {
#line 2723
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2727
    a = d_template_arg(di);
    }
#line 2728
    if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 2729
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2731
    *pal = d_make_comp(di, (enum demangle_component_type )43, a, (struct demangle_component *)((void *)0));
    }
#line 2732
    if ((unsigned long )*pal == (unsigned long )((void *)0)) {
#line 2733
      return ((struct demangle_component *)((void *)0));
    }
#line 2734
    pal = & (*pal)->u.s_binary.right;
#line 2736
    if ((int const   )*(di->n) == 69) {
#line 2738
      (di->n) ++;
#line 2739
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2743
  di->last_name = hold_last_name;
#line 2745
  return (al);
}
}
#line 2753 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_template_arg(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  int tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
  {
#line 2760
  if ((int const   )*(di->n) == 88) {
#line 2760
    goto case_88;
  }
#line 2767
  if ((int const   )*(di->n) == 76) {
#line 2767
    goto case_76;
  }
#line 2771
  if ((int const   )*(di->n) == 74) {
#line 2771
    goto case_74;
  }
#line 2771
  if ((int const   )*(di->n) == 73) {
#line 2771
    goto case_74;
  }
#line 2775
  goto switch_default;
  case_88: /* CIL Label */ 
  {
#line 2761
  (di->n) ++;
#line 2762
  ret = d_expression(di);
  }
#line 2763
  if ((int const   )*(di->n) == 69) {
#line 2763
    (di->n) ++;
#line 2763
    tmp___0 = 1;
  } else {
#line 2763
    tmp___0 = 0;
  }
#line 2763
  if (! tmp___0) {
#line 2764
    return ((struct demangle_component *)((void *)0));
  }
#line 2765
  return (ret);
  case_76: /* CIL Label */ 
  {
#line 2768
  tmp___1 = d_expr_primary(di);
  }
#line 2768
  return (tmp___1);
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  {
#line 2773
  tmp___2 = d_template_args(di);
  }
#line 2773
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 2776
  tmp___3 = cplus_demangle_type(di);
  }
#line 2776
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2783 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_exprlist(struct d_info *di , char terminator ) 
{ 
  struct demangle_component *list ;
  struct demangle_component **p ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *arg ;
  struct demangle_component *tmp___1 ;

  {
#line 2786
  list = (struct demangle_component *)((void *)0);
#line 2787
  p = & list;
#line 2789
  if ((int const   )*(di->n) == (int const   )terminator) {
    {
#line 2791
    (di->n) ++;
#line 2792
    tmp___0 = d_make_comp(di, (enum demangle_component_type )42, (struct demangle_component *)((void *)0),
                          (struct demangle_component *)((void *)0));
    }
#line 2792
    return (tmp___0);
  }
  {
#line 2795
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2797
    tmp___1 = d_expression(di);
#line 2797
    arg = tmp___1;
    }
#line 2798
    if ((unsigned long )arg == (unsigned long )((void *)0)) {
#line 2799
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 2801
    *p = d_make_comp(di, (enum demangle_component_type )42, arg, (struct demangle_component *)((void *)0));
    }
#line 2802
    if ((unsigned long )*p == (unsigned long )((void *)0)) {
#line 2803
      return ((struct demangle_component *)((void *)0));
    }
#line 2804
    p = & (*p)->u.s_binary.right;
#line 2806
    if ((int const   )*(di->n) == (int const   )terminator) {
#line 2808
      (di->n) ++;
#line 2809
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2813
  return (list);
}
}
#line 2819 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int op_is_new_cast(struct demangle_component *op ) 
{ 
  char const   *code ;
  int tmp___0 ;

  {
#line 2822
  code = (char const   *)(op->u.s_operator.op)->code;
#line 2823
  if ((int const   )*(code + 1) == 99) {
#line 2823
    if ((int const   )*(code + 0) == 115) {
#line 2823
      tmp___0 = 1;
    } else
#line 2823
    if ((int const   )*(code + 0) == 100) {
#line 2823
      tmp___0 = 1;
    } else
#line 2823
    if ((int const   )*(code + 0) == 99) {
#line 2823
      tmp___0 = 1;
    } else
#line 2823
    if ((int const   )*(code + 0) == 114) {
#line 2823
      tmp___0 = 1;
    } else {
#line 2823
      tmp___0 = 0;
    }
  } else {
#line 2823
    tmp___0 = 0;
  }
#line 2823
  return (tmp___0);
}
}
#line 2839 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_expression(struct d_info *di ) 
{ 
  char peek ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *type ;
  struct demangle_component *name___0 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *tmp___5 ;
  struct demangle_component *tmp___6 ;
  struct demangle_component *tmp___7 ;
  int index___0 ;
  long tmp___8 ;
  struct demangle_component *tmp___9 ;
  struct demangle_component *name___1 ;
  struct demangle_component *tmp___10 ;
  struct demangle_component *tmp___11 ;
  struct demangle_component *type___0 ;
  struct demangle_component *tmp___12 ;
  struct demangle_component *tmp___13 ;
  struct demangle_component *op ;
  char const   *code ;
  int args ;
  struct demangle_component *tmp___14 ;
  struct demangle_component *tmp___15 ;
  int tmp___16 ;
  struct demangle_component *tmp___17 ;
  struct demangle_component *operand ;
  int suffix ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  struct demangle_component *tmp___21 ;
  struct demangle_component *tmp___22 ;
  struct demangle_component *tmp___23 ;
  struct demangle_component *left ;
  struct demangle_component *right ;
  int tmp___24 ;
  struct demangle_component *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  struct demangle_component *tmp___29 ;
  struct demangle_component *tmp___30 ;
  struct demangle_component *first ;
  struct demangle_component *second ;
  struct demangle_component *third ;
  int tmp___31 ;
  struct demangle_component *tmp___32 ;
  struct demangle_component *tmp___33 ;
  struct demangle_component *tmp___34 ;

  {
#line 2844
  peek = (char )*(di->n);
#line 2845
  if ((int )peek == 76) {
    {
#line 2846
    tmp___0 = d_expr_primary(di);
    }
#line 2846
    return (tmp___0);
  } else
#line 2847
  if ((int )peek == 84) {
    {
#line 2848
    tmp___1 = d_template_param(di);
    }
#line 2848
    return (tmp___1);
  } else
#line 2849
  if ((int )peek == 115) {
#line 2849
    if ((int const   )*(di->n + 1) == 114) {
      {
#line 2854
      di->n += 2;
#line 2855
      type = cplus_demangle_type(di);
#line 2856
      name___0 = d_unqualified_name(di);
      }
#line 2857
      if ((int const   )*(di->n) != 73) {
        {
#line 2858
        tmp___2 = d_make_comp(di, (enum demangle_component_type )1, type, name___0);
        }
#line 2858
        return (tmp___2);
      } else {
        {
#line 2860
        tmp___3 = d_template_args(di);
#line 2860
        tmp___4 = d_make_comp(di, (enum demangle_component_type )4, name___0, tmp___3);
#line 2860
        tmp___5 = d_make_comp(di, (enum demangle_component_type )1, type, tmp___4);
        }
#line 2860
        return (tmp___5);
      }
    } else {
#line 2849
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2864
  if ((int )peek == 115) {
#line 2864
    if ((int const   )*(di->n + 1) == 112) {
      {
#line 2866
      di->n += 2;
#line 2867
      tmp___6 = d_expression(di);
#line 2867
      tmp___7 = d_make_comp(di, (enum demangle_component_type )69, tmp___6, (struct demangle_component *)((void *)0));
      }
#line 2867
      return (tmp___7);
    } else {
#line 2864
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 2870
  if ((int )peek == 102) {
#line 2870
    if ((int const   )*(di->n + 1) == 112) {
#line 2874
      di->n += 2;
#line 2875
      if ((int const   )*(di->n) == 84) {
#line 2878
        (di->n) ++;
#line 2879
        index___0 = 0;
      } else {
        {
#line 2883
        tmp___8 = d_compact_number(di);
#line 2883
        index___0 = (int )(tmp___8 + 1L);
        }
#line 2884
        if (index___0 == 0) {
#line 2885
          return ((struct demangle_component *)((void *)0));
        }
      }
      {
#line 2887
      tmp___9 = d_make_function_param(di, (long )index___0);
      }
#line 2887
      return (tmp___9);
    } else {
#line 2870
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 2889
  if ((int )peek >= 48) {
#line 2889
    if ((int )peek <= 57) {
#line 2889
      goto _L___4;
    } else {
#line 2889
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2889
  if ((int )peek == 111) {
#line 2889
    if ((int const   )*(di->n + 1) == 110) {
      _L___4: /* CIL Label */ 
#line 2896
      if ((int )peek == 111) {
#line 2898
        di->n += 2;
      }
      {
#line 2900
      name___1 = d_unqualified_name(di);
      }
#line 2901
      if ((unsigned long )name___1 == (unsigned long )((void *)0)) {
#line 2902
        return ((struct demangle_component *)((void *)0));
      }
#line 2903
      if ((int const   )*(di->n) == 73) {
        {
#line 2904
        tmp___10 = d_template_args(di);
#line 2904
        tmp___11 = d_make_comp(di, (enum demangle_component_type )4, name___1, tmp___10);
        }
#line 2904
        return (tmp___11);
      } else {
#line 2907
        return (name___1);
      }
    } else {
#line 2889
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2909
  if ((int )peek == 105) {
#line 2909
    goto _L___3;
  } else
#line 2909
  if ((int )peek == 116) {
    _L___3: /* CIL Label */ 
#line 2909
    if ((int const   )*(di->n + 1) == 108) {
#line 2913
      type___0 = (struct demangle_component *)((void *)0);
#line 2914
      if ((int )peek == 116) {
        {
#line 2915
        type___0 = cplus_demangle_type(di);
        }
      }
      {
#line 2916
      di->n += 2;
#line 2917
      tmp___12 = d_exprlist(di, (char )'E');
#line 2917
      tmp___13 = d_make_comp(di, (enum demangle_component_type )44, type___0, tmp___12);
      }
#line 2917
      return (tmp___13);
    } else {
#line 2909
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 2923
    code = (char const   *)((void *)0);
#line 2926
    op = d_operator_name(di);
    }
#line 2927
    if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 2928
      return ((struct demangle_component *)((void *)0));
    }
#line 2930
    if ((unsigned int )op->type == 45U) {
      {
#line 2932
      code = (char const   *)(op->u.s_operator.op)->code;
#line 2933
      di->expansion += (int )((op->u.s_operator.op)->len - 2);
#line 2934
      tmp___16 = strcmp(code, "st");
      }
#line 2934
      if (tmp___16 == 0) {
        {
#line 2935
        tmp___14 = cplus_demangle_type(di);
#line 2935
        tmp___15 = d_make_comp(di, (enum demangle_component_type )49, op, tmp___14);
        }
#line 2935
        return (tmp___15);
      }
    }
    {
#line 2943
    if ((unsigned int )op->type == 45U) {
#line 2943
      goto case_45;
    }
#line 2946
    if ((unsigned int )op->type == 46U) {
#line 2946
      goto case_46;
    }
#line 2949
    if ((unsigned int )op->type == 47U) {
#line 2949
      goto case_47;
    }
#line 2941
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 2942
    return ((struct demangle_component *)((void *)0));
    case_45: /* CIL Label */ 
#line 2944
    args = (int )(op->u.s_operator.op)->args;
#line 2945
    goto switch_break;
    case_46: /* CIL Label */ 
#line 2947
    args = op->u.s_extended_operator.args;
#line 2948
    goto switch_break;
    case_47: /* CIL Label */ 
#line 2950
    args = 1;
#line 2951
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 2956
    if (args == 0) {
#line 2956
      goto case_0;
    }
#line 2959
    if (args == 1) {
#line 2959
      goto case_1;
    }
#line 2985
    if (args == 2) {
#line 2985
      goto case_2;
    }
#line 3011
    if (args == 3) {
#line 3011
      goto case_3;
    }
#line 3060
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 2957
    tmp___17 = d_make_comp(di, (enum demangle_component_type )48, op, (struct demangle_component *)((void *)0));
    }
#line 2957
    return (tmp___17);
    case_1: /* CIL Label */ 
#line 2962
    suffix = 0;
#line 2964
    if (code) {
#line 2964
      if ((int const   )*(code + 0) == 112) {
#line 2964
        goto _L;
      } else
#line 2964
      if ((int const   )*(code + 0) == 109) {
        _L: /* CIL Label */ 
#line 2964
        if ((int const   )*(code + 1) == (int const   )*(code + 0)) {
#line 2967
          if ((int const   )*(di->n) == 95) {
#line 2967
            (di->n) ++;
#line 2967
            tmp___18 = 1;
          } else {
#line 2967
            tmp___18 = 0;
          }
#line 2967
          if (tmp___18) {
#line 2967
            tmp___19 = 0;
          } else {
#line 2967
            tmp___19 = 1;
          }
#line 2967
          suffix = tmp___19;
        }
      }
    }
#line 2969
    if ((unsigned int )op->type == 47U) {
#line 2969
      if ((int const   )*(di->n) == 95) {
#line 2969
        (di->n) ++;
#line 2969
        tmp___20 = 1;
      } else {
#line 2969
        tmp___20 = 0;
      }
#line 2969
      if (tmp___20) {
        {
#line 2971
        operand = d_exprlist(di, (char )'E');
        }
      } else {
        {
#line 2973
        operand = d_expression(di);
        }
      }
    } else {
      {
#line 2973
      operand = d_expression(di);
      }
    }
#line 2975
    if (suffix) {
      {
#line 2977
      tmp___21 = d_make_comp(di, (enum demangle_component_type )51, operand, operand);
#line 2977
      tmp___22 = d_make_comp(di, (enum demangle_component_type )49, op, tmp___21);
      }
#line 2977
      return (tmp___22);
    } else {
      {
#line 2982
      tmp___23 = d_make_comp(di, (enum demangle_component_type )49, op, operand);
      }
#line 2982
      return (tmp___23);
    }
    case_2: /* CIL Label */ 
    {
#line 2990
    tmp___24 = op_is_new_cast(op);
    }
#line 2990
    if (tmp___24) {
      {
#line 2991
      left = cplus_demangle_type(di);
      }
    } else {
      {
#line 2993
      left = d_expression(di);
      }
    }
    {
#line 2994
    tmp___28 = strcmp(code, "cl");
    }
#line 2994
    if (tmp___28) {
      {
#line 2996
      tmp___26 = strcmp(code, "dt");
      }
#line 2996
      if (tmp___26) {
        {
#line 2996
        tmp___27 = strcmp(code, "pt");
        }
#line 2996
        if (tmp___27) {
          {
#line 3004
          right = d_expression(di);
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 2998
          right = d_unqualified_name(di);
          }
#line 2999
          if ((int const   )*(di->n) == 73) {
            {
#line 3000
            tmp___25 = d_template_args(di);
#line 3000
            right = d_make_comp(di, (enum demangle_component_type )4, right, tmp___25);
            }
          }
        }
      } else {
#line 2996
        goto _L___0;
      }
    } else {
      {
#line 2995
      right = d_exprlist(di, (char )'E');
      }
    }
    {
#line 3006
    tmp___29 = d_make_comp(di, (enum demangle_component_type )51, left, right);
#line 3006
    tmp___30 = d_make_comp(di, (enum demangle_component_type )50, op, tmp___29);
    }
#line 3006
    return (tmp___30);
    case_3: /* CIL Label */ 
    {
#line 3017
    tmp___31 = strcmp(code, "qu");
    }
#line 3017
    if (tmp___31) {
#line 3024
      if ((int const   )*(code + 0) == 110) {
#line 3027
        if ((int const   )*(code + 1) != 119) {
#line 3027
          if ((int const   )*(code + 1) != 97) {
#line 3028
            return ((struct demangle_component *)((void *)0));
          }
        }
        {
#line 3029
        first = d_exprlist(di, (char )'_');
#line 3030
        second = cplus_demangle_type(di);
        }
#line 3031
        if ((int const   )*(di->n) == 69) {
#line 3033
          (di->n) ++;
#line 3034
          third = (struct demangle_component *)((void *)0);
        } else
#line 3036
        if ((int const   )*(di->n) == 112) {
#line 3036
          if ((int const   )*(di->n + 1) == 105) {
            {
#line 3040
            di->n += 2;
#line 3041
            third = d_exprlist(di, (char )'E');
            }
          } else {
#line 3036
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 3043
        if ((int const   )*(di->n) == 105) {
#line 3043
          if ((int const   )*(di->n + 1) == 108) {
            {
#line 3046
            third = d_expression(di);
            }
          } else {
#line 3048
            return ((struct demangle_component *)((void *)0));
          }
        } else {
#line 3048
          return ((struct demangle_component *)((void *)0));
        }
      } else {
#line 3051
        return ((struct demangle_component *)((void *)0));
      }
    } else {
      {
#line 3020
      first = d_expression(di);
#line 3021
      second = d_expression(di);
#line 3022
      third = d_expression(di);
      }
    }
    {
#line 3052
    tmp___32 = d_make_comp(di, (enum demangle_component_type )54, second, third);
#line 3052
    tmp___33 = d_make_comp(di, (enum demangle_component_type )53, first, tmp___32);
#line 3052
    tmp___34 = d_make_comp(di, (enum demangle_component_type )52, op, tmp___33);
    }
#line 3052
    return (tmp___34);
    switch_default___0: /* CIL Label */ 
#line 3061
    return ((struct demangle_component *)((void *)0));
    switch_break___0: /* CIL Label */ ;
    }
  }
}
}
#line 3071 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_expr_primary(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  int tmp___0 ;
  struct demangle_component *type ;
  enum demangle_component_type t ;
  char const   *s ;
  struct demangle_component *tmp___1 ;
  int tmp___2 ;

  {
#line 3076
  if ((int const   )*(di->n) == 76) {
#line 3076
    (di->n) ++;
#line 3076
    tmp___0 = 1;
  } else {
#line 3076
    tmp___0 = 0;
  }
#line 3076
  if (! tmp___0) {
#line 3077
    return ((struct demangle_component *)((void *)0));
  }
#line 3078
  if ((int const   )*(di->n) == 95) {
    {
#line 3081
    ret = cplus_demangle_mangled_name(di, 0);
    }
  } else
#line 3078
  if ((int const   )*(di->n) == 90) {
    {
#line 3081
    ret = cplus_demangle_mangled_name(di, 0);
    }
  } else {
    {
#line 3088
    type = cplus_demangle_type(di);
    }
#line 3089
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 3090
      return ((struct demangle_component *)((void *)0));
    }
#line 3094
    if ((unsigned int )type->type == 35U) {
#line 3094
      if ((unsigned int const   )(type->u.s_builtin.type)->print != 0U) {
#line 3096
        di->expansion -= (int )(type->u.s_builtin.type)->len;
      }
    }
#line 3109
    t = (enum demangle_component_type )55;
#line 3110
    if ((int const   )*(di->n) == 110) {
#line 3112
      t = (enum demangle_component_type )56;
#line 3113
      (di->n) ++;
    }
#line 3115
    s = di->n;
    {
#line 3116
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3116
      if (! ((int const   )*(di->n) != 69)) {
#line 3116
        goto while_break;
      }
#line 3118
      if ((int const   )*(di->n) == 0) {
#line 3119
        return ((struct demangle_component *)((void *)0));
      }
#line 3120
      (di->n) ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3122
    tmp___1 = d_make_name(di, s, (int )(di->n - s));
#line 3122
    ret = d_make_comp(di, t, type, tmp___1);
    }
  }
#line 3124
  if ((int const   )*(di->n) == 69) {
#line 3124
    (di->n) ++;
#line 3124
    tmp___2 = 1;
  } else {
#line 3124
    tmp___2 = 0;
  }
#line 3124
  if (! tmp___2) {
#line 3125
    return ((struct demangle_component *)((void *)0));
  }
#line 3126
  return (ret);
}
}
#line 3133 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_local_name(struct d_info *di ) 
{ 
  struct demangle_component *function ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct demangle_component *tmp___3 ;
  struct demangle_component *tmp___4 ;
  struct demangle_component *name___0 ;
  int num ;
  long tmp___5 ;
  int tmp___6 ;
  struct demangle_component *tmp___7 ;

  {
#line 3138
  if ((int const   )*(di->n) == 90) {
#line 3138
    (di->n) ++;
#line 3138
    tmp___0 = 1;
  } else {
#line 3138
    tmp___0 = 0;
  }
#line 3138
  if (! tmp___0) {
#line 3139
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3141
  function = d_encoding(di, 0);
  }
#line 3143
  if ((int const   )*(di->n) == 69) {
#line 3143
    (di->n) ++;
#line 3143
    tmp___1 = 1;
  } else {
#line 3143
    tmp___1 = 0;
  }
#line 3143
  if (! tmp___1) {
#line 3144
    return ((struct demangle_component *)((void *)0));
  }
#line 3146
  if ((int const   )*(di->n) == 115) {
    {
#line 3148
    (di->n) ++;
#line 3149
    tmp___2 = d_discriminator(di);
    }
#line 3149
    if (! tmp___2) {
#line 3150
      return ((struct demangle_component *)((void *)0));
    }
    {
#line 3151
    tmp___3 = d_make_name(di, "string literal", (int )(sizeof("string literal") - 1UL));
#line 3151
    tmp___4 = d_make_comp(di, (enum demangle_component_type )2, function, tmp___3);
    }
#line 3151
    return (tmp___4);
  } else {
#line 3158
    num = -1;
#line 3160
    if ((int const   )*(di->n) == 100) {
      {
#line 3163
      (di->n) ++;
#line 3164
      tmp___5 = d_compact_number(di);
#line 3164
      num = (int )tmp___5;
      }
#line 3165
      if (num < 0) {
#line 3166
        return ((struct demangle_component *)((void *)0));
      }
    }
    {
#line 3169
    name___0 = d_name(di);
    }
#line 3170
    if (name___0) {
      {
#line 3175
      if ((unsigned int )name___0->type == 66U) {
#line 3175
        goto case_66;
      }
#line 3175
      if ((unsigned int )name___0->type == 64U) {
#line 3175
        goto case_66;
      }
#line 3177
      goto switch_default;
      case_66: /* CIL Label */ 
      case_64: /* CIL Label */ 
#line 3176
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 3178
      tmp___6 = d_discriminator(di);
      }
#line 3178
      if (! tmp___6) {
#line 3179
        return ((struct demangle_component *)((void *)0));
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 3181
    if (num >= 0) {
      {
#line 3182
      name___0 = d_make_default_arg(di, num, name___0);
      }
    }
    {
#line 3183
    tmp___7 = d_make_comp(di, (enum demangle_component_type )2, function, name___0);
    }
#line 3183
    return (tmp___7);
  }
}
}
#line 3192 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int d_discriminator(struct d_info *di ) 
{ 
  long discrim ;

  {
#line 3197
  if ((int const   )*(di->n) != 95) {
#line 3198
    return (1);
  }
  {
#line 3199
  (di->n) ++;
#line 3200
  discrim = d_number(di);
  }
#line 3201
  if (discrim < 0L) {
#line 3202
    return (0);
  }
#line 3203
  return (1);
}
}
#line 3208 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_lambda(struct d_info *di ) 
{ 
  struct demangle_component *tl ;
  struct demangle_component *ret ;
  int num ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;

  {
#line 3215
  if ((int const   )*(di->n) == 85) {
#line 3215
    (di->n) ++;
#line 3215
    tmp___0 = 1;
  } else {
#line 3215
    tmp___0 = 0;
  }
#line 3215
  if (! tmp___0) {
#line 3216
    return ((struct demangle_component *)((void *)0));
  }
#line 3217
  if ((int const   )*(di->n) == 108) {
#line 3217
    (di->n) ++;
#line 3217
    tmp___1 = 1;
  } else {
#line 3217
    tmp___1 = 0;
  }
#line 3217
  if (! tmp___1) {
#line 3218
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3220
  tl = d_parmlist(di);
  }
#line 3221
  if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 3222
    return ((struct demangle_component *)((void *)0));
  }
#line 3224
  if ((int const   )*(di->n) == 69) {
#line 3224
    (di->n) ++;
#line 3224
    tmp___2 = 1;
  } else {
#line 3224
    tmp___2 = 0;
  }
#line 3224
  if (! tmp___2) {
#line 3225
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3227
  tmp___3 = d_compact_number(di);
#line 3227
  num = (int )tmp___3;
  }
#line 3228
  if (num < 0) {
#line 3229
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3231
  ret = d_make_empty(di);
  }
#line 3232
  if (ret) {
#line 3234
    ret->type = (enum demangle_component_type )64;
#line 3235
    ret->u.s_unary_num.sub = tl;
#line 3236
    ret->u.s_unary_num.num = num;
  }
  {
#line 3239
  tmp___4 = d_add_substitution(di, ret);
  }
#line 3239
  if (! tmp___4) {
#line 3240
    return ((struct demangle_component *)((void *)0));
  }
#line 3242
  return (ret);
}
}
#line 3247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_unnamed_type(struct d_info *di ) 
{ 
  struct demangle_component *ret ;
  long num ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 3253
  if ((int const   )*(di->n) == 85) {
#line 3253
    (di->n) ++;
#line 3253
    tmp___0 = 1;
  } else {
#line 3253
    tmp___0 = 0;
  }
#line 3253
  if (! tmp___0) {
#line 3254
    return ((struct demangle_component *)((void *)0));
  }
#line 3255
  if ((int const   )*(di->n) == 116) {
#line 3255
    (di->n) ++;
#line 3255
    tmp___1 = 1;
  } else {
#line 3255
    tmp___1 = 0;
  }
#line 3255
  if (! tmp___1) {
#line 3256
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3258
  num = d_compact_number(di);
  }
#line 3259
  if (num < 0L) {
#line 3260
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3262
  ret = d_make_empty(di);
  }
#line 3263
  if (ret) {
#line 3265
    ret->type = (enum demangle_component_type )66;
#line 3266
    ret->u.s_number.number = num;
  }
  {
#line 3269
  tmp___2 = d_add_substitution(di, ret);
  }
#line 3269
  if (! tmp___2) {
#line 3270
    return ((struct demangle_component *)((void *)0));
  }
#line 3272
  return (ret);
}
}
#line 3278 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_clone_suffix(struct d_info *di , struct demangle_component *encoding ) 
{ 
  char const   *suffix ;
  char const   *pend ;
  struct demangle_component *n ;
  struct demangle_component *tmp___0 ;

  {
#line 3281
  suffix = di->n;
#line 3282
  pend = suffix;
#line 3285
  if ((int const   )*pend == 46) {
#line 3285
    if ((int const   )*(pend + 1) >= 97) {
#line 3285
      if ((int const   )*(pend + 1) <= 122) {
#line 3285
        goto _L___0;
      } else {
#line 3285
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 3285
    if ((int const   )*(pend + 1) == 95) {
      _L___0: /* CIL Label */ 
#line 3287
      pend += 2;
      {
#line 3288
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3288
        if ((int const   )*pend >= 97) {
#line 3288
          if (! ((int const   )*pend <= 122)) {
#line 3288
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 3288
        if (! ((int const   )*pend == 95)) {
#line 3288
          goto while_break;
        }
#line 3289
        pend ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 3291
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3291
    if ((int const   )*pend == 46) {
#line 3291
      if ((int const   )*(pend + 1) >= 48) {
#line 3291
        if (! ((int const   )*(pend + 1) <= 57)) {
#line 3291
          goto while_break___0;
        }
      } else {
#line 3291
        goto while_break___0;
      }
    } else {
#line 3291
      goto while_break___0;
    }
#line 3293
    pend += 2;
    {
#line 3294
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3294
      if ((int const   )*pend >= 48) {
#line 3294
        if (! ((int const   )*pend <= 57)) {
#line 3294
          goto while_break___1;
        }
      } else {
#line 3294
        goto while_break___1;
      }
#line 3295
      pend ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3297
  di->n += pend - suffix;
#line 3298
  n = d_make_name(di, suffix, (int )(pend - suffix));
#line 3299
  tmp___0 = d_make_comp(di, (enum demangle_component_type )70, encoding, n);
  }
#line 3299
  return (tmp___0);
}
}
#line 3304 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int d_add_substitution(struct d_info *di , struct demangle_component *dc ) 
{ 


  {
#line 3307
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 3308
    return (0);
  }
#line 3309
  if (di->next_sub >= di->num_subs) {
#line 3310
    return (0);
  }
#line 3311
  *(di->subs + di->next_sub) = dc;
#line 3312
  (di->next_sub) ++;
#line 3313
  return (1);
}
}
#line 3335 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct d_standard_sub_info  const  standard_subs[7]  = {      {(char )'t', "std", (int )(sizeof("std") - 1UL), "std", (int )(sizeof("std") - 1UL),
      (char const   *)((void *)0), 0}, 
        {(char )'a', "std::allocator", (int )(sizeof("std::allocator") - 1UL), "std::allocator",
      (int )(sizeof("std::allocator") - 1UL), "allocator", (int )(sizeof("allocator") - 1UL)}, 
        {(char )'b',
      "std::basic_string", (int )(sizeof("std::basic_string") - 1UL), "std::basic_string",
      (int )(sizeof("std::basic_string") - 1UL), "basic_string", (int )(sizeof("basic_string") - 1UL)}, 
        {(char )'s',
      "std::string", (int )(sizeof("std::string") - 1UL), "std::basic_string<char, std::char_traits<char>, std::allocator<char> >",
      (int )(sizeof("std::basic_string<char, std::char_traits<char>, std::allocator<char> >") - 1UL),
      "basic_string", (int )(sizeof("basic_string") - 1UL)}, 
        {(char )'i', "std::istream", (int )(sizeof("std::istream") - 1UL), "std::basic_istream<char, std::char_traits<char> >",
      (int )(sizeof("std::basic_istream<char, std::char_traits<char> >") - 1UL), "basic_istream",
      (int )(sizeof("basic_istream") - 1UL)}, 
        {(char )'o', "std::ostream", (int )(sizeof("std::ostream") - 1UL), "std::basic_ostream<char, std::char_traits<char> >",
      (int )(sizeof("std::basic_ostream<char, std::char_traits<char> >") - 1UL), "basic_ostream",
      (int )(sizeof("basic_ostream") - 1UL)}, 
        {(char )'d', "std::iostream", (int )(sizeof("std::iostream") - 1UL), "std::basic_iostream<char, std::char_traits<char> >",
      (int )(sizeof("std::basic_iostream<char, std::char_traits<char> >") - 1UL),
      "basic_iostream", (int )(sizeof("basic_iostream") - 1UL)}};
#line 3360 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_substitution(struct d_info *di , int prefix ) 
{ 
  char c ;
  int tmp___0 ;
  char const   *tmp___1 ;
  unsigned int id ;
  unsigned int new_id ;
  char const   *tmp___2 ;
  int verbose ;
  struct d_standard_sub_info  const  *p ;
  struct d_standard_sub_info  const  *pend ;
  char peek ;
  char const   *s ;
  int len ;
  struct demangle_component *tmp___3 ;

  {
#line 3365
  if ((int const   )*(di->n) == 83) {
#line 3365
    (di->n) ++;
#line 3365
    tmp___0 = 1;
  } else {
#line 3365
    tmp___0 = 0;
  }
#line 3365
  if (! tmp___0) {
#line 3366
    return ((struct demangle_component *)((void *)0));
  }
#line 3368
  if ((int const   )*(di->n) == 0) {
#line 3368
    c = (char )'\000';
  } else {
#line 3368
    tmp___1 = di->n;
#line 3368
    (di->n) ++;
#line 3368
    c = (char )*tmp___1;
  }
#line 3369
  if ((int )c == 95) {
#line 3369
    goto _L___0;
  } else
#line 3369
  if ((int )c >= 48) {
#line 3369
    if ((int )c <= 57) {
#line 3369
      goto _L___0;
    } else {
#line 3369
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3369
  if ((int )c >= 65) {
#line 3369
    if ((int )c <= 90) {
      _L___0: /* CIL Label */ 
#line 3373
      id = 0U;
#line 3374
      if ((int )c != 95) {
        {
#line 3376
        while (1) {
          while_continue: /* CIL Label */ ;
#line 3380
          if ((int )c >= 48) {
#line 3380
            if ((int )c <= 57) {
#line 3381
              new_id = (id * 36U + (unsigned int )c) - 48U;
            } else {
#line 3380
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 3382
          if ((int )c >= 65) {
#line 3382
            if ((int )c <= 90) {
#line 3383
              new_id = ((id * 36U + (unsigned int )c) - 65U) + 10U;
            } else {
#line 3385
              return ((struct demangle_component *)((void *)0));
            }
          } else {
#line 3385
            return ((struct demangle_component *)((void *)0));
          }
#line 3386
          if (new_id < id) {
#line 3387
            return ((struct demangle_component *)((void *)0));
          }
#line 3388
          id = new_id;
#line 3389
          if ((int const   )*(di->n) == 0) {
#line 3389
            c = (char )'\000';
          } else {
#line 3389
            tmp___2 = di->n;
#line 3389
            (di->n) ++;
#line 3389
            c = (char )*tmp___2;
          }
#line 3376
          if (! ((int )c != 95)) {
#line 3376
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
#line 3393
        id ++;
      }
#line 3396
      if (id >= (unsigned int )di->next_sub) {
#line 3397
        return ((struct demangle_component *)((void *)0));
      }
#line 3399
      (di->did_subs) ++;
#line 3401
      return (*(di->subs + id));
    } else {
#line 3369
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 3409
    verbose = (di->options & (1 << 3)) != 0;
#line 3410
    if (! verbose) {
#line 3410
      if (prefix) {
#line 3414
        peek = (char )*(di->n);
#line 3415
        if ((int )peek == 67) {
#line 3416
          verbose = 1;
        } else
#line 3415
        if ((int )peek == 68) {
#line 3416
          verbose = 1;
        }
      }
    }
#line 3419
    pend = & standard_subs[0] + sizeof(standard_subs) / sizeof(standard_subs[0]);
#line 3421
    p = & standard_subs[0];
    {
#line 3421
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3421
      if (! ((unsigned long )p < (unsigned long )pend)) {
#line 3421
        goto while_break___0;
      }
#line 3423
      if ((int )c == (int )p->code) {
#line 3428
        if ((unsigned long )p->set_last_name != (unsigned long )((void *)0)) {
          {
#line 3429
          di->last_name = d_make_sub(di, (char const   *)p->set_last_name, (int )p->set_last_name_len);
          }
        }
#line 3431
        if (verbose) {
#line 3433
          s = (char const   *)p->full_expansion;
#line 3434
          len = (int )p->full_len;
        } else {
#line 3438
          s = (char const   *)p->simple_expansion;
#line 3439
          len = (int )p->simple_len;
        }
        {
#line 3441
        di->expansion += len;
#line 3442
        tmp___3 = d_make_sub(di, s, len);
        }
#line 3442
        return (tmp___3);
      }
#line 3421
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3446
    return ((struct demangle_component *)((void *)0));
  }
}
}
#line 3452 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_growable_string_init(struct d_growable_string *dgs , size_t estimate ) 
{ 


  {
#line 3455
  dgs->buf = (char *)((void *)0);
#line 3456
  dgs->len = (size_t )0;
#line 3457
  dgs->alc = (size_t )0;
#line 3458
  dgs->allocation_failure = 0;
#line 3460
  if (estimate > 0UL) {
    {
#line 3461
    d_growable_string_resize(dgs, estimate);
    }
  }
#line 3462
  return;
}
}
#line 3466 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_growable_string_resize(struct d_growable_string *dgs , size_t need ) 
{ 
  size_t newalc ;
  char *newbuf ;
  void *tmp___0 ;

  {
#line 3472
  if (dgs->allocation_failure) {
#line 3473
    return;
  }
#line 3478
  if (dgs->alc > 0UL) {
#line 3478
    newalc = dgs->alc;
  } else {
#line 3478
    newalc = (size_t )2;
  }
  {
#line 3479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3479
    if (! (newalc < need)) {
#line 3479
      goto while_break;
    }
#line 3480
    newalc <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3482
  tmp___0 = realloc((void *)dgs->buf, newalc);
#line 3482
  newbuf = (char *)tmp___0;
  }
#line 3483
  if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
    {
#line 3485
    free((void *)dgs->buf);
#line 3486
    dgs->buf = (char *)((void *)0);
#line 3487
    dgs->len = (size_t )0;
#line 3488
    dgs->alc = (size_t )0;
#line 3489
    dgs->allocation_failure = 1;
    }
#line 3490
    return;
  }
#line 3492
  dgs->buf = newbuf;
#line 3493
  dgs->alc = newalc;
#line 3494
  return;
}
}
#line 3498 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_growable_string_append_buffer(struct d_growable_string *dgs ,
                                                     char const   *s , size_t l ) 
{ 
  size_t need ;

  {
#line 3504
  need = (dgs->len + l) + 1UL;
#line 3505
  if (need > dgs->alc) {
    {
#line 3506
    d_growable_string_resize(dgs, need);
    }
  }
#line 3508
  if (dgs->allocation_failure) {
#line 3509
    return;
  }
  {
#line 3511
  memcpy((void */* __restrict  */)(dgs->buf + dgs->len), (void const   */* __restrict  */)s,
         l);
#line 3512
  *(dgs->buf + (dgs->len + l)) = (char )'\000';
#line 3513
  dgs->len += l;
  }
#line 3514
  return;
}
}
#line 3518 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_growable_string_callback_adapter(char const   *s , size_t l , void *opaque ) 
{ 
  struct d_growable_string *dgs ;

  {
  {
#line 3521
  dgs = (struct d_growable_string *)opaque;
#line 3523
  d_growable_string_append_buffer(dgs, s, l);
  }
#line 3524
  return;
}
}
#line 3528 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_init(struct d_print_info *dpi , void (*callback)(char const   * ,
                                                                     size_t  , void * ) ,
                         void *opaque ) 
{ 


  {
#line 3532
  dpi->len = (size_t )0;
#line 3533
  dpi->last_char = (char )'\000';
#line 3534
  dpi->templates = (struct d_print_template *)((void *)0);
#line 3535
  dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 3536
  dpi->pack_index = 0;
#line 3537
  dpi->flush_count = 0UL;
#line 3539
  dpi->callback = callback;
#line 3540
  dpi->opaque = opaque;
#line 3542
  dpi->demangle_failure = 0;
#line 3543
  return;
}
}
#line 3547 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_print_error(struct d_print_info *dpi ) 
{ 


  {
#line 3550
  dpi->demangle_failure = 1;
#line 3551
  return;
}
}
#line 3553 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static int d_print_saw_error(struct d_print_info *dpi ) 
{ 


  {
#line 3556
  return (dpi->demangle_failure != 0);
}
}
#line 3561 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_print_flush(struct d_print_info *dpi ) 
{ 


  {
  {
#line 3564
  dpi->buf[dpi->len] = (char )'\000';
#line 3565
  (*(dpi->callback))((char const   *)(dpi->buf), dpi->len, dpi->opaque);
#line 3566
  dpi->len = (size_t )0;
#line 3567
  (dpi->flush_count) ++;
  }
#line 3568
  return;
}
}
#line 3572 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_append_char(struct d_print_info *dpi , char c ) 
{ 
  size_t tmp___0 ;

  {
#line 3575
  if (dpi->len == sizeof(dpi->buf) - 1UL) {
    {
#line 3576
    d_print_flush(dpi);
    }
  }
#line 3578
  tmp___0 = dpi->len;
#line 3578
  (dpi->len) ++;
#line 3578
  dpi->buf[tmp___0] = c;
#line 3579
  dpi->last_char = c;
#line 3580
  return;
}
}
#line 3582 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_append_buffer(struct d_print_info *dpi , char const   *s ,
                                     size_t l ) 
{ 
  size_t i ;

  {
#line 3587
  i = (size_t )0;
  {
#line 3587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3587
    if (! (i < l)) {
#line 3587
      goto while_break;
    }
    {
#line 3588
    d_append_char(dpi, (char )*(s + i));
#line 3587
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3589
  return;
}
}
#line 3591 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_append_string(struct d_print_info *dpi , char const   *s ) 
{ 
  size_t tmp___0 ;

  {
  {
#line 3594
  tmp___0 = strlen(s);
#line 3594
  d_append_buffer(dpi, s, tmp___0);
  }
#line 3595
  return;
}
}
#line 3597 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static void d_append_num(struct d_print_info *dpi , long l ) 
{ 
  char buf___4[25] ;

  {
  {
#line 3601
  sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"%ld",
          l);
#line 3602
  d_append_string(dpi, (char const   *)(buf___4));
  }
#line 3603
  return;
}
}
#line 3605 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
__inline static char d_last_char(struct d_print_info *dpi ) 
{ 


  {
#line 3608
  return (dpi->last_char);
}
}
#line 3621 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int cplus_demangle_print_callback(int options___0 , struct demangle_component  const  *dc ,
                                  void (*callback)(char const   * , size_t  , void * ) ,
                                  void *opaque ) 
{ 
  struct d_print_info dpi ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 3628
  d_print_init(& dpi, callback, opaque);
#line 3630
  d_print_comp(& dpi, options___0, dc);
#line 3632
  d_print_flush(& dpi);
#line 3634
  tmp___0 = d_print_saw_error(& dpi);
  }
#line 3634
  if (tmp___0) {
#line 3634
    tmp___1 = 0;
  } else {
#line 3634
    tmp___1 = 1;
  }
#line 3634
  return (tmp___1);
}
}
#line 3646 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
char *cplus_demangle_print(int options___0 , struct demangle_component  const  *dc ,
                           int estimate , size_t *palc ) 
{ 
  struct d_growable_string dgs ;
  int tmp___0 ;

  {
  {
#line 3652
  d_growable_string_init(& dgs, (size_t )estimate);
#line 3654
  tmp___0 = cplus_demangle_print_callback(options___0, dc, & d_growable_string_callback_adapter,
                                          (void *)(& dgs));
  }
#line 3654
  if (! tmp___0) {
    {
#line 3658
    free((void *)dgs.buf);
#line 3659
    *palc = (size_t )0;
    }
#line 3660
    return ((char *)((void *)0));
  }
#line 3663
  if (dgs.allocation_failure) {
#line 3663
    *palc = (size_t )1;
  } else {
#line 3663
    *palc = dgs.alc;
  }
#line 3664
  return (dgs.buf);
}
}
#line 3670 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_index_template_argument(struct demangle_component *args ,
                                                            int i ) 
{ 
  struct demangle_component *a ;

  {
#line 3675
  a = args;
  {
#line 3675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3675
    if (! ((unsigned long )a != (unsigned long )((void *)0))) {
#line 3675
      goto while_break;
    }
#line 3679
    if ((unsigned int )a->type != 43U) {
#line 3680
      return ((struct demangle_component *)((void *)0));
    }
#line 3681
    if (i <= 0) {
#line 3682
      goto while_break;
    }
#line 3683
    i --;
#line 3675
    a = a->u.s_binary.right;
  }
  while_break: /* CIL Label */ ;
  }
#line 3685
  if (i != 0) {
#line 3686
    return ((struct demangle_component *)((void *)0));
  } else
#line 3685
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 3686
    return ((struct demangle_component *)((void *)0));
  }
#line 3688
  return (a->u.s_binary.left);
}
}
#line 3694 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_lookup_template_argument(struct d_print_info *dpi ,
                                                             struct demangle_component  const  *dc ) 
{ 
  struct demangle_component *tmp___0 ;

  {
#line 3698
  if ((unsigned long )dpi->templates == (unsigned long )((void *)0)) {
    {
#line 3700
    d_print_error(dpi);
    }
#line 3701
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3704
  tmp___0 = d_index_template_argument((struct demangle_component *)((dpi->templates)->template_decl)->u.s_binary.right,
                                      (int )dc->u.s_number.number);
  }
#line 3704
  return (tmp___0);
}
}
#line 3711 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static struct demangle_component *d_find_pack(struct d_print_info *dpi , struct demangle_component  const  *dc ) 
{ 
  struct demangle_component *a ;
  struct demangle_component *tmp___0 ;
  struct demangle_component *tmp___1 ;
  struct demangle_component *tmp___2 ;
  struct demangle_component *tmp___3 ;

  {
#line 3716
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
#line 3717
    return ((struct demangle_component *)((void *)0));
  }
  {
#line 3721
  if ((unsigned int const   )dc->type == 5U) {
#line 3721
    goto case_5;
  }
#line 3727
  if ((unsigned int const   )dc->type == 69U) {
#line 3727
    goto case_69;
  }
#line 3737
  if ((unsigned int const   )dc->type == 66U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 6U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 59U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 22U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 35U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 45U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 0U) {
#line 3737
    goto case_66;
  }
#line 3737
  if ((unsigned int const   )dc->type == 64U) {
#line 3737
    goto case_66;
  }
#line 3740
  if ((unsigned int const   )dc->type == 46U) {
#line 3740
    goto case_46;
  }
#line 3742
  if ((unsigned int const   )dc->type == 7U) {
#line 3742
    goto case_7;
  }
#line 3744
  if ((unsigned int const   )dc->type == 8U) {
#line 3744
    goto case_8;
  }
#line 3747
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 3722
  a = d_lookup_template_argument(dpi, dc);
  }
#line 3723
  if (a) {
#line 3723
    if ((unsigned int )a->type == 43U) {
#line 3724
      return (a);
    }
  }
#line 3725
  return ((struct demangle_component *)((void *)0));
  case_69: /* CIL Label */ 
#line 3728
  return ((struct demangle_component *)((void *)0));
  case_66: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_64: /* CIL Label */ 
#line 3738
  return ((struct demangle_component *)((void *)0));
  case_46: /* CIL Label */ 
  {
#line 3741
  tmp___0 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_extended_operator.name);
  }
#line 3741
  return (tmp___0);
  case_7: /* CIL Label */ 
  {
#line 3743
  tmp___1 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_ctor.name);
  }
#line 3743
  return (tmp___1);
  case_8: /* CIL Label */ 
  {
#line 3745
  tmp___2 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_dtor.name);
  }
#line 3745
  return (tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 3748
  a = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 3749
  if (a) {
#line 3750
    return (a);
  }
  {
#line 3751
  tmp___3 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 3751
  return (tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3757 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int d_pack_length(struct demangle_component  const  *dc ) 
{ 
  int count ;

  {
#line 3760
  count = 0;
  {
#line 3761
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3761
    if (dc) {
#line 3761
      if ((unsigned int const   )dc->type == 43U) {
#line 3761
        if (! ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0))) {
#line 3761
          goto while_break;
        }
      } else {
#line 3761
        goto while_break;
      }
    } else {
#line 3761
      goto while_break;
    }
#line 3764
    count ++;
#line 3765
    dc = (struct demangle_component  const  *)dc->u.s_binary.right;
  }
  while_break: /* CIL Label */ ;
  }
#line 3767
  return (count);
}
}
#line 3773 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_subexpr(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 
  int simple ;

  {
#line 3777
  simple = 0;
#line 3778
  if ((unsigned int const   )dc->type == 0U) {
#line 3782
    simple = 1;
  } else
#line 3778
  if ((unsigned int const   )dc->type == 1U) {
#line 3782
    simple = 1;
  } else
#line 3778
  if ((unsigned int const   )dc->type == 44U) {
#line 3782
    simple = 1;
  } else
#line 3778
  if ((unsigned int const   )dc->type == 6U) {
#line 3782
    simple = 1;
  }
#line 3783
  if (! simple) {
    {
#line 3784
    d_append_char(dpi, (char )'(');
    }
  }
  {
#line 3785
  d_print_comp(dpi, options___0, dc);
  }
#line 3786
  if (! simple) {
    {
#line 3787
    d_append_char(dpi, (char )')');
    }
  }
#line 3788
  return;
}
}
#line 3792 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_comp(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 
  struct demangle_component  const  *mod_inner ;
  int tmp___0 ;
  struct d_print_mod *hold_modifiers ;
  struct demangle_component *typed_name ;
  struct d_print_mod adpm[4] ;
  unsigned int i ;
  struct d_print_template dpt ;
  struct demangle_component *local_name ;
  struct d_print_mod *hold_dpm ;
  struct demangle_component *dcl ;
  char tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  struct d_print_template *hold_dpt ;
  struct demangle_component *a ;
  struct demangle_component *tmp___4 ;
  struct d_print_mod *pdpm ;
  struct demangle_component  const  *sub ;
  struct demangle_component *a___0 ;
  struct demangle_component *tmp___5 ;
  struct d_print_mod dpm ;
  struct d_print_mod dpm___0 ;
  struct d_print_mod *hold_modifiers___0 ;
  struct d_print_mod adpm___0[4] ;
  unsigned int i___0 ;
  struct d_print_mod *pdpm___0 ;
  struct d_print_mod dpm___1 ;
  size_t len ;
  unsigned long flush_count ;
  struct demangle_component *type ;
  struct demangle_component *list ;
  struct demangle_operator_info  const  *op ;
  int len___0 ;
  struct demangle_component *op___0 ;
  struct demangle_component *operand ;
  char const   *code ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct demangle_component  const  *func ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct demangle_component *op___1 ;
  struct demangle_component *first ;
  struct demangle_component *second ;
  struct demangle_component *third ;
  int tmp___13 ;
  enum d_builtin_type_print tp ;
  int len___1 ;
  int i___1 ;
  struct demangle_component *a___1 ;
  struct demangle_component *tmp___14 ;
  long num ;

  {
#line 3798
  mod_inner = (struct demangle_component  const  *)((void *)0);
#line 3800
  if ((unsigned long )dc == (unsigned long )((void *)0)) {
    {
#line 3802
    d_print_error(dpi);
    }
#line 3803
    return;
  }
  {
#line 3805
  tmp___0 = d_print_saw_error(dpi);
  }
#line 3805
  if (tmp___0) {
#line 3806
    return;
  }
  {
#line 3810
  if ((unsigned int const   )dc->type == 0U) {
#line 3810
    goto case_0;
  }
#line 3818
  if ((unsigned int const   )dc->type == 2U) {
#line 3818
    goto case_2;
  }
#line 3818
  if ((unsigned int const   )dc->type == 1U) {
#line 3818
    goto case_2;
  }
#line 3827
  if ((unsigned int const   )dc->type == 3U) {
#line 3827
    goto case_3;
  }
#line 3936
  if ((unsigned int const   )dc->type == 4U) {
#line 3936
    goto case_4;
  }
#line 3980
  if ((unsigned int const   )dc->type == 5U) {
#line 3980
    goto case_5;
  }
#line 4009
  if ((unsigned int const   )dc->type == 7U) {
#line 4009
    goto case_7;
  }
#line 4013
  if ((unsigned int const   )dc->type == 8U) {
#line 4013
    goto case_8;
  }
#line 4018
  if ((unsigned int const   )dc->type == 9U) {
#line 4018
    goto case_9;
  }
#line 4023
  if ((unsigned int const   )dc->type == 10U) {
#line 4023
    goto case_10;
  }
#line 4028
  if ((unsigned int const   )dc->type == 11U) {
#line 4028
    goto case_11;
  }
#line 4035
  if ((unsigned int const   )dc->type == 12U) {
#line 4035
    goto case_12;
  }
#line 4040
  if ((unsigned int const   )dc->type == 13U) {
#line 4040
    goto case_13;
  }
#line 4045
  if ((unsigned int const   )dc->type == 14U) {
#line 4045
    goto case_14;
  }
#line 4050
  if ((unsigned int const   )dc->type == 15U) {
#line 4050
    goto case_15;
  }
#line 4055
  if ((unsigned int const   )dc->type == 16U) {
#line 4055
    goto case_16;
  }
#line 4060
  if ((unsigned int const   )dc->type == 17U) {
#line 4060
    goto case_17;
  }
#line 4065
  if ((unsigned int const   )dc->type == 18U) {
#line 4065
    goto case_18;
  }
#line 4070
  if ((unsigned int const   )dc->type == 19U) {
#line 4070
    goto case_19;
  }
#line 4075
  if ((unsigned int const   )dc->type == 20U) {
#line 4075
    goto case_20;
  }
#line 4082
  if ((unsigned int const   )dc->type == 21U) {
#line 4082
    goto case_21;
  }
#line 4087
  if ((unsigned int const   )dc->type == 67U) {
#line 4087
    goto case_67;
  }
#line 4092
  if ((unsigned int const   )dc->type == 68U) {
#line 4092
    goto case_68;
  }
#line 4097
  if ((unsigned int const   )dc->type == 22U) {
#line 4097
    goto case_22;
  }
#line 4103
  if ((unsigned int const   )dc->type == 25U) {
#line 4103
    goto case_25;
  }
#line 4103
  if ((unsigned int const   )dc->type == 24U) {
#line 4103
    goto case_25;
  }
#line 4103
  if ((unsigned int const   )dc->type == 23U) {
#line 4103
    goto case_25;
  }
#line 4130
  if ((unsigned int const   )dc->type == 32U) {
#line 4130
    goto case_32;
  }
#line 4130
  if ((unsigned int const   )dc->type == 31U) {
#line 4130
    goto case_32;
  }
#line 4163
  if ((unsigned int const   )dc->type == 34U) {
#line 4163
    goto modifier;
  }
#line 4163
  if ((unsigned int const   )dc->type == 33U) {
#line 4163
    goto modifier;
  }
#line 4163
  if ((unsigned int const   )dc->type == 30U) {
#line 4163
    goto modifier;
  }
#line 4163
  if ((unsigned int const   )dc->type == 29U) {
#line 4163
    goto modifier;
  }
#line 4163
  if ((unsigned int const   )dc->type == 28U) {
#line 4163
    goto modifier;
  }
#line 4163
  if ((unsigned int const   )dc->type == 27U) {
#line 4163
    goto modifier;
  }
#line 4163
  if ((unsigned int const   )dc->type == 26U) {
#line 4163
    goto modifier;
  }
#line 4190
  if ((unsigned int const   )dc->type == 35U) {
#line 4190
    goto case_35;
  }
#line 4199
  if ((unsigned int const   )dc->type == 36U) {
#line 4199
    goto case_36;
  }
#line 4203
  if ((unsigned int const   )dc->type == 37U) {
#line 4203
    goto case_37;
  }
#line 4248
  if ((unsigned int const   )dc->type == 38U) {
#line 4248
    goto case_38;
  }
#line 4315
  if ((unsigned int const   )dc->type == 41U) {
#line 4315
    goto case_41;
  }
#line 4315
  if ((unsigned int const   )dc->type == 39U) {
#line 4315
    goto case_41;
  }
#line 4337
  if ((unsigned int const   )dc->type == 40U) {
#line 4337
    goto case_40;
  }
#line 4354
  if ((unsigned int const   )dc->type == 43U) {
#line 4354
    goto case_43;
  }
#line 4354
  if ((unsigned int const   )dc->type == 42U) {
#line 4354
    goto case_43;
  }
#line 4376
  if ((unsigned int const   )dc->type == 44U) {
#line 4376
    goto case_44;
  }
#line 4389
  if ((unsigned int const   )dc->type == 45U) {
#line 4389
    goto case_45;
  }
#line 4405
  if ((unsigned int const   )dc->type == 46U) {
#line 4405
    goto case_46;
  }
#line 4410
  if ((unsigned int const   )dc->type == 47U) {
#line 4410
    goto case_47;
  }
#line 4415
  if ((unsigned int const   )dc->type == 48U) {
#line 4415
    goto case_48;
  }
#line 4419
  if ((unsigned int const   )dc->type == 49U) {
#line 4419
    goto case_49;
  }
#line 4470
  if ((unsigned int const   )dc->type == 50U) {
#line 4470
    goto case_50;
  }
#line 4531
  if ((unsigned int const   )dc->type == 51U) {
#line 4531
    goto case_51;
  }
#line 4536
  if ((unsigned int const   )dc->type == 52U) {
#line 4536
    goto case_52;
  }
#line 4573
  if ((unsigned int const   )dc->type == 54U) {
#line 4573
    goto case_54;
  }
#line 4573
  if ((unsigned int const   )dc->type == 53U) {
#line 4573
    goto case_54;
  }
#line 4579
  if ((unsigned int const   )dc->type == 56U) {
#line 4579
    goto case_56;
  }
#line 4579
  if ((unsigned int const   )dc->type == 55U) {
#line 4579
    goto case_56;
  }
#line 4662
  if ((unsigned int const   )dc->type == 60U) {
#line 4662
    goto case_60;
  }
#line 4666
  if ((unsigned int const   )dc->type == 57U) {
#line 4666
    goto case_57;
  }
#line 4671
  if ((unsigned int const   )dc->type == 58U) {
#line 4671
    goto case_58;
  }
#line 4676
  if ((unsigned int const   )dc->type == 59U) {
#line 4676
    goto case_59;
  }
#line 4680
  if ((unsigned int const   )dc->type == 61U) {
#line 4680
    goto case_61;
  }
#line 4686
  if ((unsigned int const   )dc->type == 69U) {
#line 4686
    goto case_69;
  }
#line 4713
  if ((unsigned int const   )dc->type == 6U) {
#line 4713
    goto case_6___1;
  }
#line 4727
  if ((unsigned int const   )dc->type == 62U) {
#line 4727
    goto case_62;
  }
#line 4732
  if ((unsigned int const   )dc->type == 63U) {
#line 4732
    goto case_63;
  }
#line 4737
  if ((unsigned int const   )dc->type == 64U) {
#line 4737
    goto case_64;
  }
#line 4745
  if ((unsigned int const   )dc->type == 66U) {
#line 4745
    goto case_66;
  }
#line 4751
  if ((unsigned int const   )dc->type == 70U) {
#line 4751
    goto case_70;
  }
#line 4758
  goto switch_default___2;
  case_0: /* CIL Label */ 
#line 3811
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 3812
    d_append_buffer(dpi, (char const   *)dc->u.s_name.s, (size_t )dc->u.s_name.len);
    }
  } else {
    {
#line 3814
    d_print_java_identifier(dpi, (char const   *)dc->u.s_name.s, (int )dc->u.s_name.len);
    }
  }
#line 3815
  return;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 3819
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 3820
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 3821
    d_append_string(dpi, "::");
    }
  } else {
    {
#line 3823
    d_append_char(dpi, (char )'.');
    }
  }
  {
#line 3824
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 3825
  return;
  case_3: /* CIL Label */ 
#line 3838
  hold_modifiers = dpi->modifiers;
#line 3839
  dpi->modifiers = (struct d_print_mod *)0;
#line 3840
  i = 0U;
#line 3841
  typed_name = (struct demangle_component *)dc->u.s_binary.left;
  {
#line 3842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3842
    if (! ((unsigned long )typed_name != (unsigned long )((void *)0))) {
#line 3842
      goto while_break;
    }
#line 3844
    if ((unsigned long )i >= sizeof(adpm) / sizeof(adpm[0])) {
      {
#line 3846
      d_print_error(dpi);
      }
#line 3847
      return;
    }
#line 3850
    adpm[i].next = dpi->modifiers;
#line 3851
    dpi->modifiers = & adpm[i];
#line 3852
    adpm[i].mod = (struct demangle_component  const  *)typed_name;
#line 3853
    adpm[i].printed = 0;
#line 3854
    adpm[i].templates = dpi->templates;
#line 3855
    i ++;
#line 3857
    if ((unsigned int )typed_name->type != 26U) {
#line 3857
      if ((unsigned int )typed_name->type != 27U) {
#line 3857
        if ((unsigned int )typed_name->type != 28U) {
#line 3860
          goto while_break;
        }
      }
    }
#line 3862
    typed_name = typed_name->u.s_binary.left;
  }
  while_break: /* CIL Label */ ;
  }
#line 3865
  if ((unsigned long )typed_name == (unsigned long )((void *)0)) {
    {
#line 3867
    d_print_error(dpi);
    }
#line 3868
    return;
  }
#line 3873
  if ((unsigned int )typed_name->type == 4U) {
#line 3875
    dpt.next = dpi->templates;
#line 3876
    dpi->templates = & dpt;
#line 3877
    dpt.template_decl = (struct demangle_component  const  *)typed_name;
  }
#line 3884
  if ((unsigned int )typed_name->type == 2U) {
#line 3888
    local_name = typed_name->u.s_binary.right;
#line 3889
    if ((unsigned int )local_name->type == 65U) {
#line 3890
      local_name = local_name->u.s_unary_num.sub;
    }
    {
#line 3891
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3891
      if (! ((unsigned int )local_name->type == 26U)) {
#line 3891
        if (! ((unsigned int )local_name->type == 27U)) {
#line 3891
          if (! ((unsigned int )local_name->type == 28U)) {
#line 3891
            goto while_break___0;
          }
        }
      }
#line 3895
      if ((unsigned long )i >= sizeof(adpm) / sizeof(adpm[0])) {
        {
#line 3897
        d_print_error(dpi);
        }
#line 3898
        return;
      }
#line 3901
      adpm[i] = adpm[i - 1U];
#line 3902
      adpm[i].next = & adpm[i - 1U];
#line 3903
      dpi->modifiers = & adpm[i];
#line 3905
      adpm[i - 1U].mod = (struct demangle_component  const  *)local_name;
#line 3906
      adpm[i - 1U].printed = 0;
#line 3907
      adpm[i - 1U].templates = dpi->templates;
#line 3908
      i ++;
#line 3910
      local_name = local_name->u.s_binary.left;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 3914
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 3916
  if ((unsigned int )typed_name->type == 4U) {
#line 3917
    dpi->templates = dpt.next;
  }
  {
#line 3921
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3921
    if (! (i > 0U)) {
#line 3921
      goto while_break___1;
    }
#line 3923
    i --;
#line 3924
    if (! adpm[i].printed) {
      {
#line 3926
      d_append_char(dpi, (char )' ');
#line 3927
      d_print_mod(dpi, options___0, adpm[i].mod);
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3931
  dpi->modifiers = hold_modifiers;
#line 3933
  return;
  case_4: /* CIL Label */ 
#line 3945
  hold_dpm = dpi->modifiers;
#line 3946
  dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 3948
  dcl = (struct demangle_component *)dc->u.s_binary.left;
#line 3950
  if ((options___0 & (1 << 2)) != 0) {
#line 3950
    if ((unsigned int )dcl->type == 0U) {
#line 3950
      if (dcl->u.s_name.len == 6) {
        {
#line 3950
        tmp___3 = strncmp(dcl->u.s_name.s, "JArray", (size_t )6);
        }
#line 3950
        if (tmp___3 == 0) {
          {
#line 3958
          d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 3959
          d_append_string(dpi, "[]");
          }
        } else {
#line 3950
          goto _L___1;
        }
      } else {
#line 3950
        goto _L___1;
      }
    } else {
#line 3950
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 3963
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dcl);
#line 3964
    tmp___1 = d_last_char(dpi);
    }
#line 3964
    if ((int )tmp___1 == 60) {
      {
#line 3965
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 3966
    d_append_char(dpi, (char )'<');
#line 3967
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 3970
    tmp___2 = d_last_char(dpi);
    }
#line 3970
    if ((int )tmp___2 == 62) {
      {
#line 3971
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 3972
    d_append_char(dpi, (char )'>');
    }
  }
#line 3975
  dpi->modifiers = hold_dpm;
#line 3977
  return;
  case_5: /* CIL Label */ 
  {
#line 3983
  tmp___4 = d_lookup_template_argument(dpi, dc);
#line 3983
  a = tmp___4;
  }
#line 3985
  if (a) {
#line 3985
    if ((unsigned int )a->type == 43U) {
      {
#line 3986
      a = d_index_template_argument(a, dpi->pack_index);
      }
    }
  }
#line 3988
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 3990
    d_print_error(dpi);
    }
#line 3991
    return;
  }
  {
#line 3999
  hold_dpt = dpi->templates;
#line 4000
  dpi->templates = hold_dpt->next;
#line 4002
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)a);
#line 4004
  dpi->templates = hold_dpt;
  }
#line 4006
  return;
  case_7: /* CIL Label */ 
  {
#line 4010
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_ctor.name);
  }
#line 4011
  return;
  case_8: /* CIL Label */ 
  {
#line 4014
  d_append_char(dpi, (char )'~');
#line 4015
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_dtor.name);
  }
#line 4016
  return;
  case_9: /* CIL Label */ 
  {
#line 4019
  d_append_string(dpi, "vtable for ");
#line 4020
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4021
  return;
  case_10: /* CIL Label */ 
  {
#line 4024
  d_append_string(dpi, "VTT for ");
#line 4025
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4026
  return;
  case_11: /* CIL Label */ 
  {
#line 4029
  d_append_string(dpi, "construction vtable for ");
#line 4030
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4031
  d_append_string(dpi, "-in-");
#line 4032
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4033
  return;
  case_12: /* CIL Label */ 
  {
#line 4036
  d_append_string(dpi, "typeinfo for ");
#line 4037
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4038
  return;
  case_13: /* CIL Label */ 
  {
#line 4041
  d_append_string(dpi, "typeinfo name for ");
#line 4042
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4043
  return;
  case_14: /* CIL Label */ 
  {
#line 4046
  d_append_string(dpi, "typeinfo fn for ");
#line 4047
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4048
  return;
  case_15: /* CIL Label */ 
  {
#line 4051
  d_append_string(dpi, "non-virtual thunk to ");
#line 4052
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4053
  return;
  case_16: /* CIL Label */ 
  {
#line 4056
  d_append_string(dpi, "virtual thunk to ");
#line 4057
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4058
  return;
  case_17: /* CIL Label */ 
  {
#line 4061
  d_append_string(dpi, "covariant return thunk to ");
#line 4062
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4063
  return;
  case_18: /* CIL Label */ 
  {
#line 4066
  d_append_string(dpi, "java Class for ");
#line 4067
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4068
  return;
  case_19: /* CIL Label */ 
  {
#line 4071
  d_append_string(dpi, "guard variable for ");
#line 4072
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4073
  return;
  case_20: /* CIL Label */ 
  {
#line 4076
  d_append_string(dpi, "reference temporary #");
#line 4077
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4078
  d_append_string(dpi, " for ");
#line 4079
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4080
  return;
  case_21: /* CIL Label */ 
  {
#line 4083
  d_append_string(dpi, "hidden alias for ");
#line 4084
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4085
  return;
  case_67: /* CIL Label */ 
  {
#line 4088
  d_append_string(dpi, "transaction clone for ");
#line 4089
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4090
  return;
  case_68: /* CIL Label */ 
  {
#line 4093
  d_append_string(dpi, "non-transaction clone for ");
#line 4094
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4095
  return;
  case_22: /* CIL Label */ 
  {
#line 4098
  d_append_buffer(dpi, (char const   *)dc->u.s_string.string, (size_t )dc->u.s_string.len);
  }
#line 4099
  return;
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
#line 4111
  pdpm = dpi->modifiers;
  {
#line 4111
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4111
    if (! ((unsigned long )pdpm != (unsigned long )((void *)0))) {
#line 4111
      goto while_break___2;
    }
#line 4113
    if (! pdpm->printed) {
#line 4115
      if ((unsigned int const   )(pdpm->mod)->type != 23U) {
#line 4115
        if ((unsigned int const   )(pdpm->mod)->type != 24U) {
#line 4115
          if ((unsigned int const   )(pdpm->mod)->type != 25U) {
#line 4118
            goto while_break___2;
          }
        }
      }
#line 4119
      if ((unsigned int const   )(pdpm->mod)->type == (unsigned int const   )dc->type) {
        {
#line 4121
        d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
        }
#line 4122
        return;
      }
    }
#line 4111
    pdpm = pdpm->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 4127
  goto modifier;
  case_32: /* CIL Label */ 
  case_31: /* CIL Label */ 
#line 4133
  sub = (struct demangle_component  const  *)dc->u.s_binary.left;
#line 4134
  if ((unsigned int const   )sub->type == 5U) {
    {
#line 4136
    tmp___5 = d_lookup_template_argument(dpi, sub);
#line 4136
    a___0 = tmp___5;
    }
#line 4137
    if (a___0) {
#line 4137
      if ((unsigned int )a___0->type == 43U) {
        {
#line 4138
        a___0 = d_index_template_argument(a___0, dpi->pack_index);
        }
      }
    }
#line 4140
    if ((unsigned long )a___0 == (unsigned long )((void *)0)) {
      {
#line 4142
      d_print_error(dpi);
      }
#line 4143
      return;
    }
#line 4146
    sub = (struct demangle_component  const  *)a___0;
  }
#line 4149
  if ((unsigned int const   )sub->type == 31U) {
#line 4151
    dc = sub;
  } else
#line 4149
  if ((unsigned int const   )sub->type == (unsigned int const   )dc->type) {
#line 4151
    dc = sub;
  } else
#line 4152
  if ((unsigned int const   )sub->type == 32U) {
#line 4153
    mod_inner = (struct demangle_component  const  *)sub->u.s_binary.left;
  }
  modifier: 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
#line 4169
  dpm.next = dpi->modifiers;
#line 4170
  dpi->modifiers = & dpm;
#line 4171
  dpm.mod = dc;
#line 4172
  dpm.printed = 0;
#line 4173
  dpm.templates = dpi->templates;
#line 4175
  if (! mod_inner) {
#line 4176
    mod_inner = (struct demangle_component  const  *)dc->u.s_binary.left;
  }
  {
#line 4178
  d_print_comp(dpi, options___0, mod_inner);
  }
#line 4182
  if (! dpm.printed) {
    {
#line 4183
    d_print_mod(dpi, options___0, dc);
    }
  }
#line 4185
  dpi->modifiers = dpm.next;
#line 4187
  return;
  case_35: /* CIL Label */ 
#line 4191
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 4192
    d_append_buffer(dpi, (char const   *)(dc->u.s_builtin.type)->name, (size_t )(dc->u.s_builtin.type)->len);
    }
  } else {
    {
#line 4195
    d_append_buffer(dpi, (char const   *)(dc->u.s_builtin.type)->java_name, (size_t )(dc->u.s_builtin.type)->java_len);
    }
  }
#line 4197
  return;
  case_36: /* CIL Label */ 
  {
#line 4200
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4201
  return;
  case_37: /* CIL Label */ 
#line 4205
  if ((options___0 & (1 << 5)) != 0) {
    {
#line 4206
    d_print_function_type(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), dc, dpi->modifiers);
    }
  }
#line 4211
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
#line 4211
    if ((options___0 & (1 << 5)) != 0) {
      {
#line 4212
      d_print_comp(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), (struct demangle_component  const  *)dc->u.s_binary.left);
      }
    } else {
#line 4211
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 4214
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
#line 4214
    if ((options___0 & (1 << 6)) == 0) {
      {
#line 4220
      dpm___0.next = dpi->modifiers;
#line 4221
      dpi->modifiers = & dpm___0;
#line 4222
      dpm___0.mod = dc;
#line 4223
      dpm___0.printed = 0;
#line 4224
      dpm___0.templates = dpi->templates;
#line 4226
      d_print_comp(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4229
      dpi->modifiers = dpm___0.next;
      }
#line 4231
      if (dpm___0.printed) {
#line 4232
        return;
      }
#line 4236
      if ((options___0 & (1 << 5)) == 0) {
        {
#line 4237
        d_append_char(dpi, (char )' ');
        }
      }
    }
  }
#line 4240
  if ((options___0 & (1 << 5)) == 0) {
    {
#line 4241
    d_print_function_type(dpi, options___0 & ~ ((1 << 5) | (1 << 6)), dc, dpi->modifiers);
    }
  }
#line 4245
  return;
  case_38: /* CIL Label */ 
#line 4263
  hold_modifiers___0 = dpi->modifiers;
#line 4265
  adpm___0[0].next = hold_modifiers___0;
#line 4266
  dpi->modifiers = & adpm___0[0];
#line 4267
  adpm___0[0].mod = dc;
#line 4268
  adpm___0[0].printed = 0;
#line 4269
  adpm___0[0].templates = dpi->templates;
#line 4271
  i___0 = 1U;
#line 4272
  pdpm___0 = hold_modifiers___0;
  {
#line 4273
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 4273
    if ((unsigned long )pdpm___0 != (unsigned long )((void *)0)) {
#line 4273
      if (! ((unsigned int const   )(pdpm___0->mod)->type == 23U)) {
#line 4273
        if (! ((unsigned int const   )(pdpm___0->mod)->type == 24U)) {
#line 4273
          if (! ((unsigned int const   )(pdpm___0->mod)->type == 25U)) {
#line 4273
            goto while_break___3;
          }
        }
      }
    } else {
#line 4273
      goto while_break___3;
    }
#line 4278
    if (! pdpm___0->printed) {
#line 4280
      if ((unsigned long )i___0 >= sizeof(adpm___0) / sizeof(adpm___0[0])) {
        {
#line 4282
        d_print_error(dpi);
        }
#line 4283
        return;
      }
#line 4286
      adpm___0[i___0] = *pdpm___0;
#line 4287
      adpm___0[i___0].next = dpi->modifiers;
#line 4288
      dpi->modifiers = & adpm___0[i___0];
#line 4289
      pdpm___0->printed = 1;
#line 4290
      i___0 ++;
    }
#line 4293
    pdpm___0 = pdpm___0->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 4296
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4298
  dpi->modifiers = hold_modifiers___0;
  }
#line 4300
  if (adpm___0[0].printed) {
#line 4301
    return;
  }
  {
#line 4303
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 4303
    if (! (i___0 > 1U)) {
#line 4303
      goto while_break___4;
    }
    {
#line 4305
    i___0 --;
#line 4306
    d_print_mod(dpi, options___0, adpm___0[i___0].mod);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 4309
  d_print_array_type(dpi, options___0, dc, dpi->modifiers);
  }
#line 4311
  return;
  case_41: /* CIL Label */ 
  case_39: /* CIL Label */ 
  {
#line 4319
  dpm___1.next = dpi->modifiers;
#line 4320
  dpi->modifiers = & dpm___1;
#line 4321
  dpm___1.mod = dc;
#line 4322
  dpm___1.printed = 0;
#line 4323
  dpm___1.templates = dpi->templates;
#line 4325
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4329
  if (! dpm___1.printed) {
    {
#line 4330
    d_print_mod(dpi, options___0, dc);
    }
  }
#line 4332
  dpi->modifiers = dpm___1.next;
#line 4334
  return;
  case_40: /* CIL Label */ 
#line 4338
  if (dc->u.s_fixed.sat) {
    {
#line 4339
    d_append_string(dpi, "_Sat ");
    }
  }
#line 4341
  if ((unsigned long )(dc->u.s_fixed.length)->u.s_builtin.type != (unsigned long )(& cplus_demangle_builtin_types[8])) {
    {
#line 4344
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_fixed.length);
#line 4345
    d_append_char(dpi, (char )' ');
    }
  }
#line 4347
  if (dc->u.s_fixed.accum) {
    {
#line 4348
    d_append_string(dpi, "_Accum");
    }
  } else {
    {
#line 4350
    d_append_string(dpi, "_Fract");
    }
  }
#line 4351
  return;
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
#line 4355
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
    {
#line 4356
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
    }
  }
#line 4357
  if ((unsigned long )dc->u.s_binary.right != (unsigned long )((void *)0)) {
#line 4363
    if (dpi->len >= sizeof(dpi->buf) - 2UL) {
      {
#line 4364
      d_print_flush(dpi);
      }
    }
    {
#line 4365
    d_append_string(dpi, ", ");
#line 4366
    len = dpi->len;
#line 4367
    flush_count = dpi->flush_count;
#line 4368
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
    }
#line 4371
    if (dpi->flush_count == flush_count) {
#line 4371
      if (dpi->len == len) {
#line 4372
        dpi->len -= 2UL;
      }
    }
  }
#line 4374
  return;
  case_44: /* CIL Label */ 
#line 4378
  type = (struct demangle_component *)dc->u.s_binary.left;
#line 4379
  list = (struct demangle_component *)dc->u.s_binary.right;
#line 4381
  if (type) {
    {
#line 4382
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)type);
    }
  }
  {
#line 4383
  d_append_char(dpi, (char )'{');
#line 4384
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)list);
#line 4385
  d_append_char(dpi, (char )'}');
  }
#line 4387
  return;
  case_45: /* CIL Label */ 
  {
#line 4391
  op = (struct demangle_operator_info  const  *)dc->u.s_operator.op;
#line 4392
  len___0 = (int )op->len;
#line 4394
  d_append_string(dpi, "operator");
  }
#line 4396
  if ((int const   )*(op->name + 0) >= 97) {
#line 4396
    if ((int const   )*(op->name + 0) <= 122) {
      {
#line 4397
      d_append_char(dpi, (char )' ');
      }
    }
  }
#line 4399
  if ((int const   )*(op->name + (len___0 - 1)) == 32) {
#line 4400
    len___0 --;
  }
  {
#line 4401
  d_append_buffer(dpi, (char const   *)op->name, (size_t )len___0);
  }
#line 4402
  return;
  case_46: /* CIL Label */ 
  {
#line 4406
  d_append_string(dpi, "operator ");
#line 4407
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_extended_operator.name);
  }
#line 4408
  return;
  case_47: /* CIL Label */ 
  {
#line 4411
  d_append_string(dpi, "operator ");
#line 4412
  d_print_cast(dpi, options___0, dc);
  }
#line 4413
  return;
  case_48: /* CIL Label */ 
  {
#line 4416
  d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4417
  return;
  case_49: /* CIL Label */ 
#line 4421
  op___0 = (struct demangle_component *)dc->u.s_binary.left;
#line 4422
  operand = (struct demangle_component *)dc->u.s_binary.right;
#line 4423
  code = (char const   *)((void *)0);
#line 4425
  if ((unsigned int )op___0->type == 45U) {
    {
#line 4427
    code = (char const   *)(op___0->u.s_operator.op)->code;
#line 4428
    tmp___6 = strcmp(code, "ad");
    }
#line 4428
    if (! tmp___6) {
#line 4432
      if ((unsigned int )operand->type == 3U) {
#line 4432
        if ((unsigned int )(operand->u.s_binary.left)->type == 1U) {
#line 4432
          if ((unsigned int )(operand->u.s_binary.right)->type == 37U) {
#line 4435
            operand = operand->u.s_binary.left;
          }
        }
      }
    }
#line 4437
    if ((unsigned int )operand->type == 51U) {
      {
#line 4440
      operand = operand->u.s_binary.left;
#line 4441
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)operand);
#line 4442
      d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)op___0);
      }
#line 4443
      return;
    }
  }
#line 4447
  if ((unsigned int )op___0->type != 47U) {
    {
#line 4448
    d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)op___0);
    }
  } else {
    {
#line 4451
    d_append_char(dpi, (char )'(');
#line 4452
    d_print_cast(dpi, options___0, (struct demangle_component  const  *)op___0);
#line 4453
    d_append_char(dpi, (char )')');
    }
  }
#line 4455
  if (code) {
    {
#line 4455
    tmp___8 = strcmp(code, "gs");
    }
#line 4455
    if (tmp___8) {
#line 4455
      goto _L___3;
    } else {
      {
#line 4457
      d_print_comp(dpi, options___0, (struct demangle_component  const  *)operand);
      }
    }
  } else
  _L___3: /* CIL Label */ 
#line 4458
  if (code) {
    {
#line 4458
    tmp___7 = strcmp(code, "st");
    }
#line 4458
    if (tmp___7) {
      {
#line 4466
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)operand);
      }
    } else {
      {
#line 4461
      d_append_char(dpi, (char )'(');
#line 4462
      d_print_comp(dpi, options___0, (struct demangle_component  const  *)operand);
#line 4463
      d_append_char(dpi, (char )')');
      }
    }
  } else {
    {
#line 4466
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)operand);
    }
  }
#line 4468
  return;
  case_50: /* CIL Label */ 
#line 4471
  if ((unsigned int )(dc->u.s_binary.right)->type != 51U) {
    {
#line 4473
    d_print_error(dpi);
    }
#line 4474
    return;
  }
  {
#line 4477
  tmp___9 = op_is_new_cast((struct demangle_component *)dc->u.s_binary.left);
  }
#line 4477
  if (tmp___9) {
    {
#line 4479
    d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4480
    d_append_char(dpi, (char )'<');
#line 4481
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left);
#line 4482
    d_append_string(dpi, ">(");
#line 4483
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.right);
#line 4484
    d_append_char(dpi, (char )')');
    }
#line 4485
    return;
  }
#line 4491
  if ((unsigned int )(dc->u.s_binary.left)->type == 45U) {
#line 4491
    if (((dc->u.s_binary.left)->u.s_operator.op)->len == 1) {
#line 4491
      if ((int const   )*(((dc->u.s_binary.left)->u.s_operator.op)->name + 0) == 62) {
        {
#line 4494
        d_append_char(dpi, (char )'(');
        }
      }
    }
  }
  {
#line 4496
  tmp___10 = strcmp((char const   *)((dc->u.s_binary.left)->u.s_operator.op)->code,
                    "cl");
  }
#line 4496
  if (tmp___10 == 0) {
#line 4496
    if ((unsigned int )((dc->u.s_binary.right)->u.s_binary.left)->type == 3U) {
#line 4503
      func = (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left;
#line 4505
      if ((unsigned int )(func->u.s_binary.right)->type != 37U) {
        {
#line 4506
        d_print_error(dpi);
        }
      }
      {
#line 4507
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)func->u.s_binary.left);
      }
    } else {
      {
#line 4510
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left);
      }
    }
  } else {
    {
#line 4510
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.left);
    }
  }
  {
#line 4511
  tmp___12 = strcmp((char const   *)((dc->u.s_binary.left)->u.s_operator.op)->code,
                    "ix");
  }
#line 4511
  if (tmp___12 == 0) {
    {
#line 4513
    d_append_char(dpi, (char )'[');
#line 4514
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.right);
#line 4515
    d_append_char(dpi, (char )']');
    }
  } else {
    {
#line 4519
    tmp___11 = strcmp((char const   *)((dc->u.s_binary.left)->u.s_operator.op)->code,
                      "cl");
    }
#line 4519
    if (tmp___11 != 0) {
      {
#line 4520
      d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
      }
    }
    {
#line 4521
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.right)->u.s_binary.right);
    }
  }
#line 4524
  if ((unsigned int )(dc->u.s_binary.left)->type == 45U) {
#line 4524
    if (((dc->u.s_binary.left)->u.s_operator.op)->len == 1) {
#line 4524
      if ((int const   )*(((dc->u.s_binary.left)->u.s_operator.op)->name + 0) == 62) {
        {
#line 4527
        d_append_char(dpi, (char )')');
        }
      }
    }
  }
#line 4529
  return;
  case_51: /* CIL Label */ 
  {
#line 4533
  d_print_error(dpi);
  }
#line 4534
  return;
  case_52: /* CIL Label */ 
#line 4537
  if ((unsigned int )(dc->u.s_binary.right)->type != 53U) {
    {
#line 4540
    d_print_error(dpi);
    }
#line 4541
    return;
  } else
#line 4537
  if ((unsigned int )((dc->u.s_binary.right)->u.s_binary.right)->type != 54U) {
    {
#line 4540
    d_print_error(dpi);
    }
#line 4541
    return;
  }
  {
#line 4544
  op___1 = (struct demangle_component *)dc->u.s_binary.left;
#line 4545
  first = (dc->u.s_binary.right)->u.s_binary.left;
#line 4546
  second = ((dc->u.s_binary.right)->u.s_binary.right)->u.s_binary.left;
#line 4547
  third = ((dc->u.s_binary.right)->u.s_binary.right)->u.s_binary.right;
#line 4549
  tmp___13 = strcmp((char const   *)(op___1->u.s_operator.op)->code, "qu");
  }
#line 4549
  if (tmp___13) {
    {
#line 4559
    d_append_string(dpi, "new ");
    }
#line 4560
    if ((unsigned long )first->u.s_binary.left != (unsigned long )((void *)0)) {
      {
#line 4562
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)first);
#line 4563
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 4565
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)second);
    }
#line 4566
    if (third) {
      {
#line 4567
      d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)third);
      }
    }
  } else {
    {
#line 4551
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)first);
#line 4552
    d_print_expr_op(dpi, options___0, (struct demangle_component  const  *)op___1);
#line 4553
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)second);
#line 4554
    d_append_string(dpi, " : ");
#line 4555
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)third);
    }
  }
#line 4570
  return;
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  {
#line 4575
  d_print_error(dpi);
  }
#line 4576
  return;
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
#line 4584
  tp = (enum d_builtin_type_print )0;
#line 4585
  if ((unsigned int )(dc->u.s_binary.left)->type == 35U) {
#line 4587
    tp = (enum d_builtin_type_print )((dc->u.s_binary.left)->u.s_builtin.type)->print;
    {
#line 4595
    if ((unsigned int )tp == 6U) {
#line 4595
      goto case_6;
    }
#line 4595
    if ((unsigned int )tp == 5U) {
#line 4595
      goto case_6;
    }
#line 4595
    if ((unsigned int )tp == 4U) {
#line 4595
      goto case_6;
    }
#line 4595
    if ((unsigned int )tp == 3U) {
#line 4595
      goto case_6;
    }
#line 4595
    if ((unsigned int )tp == 2U) {
#line 4595
      goto case_6;
    }
#line 4595
    if ((unsigned int )tp == 1U) {
#line 4595
      goto case_6;
    }
#line 4625
    if ((unsigned int )tp == 7U) {
#line 4625
      goto case_7___0;
    }
#line 4644
    goto switch_default___1;
    case_6: /* CIL Label */ 
    case_5___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
#line 4596
    if ((unsigned int )(dc->u.s_binary.right)->type == 0U) {
#line 4598
      if ((unsigned int const   )dc->type == 56U) {
        {
#line 4599
        d_append_char(dpi, (char )'-');
        }
      }
      {
#line 4600
      d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
      }
      {
#line 4605
      if ((unsigned int )tp == 2U) {
#line 4605
        goto case_2___1;
      }
#line 4608
      if ((unsigned int )tp == 3U) {
#line 4608
        goto case_3___1;
      }
#line 4611
      if ((unsigned int )tp == 4U) {
#line 4611
        goto case_4___1;
      }
#line 4614
      if ((unsigned int )tp == 5U) {
#line 4614
        goto case_5___1;
      }
#line 4617
      if ((unsigned int )tp == 6U) {
#line 4617
        goto case_6___0;
      }
#line 4603
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 4604
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
      {
#line 4606
      d_append_char(dpi, (char )'u');
      }
#line 4607
      goto switch_break___1;
      case_3___1: /* CIL Label */ 
      {
#line 4609
      d_append_char(dpi, (char )'l');
      }
#line 4610
      goto switch_break___1;
      case_4___1: /* CIL Label */ 
      {
#line 4612
      d_append_string(dpi, "ul");
      }
#line 4613
      goto switch_break___1;
      case_5___1: /* CIL Label */ 
      {
#line 4615
      d_append_string(dpi, "ll");
      }
#line 4616
      goto switch_break___1;
      case_6___0: /* CIL Label */ 
      {
#line 4618
      d_append_string(dpi, "ull");
      }
#line 4619
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 4621
      return;
    }
#line 4623
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 4626
    if ((unsigned int )(dc->u.s_binary.right)->type == 0U) {
#line 4626
      if ((dc->u.s_binary.right)->u.s_name.len == 1) {
#line 4626
        if ((unsigned int const   )dc->type == 55U) {
          {
#line 4632
          if ((int const   )*((dc->u.s_binary.right)->u.s_name.s + 0) == 48) {
#line 4632
            goto case_48___0;
          }
#line 4635
          if ((int const   )*((dc->u.s_binary.right)->u.s_name.s + 0) == 49) {
#line 4635
            goto case_49___0;
          }
#line 4638
          goto switch_default___0;
          case_48___0: /* CIL Label */ 
          {
#line 4633
          d_append_string(dpi, "false");
          }
#line 4634
          return;
          case_49___0: /* CIL Label */ 
          {
#line 4636
          d_append_string(dpi, "true");
          }
#line 4637
          return;
          switch_default___0: /* CIL Label */ 
#line 4639
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 4642
    goto switch_break___0;
    switch_default___1: /* CIL Label */ 
#line 4645
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 4649
  d_append_char(dpi, (char )'(');
#line 4650
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4651
  d_append_char(dpi, (char )')');
  }
#line 4652
  if ((unsigned int const   )dc->type == 56U) {
    {
#line 4653
    d_append_char(dpi, (char )'-');
    }
  }
#line 4654
  if ((unsigned int )tp == 8U) {
    {
#line 4655
    d_append_char(dpi, (char )'[');
    }
  }
  {
#line 4656
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4657
  if ((unsigned int )tp == 8U) {
    {
#line 4658
    d_append_char(dpi, (char )']');
    }
  }
#line 4660
  return;
  case_60: /* CIL Label */ 
  {
#line 4663
  d_append_num(dpi, (long )dc->u.s_number.number);
  }
#line 4664
  return;
  case_57: /* CIL Label */ 
  {
#line 4667
  d_append_string(dpi, "java resource ");
#line 4668
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4669
  return;
  case_58: /* CIL Label */ 
  {
#line 4672
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4673
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
  }
#line 4674
  return;
  case_59: /* CIL Label */ 
  {
#line 4677
  d_append_char(dpi, (char )dc->u.s_character.character);
  }
#line 4678
  return;
  case_61: /* CIL Label */ 
  {
#line 4681
  d_append_string(dpi, "decltype (");
#line 4682
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4683
  d_append_char(dpi, (char )')');
  }
#line 4684
  return;
  case_69: /* CIL Label */ 
  {
#line 4690
  tmp___14 = d_find_pack(dpi, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4690
  a___1 = tmp___14;
  }
#line 4691
  if ((unsigned long )a___1 == (unsigned long )((void *)0)) {
    {
#line 4696
    d_print_subexpr(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4697
    d_append_string(dpi, "...");
    }
#line 4698
    return;
  }
  {
#line 4701
  len___1 = d_pack_length((struct demangle_component  const  *)a___1);
#line 4702
  dc = (struct demangle_component  const  *)dc->u.s_binary.left;
#line 4703
  i___1 = 0;
  }
  {
#line 4703
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 4703
    if (! (i___1 < len___1)) {
#line 4703
      goto while_break___5;
    }
    {
#line 4705
    dpi->pack_index = i___1;
#line 4706
    d_print_comp(dpi, options___0, dc);
    }
#line 4707
    if (i___1 < len___1 - 1) {
      {
#line 4708
      d_append_string(dpi, ", ");
      }
    }
#line 4703
    i___1 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 4711
  return;
  case_6___1: /* CIL Label */ 
#line 4715
  num = (long )dc->u.s_number.number;
#line 4716
  if (num == 0L) {
    {
#line 4717
    d_append_string(dpi, "this");
    }
  } else {
    {
#line 4720
    d_append_string(dpi, "{parm#");
#line 4721
    d_append_num(dpi, num);
#line 4722
    d_append_char(dpi, (char )'}');
    }
  }
#line 4725
  return;
  case_62: /* CIL Label */ 
  {
#line 4728
  d_append_string(dpi, "global constructors keyed to ");
#line 4729
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4730
  return;
  case_63: /* CIL Label */ 
  {
#line 4733
  d_append_string(dpi, "global destructors keyed to ");
#line 4734
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
  }
#line 4735
  return;
  case_64: /* CIL Label */ 
  {
#line 4738
  d_append_string(dpi, "{lambda(");
#line 4739
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_unary_num.sub);
#line 4740
  d_append_string(dpi, ")#");
#line 4741
  d_append_num(dpi, (long )(dc->u.s_unary_num.num + 1));
#line 4742
  d_append_char(dpi, (char )'}');
  }
#line 4743
  return;
  case_66: /* CIL Label */ 
  {
#line 4746
  d_append_string(dpi, "{unnamed type#");
#line 4747
  d_append_num(dpi, (long )(dc->u.s_number.number + 1L));
#line 4748
  d_append_char(dpi, (char )'}');
  }
#line 4749
  return;
  case_70: /* CIL Label */ 
  {
#line 4752
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
#line 4753
  d_append_string(dpi, " [clone ");
#line 4754
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
#line 4755
  d_append_char(dpi, (char )']');
  }
#line 4756
  return;
  switch_default___2: /* CIL Label */ 
  {
#line 4759
  d_print_error(dpi);
  }
#line 4760
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4769 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_java_identifier(struct d_print_info *dpi , char const   *name___0 ,
                                    int len ) 
{ 
  char const   *p ;
  char const   *end ;
  unsigned long c ;
  char const   *q ;
  int dig ;

  {
#line 4775
  end = name___0 + len;
#line 4776
  p = name___0;
  {
#line 4776
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4776
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 4776
      goto while_break;
    }
#line 4778
    if (end - p > 3L) {
#line 4778
      if ((int const   )*(p + 0) == 95) {
#line 4778
        if ((int const   )*(p + 1) == 95) {
#line 4778
          if ((int const   )*(p + 2) == 85) {
#line 4786
            c = 0UL;
#line 4787
            q = p + 3;
            {
#line 4787
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 4787
              if (! ((unsigned long )q < (unsigned long )end)) {
#line 4787
                goto while_break___0;
              }
#line 4791
              if ((int const   )*q >= 48) {
#line 4791
                if ((int const   )*q <= 57) {
#line 4792
                  dig = (int )((int const   )*q - 48);
                } else {
#line 4791
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 4793
              if ((int const   )*q >= 65) {
#line 4793
                if ((int const   )*q <= 70) {
#line 4794
                  dig = (int )(((int const   )*q - 65) + 10);
                } else {
#line 4793
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 4795
              if ((int const   )*q >= 97) {
#line 4795
                if ((int const   )*q <= 102) {
#line 4796
                  dig = (int )(((int const   )*q - 97) + 10);
                } else {
#line 4798
                  goto while_break___0;
                }
              } else {
#line 4798
                goto while_break___0;
              }
#line 4800
              c = c * 16UL + (unsigned long )dig;
#line 4787
              q ++;
            }
            while_break___0: /* CIL Label */ ;
            }
#line 4804
            if ((unsigned long )q < (unsigned long )end) {
#line 4804
              if ((int const   )*q == 95) {
#line 4804
                if (c < 256UL) {
                  {
#line 4806
                  d_append_char(dpi, (char )c);
#line 4807
                  p = q;
                  }
#line 4808
                  goto __Cont;
                }
              }
            }
          }
        }
      }
    }
    {
#line 4812
    d_append_char(dpi, (char )*p);
    }
    __Cont: /* CIL Label */ 
#line 4776
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4814
  return;
}
}
#line 4819 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_mod_list(struct d_print_info *dpi , int options___0 , struct d_print_mod *mods ,
                             int suffix ) 
{ 
  struct d_print_template *hold_dpt ;
  int tmp___0 ;
  struct d_print_mod *hold_modifiers ;
  struct demangle_component *dc ;

  {
#line 4825
  if ((unsigned long )mods == (unsigned long )((void *)0)) {
#line 4826
    return;
  } else {
    {
#line 4825
    tmp___0 = d_print_saw_error(dpi);
    }
#line 4825
    if (tmp___0) {
#line 4826
      return;
    }
  }
#line 4828
  if (mods->printed) {
    {
#line 4834
    d_print_mod_list(dpi, options___0, mods->next, suffix);
    }
#line 4835
    return;
  } else
#line 4828
  if (! suffix) {
#line 4828
    if ((unsigned int const   )(mods->mod)->type == 26U) {
      {
#line 4834
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4835
      return;
    } else
#line 4828
    if ((unsigned int const   )(mods->mod)->type == 27U) {
      {
#line 4834
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4835
      return;
    } else
#line 4828
    if ((unsigned int const   )(mods->mod)->type == 28U) {
      {
#line 4834
      d_print_mod_list(dpi, options___0, mods->next, suffix);
      }
#line 4835
      return;
    }
  }
#line 4838
  mods->printed = 1;
#line 4840
  hold_dpt = dpi->templates;
#line 4841
  dpi->templates = mods->templates;
#line 4843
  if ((unsigned int const   )(mods->mod)->type == 37U) {
    {
#line 4845
    d_print_function_type(dpi, options___0, mods->mod, mods->next);
#line 4846
    dpi->templates = hold_dpt;
    }
#line 4847
    return;
  } else
#line 4849
  if ((unsigned int const   )(mods->mod)->type == 38U) {
    {
#line 4851
    d_print_array_type(dpi, options___0, mods->mod, mods->next);
#line 4852
    dpi->templates = hold_dpt;
    }
#line 4853
    return;
  } else
#line 4855
  if ((unsigned int const   )(mods->mod)->type == 2U) {
    {
#line 4865
    hold_modifiers = dpi->modifiers;
#line 4866
    dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 4867
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(mods->mod)->u.s_binary.left);
#line 4868
    dpi->modifiers = hold_modifiers;
    }
#line 4870
    if ((options___0 & (1 << 2)) == 0) {
      {
#line 4871
      d_append_string(dpi, "::");
      }
    } else {
      {
#line 4873
      d_append_char(dpi, (char )'.');
      }
    }
#line 4875
    dc = (struct demangle_component *)(mods->mod)->u.s_binary.right;
#line 4877
    if ((unsigned int )dc->type == 65U) {
      {
#line 4879
      d_append_string(dpi, "{default arg#");
#line 4880
      d_append_num(dpi, (long )(dc->u.s_unary_num.num + 1));
#line 4881
      d_append_string(dpi, "}::");
#line 4882
      dc = dc->u.s_unary_num.sub;
      }
    }
    {
#line 4885
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4885
      if (! ((unsigned int )dc->type == 26U)) {
#line 4885
        if (! ((unsigned int )dc->type == 27U)) {
#line 4885
          if (! ((unsigned int )dc->type == 28U)) {
#line 4885
            goto while_break;
          }
        }
      }
#line 4888
      dc = dc->u.s_binary.left;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4890
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc);
#line 4892
    dpi->templates = hold_dpt;
    }
#line 4893
    return;
  }
  {
#line 4896
  d_print_mod(dpi, options___0, mods->mod);
#line 4898
  dpi->templates = hold_dpt;
#line 4900
  d_print_mod_list(dpi, options___0, mods->next, suffix);
  }
#line 4901
  return;
}
}
#line 4905 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_mod(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *mod ) 
{ 
  char tmp___0 ;

  {
  {
#line 4912
  if ((unsigned int const   )mod->type == 26U) {
#line 4912
    goto case_26;
  }
#line 4912
  if ((unsigned int const   )mod->type == 23U) {
#line 4912
    goto case_26;
  }
#line 4916
  if ((unsigned int const   )mod->type == 27U) {
#line 4916
    goto case_27;
  }
#line 4916
  if ((unsigned int const   )mod->type == 24U) {
#line 4916
    goto case_27;
  }
#line 4920
  if ((unsigned int const   )mod->type == 28U) {
#line 4920
    goto case_28;
  }
#line 4920
  if ((unsigned int const   )mod->type == 25U) {
#line 4920
    goto case_28;
  }
#line 4923
  if ((unsigned int const   )mod->type == 29U) {
#line 4923
    goto case_29;
  }
#line 4927
  if ((unsigned int const   )mod->type == 30U) {
#line 4927
    goto case_30;
  }
#line 4932
  if ((unsigned int const   )mod->type == 31U) {
#line 4932
    goto case_31;
  }
#line 4935
  if ((unsigned int const   )mod->type == 32U) {
#line 4935
    goto case_32;
  }
#line 4938
  if ((unsigned int const   )mod->type == 33U) {
#line 4938
    goto case_33;
  }
#line 4941
  if ((unsigned int const   )mod->type == 34U) {
#line 4941
    goto case_34;
  }
#line 4944
  if ((unsigned int const   )mod->type == 39U) {
#line 4944
    goto case_39;
  }
#line 4950
  if ((unsigned int const   )mod->type == 3U) {
#line 4950
    goto case_3;
  }
#line 4953
  if ((unsigned int const   )mod->type == 41U) {
#line 4953
    goto case_41;
  }
#line 4959
  goto switch_default;
  case_26: /* CIL Label */ 
  case_23: /* CIL Label */ 
  {
#line 4913
  d_append_string(dpi, " restrict");
  }
#line 4914
  return;
  case_27: /* CIL Label */ 
  case_24: /* CIL Label */ 
  {
#line 4917
  d_append_string(dpi, " volatile");
  }
#line 4918
  return;
  case_28: /* CIL Label */ 
  case_25: /* CIL Label */ 
  {
#line 4921
  d_append_string(dpi, " const");
  }
#line 4922
  return;
  case_29: /* CIL Label */ 
  {
#line 4924
  d_append_char(dpi, (char )' ');
#line 4925
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.right);
  }
#line 4926
  return;
  case_30: /* CIL Label */ 
#line 4929
  if ((options___0 & (1 << 2)) == 0) {
    {
#line 4930
    d_append_char(dpi, (char )'*');
    }
  }
#line 4931
  return;
  case_31: /* CIL Label */ 
  {
#line 4933
  d_append_char(dpi, (char )'&');
  }
#line 4934
  return;
  case_32: /* CIL Label */ 
  {
#line 4936
  d_append_string(dpi, "&&");
  }
#line 4937
  return;
  case_33: /* CIL Label */ 
  {
#line 4939
  d_append_string(dpi, "complex ");
  }
#line 4940
  return;
  case_34: /* CIL Label */ 
  {
#line 4942
  d_append_string(dpi, "imaginary ");
  }
#line 4943
  return;
  case_39: /* CIL Label */ 
  {
#line 4945
  tmp___0 = d_last_char(dpi);
  }
#line 4945
  if ((int )tmp___0 != 40) {
    {
#line 4946
    d_append_char(dpi, (char )' ');
    }
  }
  {
#line 4947
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.left);
#line 4948
  d_append_string(dpi, "::*");
  }
#line 4949
  return;
  case_3: /* CIL Label */ 
  {
#line 4951
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.left);
  }
#line 4952
  return;
  case_41: /* CIL Label */ 
  {
#line 4954
  d_append_string(dpi, " __vector(");
#line 4955
  d_print_comp(dpi, options___0, (struct demangle_component  const  *)mod->u.s_binary.left);
#line 4956
  d_append_char(dpi, (char )')');
  }
#line 4957
  return;
  switch_default: /* CIL Label */ 
  {
#line 4962
  d_print_comp(dpi, options___0, mod);
  }
#line 4963
  return;
  switch_break: /* CIL Label */ ;
  }
}
}
#line 4969 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_function_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                                  struct d_print_mod *mods ) 
{ 
  int need_paren ;
  int need_space ;
  struct d_print_mod *p ;
  struct d_print_mod *hold_modifiers ;
  char tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;

  {
#line 4979
  need_paren = 0;
#line 4980
  need_space = 0;
#line 4981
  p = mods;
  {
#line 4981
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4981
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 4981
      goto while_break;
    }
#line 4983
    if (p->printed) {
#line 4984
      goto while_break;
    }
    {
#line 4990
    if ((unsigned int const   )(p->mod)->type == 32U) {
#line 4990
      goto case_32;
    }
#line 4990
    if ((unsigned int const   )(p->mod)->type == 31U) {
#line 4990
      goto case_32;
    }
#line 4990
    if ((unsigned int const   )(p->mod)->type == 30U) {
#line 4990
      goto case_32;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 39U) {
#line 4999
      goto case_39;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 34U) {
#line 4999
      goto case_39;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 33U) {
#line 4999
      goto case_39;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 29U) {
#line 4999
      goto case_39;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 25U) {
#line 4999
      goto case_39;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 24U) {
#line 4999
      goto case_39;
    }
#line 4999
    if ((unsigned int const   )(p->mod)->type == 23U) {
#line 4999
      goto case_39;
    }
#line 5005
    if ((unsigned int const   )(p->mod)->type == 28U) {
#line 5005
      goto case_28;
    }
#line 5005
    if ((unsigned int const   )(p->mod)->type == 27U) {
#line 5005
      goto case_28;
    }
#line 5005
    if ((unsigned int const   )(p->mod)->type == 26U) {
#line 5005
      goto case_28;
    }
#line 5007
    goto switch_default;
    case_32: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_30: /* CIL Label */ 
#line 4991
    need_paren = 1;
#line 4992
    goto switch_break;
    case_39: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_29: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_24: /* CIL Label */ 
    case_23: /* CIL Label */ 
#line 5000
    need_space = 1;
#line 5001
    need_paren = 1;
#line 5002
    goto switch_break;
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
#line 5006
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5008
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5010
    if (need_paren) {
#line 5011
      goto while_break;
    }
#line 4981
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 5014
  if (need_paren) {
#line 5016
    if (! need_space) {
      {
#line 5018
      tmp___0 = d_last_char(dpi);
      }
#line 5018
      if ((int )tmp___0 != 40) {
        {
#line 5018
        tmp___1 = d_last_char(dpi);
        }
#line 5018
        if ((int )tmp___1 != 42) {
#line 5020
          need_space = 1;
        }
      }
    }
#line 5022
    if (need_space) {
      {
#line 5022
      tmp___2 = d_last_char(dpi);
      }
#line 5022
      if ((int )tmp___2 != 32) {
        {
#line 5023
        d_append_char(dpi, (char )' ');
        }
      }
    }
    {
#line 5024
    d_append_char(dpi, (char )'(');
    }
  }
  {
#line 5027
  hold_modifiers = dpi->modifiers;
#line 5028
  dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 5030
  d_print_mod_list(dpi, options___0, mods, 0);
  }
#line 5032
  if (need_paren) {
    {
#line 5033
    d_append_char(dpi, (char )')');
    }
  }
  {
#line 5035
  d_append_char(dpi, (char )'(');
  }
#line 5037
  if ((unsigned long )dc->u.s_binary.right != (unsigned long )((void *)0)) {
    {
#line 5038
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.right);
    }
  }
  {
#line 5040
  d_append_char(dpi, (char )')');
#line 5042
  d_print_mod_list(dpi, options___0, mods, 1);
#line 5044
  dpi->modifiers = hold_modifiers;
  }
#line 5045
  return;
}
}
#line 5049 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_array_type(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ,
                               struct d_print_mod *mods ) 
{ 
  int need_space ;
  int need_paren ;
  struct d_print_mod *p ;

  {
#line 5056
  need_space = 1;
#line 5057
  if ((unsigned long )mods != (unsigned long )((void *)0)) {
#line 5062
    need_paren = 0;
#line 5063
    p = mods;
    {
#line 5063
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5063
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 5063
        goto while_break;
      }
#line 5065
      if (! p->printed) {
#line 5067
        if ((unsigned int const   )(p->mod)->type == 38U) {
#line 5069
          need_space = 0;
#line 5070
          goto while_break;
        } else {
#line 5074
          need_paren = 1;
#line 5075
          need_space = 1;
#line 5076
          goto while_break;
        }
      }
#line 5063
      p = p->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 5081
    if (need_paren) {
      {
#line 5082
      d_append_string(dpi, " (");
      }
    }
    {
#line 5084
    d_print_mod_list(dpi, options___0, mods, 0);
    }
#line 5086
    if (need_paren) {
      {
#line 5087
      d_append_char(dpi, (char )')');
      }
    }
  }
#line 5090
  if (need_space) {
    {
#line 5091
    d_append_char(dpi, (char )' ');
    }
  }
  {
#line 5093
  d_append_char(dpi, (char )'[');
  }
#line 5095
  if ((unsigned long )dc->u.s_binary.left != (unsigned long )((void *)0)) {
    {
#line 5096
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
    }
  }
  {
#line 5098
  d_append_char(dpi, (char )']');
  }
#line 5099
  return;
}
}
#line 5103 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_expr_op(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 


  {
#line 5107
  if ((unsigned int const   )dc->type == 45U) {
    {
#line 5108
    d_append_buffer(dpi, (char const   *)(dc->u.s_operator.op)->name, (size_t )(dc->u.s_operator.op)->len);
    }
  } else {
    {
#line 5111
    d_print_comp(dpi, options___0, dc);
    }
  }
#line 5112
  return;
}
}
#line 5116 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static void d_print_cast(struct d_print_info *dpi , int options___0 , struct demangle_component  const  *dc ) 
{ 
  struct d_print_mod *hold_dpm ;
  struct d_print_template dpt ;
  char tmp___0 ;
  char tmp___1 ;

  {
#line 5120
  if ((unsigned int )(dc->u.s_binary.left)->type != 4U) {
    {
#line 5121
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)dc->u.s_binary.left);
    }
  } else {
    {
#line 5132
    hold_dpm = dpi->modifiers;
#line 5133
    dpi->modifiers = (struct d_print_mod *)((void *)0);
#line 5135
    dpt.next = dpi->templates;
#line 5136
    dpi->templates = & dpt;
#line 5137
    dpt.template_decl = (struct demangle_component  const  *)dc->u.s_binary.left;
#line 5139
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.left)->u.s_binary.left);
#line 5141
    dpi->templates = dpt.next;
#line 5143
    tmp___0 = d_last_char(dpi);
    }
#line 5143
    if ((int )tmp___0 == 60) {
      {
#line 5144
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 5145
    d_append_char(dpi, (char )'<');
#line 5146
    d_print_comp(dpi, options___0, (struct demangle_component  const  *)(dc->u.s_binary.left)->u.s_binary.right);
#line 5149
    tmp___1 = d_last_char(dpi);
    }
#line 5149
    if ((int )tmp___1 == 62) {
      {
#line 5150
      d_append_char(dpi, (char )' ');
      }
    }
    {
#line 5151
    d_append_char(dpi, (char )'>');
#line 5153
    dpi->modifiers = hold_dpm;
    }
  }
#line 5155
  return;
}
}
#line 5161 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
void cplus_demangle_init_info(char const   *mangled , int options___0 , size_t len ,
                              struct d_info *di ) 
{ 


  {
#line 5165
  di->s = mangled;
#line 5166
  di->send = mangled + len;
#line 5167
  di->options = options___0;
#line 5169
  di->n = mangled;
#line 5174
  di->num_comps = (int )(2UL * len);
#line 5175
  di->next_comp = 0;
#line 5179
  di->num_subs = (int )len;
#line 5180
  di->next_sub = 0;
#line 5181
  di->did_subs = 0;
#line 5183
  di->last_name = (struct demangle_component *)((void *)0);
#line 5185
  di->expansion = 0;
#line 5186
  return;
}
}
#line 5193 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int d_demangle_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) 
{ 
  enum __anonenum_type_117194467 type ;
  struct d_info di ;
  struct demangle_component *dc ;
  int status ;
  int tmp___0 ;
  size_t tmp___1 ;
  struct demangle_component *comps ;
  unsigned long __lengthofcomps ;
  void *tmp___2 ;
  struct demangle_component **subs ;
  unsigned long __lengthofsubs ;
  void *tmp___3 ;
  struct demangle_component *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 5209
  if ((int const   )*(mangled + 0) == 95) {
#line 5209
    if ((int const   )*(mangled + 1) == 90) {
#line 5210
      type = (enum __anonenum_type_117194467 )1;
    } else {
#line 5209
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
    {
#line 5211
    tmp___0 = strncmp(mangled, "_GLOBAL_", (size_t )8);
    }
#line 5211
    if (tmp___0 == 0) {
#line 5211
      if ((int const   )*(mangled + 8) == 46) {
#line 5211
        goto _L___3;
      } else
#line 5211
      if ((int const   )*(mangled + 8) == 95) {
#line 5211
        goto _L___3;
      } else
#line 5211
      if ((int const   )*(mangled + 8) == 36) {
        _L___3: /* CIL Label */ 
#line 5211
        if ((int const   )*(mangled + 9) == 68) {
#line 5211
          goto _L___1;
        } else
#line 5211
        if ((int const   )*(mangled + 9) == 73) {
          _L___1: /* CIL Label */ 
#line 5211
          if ((int const   )*(mangled + 10) == 95) {
#line 5215
            if ((int const   )*(mangled + 9) == 73) {
#line 5215
              type = (enum __anonenum_type_117194467 )2;
            } else {
#line 5215
              type = (enum __anonenum_type_117194467 )3;
            }
          } else {
#line 5211
            goto _L___2;
          }
        } else {
#line 5211
          goto _L___2;
        }
      } else {
#line 5211
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
#line 5218
      if ((options___0 & (1 << 4)) == 0) {
#line 5219
        return (0);
      }
#line 5220
      type = (enum __anonenum_type_117194467 )0;
    }
  }
  {
#line 5223
  tmp___1 = strlen(mangled);
#line 5223
  cplus_demangle_init_info(mangled, options___0, tmp___1, & di);
#line 5227
  __lengthofcomps = (unsigned long )di.num_comps;
#line 5227
  tmp___2 = __builtin_alloca(sizeof(*comps) * __lengthofcomps);
#line 5227
  comps = (struct demangle_component *)tmp___2;
#line 5228
  __lengthofsubs = (unsigned long )di.num_subs;
#line 5228
  tmp___3 = __builtin_alloca(sizeof(*subs) * __lengthofsubs);
#line 5228
  subs = (struct demangle_component **)tmp___3;
#line 5230
  di.comps = comps;
#line 5231
  di.subs = subs;
  }
  {
#line 5239
  if ((unsigned int )type == 0U) {
#line 5239
    goto case_0;
  }
#line 5242
  if ((unsigned int )type == 1U) {
#line 5242
    goto case_1;
  }
#line 5246
  if ((unsigned int )type == 3U) {
#line 5246
    goto case_3;
  }
#line 5246
  if ((unsigned int )type == 2U) {
#line 5246
    goto case_3;
  }
#line 5237
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 5240
  dc = cplus_demangle_type(& di);
  }
#line 5241
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 5243
  dc = cplus_demangle_mangled_name(& di, 1);
  }
#line 5244
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 5247
  di.n += 11;
#line 5248
  tmp___4 = d_make_demangle_mangled_name(& di, di.n);
  }
#line 5248
  if ((unsigned int )type == 2U) {
#line 5248
    tmp___5 = 62;
  } else {
#line 5248
    tmp___5 = 63;
  }
  {
#line 5248
  dc = d_make_comp(& di, (enum demangle_component_type )tmp___5, tmp___4, (struct demangle_component *)((void *)0));
#line 5254
  tmp___6 = strlen(di.n);
#line 5254
  di.n += tmp___6;
  }
#line 5255
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 5262
  if ((options___0 & 1) != 0) {
#line 5262
    if ((int const   )*(di.n) != 0) {
#line 5263
      dc = (struct demangle_component *)((void *)0);
    }
  }
#line 5269
  if ((unsigned long )dc != (unsigned long )((void *)0)) {
    {
#line 5269
    tmp___7 = cplus_demangle_print_callback(options___0, (struct demangle_component  const  *)dc,
                                            callback, opaque);
#line 5269
    status = tmp___7;
    }
  } else {
#line 5269
    status = 0;
  }
#line 5274
  return (status);
}
}
#line 5284 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static char *d_demangle(char const   *mangled , int options___0 , size_t *palc ) 
{ 
  struct d_growable_string dgs ;
  int status ;

  {
  {
#line 5290
  d_growable_string_init(& dgs, (size_t )0);
#line 5292
  status = d_demangle_callback(mangled, options___0, & d_growable_string_callback_adapter,
                               (void *)(& dgs));
  }
#line 5294
  if (status == 0) {
    {
#line 5296
    free((void *)dgs.buf);
#line 5297
    *palc = (size_t )0;
    }
#line 5298
    return ((char *)((void *)0));
  }
#line 5301
  if (dgs.allocation_failure) {
#line 5301
    *palc = (size_t )1;
  } else {
#line 5301
    *palc = dgs.alc;
  }
#line 5302
  return (dgs.buf);
}
}
#line 5444 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
char *cplus_demangle_v3(char const   *mangled , int options___0 ) 
{ 
  size_t alc ;
  char *tmp___0 ;

  {
  {
#line 5449
  tmp___0 = d_demangle(mangled, options___0, & alc);
  }
#line 5449
  return (tmp___0);
}
}
#line 5452 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int cplus_demangle_v3_callback(char const   *mangled , int options___0 , void (*callback)(char const   * ,
                                                                                          size_t  ,
                                                                                          void * ) ,
                               void *opaque ) 
{ 
  int tmp___0 ;

  {
  {
#line 5456
  tmp___0 = d_demangle_callback(mangled, options___0, callback, opaque);
  }
#line 5456
  return (tmp___0);
}
}
#line 5465 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
char *java_demangle_v3(char const   *mangled ) 
{ 
  size_t alc ;
  char *tmp___0 ;

  {
  {
#line 5470
  tmp___0 = d_demangle(mangled, ((1 << 2) | 1) | (1 << 5), & alc);
  }
#line 5470
  return (tmp___0);
}
}
#line 5473 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
int java_demangle_v3_callback(char const   *mangled , void (*callback)(char const   * ,
                                                                       size_t  , void * ) ,
                              void *opaque ) 
{ 
  int tmp___0 ;

  {
  {
#line 5477
  tmp___0 = d_demangle_callback(mangled, ((1 << 2) | 1) | (1 << 5), callback, opaque);
  }
#line 5477
  return (tmp___0);
}
}
#line 5490 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
static int is_ctor_or_dtor(char const   *mangled , enum gnu_v3_ctor_kinds *ctor_kind ,
                           enum gnu_v3_dtor_kinds *dtor_kind ) 
{ 
  struct d_info di ;
  struct demangle_component *dc ;
  int ret ;
  size_t tmp___0 ;
  struct demangle_component *comps ;
  unsigned long __lengthofcomps ;
  void *tmp___1 ;
  struct demangle_component **subs ;
  unsigned long __lengthofsubs ;
  void *tmp___2 ;

  {
  {
#line 5499
  *ctor_kind = (enum gnu_v3_ctor_kinds )0;
#line 5500
  *dtor_kind = (enum gnu_v3_dtor_kinds )0;
#line 5502
  tmp___0 = strlen(mangled);
#line 5502
  cplus_demangle_init_info(mangled, 1 << 14, tmp___0, & di);
#line 5506
  __lengthofcomps = (unsigned long )di.num_comps;
#line 5506
  tmp___1 = __builtin_alloca(sizeof(*comps) * __lengthofcomps);
#line 5506
  comps = (struct demangle_component *)tmp___1;
#line 5507
  __lengthofsubs = (unsigned long )di.num_subs;
#line 5507
  tmp___2 = __builtin_alloca(sizeof(*subs) * __lengthofsubs);
#line 5507
  subs = (struct demangle_component **)tmp___2;
#line 5509
  di.comps = comps;
#line 5510
  di.subs = subs;
#line 5516
  dc = cplus_demangle_mangled_name(& di, 1);
#line 5521
  ret = 0;
  }
  {
#line 5522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5522
    if (! ((unsigned long )dc != (unsigned long )((void *)0))) {
#line 5522
      goto while_break;
    }
    {
#line 5533
    if ((unsigned int )dc->type == 28U) {
#line 5533
      goto case_28;
    }
#line 5533
    if ((unsigned int )dc->type == 27U) {
#line 5533
      goto case_28;
    }
#line 5533
    if ((unsigned int )dc->type == 26U) {
#line 5533
      goto case_28;
    }
#line 5533
    if ((unsigned int )dc->type == 4U) {
#line 5533
      goto case_28;
    }
#line 5533
    if ((unsigned int )dc->type == 3U) {
#line 5533
      goto case_28;
    }
#line 5537
    if ((unsigned int )dc->type == 2U) {
#line 5537
      goto case_2;
    }
#line 5537
    if ((unsigned int )dc->type == 1U) {
#line 5537
      goto case_2;
    }
#line 5540
    if ((unsigned int )dc->type == 7U) {
#line 5540
      goto case_7;
    }
#line 5545
    if ((unsigned int )dc->type == 8U) {
#line 5545
      goto case_8;
    }
#line 5526
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 5527
    dc = (struct demangle_component *)((void *)0);
#line 5528
    goto switch_break;
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_26: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
#line 5534
    dc = dc->u.s_binary.left;
#line 5535
    goto switch_break;
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 5538
    dc = dc->u.s_binary.right;
#line 5539
    goto switch_break;
    case_7: /* CIL Label */ 
#line 5541
    *ctor_kind = dc->u.s_ctor.kind;
#line 5542
    ret = 1;
#line 5543
    dc = (struct demangle_component *)((void *)0);
#line 5544
    goto switch_break;
    case_8: /* CIL Label */ 
#line 5546
    *dtor_kind = dc->u.s_dtor.kind;
#line 5547
    ret = 1;
#line 5548
    dc = (struct demangle_component *)((void *)0);
#line 5549
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5554
  return (ret);
}
}
#line 5560 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
enum gnu_v3_ctor_kinds is_gnu_v3_mangled_ctor(char const   *name___0 ) 
{ 
  enum gnu_v3_ctor_kinds ctor_kind ;
  enum gnu_v3_dtor_kinds dtor_kind ;
  int tmp___0 ;

  {
  {
#line 5566
  tmp___0 = is_ctor_or_dtor(name___0, & ctor_kind, & dtor_kind);
  }
#line 5566
  if (! tmp___0) {
#line 5567
    return ((enum gnu_v3_ctor_kinds )0);
  }
#line 5568
  return (ctor_kind);
}
}
#line 5575 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./cp-demangle.c"
enum gnu_v3_dtor_kinds is_gnu_v3_mangled_dtor(char const   *name___0 ) 
{ 
  enum gnu_v3_ctor_kinds ctor_kind ;
  enum gnu_v3_dtor_kinds dtor_kind ;
  int tmp___0 ;

  {
  {
#line 5581
  tmp___0 = is_ctor_or_dtor(name___0, & ctor_kind, & dtor_kind);
  }
#line 5581
  if (! tmp___0) {
#line 5582
    return ((enum gnu_v3_dtor_kinds )0);
  }
#line 5583
  return (dtor_kind);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 151 "./../include/libiberty.h"
char *reconcat(char *optr , char const   *first  , ...)  __attribute__((__sentinel__,
__malloc__)) ;
#line 157
unsigned long concat_length(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 164
char *concat_copy(char *dst , char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 171
char *concat_copy2(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 175 "./../include/libiberty.h"
char *libiberty_concat_ptr  ;
#line 69 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
__inline static unsigned long vconcat_length(char const   *first , va_list args ) ;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
__inline static unsigned long vconcat_length(char const   *first , va_list args ) 
{ 
  unsigned long length ;
  char const   *arg ;
  char const   *tmp___0 ;
  size_t tmp___1 ;

  {
#line 73
  length = 0UL;
#line 76
  arg = first;
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! arg) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___1 = strlen(arg);
#line 77
    length += tmp___1;
#line 76
    tmp___0 = __builtin_va_arg(args, char const   *);
#line 76
    arg = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return (length);
}
}
#line 82 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
__inline static char *vconcat_copy(char *dst , char const   *first , va_list args ) 
{ 
  char *end ;
  char const   *arg ;
  char const   *tmp___0 ;
  unsigned long length ;
  size_t tmp___1 ;

  {
#line 85
  end = dst;
#line 88
  arg = first;
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! arg) {
#line 88
      goto while_break;
    }
    {
#line 90
    tmp___1 = strlen(arg);
#line 90
    length = tmp___1;
#line 91
    memcpy((void */* __restrict  */)end, (void const   */* __restrict  */)arg, length);
#line 92
    end += length;
#line 88
    tmp___0 = __builtin_va_arg(args, char const   *);
#line 88
    arg = tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 94
  *end = (char )'\000';
#line 96
  return (dst);
}
}
#line 101
unsigned long concat_length(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 101 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
unsigned long concat_length(char const   *first  , ...) 
{ 
  unsigned long length ;
  va_list args ;

  {
  {
#line 106
  __builtin_va_start(args, first);
#line 108
  length = vconcat_length(first, args);
#line 109
  __builtin_va_end(args);
  }
#line 111
  return (length);
}
}
#line 116
char *concat_copy(char *dst , char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 116 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
char *concat_copy(char *dst , char const   *first  , ...) 
{ 
  char *save_dst ;
  va_list args ;

  {
  {
#line 121
  __builtin_va_start(args, first);
#line 124
  vconcat_copy(dst, first, args);
#line 125
  save_dst = dst;
#line 126
  __builtin_va_end(args);
  }
#line 128
  return (save_dst);
}
}
#line 141
char *concat_copy2(char const   *first  , ...)  __attribute__((__sentinel__)) ;
#line 141 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
char *concat_copy2(char const   *first  , ...) 
{ 
  va_list args ;

  {
  {
#line 144
  __builtin_va_start(args, first);
#line 146
  vconcat_copy(libiberty_concat_ptr, first, args);
#line 147
  __builtin_va_end(args);
  }
#line 149
  return (libiberty_concat_ptr);
}
}
#line 152
char *concat(char const   *first  , ...)  __attribute__((__sentinel__, __malloc__)) ;
#line 152 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
char *concat(char const   *first  , ...) 
{ 
  char *newstr ;
  va_list args ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  va_list args___0 ;

  {
  {
#line 158
  __builtin_va_start(args, first);
#line 160
  tmp___0 = vconcat_length(first, args);
#line 160
  tmp___1 = xmalloc(sizeof(char ) * (tmp___0 + 1UL));
#line 160
  newstr = (char *)tmp___1;
#line 161
  __builtin_va_end(args);
#line 164
  __builtin_va_start(args___0, first);
#line 166
  vconcat_copy(newstr, first, args___0);
#line 167
  __builtin_va_end(args___0);
  }
#line 169
  return (newstr);
}
}
#line 190
char *reconcat(char *optr , char const   *first  , ...)  __attribute__((__sentinel__,
__malloc__)) ;
#line 190 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./concat.c"
char *reconcat(char *optr , char const   *first  , ...) 
{ 
  char *newstr ;
  va_list args ;
  unsigned long tmp___0 ;
  void *tmp___1 ;
  va_list args___0 ;

  {
  {
#line 196
  __builtin_va_start(args, first);
#line 199
  tmp___0 = vconcat_length(first, args);
#line 199
  tmp___1 = xmalloc(sizeof(char ) * (tmp___0 + 1UL));
#line 199
  newstr = (char *)tmp___1;
#line 200
  __builtin_va_end(args);
#line 203
  __builtin_va_start(args___0, first);
#line 206
  vconcat_copy(newstr, first, args___0);
  }
#line 207
  if (optr) {
    {
#line 208
    free((void *)optr);
    }
  }
  {
#line 209
  __builtin_va_end(args___0);
  }
#line 211
  return (newstr);
}
}
#line 672 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mktemp)(char *__template ) ;
#line 229 "./../include/libiberty.h"
char *choose_temp_base(void)  __attribute__((__malloc__)) ;
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./choose-temp.c"
char *choose_temp_base(void)  __attribute__((__malloc__)) ;
#line 60 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./choose-temp.c"
char *choose_temp_base(void) 
{ 
  char const   *base ;
  char *tmp___0 ;
  char *temp_filename ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 63
  tmp___0 = choose_tmpdir();
#line 63
  base = (char const   *)tmp___0;
#line 67
  tmp___1 = strlen(base);
#line 67
  len = (int )tmp___1;
#line 68
  tmp___2 = xmalloc(sizeof(char ) * (((unsigned long )len + (sizeof("ccXXXXXX") - 1UL)) + 1UL));
#line 68
  temp_filename = (char *)tmp___2;
#line 69
  strcpy((char */* __restrict  */)temp_filename, (char const   */* __restrict  */)base);
#line 70
  strcpy((char */* __restrict  */)(temp_filename + len), (char const   */* __restrict  */)"ccXXXXXX");
#line 72
  tmp___3 = mktemp(temp_filename);
  }
#line 72
  if ((unsigned long )tmp___3 == (unsigned long )((char *)0)) {
    {
#line 73
    abort();
    }
  }
#line 74
  return (temp_filename);
}
}
#line 626 "/usr/include/stdio.h"
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 684
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 689
extern long ftell(FILE *__stream ) ;
#line 75 "./../include/libiberty.h"
char **buildargv(char const   *input )  __attribute__((__malloc__)) ;
#line 79
void freeargv(char **vector ) ;
#line 84
char **dupargv(char **argv )  __attribute__((__malloc__)) ;
#line 88
void expandargv(int *argcp , char ***argvp ) ;
#line 92
int writeargv(char **argv , FILE *f ) ;
#line 96
int countargv(char **argv ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
char **dupargv(char **argv )  __attribute__((__malloc__)) ;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
char **dupargv(char **argv ) 
{ 
  int argc ;
  char **copy ;
  void *tmp___0 ;
  int len ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 70
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 71
    return ((char **)((void *)0));
  }
#line 74
  argc = 0;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 74
      goto while_break;
    }
#line 74
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  tmp___0 = malloc((unsigned long )(argc + 1) * sizeof(char *));
#line 75
  copy = (char **)tmp___0;
  }
#line 76
  if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 77
    return ((char **)((void *)0));
  }
#line 80
  argc = 0;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 80
      goto while_break___0;
    }
    {
#line 82
    tmp___1 = strlen((char const   *)*(argv + argc));
#line 82
    len = (int )tmp___1;
#line 83
    tmp___2 = malloc((size_t )(len + 1));
#line 83
    *(copy + argc) = (char *)tmp___2;
    }
#line 84
    if ((unsigned long )*(copy + argc) == (unsigned long )((void *)0)) {
      {
#line 86
      freeargv(copy);
      }
#line 87
      return ((char **)((void *)0));
    }
    {
#line 89
    strcpy((char */* __restrict  */)*(copy + argc), (char const   */* __restrict  */)*(argv + argc));
#line 80
    argc ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  *(copy + argc) = (char *)((void *)0);
#line 92
  return (copy);
}
}
#line 108 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
void freeargv(char **vector ) 
{ 
  register char **scan ;

  {
#line 112
  if ((unsigned long )vector != (unsigned long )((void *)0)) {
#line 114
    scan = vector;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! ((unsigned long )*scan != (unsigned long )((void *)0))) {
#line 114
        goto while_break;
      }
      {
#line 116
      free((void *)*scan);
#line 114
      scan ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 118
    free((void *)vector);
    }
  }
#line 120
  return;
}
}
#line 122 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
static void consume_whitespace(char const   **input ) 
{ 


  {
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! ((int const   )_sch_istable[(int const   )*(*input) & 255] & 64)) {
#line 125
      goto while_break;
    }
#line 127
    (*input) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
static int only_whitespace(char const   *input ) 
{ 


  {
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if ((int const   )*input != 0) {
#line 134
      if (! ((int const   )_sch_istable[(int const   )*input & 255] & 64)) {
#line 134
        goto while_break;
      }
    } else {
#line 134
      goto while_break;
    }
#line 135
    input ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return ((int const   )*input == 0);
}
}
#line 180
char **buildargv(char const   *input )  __attribute__((__malloc__)) ;
#line 180 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
char **buildargv(char const   *input ) 
{ 
  char *arg ;
  char *copybuf ;
  int squote ;
  int dquote ;
  int bsquote ;
  int argc ;
  int maxargc ;
  char **argv ;
  char **nargv ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 184
  squote = 0;
#line 185
  dquote = 0;
#line 186
  bsquote = 0;
#line 187
  argc = 0;
#line 188
  maxargc = 0;
#line 189
  argv = (char **)((void *)0);
#line 192
  if ((unsigned long )input != (unsigned long )((void *)0)) {
    {
#line 194
    tmp___0 = strlen(input);
#line 194
    tmp___1 = __builtin_alloca(tmp___0 + 1UL);
#line 194
    copybuf = (char *)tmp___1;
    }
    {
#line 197
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 200
      consume_whitespace(& input);
      }
#line 202
      if (maxargc == 0) {
#line 202
        goto _L;
      } else
#line 202
      if (argc >= maxargc - 1) {
        _L: /* CIL Label */ 
#line 205
        if ((unsigned long )argv == (unsigned long )((void *)0)) {
          {
#line 207
          maxargc = 8;
#line 208
          tmp___2 = malloc((unsigned long )maxargc * sizeof(char *));
#line 208
          nargv = (char **)tmp___2;
          }
        } else {
          {
#line 212
          maxargc *= 2;
#line 213
          tmp___3 = realloc((void *)argv, (unsigned long )maxargc * sizeof(char *));
#line 213
          nargv = (char **)tmp___3;
          }
        }
#line 215
        if ((unsigned long )nargv == (unsigned long )((void *)0)) {
#line 217
          if ((unsigned long )argv != (unsigned long )((void *)0)) {
            {
#line 219
            freeargv(argv);
#line 220
            argv = (char **)((void *)0);
            }
          }
#line 222
          goto while_break;
        }
#line 224
        argv = nargv;
#line 225
        *(argv + argc) = (char *)((void *)0);
      }
#line 228
      arg = copybuf;
      {
#line 229
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 229
        if (! ((int const   )*input != 0)) {
#line 229
          goto while_break___0;
        }
#line 231
        if ((int const   )_sch_istable[(int const   )*input & 255] & 64) {
#line 231
          if (! squote) {
#line 231
            if (! dquote) {
#line 231
              if (! bsquote) {
#line 233
                goto while_break___0;
              } else {
#line 231
                goto _L___2;
              }
            } else {
#line 231
              goto _L___2;
            }
          } else {
#line 231
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 237
          if (bsquote) {
#line 239
            bsquote = 0;
#line 240
            tmp___4 = arg;
#line 240
            arg ++;
#line 240
            *tmp___4 = (char )*input;
          } else
#line 242
          if ((int const   )*input == 92) {
#line 244
            bsquote = 1;
          } else
#line 246
          if (squote) {
#line 248
            if ((int const   )*input == 39) {
#line 250
              squote = 0;
            } else {
#line 254
              tmp___5 = arg;
#line 254
              arg ++;
#line 254
              *tmp___5 = (char )*input;
            }
          } else
#line 257
          if (dquote) {
#line 259
            if ((int const   )*input == 34) {
#line 261
              dquote = 0;
            } else {
#line 265
              tmp___6 = arg;
#line 265
              arg ++;
#line 265
              *tmp___6 = (char )*input;
            }
          } else
#line 270
          if ((int const   )*input == 39) {
#line 272
            squote = 1;
          } else
#line 274
          if ((int const   )*input == 34) {
#line 276
            dquote = 1;
          } else {
#line 280
            tmp___7 = arg;
#line 280
            arg ++;
#line 280
            *tmp___7 = (char )*input;
          }
#line 283
          input ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 286
      *arg = (char )'\000';
#line 287
      *(argv + argc) = strdup((char const   *)copybuf);
      }
#line 288
      if ((unsigned long )*(argv + argc) == (unsigned long )((void *)0)) {
        {
#line 290
        freeargv(argv);
#line 291
        argv = (char **)((void *)0);
        }
#line 292
        goto while_break;
      }
      {
#line 294
      argc ++;
#line 295
      *(argv + argc) = (char *)((void *)0);
#line 297
      consume_whitespace(& input);
      }
#line 197
      if (! ((int const   )*input != 0)) {
#line 197
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 301
  return (argv);
}
}
#line 316 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
int writeargv(char **argv , FILE *f ) 
{ 
  int status ;
  char const   *arg ;
  char c ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 319
  status = 0;
#line 321
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 322
    return (1);
  }
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! ((unsigned long )*argv != (unsigned long )((void *)0))) {
#line 324
      goto while_break;
    }
#line 326
    arg = (char const   *)*argv;
    {
#line 328
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 328
      if (! ((int const   )*arg != 0)) {
#line 328
        goto while_break___0;
      }
#line 330
      c = (char )*arg;
#line 332
      if ((int const   )_sch_istable[(int )c & 255] & 64) {
#line 332
        goto _L;
      } else
#line 332
      if ((int )c == 92) {
#line 332
        goto _L;
      } else
#line 332
      if ((int )c == 39) {
#line 332
        goto _L;
      } else
#line 332
      if ((int )c == 34) {
        _L: /* CIL Label */ 
        {
#line 333
        tmp___0 = fputc('\\', f);
        }
#line 333
        if (-1 == tmp___0) {
#line 335
          status = 1;
#line 336
          goto done;
        }
      }
      {
#line 339
      tmp___1 = fputc((int )c, f);
      }
#line 339
      if (-1 == tmp___1) {
#line 341
        status = 1;
#line 342
        goto done;
      }
#line 344
      arg ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 347
    tmp___2 = fputc('\n', f);
    }
#line 347
    if (-1 == tmp___2) {
#line 349
      status = 1;
#line 350
      goto done;
    }
#line 352
    argv ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 356
  return (status);
}
}
#line 382 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
void expandargv(int *argcp , char ***argvp ) 
{ 
  int i ;
  int argv_dynamic ;
  unsigned int iteration_limit ;
  char const   *filename ;
  FILE *f ;
  long pos ;
  size_t len ;
  char *buffer___2 ;
  char **file_argv ;
  size_t file_argc ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
#line 386
  i = 0;
#line 388
  argv_dynamic = 0;
#line 391
  iteration_limit = 2000U;
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    i ++;
#line 394
    if (! (i < *argcp)) {
#line 394
      goto while_break;
    }
#line 415
    filename = (char const   *)*(*argvp + i);
#line 416
    if ((int const   )*(filename + 0) != 64) {
#line 417
      goto while_continue;
    }
#line 419
    iteration_limit --;
#line 419
    if (iteration_limit == 0U) {
      {
#line 421
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: error: too many @-files encountered\n",
              *(*argvp + 0));
#line 422
      xexit(1);
      }
    }
    {
#line 425
    filename ++;
#line 425
    f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
#line 426
    if (! f) {
#line 427
      goto while_continue;
    }
    {
#line 428
    tmp___0 = fseek(f, 0L, 2);
    }
#line 428
    if (tmp___0 == -1) {
#line 429
      goto error;
    }
    {
#line 430
    pos = ftell(f);
    }
#line 431
    if (pos == -1L) {
#line 432
      goto error;
    }
    {
#line 433
    tmp___1 = fseek(f, 0L, 0);
    }
#line 433
    if (tmp___1 == -1) {
#line 434
      goto error;
    }
    {
#line 435
    tmp___2 = xmalloc((unsigned long )pos * sizeof(char ) + 1UL);
#line 435
    buffer___2 = (char *)tmp___2;
#line 436
    len = fread((void */* __restrict  */)buffer___2, sizeof(char ), (size_t )pos,
                (FILE */* __restrict  */)f);
    }
#line 437
    if (len != (size_t )pos) {
      {
#line 437
      tmp___3 = ferror(f);
      }
#line 437
      if (tmp___3) {
#line 442
        goto error;
      }
    }
    {
#line 444
    *(buffer___2 + len) = (char )'\000';
#line 448
    tmp___5 = only_whitespace((char const   *)buffer___2);
    }
#line 448
    if (tmp___5) {
      {
#line 450
      tmp___4 = xmalloc(sizeof(char *));
#line 450
      file_argv = (char **)tmp___4;
#line 451
      *(file_argv + 0) = (char *)((void *)0);
      }
    } else {
      {
#line 455
      file_argv = buildargv((char const   *)buffer___2);
      }
    }
#line 457
    if (! argv_dynamic) {
      {
#line 459
      *argvp = dupargv(*argvp);
      }
#line 460
      if (! *argvp) {
        {
#line 462
        fputs((char const   */* __restrict  */)"\nout of memory\n", (FILE */* __restrict  */)stderr);
#line 463
        xexit(1);
        }
      }
    }
#line 467
    file_argc = (size_t )0;
    {
#line 468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 468
      if (! *(file_argv + file_argc)) {
#line 468
        goto while_break___0;
      }
#line 469
      file_argc ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 472
    tmp___6 = xrealloc((void *)*argvp, (((size_t )*argcp + file_argc) + 1UL) * sizeof(char *));
#line 472
    *argvp = (char **)tmp___6;
#line 475
    memmove((void *)((*argvp + i) + file_argc), (void const   *)((*argvp + i) + 1),
            (unsigned long )(*argcp - i) * sizeof(char *));
#line 477
    memcpy((void */* __restrict  */)(*argvp + i), (void const   */* __restrict  */)file_argv,
           file_argc * sizeof(char *));
#line 480
    *argcp = (int )((size_t )*argcp + (file_argc - 1UL));
#line 484
    free((void *)file_argv);
#line 485
    free((void *)buffer___2);
#line 488
    i --;
    }
    error: 
    {
#line 491
    fclose(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 493
  return;
}
}
#line 506 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./argv.c"
int countargv(char **argv ) 
{ 
  int argc ;

  {
#line 511
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
#line 512
    return (0);
  }
#line 513
  argc = 0;
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if (! ((unsigned long )*(argv + argc) != (unsigned long )((void *)0))) {
#line 513
      goto while_break;
    }
#line 514
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 513
    argc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 515
  return (argc);
}
}
#line 655 "./../include/libiberty.h"
void *C_alloca(size_t size )  __attribute__((__malloc__)) ;
#line 63 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
char const   *libiberty_optr  ;
#line 64 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
char *libiberty_nptr  ;
#line 65 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
unsigned long libiberty_len  ;
#line 150 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
static header *last_alloca_header  =    (header *)((void *)0);
#line 161
void *C_alloca(size_t size )  __attribute__((__malloc__)) ;
#line 161 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/libiberty/./alloca.c"
void *C_alloca(size_t size ) 
{ 
  char probe ;
  register char *depth ;
  register header *hp ;
  register header *np ;
  register void *new_storage ;
  void *tmp___0 ;

  {
#line 165
  depth = & probe;
#line 178
  hp = last_alloca_header;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned long )hp != (unsigned long )((void *)0))) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )hp->h.deep < (unsigned long )depth) {
      {
#line 182
      np = hp->h.next;
#line 184
      free((void *)hp);
#line 186
      hp = np;
      }
    } else {
#line 189
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  last_alloca_header = hp;
#line 194
  if (size == 0UL) {
#line 195
    return ((void *)0);
  }
  {
#line 200
  tmp___0 = xmalloc(sizeof(char ) * (sizeof(header ) + size));
#line 200
  new_storage = (void *)((char *)tmp___0);
  }
#line 203
  if ((unsigned long )new_storage == (unsigned long )((void *)0)) {
    {
#line 204
    abort();
    }
  }
#line 206
  ((header *)new_storage)->h.next = last_alloca_header;
#line 207
  ((header *)new_storage)->h.deep = depth;
#line 209
  last_alloca_header = (header *)new_storage;
#line 213
  return ((void *)((char *)new_storage + sizeof(header )));
}
}
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 61 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/bucomm.h"
char *program_name ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.h"
void ( /* format attribute */ __attribute__((__nonnull__(1))) error)(char const   *message 
                                                                     , ...) ;
#line 31
void ( /* format attribute */ __attribute__((__nonnull__(1))) warn)(char const   *message 
                                                                    , ...) ;
#line 42 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.h"
void (*byte_put)(unsigned char * , elf_vma  , int  )  ;
#line 43
void byte_put_little_endian(unsigned char *field , elf_vma value , int size ) ;
#line 44
void byte_put_big_endian(unsigned char *field , elf_vma value , int size ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.h"
elf_vma (*byte_get)(unsigned char * , int  )  ;
#line 47
elf_vma byte_get_signed(unsigned char *field , int size ) ;
#line 48
elf_vma byte_get_little_endian(unsigned char *field , int size ) ;
#line 49
elf_vma byte_get_big_endian(unsigned char *field , int size ) ;
#line 50
void byte_get_64(unsigned char *field , elf_vma *high , elf_vma *low ) ;
#line 81
char *adjust_relative_path(char const   *file_name , char const   *name___0 , int name_len ) ;
#line 84
int setup_archive(struct archive_info *arch , char const   *file_name , FILE *file ,
                  bfd_boolean is_thin_archive , bfd_boolean read_symbols ) ;
#line 88
int setup_nested_archive(struct archive_info *nested_arch , char const   *member_file_name ) ;
#line 91
void release_archive(struct archive_info *arch ) ;
#line 95
char *get_archive_member_name(struct archive_info *arch , struct archive_info *nested_arch ) ;
#line 101
char *get_archive_member_name_at(struct archive_info *arch , unsigned long offset ,
                                 struct archive_info *nested_arch ) ;
#line 108
char *make_qualified_name(struct archive_info *arch , struct archive_info *nested_arch ,
                          char const   *member_name ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 34 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
void ( /* format attribute */ __attribute__((__nonnull__(1))) error)(char const   *message 
                                                                     , ...) 
{ 
  va_list args ;
  char *tmp___0 ;

  {
  {
#line 39
  __builtin_va_start(args, message);
#line 40
  tmp___0 = gettext("%s: Error: ");
#line 40
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          program_name);
#line 41
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 42
  __builtin_va_end(args);
  }
#line 43
  return;
}
}
#line 45 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
void ( /* format attribute */ __attribute__((__nonnull__(1))) warn)(char const   *message 
                                                                    , ...) 
{ 
  va_list args ;
  char *tmp___0 ;

  {
  {
#line 50
  __builtin_va_start(args, message);
#line 51
  tmp___0 = gettext("%s: Warning: ");
#line 51
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
          program_name);
#line 52
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)message,
           args);
#line 53
  __builtin_va_end(args);
  }
#line 54
  return;
}
}
#line 58 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
void byte_put_little_endian(unsigned char *field , elf_vma value , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 63
  if (size == 8) {
#line 63
    goto case_8;
  }
#line 69
  if (size == 4) {
#line 69
    goto case_4;
  }
#line 72
  if (size == 3) {
#line 72
    goto case_3;
  }
#line 75
  if (size == 2) {
#line 75
    goto case_2;
  }
#line 78
  if (size == 1) {
#line 78
    goto case_1;
  }
#line 82
  goto switch_default;
  case_8: /* CIL Label */ 
#line 64
  *(field + 7) = (unsigned char )((((value >> 24) >> 24) >> 8) & 255ULL);
#line 65
  *(field + 6) = (unsigned char )(((value >> 24) >> 24) & 255ULL);
#line 66
  *(field + 5) = (unsigned char )(((value >> 24) >> 16) & 255ULL);
#line 67
  *(field + 4) = (unsigned char )(((value >> 24) >> 8) & 255ULL);
  case_4: /* CIL Label */ 
#line 70
  *(field + 3) = (unsigned char )((value >> 24) & 255ULL);
  case_3: /* CIL Label */ 
#line 73
  *(field + 2) = (unsigned char )((value >> 16) & 255ULL);
  case_2: /* CIL Label */ 
#line 76
  *(field + 1) = (unsigned char )((value >> 8) & 255ULL);
  case_1: /* CIL Label */ 
#line 79
  *(field + 0) = (unsigned char )(value & 255ULL);
#line 80
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 83
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 83
  error((char const   *)tmp___0, size);
#line 84
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
void byte_put_big_endian(unsigned char *field , elf_vma value , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 93
  if (size == 8) {
#line 93
    goto case_8;
  }
#line 101
  if (size == 4) {
#line 101
    goto case_4;
  }
#line 105
  if (size == 3) {
#line 105
    goto case_3;
  }
#line 109
  if (size == 2) {
#line 109
    goto case_2;
  }
#line 113
  if (size == 1) {
#line 113
    goto case_1;
  }
#line 117
  goto switch_default;
  case_8: /* CIL Label */ 
#line 94
  *(field + 7) = (unsigned char )(value & 255ULL);
#line 95
  *(field + 6) = (unsigned char )((value >> 8) & 255ULL);
#line 96
  *(field + 5) = (unsigned char )((value >> 16) & 255ULL);
#line 97
  *(field + 4) = (unsigned char )((value >> 24) & 255ULL);
#line 98
  value >>= 16;
#line 99
  value >>= 16;
  case_4: /* CIL Label */ 
#line 102
  *(field + 3) = (unsigned char )(value & 255ULL);
#line 103
  value >>= 8;
  case_3: /* CIL Label */ 
#line 106
  *(field + 2) = (unsigned char )(value & 255ULL);
#line 107
  value >>= 8;
  case_2: /* CIL Label */ 
#line 110
  *(field + 1) = (unsigned char )(value & 255ULL);
#line 111
  value >>= 8;
  case_1: /* CIL Label */ 
#line 114
  *(field + 0) = (unsigned char )(value & 255ULL);
#line 115
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 118
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 118
  error((char const   *)tmp___0, size);
#line 119
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 121
  return;
}
}
#line 125 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
elf_vma byte_get_little_endian(unsigned char *field , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 130
  if (size == 1) {
#line 130
    goto case_1;
  }
#line 133
  if (size == 2) {
#line 133
    goto case_2;
  }
#line 137
  if (size == 3) {
#line 137
    goto case_3;
  }
#line 142
  if (size == 4) {
#line 142
    goto case_4;
  }
#line 148
  if (size == 8) {
#line 148
    goto case_8;
  }
#line 167
  goto switch_default;
  case_1: /* CIL Label */ 
#line 131
  return ((elf_vma )*field);
  case_2: /* CIL Label */ 
#line 134
  return ((elf_vma )((unsigned int )*(field + 0) | ((unsigned int )*(field + 1) << 8)));
  case_3: /* CIL Label */ 
#line 138
  return ((elf_vma )(((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)));
  case_4: /* CIL Label */ 
#line 143
  return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  case_8: /* CIL Label */ 
#line 149
  if (sizeof(elf_vma ) == 8UL) {
#line 150
    return ((((((((elf_vma )*(field + 0) | ((elf_vma )*(field + 1) << 8)) | ((elf_vma )*(field + 2) << 16)) | ((elf_vma )*(field + 3) << 24)) | ((elf_vma )*(field + 4) << 32)) | ((elf_vma )*(field + 5) << 40)) | ((elf_vma )*(field + 6) << 48)) | ((elf_vma )*(field + 7) << 56));
  } else
#line 158
  if (sizeof(elf_vma ) == 4UL) {
#line 162
    return ((elf_vma )((((unsigned long )*(field + 0) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 2) << 16)) | ((unsigned long )*(field + 3) << 24)));
  }
  switch_default: /* CIL Label */ 
  {
#line 168
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 168
  error((char const   *)tmp___0, size);
#line 169
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 173 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
elf_vma byte_get_big_endian(unsigned char *field , int size ) 
{ 
  char *tmp___0 ;

  {
  {
#line 178
  if (size == 1) {
#line 178
    goto case_1;
  }
#line 181
  if (size == 2) {
#line 181
    goto case_2;
  }
#line 184
  if (size == 3) {
#line 184
    goto case_3;
  }
#line 189
  if (size == 4) {
#line 189
    goto case_4;
  }
#line 195
  if (size == 8) {
#line 195
    goto case_8;
  }
#line 216
  goto switch_default;
  case_1: /* CIL Label */ 
#line 179
  return ((elf_vma )*field);
  case_2: /* CIL Label */ 
#line 182
  return ((elf_vma )((unsigned int )*(field + 1) | (unsigned int )((int )*(field + 0) << 8)));
  case_3: /* CIL Label */ 
#line 185
  return ((elf_vma )(((unsigned long )*(field + 2) | ((unsigned long )*(field + 1) << 8)) | ((unsigned long )*(field + 0) << 16)));
  case_4: /* CIL Label */ 
#line 190
  return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  case_8: /* CIL Label */ 
#line 196
  if (sizeof(elf_vma ) == 8UL) {
#line 197
    return ((((((((elf_vma )*(field + 7) | ((elf_vma )*(field + 6) << 8)) | ((elf_vma )*(field + 5) << 16)) | ((elf_vma )*(field + 4) << 24)) | ((elf_vma )*(field + 3) << 32)) | ((elf_vma )*(field + 2) << 40)) | ((elf_vma )*(field + 1) << 48)) | ((elf_vma )*(field + 0) << 56));
  } else
#line 205
  if (sizeof(elf_vma ) == 4UL) {
#line 209
    field += 4;
#line 210
    return ((elf_vma )((((unsigned long )*(field + 3) | ((unsigned long )*(field + 2) << 8)) | ((unsigned long )*(field + 1) << 16)) | ((unsigned long )*(field + 0) << 24)));
  }
  switch_default: /* CIL Label */ 
  {
#line 217
  tmp___0 = gettext("Unhandled data length: %d\n");
#line 217
  error((char const   *)tmp___0, size);
#line 218
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 222 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
elf_vma byte_get_signed(unsigned char *field , int size ) 
{ 
  elf_vma x ;
  elf_vma tmp___0 ;

  {
  {
#line 225
  tmp___0 = (*byte_get)(field, size);
#line 225
  x = tmp___0;
  }
  {
#line 229
  if (size == 1) {
#line 229
    goto case_1;
  }
#line 231
  if (size == 2) {
#line 231
    goto case_2;
  }
#line 233
  if (size == 4) {
#line 233
    goto case_4;
  }
#line 235
  if (size == 8) {
#line 235
    goto case_8;
  }
#line 237
  goto switch_default;
  case_1: /* CIL Label */ 
#line 230
  return ((x ^ 128ULL) - 128ULL);
  case_2: /* CIL Label */ 
#line 232
  return ((x ^ 32768ULL) - 32768ULL);
  case_4: /* CIL Label */ 
#line 234
  return ((x ^ 2147483648ULL) - 2147483648ULL);
  case_8: /* CIL Label */ 
#line 236
  return (x);
  switch_default: /* CIL Label */ 
  {
#line 238
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 245 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
void byte_get_64(unsigned char *field , elf_vma *high , elf_vma *low ) 
{ 


  {
#line 248
  if ((unsigned long )byte_get == (unsigned long )(& byte_get_big_endian)) {
    {
#line 250
    *high = byte_get_big_endian(field, 4);
#line 251
    *low = byte_get_big_endian(field + 4, 4);
    }
  } else {
    {
#line 255
    *high = byte_get_little_endian(field + 4, 4);
#line 256
    *low = byte_get_little_endian(field, 4);
    }
  }
#line 258
  return;
}
}
#line 265 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
char *adjust_relative_path(char const   *file_name , char const   *name___0 , int name_len ) 
{ 
  char *member_file_name ;
  char const   *base_name ;
  char const   *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  size_t prefix_len ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 270
  tmp___0 = lbasename(file_name);
#line 270
  base_name = tmp___0;
  }
#line 278
  if ((int const   )*(name___0 + 0) == 47) {
#line 278
    goto _L;
  } else
#line 278
  if ((int const   )*(name___0 + 0) == 92) {
#line 278
    goto _L___2;
  } else
  _L___2: /* CIL Label */ 
#line 278
  if (*(name___0 + 0)) {
#line 278
    if ((int const   )*(name___0 + 1) == 58) {
#line 278
      goto _L___1;
    } else {
#line 278
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 278
  if ((unsigned long )base_name == (unsigned long )file_name) {
    _L: /* CIL Label */ 
    {
#line 280
    tmp___1 = malloc((size_t )(name_len + 1));
#line 280
    member_file_name = (char *)tmp___1;
    }
#line 281
    if ((unsigned long )member_file_name == (unsigned long )((void *)0)) {
      {
#line 283
      tmp___2 = gettext("Out of memory\n");
#line 283
      error((char const   *)tmp___2);
      }
#line 284
      return ((char *)((void *)0));
    }
    {
#line 286
    memcpy((void */* __restrict  */)member_file_name, (void const   */* __restrict  */)name___0,
           (size_t )name_len);
#line 287
    *(member_file_name + name_len) = (char )'\000';
    }
  } else {
    {
#line 293
    prefix_len = (size_t )(base_name - file_name);
#line 294
    tmp___3 = malloc((prefix_len + (size_t )name_len) + 1UL);
#line 294
    member_file_name = (char *)tmp___3;
    }
#line 295
    if ((unsigned long )member_file_name == (unsigned long )((void *)0)) {
      {
#line 297
      tmp___4 = gettext("Out of memory\n");
#line 297
      error((char const   *)tmp___4);
      }
#line 298
      return ((char *)((void *)0));
    }
    {
#line 300
    memcpy((void */* __restrict  */)member_file_name, (void const   */* __restrict  */)file_name,
           prefix_len);
#line 301
    memcpy((void */* __restrict  */)(member_file_name + prefix_len), (void const   */* __restrict  */)name___0,
           (size_t )name_len);
#line 302
    *(member_file_name + (prefix_len + (size_t )name_len)) = (char )'\000';
    }
  }
#line 304
  return (member_file_name);
}
}
#line 317 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
static bfd_boolean process_archive_index_and_symbols(struct archive_info *arch , unsigned int sizeof_ar_index ,
                                                     bfd_boolean read_symbols ) 
{ 
  size_t got ;
  unsigned long size ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned long i ;
  unsigned char integer_buffer[sizeof(arch->index_num)] ;
  unsigned char *index_buffer ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 325
  size = strtoul((char const   */* __restrict  */)(arch->arhdr.ar_size), (char **/* __restrict  */)((void *)0),
                 10);
#line 326
  size += size & 1UL;
#line 328
  arch->next_arhdr_offset += sizeof(arch->arhdr) + size;
  }
#line 330
  if (! read_symbols) {
    {
#line 332
    tmp___1 = fseek(arch->file, (long )size, 1);
    }
#line 332
    if (tmp___1 != 0) {
      {
#line 334
      tmp___0 = gettext("%s: failed to skip archive symbol table\n");
#line 334
      error((char const   *)tmp___0, arch->file_name);
      }
#line 336
      return (0);
    }
  } else {
#line 348
    if (! ((unsigned long )sizeof_ar_index <= sizeof(integer_buffer))) {
      {
#line 348
      __assert_fail("sizeof_ar_index <= sizeof integer_buffer", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c",
                    348U, "process_archive_index_and_symbols");
      }
    }
#line 351
    if (size < (unsigned long )sizeof_ar_index) {
      {
#line 353
      tmp___2 = gettext("%s: the archive index is empty\n");
#line 353
      error((char const   *)tmp___2, arch->file_name);
      }
#line 354
      return (0);
    }
    {
#line 358
    got = fread((void */* __restrict  */)(integer_buffer), (size_t )1, (size_t )sizeof_ar_index,
                (FILE */* __restrict  */)arch->file);
    }
#line 359
    if (got != (size_t )sizeof_ar_index) {
      {
#line 361
      tmp___3 = gettext("%s: failed to read archive index\n");
#line 361
      error((char const   *)tmp___3, arch->file_name);
      }
#line 362
      return (0);
    }
    {
#line 365
    arch->index_num = byte_get_big_endian(integer_buffer, (int )sizeof_ar_index);
#line 366
    size -= (unsigned long )sizeof_ar_index;
    }
#line 368
    if ((elf_vma )size < arch->index_num * (elf_vma )sizeof_ar_index) {
      {
#line 370
      tmp___4 = gettext("%s: the archive index is supposed to have %ld entries of %d bytes, but the size is only %ld\n");
#line 370
      error((char const   *)tmp___4, arch->file_name, (long )arch->index_num, sizeof_ar_index,
            size);
      }
#line 372
      return (0);
    }
    {
#line 376
    tmp___5 = malloc((size_t )(arch->index_num * (elf_vma )sizeof_ar_index));
#line 376
    index_buffer = (unsigned char *)tmp___5;
    }
#line 378
    if ((unsigned long )index_buffer == (unsigned long )((void *)0)) {
      {
#line 380
      tmp___6 = gettext("Out of memory whilst trying to read archive symbol index\n");
#line 380
      error((char const   *)tmp___6);
      }
#line 381
      return (0);
    }
    {
#line 384
    got = fread((void */* __restrict  */)index_buffer, (size_t )sizeof_ar_index, (size_t )arch->index_num,
                (FILE */* __restrict  */)arch->file);
    }
#line 385
    if ((elf_vma )got != arch->index_num) {
      {
#line 387
      free((void *)index_buffer);
#line 388
      tmp___7 = gettext("%s: failed to read archive index\n");
#line 388
      error((char const   *)tmp___7, arch->file_name);
      }
#line 389
      return (0);
    }
    {
#line 392
    size = (unsigned long )((elf_vma )size - arch->index_num * (elf_vma )sizeof_ar_index);
#line 395
    tmp___8 = malloc((size_t )(arch->index_num * (elf_vma )sizeof(*(arch->index_array))));
#line 395
    arch->index_array = (elf_vma *)tmp___8;
    }
#line 397
    if ((unsigned long )arch->index_array == (unsigned long )((void *)0)) {
      {
#line 399
      free((void *)index_buffer);
#line 400
      tmp___9 = gettext("Out of memory whilst trying to convert the archive symbol index\n");
#line 400
      error((char const   *)tmp___9);
      }
#line 401
      return (0);
    }
#line 404
    i = 0UL;
    {
#line 404
    while (1) {
      while_continue: /* CIL Label */ ;
#line 404
      if (! ((elf_vma )i < arch->index_num)) {
#line 404
        goto while_break;
      }
      {
#line 405
      *(arch->index_array + i) = byte_get_big_endian(index_buffer + i * (unsigned long )sizeof_ar_index,
                                                     (int )sizeof_ar_index);
#line 404
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 408
    free((void *)index_buffer);
    }
#line 411
    if (size < 1UL) {
      {
#line 413
      tmp___10 = gettext("%s: the archive has an index but no symbols\n");
#line 413
      error((char const   *)tmp___10, arch->file_name);
      }
#line 415
      return (0);
    }
    {
#line 418
    tmp___11 = malloc(size);
#line 418
    arch->sym_table = (char *)tmp___11;
    }
#line 419
    if ((unsigned long )arch->sym_table == (unsigned long )((void *)0)) {
      {
#line 421
      tmp___12 = gettext("Out of memory whilst trying to read archive index symbol table\n");
#line 421
      error((char const   *)tmp___12);
      }
#line 422
      return (0);
    }
    {
#line 425
    arch->sym_size = size;
#line 426
    got = fread((void */* __restrict  */)arch->sym_table, (size_t )1, size, (FILE */* __restrict  */)arch->file);
    }
#line 427
    if (got != size) {
      {
#line 429
      tmp___13 = gettext("%s: failed to read archive index symbol table\n");
#line 429
      error((char const   *)tmp___13, arch->file_name);
      }
#line 431
      return (0);
    }
  }
  {
#line 436
  got = fread((void */* __restrict  */)(& arch->arhdr), (size_t )1, sizeof(arch->arhdr),
              (FILE */* __restrict  */)arch->file);
  }
#line 437
  if (got != sizeof(arch->arhdr)) {
#line 437
    if (got != 0UL) {
      {
#line 439
      tmp___14 = gettext("%s: failed to read archive header following archive index\n");
#line 439
      error((char const   *)tmp___14, arch->file_name);
      }
#line 441
      return (0);
    }
  }
#line 444
  return (1);
}
}
#line 449 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
int setup_archive(struct archive_info *arch , char const   *file_name , FILE *file ,
                  bfd_boolean is_thin_archive , bfd_boolean read_symbols ) 
{ 
  size_t got ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  bfd_boolean tmp___3 ;
  bfd_boolean tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;

  {
  {
#line 456
  arch->file_name = strdup(file_name);
#line 457
  arch->file = file;
#line 458
  arch->index_num = (elf_vma )0;
#line 459
  arch->index_array = (elf_vma *)((void *)0);
#line 460
  arch->sym_table = (char *)((void *)0);
#line 461
  arch->sym_size = 0UL;
#line 462
  arch->longnames = (char *)((void *)0);
#line 463
  arch->longnames_size = 0UL;
#line 464
  arch->nested_member_origin = 0UL;
#line 465
  arch->is_thin_archive = is_thin_archive;
#line 466
  arch->uses_64bit_indicies = 0;
#line 467
  arch->next_arhdr_offset = 8UL;
#line 470
  tmp___1 = fseek(file, 8L, 0);
  }
#line 470
  if (tmp___1 != 0) {
    {
#line 472
    tmp___0 = gettext("%s: failed to seek to first archive header\n");
#line 472
    error((char const   *)tmp___0, file_name);
    }
#line 473
    return (1);
  }
  {
#line 475
  got = fread((void */* __restrict  */)(& arch->arhdr), (size_t )1, sizeof(arch->arhdr),
              (FILE */* __restrict  */)file);
  }
#line 476
  if (got != sizeof(arch->arhdr)) {
#line 478
    if (got == 0UL) {
#line 479
      return (0);
    }
    {
#line 481
    tmp___2 = gettext("%s: failed to read archive header\n");
#line 481
    error((char const   *)tmp___2, file_name);
    }
#line 482
    return (1);
  }
  {
#line 486
  tmp___7 = strncmp((char const   *)(arch->arhdr.ar_name), "/               ", sizeof("/               ") - 1UL);
  }
#line 486
  if (tmp___7 == 0) {
    {
#line 488
    tmp___3 = process_archive_index_and_symbols(arch, 4U, read_symbols);
    }
#line 488
    if (! tmp___3) {
#line 489
      return (1);
    }
  } else {
    {
#line 491
    tmp___6 = strncmp((char const   *)(arch->arhdr.ar_name), "/SYM64/         ", sizeof("/SYM64/         ") - 1UL);
    }
#line 491
    if (tmp___6 == 0) {
      {
#line 493
      arch->uses_64bit_indicies = 1;
#line 494
      tmp___4 = process_archive_index_and_symbols(arch, 8U, read_symbols);
      }
#line 494
      if (! tmp___4) {
#line 495
        return (1);
      }
    } else
#line 497
    if (read_symbols) {
      {
#line 498
      tmp___5 = gettext("%s has no archive index\n");
#line 498
      printf((char const   */* __restrict  */)tmp___5, file_name);
      }
    }
  }
  {
#line 500
  tmp___12 = strncmp((char const   *)(arch->arhdr.ar_name), "//              ", sizeof("//              ") - 1UL);
  }
#line 500
  if (tmp___12 == 0) {
    {
#line 503
    arch->longnames_size = strtoul((char const   */* __restrict  */)(arch->arhdr.ar_size),
                                   (char **/* __restrict  */)((void *)0), 10);
#line 504
    arch->next_arhdr_offset += sizeof(arch->arhdr) + arch->longnames_size;
#line 506
    tmp___8 = malloc(arch->longnames_size);
#line 506
    arch->longnames = (char *)tmp___8;
    }
#line 507
    if ((unsigned long )arch->longnames == (unsigned long )((void *)0)) {
      {
#line 509
      tmp___9 = gettext("Out of memory reading long symbol names in archive\n");
#line 509
      error((char const   *)tmp___9);
      }
#line 510
      return (1);
    }
    {
#line 513
    tmp___11 = fread((void */* __restrict  */)arch->longnames, arch->longnames_size,
                     (size_t )1, (FILE */* __restrict  */)file);
    }
#line 513
    if (tmp___11 != 1UL) {
      {
#line 515
      free((void *)arch->longnames);
#line 516
      arch->longnames = (char *)((void *)0);
#line 517
      tmp___10 = gettext("%s: failed to read long symbol name string table\n");
#line 517
      error((char const   *)tmp___10, file_name);
      }
#line 519
      return (1);
    }
#line 522
    if ((arch->longnames_size & 1UL) != 0UL) {
      {
#line 523
      _IO_getc(file);
      }
    }
  }
#line 526
  return (0);
}
}
#line 531 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
int setup_nested_archive(struct archive_info *nested_arch , char const   *member_file_name ) 
{ 
  FILE *member_file ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 538
  if ((unsigned long )nested_arch->file_name != (unsigned long )((void *)0)) {
    {
#line 538
    tmp___0 = strcmp((char const   *)nested_arch->file_name, member_file_name);
    }
#line 538
    if (tmp___0 == 0) {
#line 540
      return (0);
    }
  }
#line 543
  if ((unsigned long )nested_arch->file != (unsigned long )((void *)0)) {
    {
#line 544
    fclose(nested_arch->file);
    }
  }
  {
#line 545
  release_archive(nested_arch);
#line 547
  member_file = fopen((char const   */* __restrict  */)member_file_name, (char const   */* __restrict  */)"rb");
  }
#line 548
  if ((unsigned long )member_file == (unsigned long )((void *)0)) {
#line 549
    return (1);
  }
  {
#line 550
  tmp___1 = setup_archive(nested_arch, member_file_name, member_file, 0, 0);
  }
#line 550
  return (tmp___1);
}
}
#line 556 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
void release_archive(struct archive_info *arch ) 
{ 


  {
#line 559
  if ((unsigned long )arch->file_name != (unsigned long )((void *)0)) {
    {
#line 560
    free((void *)arch->file_name);
    }
  }
#line 561
  if ((unsigned long )arch->index_array != (unsigned long )((void *)0)) {
    {
#line 562
    free((void *)arch->index_array);
    }
  }
#line 563
  if ((unsigned long )arch->sym_table != (unsigned long )((void *)0)) {
    {
#line 564
    free((void *)arch->sym_table);
    }
  }
#line 565
  if ((unsigned long )arch->longnames != (unsigned long )((void *)0)) {
    {
#line 566
    free((void *)arch->longnames);
    }
  }
#line 567
  return;
}
}
#line 576 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
char *get_archive_member_name(struct archive_info *arch , struct archive_info *nested_arch ) 
{ 
  unsigned long j ;
  unsigned long k ;
  char *endp ;
  char *member_file_name ;
  char *member_name ;
  int tmp___0 ;
  char *name___0 ;
  void *tmp___1 ;

  {
#line 582
  if ((int )arch->arhdr.ar_name[0] == 47) {
    {
#line 589
    arch->nested_member_origin = 0UL;
#line 590
    j = strtoul((char const   */* __restrict  */)(arch->arhdr.ar_name + 1), (char **/* __restrict  */)(& endp),
                10);
#line 590
    k = j;
    }
#line 591
    if (arch->is_thin_archive) {
#line 591
      if ((unsigned long )endp != (unsigned long )((void *)0)) {
#line 591
        if ((int )*endp == 58) {
          {
#line 592
          arch->nested_member_origin = strtoul((char const   */* __restrict  */)(endp + 1),
                                               (char **/* __restrict  */)((void *)0),
                                               10);
          }
        }
      }
    }
    {
#line 594
    while (1) {
      while_continue: /* CIL Label */ ;
#line 594
      if (j < arch->longnames_size) {
#line 594
        if ((int )*(arch->longnames + j) != 10) {
#line 594
          if (! ((int )*(arch->longnames + j) != 0)) {
#line 594
            goto while_break;
          }
        } else {
#line 594
          goto while_break;
        }
      } else {
#line 594
        goto while_break;
      }
#line 597
      j ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 598
    if ((int )*(arch->longnames + (j - 1UL)) == 47) {
#line 599
      j --;
    }
#line 600
    *(arch->longnames + j) = (char )'\000';
#line 602
    if (! arch->is_thin_archive) {
#line 603
      return (arch->longnames + k);
    } else
#line 602
    if (arch->nested_member_origin == 0UL) {
#line 603
      return (arch->longnames + k);
    }
    {
#line 607
    member_file_name = adjust_relative_path((char const   *)arch->file_name, (char const   *)(arch->longnames + k),
                                            (int )(j - k));
    }
#line 609
    if ((unsigned long )member_file_name != (unsigned long )((void *)0)) {
      {
#line 609
      tmp___0 = setup_nested_archive(nested_arch, (char const   *)member_file_name);
      }
#line 609
      if (tmp___0 == 0) {
        {
#line 612
        member_name = get_archive_member_name_at(nested_arch, arch->nested_member_origin,
                                                 (struct archive_info *)((void *)0));
        }
#line 615
        if ((unsigned long )member_name != (unsigned long )((void *)0)) {
          {
#line 617
          free((void *)member_file_name);
          }
#line 618
          return (member_name);
        }
      }
    }
    {
#line 621
    free((void *)member_file_name);
    }
#line 624
    return (arch->longnames + k);
  }
#line 628
  j = 0UL;
  {
#line 628
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 628
    if (! (j < sizeof(arch->arhdr.ar_name))) {
#line 628
      goto while_break___0;
    }
#line 629
    if ((int )arch->arhdr.ar_name[j] == 47) {
#line 631
      arch->arhdr.ar_name[j] = (char )'\000';
#line 632
      return (arch->arhdr.ar_name);
    }
#line 628
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 638
  tmp___1 = xmalloc(sizeof(arch->arhdr.ar_name) + 1UL);
#line 638
  name___0 = (char *)tmp___1;
#line 639
  memcpy((void */* __restrict  */)name___0, (void const   */* __restrict  */)(arch->arhdr.ar_name),
         sizeof(arch->arhdr.ar_name));
#line 640
  *(name___0 + sizeof(arch->arhdr.ar_name)) = (char )'\000';
  }
#line 641
  return (name___0);
}
}
#line 648 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
char *get_archive_member_name_at(struct archive_info *arch , unsigned long offset ,
                                 struct archive_info *nested_arch ) 
{ 
  size_t got ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 655
  tmp___1 = fseek(arch->file, (long )offset, 0);
  }
#line 655
  if (tmp___1 != 0) {
    {
#line 657
    tmp___0 = gettext("%s: failed to seek to next file name\n");
#line 657
    error((char const   *)tmp___0, arch->file_name);
    }
#line 658
    return ((char *)((void *)0));
  }
  {
#line 660
  got = fread((void */* __restrict  */)(& arch->arhdr), (size_t )1, sizeof(arch->arhdr),
              (FILE */* __restrict  */)arch->file);
  }
#line 661
  if (got != sizeof(arch->arhdr)) {
    {
#line 663
    tmp___2 = gettext("%s: failed to read archive header\n");
#line 663
    error((char const   *)tmp___2, arch->file_name);
    }
#line 664
    return ((char *)((void *)0));
  }
  {
#line 666
  tmp___4 = memcmp((void const   *)(arch->arhdr.ar_fmag), (void const   *)"`\n", (size_t )2);
  }
#line 666
  if (tmp___4 != 0) {
    {
#line 668
    tmp___3 = gettext("%s: did not find a valid archive header\n");
#line 668
    error((char const   *)tmp___3, arch->file_name);
    }
#line 670
    return ((char *)((void *)0));
  }
  {
#line 673
  tmp___5 = get_archive_member_name(arch, nested_arch);
  }
#line 673
  return (tmp___5);
}
}
#line 682 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/elfcomm.c"
char *make_qualified_name(struct archive_info *arch , struct archive_info *nested_arch ,
                          char const   *member_name ) 
{ 
  size_t len ;
  char *name___0 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 690
  tmp___0 = strlen((char const   *)arch->file_name);
#line 690
  tmp___1 = strlen(member_name);
#line 690
  len = (tmp___0 + tmp___1) + 3UL;
  }
#line 691
  if (arch->is_thin_archive) {
#line 691
    if (arch->nested_member_origin != 0UL) {
      {
#line 692
      tmp___2 = strlen((char const   *)nested_arch->file_name);
#line 692
      len += tmp___2 + 2UL;
      }
    }
  }
  {
#line 694
  tmp___3 = malloc(len);
#line 694
  name___0 = (char *)tmp___3;
  }
#line 695
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 697
    tmp___4 = gettext("Out of memory\n");
#line 697
    error((char const   *)tmp___4);
    }
#line 698
    return ((char *)((void *)0));
  }
#line 701
  if (arch->is_thin_archive) {
#line 701
    if (arch->nested_member_origin != 0UL) {
      {
#line 702
      snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s[%s(%s)]",
               arch->file_name, nested_arch->file_name, member_name);
      }
    } else {
#line 701
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 704
  if (arch->is_thin_archive) {
    {
#line 705
    snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s[%s]",
             arch->file_name, member_name);
    }
  } else {
    {
#line 707
    snprintf((char */* __restrict  */)name___0, len, (char const   */* __restrict  */)"%s(%s)",
             arch->file_name, member_name);
    }
  }
#line 709
  return (name___0);
}
}
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 524
extern int putchar(int __c ) ;
#line 632
extern int puts(char const   *__s ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 174 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
struct dwarf_section_display debug_displays[32] ;
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int eh_addr_size  ;
#line 205 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_info  ;
#line 206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_abbrevs  ;
#line 207 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_lines  ;
#line 208 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_pubnames  ;
#line 209 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_pubtypes  ;
#line 210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_aranges  ;
#line 211 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_ranges  ;
#line 212 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_frames  ;
#line 213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_frames_interp  ;
#line 214 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_macinfo  ;
#line 215 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_str  ;
#line 216 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_debug_loc  ;
#line 217 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_gdb_index  ;
#line 218 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_trace_info  ;
#line 219 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_trace_abbrevs  ;
#line 220 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_trace_aranges  ;
#line 221 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
int do_wide  ;
#line 223
int dwarf_cutoff_level ;
#line 224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.h"
unsigned long dwarf_start_die  ;
#line 226
int dwarf_check ;
#line 228
void init_dwarf_regnames(unsigned int e_machine ) ;
#line 229
void init_dwarf_regnames_i386(void) ;
#line 230
void init_dwarf_regnames_x86_64(void) ;
#line 232
int load_debug_section(enum dwarf_section_display_enum debug , void *file ) ;
#line 233
void free_debug_section(enum dwarf_section_display_enum debug ) ;
#line 235
void free_debug_memory(void) ;
#line 237
void dwarf_select_sections_by_names(char const   *names ) ;
#line 238
void dwarf_select_sections_by_letters(char const   *letters ) ;
#line 239
void dwarf_select_sections_all(void) ;
#line 241
void *cmalloc(size_t nmemb , size_t size ) ;
#line 242
void *xcmalloc(size_t nmemb , size_t size ) ;
#line 243
void *xcrealloc(void *ptr , size_t nmemb , size_t size ) ;
#line 245
dwarf_vma read_leb128(unsigned char *data , unsigned int *length_return , int sign ) ;
#line 33 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *regname(unsigned int regno , int row ) ;
#line 35 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int have_frame_base  ;
#line 36 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int need_base_address  ;
#line 38 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned int last_pointer_size  =    0U;
#line 39 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int warned_about_missing_comp_units  =    0;
#line 41 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned int num_debug_info_entries  =    0U;
#line 42 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static debug_info *debug_information  =    (debug_info *)((void *)0);
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
int dwarf_cutoff_level  =    -1;
#line 70 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
int dwarf_check  =    0;
#line 76 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int size_of_encoded_value(int encoding ) 
{ 


  {
  {
#line 83
  if ((encoding & 7) == 2) {
#line 83
    goto case_2;
  }
#line 84
  if ((encoding & 7) == 3) {
#line 84
    goto case_3;
  }
#line 85
  if ((encoding & 7) == 4) {
#line 85
    goto case_4;
  }
#line 81
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 82
  return (eh_addr_size);
  case_2: /* CIL Label */ 
#line 83
  return (2);
  case_3: /* CIL Label */ 
#line 84
  return (4);
  case_4: /* CIL Label */ 
#line 85
  return (8);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 89 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static dwarf_vma get_encoded_value(unsigned char *data , int encoding , struct dwarf_section *section ) 
{ 
  int size ;
  int tmp___0 ;
  dwarf_vma val ;

  {
  {
#line 94
  tmp___0 = size_of_encoded_value(encoding);
#line 94
  size = tmp___0;
  }
#line 97
  if (encoding & 8) {
    {
#line 98
    val = byte_get_signed(data, size);
    }
  } else {
    {
#line 100
    val = (*byte_get)(data, size);
    }
  }
#line 102
  if ((encoding & 112) == 16) {
#line 103
    val += section->address + (dwarf_vma )(data - section->start);
  }
#line 104
  return (val);
}
}
#line 114 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char buff[18]  ;
#line 111 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void print_dwarf_vma(dwarf_vma val , unsigned int byte_size ) 
{ 
  int offset ;
  char *tmp___0 ;

  {
  {
#line 115
  offset = 0;
#line 122
  snprintf((char */* __restrict  */)(buff), sizeof(buff), (char const   */* __restrict  */)"%16.16llx ",
           val);
  }
#line 130
  if (byte_size != 0U) {
#line 132
    if (byte_size > 0U) {
#line 132
      if (byte_size <= 8U) {
#line 133
        offset = (int )(16U - 2U * byte_size);
      } else {
        {
#line 135
        tmp___0 = gettext("Wrong size in print_dwarf_vma");
#line 135
        error((char const   *)tmp___0);
        }
      }
    } else {
      {
#line 135
      tmp___0 = gettext("Wrong size in print_dwarf_vma");
#line 135
      error((char const   *)tmp___0);
      }
    }
  }
  {
#line 138
  fputs((char const   */* __restrict  */)(buff + offset), (FILE */* __restrict  */)stdout);
  }
#line 139
  return;
}
}
#line 157
static char const   *dwarf_vmatoa(char const   *fmtch , dwarf_vma value ) ;
#line 157 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int buf_pos  =    0;
#line 158 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static struct dwarf_vmatoa_buf buf___2[16]  ;
#line 151 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *dwarf_vmatoa(char const   *fmtch , dwarf_vma value ) 
{ 
  char fmt[32] ;
  char *ret ;
  int tmp___0 ;

  {
  {
#line 165
  sprintf((char */* __restrict  */)(fmt), (char const   */* __restrict  */)"%%%s%s",
          "ll", fmtch);
#line 167
  tmp___0 = buf_pos;
#line 167
  buf_pos ++;
#line 167
  ret = buf___2[tmp___0].place;
#line 168
  buf_pos = (int )((unsigned long )buf_pos % (sizeof(buf___2) / sizeof(buf___2[0])));
#line 170
  snprintf((char */* __restrict  */)ret, sizeof(buf___2[0].place), (char const   */* __restrict  */)(fmt),
           value);
  }
#line 172
  return ((char const   *)ret);
}
}
#line 178 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *dwarf_vmatoa64(dwarf_vma hvalue , dwarf_vma lvalue , char *buf___4 ,
                                    unsigned int buf_len ) 
{ 
  int len ;

  {
#line 182
  len = 0;
#line 184
  if (hvalue == 0ULL) {
    {
#line 185
    snprintf((char */* __restrict  */)buf___4, (size_t )buf_len, (char const   */* __restrict  */)"%llx",
             lvalue);
    }
  } else {
    {
#line 188
    len = snprintf((char */* __restrict  */)buf___4, (size_t )buf_len, (char const   */* __restrict  */)"%llx",
                   hvalue);
#line 189
    snprintf((char */* __restrict  */)(buf___4 + len), (size_t )(buf_len - (unsigned int )len),
             (char const   */* __restrict  */)"%08llx", lvalue);
    }
  }
#line 193
  return ((char const   *)buf___4);
}
}
#line 196 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
dwarf_vma read_leb128(unsigned char *data , unsigned int *length_return , int sign ) 
{ 
  dwarf_vma result ;
  unsigned int num_read ;
  unsigned int shift ;
  unsigned char byte ;
  unsigned char *tmp___0 ;

  {
#line 199
  result = (dwarf_vma )0;
#line 200
  num_read = 0U;
#line 201
  shift = 0U;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    tmp___0 = data;
#line 206
    data ++;
#line 206
    byte = *tmp___0;
#line 207
    num_read ++;
#line 209
    result |= (dwarf_vma )((int )byte & 127) << shift;
#line 211
    shift += 7U;
#line 204
    if (! ((int )byte & 128)) {
#line 204
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if ((unsigned long )length_return != (unsigned long )((void *)0)) {
#line 217
    *length_return = num_read;
  }
#line 219
  if (sign) {
#line 219
    if ((unsigned long )shift < 8UL * sizeof(result)) {
#line 219
      if ((int )byte & 64) {
#line 220
        result |= (unsigned long long )(-1L << shift);
      }
    }
  }
#line 222
  return (result);
}
}
#line 226 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static dwarf_signed_vma read_sleb128(unsigned char *data , unsigned int *length_return ) 
{ 
  dwarf_vma tmp___0 ;

  {
  {
#line 229
  tmp___0 = read_leb128(data, length_return, 1);
  }
#line 229
  return ((dwarf_signed_vma )tmp___0);
}
}
#line 247 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static SMR state_machine_regs  ;
#line 249 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void reset_state_machine(int is_stmt ) 
{ 


  {
#line 252
  state_machine_regs.address = (dwarf_vma )0;
#line 253
  state_machine_regs.op_index = (unsigned char)0;
#line 254
  state_machine_regs.file = 1U;
#line 255
  state_machine_regs.line = 1U;
#line 256
  state_machine_regs.column = 0U;
#line 257
  state_machine_regs.is_stmt = is_stmt;
#line 258
  state_machine_regs.basic_block = 0;
#line 259
  state_machine_regs.end_sequence = (unsigned char)0;
#line 260
  state_machine_regs.last_file_entry = 0U;
#line 261
  return;
}
}
#line 266 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int process_extended_line_op(unsigned char *data , int is_stmt ) 
{ 
  unsigned char op_code ;
  unsigned int bytes_read ;
  unsigned int len ;
  unsigned char *name___0 ;
  dwarf_vma adr ;
  unsigned char *orig_data ;
  dwarf_vma tmp___0 ;
  char *tmp___1 ;
  unsigned char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  dwarf_vma tmp___10 ;
  char const   *tmp___11 ;
  dwarf_vma tmp___12 ;
  char const   *tmp___13 ;
  dwarf_vma tmp___14 ;
  char const   *tmp___15 ;
  char *tmp___16 ;
  dwarf_vma tmp___17 ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  unsigned char *edata ;
  unsigned int opc ;
  dwarf_vma tmp___20 ;
  dwarf_vma tmp___21 ;
  char const   *tmp___22 ;
  dwarf_vma tmp___23 ;
  char const   *tmp___24 ;
  dwarf_vma tmp___25 ;
  char const   *tmp___26 ;
  dwarf_vma tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  unsigned int rlen ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  unsigned char *tmp___33 ;

  {
  {
#line 274
  orig_data = data;
#line 276
  tmp___0 = read_leb128(data, & bytes_read, 0);
#line 276
  len = (unsigned int )tmp___0;
#line 277
  data += bytes_read;
  }
#line 279
  if (len == 0U) {
    {
#line 281
    tmp___1 = gettext("badly formed extended line op encountered!\n");
#line 281
    warn((char const   *)tmp___1);
    }
#line 282
    return ((int )bytes_read);
  }
  {
#line 285
  len += bytes_read;
#line 286
  tmp___2 = data;
#line 286
  data ++;
#line 286
  op_code = *tmp___2;
#line 288
  tmp___3 = gettext("  Extended opcode %d: ");
#line 288
  printf((char const   */* __restrict  */)tmp___3, (int )op_code);
  }
  {
#line 292
  if ((int )op_code == 1) {
#line 292
    goto case_1;
  }
#line 297
  if ((int )op_code == 2) {
#line 297
    goto case_2;
  }
#line 304
  if ((int )op_code == 3) {
#line 304
    goto case_3;
  }
#line 323
  if ((int )op_code == 4) {
#line 323
    goto case_4;
  }
#line 329
  if ((int )op_code == 17) {
#line 329
    goto case_17;
  }
#line 332
  if ((int )op_code == 18) {
#line 332
    goto case_18;
  }
#line 335
  if ((int )op_code == 19) {
#line 335
    goto case_19;
  }
#line 338
  if ((int )op_code == 20) {
#line 338
    goto case_20;
  }
#line 341
  if ((int )op_code == 21) {
#line 341
    goto case_21;
  }
#line 344
  if ((int )op_code == 22) {
#line 344
    goto case_22;
  }
#line 347
  if ((int )op_code == 23) {
#line 347
    goto case_23;
  }
#line 350
  if ((int )op_code == 24) {
#line 350
    goto case_24;
  }
#line 353
  if ((int )op_code == 25) {
#line 353
    goto case_25;
  }
#line 356
  if ((int )op_code == 32) {
#line 356
    goto case_32;
  }
#line 359
  if ((int )op_code == 128) {
#line 359
    goto case_128;
  }
#line 407
  goto switch_default___0;
  case_1: /* CIL Label */ 
  {
#line 293
  tmp___4 = gettext("End of Sequence\n\n");
#line 293
  printf((char const   */* __restrict  */)tmp___4);
#line 294
  reset_state_machine(is_stmt);
  }
#line 295
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 298
  adr = (*byte_get)(data, (int )((len - bytes_read) - 1U));
#line 299
  tmp___5 = dwarf_vmatoa("x", adr);
#line 299
  tmp___6 = gettext("set Address to 0x%s\n");
#line 299
  printf((char const   */* __restrict  */)tmp___6, tmp___5);
#line 300
  state_machine_regs.address = adr;
#line 301
  state_machine_regs.op_index = (unsigned char)0;
  }
#line 302
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 305
  tmp___7 = gettext("define new File Table entry\n");
#line 305
  printf((char const   */* __restrict  */)tmp___7);
#line 306
  tmp___8 = gettext("  Entry\tDir\tTime\tSize\tName\n");
#line 306
  printf((char const   */* __restrict  */)tmp___8);
#line 308
  (state_machine_regs.last_file_entry) ++;
#line 308
  printf((char const   */* __restrict  */)"   %d\t", state_machine_regs.last_file_entry);
#line 309
  name___0 = data;
#line 310
  tmp___9 = strlen((char const   *)((char *)data));
#line 310
  data += tmp___9 + 1UL;
#line 311
  tmp___10 = read_leb128(data, & bytes_read, 0);
#line 311
  tmp___11 = dwarf_vmatoa("u", tmp___10);
#line 311
  printf((char const   */* __restrict  */)"%s\t", tmp___11);
#line 312
  data += bytes_read;
#line 313
  tmp___12 = read_leb128(data, & bytes_read, 0);
#line 313
  tmp___13 = dwarf_vmatoa("u", tmp___12);
#line 313
  printf((char const   */* __restrict  */)"%s\t", tmp___13);
#line 314
  data += bytes_read;
#line 315
  tmp___14 = read_leb128(data, & bytes_read, 0);
#line 315
  tmp___15 = dwarf_vmatoa("u", tmp___14);
#line 315
  printf((char const   */* __restrict  */)"%s\t", tmp___15);
#line 316
  data += bytes_read;
#line 317
  printf((char const   */* __restrict  */)"%s", name___0);
  }
#line 318
  if ((unsigned int )(data - orig_data) != len) {
    {
#line 319
    tmp___16 = gettext(" [Bad opcode length]");
#line 319
    printf((char const   */* __restrict  */)tmp___16);
    }
  }
  {
#line 320
  printf((char const   */* __restrict  */)"\n\n");
  }
#line 321
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 324
  tmp___17 = read_leb128(data, & bytes_read, 0);
#line 324
  tmp___18 = dwarf_vmatoa("u", tmp___17);
#line 324
  tmp___19 = gettext("set Discriminator to %s\n");
#line 324
  printf((char const   */* __restrict  */)tmp___19, tmp___18);
  }
#line 326
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 330
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_is_UV_update\n");
  }
#line 331
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 333
  printf((char const   */* __restrict  */)"DW_LNE_HP_push_context\n");
  }
#line 334
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 336
  printf((char const   */* __restrict  */)"DW_LNE_HP_pop_context\n");
  }
#line 337
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 339
  printf((char const   */* __restrict  */)"DW_LNE_HP_set_file_line_column\n");
  }
#line 340
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 342
  printf((char const   */* __restrict  */)"DW_LNE_HP_set_routine_name\n");
  }
#line 343
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 345
  printf((char const   */* __restrict  */)"DW_LNE_HP_set_sequence\n");
  }
#line 346
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 348
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_post_semantics\n");
  }
#line 349
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 351
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_function_exit\n");
  }
#line 352
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 354
  printf((char const   */* __restrict  */)"DW_LNE_HP_negate_front_end_logical\n");
  }
#line 355
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 357
  printf((char const   */* __restrict  */)"DW_LNE_HP_define_proc\n");
  }
#line 358
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 361
  edata = ((data + len) - bytes_read) - 1;
#line 363
  printf((char const   */* __restrict  */)"DW_LNE_HP_source_file_correlation\n");
  }
  {
#line 365
  while (1) {
    while_continue: /* CIL Label */ ;
#line 365
    if (! ((unsigned long )data < (unsigned long )edata)) {
#line 365
      goto while_break;
    }
    {
#line 369
    tmp___20 = read_leb128(data, & bytes_read, 0);
#line 369
    opc = (unsigned int )tmp___20;
#line 370
    data += bytes_read;
    }
    {
#line 374
    if (opc == 1U) {
#line 374
      goto case_1___0;
    }
#line 377
    if (opc == 2U) {
#line 377
      goto case_2___0;
    }
#line 383
    if (opc == 3U) {
#line 383
      goto case_3___0;
    }
#line 398
    goto switch_default;
    case_1___0: /* CIL Label */ 
    {
#line 375
    printf((char const   */* __restrict  */)"    DW_LNE_HP_SFC_formfeed\n");
    }
#line 376
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 378
    tmp___21 = read_leb128(data, & bytes_read, 0);
#line 378
    tmp___22 = dwarf_vmatoa("u", tmp___21);
#line 378
    printf((char const   */* __restrict  */)"    DW_LNE_HP_SFC_set_listing_line (%s)\n",
           tmp___22);
#line 381
    data += bytes_read;
    }
#line 382
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 384
    printf((char const   */* __restrict  */)"    DW_LNE_HP_SFC_associate ");
#line 385
    tmp___23 = read_leb128(data, & bytes_read, 0);
#line 385
    tmp___24 = dwarf_vmatoa("u", tmp___23);
#line 385
    printf((char const   */* __restrict  */)"(%s", tmp___24);
#line 388
    data += bytes_read;
#line 389
    tmp___25 = read_leb128(data, & bytes_read, 0);
#line 389
    tmp___26 = dwarf_vmatoa("u", tmp___25);
#line 389
    printf((char const   */* __restrict  */)",%s", tmp___26);
#line 392
    data += bytes_read;
#line 393
    tmp___27 = read_leb128(data, & bytes_read, 0);
#line 393
    tmp___28 = dwarf_vmatoa("u", tmp___27);
#line 393
    printf((char const   */* __restrict  */)",%s)\n", tmp___28);
#line 396
    data += bytes_read;
    }
#line 397
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 399
    tmp___29 = gettext("    UNKNOWN DW_LNE_HP_SFC opcode (%u)\n");
#line 399
    printf((char const   */* __restrict  */)tmp___29, opc);
#line 400
    data = edata;
    }
#line 401
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  goto switch_break;
  switch_default___0: /* CIL Label */ 
#line 409
  rlen = (len - bytes_read) - 1U;
#line 411
  if ((int )op_code >= 128) {
    {
#line 416
    tmp___30 = gettext("user defined: ");
#line 416
    printf((char const   */* __restrict  */)tmp___30);
    }
  } else {
    {
#line 418
    tmp___31 = gettext("UNKNOWN: ");
#line 418
    printf((char const   */* __restrict  */)tmp___31);
    }
  }
  {
#line 419
  tmp___32 = gettext("length %d [");
#line 419
  printf((char const   */* __restrict  */)tmp___32, rlen);
  }
  {
#line 420
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 420
    if (! rlen) {
#line 420
      goto while_break___0;
    }
    {
#line 421
    tmp___33 = data;
#line 421
    data ++;
#line 421
    printf((char const   */* __restrict  */)" %02x", (int )*tmp___33);
#line 420
    rlen --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 422
  printf((char const   */* __restrict  */)"]\n");
  }
#line 424
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 427
  return ((int )len);
}
}
#line 430 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *fetch_indirect_string(dwarf_vma offset ) 
{ 
  struct dwarf_section *section ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 433
  section = & debug_displays[9].section;
#line 435
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
    {
#line 436
    tmp___0 = gettext("<no .debug_str section>");
    }
#line 436
    return ((char const   *)tmp___0);
  }
#line 439
  offset -= section->address;
#line 440
  if (offset > section->size) {
    {
#line 442
    tmp___1 = dwarf_vmatoa("x", offset);
#line 442
    tmp___2 = gettext("DW_FORM_strp offset too big: %s\n");
#line 442
    warn((char const   *)tmp___2, tmp___1);
#line 444
    tmp___3 = gettext("<offset is too big>");
    }
#line 444
    return ((char const   *)tmp___3);
  }
#line 447
  return ((char const   *)section->start + offset);
}
}
#line 450 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *fetch_indexed_string(dwarf_vma idx___0 , dwarf_vma offset_size ,
                                          int dwo ) 
{ 
  enum dwarf_section_display_enum str_sec_idx ;
  int tmp___0 ;
  enum dwarf_section_display_enum idx_sec_idx ;
  int tmp___1 ;
  struct dwarf_section *index_section ;
  struct dwarf_section *str_section ;
  dwarf_vma index_offset ;
  dwarf_vma str_offset ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 453
  if (dwo) {
#line 453
    tmp___0 = 28;
  } else {
#line 453
    tmp___0 = 9;
  }
#line 453
  str_sec_idx = (enum dwarf_section_display_enum )tmp___0;
#line 454
  if (dwo) {
#line 454
    tmp___1 = 30;
  } else {
#line 454
    tmp___1 = 29;
  }
#line 454
  idx_sec_idx = (enum dwarf_section_display_enum )tmp___1;
#line 455
  index_section = & debug_displays[idx_sec_idx].section;
#line 456
  str_section = & debug_displays[str_sec_idx].section;
#line 457
  index_offset = idx___0 * offset_size;
#line 460
  if ((unsigned long )index_section->start == (unsigned long )((void *)0)) {
#line 461
    if (dwo) {
      {
#line 461
      tmp___2 = gettext("<no .debug_str_offsets.dwo section>");
#line 461
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 461
      tmp___3 = gettext("<no .debug_str_offsets section>");
#line 461
      tmp___4 = tmp___3;
      }
    }
#line 461
    return ((char const   *)tmp___4);
  }
#line 465
  index_offset -= index_section->address;
#line 466
  if (index_offset > index_section->size) {
    {
#line 468
    tmp___5 = dwarf_vmatoa("x", index_offset);
#line 468
    tmp___6 = gettext("DW_FORM_GNU_str_index offset too big: %s\n");
#line 468
    warn((char const   *)tmp___6, tmp___5);
#line 470
    tmp___7 = gettext("<index offset is too big>");
    }
#line 470
    return ((char const   *)tmp___7);
  }
#line 473
  if ((unsigned long )str_section->start == (unsigned long )((void *)0)) {
#line 474
    if (dwo) {
      {
#line 474
      tmp___8 = gettext("<no .debug_str.dwo section>");
#line 474
      tmp___10 = tmp___8;
      }
    } else {
      {
#line 474
      tmp___9 = gettext("<no .debug_str section>");
#line 474
      tmp___10 = tmp___9;
      }
    }
#line 474
    return ((char const   *)tmp___10);
  }
  {
#line 477
  str_offset = (*byte_get)(index_section->start + index_offset, (int )offset_size);
#line 478
  str_offset -= str_section->address;
  }
#line 479
  if (str_offset > str_section->size) {
    {
#line 481
    tmp___11 = dwarf_vmatoa("x", str_offset);
#line 481
    tmp___12 = gettext("DW_FORM_GNU_str_index indirect offset too big: %s\n");
#line 481
    warn((char const   *)tmp___12, tmp___11);
#line 483
    tmp___13 = gettext("<indirect index offset is too big>");
    }
#line 483
    return ((char const   *)tmp___13);
  }
#line 486
  return ((char const   *)str_section->start + str_offset);
}
}
#line 489 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *fetch_indexed_value(dwarf_vma offset , dwarf_vma bytes ) 
{ 
  struct dwarf_section *section ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  elf_vma tmp___3 ;
  char const   *tmp___4 ;

  {
#line 492
  section = & debug_displays[31].section;
#line 494
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
    {
#line 495
    tmp___0 = gettext("<no .debug_addr section>");
    }
#line 495
    return ((char const   *)tmp___0);
  }
#line 497
  if (offset + bytes > section->size) {
    {
#line 499
    tmp___1 = dwarf_vmatoa("x", offset);
#line 499
    tmp___2 = gettext("Offset into section %s too big: %s\n");
#line 499
    warn((char const   *)tmp___2, section->name, tmp___1);
    }
#line 501
    return ("<offset too big>");
  }
  {
#line 504
  tmp___3 = (*byte_get)(section->start + offset, (int )bytes);
#line 504
  tmp___4 = dwarf_vmatoa("x", tmp___3);
  }
#line 504
  return (tmp___4);
}
}
#line 530 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static abbrev_entry *first_abbrev  =    (abbrev_entry *)((void *)0);
#line 531 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static abbrev_entry *last_abbrev  =    (abbrev_entry *)((void *)0);
#line 533 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void free_abbrevs(void) 
{ 
  abbrev_entry *abbrv ;
  abbrev_entry *next_abbrev ;
  abbrev_attr *attr ;
  abbrev_attr *next_attr ;

  {
#line 538
  abbrv = first_abbrev;
  {
#line 538
  while (1) {
    while_continue: /* CIL Label */ ;
#line 538
    if (! abbrv) {
#line 538
      goto while_break;
    }
#line 540
    next_abbrev = abbrv->next;
#line 543
    attr = abbrv->first_attr;
    {
#line 543
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 543
      if (! attr) {
#line 543
        goto while_break___0;
      }
      {
#line 545
      next_attr = attr->next;
#line 547
      free((void *)attr);
#line 548
      attr = next_attr;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 551
    free((void *)abbrv);
#line 552
    abbrv = next_abbrev;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  first_abbrev = (abbrev_entry *)((void *)0);
#line 555
  last_abbrev = first_abbrev;
#line 556
  return;
}
}
#line 558 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void add_abbrev(unsigned long number , unsigned long tag , int children ) 
{ 
  abbrev_entry *entry ;
  void *tmp___0 ;

  {
  {
#line 563
  tmp___0 = malloc(sizeof(*entry));
#line 563
  entry = (abbrev_entry *)tmp___0;
  }
#line 564
  if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 566
    return;
  }
#line 568
  entry->entry = number;
#line 569
  entry->tag = tag;
#line 570
  entry->children = children;
#line 571
  entry->first_attr = (struct abbrev_attr *)((void *)0);
#line 572
  entry->last_attr = (struct abbrev_attr *)((void *)0);
#line 573
  entry->next = (struct abbrev_entry *)((void *)0);
#line 575
  if ((unsigned long )first_abbrev == (unsigned long )((void *)0)) {
#line 576
    first_abbrev = entry;
  } else {
#line 578
    last_abbrev->next = entry;
  }
#line 580
  last_abbrev = entry;
#line 581
  return;
}
}
#line 583 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void add_abbrev_attr(unsigned long attribute , unsigned long form ) 
{ 
  abbrev_attr *attr ;
  void *tmp___0 ;

  {
  {
#line 588
  tmp___0 = malloc(sizeof(*attr));
#line 588
  attr = (abbrev_attr *)tmp___0;
  }
#line 589
  if ((unsigned long )attr == (unsigned long )((void *)0)) {
#line 591
    return;
  }
#line 593
  attr->attribute = attribute;
#line 594
  attr->form = form;
#line 595
  attr->next = (struct abbrev_attr *)((void *)0);
#line 597
  if ((unsigned long )last_abbrev->first_attr == (unsigned long )((void *)0)) {
#line 598
    last_abbrev->first_attr = attr;
  } else {
#line 600
    (last_abbrev->last_attr)->next = attr;
  }
#line 602
  last_abbrev->last_attr = attr;
#line 603
  return;
}
}
#line 610 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned char *process_abbrev_section(unsigned char *start , unsigned char *end ) 
{ 
  unsigned int bytes_read ;
  unsigned long entry ;
  unsigned long tag ;
  unsigned long attribute ;
  int children ;
  dwarf_vma tmp___0 ;
  unsigned char *tmp___1 ;
  dwarf_vma tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned long form ;
  dwarf_vma tmp___4 ;
  dwarf_vma tmp___5 ;

  {
#line 613
  if ((unsigned long )first_abbrev != (unsigned long )((void *)0)) {
#line 614
    return ((unsigned char *)((void *)0));
  }
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 616
      goto while_break;
    }
    {
#line 624
    tmp___0 = read_leb128(start, & bytes_read, 0);
#line 624
    entry = (unsigned long )tmp___0;
#line 625
    start += bytes_read;
    }
#line 630
    if (entry == 0UL) {
#line 631
      if ((unsigned long )start == (unsigned long )end) {
#line 631
        tmp___1 = (unsigned char *)((void *)0);
      } else {
#line 631
        tmp___1 = start;
      }
#line 631
      return (tmp___1);
    }
    {
#line 633
    tmp___2 = read_leb128(start, & bytes_read, 0);
#line 633
    tag = (unsigned long )tmp___2;
#line 634
    start += bytes_read;
#line 636
    tmp___3 = start;
#line 636
    start ++;
#line 636
    children = (int )*tmp___3;
#line 638
    add_abbrev(entry, tag, children);
    }
    {
#line 640
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 644
      tmp___4 = read_leb128(start, & bytes_read, 0);
#line 644
      attribute = (unsigned long )tmp___4;
#line 645
      start += bytes_read;
#line 647
      tmp___5 = read_leb128(start, & bytes_read, 0);
#line 647
      form = (unsigned long )tmp___5;
#line 648
      start += bytes_read;
      }
#line 650
      if (attribute != 0UL) {
        {
#line 651
        add_abbrev_attr(attribute, form);
        }
      }
#line 640
      if (! (attribute != 0UL)) {
#line 640
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return ((unsigned char *)((void *)0));
}
}
#line 666 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char buffer[100]  ;
#line 659 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *get_TAG_name(unsigned long tag ) 
{ 
  char const   *name___0 ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 662
  tmp___0 = get_DW_TAG_name((unsigned int )tag);
#line 662
  name___0 = tmp___0;
  }
#line 664
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 668
    tmp___1 = gettext("Unknown TAG value: %lx");
#line 668
    snprintf((char */* __restrict  */)(buffer), sizeof(buffer), (char const   */* __restrict  */)tmp___1,
             tag);
    }
#line 669
    return ((char const   *)(buffer));
  }
#line 672
  return (name___0);
}
}
#line 682 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char buffer___0[100]  ;
#line 675 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *get_FORM_name(unsigned long form ) 
{ 
  char const   *name___0 ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 678
  tmp___0 = get_DW_FORM_name((unsigned int )form);
#line 678
  name___0 = tmp___0;
  }
#line 680
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 684
    tmp___1 = gettext("Unknown FORM value: %lx");
#line 684
    snprintf((char */* __restrict  */)(buffer___0), sizeof(buffer___0), (char const   */* __restrict  */)tmp___1,
             form);
    }
#line 685
    return ((char const   *)(buffer___0));
  }
#line 688
  return (name___0);
}
}
#line 691 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned char *display_block(unsigned char *data , dwarf_vma length ) 
{ 
  char const   *tmp___0 ;
  char *tmp___1 ;
  unsigned char *tmp___2 ;
  elf_vma tmp___3 ;
  dwarf_vma tmp___4 ;

  {
  {
#line 694
  tmp___0 = dwarf_vmatoa("u", length);
#line 694
  tmp___1 = gettext(" %s byte block: ");
#line 694
  printf((char const   */* __restrict  */)tmp___1, tmp___0);
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    tmp___4 = length;
#line 696
    length --;
#line 696
    if (! tmp___4) {
#line 696
      goto while_break;
    }
    {
#line 697
    tmp___2 = data;
#line 697
    data ++;
#line 697
    tmp___3 = (*byte_get)(tmp___2, 1);
#line 697
    printf((char const   */* __restrict  */)"%lx ", (unsigned long )tmp___3);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 699
  return (data);
}
}
#line 702 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int decode_location_expression(unsigned char *data , unsigned int pointer_size ,
                                      unsigned int offset_size , int dwarf_version ,
                                      dwarf_vma length , dwarf_vma cu_offset , struct dwarf_section *section ) 
{ 
  unsigned int op ;
  unsigned int bytes_read ;
  dwarf_vma uvalue ;
  unsigned char *end ;
  int need_frame_base ;
  unsigned char *tmp___0 ;
  elf_vma tmp___1 ;
  char const   *tmp___2 ;
  unsigned char *tmp___3 ;
  elf_vma tmp___4 ;
  unsigned char *tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  dwarf_vma tmp___15 ;
  char const   *tmp___16 ;
  dwarf_signed_vma tmp___17 ;
  char const   *tmp___18 ;
  unsigned char *tmp___19 ;
  elf_vma tmp___20 ;
  dwarf_vma tmp___21 ;
  char const   *tmp___22 ;
  elf_vma tmp___23 ;
  elf_vma tmp___24 ;
  char const   *tmp___25 ;
  dwarf_vma tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  dwarf_signed_vma tmp___31 ;
  char const   *tmp___32 ;
  dwarf_signed_vma tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  dwarf_vma tmp___37 ;
  char const   *tmp___38 ;
  unsigned char *tmp___39 ;
  elf_vma tmp___40 ;
  unsigned char *tmp___41 ;
  elf_vma tmp___42 ;
  elf_vma tmp___43 ;
  char const   *tmp___44 ;
  elf_vma tmp___45 ;
  char const   *tmp___46 ;
  char *tmp___47 ;
  elf_vma tmp___48 ;
  char const   *tmp___49 ;
  elf_vma tmp___50 ;
  char const   *tmp___51 ;
  dwarf_vma tmp___52 ;
  char const   *tmp___53 ;
  char *tmp___54 ;
  dwarf_vma tmp___55 ;
  char const   *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  int encoding ;
  dwarf_vma addr ;
  unsigned char *tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  dwarf_signed_vma tmp___62 ;
  char const   *tmp___63 ;
  elf_vma tmp___64 ;
  char const   *tmp___65 ;
  dwarf_signed_vma tmp___66 ;
  char const   *tmp___67 ;
  elf_vma tmp___68 ;
  char const   *tmp___69 ;
  int tmp___70 ;
  char const   *tmp___71 ;
  unsigned char *tmp___72 ;
  char const   *tmp___73 ;
  char const   *tmp___74 ;
  char const   *tmp___75 ;
  unsigned char *tmp___76 ;
  elf_vma tmp___77 ;
  char const   *tmp___78 ;
  dwarf_vma tmp___79 ;
  char const   *tmp___80 ;
  dwarf_vma tmp___81 ;
  char const   *tmp___82 ;
  elf_vma tmp___83 ;
  char const   *tmp___84 ;
  char const   *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;

  {
#line 714
  end = data + length;
#line 715
  need_frame_base = 0;
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 717
      goto while_break;
    }
#line 719
    tmp___0 = data;
#line 719
    data ++;
#line 719
    op = (unsigned int )*tmp___0;
    {
#line 723
    if (op == 3U) {
#line 723
      goto case_3;
    }
#line 728
    if (op == 6U) {
#line 728
      goto case_6;
    }
#line 731
    if (op == 8U) {
#line 731
      goto case_8;
    }
#line 734
    if (op == 9U) {
#line 734
      goto case_9;
    }
#line 737
    if (op == 10U) {
#line 737
      goto case_10;
    }
#line 741
    if (op == 11U) {
#line 741
      goto case_11;
    }
#line 745
    if (op == 12U) {
#line 745
      goto case_12;
    }
#line 749
    if (op == 13U) {
#line 749
      goto case_13;
    }
#line 753
    if (op == 14U) {
#line 753
      goto case_14;
    }
#line 758
    if (op == 15U) {
#line 758
      goto case_15;
    }
#line 763
    if (op == 16U) {
#line 763
      goto case_16;
    }
#line 768
    if (op == 17U) {
#line 768
      goto case_17;
    }
#line 773
    if (op == 18U) {
#line 773
      goto case_18;
    }
#line 776
    if (op == 19U) {
#line 776
      goto case_19;
    }
#line 779
    if (op == 20U) {
#line 779
      goto case_20;
    }
#line 782
    if (op == 21U) {
#line 782
      goto case_21;
    }
#line 785
    if (op == 22U) {
#line 785
      goto case_22;
    }
#line 788
    if (op == 23U) {
#line 788
      goto case_23;
    }
#line 791
    if (op == 24U) {
#line 791
      goto case_24;
    }
#line 794
    if (op == 25U) {
#line 794
      goto case_25;
    }
#line 797
    if (op == 26U) {
#line 797
      goto case_26;
    }
#line 800
    if (op == 27U) {
#line 800
      goto case_27;
    }
#line 803
    if (op == 28U) {
#line 803
      goto case_28;
    }
#line 806
    if (op == 29U) {
#line 806
      goto case_29;
    }
#line 809
    if (op == 30U) {
#line 809
      goto case_30;
    }
#line 812
    if (op == 31U) {
#line 812
      goto case_31;
    }
#line 815
    if (op == 32U) {
#line 815
      goto case_32;
    }
#line 818
    if (op == 33U) {
#line 818
      goto case_33;
    }
#line 821
    if (op == 34U) {
#line 821
      goto case_34;
    }
#line 824
    if (op == 35U) {
#line 824
      goto case_35;
    }
#line 829
    if (op == 36U) {
#line 829
      goto case_36;
    }
#line 832
    if (op == 37U) {
#line 832
      goto case_37;
    }
#line 835
    if (op == 38U) {
#line 835
      goto case_38;
    }
#line 838
    if (op == 39U) {
#line 838
      goto case_39;
    }
#line 841
    if (op == 40U) {
#line 841
      goto case_40;
    }
#line 845
    if (op == 41U) {
#line 845
      goto case_41;
    }
#line 848
    if (op == 42U) {
#line 848
      goto case_42;
    }
#line 851
    if (op == 43U) {
#line 851
      goto case_43;
    }
#line 854
    if (op == 44U) {
#line 854
      goto case_44;
    }
#line 857
    if (op == 45U) {
#line 857
      goto case_45;
    }
#line 860
    if (op == 46U) {
#line 860
      goto case_46;
    }
#line 863
    if (op == 47U) {
#line 863
      goto case_47;
    }
#line 899
    if (op == 79U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 78U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 77U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 76U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 75U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 74U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 73U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 72U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 71U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 70U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 69U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 68U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 67U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 66U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 65U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 64U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 63U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 62U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 61U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 60U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 59U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 58U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 57U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 56U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 55U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 54U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 53U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 52U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 51U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 50U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 49U) {
#line 899
      goto case_79;
    }
#line 899
    if (op == 48U) {
#line 899
      goto case_79;
    }
#line 934
    if (op == 111U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 110U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 109U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 108U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 107U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 106U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 105U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 104U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 103U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 102U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 101U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 100U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 99U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 98U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 97U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 96U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 95U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 94U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 93U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 92U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 91U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 90U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 89U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 88U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 87U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 86U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 85U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 84U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 83U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 82U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 81U) {
#line 934
      goto case_111;
    }
#line 934
    if (op == 80U) {
#line 934
      goto case_111;
    }
#line 970
    if (op == 143U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 142U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 141U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 140U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 139U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 138U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 137U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 136U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 135U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 134U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 133U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 132U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 131U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 130U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 129U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 128U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 127U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 126U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 125U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 124U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 123U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 122U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 121U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 120U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 119U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 118U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 117U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 116U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 115U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 114U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 113U) {
#line 970
      goto case_143;
    }
#line 970
    if (op == 112U) {
#line 970
      goto case_143;
    }
#line 979
    if (op == 144U) {
#line 979
      goto case_144;
    }
#line 985
    if (op == 145U) {
#line 985
      goto case_145;
    }
#line 991
    if (op == 146U) {
#line 991
      goto case_146;
    }
#line 999
    if (op == 147U) {
#line 999
      goto case_147;
    }
#line 1004
    if (op == 148U) {
#line 1004
      goto case_148;
    }
#line 1007
    if (op == 149U) {
#line 1007
      goto case_149;
    }
#line 1010
    if (op == 150U) {
#line 1010
      goto case_150;
    }
#line 1015
    if (op == 151U) {
#line 1015
      goto case_151;
    }
#line 1018
    if (op == 152U) {
#line 1018
      goto case_152;
    }
#line 1026
    if (op == 153U) {
#line 1026
      goto case_153;
    }
#line 1034
    if (op == 154U) {
#line 1034
      goto case_154;
    }
#line 1056
    if (op == 155U) {
#line 1056
      goto case_155;
    }
#line 1059
    if (op == 156U) {
#line 1059
      goto case_156;
    }
#line 1062
    if (op == 157U) {
#line 1062
      goto case_157;
    }
#line 1073
    if (op == 159U) {
#line 1073
      goto case_159;
    }
#line 1077
    if (op == 158U) {
#line 1077
      goto case_158;
    }
#line 1086
    if (op == 224U) {
#line 1086
      goto case_224;
    }
#line 1089
    if (op == 240U) {
#line 1089
      goto case_240;
    }
#line 1093
    if (op == 241U) {
#line 1093
      goto case_241;
    }
#line 1106
    if (op == 242U) {
#line 1106
      goto case_242;
    }
#line 1132
    if (op == 243U) {
#line 1132
      goto case_243;
    }
#line 1143
    if (op == 244U) {
#line 1143
      goto case_244;
    }
#line 1152
    if (op == 245U) {
#line 1152
      goto case_245;
    }
#line 1161
    if (op == 246U) {
#line 1161
      goto case_246;
    }
#line 1167
    if (op == 247U) {
#line 1167
      goto case_247;
    }
#line 1173
    if (op == 249U) {
#line 1173
      goto case_249;
    }
#line 1179
    if (op == 250U) {
#line 1179
      goto case_250;
    }
#line 1184
    if (op == 251U) {
#line 1184
      goto case_251;
    }
#line 1191
    if (op == 225U) {
#line 1191
      goto case_225;
    }
#line 1195
    if (op == 226U) {
#line 1195
      goto case_226;
    }
#line 1199
    if (op == 227U) {
#line 1199
      goto case_227;
    }
#line 1203
    if (op == 228U) {
#line 1203
      goto case_228;
    }
#line 1207
    if (op == 229U) {
#line 1207
      goto case_229;
    }
#line 1211
    if (op == 230U) {
#line 1211
      goto case_230;
    }
#line 1217
    if (op == 248U) {
#line 1217
      goto case_248;
    }
#line 1225
    goto switch_default;
    case_3: /* CIL Label */ 
    {
#line 724
    tmp___1 = (*byte_get)(data, (int )pointer_size);
#line 724
    tmp___2 = dwarf_vmatoa("x", tmp___1);
#line 724
    printf((char const   */* __restrict  */)"DW_OP_addr: %s", tmp___2);
#line 726
    data += pointer_size;
    }
#line 727
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 729
    printf((char const   */* __restrict  */)"DW_OP_deref");
    }
#line 730
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 732
    tmp___3 = data;
#line 732
    data ++;
#line 732
    tmp___4 = (*byte_get)(tmp___3, 1);
#line 732
    printf((char const   */* __restrict  */)"DW_OP_const1u: %lu", (unsigned long )tmp___4);
    }
#line 733
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 735
    tmp___5 = data;
#line 735
    data ++;
#line 735
    tmp___6 = byte_get_signed(tmp___5, 1);
#line 735
    printf((char const   */* __restrict  */)"DW_OP_const1s: %ld", (long )tmp___6);
    }
#line 736
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 738
    tmp___7 = (*byte_get)(data, 2);
#line 738
    printf((char const   */* __restrict  */)"DW_OP_const2u: %lu", (unsigned long )tmp___7);
#line 739
    data += 2;
    }
#line 740
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 742
    tmp___8 = byte_get_signed(data, 2);
#line 742
    printf((char const   */* __restrict  */)"DW_OP_const2s: %ld", (long )tmp___8);
#line 743
    data += 2;
    }
#line 744
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 746
    tmp___9 = (*byte_get)(data, 4);
#line 746
    printf((char const   */* __restrict  */)"DW_OP_const4u: %lu", (unsigned long )tmp___9);
#line 747
    data += 4;
    }
#line 748
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 750
    tmp___10 = byte_get_signed(data, 4);
#line 750
    printf((char const   */* __restrict  */)"DW_OP_const4s: %ld", (long )tmp___10);
#line 751
    data += 4;
    }
#line 752
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 754
    tmp___11 = (*byte_get)(data + 4, 4);
#line 754
    tmp___12 = (*byte_get)(data, 4);
#line 754
    printf((char const   */* __restrict  */)"DW_OP_const8u: %lu %lu", (unsigned long )tmp___12,
           (unsigned long )tmp___11);
#line 756
    data += 8;
    }
#line 757
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 759
    tmp___13 = (*byte_get)(data + 4, 4);
#line 759
    tmp___14 = (*byte_get)(data, 4);
#line 759
    printf((char const   */* __restrict  */)"DW_OP_const8s: %ld %ld", (long )tmp___14,
           (long )tmp___13);
#line 761
    data += 8;
    }
#line 762
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 764
    tmp___15 = read_leb128(data, & bytes_read, 0);
#line 764
    tmp___16 = dwarf_vmatoa("u", tmp___15);
#line 764
    printf((char const   */* __restrict  */)"DW_OP_constu: %s", tmp___16);
#line 766
    data += bytes_read;
    }
#line 767
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 769
    tmp___17 = read_sleb128(data, & bytes_read);
#line 769
    tmp___18 = dwarf_vmatoa("d", (dwarf_vma )tmp___17);
#line 769
    printf((char const   */* __restrict  */)"DW_OP_consts: %s", tmp___18);
#line 771
    data += bytes_read;
    }
#line 772
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 774
    printf((char const   */* __restrict  */)"DW_OP_dup");
    }
#line 775
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 777
    printf((char const   */* __restrict  */)"DW_OP_drop");
    }
#line 778
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 780
    printf((char const   */* __restrict  */)"DW_OP_over");
    }
#line 781
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 783
    tmp___19 = data;
#line 783
    data ++;
#line 783
    tmp___20 = (*byte_get)(tmp___19, 1);
#line 783
    printf((char const   */* __restrict  */)"DW_OP_pick: %ld", (unsigned long )tmp___20);
    }
#line 784
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 786
    printf((char const   */* __restrict  */)"DW_OP_swap");
    }
#line 787
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 789
    printf((char const   */* __restrict  */)"DW_OP_rot");
    }
#line 790
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 792
    printf((char const   */* __restrict  */)"DW_OP_xderef");
    }
#line 793
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 795
    printf((char const   */* __restrict  */)"DW_OP_abs");
    }
#line 796
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 798
    printf((char const   */* __restrict  */)"DW_OP_and");
    }
#line 799
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 801
    printf((char const   */* __restrict  */)"DW_OP_div");
    }
#line 802
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 804
    printf((char const   */* __restrict  */)"DW_OP_minus");
    }
#line 805
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 807
    printf((char const   */* __restrict  */)"DW_OP_mod");
    }
#line 808
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 810
    printf((char const   */* __restrict  */)"DW_OP_mul");
    }
#line 811
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 813
    printf((char const   */* __restrict  */)"DW_OP_neg");
    }
#line 814
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 816
    printf((char const   */* __restrict  */)"DW_OP_not");
    }
#line 817
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 819
    printf((char const   */* __restrict  */)"DW_OP_or");
    }
#line 820
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 822
    printf((char const   */* __restrict  */)"DW_OP_plus");
    }
#line 823
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 825
    tmp___21 = read_leb128(data, & bytes_read, 0);
#line 825
    tmp___22 = dwarf_vmatoa("u", tmp___21);
#line 825
    printf((char const   */* __restrict  */)"DW_OP_plus_uconst: %s", tmp___22);
#line 827
    data += bytes_read;
    }
#line 828
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 830
    printf((char const   */* __restrict  */)"DW_OP_shl");
    }
#line 831
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 833
    printf((char const   */* __restrict  */)"DW_OP_shr");
    }
#line 834
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 836
    printf((char const   */* __restrict  */)"DW_OP_shra");
    }
#line 837
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 839
    printf((char const   */* __restrict  */)"DW_OP_xor");
    }
#line 840
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 842
    tmp___23 = byte_get_signed(data, 2);
#line 842
    printf((char const   */* __restrict  */)"DW_OP_bra: %ld", (long )tmp___23);
#line 843
    data += 2;
    }
#line 844
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 846
    printf((char const   */* __restrict  */)"DW_OP_eq");
    }
#line 847
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 849
    printf((char const   */* __restrict  */)"DW_OP_ge");
    }
#line 850
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 852
    printf((char const   */* __restrict  */)"DW_OP_gt");
    }
#line 853
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 855
    printf((char const   */* __restrict  */)"DW_OP_le");
    }
#line 856
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 858
    printf((char const   */* __restrict  */)"DW_OP_lt");
    }
#line 859
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 861
    printf((char const   */* __restrict  */)"DW_OP_ne");
    }
#line 862
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 864
    tmp___24 = byte_get_signed(data, 2);
#line 864
    printf((char const   */* __restrict  */)"DW_OP_skip: %ld", (long )tmp___24);
#line 865
    data += 2;
    }
#line 866
    goto switch_break;
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_61: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 900
    printf((char const   */* __restrict  */)"DW_OP_lit%d", op - 48U);
    }
#line 901
    goto switch_break;
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    {
#line 935
    tmp___25 = regname(op - 80U, 1);
#line 935
    printf((char const   */* __restrict  */)"DW_OP_reg%d (%s)", op - 80U, tmp___25);
    }
#line 937
    goto switch_break;
    case_143: /* CIL Label */ 
    case_142: /* CIL Label */ 
    case_141: /* CIL Label */ 
    case_140: /* CIL Label */ 
    case_139: /* CIL Label */ 
    case_138: /* CIL Label */ 
    case_137: /* CIL Label */ 
    case_136: /* CIL Label */ 
    case_135: /* CIL Label */ 
    case_134: /* CIL Label */ 
    case_133: /* CIL Label */ 
    case_132: /* CIL Label */ 
    case_131: /* CIL Label */ 
    case_130: /* CIL Label */ 
    case_129: /* CIL Label */ 
    case_128: /* CIL Label */ 
    case_127: /* CIL Label */ 
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    {
#line 971
    tmp___26 = read_leb128(data, & bytes_read, 1);
#line 971
    tmp___27 = dwarf_vmatoa("d", (dwarf_vma )((dwarf_signed_vma )tmp___26));
#line 971
    tmp___28 = regname(op - 112U, 1);
#line 971
    printf((char const   */* __restrict  */)"DW_OP_breg%d (%s): %s", op - 112U, tmp___28,
           tmp___27);
#line 976
    data += bytes_read;
    }
#line 977
    goto switch_break;
    case_144: /* CIL Label */ 
    {
#line 980
    uvalue = read_leb128(data, & bytes_read, 0);
#line 981
    data += bytes_read;
#line 982
    tmp___29 = regname((unsigned int )uvalue, 1);
#line 982
    tmp___30 = dwarf_vmatoa("u", uvalue);
#line 982
    printf((char const   */* __restrict  */)"DW_OP_regx: %s (%s)", tmp___30, tmp___29);
    }
#line 984
    goto switch_break;
    case_145: /* CIL Label */ 
    {
#line 986
    need_frame_base = 1;
#line 987
    tmp___31 = read_sleb128(data, & bytes_read);
#line 987
    tmp___32 = dwarf_vmatoa("d", (dwarf_vma )tmp___31);
#line 987
    printf((char const   */* __restrict  */)"DW_OP_fbreg: %s", tmp___32);
#line 989
    data += bytes_read;
    }
#line 990
    goto switch_break;
    case_146: /* CIL Label */ 
    {
#line 992
    uvalue = read_leb128(data, & bytes_read, 0);
#line 993
    data += bytes_read;
#line 994
    tmp___33 = read_sleb128(data, & bytes_read);
#line 994
    tmp___34 = dwarf_vmatoa("d", (dwarf_vma )tmp___33);
#line 994
    tmp___35 = regname((unsigned int )uvalue, 1);
#line 994
    tmp___36 = dwarf_vmatoa("u", uvalue);
#line 994
    printf((char const   */* __restrict  */)"DW_OP_bregx: %s (%s) %s", tmp___36, tmp___35,
           tmp___34);
#line 997
    data += bytes_read;
    }
#line 998
    goto switch_break;
    case_147: /* CIL Label */ 
    {
#line 1000
    tmp___37 = read_leb128(data, & bytes_read, 0);
#line 1000
    tmp___38 = dwarf_vmatoa("u", tmp___37);
#line 1000
    printf((char const   */* __restrict  */)"DW_OP_piece: %s", tmp___38);
#line 1002
    data += bytes_read;
    }
#line 1003
    goto switch_break;
    case_148: /* CIL Label */ 
    {
#line 1005
    tmp___39 = data;
#line 1005
    data ++;
#line 1005
    tmp___40 = (*byte_get)(tmp___39, 1);
#line 1005
    printf((char const   */* __restrict  */)"DW_OP_deref_size: %ld", (long )tmp___40);
    }
#line 1006
    goto switch_break;
    case_149: /* CIL Label */ 
    {
#line 1008
    tmp___41 = data;
#line 1008
    data ++;
#line 1008
    tmp___42 = (*byte_get)(tmp___41, 1);
#line 1008
    printf((char const   */* __restrict  */)"DW_OP_xderef_size: %ld", (long )tmp___42);
    }
#line 1009
    goto switch_break;
    case_150: /* CIL Label */ 
    {
#line 1011
    printf((char const   */* __restrict  */)"DW_OP_nop");
    }
#line 1012
    goto switch_break;
    case_151: /* CIL Label */ 
    {
#line 1016
    printf((char const   */* __restrict  */)"DW_OP_push_object_address");
    }
#line 1017
    goto switch_break;
    case_152: /* CIL Label */ 
    {
#line 1021
    tmp___43 = (*byte_get)(data, 2);
#line 1021
    tmp___44 = dwarf_vmatoa("x", (dwarf_vma )((dwarf_signed_vma )tmp___43) + cu_offset);
#line 1021
    printf((char const   */* __restrict  */)"DW_OP_call2: <0x%s>", tmp___44);
#line 1024
    data += 2;
    }
#line 1025
    goto switch_break;
    case_153: /* CIL Label */ 
    {
#line 1029
    tmp___45 = (*byte_get)(data, 4);
#line 1029
    tmp___46 = dwarf_vmatoa("x", (dwarf_vma )((dwarf_signed_vma )tmp___45) + cu_offset);
#line 1029
    printf((char const   */* __restrict  */)"DW_OP_call4: <0x%s>", tmp___46);
#line 1032
    data += 4;
    }
#line 1033
    goto switch_break;
    case_154: /* CIL Label */ 
#line 1037
    if (dwarf_version == -1) {
      {
#line 1039
      tmp___47 = gettext("(DW_OP_call_ref in frame info)");
#line 1039
      printf((char const   */* __restrict  */)tmp___47);
      }
#line 1041
      return (need_frame_base);
    }
#line 1043
    if (dwarf_version == 2) {
      {
#line 1045
      tmp___48 = (*byte_get)(data, (int )pointer_size);
#line 1045
      tmp___49 = dwarf_vmatoa("x", tmp___48);
#line 1045
      printf((char const   */* __restrict  */)"DW_OP_call_ref: <0x%s>", tmp___49);
#line 1047
      data += pointer_size;
      }
    } else {
      {
#line 1051
      tmp___50 = (*byte_get)(data, (int )offset_size);
#line 1051
      tmp___51 = dwarf_vmatoa("x", tmp___50);
#line 1051
      printf((char const   */* __restrict  */)"DW_OP_call_ref: <0x%s>", tmp___51);
#line 1053
      data += offset_size;
      }
    }
#line 1055
    goto switch_break;
    case_155: /* CIL Label */ 
    {
#line 1057
    printf((char const   */* __restrict  */)"DW_OP_form_tls_address");
    }
#line 1058
    goto switch_break;
    case_156: /* CIL Label */ 
    {
#line 1060
    printf((char const   */* __restrict  */)"DW_OP_call_frame_cfa");
    }
#line 1061
    goto switch_break;
    case_157: /* CIL Label */ 
    {
#line 1063
    printf((char const   */* __restrict  */)"DW_OP_bit_piece: ");
#line 1064
    tmp___52 = read_leb128(data, & bytes_read, 0);
#line 1064
    tmp___53 = dwarf_vmatoa("u", tmp___52);
#line 1064
    tmp___54 = gettext("size: %s ");
#line 1064
    printf((char const   */* __restrict  */)tmp___54, tmp___53);
#line 1066
    data += bytes_read;
#line 1067
    tmp___55 = read_leb128(data, & bytes_read, 0);
#line 1067
    tmp___56 = dwarf_vmatoa("u", tmp___55);
#line 1067
    tmp___57 = gettext("offset: %s ");
#line 1067
    printf((char const   */* __restrict  */)tmp___57, tmp___56);
#line 1069
    data += bytes_read;
    }
#line 1070
    goto switch_break;
    case_159: /* CIL Label */ 
    {
#line 1074
    printf((char const   */* __restrict  */)"DW_OP_stack_value");
    }
#line 1075
    goto switch_break;
    case_158: /* CIL Label */ 
    {
#line 1078
    printf((char const   */* __restrict  */)"DW_OP_implicit_value");
#line 1079
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1080
    data += bytes_read;
#line 1081
    display_block(data, uvalue);
#line 1082
    data += uvalue;
    }
#line 1083
    goto switch_break;
    case_224: /* CIL Label */ 
    {
#line 1087
    tmp___58 = gettext("DW_OP_GNU_push_tls_address or DW_OP_HP_unknown");
#line 1087
    printf((char const   */* __restrict  */)tmp___58);
    }
#line 1088
    goto switch_break;
    case_240: /* CIL Label */ 
    {
#line 1090
    printf((char const   */* __restrict  */)"DW_OP_GNU_uninit");
    }
#line 1092
    goto switch_break;
    case_241: /* CIL Label */ 
    {
#line 1098
    tmp___59 = data;
#line 1098
    data ++;
#line 1098
    encoding = (int )*tmp___59;
#line 1099
    addr = get_encoded_value(data, encoding, section);
#line 1100
    tmp___60 = size_of_encoded_value(encoding);
#line 1100
    data += tmp___60;
#line 1102
    printf((char const   */* __restrict  */)"DW_OP_GNU_encoded_addr: fmt:%02x addr:",
           encoding);
#line 1103
    print_dwarf_vma(addr, pointer_size);
    }
#line 1105
    goto switch_break;
    case_242: /* CIL Label */ 
#line 1109
    if (dwarf_version == -1) {
      {
#line 1111
      tmp___61 = gettext("(DW_OP_GNU_implicit_pointer in frame info)");
#line 1111
      printf((char const   */* __restrict  */)tmp___61);
      }
#line 1113
      return (need_frame_base);
    }
#line 1115
    if (dwarf_version == 2) {
      {
#line 1117
      tmp___62 = read_sleb128(data + pointer_size, & bytes_read);
#line 1117
      tmp___63 = dwarf_vmatoa("d", (dwarf_vma )tmp___62);
#line 1117
      tmp___64 = (*byte_get)(data, (int )pointer_size);
#line 1117
      tmp___65 = dwarf_vmatoa("x", tmp___64);
#line 1117
      printf((char const   */* __restrict  */)"DW_OP_GNU_implicit_pointer: <0x%s> %s",
             tmp___65, tmp___63);
#line 1121
      data += pointer_size + bytes_read;
      }
    } else {
      {
#line 1125
      tmp___66 = read_sleb128(data + offset_size, & bytes_read);
#line 1125
      tmp___67 = dwarf_vmatoa("d", (dwarf_vma )tmp___66);
#line 1125
      tmp___68 = (*byte_get)(data, (int )offset_size);
#line 1125
      tmp___69 = dwarf_vmatoa("x", tmp___68);
#line 1125
      printf((char const   */* __restrict  */)"DW_OP_GNU_implicit_pointer: <0x%s> %s",
             tmp___69, tmp___67);
#line 1129
      data += offset_size + bytes_read;
      }
    }
#line 1131
    goto switch_break;
    case_243: /* CIL Label */ 
    {
#line 1133
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1134
    data += bytes_read;
#line 1135
    printf((char const   */* __restrict  */)"DW_OP_GNU_entry_value: (");
#line 1136
    tmp___70 = decode_location_expression(data, pointer_size, offset_size, dwarf_version,
                                          uvalue, cu_offset, section);
    }
#line 1136
    if (tmp___70) {
#line 1139
      need_frame_base = 1;
    }
    {
#line 1140
    putchar(')');
#line 1141
    data += uvalue;
    }
#line 1142
    goto switch_break;
    case_244: /* CIL Label */ 
    {
#line 1144
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1145
    data += bytes_read;
#line 1146
    tmp___71 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1146
    printf((char const   */* __restrict  */)"DW_OP_GNU_const_type: <0x%s> ", tmp___71);
#line 1148
    tmp___72 = data;
#line 1148
    data ++;
#line 1148
    uvalue = (*byte_get)(tmp___72, 1);
#line 1149
    display_block(data, uvalue);
#line 1150
    data += uvalue;
    }
#line 1151
    goto switch_break;
    case_245: /* CIL Label */ 
    {
#line 1153
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1154
    data += bytes_read;
#line 1155
    tmp___73 = regname((unsigned int )uvalue, 1);
#line 1155
    tmp___74 = dwarf_vmatoa("u", uvalue);
#line 1155
    printf((char const   */* __restrict  */)"DW_OP_GNU_regval_type: %s (%s)", tmp___74,
           tmp___73);
#line 1157
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1158
    data += bytes_read;
#line 1159
    tmp___75 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1159
    printf((char const   */* __restrict  */)" <0x%s>", tmp___75);
    }
#line 1160
    goto switch_break;
    case_246: /* CIL Label */ 
    {
#line 1162
    tmp___76 = data;
#line 1162
    data ++;
#line 1162
    tmp___77 = (*byte_get)(tmp___76, 1);
#line 1162
    printf((char const   */* __restrict  */)"DW_OP_GNU_deref_type: %ld", (long )tmp___77);
#line 1163
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1164
    data += bytes_read;
#line 1165
    tmp___78 = dwarf_vmatoa("x", cu_offset + uvalue);
#line 1165
    printf((char const   */* __restrict  */)" <0x%s>", tmp___78);
    }
#line 1166
    goto switch_break;
    case_247: /* CIL Label */ 
    {
#line 1168
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1169
    data += bytes_read;
    }
#line 1170
    if (uvalue) {
#line 1170
      tmp___79 = cu_offset + uvalue;
    } else {
#line 1170
      tmp___79 = (dwarf_vma )0;
    }
    {
#line 1170
    tmp___80 = dwarf_vmatoa("x", tmp___79);
#line 1170
    printf((char const   */* __restrict  */)"DW_OP_GNU_convert <0x%s>", tmp___80);
    }
#line 1172
    goto switch_break;
    case_249: /* CIL Label */ 
    {
#line 1174
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1175
    data += bytes_read;
    }
#line 1176
    if (uvalue) {
#line 1176
      tmp___81 = cu_offset + uvalue;
    } else {
#line 1176
      tmp___81 = (dwarf_vma )0;
    }
    {
#line 1176
    tmp___82 = dwarf_vmatoa("x", tmp___81);
#line 1176
    printf((char const   */* __restrict  */)"DW_OP_GNU_reinterpret <0x%s>", tmp___82);
    }
#line 1178
    goto switch_break;
    case_250: /* CIL Label */ 
    {
#line 1180
    tmp___83 = (*byte_get)(data, 4);
#line 1180
    tmp___84 = dwarf_vmatoa("x", cu_offset + tmp___83);
#line 1180
    printf((char const   */* __restrict  */)"DW_OP_GNU_parameter_ref: <0x%s>", tmp___84);
#line 1182
    data += 4;
    }
#line 1183
    goto switch_break;
    case_251: /* CIL Label */ 
    {
#line 1185
    uvalue = read_leb128(data, & bytes_read, 0);
#line 1186
    data += bytes_read;
#line 1187
    tmp___85 = dwarf_vmatoa("x", uvalue);
#line 1187
    printf((char const   */* __restrict  */)"DW_OP_GNU_addr_index <0x%s>", tmp___85);
    }
#line 1188
    goto switch_break;
    case_225: /* CIL Label */ 
    {
#line 1192
    printf((char const   */* __restrict  */)"DW_OP_HP_is_value");
    }
#line 1194
    goto switch_break;
    case_226: /* CIL Label */ 
    {
#line 1196
    printf((char const   */* __restrict  */)"DW_OP_HP_fltconst4");
    }
#line 1198
    goto switch_break;
    case_227: /* CIL Label */ 
    {
#line 1200
    printf((char const   */* __restrict  */)"DW_OP_HP_fltconst8");
    }
#line 1202
    goto switch_break;
    case_228: /* CIL Label */ 
    {
#line 1204
    printf((char const   */* __restrict  */)"DW_OP_HP_mod_range");
    }
#line 1206
    goto switch_break;
    case_229: /* CIL Label */ 
    {
#line 1208
    printf((char const   */* __restrict  */)"DW_OP_HP_unmod_range");
    }
#line 1210
    goto switch_break;
    case_230: /* CIL Label */ 
    {
#line 1212
    printf((char const   */* __restrict  */)"DW_OP_HP_tls");
    }
#line 1214
    goto switch_break;
    case_248: /* CIL Label */ 
    {
#line 1222
    printf((char const   */* __restrict  */)"DW_OP_PGI_omp_thread_num");
    }
#line 1223
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1226
    if (op >= 224U) {
#line 1226
      if (op <= 255U) {
        {
#line 1228
        tmp___86 = gettext("(User defined location op)");
#line 1228
        printf((char const   */* __restrict  */)tmp___86);
        }
      } else {
        {
#line 1230
        tmp___87 = gettext("(Unknown location op)");
#line 1230
        printf((char const   */* __restrict  */)tmp___87);
        }
      }
    } else {
      {
#line 1230
      tmp___87 = gettext("(Unknown location op)");
#line 1230
      printf((char const   */* __restrict  */)tmp___87);
      }
    }
#line 1232
    return (need_frame_base);
    switch_break: /* CIL Label */ ;
    }
#line 1236
    if ((unsigned long )data < (unsigned long )end) {
      {
#line 1237
      printf((char const   */* __restrict  */)"; ");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1240
  return (need_frame_base);
}
}
#line 1243 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned char *read_and_display_attr_value(unsigned long attribute , unsigned long form ,
                                                  unsigned char *data , dwarf_vma cu_offset ,
                                                  dwarf_vma pointer_size , dwarf_vma offset_size ,
                                                  int dwarf_version , debug_info *debug_info_p ,
                                                  int do_loc , struct dwarf_section *section ) 
{ 
  dwarf_vma uvalue ;
  unsigned char *block_start ;
  unsigned char *orig_data ;
  unsigned int bytes_read ;
  char *tmp___0 ;
  unsigned char *tmp___1 ;
  dwarf_vma tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  dwarf_vma high_bits ;
  char buf___4[64] ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  size_t tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char const   *suffix ;
  char *tmp___16 ;
  int dwo ;
  int tmp___17 ;
  int tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  dwarf_vma high_bits___0 ;
  char buf___5[64] ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  unsigned int lmax ;
  unsigned int num ;
  void *tmp___29 ;
  void *tmp___30 ;
  unsigned int lmax___0 ;
  unsigned int num___0 ;
  void *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char const   *tmp___36 ;
  char *tmp___37 ;
  char const   *tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  int need_frame_base ;
  char *tmp___52 ;
  char const   *tmp___53 ;
  char *tmp___54 ;
  unsigned long abbrev_number ;
  abbrev_entry *entry ;
  dwarf_vma tmp___55 ;
  char *tmp___56 ;
  char const   *tmp___57 ;

  {
#line 1255
  uvalue = (dwarf_vma )0;
#line 1256
  block_start = (unsigned char *)((void *)0);
#line 1257
  orig_data = data;
  {
#line 1265
  if (form == 16UL) {
#line 1265
    goto case_16;
  }
#line 1281
  if (form == 1UL) {
#line 1281
    goto case_1;
  }
#line 1289
  if (form == 7969UL) {
#line 1289
    goto case_7969;
  }
#line 1289
  if (form == 7968UL) {
#line 1289
    goto case_7969;
  }
#line 1289
  if (form == 23UL) {
#line 1289
    goto case_7969;
  }
#line 1289
  if (form == 14UL) {
#line 1289
    goto case_7969;
  }
#line 1294
  if (form == 25UL) {
#line 1294
    goto case_25;
  }
#line 1300
  if (form == 11UL) {
#line 1300
    goto case_11;
  }
#line 1300
  if (form == 12UL) {
#line 1300
    goto case_11;
  }
#line 1300
  if (form == 17UL) {
#line 1300
    goto case_11;
  }
#line 1305
  if (form == 5UL) {
#line 1305
    goto case_5;
  }
#line 1305
  if (form == 18UL) {
#line 1305
    goto case_5;
  }
#line 1311
  if (form == 6UL) {
#line 1311
    goto case_6;
  }
#line 1311
  if (form == 19UL) {
#line 1311
    goto case_6;
  }
#line 1316
  if (form == 13UL) {
#line 1316
    goto case_13;
  }
#line 1321
  if (form == 7938UL) {
#line 1321
    goto case_7938;
  }
#line 1327
  if (form == 15UL) {
#line 1327
    goto case_15;
  }
#line 1327
  if (form == 21UL) {
#line 1327
    goto case_15;
  }
#line 1332
  if (form == 22UL) {
#line 1332
    goto case_22;
  }
#line 1342
  if (form == 7937UL) {
#line 1342
    goto case_7937;
  }
#line 1262
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1263
  goto switch_break;
  case_16: /* CIL Label */ 
#line 1266
  if (dwarf_version == 2) {
    {
#line 1268
    uvalue = (*byte_get)(data, (int )pointer_size);
#line 1269
    data += pointer_size;
    }
  } else
#line 1271
  if (dwarf_version == 3) {
    {
#line 1273
    uvalue = (*byte_get)(data, (int )offset_size);
#line 1274
    data += offset_size;
    }
  } else
#line 1271
  if (dwarf_version == 4) {
    {
#line 1273
    uvalue = (*byte_get)(data, (int )offset_size);
#line 1274
    data += offset_size;
    }
  } else {
    {
#line 1277
    tmp___0 = gettext("Internal error: DWARF version is not 2, 3 or 4.\n");
#line 1277
    error((char const   *)tmp___0);
    }
  }
#line 1279
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1282
  uvalue = (*byte_get)(data, (int )pointer_size);
#line 1283
  data += pointer_size;
  }
#line 1284
  goto switch_break;
  case_7969: /* CIL Label */ 
  case_7968: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_14: /* CIL Label */ 
  {
#line 1290
  uvalue = (*byte_get)(data, (int )offset_size);
#line 1291
  data += offset_size;
  }
#line 1292
  goto switch_break;
  case_25: /* CIL Label */ 
#line 1295
  uvalue = (dwarf_vma )1;
#line 1296
  goto switch_break;
  case_11: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_17: /* CIL Label */ 
  {
#line 1301
  tmp___1 = data;
#line 1301
  data ++;
#line 1301
  uvalue = (*byte_get)(tmp___1, 1);
  }
#line 1302
  goto switch_break;
  case_5: /* CIL Label */ 
  case_18: /* CIL Label */ 
  {
#line 1306
  uvalue = (*byte_get)(data, 2);
#line 1307
  data += 2;
  }
#line 1308
  goto switch_break;
  case_6: /* CIL Label */ 
  case_19: /* CIL Label */ 
  {
#line 1312
  uvalue = (*byte_get)(data, 4);
#line 1313
  data += 4;
  }
#line 1314
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 1317
  uvalue = read_leb128(data, & bytes_read, 1);
#line 1318
  data += bytes_read;
  }
#line 1319
  goto switch_break;
  case_7938: /* CIL Label */ 
  {
#line 1322
  uvalue = read_leb128(data, & bytes_read, 0);
#line 1323
  data += bytes_read;
  }
#line 1324
  goto switch_break;
  case_15: /* CIL Label */ 
  case_21: /* CIL Label */ 
  {
#line 1328
  uvalue = read_leb128(data, & bytes_read, 0);
#line 1329
  data += bytes_read;
  }
#line 1330
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 1333
  tmp___2 = read_leb128(data, & bytes_read, 0);
#line 1333
  form = (unsigned long )tmp___2;
#line 1334
  data += bytes_read;
  }
#line 1335
  if (! do_loc) {
    {
#line 1336
    tmp___3 = get_FORM_name(form);
#line 1336
    printf((char const   */* __restrict  */)" %s", tmp___3);
    }
  }
  {
#line 1337
  tmp___4 = read_and_display_attr_value(attribute, form, data, cu_offset, pointer_size,
                                        offset_size, dwarf_version, debug_info_p,
                                        do_loc, section);
  }
#line 1337
  return (tmp___4);
  case_7937: /* CIL Label */ 
  {
#line 1343
  uvalue = read_leb128(data, & bytes_read, 0);
#line 1344
  data += bytes_read;
  }
#line 1345
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1350
  if (form == 16UL) {
#line 1350
    goto case_16___0;
  }
#line 1355
  if (form == 7968UL) {
#line 1355
    goto case_7968___0;
  }
#line 1363
  if (form == 21UL) {
#line 1363
    goto case_21___0;
  }
#line 1363
  if (form == 19UL) {
#line 1363
    goto case_21___0;
  }
#line 1363
  if (form == 18UL) {
#line 1363
    goto case_21___0;
  }
#line 1363
  if (form == 17UL) {
#line 1363
    goto case_21___0;
  }
#line 1370
  if (form == 23UL) {
#line 1370
    goto case_23___0;
  }
#line 1370
  if (form == 1UL) {
#line 1370
    goto case_23___0;
  }
#line 1370
  if (form == 6UL) {
#line 1370
    goto case_23___0;
  }
#line 1380
  if (form == 15UL) {
#line 1380
    goto case_15___0;
  }
#line 1380
  if (form == 13UL) {
#line 1380
    goto case_15___0;
  }
#line 1380
  if (form == 5UL) {
#line 1380
    goto case_15___0;
  }
#line 1380
  if (form == 11UL) {
#line 1380
    goto case_15___0;
  }
#line 1380
  if (form == 12UL) {
#line 1380
    goto case_15___0;
  }
#line 1380
  if (form == 25UL) {
#line 1380
    goto case_15___0;
  }
#line 1386
  if (form == 7UL) {
#line 1386
    goto case_7;
  }
#line 1386
  if (form == 20UL) {
#line 1386
    goto case_7;
  }
#line 1407
  if (form == 8UL) {
#line 1407
    goto case_8;
  }
#line 1414
  if (form == 24UL) {
#line 1414
    goto case_24;
  }
#line 1414
  if (form == 9UL) {
#line 1414
    goto case_24;
  }
#line 1423
  if (form == 10UL) {
#line 1423
    goto case_10;
  }
#line 1432
  if (form == 3UL) {
#line 1432
    goto case_3;
  }
#line 1441
  if (form == 4UL) {
#line 1441
    goto case_4;
  }
#line 1450
  if (form == 14UL) {
#line 1450
    goto case_14___0;
  }
#line 1457
  if (form == 7938UL) {
#line 1457
    goto case_7938___0;
  }
#line 1469
  if (form == 7969UL) {
#line 1469
    goto case_7969___0;
  }
#line 1475
  if (form == 22UL) {
#line 1475
    goto case_22___0;
  }
#line 1479
  if (form == 32UL) {
#line 1479
    goto case_32;
  }
#line 1492
  if (form == 7937UL) {
#line 1492
    goto case_7937___0;
  }
#line 1499
  goto switch_default___0;
  case_16___0: /* CIL Label */ 
#line 1351
  if (! do_loc) {
    {
#line 1352
    tmp___5 = dwarf_vmatoa("x", uvalue);
#line 1352
    printf((char const   */* __restrict  */)" <0x%s>", tmp___5);
    }
  }
#line 1353
  goto switch_break___0;
  case_7968___0: /* CIL Label */ 
#line 1356
  if (! do_loc) {
    {
#line 1357
    tmp___6 = dwarf_vmatoa("x", uvalue);
#line 1357
    printf((char const   */* __restrict  */)" <alt 0x%s>", tmp___6);
    }
  }
#line 1358
  goto switch_break___0;
  case_21___0: /* CIL Label */ 
  case_19___0: /* CIL Label */ 
  case_18___0: /* CIL Label */ 
  case_17___0: /* CIL Label */ 
#line 1364
  if (! do_loc) {
    {
#line 1365
    tmp___7 = dwarf_vmatoa("x", uvalue + cu_offset);
#line 1365
    printf((char const   */* __restrict  */)" <0x%s>", tmp___7);
    }
  }
#line 1366
  goto switch_break___0;
  case_23___0: /* CIL Label */ 
  case_1___0: /* CIL Label */ 
  case_6___0: /* CIL Label */ 
#line 1371
  if (! do_loc) {
    {
#line 1372
    tmp___8 = dwarf_vmatoa("x", uvalue);
#line 1372
    printf((char const   */* __restrict  */)" 0x%s", tmp___8);
    }
  }
#line 1373
  goto switch_break___0;
  case_15___0: /* CIL Label */ 
  case_13___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
  case_11___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  case_25___0: /* CIL Label */ 
#line 1381
  if (! do_loc) {
    {
#line 1382
    tmp___9 = dwarf_vmatoa("d", uvalue);
#line 1382
    printf((char const   */* __restrict  */)" %s", tmp___9);
    }
  }
#line 1383
  goto switch_break___0;
  case_7: /* CIL Label */ 
  case_20: /* CIL Label */ 
#line 1387
  if (! do_loc) {
    {
#line 1392
    byte_get_64(data, & high_bits, & uvalue);
#line 1393
    tmp___10 = dwarf_vmatoa64(high_bits, uvalue, buf___4, (unsigned int )sizeof(buf___4));
#line 1393
    printf((char const   */* __restrict  */)" 0x%s", tmp___10);
    }
  }
#line 1396
  if (do_loc) {
#line 1396
    goto _L;
  } else
#line 1396
  if (do_debug_loc) {
#line 1396
    goto _L;
  } else
#line 1396
  if (do_debug_ranges) {
    _L: /* CIL Label */ 
#line 1396
    if (num_debug_info_entries == 0U) {
#line 1399
      if (sizeof(uvalue) == 8UL) {
        {
#line 1400
        uvalue = (*byte_get)(data, 8);
        }
      } else {
        {
#line 1402
        tmp___11 = gettext("DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\n");
#line 1402
        error((char const   *)tmp___11);
        }
      }
    }
  }
#line 1404
  data += 8;
#line 1405
  goto switch_break___0;
  case_8: /* CIL Label */ 
#line 1408
  if (! do_loc) {
    {
#line 1409
    printf((char const   */* __restrict  */)" %s", data);
    }
  }
  {
#line 1410
  tmp___12 = strlen((char const   *)((char *)data));
#line 1410
  data += tmp___12 + 1UL;
  }
#line 1411
  goto switch_break___0;
  case_24: /* CIL Label */ 
  case_9: /* CIL Label */ 
  {
#line 1415
  uvalue = read_leb128(data, & bytes_read, 0);
#line 1416
  block_start = data + bytes_read;
  }
#line 1417
  if (do_loc) {
#line 1418
    data = block_start + uvalue;
  } else {
    {
#line 1420
    data = display_block(block_start, uvalue);
    }
  }
#line 1421
  goto switch_break___0;
  case_10: /* CIL Label */ 
  {
#line 1424
  uvalue = (*byte_get)(data, 1);
#line 1425
  block_start = data + 1;
  }
#line 1426
  if (do_loc) {
#line 1427
    data = block_start + uvalue;
  } else {
    {
#line 1429
    data = display_block(block_start, uvalue);
    }
  }
#line 1430
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 1433
  uvalue = (*byte_get)(data, 2);
#line 1434
  block_start = data + 2;
  }
#line 1435
  if (do_loc) {
#line 1436
    data = block_start + uvalue;
  } else {
    {
#line 1438
    data = display_block(block_start, uvalue);
    }
  }
#line 1439
  goto switch_break___0;
  case_4: /* CIL Label */ 
  {
#line 1442
  uvalue = (*byte_get)(data, 4);
#line 1443
  block_start = data + 4;
  }
#line 1444
  if (do_loc) {
#line 1445
    data = block_start + uvalue;
  } else {
    {
#line 1447
    data = display_block(block_start, uvalue);
    }
  }
#line 1448
  goto switch_break___0;
  case_14___0: /* CIL Label */ 
#line 1451
  if (! do_loc) {
    {
#line 1452
    tmp___13 = fetch_indirect_string(uvalue);
#line 1452
    tmp___14 = dwarf_vmatoa("x", uvalue);
#line 1452
    tmp___15 = gettext(" (indirect string, offset: 0x%s): %s");
#line 1452
    printf((char const   */* __restrict  */)tmp___15, tmp___14, tmp___13);
    }
  }
#line 1455
  goto switch_break___0;
  case_7938___0: /* CIL Label */ 
#line 1458
  if (! do_loc) {
    {
#line 1460
    tmp___16 = strrchr(section->name, '.');
#line 1460
    suffix = (char const   *)tmp___16;
    }
#line 1461
    if (suffix) {
      {
#line 1461
      tmp___18 = strcmp(suffix, ".dwo");
      }
#line 1461
      if (tmp___18 == 0) {
#line 1461
        tmp___17 = 1;
      } else {
#line 1461
        tmp___17 = 0;
      }
    } else {
#line 1461
      tmp___17 = 0;
    }
    {
#line 1461
    dwo = tmp___17;
#line 1463
    tmp___19 = fetch_indexed_string(uvalue, offset_size, dwo);
#line 1463
    tmp___20 = dwarf_vmatoa("x", uvalue);
#line 1463
    tmp___21 = gettext(" (indexed string: 0x%s): %s");
#line 1463
    printf((char const   */* __restrict  */)tmp___21, tmp___20, tmp___19);
    }
  }
#line 1467
  goto switch_break___0;
  case_7969___0: /* CIL Label */ 
#line 1470
  if (! do_loc) {
    {
#line 1471
    tmp___22 = dwarf_vmatoa("x", uvalue);
#line 1471
    tmp___23 = gettext(" (alt indirect string, offset: 0x%s)");
#line 1471
    printf((char const   */* __restrict  */)tmp___23, tmp___22);
    }
  }
#line 1473
  goto switch_break___0;
  case_22___0: /* CIL Label */ 
#line 1477
  goto switch_break___0;
  case_32: /* CIL Label */ 
#line 1480
  if (! do_loc) {
    {
#line 1485
    byte_get_64(data, & high_bits___0, & uvalue);
#line 1486
    tmp___24 = dwarf_vmatoa64(high_bits___0, uvalue, buf___5, (unsigned int )sizeof(buf___5));
#line 1486
    printf((char const   */* __restrict  */)" signature: 0x%s", tmp___24);
    }
  }
#line 1489
  data += 8;
#line 1490
  goto switch_break___0;
  case_7937___0: /* CIL Label */ 
#line 1493
  if (! do_loc) {
    {
#line 1494
    tmp___25 = fetch_indexed_value(uvalue * pointer_size, pointer_size);
#line 1494
    tmp___26 = dwarf_vmatoa("x", uvalue);
#line 1494
    tmp___27 = gettext(" (addr_index: 0x%s): %s");
#line 1494
    printf((char const   */* __restrict  */)tmp___27, tmp___26, tmp___25);
    }
  }
#line 1497
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 1500
  tmp___28 = gettext("Unrecognized form: %lu\n");
#line 1500
  warn((char const   *)tmp___28, form);
  }
#line 1501
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1504
  if (do_loc) {
#line 1504
    goto _L___5;
  } else
#line 1504
  if (do_debug_loc) {
#line 1504
    goto _L___5;
  } else
#line 1504
  if (do_debug_ranges) {
    _L___5: /* CIL Label */ 
#line 1504
    if (num_debug_info_entries == 0U) {
#line 1504
      if ((unsigned long )debug_info_p != (unsigned long )((void *)0)) {
        {
#line 1510
        if (attribute == 64UL) {
#line 1510
          goto case_64;
        }
#line 1523
        if (attribute == 8468UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 8467UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 8466UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 8465UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 74UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 72UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 70UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 77UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 56UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 42UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 25UL) {
#line 1523
          goto case_8468;
        }
#line 1523
        if (attribute == 2UL) {
#line 1523
          goto case_8468;
        }
#line 1549
        if (attribute == 17UL) {
#line 1549
          goto case_17___1;
        }
#line 1554
        if (attribute == 8499UL) {
#line 1554
          goto case_8499;
        }
#line 1558
        if (attribute == 8498UL) {
#line 1558
          goto case_8498;
        }
#line 1562
        if (attribute == 85UL) {
#line 1562
          goto case_85;
        }
#line 1584
        goto switch_default___1;
        case_64: /* CIL Label */ 
#line 1511
        have_frame_base = 1;
        case_8468: /* CIL Label */ 
        case_8467: /* CIL Label */ 
        case_8466: /* CIL Label */ 
        case_8465: /* CIL Label */ 
        case_74: /* CIL Label */ 
        case_72: /* CIL Label */ 
        case_70: /* CIL Label */ 
        case_77: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_42: /* CIL Label */ 
        case_25___1: /* CIL Label */ 
        case_2: /* CIL Label */ 
#line 1524
        if (dwarf_version < 4) {
#line 1524
          if (form == 6UL) {
#line 1524
            goto _L___1;
          } else
#line 1524
          if (form == 7UL) {
#line 1524
            goto _L___1;
          } else {
#line 1524
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1524
        if (form == 23UL) {
          _L___1: /* CIL Label */ 
#line 1529
          lmax = debug_info_p->max_loc_offsets;
#line 1530
          num = debug_info_p->num_loc_offsets;
#line 1532
          if (lmax == 0U) {
#line 1532
            goto _L___0;
          } else
#line 1532
          if (num >= lmax) {
            _L___0: /* CIL Label */ 
            {
#line 1534
            lmax += 1024U;
#line 1535
            tmp___29 = xcrealloc((void *)debug_info_p->loc_offsets, (size_t )lmax,
                                 sizeof(*(debug_info_p->loc_offsets)));
#line 1535
            debug_info_p->loc_offsets = (dwarf_vma *)tmp___29;
#line 1538
            tmp___30 = xcrealloc((void *)debug_info_p->have_frame_base, (size_t )lmax,
                                 sizeof(*(debug_info_p->have_frame_base)));
#line 1538
            debug_info_p->have_frame_base = (int *)tmp___30;
#line 1541
            debug_info_p->max_loc_offsets = lmax;
            }
          }
#line 1543
          *(debug_info_p->loc_offsets + num) = uvalue;
#line 1544
          *(debug_info_p->have_frame_base + num) = have_frame_base;
#line 1545
          (debug_info_p->num_loc_offsets) ++;
        }
#line 1547
        goto switch_break___1;
        case_17___1: /* CIL Label */ 
#line 1550
        if (need_base_address) {
#line 1551
          debug_info_p->base_address = uvalue;
        }
#line 1552
        goto switch_break___1;
        case_8499: /* CIL Label */ 
#line 1555
        debug_info_p->addr_base = uvalue;
#line 1556
        goto switch_break___1;
        case_8498: /* CIL Label */ 
#line 1559
        debug_info_p->ranges_base = uvalue;
#line 1560
        goto switch_break___1;
        case_85: /* CIL Label */ 
#line 1563
        if (dwarf_version < 4) {
#line 1563
          if (form == 6UL) {
#line 1563
            goto _L___3;
          } else
#line 1563
          if (form == 7UL) {
#line 1563
            goto _L___3;
          } else {
#line 1563
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 1563
        if (form == 23UL) {
          _L___3: /* CIL Label */ 
#line 1568
          lmax___0 = debug_info_p->max_range_lists;
#line 1569
          num___0 = debug_info_p->num_range_lists;
#line 1571
          if (lmax___0 == 0U) {
            {
#line 1573
            lmax___0 += 1024U;
#line 1574
            tmp___31 = xcrealloc((void *)debug_info_p->range_lists, (size_t )lmax___0,
                                 sizeof(*(debug_info_p->range_lists)));
#line 1574
            debug_info_p->range_lists = (dwarf_vma *)tmp___31;
#line 1577
            debug_info_p->max_range_lists = lmax___0;
            }
          } else
#line 1571
          if (num___0 >= lmax___0) {
            {
#line 1573
            lmax___0 += 1024U;
#line 1574
            tmp___31 = xcrealloc((void *)debug_info_p->range_lists, (size_t )lmax___0,
                                 sizeof(*(debug_info_p->range_lists)));
#line 1574
            debug_info_p->range_lists = (dwarf_vma *)tmp___31;
#line 1577
            debug_info_p->max_range_lists = lmax___0;
            }
          }
#line 1579
          *(debug_info_p->range_lists + num___0) = uvalue;
#line 1580
          (debug_info_p->num_range_lists) ++;
        }
#line 1582
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 1585
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 1589
  if (do_loc) {
#line 1590
    return (data);
  } else
#line 1589
  if (attribute == 0UL) {
#line 1590
    return (data);
  }
  {
#line 1593
  printf((char const   */* __restrict  */)"\t");
  }
  {
#line 1597
  if (attribute == 32UL) {
#line 1597
    goto case_32___0;
  }
#line 1619
  if (attribute == 19UL) {
#line 1619
    goto case_19___1;
  }
#line 1662
  if (attribute == 62UL) {
#line 1662
    goto case_62;
  }
#line 1702
  if (attribute == 50UL) {
#line 1702
    goto case_50;
  }
#line 1714
  if (attribute == 23UL) {
#line 1714
    goto case_23___1;
  }
#line 1724
  if (attribute == 76UL) {
#line 1724
    goto case_76;
  }
#line 1734
  if (attribute == 66UL) {
#line 1734
    goto case_66;
  }
#line 1745
  if (attribute == 54UL) {
#line 1745
    goto case_54;
  }
#line 1760
  if (attribute == 9UL) {
#line 1760
    goto case_9___2;
  }
#line 1769
  if (attribute == 64UL) {
#line 1769
    goto case_64___0;
  }
#line 1782
  if (attribute == 8468UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 8467UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 8466UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 8465UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 74UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 72UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 70UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 77UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 56UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 42UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 25UL) {
#line 1782
    goto case_8468___0;
  }
#line 1782
  if (attribute == 2UL) {
#line 1782
    goto case_8468___0;
  }
#line 1793
  if (attribute == 34UL) {
#line 1793
    goto case_34;
  }
#line 1793
  if (attribute == 47UL) {
#line 1793
    goto case_34;
  }
#line 1793
  if (attribute == 81UL) {
#line 1793
    goto case_34;
  }
#line 1793
  if (attribute == 80UL) {
#line 1793
    goto case_34;
  }
#line 1793
  if (attribute == 79UL) {
#line 1793
    goto case_34;
  }
#line 1793
  if (attribute == 78UL) {
#line 1793
    goto case_34;
  }
#line 1811
  if (attribute == 24UL) {
#line 1811
    goto case_24___0;
  }
#line 1851
  goto switch_default___10;
  case_32___0: /* CIL Label */ 
  {
#line 1600
  if (uvalue == 0ULL) {
#line 1600
    goto case_0;
  }
#line 1603
  if (uvalue == 1ULL) {
#line 1603
    goto case_1___1;
  }
#line 1606
  if (uvalue == 2ULL) {
#line 1606
    goto case_2___0;
  }
#line 1609
  if (uvalue == 3ULL) {
#line 1609
    goto case_3___0;
  }
#line 1612
  goto switch_default___2;
  case_0: /* CIL Label */ 
  {
#line 1601
  tmp___32 = gettext("(not inlined)");
#line 1601
  printf((char const   */* __restrict  */)tmp___32);
  }
#line 1602
  goto switch_break___3;
  case_1___1: /* CIL Label */ 
  {
#line 1604
  tmp___33 = gettext("(inlined)");
#line 1604
  printf((char const   */* __restrict  */)tmp___33);
  }
#line 1605
  goto switch_break___3;
  case_2___0: /* CIL Label */ 
  {
#line 1607
  tmp___34 = gettext("(declared as inline but ignored)");
#line 1607
  printf((char const   */* __restrict  */)tmp___34);
  }
#line 1608
  goto switch_break___3;
  case_3___0: /* CIL Label */ 
  {
#line 1610
  tmp___35 = gettext("(declared as inline and inlined)");
#line 1610
  printf((char const   */* __restrict  */)tmp___35);
  }
#line 1611
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 1613
  tmp___36 = dwarf_vmatoa("x", uvalue);
#line 1613
  tmp___37 = gettext("  (Unknown inline attribute value: %s)");
#line 1613
  printf((char const   */* __restrict  */)tmp___37, tmp___36);
  }
#line 1615
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 1617
  goto switch_break___2;
  case_19___1: /* CIL Label */ 
  {
#line 1623
  if (uvalue == 1ULL) {
#line 1623
    goto case_1___2;
  }
#line 1624
  if (uvalue == 2ULL) {
#line 1624
    goto case_2___1;
  }
#line 1625
  if (uvalue == 3ULL) {
#line 1625
    goto case_3___1;
  }
#line 1626
  if (uvalue == 4ULL) {
#line 1626
    goto case_4___0;
  }
#line 1627
  if (uvalue == 5ULL) {
#line 1627
    goto case_5___1;
  }
#line 1628
  if (uvalue == 6ULL) {
#line 1628
    goto case_6___1;
  }
#line 1629
  if (uvalue == 7ULL) {
#line 1629
    goto case_7___0;
  }
#line 1630
  if (uvalue == 8ULL) {
#line 1630
    goto case_8___0;
  }
#line 1631
  if (uvalue == 9ULL) {
#line 1631
    goto case_9___0;
  }
#line 1632
  if (uvalue == 10ULL) {
#line 1632
    goto case_10___0;
  }
#line 1634
  if (uvalue == 11ULL) {
#line 1634
    goto case_11___1;
  }
#line 1635
  if (uvalue == 12ULL) {
#line 1635
    goto case_12___1;
  }
#line 1636
  if (uvalue == 13ULL) {
#line 1636
    goto case_13___1;
  }
#line 1637
  if (uvalue == 14ULL) {
#line 1637
    goto case_14___1;
  }
#line 1639
  if (uvalue == 15ULL) {
#line 1639
    goto case_15___1;
  }
#line 1640
  if (uvalue == 16ULL) {
#line 1640
    goto case_16___1;
  }
#line 1641
  if (uvalue == 17ULL) {
#line 1641
    goto case_17___2;
  }
#line 1642
  if (uvalue == 18ULL) {
#line 1642
    goto case_18___1;
  }
#line 1643
  if (uvalue == 19ULL) {
#line 1643
    goto case_19___2;
  }
#line 1645
  if (uvalue == 20ULL) {
#line 1645
    goto case_20___0;
  }
#line 1647
  if (uvalue == 22ULL) {
#line 1647
    goto case_22___1;
  }
#line 1649
  if (uvalue == 32769ULL) {
#line 1649
    goto case_32769;
  }
#line 1651
  if (uvalue == 34661ULL) {
#line 1651
    goto case_34661;
  }
#line 1652
  goto switch_default___3;
  case_1___2: /* CIL Label */ 
  {
#line 1623
  printf((char const   */* __restrict  */)"(ANSI C)");
  }
#line 1623
  goto switch_break___4;
  case_2___1: /* CIL Label */ 
  {
#line 1624
  printf((char const   */* __restrict  */)"(non-ANSI C)");
  }
#line 1624
  goto switch_break___4;
  case_3___1: /* CIL Label */ 
  {
#line 1625
  printf((char const   */* __restrict  */)"(Ada)");
  }
#line 1625
  goto switch_break___4;
  case_4___0: /* CIL Label */ 
  {
#line 1626
  printf((char const   */* __restrict  */)"(C++)");
  }
#line 1626
  goto switch_break___4;
  case_5___1: /* CIL Label */ 
  {
#line 1627
  printf((char const   */* __restrict  */)"(Cobol 74)");
  }
#line 1627
  goto switch_break___4;
  case_6___1: /* CIL Label */ 
  {
#line 1628
  printf((char const   */* __restrict  */)"(Cobol 85)");
  }
#line 1628
  goto switch_break___4;
  case_7___0: /* CIL Label */ 
  {
#line 1629
  printf((char const   */* __restrict  */)"(FORTRAN 77)");
  }
#line 1629
  goto switch_break___4;
  case_8___0: /* CIL Label */ 
  {
#line 1630
  printf((char const   */* __restrict  */)"(Fortran 90)");
  }
#line 1630
  goto switch_break___4;
  case_9___0: /* CIL Label */ 
  {
#line 1631
  printf((char const   */* __restrict  */)"(ANSI Pascal)");
  }
#line 1631
  goto switch_break___4;
  case_10___0: /* CIL Label */ 
  {
#line 1632
  printf((char const   */* __restrict  */)"(Modula 2)");
  }
#line 1632
  goto switch_break___4;
  case_11___1: /* CIL Label */ 
  {
#line 1634
  printf((char const   */* __restrict  */)"(Java)");
  }
#line 1634
  goto switch_break___4;
  case_12___1: /* CIL Label */ 
  {
#line 1635
  printf((char const   */* __restrict  */)"(ANSI C99)");
  }
#line 1635
  goto switch_break___4;
  case_13___1: /* CIL Label */ 
  {
#line 1636
  printf((char const   */* __restrict  */)"(ADA 95)");
  }
#line 1636
  goto switch_break___4;
  case_14___1: /* CIL Label */ 
  {
#line 1637
  printf((char const   */* __restrict  */)"(Fortran 95)");
  }
#line 1637
  goto switch_break___4;
  case_15___1: /* CIL Label */ 
  {
#line 1639
  printf((char const   */* __restrict  */)"(PLI)");
  }
#line 1639
  goto switch_break___4;
  case_16___1: /* CIL Label */ 
  {
#line 1640
  printf((char const   */* __restrict  */)"(Objective C)");
  }
#line 1640
  goto switch_break___4;
  case_17___2: /* CIL Label */ 
  {
#line 1641
  printf((char const   */* __restrict  */)"(Objective C++)");
  }
#line 1641
  goto switch_break___4;
  case_18___1: /* CIL Label */ 
  {
#line 1642
  printf((char const   */* __restrict  */)"(Unified Parallel C)");
  }
#line 1642
  goto switch_break___4;
  case_19___2: /* CIL Label */ 
  {
#line 1643
  printf((char const   */* __restrict  */)"(D)");
  }
#line 1643
  goto switch_break___4;
  case_20___0: /* CIL Label */ 
  {
#line 1645
  printf((char const   */* __restrict  */)"(Python)");
  }
#line 1645
  goto switch_break___4;
  case_22___1: /* CIL Label */ 
  {
#line 1647
  printf((char const   */* __restrict  */)"(Go)");
  }
#line 1647
  goto switch_break___4;
  case_32769: /* CIL Label */ 
  {
#line 1649
  printf((char const   */* __restrict  */)"(MIPS assembler)");
  }
#line 1649
  goto switch_break___4;
  case_34661: /* CIL Label */ 
  {
#line 1651
  printf((char const   */* __restrict  */)"(Unified Parallel C)");
  }
#line 1651
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
#line 1653
  if (uvalue >= 32768ULL) {
#line 1653
    if (uvalue <= 65535ULL) {
      {
#line 1654
      tmp___38 = dwarf_vmatoa("x", uvalue);
#line 1654
      tmp___39 = gettext("(implementation defined: %s)");
#line 1654
      printf((char const   */* __restrict  */)tmp___39, tmp___38);
      }
    } else {
      {
#line 1657
      tmp___40 = dwarf_vmatoa("x", uvalue);
#line 1657
      tmp___41 = gettext("(Unknown: %s)");
#line 1657
      printf((char const   */* __restrict  */)tmp___41, tmp___40);
      }
    }
  } else {
    {
#line 1657
    tmp___40 = dwarf_vmatoa("x", uvalue);
#line 1657
    tmp___41 = gettext("(Unknown: %s)");
#line 1657
    printf((char const   */* __restrict  */)tmp___41, tmp___40);
    }
  }
#line 1658
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 1660
  goto switch_break___2;
  case_62: /* CIL Label */ 
  {
#line 1665
  if (uvalue == 0ULL) {
#line 1665
    goto case_0___0;
  }
#line 1666
  if (uvalue == 1ULL) {
#line 1666
    goto case_1___3;
  }
#line 1667
  if (uvalue == 2ULL) {
#line 1667
    goto case_2___2;
  }
#line 1668
  if (uvalue == 3ULL) {
#line 1668
    goto case_3___2;
  }
#line 1669
  if (uvalue == 4ULL) {
#line 1669
    goto case_4___1;
  }
#line 1670
  if (uvalue == 5ULL) {
#line 1670
    goto case_5___2;
  }
#line 1671
  if (uvalue == 6ULL) {
#line 1671
    goto case_6___2;
  }
#line 1672
  if (uvalue == 7ULL) {
#line 1672
    goto case_7___1;
  }
#line 1673
  if (uvalue == 8ULL) {
#line 1673
    goto case_8___1;
  }
#line 1675
  if (uvalue == 9ULL) {
#line 1675
    goto case_9___1;
  }
#line 1676
  if (uvalue == 15ULL) {
#line 1676
    goto case_15___2;
  }
#line 1678
  if (uvalue == 10ULL) {
#line 1678
    goto case_10___1;
  }
#line 1679
  if (uvalue == 11ULL) {
#line 1679
    goto case_11___2;
  }
#line 1680
  if (uvalue == 12ULL) {
#line 1680
    goto case_12___2;
  }
#line 1681
  if (uvalue == 13ULL) {
#line 1681
    goto case_13___2;
  }
#line 1682
  if (uvalue == 14ULL) {
#line 1682
    goto case_14___2;
  }
#line 1684
  if (uvalue == 128ULL) {
#line 1684
    goto case_128;
  }
#line 1685
  if (uvalue == 129ULL) {
#line 1685
    goto case_129;
  }
#line 1686
  if (uvalue == 130ULL) {
#line 1686
    goto case_130;
  }
#line 1687
  if (uvalue == 131ULL) {
#line 1687
    goto case_131;
  }
#line 1688
  if (uvalue == 132ULL) {
#line 1688
    goto case_132;
  }
#line 1689
  if (uvalue == 133ULL) {
#line 1689
    goto case_133;
  }
#line 1690
  if (uvalue == 134ULL) {
#line 1690
    goto case_134;
  }
#line 1692
  goto switch_default___4;
  case_0___0: /* CIL Label */ 
  {
#line 1665
  printf((char const   */* __restrict  */)"(void)");
  }
#line 1665
  goto switch_break___5;
  case_1___3: /* CIL Label */ 
  {
#line 1666
  printf((char const   */* __restrict  */)"(machine address)");
  }
#line 1666
  goto switch_break___5;
  case_2___2: /* CIL Label */ 
  {
#line 1667
  printf((char const   */* __restrict  */)"(boolean)");
  }
#line 1667
  goto switch_break___5;
  case_3___2: /* CIL Label */ 
  {
#line 1668
  printf((char const   */* __restrict  */)"(complex float)");
  }
#line 1668
  goto switch_break___5;
  case_4___1: /* CIL Label */ 
  {
#line 1669
  printf((char const   */* __restrict  */)"(float)");
  }
#line 1669
  goto switch_break___5;
  case_5___2: /* CIL Label */ 
  {
#line 1670
  printf((char const   */* __restrict  */)"(signed)");
  }
#line 1670
  goto switch_break___5;
  case_6___2: /* CIL Label */ 
  {
#line 1671
  printf((char const   */* __restrict  */)"(signed char)");
  }
#line 1671
  goto switch_break___5;
  case_7___1: /* CIL Label */ 
  {
#line 1672
  printf((char const   */* __restrict  */)"(unsigned)");
  }
#line 1672
  goto switch_break___5;
  case_8___1: /* CIL Label */ 
  {
#line 1673
  printf((char const   */* __restrict  */)"(unsigned char)");
  }
#line 1673
  goto switch_break___5;
  case_9___1: /* CIL Label */ 
  {
#line 1675
  printf((char const   */* __restrict  */)"(imaginary float)");
  }
#line 1675
  goto switch_break___5;
  case_15___2: /* CIL Label */ 
  {
#line 1676
  printf((char const   */* __restrict  */)"(decimal float)");
  }
#line 1676
  goto switch_break___5;
  case_10___1: /* CIL Label */ 
  {
#line 1678
  printf((char const   */* __restrict  */)"(packed_decimal)");
  }
#line 1678
  goto switch_break___5;
  case_11___2: /* CIL Label */ 
  {
#line 1679
  printf((char const   */* __restrict  */)"(numeric_string)");
  }
#line 1679
  goto switch_break___5;
  case_12___2: /* CIL Label */ 
  {
#line 1680
  printf((char const   */* __restrict  */)"(edited)");
  }
#line 1680
  goto switch_break___5;
  case_13___2: /* CIL Label */ 
  {
#line 1681
  printf((char const   */* __restrict  */)"(signed_fixed)");
  }
#line 1681
  goto switch_break___5;
  case_14___2: /* CIL Label */ 
  {
#line 1682
  printf((char const   */* __restrict  */)"(unsigned_fixed)");
  }
#line 1682
  goto switch_break___5;
  case_128: /* CIL Label */ 
  {
#line 1684
  printf((char const   */* __restrict  */)"(HP_float80)");
  }
#line 1684
  goto switch_break___5;
  case_129: /* CIL Label */ 
  {
#line 1685
  printf((char const   */* __restrict  */)"(HP_complex_float80)");
  }
#line 1685
  goto switch_break___5;
  case_130: /* CIL Label */ 
  {
#line 1686
  printf((char const   */* __restrict  */)"(HP_float128)");
  }
#line 1686
  goto switch_break___5;
  case_131: /* CIL Label */ 
  {
#line 1687
  printf((char const   */* __restrict  */)"(HP_complex_float128)");
  }
#line 1687
  goto switch_break___5;
  case_132: /* CIL Label */ 
  {
#line 1688
  printf((char const   */* __restrict  */)"(HP_floathpintel)");
  }
#line 1688
  goto switch_break___5;
  case_133: /* CIL Label */ 
  {
#line 1689
  printf((char const   */* __restrict  */)"(HP_imaginary_float80)");
  }
#line 1689
  goto switch_break___5;
  case_134: /* CIL Label */ 
  {
#line 1690
  printf((char const   */* __restrict  */)"(HP_imaginary_float128)");
  }
#line 1690
  goto switch_break___5;
  switch_default___4: /* CIL Label */ 
#line 1693
  if (uvalue >= 128ULL) {
#line 1693
    if (uvalue <= 255ULL) {
      {
#line 1695
      tmp___42 = gettext("(user defined type)");
#line 1695
      printf((char const   */* __restrict  */)tmp___42);
      }
    } else {
      {
#line 1697
      tmp___43 = gettext("(unknown type)");
#line 1697
      printf((char const   */* __restrict  */)tmp___43);
      }
    }
  } else {
    {
#line 1697
    tmp___43 = gettext("(unknown type)");
#line 1697
    printf((char const   */* __restrict  */)tmp___43);
    }
  }
#line 1698
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 1700
  goto switch_break___2;
  case_50: /* CIL Label */ 
  {
#line 1705
  if (uvalue == 1ULL) {
#line 1705
    goto case_1___4;
  }
#line 1706
  if (uvalue == 2ULL) {
#line 1706
    goto case_2___3;
  }
#line 1707
  if (uvalue == 3ULL) {
#line 1707
    goto case_3___3;
  }
#line 1708
  goto switch_default___5;
  case_1___4: /* CIL Label */ 
  {
#line 1705
  printf((char const   */* __restrict  */)"(public)");
  }
#line 1705
  goto switch_break___6;
  case_2___3: /* CIL Label */ 
  {
#line 1706
  printf((char const   */* __restrict  */)"(protected)");
  }
#line 1706
  goto switch_break___6;
  case_3___3: /* CIL Label */ 
  {
#line 1707
  printf((char const   */* __restrict  */)"(private)");
  }
#line 1707
  goto switch_break___6;
  switch_default___5: /* CIL Label */ 
  {
#line 1709
  tmp___44 = gettext("(unknown accessibility)");
#line 1709
  printf((char const   */* __restrict  */)tmp___44);
  }
#line 1710
  goto switch_break___6;
  switch_break___6: /* CIL Label */ ;
  }
#line 1712
  goto switch_break___2;
  case_23___1: /* CIL Label */ 
  {
#line 1717
  if (uvalue == 1ULL) {
#line 1717
    goto case_1___5;
  }
#line 1718
  if (uvalue == 2ULL) {
#line 1718
    goto case_2___4;
  }
#line 1719
  if (uvalue == 3ULL) {
#line 1719
    goto case_3___4;
  }
#line 1720
  goto switch_default___6;
  case_1___5: /* CIL Label */ 
  {
#line 1717
  printf((char const   */* __restrict  */)"(local)");
  }
#line 1717
  goto switch_break___7;
  case_2___4: /* CIL Label */ 
  {
#line 1718
  printf((char const   */* __restrict  */)"(exported)");
  }
#line 1718
  goto switch_break___7;
  case_3___4: /* CIL Label */ 
  {
#line 1719
  printf((char const   */* __restrict  */)"(qualified)");
  }
#line 1719
  goto switch_break___7;
  switch_default___6: /* CIL Label */ 
  {
#line 1720
  tmp___45 = gettext("(unknown visibility)");
#line 1720
  printf((char const   */* __restrict  */)tmp___45);
  }
#line 1720
  goto switch_break___7;
  switch_break___7: /* CIL Label */ ;
  }
#line 1722
  goto switch_break___2;
  case_76: /* CIL Label */ 
  {
#line 1727
  if (uvalue == 0ULL) {
#line 1727
    goto case_0___1;
  }
#line 1728
  if (uvalue == 1ULL) {
#line 1728
    goto case_1___6;
  }
#line 1729
  if (uvalue == 2ULL) {
#line 1729
    goto case_2___5;
  }
#line 1730
  goto switch_default___7;
  case_0___1: /* CIL Label */ 
  {
#line 1727
  printf((char const   */* __restrict  */)"(none)");
  }
#line 1727
  goto switch_break___8;
  case_1___6: /* CIL Label */ 
  {
#line 1728
  printf((char const   */* __restrict  */)"(virtual)");
  }
#line 1728
  goto switch_break___8;
  case_2___5: /* CIL Label */ 
  {
#line 1729
  printf((char const   */* __restrict  */)"(pure_virtual)");
  }
#line 1729
  goto switch_break___8;
  switch_default___7: /* CIL Label */ 
  {
#line 1730
  tmp___46 = gettext("(unknown virtuality)");
#line 1730
  printf((char const   */* __restrict  */)tmp___46);
  }
#line 1730
  goto switch_break___8;
  switch_break___8: /* CIL Label */ ;
  }
#line 1732
  goto switch_break___2;
  case_66: /* CIL Label */ 
  {
#line 1737
  if (uvalue == 0ULL) {
#line 1737
    goto case_0___2;
  }
#line 1738
  if (uvalue == 1ULL) {
#line 1738
    goto case_1___7;
  }
#line 1739
  if (uvalue == 2ULL) {
#line 1739
    goto case_2___6;
  }
#line 1740
  if (uvalue == 3ULL) {
#line 1740
    goto case_3___5;
  }
#line 1741
  goto switch_default___8;
  case_0___2: /* CIL Label */ 
  {
#line 1737
  printf((char const   */* __restrict  */)"(case_sensitive)");
  }
#line 1737
  goto switch_break___9;
  case_1___7: /* CIL Label */ 
  {
#line 1738
  printf((char const   */* __restrict  */)"(up_case)");
  }
#line 1738
  goto switch_break___9;
  case_2___6: /* CIL Label */ 
  {
#line 1739
  printf((char const   */* __restrict  */)"(down_case)");
  }
#line 1739
  goto switch_break___9;
  case_3___5: /* CIL Label */ 
  {
#line 1740
  printf((char const   */* __restrict  */)"(case_insensitive)");
  }
#line 1740
  goto switch_break___9;
  switch_default___8: /* CIL Label */ 
  {
#line 1741
  tmp___47 = gettext("(unknown case)");
#line 1741
  printf((char const   */* __restrict  */)tmp___47);
  }
#line 1741
  goto switch_break___9;
  switch_break___9: /* CIL Label */ ;
  }
#line 1743
  goto switch_break___2;
  case_54: /* CIL Label */ 
  {
#line 1748
  if (uvalue == 1ULL) {
#line 1748
    goto case_1___8;
  }
#line 1749
  if (uvalue == 2ULL) {
#line 1749
    goto case_2___7;
  }
#line 1750
  if (uvalue == 3ULL) {
#line 1750
    goto case_3___6;
  }
#line 1751
  goto switch_default___9;
  case_1___8: /* CIL Label */ 
  {
#line 1748
  printf((char const   */* __restrict  */)"(normal)");
  }
#line 1748
  goto switch_break___10;
  case_2___7: /* CIL Label */ 
  {
#line 1749
  printf((char const   */* __restrict  */)"(program)");
  }
#line 1749
  goto switch_break___10;
  case_3___6: /* CIL Label */ 
  {
#line 1750
  printf((char const   */* __restrict  */)"(nocall)");
  }
#line 1750
  goto switch_break___10;
  switch_default___9: /* CIL Label */ 
#line 1752
  if (uvalue >= 64ULL) {
#line 1752
    if (uvalue <= 255ULL) {
      {
#line 1754
      tmp___48 = gettext("(user defined)");
#line 1754
      printf((char const   */* __restrict  */)tmp___48);
      }
    } else {
      {
#line 1756
      tmp___49 = gettext("(unknown convention)");
#line 1756
      printf((char const   */* __restrict  */)tmp___49);
      }
    }
  } else {
    {
#line 1756
    tmp___49 = gettext("(unknown convention)");
#line 1756
    printf((char const   */* __restrict  */)tmp___49);
    }
  }
  switch_break___10: /* CIL Label */ ;
  }
#line 1758
  goto switch_break___2;
  case_9___2: /* CIL Label */ 
  {
#line 1763
  if (uvalue == 0xffffffffffffffffULL) {
#line 1763
    goto case_18446744073709551615;
  }
#line 1764
  if (uvalue == 0ULL) {
#line 1764
    goto case_0___3;
  }
#line 1765
  if (uvalue == 1ULL) {
#line 1765
    goto case_1___9;
  }
#line 1761
  goto switch_break___11;
  case_18446744073709551615: /* CIL Label */ 
  {
#line 1763
  tmp___50 = gettext("(undefined)");
#line 1763
  printf((char const   */* __restrict  */)tmp___50);
  }
#line 1763
  goto switch_break___11;
  case_0___3: /* CIL Label */ 
  {
#line 1764
  printf((char const   */* __restrict  */)"(row major)");
  }
#line 1764
  goto switch_break___11;
  case_1___9: /* CIL Label */ 
  {
#line 1765
  printf((char const   */* __restrict  */)"(column major)");
  }
#line 1765
  goto switch_break___11;
  switch_break___11: /* CIL Label */ ;
  }
#line 1767
  goto switch_break___2;
  case_64___0: /* CIL Label */ 
#line 1770
  have_frame_base = 1;
  case_8468___0: /* CIL Label */ 
  case_8467___0: /* CIL Label */ 
  case_8466___0: /* CIL Label */ 
  case_8465___0: /* CIL Label */ 
  case_74___0: /* CIL Label */ 
  case_72___0: /* CIL Label */ 
  case_70___0: /* CIL Label */ 
  case_77___0: /* CIL Label */ 
  case_56___0: /* CIL Label */ 
  case_42___0: /* CIL Label */ 
  case_25___2: /* CIL Label */ 
  case_2___8: /* CIL Label */ 
#line 1783
  if (dwarf_version < 4) {
#line 1783
    if (form == 6UL) {
      {
#line 1786
      tmp___51 = gettext("(location list)");
#line 1786
      printf((char const   */* __restrict  */)tmp___51);
      }
    } else
#line 1783
    if (form == 7UL) {
      {
#line 1786
      tmp___51 = gettext("(location list)");
#line 1786
      printf((char const   */* __restrict  */)tmp___51);
      }
    } else {
#line 1783
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 1783
  if (form == 23UL) {
    {
#line 1786
    tmp___51 = gettext("(location list)");
#line 1786
    printf((char const   */* __restrict  */)tmp___51);
    }
  }
  case_34: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
#line 1794
  if (block_start) {
    {
#line 1798
    printf((char const   */* __restrict  */)"(");
#line 1799
    need_frame_base = decode_location_expression(block_start, (unsigned int )pointer_size,
                                                 (unsigned int )offset_size, dwarf_version,
                                                 uvalue, cu_offset, section);
#line 1805
    printf((char const   */* __restrict  */)")");
    }
#line 1806
    if (need_frame_base) {
#line 1806
      if (! have_frame_base) {
        {
#line 1807
        tmp___52 = gettext(" [without DW_AT_frame_base]");
#line 1807
        printf((char const   */* __restrict  */)tmp___52);
        }
      }
    }
  }
#line 1809
  goto switch_break___2;
  case_24___0: /* CIL Label */ 
#line 1813
  if (form == 32UL) {
#line 1815
    goto switch_break___2;
  } else
#line 1813
  if (form == 7968UL) {
#line 1815
    goto switch_break___2;
  }
#line 1817
  if (form == 17UL) {
#line 1821
    uvalue += cu_offset;
  } else
#line 1817
  if (form == 18UL) {
#line 1821
    uvalue += cu_offset;
  } else
#line 1817
  if (form == 19UL) {
#line 1821
    uvalue += cu_offset;
  } else
#line 1817
  if (form == 21UL) {
#line 1821
    uvalue += cu_offset;
  }
#line 1823
  if (uvalue >= section->size) {
    {
#line 1824
    tmp___53 = dwarf_vmatoa("x", uvalue);
#line 1824
    tmp___54 = gettext("Offset %s used as value for DW_AT_import attribute of DIE at offset %lx is too big.\n");
#line 1824
    warn((char const   *)tmp___54, tmp___53, (unsigned long )(orig_data - section->start));
    }
  } else {
    {
#line 1832
    tmp___55 = read_leb128(section->start + uvalue, (unsigned int *)((void *)0), 0);
#line 1832
    abbrev_number = (unsigned long )tmp___55;
#line 1834
    tmp___56 = gettext("[Abbrev Number: %ld");
#line 1834
    printf((char const   */* __restrict  */)tmp___56, abbrev_number);
    }
#line 1838
    if (form != 16UL) {
#line 1840
      entry = first_abbrev;
      {
#line 1840
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1840
        if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 1840
          goto while_break;
        }
#line 1841
        if (entry->entry == abbrev_number) {
#line 1842
          goto while_break;
        }
#line 1840
        entry = entry->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 1843
      if ((unsigned long )entry != (unsigned long )((void *)0)) {
        {
#line 1844
        tmp___57 = get_TAG_name(entry->tag);
#line 1844
        printf((char const   */* __restrict  */)" (%s)", tmp___57);
        }
      }
    }
    {
#line 1846
    printf((char const   */* __restrict  */)"]");
    }
  }
#line 1849
  goto switch_break___2;
  switch_default___10: /* CIL Label */ 
#line 1852
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 1855
  return (data);
}
}
#line 1871 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char buffer___1[100]  ;
#line 1858 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *get_AT_name(unsigned long attribute ) 
{ 
  char const   *name___0 ;
  char *tmp___0 ;

  {
#line 1864
  if (attribute == 8193UL) {
#line 1865
    return ("DW_AT_MIPS_fde or DW_AT_HP_unmodifiable");
  }
  {
#line 1867
  name___0 = get_DW_AT_name((unsigned int )attribute);
  }
#line 1869
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 1873
    tmp___0 = gettext("Unknown AT value: %lx");
#line 1873
    snprintf((char */* __restrict  */)(buffer___1), sizeof(buffer___1), (char const   */* __restrict  */)tmp___0,
             attribute);
    }
#line 1875
    return ((char const   *)(buffer___1));
  }
#line 1878
  return (name___0);
}
}
#line 1881 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned char *read_and_display_attr(unsigned long attribute , unsigned long form ,
                                            unsigned char *data , dwarf_vma cu_offset ,
                                            dwarf_vma pointer_size , dwarf_vma offset_size ,
                                            int dwarf_version , debug_info *debug_info_p ,
                                            int do_loc , struct dwarf_section *section ) 
{ 
  char const   *tmp___0 ;

  {
#line 1893
  if (! do_loc) {
    {
#line 1894
    tmp___0 = get_AT_name(attribute);
#line 1894
    printf((char const   */* __restrict  */)"   %-18s:", tmp___0);
    }
  }
  {
#line 1895
  data = read_and_display_attr_value(attribute, form, data, cu_offset, pointer_size,
                                     offset_size, dwarf_version, debug_info_p, do_loc,
                                     section);
  }
#line 1899
  if (! do_loc) {
    {
#line 1900
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 1901
  return (data);
}
}
#line 2167
static int process_debug_info(struct dwarf_section *section , void *file , enum dwarf_section_display_enum abbrev_sec ,
                              int do_loc , int do_types ) ;
#line 2167 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned int num_bogus_warns  =    0U;
#line 1910 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int process_debug_info(struct dwarf_section *section , void *file , enum dwarf_section_display_enum abbrev_sec ,
                              int do_loc , int do_types ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *section_begin ;
  unsigned int unit ;
  unsigned int num_units ;
  dwarf_vma length ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  DWARF2_Internal_CompUnit compunit ;
  unsigned char *hdrptr ;
  unsigned char *tags ;
  int level ;
  int last_level ;
  int saved_level ;
  dwarf_vma cu_offset ;
  int offset_size ;
  int initial_length_size ;
  dwarf_vma signature_high ;
  dwarf_vma signature_low ;
  dwarf_vma type_offset ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char buf___4[64] ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  char const   *tmp___22 ;
  char *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned int bytes_read ;
  unsigned long abbrev_number ;
  unsigned long die_offset ;
  abbrev_entry *entry ;
  abbrev_attr *attr ;
  int do_printing ;
  dwarf_vma tmp___30 ;
  unsigned char *chk ;
  char *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char const   *tmp___37 ;
  debug_info *arg ;
  int tmp___38 ;

  {
#line 1917
  start = section->start;
#line 1918
  end = start + section->size;
#line 1921
  num_units = 0U;
#line 1923
  if (do_loc) {
#line 1923
    goto _L;
  } else
#line 1923
  if (do_debug_loc) {
#line 1923
    goto _L;
  } else
#line 1923
  if (do_debug_ranges) {
    _L: /* CIL Label */ 
#line 1923
    if (num_debug_info_entries == 0U) {
#line 1923
      if (! do_types) {
#line 1930
        section_begin = start;
#line 1930
        num_units = 0U;
        {
#line 1930
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1930
          if (! ((unsigned long )section_begin < (unsigned long )end)) {
#line 1930
            goto while_break;
          }
          {
#line 1936
          length = (*byte_get)(section_begin, 4);
          }
#line 1938
          if (length == 4294967295ULL) {
            {
#line 1940
            length = (*byte_get)(section_begin + 4, 8);
#line 1941
            section_begin += length + 12ULL;
            }
          } else
#line 1943
          if (length >= 4294967280ULL) {
#line 1943
            if (length < 4294967295ULL) {
              {
#line 1945
              tmp___0 = dwarf_vmatoa("x", length);
#line 1945
              tmp___1 = gettext("Reserved length value (0x%s) found in section %s\n");
#line 1945
              warn((char const   *)tmp___1, tmp___0, section->name);
              }
#line 1947
              return (0);
            } else {
#line 1950
              section_begin += length + 4ULL;
            }
          } else {
#line 1950
            section_begin += length + 4ULL;
          }
#line 1955
          if ((long )length <= 0L) {
            {
#line 1957
            tmp___2 = dwarf_vmatoa("x", length);
#line 1957
            tmp___3 = gettext("Corrupt unit length (0x%s) found in section %s\n");
#line 1957
            warn((char const   *)tmp___3, tmp___2, section->name);
            }
#line 1959
            return (0);
          }
#line 1930
          num_units ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 1963
        if (num_units == 0U) {
          {
#line 1965
          tmp___4 = gettext("No comp units in %s section ?");
#line 1965
          error((char const   *)tmp___4, section->name);
          }
#line 1966
          return (0);
        }
        {
#line 1970
        tmp___5 = cmalloc((size_t )num_units, sizeof(*debug_information));
#line 1970
        debug_information = (debug_info *)tmp___5;
        }
#line 1972
        if ((unsigned long )debug_information == (unsigned long )((void *)0)) {
          {
#line 1974
          tmp___6 = gettext("Not enough memory for a debug info array of %u entries");
#line 1974
          error((char const   *)tmp___6, num_units);
          }
#line 1976
          return (0);
        }
      }
    }
  }
#line 1980
  if (! do_loc) {
#line 1982
    if (dwarf_start_die == 0UL) {
      {
#line 1983
      tmp___7 = gettext("Contents of the %s section:\n\n");
#line 1983
      printf((char const   */* __restrict  */)tmp___7, section->name);
      }
    }
    {
#line 1985
    load_debug_section((enum dwarf_section_display_enum )9, file);
#line 1986
    load_debug_section((enum dwarf_section_display_enum )28, file);
#line 1987
    load_debug_section((enum dwarf_section_display_enum )29, file);
#line 1988
    load_debug_section((enum dwarf_section_display_enum )30, file);
#line 1989
    load_debug_section((enum dwarf_section_display_enum )31, file);
    }
  }
  {
#line 1992
  load_debug_section(abbrev_sec, file);
  }
#line 1993
  if ((unsigned long )debug_displays[abbrev_sec].section.start == (unsigned long )((void *)0)) {
    {
#line 1995
    tmp___8 = gettext("Unable to locate %s section!\n");
#line 1995
    warn((char const   *)tmp___8, debug_displays[abbrev_sec].section.name);
    }
#line 1997
    return (0);
  }
#line 2000
  section_begin = start;
#line 2000
  unit = 0U;
  {
#line 2000
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2000
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 2000
      goto while_break___0;
    }
    {
#line 2009
    signature_high = (dwarf_vma )0;
#line 2010
    signature_low = (dwarf_vma )0;
#line 2011
    type_offset = (dwarf_vma )0;
#line 2013
    hdrptr = start;
#line 2015
    compunit.cu_length = (*byte_get)(hdrptr, 4);
#line 2016
    hdrptr += 4;
    }
#line 2018
    if (compunit.cu_length == 4294967295ULL) {
      {
#line 2020
      compunit.cu_length = (*byte_get)(hdrptr, 8);
#line 2021
      hdrptr += 8;
#line 2022
      offset_size = 8;
#line 2023
      initial_length_size = 12;
      }
    } else {
#line 2027
      offset_size = 4;
#line 2028
      initial_length_size = 4;
    }
    {
#line 2031
    tmp___9 = (*byte_get)(hdrptr, 2);
#line 2031
    compunit.cu_version = (unsigned short )tmp___9;
#line 2032
    hdrptr += 2;
#line 2034
    cu_offset = (dwarf_vma )(start - section_begin);
#line 2036
    compunit.cu_abbrev_offset = (*byte_get)(hdrptr, offset_size);
#line 2037
    hdrptr += offset_size;
#line 2039
    tmp___10 = (*byte_get)(hdrptr, 1);
#line 2039
    compunit.cu_pointer_size = (unsigned char )tmp___10;
#line 2040
    hdrptr ++;
    }
#line 2042
    if (do_types) {
      {
#line 2044
      byte_get_64(hdrptr, & signature_high, & signature_low);
#line 2045
      hdrptr += 8;
#line 2046
      type_offset = (*byte_get)(hdrptr, offset_size);
#line 2047
      hdrptr += offset_size;
      }
    }
#line 2050
    if (do_loc) {
#line 2050
      goto _L___0;
    } else
#line 2050
    if (do_debug_loc) {
#line 2050
      goto _L___0;
    } else
#line 2050
    if (do_debug_ranges) {
      _L___0: /* CIL Label */ 
#line 2050
      if (num_debug_info_entries == 0U) {
#line 2050
        if (! do_types) {
#line 2054
          (debug_information + unit)->cu_offset = cu_offset;
#line 2055
          (debug_information + unit)->pointer_size = (unsigned int )compunit.cu_pointer_size;
#line 2057
          (debug_information + unit)->offset_size = (unsigned int )offset_size;
#line 2058
          (debug_information + unit)->dwarf_version = (int )compunit.cu_version;
#line 2059
          (debug_information + unit)->base_address = (dwarf_vma )0;
#line 2060
          (debug_information + unit)->addr_base = (dwarf_vma )4294967295U;
#line 2061
          (debug_information + unit)->ranges_base = (dwarf_vma )4294967295U;
#line 2062
          (debug_information + unit)->loc_offsets = (dwarf_vma *)((void *)0);
#line 2063
          (debug_information + unit)->have_frame_base = (int *)((void *)0);
#line 2064
          (debug_information + unit)->max_loc_offsets = 0U;
#line 2065
          (debug_information + unit)->num_loc_offsets = 0U;
#line 2066
          (debug_information + unit)->range_lists = (dwarf_vma *)((void *)0);
#line 2067
          (debug_information + unit)->max_range_lists = 0U;
#line 2068
          (debug_information + unit)->num_range_lists = 0U;
        }
      }
    }
#line 2071
    if (! do_loc) {
#line 2071
      if (dwarf_start_die == 0UL) {
        {
#line 2073
        tmp___11 = dwarf_vmatoa("x", cu_offset);
#line 2073
        tmp___12 = gettext("  Compilation Unit @ offset 0x%s:\n");
#line 2073
        printf((char const   */* __restrict  */)tmp___12, tmp___11);
        }
#line 2075
        if (offset_size == 8) {
#line 2075
          tmp___13 = "64-bit";
        } else {
#line 2075
          tmp___13 = "32-bit";
        }
        {
#line 2075
        tmp___14 = dwarf_vmatoa("x", compunit.cu_length);
#line 2075
        tmp___15 = gettext("   Length:        0x%s (%s)\n");
#line 2075
        printf((char const   */* __restrict  */)tmp___15, tmp___14, tmp___13);
#line 2078
        tmp___16 = gettext("   Version:       %d\n");
#line 2078
        printf((char const   */* __restrict  */)tmp___16, (int )compunit.cu_version);
#line 2079
        tmp___17 = dwarf_vmatoa("x", compunit.cu_abbrev_offset);
#line 2079
        tmp___18 = gettext("   Abbrev Offset: 0x%s\n");
#line 2079
        printf((char const   */* __restrict  */)tmp___18, tmp___17);
#line 2081
        tmp___19 = gettext("   Pointer Size:  %d\n");
#line 2081
        printf((char const   */* __restrict  */)tmp___19, (int )compunit.cu_pointer_size);
        }
#line 2082
        if (do_types) {
          {
#line 2086
          tmp___20 = dwarf_vmatoa64(signature_high, signature_low, buf___4, (unsigned int )sizeof(buf___4));
#line 2086
          tmp___21 = gettext("   Signature:     0x%s\n");
#line 2086
          printf((char const   */* __restrict  */)tmp___21, tmp___20);
#line 2089
          tmp___22 = dwarf_vmatoa("x", type_offset);
#line 2089
          tmp___23 = gettext("   Type Offset:   0x%s\n");
#line 2089
          printf((char const   */* __restrict  */)tmp___23, tmp___22);
          }
        }
      }
    }
#line 2094
    if ((cu_offset + compunit.cu_length) + (dwarf_vma )initial_length_size > section->size) {
      {
#line 2097
      tmp___24 = dwarf_vmatoa("x", compunit.cu_length);
#line 2097
      tmp___25 = dwarf_vmatoa("x", cu_offset);
#line 2097
      tmp___26 = gettext("Debug info is corrupted, length of CU at %s extends beyond end of section (length = %s)\n");
#line 2097
      warn((char const   *)tmp___26, tmp___25, tmp___24);
      }
#line 2101
      goto while_break___0;
    }
#line 2103
    tags = hdrptr;
#line 2104
    start += compunit.cu_length + (dwarf_vma )initial_length_size;
#line 2106
    if ((int )compunit.cu_version != 2) {
#line 2106
      if ((int )compunit.cu_version != 3) {
#line 2106
        if ((int )compunit.cu_version != 4) {
          {
#line 2110
          tmp___27 = dwarf_vmatoa("x", cu_offset);
#line 2110
          tmp___28 = gettext("CU at offset %s contains corrupt or unsupported version number: %d.\n");
#line 2110
          warn((char const   *)tmp___28, tmp___27, (int )compunit.cu_version);
          }
#line 2113
          goto __Cont;
        }
      }
    }
    {
#line 2116
    free_abbrevs();
    }
#line 2120
    if (compunit.cu_abbrev_offset >= debug_displays[abbrev_sec].section.size) {
      {
#line 2121
      tmp___29 = gettext("Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n");
#line 2121
      warn((char const   *)tmp___29, (unsigned long )compunit.cu_abbrev_offset, (unsigned long )debug_displays[abbrev_sec].section.size);
      }
    } else {
      {
#line 2125
      process_abbrev_section(debug_displays[abbrev_sec].section.start + compunit.cu_abbrev_offset,
                             debug_displays[abbrev_sec].section.start + debug_displays[abbrev_sec].section.size);
      }
    }
#line 2131
    level = 0;
#line 2132
    last_level = level;
#line 2133
    saved_level = -1;
    {
#line 2134
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2134
      if (! ((unsigned long )tags < (unsigned long )start)) {
#line 2134
        goto while_break___1;
      }
      {
#line 2141
      do_printing = 1;
#line 2143
      die_offset = (unsigned long )(tags - section_begin);
#line 2145
      tmp___30 = read_leb128(tags, & bytes_read, 0);
#line 2145
      abbrev_number = (unsigned long )tmp___30;
#line 2146
      tags += bytes_read;
      }
#line 2150
      if (abbrev_number == 0UL) {
#line 2153
        if (level == 0) {
#line 2153
          if ((unsigned long )start == (unsigned long )end) {
#line 2157
            chk = tags;
            {
#line 2157
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2157
              if (! ((unsigned long )chk < (unsigned long )start)) {
#line 2157
                goto while_break___2;
              }
#line 2158
              if ((int )*chk != 0) {
#line 2159
                goto while_break___2;
              }
#line 2157
              chk ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2160
            if ((unsigned long )chk == (unsigned long )start) {
#line 2161
              goto while_break___1;
            }
          }
        }
#line 2164
        level --;
#line 2165
        if (level < 0) {
#line 2169
          if (num_bogus_warns < 3U) {
            {
#line 2171
            tmp___31 = gettext("Bogus end-of-siblings marker detected at offset %lx in %s section\n");
#line 2171
            warn((char const   *)tmp___31, die_offset, section->name);
#line 2173
            num_bogus_warns ++;
            }
#line 2174
            if (num_bogus_warns == 3U) {
              {
#line 2175
              tmp___32 = gettext("Further warnings about bogus end-of-sibling markers suppressed\n");
#line 2175
              warn((char const   *)tmp___32);
              }
            }
          }
        }
#line 2178
        if (dwarf_start_die != 0UL) {
#line 2178
          if (level < saved_level) {
#line 2179
            return (1);
          }
        }
#line 2180
        goto while_continue___1;
      }
#line 2183
      if (! do_loc) {
#line 2185
        if (dwarf_start_die != 0UL) {
#line 2185
          if (die_offset < dwarf_start_die) {
#line 2186
            do_printing = 0;
          } else {
#line 2185
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
#line 2189
          if (dwarf_start_die != 0UL) {
#line 2189
            if (die_offset == dwarf_start_die) {
#line 2190
              saved_level = level;
            }
          }
#line 2191
          if (dwarf_cutoff_level == -1) {
#line 2191
            tmp___33 = 1;
          } else
#line 2191
          if (level < dwarf_cutoff_level) {
#line 2191
            tmp___33 = 1;
          } else {
#line 2191
            tmp___33 = 0;
          }
#line 2191
          do_printing = tmp___33;
#line 2193
          if (do_printing) {
            {
#line 2194
            tmp___34 = gettext(" <%d><%lx>: Abbrev Number: %lu");
#line 2194
            printf((char const   */* __restrict  */)tmp___34, level, die_offset, abbrev_number);
            }
          } else
#line 2196
          if (dwarf_cutoff_level == -1) {
            {
#line 2198
            tmp___35 = gettext(" <%d><%lx>: ...\n");
#line 2198
            printf((char const   */* __restrict  */)tmp___35, level, die_offset);
            }
          } else
#line 2196
          if (last_level < dwarf_cutoff_level) {
            {
#line 2198
            tmp___35 = gettext(" <%d><%lx>: ...\n");
#line 2198
            printf((char const   */* __restrict  */)tmp___35, level, die_offset);
            }
          }
#line 2199
          last_level = level;
        }
      }
#line 2205
      entry = first_abbrev;
      {
#line 2205
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2205
        if (entry) {
#line 2205
          if (! (entry->entry != abbrev_number)) {
#line 2205
            goto while_break___3;
          }
        } else {
#line 2205
          goto while_break___3;
        }
#line 2208
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 2205
        entry = entry->next;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2210
      if ((unsigned long )entry == (unsigned long )((void *)0)) {
#line 2212
        if (! do_loc) {
#line 2212
          if (do_printing) {
            {
#line 2214
            printf((char const   */* __restrict  */)"\n");
#line 2215
            fflush(stdout);
            }
          }
        }
        {
#line 2217
        tmp___36 = gettext("DIE at offset %lx refers to abbreviation number %lu which does not exist\n");
#line 2217
        warn((char const   *)tmp___36, die_offset, abbrev_number);
        }
#line 2219
        return (0);
      }
#line 2222
      if (! do_loc) {
#line 2222
        if (do_printing) {
          {
#line 2223
          tmp___37 = get_TAG_name(entry->tag);
#line 2223
          printf((char const   */* __restrict  */)" (%s)\n", tmp___37);
          }
        }
      }
      {
#line 2230
      if (entry->tag == 17UL) {
#line 2230
        goto case_17;
      }
#line 2234
      if (entry->tag == 46UL) {
#line 2234
        goto case_46;
      }
#line 2234
      if (entry->tag == 3UL) {
#line 2234
        goto case_46;
      }
#line 2227
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 2228
      need_base_address = 0;
#line 2229
      goto switch_break;
      case_17: /* CIL Label */ 
#line 2231
      need_base_address = 1;
#line 2232
      goto switch_break;
      case_46: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 2235
      need_base_address = 0;
#line 2237
      have_frame_base = 0;
#line 2238
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 2241
      attr = entry->first_attr;
      {
#line 2241
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2241
        if (! attr) {
#line 2241
          goto while_break___4;
        }
#line 2245
        if (! do_loc) {
#line 2245
          if (do_printing) {
            {
#line 2247
            printf((char const   */* __restrict  */)"    <%lx>", (unsigned long )(tags - section_begin));
            }
          }
        }
#line 2249
        arg = debug_information;
#line 2250
        if (debug_information) {
#line 2251
          arg += unit;
        }
#line 2253
        if (do_loc) {
#line 2253
          tmp___38 = 1;
        } else
#line 2253
        if (! do_printing) {
#line 2253
          tmp___38 = 1;
        } else {
#line 2253
          tmp___38 = 0;
        }
        {
#line 2253
        tags = read_and_display_attr(attr->attribute, attr->form, tags, cu_offset,
                                     (dwarf_vma )compunit.cu_pointer_size, (dwarf_vma )offset_size,
                                     (int )compunit.cu_version, arg, tmp___38, section);
#line 2241
        attr = attr->next;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2263
      if (entry->children) {
#line 2264
        level ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 2000
    unit ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2270
  if (do_loc) {
#line 2270
    goto _L___2;
  } else
#line 2270
  if (do_debug_loc) {
#line 2270
    goto _L___2;
  } else
#line 2270
  if (do_debug_ranges) {
    _L___2: /* CIL Label */ 
#line 2270
    if (num_debug_info_entries == 0U) {
#line 2270
      if (! do_types) {
#line 2273
        num_debug_info_entries = num_units;
      }
    }
  }
#line 2275
  if (! do_loc) {
    {
#line 2276
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 2278
  return (1);
}
}
#line 2287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned int load_debug_info(void *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2292
  last_pointer_size = 0U;
#line 2293
  warned_about_missing_comp_units = 0;
#line 2297
  if (num_debug_info_entries == 4294967295U) {
#line 2298
    return (0U);
  }
#line 2301
  if (num_debug_info_entries > 0U) {
#line 2302
    return (num_debug_info_entries);
  }
  {
#line 2304
  tmp___2 = load_debug_section((enum dwarf_section_display_enum )3, file);
  }
#line 2304
  if (tmp___2) {
    {
#line 2304
    tmp___3 = process_debug_info(& debug_displays[3].section, file, (enum dwarf_section_display_enum )0,
                                 1, 0);
    }
#line 2304
    if (tmp___3) {
#line 2306
      return (num_debug_info_entries);
    } else {
#line 2304
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 2307
    tmp___0 = load_debug_section((enum dwarf_section_display_enum )21, file);
    }
#line 2307
    if (tmp___0) {
      {
#line 2307
      tmp___1 = process_debug_info(& debug_displays[21].section, file, (enum dwarf_section_display_enum )22,
                                   1, 0);
      }
#line 2307
      if (tmp___1) {
#line 2310
        return (num_debug_info_entries);
      }
    }
  }
#line 2312
  num_debug_info_entries = 4294967295U;
#line 2313
  return (0U);
}
}
#line 2316 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_lines_raw(struct dwarf_section *section , unsigned char *data ,
                                   unsigned char *end ) 
{ 
  unsigned char *start ;
  char *tmp___0 ;
  DWARF2_Internal_LineInfo linfo ;
  unsigned char *standard_opcodes ;
  unsigned char *end_of_sequence ;
  unsigned char *hdrptr ;
  unsigned long hdroff ;
  int initial_length_size ;
  int offset_size ;
  int i ;
  char *tmp___1 ;
  elf_vma tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  unsigned char *name___0 ;
  unsigned int bytes_read ;
  size_t tmp___30 ;
  dwarf_vma tmp___31 ;
  char const   *tmp___32 ;
  dwarf_vma tmp___33 ;
  char const   *tmp___34 ;
  dwarf_vma tmp___35 ;
  char const   *tmp___36 ;
  char *tmp___37 ;
  unsigned char op_code ;
  dwarf_signed_vma adv ;
  dwarf_vma uladv ;
  unsigned int bytes_read___0 ;
  unsigned char *tmp___38 ;
  char const   *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  char const   *tmp___42 ;
  char const   *tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  char const   *tmp___49 ;
  char const   *tmp___50 ;
  char *tmp___51 ;
  char const   *tmp___52 ;
  char const   *tmp___53 ;
  char *tmp___54 ;
  char const   *tmp___55 ;
  char *tmp___56 ;
  dwarf_vma tmp___57 ;
  char const   *tmp___58 ;
  char *tmp___59 ;
  char const   *tmp___60 ;
  char *tmp___61 ;
  char const   *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char const   *tmp___65 ;
  char const   *tmp___66 ;
  char *tmp___67 ;
  char const   *tmp___68 ;
  char const   *tmp___69 ;
  char *tmp___70 ;
  char const   *tmp___71 ;
  char const   *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char const   *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char const   *tmp___79 ;
  dwarf_vma tmp___80 ;
  char const   *tmp___81 ;

  {
  {
#line 2321
  start = section->start;
#line 2323
  tmp___0 = gettext("Raw dump of debug contents of section %s:\n\n");
#line 2323
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 2326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2326
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 2326
      goto while_break;
    }
    {
#line 2337
    hdrptr = data;
#line 2338
    hdroff = (unsigned long )(hdrptr - start);
#line 2341
    linfo.li_length = (*byte_get)(hdrptr, 4);
#line 2342
    hdrptr += 4;
    }
#line 2344
    if (linfo.li_length == 4294967295ULL) {
      {
#line 2347
      linfo.li_length = (*byte_get)(hdrptr, 8);
#line 2348
      hdrptr += 8;
#line 2349
      offset_size = 8;
#line 2350
      initial_length_size = 12;
      }
    } else {
#line 2354
      offset_size = 4;
#line 2355
      initial_length_size = 4;
    }
#line 2358
    if (linfo.li_length + (dwarf_vma )initial_length_size > section->size) {
      {
#line 2360
      tmp___1 = gettext("The information in section %s appears to be corrupt - the section is too small\n");
#line 2360
      warn((char const   *)tmp___1, section->name);
      }
#line 2363
      return (0);
    }
    {
#line 2367
    tmp___2 = (*byte_get)(hdrptr, 2);
#line 2367
    linfo.li_version = (unsigned short )tmp___2;
#line 2368
    hdrptr += 2;
    }
#line 2369
    if ((int )linfo.li_version != 2) {
#line 2369
      if ((int )linfo.li_version != 3) {
#line 2369
        if ((int )linfo.li_version != 4) {
          {
#line 2373
          tmp___3 = gettext("Only DWARF version 2, 3 and 4 line info is currently supported.\n");
#line 2373
          warn((char const   *)tmp___3);
          }
#line 2374
          return (0);
        }
      }
    }
    {
#line 2377
    tmp___4 = (*byte_get)(hdrptr, offset_size);
#line 2377
    linfo.li_prologue_length = (unsigned int )tmp___4;
#line 2378
    hdrptr += offset_size;
#line 2379
    tmp___5 = (*byte_get)(hdrptr, 1);
#line 2379
    linfo.li_min_insn_length = (unsigned char )tmp___5;
#line 2380
    hdrptr ++;
    }
#line 2381
    if ((int )linfo.li_version >= 4) {
      {
#line 2383
      tmp___6 = (*byte_get)(hdrptr, 1);
#line 2383
      linfo.li_max_ops_per_insn = (unsigned char )tmp___6;
#line 2384
      hdrptr ++;
      }
#line 2385
      if ((int )linfo.li_max_ops_per_insn == 0) {
        {
#line 2387
        tmp___7 = gettext("Invalid maximum operations per insn.\n");
#line 2387
        warn((char const   *)tmp___7);
        }
#line 2388
        return (0);
      }
    } else {
#line 2392
      linfo.li_max_ops_per_insn = (unsigned char)1;
    }
    {
#line 2393
    tmp___8 = (*byte_get)(hdrptr, 1);
#line 2393
    linfo.li_default_is_stmt = (unsigned char )tmp___8;
#line 2394
    hdrptr ++;
#line 2395
    tmp___9 = (*byte_get)(hdrptr, 1);
#line 2395
    linfo.li_line_base = (int )tmp___9;
#line 2396
    hdrptr ++;
#line 2397
    tmp___10 = (*byte_get)(hdrptr, 1);
#line 2397
    linfo.li_line_range = (unsigned char )tmp___10;
#line 2398
    hdrptr ++;
#line 2399
    tmp___11 = (*byte_get)(hdrptr, 1);
#line 2399
    linfo.li_opcode_base = (unsigned char )tmp___11;
#line 2400
    hdrptr ++;
#line 2403
    linfo.li_line_base <<= 24;
#line 2404
    linfo.li_line_base >>= 24;
#line 2406
    tmp___12 = gettext("  Offset:                      0x%lx\n");
#line 2406
    printf((char const   */* __restrict  */)tmp___12, hdroff);
#line 2407
    tmp___13 = gettext("  Length:                      %ld\n");
#line 2407
    printf((char const   */* __restrict  */)tmp___13, (long )linfo.li_length);
#line 2408
    tmp___14 = gettext("  DWARF Version:               %d\n");
#line 2408
    printf((char const   */* __restrict  */)tmp___14, (int )linfo.li_version);
#line 2409
    tmp___15 = gettext("  Prologue Length:             %d\n");
#line 2409
    printf((char const   */* __restrict  */)tmp___15, linfo.li_prologue_length);
#line 2410
    tmp___16 = gettext("  Minimum Instruction Length:  %d\n");
#line 2410
    printf((char const   */* __restrict  */)tmp___16, (int )linfo.li_min_insn_length);
    }
#line 2411
    if ((int )linfo.li_version >= 4) {
      {
#line 2412
      tmp___17 = gettext("  Maximum Ops per Instruction: %d\n");
#line 2412
      printf((char const   */* __restrict  */)tmp___17, (int )linfo.li_max_ops_per_insn);
      }
    }
    {
#line 2413
    tmp___18 = gettext("  Initial value of \'is_stmt\':  %d\n");
#line 2413
    printf((char const   */* __restrict  */)tmp___18, (int )linfo.li_default_is_stmt);
#line 2414
    tmp___19 = gettext("  Line Base:                   %d\n");
#line 2414
    printf((char const   */* __restrict  */)tmp___19, linfo.li_line_base);
#line 2415
    tmp___20 = gettext("  Line Range:                  %d\n");
#line 2415
    printf((char const   */* __restrict  */)tmp___20, (int )linfo.li_line_range);
#line 2416
    tmp___21 = gettext("  Opcode Base:                 %d\n");
#line 2416
    printf((char const   */* __restrict  */)tmp___21, (int )linfo.li_opcode_base);
#line 2418
    end_of_sequence = (data + linfo.li_length) + initial_length_size;
#line 2420
    reset_state_machine((int )linfo.li_default_is_stmt);
#line 2423
    standard_opcodes = hdrptr;
#line 2425
    tmp___22 = gettext("\n Opcodes:\n");
#line 2425
    printf((char const   */* __restrict  */)tmp___22);
#line 2427
    i = 1;
    }
    {
#line 2427
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2427
      if (! (i < (int )linfo.li_opcode_base)) {
#line 2427
        goto while_break___0;
      }
      {
#line 2428
      tmp___23 = gettext("  Opcode %d has %d args\n");
#line 2428
      printf((char const   */* __restrict  */)tmp___23, i, (int )*(standard_opcodes + (i - 1)));
#line 2427
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2431
    data = (standard_opcodes + (int )linfo.li_opcode_base) - 1;
#line 2433
    if ((int )*data == 0) {
      {
#line 2434
      tmp___24 = gettext("\n The Directory Table is empty.\n");
#line 2434
      printf((char const   */* __restrict  */)tmp___24);
      }
    } else {
      {
#line 2437
      tmp___25 = gettext("\n The Directory Table:\n");
#line 2437
      printf((char const   */* __restrict  */)tmp___25);
      }
      {
#line 2439
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2439
        if (! ((int )*data != 0)) {
#line 2439
          goto while_break___1;
        }
        {
#line 2441
        printf((char const   */* __restrict  */)"  %s\n", data);
#line 2443
        tmp___26 = strlen((char const   *)((char *)data));
#line 2443
        data += tmp___26 + 1UL;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2448
    data ++;
#line 2451
    if ((int )*data == 0) {
      {
#line 2452
      tmp___27 = gettext("\n The File Name Table is empty.\n");
#line 2452
      printf((char const   */* __restrict  */)tmp___27);
      }
    } else {
      {
#line 2455
      tmp___28 = gettext("\n The File Name Table:\n");
#line 2455
      printf((char const   */* __restrict  */)tmp___28);
#line 2456
      tmp___29 = gettext("  Entry\tDir\tTime\tSize\tName\n");
#line 2456
      printf((char const   */* __restrict  */)tmp___29);
      }
      {
#line 2458
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2458
        if (! ((int )*data != 0)) {
#line 2458
          goto while_break___2;
        }
        {
#line 2463
        (state_machine_regs.last_file_entry) ++;
#line 2463
        printf((char const   */* __restrict  */)"  %d\t", state_machine_regs.last_file_entry);
#line 2464
        name___0 = data;
#line 2466
        tmp___30 = strlen((char const   *)((char *)data));
#line 2466
        data += tmp___30 + 1UL;
#line 2468
        tmp___31 = read_leb128(data, & bytes_read, 0);
#line 2468
        tmp___32 = dwarf_vmatoa("u", tmp___31);
#line 2468
        printf((char const   */* __restrict  */)"%s\t", tmp___32);
#line 2470
        data += bytes_read;
#line 2471
        tmp___33 = read_leb128(data, & bytes_read, 0);
#line 2471
        tmp___34 = dwarf_vmatoa("u", tmp___33);
#line 2471
        printf((char const   */* __restrict  */)"%s\t", tmp___34);
#line 2473
        data += bytes_read;
#line 2474
        tmp___35 = read_leb128(data, & bytes_read, 0);
#line 2474
        tmp___36 = dwarf_vmatoa("u", tmp___35);
#line 2474
        printf((char const   */* __restrict  */)"%s\t", tmp___36);
#line 2476
        data += bytes_read;
#line 2477
        printf((char const   */* __restrict  */)"%s\n", name___0);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 2482
    data ++;
#line 2485
    tmp___37 = gettext("\n Line Number Statements:\n");
#line 2485
    printf((char const   */* __restrict  */)tmp___37);
    }
    {
#line 2487
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 2487
      if (! ((unsigned long )data < (unsigned long )end_of_sequence)) {
#line 2487
        goto while_break___3;
      }
#line 2494
      tmp___38 = data;
#line 2494
      data ++;
#line 2494
      op_code = *tmp___38;
#line 2496
      if ((int )op_code >= (int )linfo.li_opcode_base) {
#line 2498
        op_code = (unsigned char )((int )op_code - (int )linfo.li_opcode_base);
#line 2499
        uladv = (dwarf_vma )((int )op_code / (int )linfo.li_line_range);
#line 2500
        if ((int )linfo.li_max_ops_per_insn == 1) {
          {
#line 2502
          uladv *= (dwarf_vma )linfo.li_min_insn_length;
#line 2503
          state_machine_regs.address += uladv;
#line 2504
          tmp___39 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2504
          tmp___40 = dwarf_vmatoa("u", uladv);
#line 2504
          tmp___41 = gettext("  Special opcode %d: advance Address by %s to 0x%s");
#line 2504
          printf((char const   */* __restrict  */)tmp___41, (int )op_code, tmp___40,
                 tmp___39);
          }
        } else {
          {
#line 2511
          state_machine_regs.address += (((dwarf_vma )state_machine_regs.op_index + uladv) / (dwarf_vma )linfo.li_max_ops_per_insn) * (dwarf_vma )linfo.li_min_insn_length;
#line 2515
          state_machine_regs.op_index = (unsigned char )(((dwarf_vma )state_machine_regs.op_index + uladv) % (unsigned long long )linfo.li_max_ops_per_insn);
#line 2518
          tmp___42 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2518
          tmp___43 = dwarf_vmatoa("u", uladv);
#line 2518
          tmp___44 = gettext("  Special opcode %d: advance Address by %s to 0x%s[%d]");
#line 2518
          printf((char const   */* __restrict  */)tmp___44, (int )op_code, tmp___43,
                 tmp___42, (int )state_machine_regs.op_index);
          }
        }
        {
#line 2524
        adv = (dwarf_signed_vma )((int )op_code % (int )linfo.li_line_range + linfo.li_line_base);
#line 2525
        state_machine_regs.line = (unsigned int )((dwarf_signed_vma )state_machine_regs.line + adv);
#line 2526
        tmp___45 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2526
        tmp___46 = gettext(" and Line by %s to %d\n");
#line 2526
        printf((char const   */* __restrict  */)tmp___46, tmp___45, state_machine_regs.line);
        }
      } else {
        {
#line 2531
        if ((int )op_code == 0) {
#line 2531
          goto case_0;
        }
#line 2535
        if ((int )op_code == 1) {
#line 2535
          goto case_1;
        }
#line 2539
        if ((int )op_code == 2) {
#line 2539
          goto case_2;
        }
#line 2566
        if ((int )op_code == 3) {
#line 2566
          goto case_3;
        }
#line 2575
        if ((int )op_code == 4) {
#line 2575
          goto case_4;
        }
#line 2583
        if ((int )op_code == 5) {
#line 2583
          goto case_5;
        }
#line 2591
        if ((int )op_code == 6) {
#line 2591
          goto case_6;
        }
#line 2598
        if ((int )op_code == 7) {
#line 2598
          goto case_7;
        }
#line 2603
        if ((int )op_code == 8) {
#line 2603
          goto case_8;
        }
#line 2629
        if ((int )op_code == 9) {
#line 2629
          goto case_9;
        }
#line 2639
        if ((int )op_code == 10) {
#line 2639
          goto case_10;
        }
#line 2643
        if ((int )op_code == 11) {
#line 2643
          goto case_11;
        }
#line 2647
        if ((int )op_code == 12) {
#line 2647
          goto case_12;
        }
#line 2653
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 2532
        tmp___47 = process_extended_line_op(data, (int )linfo.li_default_is_stmt);
#line 2532
        data += tmp___47;
        }
#line 2533
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 2536
        tmp___48 = gettext("  Copy\n");
#line 2536
        printf((char const   */* __restrict  */)tmp___48);
        }
#line 2537
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 2540
        uladv = read_leb128(data, & bytes_read___0, 0);
#line 2541
        data += bytes_read___0;
        }
#line 2542
        if ((int )linfo.li_max_ops_per_insn == 1) {
          {
#line 2544
          uladv *= (dwarf_vma )linfo.li_min_insn_length;
#line 2545
          state_machine_regs.address += uladv;
#line 2546
          tmp___49 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2546
          tmp___50 = dwarf_vmatoa("u", uladv);
#line 2546
          tmp___51 = gettext("  Advance PC by %s to 0x%s\n");
#line 2546
          printf((char const   */* __restrict  */)tmp___51, tmp___50, tmp___49);
          }
        } else {
          {
#line 2552
          state_machine_regs.address += (((dwarf_vma )state_machine_regs.op_index + uladv) / (dwarf_vma )linfo.li_max_ops_per_insn) * (dwarf_vma )linfo.li_min_insn_length;
#line 2556
          state_machine_regs.op_index = (unsigned char )(((dwarf_vma )state_machine_regs.op_index + uladv) % (unsigned long long )linfo.li_max_ops_per_insn);
#line 2559
          tmp___52 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2559
          tmp___53 = dwarf_vmatoa("u", uladv);
#line 2559
          tmp___54 = gettext("  Advance PC by %s to 0x%s[%d]\n");
#line 2559
          printf((char const   */* __restrict  */)tmp___54, tmp___53, tmp___52, (int )state_machine_regs.op_index);
          }
        }
#line 2564
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 2567
        adv = read_sleb128(data, & bytes_read___0);
#line 2568
        data += bytes_read___0;
#line 2569
        state_machine_regs.line = (unsigned int )((dwarf_signed_vma )state_machine_regs.line + adv);
#line 2570
        tmp___55 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2570
        tmp___56 = gettext("  Advance Line by %s to %d\n");
#line 2570
        printf((char const   */* __restrict  */)tmp___56, tmp___55, state_machine_regs.line);
        }
#line 2573
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 2576
        tmp___57 = read_leb128(data, & bytes_read___0, 0);
#line 2576
        adv = (dwarf_signed_vma )tmp___57;
#line 2577
        data += bytes_read___0;
#line 2578
        tmp___58 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2578
        tmp___59 = gettext("  Set File Name to entry %s in the File Name Table\n");
#line 2578
        printf((char const   */* __restrict  */)tmp___59, tmp___58);
#line 2580
        state_machine_regs.file = (unsigned int )adv;
        }
#line 2581
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 2584
        uladv = read_leb128(data, & bytes_read___0, 0);
#line 2585
        data += bytes_read___0;
#line 2586
        tmp___60 = dwarf_vmatoa("u", uladv);
#line 2586
        tmp___61 = gettext("  Set column to %s\n");
#line 2586
        printf((char const   */* __restrict  */)tmp___61, tmp___60);
#line 2588
        state_machine_regs.column = (unsigned int )uladv;
        }
#line 2589
        goto switch_break;
        case_6: /* CIL Label */ 
        {
#line 2592
        adv = (dwarf_signed_vma )state_machine_regs.is_stmt;
#line 2593
        adv = (dwarf_signed_vma )(! adv);
#line 2594
        tmp___62 = dwarf_vmatoa("d", (dwarf_vma )adv);
#line 2594
        tmp___63 = gettext("  Set is_stmt to %s\n");
#line 2594
        printf((char const   */* __restrict  */)tmp___63, tmp___62);
#line 2595
        state_machine_regs.is_stmt = (int )adv;
        }
#line 2596
        goto switch_break;
        case_7: /* CIL Label */ 
        {
#line 2599
        tmp___64 = gettext("  Set basic block\n");
#line 2599
        printf((char const   */* __restrict  */)tmp___64);
#line 2600
        state_machine_regs.basic_block = 1;
        }
#line 2601
        goto switch_break;
        case_8: /* CIL Label */ 
#line 2604
        uladv = (dwarf_vma )((255 - (int )linfo.li_opcode_base) / (int )linfo.li_line_range);
#line 2605
        if (linfo.li_max_ops_per_insn) {
          {
#line 2607
          uladv *= (dwarf_vma )linfo.li_min_insn_length;
#line 2608
          state_machine_regs.address += uladv;
#line 2609
          tmp___65 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2609
          tmp___66 = dwarf_vmatoa("u", uladv);
#line 2609
          tmp___67 = gettext("  Advance PC by constant %s to 0x%s\n");
#line 2609
          printf((char const   */* __restrict  */)tmp___67, tmp___66, tmp___65);
          }
        } else {
          {
#line 2615
          state_machine_regs.address += (((dwarf_vma )state_machine_regs.op_index + uladv) / (dwarf_vma )linfo.li_max_ops_per_insn) * (dwarf_vma )linfo.li_min_insn_length;
#line 2619
          state_machine_regs.op_index = (unsigned char )(((dwarf_vma )state_machine_regs.op_index + uladv) % (unsigned long long )linfo.li_max_ops_per_insn);
#line 2622
          tmp___68 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2622
          tmp___69 = dwarf_vmatoa("u", uladv);
#line 2622
          tmp___70 = gettext("  Advance PC by constant %s to 0x%s[%d]\n");
#line 2622
          printf((char const   */* __restrict  */)tmp___70, tmp___69, tmp___68, (int )state_machine_regs.op_index);
          }
        }
#line 2627
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 2630
        uladv = (*byte_get)(data, 2);
#line 2631
        data += 2;
#line 2632
        state_machine_regs.address += uladv;
#line 2633
        state_machine_regs.op_index = (unsigned char)0;
#line 2634
        tmp___71 = dwarf_vmatoa("x", state_machine_regs.address);
#line 2634
        tmp___72 = dwarf_vmatoa("u", uladv);
#line 2634
        tmp___73 = gettext("  Advance PC by fixed size amount %s to 0x%s\n");
#line 2634
        printf((char const   */* __restrict  */)tmp___73, tmp___72, tmp___71);
        }
#line 2637
        goto switch_break;
        case_10: /* CIL Label */ 
        {
#line 2640
        tmp___74 = gettext("  Set prologue_end to true\n");
#line 2640
        printf((char const   */* __restrict  */)tmp___74);
        }
#line 2641
        goto switch_break;
        case_11: /* CIL Label */ 
        {
#line 2644
        tmp___75 = gettext("  Set epilogue_begin to true\n");
#line 2644
        printf((char const   */* __restrict  */)tmp___75);
        }
#line 2645
        goto switch_break;
        case_12: /* CIL Label */ 
        {
#line 2648
        uladv = read_leb128(data, & bytes_read___0, 0);
#line 2649
        data += bytes_read___0;
#line 2650
        tmp___76 = dwarf_vmatoa("u", uladv);
#line 2650
        tmp___77 = gettext("  Set ISA to %s\n");
#line 2650
        printf((char const   */* __restrict  */)tmp___77, tmp___76);
        }
#line 2651
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 2654
        tmp___78 = gettext("  Unknown opcode %d with operands: ");
#line 2654
        printf((char const   */* __restrict  */)tmp___78, (int )op_code);
#line 2656
        i = (int )*(standard_opcodes + ((int )op_code - 1));
        }
        {
#line 2656
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2656
          if (! (i > 0)) {
#line 2656
            goto while_break___4;
          }
#line 2658
          if (i == 1) {
#line 2658
            tmp___79 = "";
          } else {
#line 2658
            tmp___79 = ", ";
          }
          {
#line 2658
          tmp___80 = read_leb128(data, & bytes_read___0, 0);
#line 2658
          tmp___81 = dwarf_vmatoa("x", tmp___80);
#line 2658
          printf((char const   */* __restrict  */)"0x%s%s", tmp___81, tmp___79);
#line 2661
          data += bytes_read___0;
#line 2656
          i --;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 2663
        putchar('\n');
        }
#line 2664
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 2667
    putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2670
  return (1);
}
}
#line 2683 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_lines_decoded(struct dwarf_section *section , unsigned char *data ,
                                       unsigned char *end ) 
{ 
  char *tmp___0 ;
  DWARF2_Internal_LineInfo linfo ;
  unsigned char *standard_opcodes ;
  unsigned char *end_of_sequence ;
  unsigned char *hdrptr ;
  int initial_length_size ;
  int offset_size ;
  int i ;
  File_Entry *file_table ;
  unsigned int n_files ;
  unsigned char **directory_table ;
  unsigned int n_directories ;
  char *tmp___1 ;
  elf_vma tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  unsigned char *ptr_directory_table ;
  size_t tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  unsigned char *ptr_file_name_table ;
  unsigned int bytes_read ;
  size_t tmp___15 ;
  void *tmp___16 ;
  unsigned int bytes_read___0 ;
  size_t tmp___17 ;
  dwarf_vma tmp___18 ;
  dwarf_vma tmp___19 ;
  dwarf_vma tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  unsigned int ix ;
  char const   *directory ;
  char const   *tmp___23 ;
  char *tmp___24 ;
  size_t tmp___25 ;
  char *tmp___26 ;
  unsigned char op_code ;
  int adv ;
  unsigned long uladv ;
  unsigned int bytes_read___1 ;
  int is_special_opcode ;
  unsigned char *tmp___27 ;
  unsigned int ext_op_code_len ;
  unsigned char ext_op_code ;
  unsigned char *op_code_data ;
  dwarf_vma tmp___28 ;
  char *tmp___29 ;
  unsigned char *tmp___30 ;
  void *tmp___31 ;
  size_t tmp___32 ;
  dwarf_vma tmp___33 ;
  dwarf_vma tmp___34 ;
  dwarf_vma tmp___35 ;
  char *tmp___36 ;
  dwarf_vma tmp___37 ;
  dwarf_signed_vma tmp___38 ;
  dwarf_vma tmp___39 ;
  dwarf_vma tmp___40 ;
  elf_vma tmp___41 ;
  dwarf_vma tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  dwarf_vma tmp___46 ;
  char const   *tmp___47 ;
  unsigned int MAX_FILENAME_LENGTH ;
  char *fileName ;
  char *newFileName ;
  size_t fileNameLength ;
  size_t tmp___48 ;
  void *tmp___49 ;
  void *tmp___50 ;

  {
  {
#line 2688
  tmp___0 = gettext("Decoded dump of debug contents of section %s:\n\n");
#line 2688
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 2691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2691
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 2691
      goto while_break;
    }
    {
#line 2701
    file_table = (File_Entry *)((void *)0);
#line 2702
    n_files = 0U;
#line 2703
    directory_table = (unsigned char **)((void *)0);
#line 2704
    n_directories = 0U;
#line 2706
    hdrptr = data;
#line 2712
    linfo.li_length = (*byte_get)(hdrptr, 4);
#line 2713
    hdrptr += 4;
    }
#line 2715
    if (linfo.li_length == 4294967295ULL) {
      {
#line 2718
      linfo.li_length = (*byte_get)(hdrptr, 8);
#line 2719
      hdrptr += 8;
#line 2720
      offset_size = 8;
#line 2721
      initial_length_size = 12;
      }
    } else {
#line 2725
      offset_size = 4;
#line 2726
      initial_length_size = 4;
    }
#line 2729
    if (linfo.li_length + (dwarf_vma )initial_length_size > section->size) {
      {
#line 2731
      tmp___1 = gettext("The line info appears to be corrupt - the section is too small\n");
#line 2731
      warn((char const   *)tmp___1);
      }
#line 2733
      return (0);
    }
    {
#line 2737
    tmp___2 = (*byte_get)(hdrptr, 2);
#line 2737
    linfo.li_version = (unsigned short )tmp___2;
#line 2738
    hdrptr += 2;
    }
#line 2739
    if ((int )linfo.li_version != 2) {
#line 2739
      if ((int )linfo.li_version != 3) {
#line 2739
        if ((int )linfo.li_version != 4) {
          {
#line 2743
          tmp___3 = gettext("Only DWARF version 2, 3 and 4 line info is currently supported.\n");
#line 2743
          warn((char const   *)tmp___3);
          }
#line 2745
          return (0);
        }
      }
    }
    {
#line 2748
    tmp___4 = (*byte_get)(hdrptr, offset_size);
#line 2748
    linfo.li_prologue_length = (unsigned int )tmp___4;
#line 2749
    hdrptr += offset_size;
#line 2750
    tmp___5 = (*byte_get)(hdrptr, 1);
#line 2750
    linfo.li_min_insn_length = (unsigned char )tmp___5;
#line 2751
    hdrptr ++;
    }
#line 2752
    if ((int )linfo.li_version >= 4) {
      {
#line 2754
      tmp___6 = (*byte_get)(hdrptr, 1);
#line 2754
      linfo.li_max_ops_per_insn = (unsigned char )tmp___6;
#line 2755
      hdrptr ++;
      }
#line 2756
      if ((int )linfo.li_max_ops_per_insn == 0) {
        {
#line 2758
        tmp___7 = gettext("Invalid maximum operations per insn.\n");
#line 2758
        warn((char const   *)tmp___7);
        }
#line 2759
        return (0);
      }
    } else {
#line 2763
      linfo.li_max_ops_per_insn = (unsigned char)1;
    }
    {
#line 2764
    tmp___8 = (*byte_get)(hdrptr, 1);
#line 2764
    linfo.li_default_is_stmt = (unsigned char )tmp___8;
#line 2765
    hdrptr ++;
#line 2766
    tmp___9 = (*byte_get)(hdrptr, 1);
#line 2766
    linfo.li_line_base = (int )tmp___9;
#line 2767
    hdrptr ++;
#line 2768
    tmp___10 = (*byte_get)(hdrptr, 1);
#line 2768
    linfo.li_line_range = (unsigned char )tmp___10;
#line 2769
    hdrptr ++;
#line 2770
    tmp___11 = (*byte_get)(hdrptr, 1);
#line 2770
    linfo.li_opcode_base = (unsigned char )tmp___11;
#line 2771
    hdrptr ++;
#line 2774
    linfo.li_line_base <<= 24;
#line 2775
    linfo.li_line_base >>= 24;
#line 2778
    end_of_sequence = (data + linfo.li_length) + initial_length_size;
#line 2780
    reset_state_machine((int )linfo.li_default_is_stmt);
#line 2783
    standard_opcodes = hdrptr;
#line 2786
    data = (standard_opcodes + (int )linfo.li_opcode_base) - 1;
    }
#line 2787
    if ((int )*data != 0) {
#line 2789
      ptr_directory_table = data;
      {
#line 2791
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2791
        if (! ((int )*data != 0)) {
#line 2791
          goto while_break___0;
        }
        {
#line 2793
        tmp___12 = strlen((char const   *)((char *)data));
#line 2793
        data += tmp___12 + 1UL;
#line 2794
        n_directories ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 2798
      tmp___13 = xmalloc((unsigned long )n_directories * sizeof(unsigned char *));
#line 2798
      directory_table = (unsigned char **)tmp___13;
#line 2801
      i = 0;
      }
      {
#line 2802
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2802
        if (! ((int )*ptr_directory_table != 0)) {
#line 2802
          goto while_break___1;
        }
        {
#line 2804
        *(directory_table + i) = ptr_directory_table;
#line 2805
        tmp___14 = strlen((char const   *)((char *)ptr_directory_table));
#line 2805
        ptr_directory_table += tmp___14 + 1UL;
#line 2806
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 2810
    data ++;
#line 2813
    if ((int )*data != 0) {
#line 2815
      ptr_file_name_table = data;
      {
#line 2817
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2817
        if (! ((int )*data != 0)) {
#line 2817
          goto while_break___2;
        }
        {
#line 2823
        tmp___15 = strlen((char const   *)((char *)data));
#line 2823
        data += tmp___15 + 1UL;
#line 2824
        read_leb128(data, & bytes_read, 0);
#line 2825
        data += bytes_read;
#line 2826
        read_leb128(data, & bytes_read, 0);
#line 2827
        data += bytes_read;
#line 2828
        read_leb128(data, & bytes_read, 0);
#line 2829
        data += bytes_read;
#line 2831
        n_files ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2835
      tmp___16 = xmalloc((unsigned long )n_files * sizeof(File_Entry ));
#line 2835
      file_table = (File_Entry *)tmp___16;
#line 2837
      i = 0;
      }
      {
#line 2838
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2838
        if (! ((int )*ptr_file_name_table != 0)) {
#line 2838
          goto while_break___3;
        }
        {
#line 2842
        (file_table + i)->name = ptr_file_name_table;
#line 2843
        tmp___17 = strlen((char const   *)((char *)ptr_file_name_table));
#line 2843
        ptr_file_name_table += tmp___17 + 1UL;
#line 2846
        tmp___18 = read_leb128(ptr_file_name_table, & bytes_read___0, 0);
#line 2846
        (file_table + i)->directory_index = (unsigned int )tmp___18;
#line 2848
        ptr_file_name_table += bytes_read___0;
#line 2849
        tmp___19 = read_leb128(ptr_file_name_table, & bytes_read___0, 0);
#line 2849
        (file_table + i)->modification_date = (unsigned int )tmp___19;
#line 2851
        ptr_file_name_table += bytes_read___0;
#line 2852
        tmp___20 = read_leb128(ptr_file_name_table, & bytes_read___0, 0);
#line 2852
        (file_table + i)->length = (unsigned int )tmp___20;
#line 2853
        ptr_file_name_table += bytes_read___0;
#line 2854
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2856
      i = 0;
#line 2859
      if ((unsigned long )directory_table == (unsigned long )((void *)0)) {
        {
#line 2861
        tmp___21 = gettext("CU: %s:\n");
#line 2861
        printf((char const   */* __restrict  */)tmp___21, (file_table + 0)->name);
#line 2862
        tmp___22 = gettext("File name                            Line number    Starting address\n");
#line 2862
        printf((char const   */* __restrict  */)tmp___22);
        }
      } else {
#line 2866
        ix = (file_table + 0)->directory_index;
#line 2867
        if (ix) {
#line 2867
          tmp___23 = (char const   *)((char *)*(directory_table + (ix - 1U)));
        } else {
#line 2867
          tmp___23 = ".";
        }
#line 2867
        directory = tmp___23;
#line 2868
        if (do_wide) {
          {
#line 2869
          tmp___24 = gettext("CU: %s/%s:\n");
#line 2869
          printf((char const   */* __restrict  */)tmp___24, directory, (file_table + 0)->name);
          }
        } else {
          {
#line 2868
          tmp___25 = strlen(directory);
          }
#line 2868
          if (tmp___25 < 76UL) {
            {
#line 2869
            tmp___24 = gettext("CU: %s/%s:\n");
#line 2869
            printf((char const   */* __restrict  */)tmp___24, directory, (file_table + 0)->name);
            }
          } else {
            {
#line 2871
            printf((char const   */* __restrict  */)"%s:\n", (file_table + 0)->name);
            }
          }
        }
        {
#line 2873
        tmp___26 = gettext("File name                            Line number    Starting address\n");
#line 2873
        printf((char const   */* __restrict  */)tmp___26);
        }
      }
    }
#line 2878
    data ++;
    {
#line 2881
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2881
      if (! ((unsigned long )data < (unsigned long )end_of_sequence)) {
#line 2881
        goto while_break___4;
      }
#line 2887
      is_special_opcode = 0;
#line 2889
      tmp___27 = data;
#line 2889
      data ++;
#line 2889
      op_code = *tmp___27;
#line 2891
      if ((int )op_code >= (int )linfo.li_opcode_base) {
#line 2893
        op_code = (unsigned char )((int )op_code - (int )linfo.li_opcode_base);
#line 2894
        uladv = (unsigned long )((int )op_code / (int )linfo.li_line_range);
#line 2895
        if ((int )linfo.li_max_ops_per_insn == 1) {
#line 2897
          uladv *= (unsigned long )linfo.li_min_insn_length;
#line 2898
          state_machine_regs.address += (dwarf_vma )uladv;
        } else {
#line 2902
          state_machine_regs.address += (dwarf_vma )((((unsigned long )state_machine_regs.op_index + uladv) / (unsigned long )linfo.li_max_ops_per_insn) * (unsigned long )linfo.li_min_insn_length);
#line 2906
          state_machine_regs.op_index = (unsigned char )(((unsigned long )state_machine_regs.op_index + uladv) % (unsigned long )linfo.li_max_ops_per_insn);
        }
#line 2911
        adv = (int )op_code % (int )linfo.li_line_range + linfo.li_line_base;
#line 2912
        state_machine_regs.line += (unsigned int )adv;
#line 2913
        is_special_opcode = 1;
      } else {
        {
#line 2917
        if ((int )op_code == 0) {
#line 2917
          goto case_0;
        }
#line 2981
        if ((int )op_code == 1) {
#line 2981
          goto case_1___0;
        }
#line 2984
        if ((int )op_code == 2) {
#line 2984
          goto case_2___0;
        }
#line 3004
        if ((int )op_code == 3) {
#line 3004
          goto case_3___0;
        }
#line 3010
        if ((int )op_code == 4) {
#line 3010
          goto case_4___0;
        }
#line 3029
        if ((int )op_code == 5) {
#line 3029
          goto case_5;
        }
#line 3035
        if ((int )op_code == 6) {
#line 3035
          goto case_6;
        }
#line 3041
        if ((int )op_code == 7) {
#line 3041
          goto case_7;
        }
#line 3045
        if ((int )op_code == 8) {
#line 3045
          goto case_8;
        }
#line 3064
        if ((int )op_code == 9) {
#line 3064
          goto case_9;
        }
#line 3071
        if ((int )op_code == 10) {
#line 3071
          goto case_10;
        }
#line 3074
        if ((int )op_code == 11) {
#line 3074
          goto case_11;
        }
#line 3077
        if ((int )op_code == 12) {
#line 3077
          goto case_12;
        }
#line 3083
        goto switch_default___0;
        case_0: /* CIL Label */ 
        {
#line 2921
        op_code_data = data;
#line 2923
        tmp___28 = read_leb128(op_code_data, & bytes_read___1, 0);
#line 2923
        ext_op_code_len = (unsigned int )tmp___28;
#line 2924
        op_code_data += bytes_read___1;
        }
#line 2926
        if (ext_op_code_len == 0U) {
          {
#line 2928
          tmp___29 = gettext("badly formed extended line op encountered!\n");
#line 2928
          warn((char const   *)tmp___29);
          }
#line 2929
          goto switch_break;
        }
#line 2931
        ext_op_code_len += bytes_read___1;
#line 2932
        tmp___30 = op_code_data;
#line 2932
        op_code_data ++;
#line 2932
        ext_op_code = *tmp___30;
        {
#line 2936
        if ((int )ext_op_code == 1) {
#line 2936
          goto case_1;
        }
#line 2939
        if ((int )ext_op_code == 2) {
#line 2939
          goto case_2;
        }
#line 2944
        if ((int )ext_op_code == 3) {
#line 2944
          goto case_3;
        }
#line 2969
        if ((int )ext_op_code == 22) {
#line 2969
          goto case_22;
        }
#line 2969
        if ((int )ext_op_code == 4) {
#line 2969
          goto case_22;
        }
#line 2973
        goto switch_default;
        case_1: /* CIL Label */ 
        {
#line 2937
        reset_state_machine((int )linfo.li_default_is_stmt);
        }
#line 2938
        goto switch_break___0;
        case_2: /* CIL Label */ 
        {
#line 2940
        state_machine_regs.address = (*byte_get)(op_code_data, (int )((ext_op_code_len - bytes_read___1) - 1U));
#line 2942
        state_machine_regs.op_index = (unsigned char)0;
        }
#line 2943
        goto switch_break___0;
        case_3: /* CIL Label */ 
        {
#line 2946
        tmp___31 = xrealloc((void *)file_table, (unsigned long )(n_files + 1U) * sizeof(File_Entry ));
#line 2946
        file_table = (File_Entry *)tmp___31;
#line 2949
        (state_machine_regs.last_file_entry) ++;
#line 2951
        (file_table + n_files)->name = op_code_data;
#line 2952
        tmp___32 = strlen((char const   *)((char *)op_code_data));
#line 2952
        op_code_data += tmp___32 + 1UL;
#line 2954
        tmp___33 = read_leb128(op_code_data, & bytes_read___1, 0);
#line 2954
        (file_table + n_files)->directory_index = (unsigned int )tmp___33;
#line 2956
        op_code_data += bytes_read___1;
#line 2958
        tmp___34 = read_leb128(op_code_data, & bytes_read___1, 0);
#line 2958
        (file_table + n_files)->modification_date = (unsigned int )tmp___34;
#line 2960
        op_code_data += bytes_read___1;
#line 2962
        tmp___35 = read_leb128(op_code_data, & bytes_read___1, 0);
#line 2962
        (file_table + n_files)->length = (unsigned int )tmp___35;
#line 2965
        n_files ++;
        }
#line 2966
        goto switch_break___0;
        case_22: /* CIL Label */ 
        case_4: /* CIL Label */ 
#line 2971
        goto switch_break___0;
        switch_default: /* CIL Label */ 
        {
#line 2974
        tmp___36 = gettext("UNKNOWN (%u): length %d\n");
#line 2974
        printf((char const   */* __restrict  */)tmp___36, (int )ext_op_code, ext_op_code_len - bytes_read___1);
        }
#line 2976
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 2978
        data += ext_op_code_len;
#line 2979
        goto switch_break;
        case_1___0: /* CIL Label */ 
#line 2982
        goto switch_break;
        case_2___0: /* CIL Label */ 
        {
#line 2985
        tmp___37 = read_leb128(data, & bytes_read___1, 0);
#line 2985
        uladv = (unsigned long )tmp___37;
#line 2986
        data += bytes_read___1;
        }
#line 2987
        if ((int )linfo.li_max_ops_per_insn == 1) {
#line 2989
          uladv *= (unsigned long )linfo.li_min_insn_length;
#line 2990
          state_machine_regs.address += (dwarf_vma )uladv;
        } else {
#line 2994
          state_machine_regs.address += (dwarf_vma )((((unsigned long )state_machine_regs.op_index + uladv) / (unsigned long )linfo.li_max_ops_per_insn) * (unsigned long )linfo.li_min_insn_length);
#line 2998
          state_machine_regs.op_index = (unsigned char )(((unsigned long )state_machine_regs.op_index + uladv) % (unsigned long )linfo.li_max_ops_per_insn);
        }
#line 3002
        goto switch_break;
        case_3___0: /* CIL Label */ 
        {
#line 3005
        tmp___38 = read_sleb128(data, & bytes_read___1);
#line 3005
        adv = (int )tmp___38;
#line 3006
        data += bytes_read___1;
#line 3007
        state_machine_regs.line += (unsigned int )adv;
        }
#line 3008
        goto switch_break;
        case_4___0: /* CIL Label */ 
        {
#line 3011
        tmp___39 = read_leb128(data, & bytes_read___1, 0);
#line 3011
        adv = (int )tmp___39;
#line 3012
        data += bytes_read___1;
#line 3013
        state_machine_regs.file = (unsigned int )adv;
        }
#line 3014
        if ((file_table + (state_machine_regs.file - 1U))->directory_index == 0U) {
          {
#line 3017
          printf((char const   */* __restrict  */)"\n./%s:[++]\n", (file_table + (state_machine_regs.file - 1U))->name);
          }
        } else {
          {
#line 3023
          printf((char const   */* __restrict  */)"\n%s/%s:\n", *(directory_table + ((file_table + (state_machine_regs.file - 1U))->directory_index - 1U)),
                 (file_table + (state_machine_regs.file - 1U))->name);
          }
        }
#line 3027
        goto switch_break;
        case_5: /* CIL Label */ 
        {
#line 3030
        tmp___40 = read_leb128(data, & bytes_read___1, 0);
#line 3030
        uladv = (unsigned long )tmp___40;
#line 3031
        data += bytes_read___1;
#line 3032
        state_machine_regs.column = (unsigned int )uladv;
        }
#line 3033
        goto switch_break;
        case_6: /* CIL Label */ 
#line 3036
        adv = state_machine_regs.is_stmt;
#line 3037
        adv = ! adv;
#line 3038
        state_machine_regs.is_stmt = adv;
#line 3039
        goto switch_break;
        case_7: /* CIL Label */ 
#line 3042
        state_machine_regs.basic_block = 1;
#line 3043
        goto switch_break;
        case_8: /* CIL Label */ 
#line 3046
        uladv = (unsigned long )((255 - (int )linfo.li_opcode_base) / (int )linfo.li_line_range);
#line 3047
        if ((int )linfo.li_max_ops_per_insn == 1) {
#line 3049
          uladv *= (unsigned long )linfo.li_min_insn_length;
#line 3050
          state_machine_regs.address += (dwarf_vma )uladv;
        } else {
#line 3054
          state_machine_regs.address += (dwarf_vma )((((unsigned long )state_machine_regs.op_index + uladv) / (unsigned long )linfo.li_max_ops_per_insn) * (unsigned long )linfo.li_min_insn_length);
#line 3058
          state_machine_regs.op_index = (unsigned char )(((unsigned long )state_machine_regs.op_index + uladv) % (unsigned long )linfo.li_max_ops_per_insn);
        }
#line 3062
        goto switch_break;
        case_9: /* CIL Label */ 
        {
#line 3065
        tmp___41 = (*byte_get)(data, 2);
#line 3065
        uladv = (unsigned long )tmp___41;
#line 3066
        data += 2;
#line 3067
        state_machine_regs.address += (dwarf_vma )uladv;
#line 3068
        state_machine_regs.op_index = (unsigned char)0;
        }
#line 3069
        goto switch_break;
        case_10: /* CIL Label */ 
#line 3072
        goto switch_break;
        case_11: /* CIL Label */ 
#line 3075
        goto switch_break;
        case_12: /* CIL Label */ 
        {
#line 3078
        tmp___42 = read_leb128(data, & bytes_read___1, 0);
#line 3078
        uladv = (unsigned long )tmp___42;
#line 3079
        data += bytes_read___1;
#line 3080
        tmp___43 = gettext("  Set ISA to %lu\n");
#line 3080
        printf((char const   */* __restrict  */)tmp___43, uladv);
        }
#line 3081
        goto switch_break;
        switch_default___0: /* CIL Label */ 
        {
#line 3084
        tmp___44 = gettext("  Unknown opcode %d with operands: ");
#line 3084
        printf((char const   */* __restrict  */)tmp___44, (int )op_code);
#line 3086
        i = (int )*(standard_opcodes + ((int )op_code - 1));
        }
        {
#line 3086
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 3086
          if (! (i > 0)) {
#line 3086
            goto while_break___5;
          }
#line 3088
          if (i == 1) {
#line 3088
            tmp___45 = "";
          } else {
#line 3088
            tmp___45 = ", ";
          }
          {
#line 3088
          tmp___46 = read_leb128(data, & bytes_read___1, 0);
#line 3088
          tmp___47 = dwarf_vmatoa("x", tmp___46);
#line 3088
          printf((char const   */* __restrict  */)"0x%s%s", tmp___47, tmp___45);
#line 3091
          data += bytes_read___1;
#line 3086
          i --;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 3093
        putchar('\n');
        }
#line 3094
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 3099
      if (is_special_opcode) {
#line 3099
        goto _L___0;
      } else
#line 3099
      if ((int )op_code == 1) {
#line 3099
        goto _L___0;
      } else
#line 3099
      if ((int )op_code == 1) {
        _L___0: /* CIL Label */ 
        {
#line 3102
        MAX_FILENAME_LENGTH = 35U;
#line 3103
        fileName = (char *)(file_table + (state_machine_regs.file - 1U))->name;
#line 3104
        newFileName = (char *)((void *)0);
#line 3105
        tmp___48 = strlen((char const   *)fileName);
#line 3105
        fileNameLength = tmp___48;
        }
#line 3107
        if (fileNameLength > (size_t )MAX_FILENAME_LENGTH) {
#line 3107
          if (! do_wide) {
            {
#line 3109
            tmp___49 = xmalloc((size_t )(MAX_FILENAME_LENGTH + 1U));
#line 3109
            newFileName = (char *)tmp___49;
#line 3111
            strncpy((char */* __restrict  */)newFileName, (char const   */* __restrict  */)((fileName + fileNameLength) - MAX_FILENAME_LENGTH),
                    (size_t )(MAX_FILENAME_LENGTH + 1U));
            }
          } else {
            {
#line 3117
            tmp___50 = xmalloc(fileNameLength + 1UL);
#line 3117
            newFileName = (char *)tmp___50;
#line 3118
            strncpy((char */* __restrict  */)newFileName, (char const   */* __restrict  */)fileName,
                    fileNameLength + 1UL);
            }
          }
        } else {
          {
#line 3117
          tmp___50 = xmalloc(fileNameLength + 1UL);
#line 3117
          newFileName = (char *)tmp___50;
#line 3118
          strncpy((char */* __restrict  */)newFileName, (char const   */* __restrict  */)fileName,
                  fileNameLength + 1UL);
          }
        }
#line 3121
        if (! do_wide) {
#line 3121
          goto _L;
        } else
#line 3121
        if (fileNameLength <= (size_t )MAX_FILENAME_LENGTH) {
          _L: /* CIL Label */ 
#line 3123
          if ((int )linfo.li_max_ops_per_insn == 1) {
            {
#line 3124
            printf((char const   */* __restrict  */)"%-35s  %11d  %#18llx\n", newFileName,
                   state_machine_regs.line, state_machine_regs.address);
            }
          } else {
            {
#line 3128
            printf((char const   */* __restrict  */)"%-35s  %11d  %#18llx[%d]\n",
                   newFileName, state_machine_regs.line, state_machine_regs.address,
                   (int )state_machine_regs.op_index);
            }
          }
        } else
#line 3135
        if ((int )linfo.li_max_ops_per_insn == 1) {
          {
#line 3136
          printf((char const   */* __restrict  */)"%s  %11d  %#18llx\n", newFileName,
                 state_machine_regs.line, state_machine_regs.address);
          }
        } else {
          {
#line 3140
          printf((char const   */* __restrict  */)"%s  %11d  %#18llx[%d]\n", newFileName,
                 state_machine_regs.line, state_machine_regs.address, (int )state_machine_regs.op_index);
          }
        }
#line 3146
        if ((int )op_code == 1) {
          {
#line 3147
          printf((char const   */* __restrict  */)"\n");
          }
        }
        {
#line 3149
        free((void *)newFileName);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 3152
    free((void *)file_table);
#line 3153
    file_table = (File_Entry *)((void *)0);
#line 3154
    free((void *)directory_table);
#line 3155
    directory_table = (unsigned char **)((void *)0);
#line 3156
    putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3159
  return (1);
}
}
#line 3162 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_lines(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *data ;
  unsigned char *end ;
  int retValRaw ;
  int retValDecoded ;

  {
#line 3165
  data = section->start;
#line 3166
  end = data + section->size;
#line 3167
  retValRaw = 1;
#line 3168
  retValDecoded = 1;
#line 3170
  if (do_debug_lines == 0) {
#line 3171
    do_debug_lines |= 1;
  }
#line 3173
  if (do_debug_lines & 1) {
    {
#line 3174
    retValRaw = display_debug_lines_raw(section, data, end);
    }
  }
#line 3176
  if (do_debug_lines & 2) {
    {
#line 3177
    retValDecoded = display_debug_lines_decoded(section, data, end);
    }
  }
#line 3179
  if (! retValRaw) {
#line 3180
    return (0);
  } else
#line 3179
  if (! retValDecoded) {
#line 3180
    return (0);
  }
#line 3182
  return (1);
}
}
#line 3185 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static debug_info *find_debug_info_for_offset(unsigned long offset ) 
{ 
  unsigned int i ;

  {
#line 3190
  if (num_debug_info_entries == 4294967295U) {
#line 3191
    return ((debug_info *)((void *)0));
  }
#line 3193
  i = 0U;
  {
#line 3193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3193
    if (! (i < num_debug_info_entries)) {
#line 3193
      goto while_break;
    }
#line 3194
    if ((debug_information + i)->cu_offset == (dwarf_vma )offset) {
#line 3195
      return (debug_information + i);
    }
#line 3193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3197
  return ((debug_info *)((void *)0));
}
}
#line 3256
static int display_debug_pubnames(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) ;
#line 3256 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int warned  =    0;
#line 3200 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_pubnames(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  DWARF2_Internal_PubNames names ;
  unsigned char *start ;
  unsigned char *end ;
  char *tmp___0 ;
  unsigned char *data ;
  unsigned long offset ;
  int offset_size ;
  int initial_length_size ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  debug_info *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  elf_vma tmp___10 ;
  size_t tmp___11 ;

  {
  {
#line 3205
  start = section->start;
#line 3206
  end = start + section->size;
#line 3210
  load_debug_info(file);
#line 3212
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3212
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3214
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 3214
      goto while_break;
    }
    {
#line 3220
    data = start;
#line 3222
    names.pn_length = (*byte_get)(data, 4);
#line 3223
    data += 4;
    }
#line 3224
    if (names.pn_length == 4294967295ULL) {
      {
#line 3226
      names.pn_length = (*byte_get)(data, 8);
#line 3227
      data += 8;
#line 3228
      offset_size = 8;
#line 3229
      initial_length_size = 12;
      }
    } else {
#line 3233
      offset_size = 4;
#line 3234
      initial_length_size = 4;
    }
    {
#line 3237
    tmp___1 = (*byte_get)(data, 2);
#line 3237
    names.pn_version = (unsigned short )tmp___1;
#line 3238
    data += 2;
#line 3240
    names.pn_offset = (*byte_get)(data, offset_size);
#line 3241
    data += offset_size;
    }
#line 3243
    if (num_debug_info_entries != 4294967295U) {
#line 3243
      if (num_debug_info_entries > 0U) {
        {
#line 3243
        tmp___3 = find_debug_info_for_offset((unsigned long )names.pn_offset);
        }
#line 3243
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
          {
#line 3246
          tmp___2 = gettext(".debug_info offset of 0x%lx in %s section does not point to a CU header.\n");
#line 3246
          warn((char const   *)tmp___2, (unsigned long )names.pn_offset, section->name);
          }
        }
      }
    }
    {
#line 3249
    names.pn_size = (*byte_get)(data, offset_size);
#line 3250
    data += offset_size;
#line 3252
    start += names.pn_length + (dwarf_vma )initial_length_size;
    }
#line 3254
    if ((int )names.pn_version != 2) {
#line 3254
      if ((int )names.pn_version != 3) {
#line 3258
        if (! warned) {
          {
#line 3260
          tmp___4 = gettext("Only DWARF 2 and 3 pubnames are currently supported\n");
#line 3260
          warn((char const   *)tmp___4);
#line 3261
          warned = 1;
          }
        }
#line 3264
        goto while_continue;
      }
    }
    {
#line 3267
    tmp___5 = gettext("  Length:                              %ld\n");
#line 3267
    printf((char const   */* __restrict  */)tmp___5, (long )names.pn_length);
#line 3269
    tmp___6 = gettext("  Version:                             %d\n");
#line 3269
    printf((char const   */* __restrict  */)tmp___6, (int )names.pn_version);
#line 3271
    tmp___7 = gettext("  Offset into .debug_info section:     0x%lx\n");
#line 3271
    printf((char const   */* __restrict  */)tmp___7, (unsigned long )names.pn_offset);
#line 3273
    tmp___8 = gettext("  Size of area in .debug_info section: %ld\n");
#line 3273
    printf((char const   */* __restrict  */)tmp___8, (long )names.pn_size);
#line 3276
    tmp___9 = gettext("\n    Offset\tName\n");
#line 3276
    printf((char const   */* __restrict  */)tmp___9);
    }
    {
#line 3278
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 3280
      tmp___10 = (*byte_get)(data, offset_size);
#line 3280
      offset = (unsigned long )tmp___10;
      }
#line 3282
      if (offset != 0UL) {
        {
#line 3284
        data += offset_size;
#line 3285
        printf((char const   */* __restrict  */)"    %-6lx\t%s\n", offset, data);
#line 3286
        tmp___11 = strlen((char const   *)((char *)data));
#line 3286
        data += tmp___11 + 1UL;
        }
      }
#line 3278
      if (! (offset != 0UL)) {
#line 3278
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3292
  printf((char const   */* __restrict  */)"\n");
  }
#line 3293
  return (1);
}
}
#line 3296 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_macinfo(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *curr ;
  unsigned int bytes_read ;
  enum dwarf_macinfo_record_type op ;
  char *tmp___0 ;
  unsigned int lineno ;
  char const   *string ;
  unsigned int filenum ;
  dwarf_vma tmp___1 ;
  dwarf_vma tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  dwarf_vma tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  dwarf_vma tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  unsigned int constant ;
  dwarf_vma tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 3300
  start = section->start;
#line 3301
  end = start + section->size;
#line 3302
  curr = start;
#line 3306
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3306
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3308
    if (! ((unsigned long )curr < (unsigned long )end)) {
#line 3308
      goto while_break;
    }
#line 3313
    op = (enum dwarf_macinfo_record_type )*curr;
#line 3314
    curr ++;
    {
#line 3318
    if ((unsigned int )op == 3U) {
#line 3318
      goto case_3;
    }
#line 3332
    if ((unsigned int )op == 4U) {
#line 3332
      goto case_4;
    }
#line 3336
    if ((unsigned int )op == 1U) {
#line 3336
      goto case_1;
    }
#line 3345
    if ((unsigned int )op == 2U) {
#line 3345
      goto case_2;
    }
#line 3354
    if ((unsigned int )op == 255U) {
#line 3354
      goto case_255;
    }
#line 3316
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 3322
    tmp___1 = read_leb128(curr, & bytes_read, 0);
#line 3322
    lineno = (unsigned int )tmp___1;
#line 3323
    curr += bytes_read;
#line 3324
    tmp___2 = read_leb128(curr, & bytes_read, 0);
#line 3324
    filenum = (unsigned int )tmp___2;
#line 3325
    curr += bytes_read;
#line 3327
    tmp___3 = gettext(" DW_MACINFO_start_file - lineno: %d filenum: %d\n");
#line 3327
    printf((char const   */* __restrict  */)tmp___3, lineno, filenum);
    }
#line 3330
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 3333
    tmp___4 = gettext(" DW_MACINFO_end_file\n");
#line 3333
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 3334
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 3337
    tmp___5 = read_leb128(curr, & bytes_read, 0);
#line 3337
    lineno = (unsigned int )tmp___5;
#line 3338
    curr += bytes_read;
#line 3339
    string = (char const   *)((char *)curr);
#line 3340
    tmp___6 = strlen(string);
#line 3340
    curr += tmp___6 + 1UL;
#line 3341
    tmp___7 = gettext(" DW_MACINFO_define - lineno : %d macro : %s\n");
#line 3341
    printf((char const   */* __restrict  */)tmp___7, lineno, string);
    }
#line 3343
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 3346
    tmp___8 = read_leb128(curr, & bytes_read, 0);
#line 3346
    lineno = (unsigned int )tmp___8;
#line 3347
    curr += bytes_read;
#line 3348
    string = (char const   *)((char *)curr);
#line 3349
    tmp___9 = strlen(string);
#line 3349
    curr += tmp___9 + 1UL;
#line 3350
    tmp___10 = gettext(" DW_MACINFO_undef - lineno : %d macro : %s\n");
#line 3350
    printf((char const   */* __restrict  */)tmp___10, lineno, string);
    }
#line 3352
    goto switch_break;
    case_255: /* CIL Label */ 
    {
#line 3358
    tmp___11 = read_leb128(curr, & bytes_read, 0);
#line 3358
    constant = (unsigned int )tmp___11;
#line 3359
    curr += bytes_read;
#line 3360
    string = (char const   *)((char *)curr);
#line 3361
    tmp___12 = strlen(string);
#line 3361
    curr += tmp___12 + 1UL;
#line 3362
    tmp___13 = gettext(" DW_MACINFO_vendor_ext - constant : %d string : %s\n");
#line 3362
    printf((char const   */* __restrict  */)tmp___13, constant, string);
    }
#line 3365
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3369
  return (1);
}
}
#line 3376 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned char *get_line_filename_and_dirname(dwarf_vma line_offset , dwarf_vma fileidx ,
                                                    unsigned char **dir_name ) 
{ 
  struct dwarf_section *section ;
  unsigned char *hdrptr ;
  unsigned char *dirtable ;
  unsigned char *file_name ;
  unsigned int offset_size ;
  unsigned int initial_length_size ;
  unsigned int version ;
  unsigned int opcode_base ;
  unsigned int bytes_read ;
  dwarf_vma length ;
  dwarf_vma diridx ;
  elf_vma tmp___0 ;
  elf_vma tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 3380
  section = & debug_displays[4].section;
#line 3386
  *dir_name = (unsigned char *)((void *)0);
#line 3387
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 3390
    return ((unsigned char *)((void *)0));
  } else
#line 3387
  if (line_offset >= section->size) {
#line 3390
    return ((unsigned char *)((void *)0));
  } else
#line 3387
  if (fileidx == 0ULL) {
#line 3390
    return ((unsigned char *)((void *)0));
  }
  {
#line 3392
  hdrptr = section->start + line_offset;
#line 3393
  length = (*byte_get)(hdrptr, 4);
#line 3394
  hdrptr += 4;
  }
#line 3395
  if (length == 4294967295ULL) {
    {
#line 3398
    length = (*byte_get)(hdrptr, 8);
#line 3399
    hdrptr += 8;
#line 3400
    offset_size = 8U;
#line 3401
    initial_length_size = 12U;
    }
  } else {
#line 3405
    offset_size = 4U;
#line 3406
    initial_length_size = 4U;
  }
#line 3408
  if (length + (dwarf_vma )initial_length_size > section->size) {
#line 3409
    return ((unsigned char *)((void *)0));
  }
  {
#line 3410
  tmp___0 = (*byte_get)(hdrptr, 2);
#line 3410
  version = (unsigned int )tmp___0;
#line 3411
  hdrptr += 2;
  }
#line 3412
  if (version != 2U) {
#line 3412
    if (version != 3U) {
#line 3412
      if (version != 4U) {
#line 3413
        return ((unsigned char *)((void *)0));
      }
    }
  }
#line 3414
  hdrptr += offset_size + 1U;
#line 3415
  if (version >= 4U) {
#line 3416
    hdrptr ++;
  }
  {
#line 3417
  hdrptr += 3;
#line 3418
  tmp___1 = (*byte_get)(hdrptr, 1);
#line 3418
  opcode_base = (unsigned int )tmp___1;
  }
#line 3419
  if (opcode_base == 0U) {
#line 3420
    return ((unsigned char *)((void *)0));
  }
#line 3421
  hdrptr ++;
#line 3422
  hdrptr += opcode_base - 1U;
#line 3423
  dirtable = hdrptr;
  {
#line 3425
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3425
    if (! ((int )*hdrptr != 0)) {
#line 3425
      goto while_break;
    }
    {
#line 3426
    tmp___2 = strlen((char const   *)((char *)hdrptr));
#line 3426
    hdrptr += tmp___2 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3427
  hdrptr ++;
  {
#line 3429
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3429
    if ((int )*hdrptr != 0) {
#line 3429
      if (! (fileidx > 1ULL)) {
#line 3429
        goto while_break___0;
      }
    } else {
#line 3429
      goto while_break___0;
    }
    {
#line 3431
    tmp___3 = strlen((char const   *)((char *)hdrptr));
#line 3431
    hdrptr += tmp___3 + 1UL;
#line 3432
    read_leb128(hdrptr, & bytes_read, 0);
#line 3433
    hdrptr += bytes_read;
#line 3434
    read_leb128(hdrptr, & bytes_read, 0);
#line 3435
    hdrptr += bytes_read;
#line 3436
    read_leb128(hdrptr, & bytes_read, 0);
#line 3437
    hdrptr += bytes_read;
#line 3429
    fileidx --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3439
  if ((int )*hdrptr == 0) {
#line 3440
    return ((unsigned char *)((void *)0));
  }
  {
#line 3441
  file_name = hdrptr;
#line 3442
  tmp___4 = strlen((char const   *)((char *)hdrptr));
#line 3442
  hdrptr += tmp___4 + 1UL;
#line 3443
  diridx = read_leb128(hdrptr, & bytes_read, 0);
  }
#line 3444
  if (diridx == 0ULL) {
#line 3445
    return (file_name);
  }
  {
#line 3446
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 3446
    if ((int )*dirtable != 0) {
#line 3446
      if (! (diridx > 1ULL)) {
#line 3446
        goto while_break___1;
      }
    } else {
#line 3446
      goto while_break___1;
    }
    {
#line 3447
    tmp___5 = strlen((char const   *)((char *)dirtable));
#line 3447
    dirtable += tmp___5 + 1UL;
#line 3446
    diridx --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 3448
  if ((int )*dirtable == 0) {
#line 3449
    return ((unsigned char *)((void *)0));
  }
#line 3450
  *dir_name = dirtable;
#line 3451
  return (file_name);
}
}
#line 3454 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_macro(struct dwarf_section *section , void *file ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *curr ;
  unsigned char *extended_op_buf[256] ;
  unsigned int bytes_read ;
  char *tmp___0 ;
  unsigned int lineno ;
  unsigned int version ;
  unsigned int flags___1 ;
  unsigned int offset_size ;
  char const   *string ;
  dwarf_vma line_offset ;
  dwarf_vma sec_offset ;
  dwarf_vma offset ;
  unsigned char **extended_ops ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  unsigned char *tmp___3 ;
  elf_vma tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned int i ;
  unsigned int count ;
  unsigned char *tmp___9 ;
  elf_vma tmp___10 ;
  unsigned int op ;
  dwarf_vma nargs ;
  dwarf_vma n ;
  char *tmp___11 ;
  unsigned char *tmp___12 ;
  elf_vma tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  unsigned int form ;
  unsigned char *tmp___16 ;
  elf_vma tmp___17 ;
  char const   *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  unsigned int op___0 ;
  char *tmp___22 ;
  unsigned char *tmp___23 ;
  elf_vma tmp___24 ;
  unsigned int filenum ;
  unsigned char *file_name ;
  unsigned char *dir_name ;
  dwarf_vma tmp___25 ;
  dwarf_vma tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  dwarf_vma tmp___33 ;
  size_t tmp___34 ;
  char *tmp___35 ;
  dwarf_vma tmp___36 ;
  size_t tmp___37 ;
  char *tmp___38 ;
  dwarf_vma tmp___39 ;
  char *tmp___40 ;
  dwarf_vma tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  dwarf_vma tmp___44 ;
  char *tmp___45 ;
  dwarf_vma tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  dwarf_vma nargs___0 ;
  dwarf_vma n___0 ;
  unsigned char *desc ;
  char *tmp___50 ;
  char *tmp___51 ;
  unsigned char *tmp___52 ;
  elf_vma tmp___53 ;

  {
  {
#line 3458
  start = section->start;
#line 3459
  end = start + section->size;
#line 3460
  curr = start;
#line 3464
  load_debug_section((enum dwarf_section_display_enum )9, file);
#line 3465
  load_debug_section((enum dwarf_section_display_enum )4, file);
#line 3467
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3467
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3469
    if (! ((unsigned long )curr < (unsigned long )end)) {
#line 3469
      goto while_break;
    }
    {
#line 3472
    offset_size = 4U;
#line 3474
    line_offset = (dwarf_vma )0;
#line 3474
    sec_offset = (dwarf_vma )(curr - start);
#line 3475
    extended_ops = (unsigned char **)((void *)0);
#line 3477
    tmp___1 = (*byte_get)(curr, 2);
#line 3477
    version = (unsigned int )tmp___1;
#line 3478
    curr += 2;
    }
#line 3480
    if (version != 4U) {
      {
#line 3482
      tmp___2 = gettext("Only GNU extension to DWARF 4 of %s is currently supported.\n");
#line 3482
      error((char const   *)tmp___2, section->name);
      }
#line 3484
      return (0);
    }
    {
#line 3487
    tmp___3 = curr;
#line 3487
    curr ++;
#line 3487
    tmp___4 = (*byte_get)(tmp___3, 1);
#line 3487
    flags___1 = (unsigned int )tmp___4;
    }
#line 3488
    if (flags___1 & 1U) {
#line 3489
      offset_size = 8U;
    }
    {
#line 3490
    tmp___5 = gettext("  Offset:                      0x%lx\n");
#line 3490
    printf((char const   */* __restrict  */)tmp___5, (unsigned long )sec_offset);
#line 3492
    tmp___6 = gettext("  Version:                     %d\n");
#line 3492
    printf((char const   */* __restrict  */)tmp___6, version);
#line 3493
    tmp___7 = gettext("  Offset size:                 %d\n");
#line 3493
    printf((char const   */* __restrict  */)tmp___7, offset_size);
    }
#line 3494
    if (flags___1 & 2U) {
      {
#line 3496
      line_offset = (*byte_get)(curr, (int )offset_size);
#line 3497
      curr += offset_size;
#line 3498
      tmp___8 = gettext("  Offset into .debug_line:     0x%lx\n");
#line 3498
      printf((char const   */* __restrict  */)tmp___8, (unsigned long )line_offset);
      }
    }
#line 3501
    if (flags___1 & 4U) {
      {
#line 3503
      tmp___9 = curr;
#line 3503
      curr ++;
#line 3503
      tmp___10 = (*byte_get)(tmp___9, 1);
#line 3503
      count = (unsigned int )tmp___10;
#line 3505
      memset((void *)(extended_op_buf), 0, sizeof(extended_op_buf));
#line 3506
      extended_ops = extended_op_buf;
      }
#line 3507
      if (count) {
        {
#line 3509
        tmp___11 = gettext("  Extension opcode arguments:\n");
#line 3509
        printf((char const   */* __restrict  */)tmp___11);
#line 3510
        i = 0U;
        }
        {
#line 3510
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3510
          if (! (i < count)) {
#line 3510
            goto while_break___0;
          }
          {
#line 3512
          tmp___12 = curr;
#line 3512
          curr ++;
#line 3512
          tmp___13 = (*byte_get)(tmp___12, 1);
#line 3512
          op = (unsigned int )tmp___13;
#line 3513
          *(extended_ops + op) = curr;
#line 3514
          nargs = read_leb128(curr, & bytes_read, 0);
#line 3515
          curr += bytes_read;
          }
#line 3516
          if (nargs == 0ULL) {
            {
#line 3517
            tmp___14 = gettext("    DW_MACRO_GNU_%02x has no arguments\n");
#line 3517
            printf((char const   */* __restrict  */)tmp___14, op);
            }
          } else {
            {
#line 3520
            tmp___15 = gettext("    DW_MACRO_GNU_%02x arguments: ");
#line 3520
            printf((char const   */* __restrict  */)tmp___15, op);
#line 3521
            n = (dwarf_vma )0;
            }
            {
#line 3521
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 3521
              if (! (n < nargs)) {
#line 3521
                goto while_break___1;
              }
              {
#line 3523
              tmp___16 = curr;
#line 3523
              curr ++;
#line 3523
              tmp___17 = (*byte_get)(tmp___16, 1);
#line 3523
              form = (unsigned int )tmp___17;
              }
#line 3524
              if (n == nargs - 1ULL) {
#line 3524
                tmp___18 = "\n";
              } else {
#line 3524
                tmp___18 = ", ";
              }
              {
#line 3524
              tmp___19 = get_FORM_name((unsigned long )form);
#line 3524
              printf((char const   */* __restrict  */)"%s%s", tmp___19, tmp___18);
              }
              {
#line 3541
              if (form == 23U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 14U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 8U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 12U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 4U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 3U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 10U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 9U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 15U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 13U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 7U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 6U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 5U) {
#line 3541
                goto case_23;
              }
#line 3541
              if (form == 11U) {
#line 3541
                goto case_23;
              }
#line 3543
              goto switch_default;
              case_23: /* CIL Label */ 
              case_14: /* CIL Label */ 
              case_8: /* CIL Label */ 
              case_12: /* CIL Label */ 
              case_4: /* CIL Label */ 
              case_3: /* CIL Label */ 
              case_10: /* CIL Label */ 
              case_9: /* CIL Label */ 
              case_15: /* CIL Label */ 
              case_13: /* CIL Label */ 
              case_7: /* CIL Label */ 
              case_6: /* CIL Label */ 
              case_5: /* CIL Label */ 
              case_11: /* CIL Label */ 
#line 3542
              goto switch_break;
              switch_default: /* CIL Label */ 
              {
#line 3544
              tmp___20 = get_FORM_name((unsigned long )form);
#line 3544
              tmp___21 = gettext("Invalid extension opcode form %s\n");
#line 3544
              error((char const   *)tmp___21, tmp___20);
              }
#line 3546
              return (0);
              switch_break: /* CIL Label */ ;
              }
#line 3521
              n ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 3510
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 3553
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 3555
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3559
      if ((unsigned long )curr >= (unsigned long )end) {
        {
#line 3561
        tmp___22 = gettext(".debug_macro section not zero terminated\n");
#line 3561
        error((char const   *)tmp___22);
        }
#line 3562
        return (0);
      }
      {
#line 3565
      tmp___23 = curr;
#line 3565
      curr ++;
#line 3565
      tmp___24 = (*byte_get)(tmp___23, 1);
#line 3565
      op___0 = (unsigned int )tmp___24;
      }
#line 3566
      if (op___0 == 0U) {
#line 3567
        goto while_break___2;
      }
      {
#line 3571
      if (op___0 == 3U) {
#line 3571
        goto case_3___0;
      }
#line 3598
      if (op___0 == 4U) {
#line 3598
        goto case_4___0;
      }
#line 3602
      if (op___0 == 1U) {
#line 3602
        goto case_1;
      }
#line 3611
      if (op___0 == 2U) {
#line 3611
        goto case_2;
      }
#line 3620
      if (op___0 == 5U) {
#line 3620
        goto case_5___0;
      }
#line 3630
      if (op___0 == 6U) {
#line 3630
        goto case_6___0;
      }
#line 3640
      if (op___0 == 7U) {
#line 3640
        goto case_7___0;
      }
#line 3647
      if (op___0 == 8U) {
#line 3647
        goto case_8___0;
      }
#line 3656
      if (op___0 == 9U) {
#line 3656
        goto case_9___0;
      }
#line 3665
      if (op___0 == 10U) {
#line 3665
        goto case_10___0;
      }
#line 3672
      goto switch_default___0;
      case_3___0: /* CIL Label */ 
      {
#line 3574
      file_name = (unsigned char *)((void *)0);
#line 3574
      dir_name = (unsigned char *)((void *)0);
#line 3576
      tmp___25 = read_leb128(curr, & bytes_read, 0);
#line 3576
      lineno = (unsigned int )tmp___25;
#line 3577
      curr += bytes_read;
#line 3578
      tmp___26 = read_leb128(curr, & bytes_read, 0);
#line 3578
      filenum = (unsigned int )tmp___26;
#line 3579
      curr += bytes_read;
      }
#line 3581
      if ((flags___1 & 2U) == 0U) {
        {
#line 3582
        tmp___27 = gettext("DW_MACRO_GNU_start_file used, but no .debug_line offset provided.\n");
#line 3582
        error((char const   *)tmp___27);
        }
      } else {
        {
#line 3584
        file_name = get_line_filename_and_dirname(line_offset, (dwarf_vma )filenum,
                                                  & dir_name);
        }
      }
#line 3587
      if ((unsigned long )file_name == (unsigned long )((void *)0)) {
        {
#line 3588
        tmp___28 = gettext(" DW_MACRO_GNU_start_file - lineno: %d filenum: %d\n");
#line 3588
        printf((char const   */* __restrict  */)tmp___28, lineno, filenum);
        }
      } else {
#line 3591
        if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
#line 3591
          tmp___29 = "/";
        } else {
#line 3591
          tmp___29 = "";
        }
#line 3591
        if ((unsigned long )dir_name != (unsigned long )((void *)0)) {
#line 3591
          tmp___30 = (char const   *)dir_name;
        } else {
#line 3591
          tmp___30 = "";
        }
        {
#line 3591
        tmp___31 = gettext(" DW_MACRO_GNU_start_file - lineno: %d filenum: %d filename: %s%s%s\n");
#line 3591
        printf((char const   */* __restrict  */)tmp___31, lineno, filenum, tmp___30,
               tmp___29, file_name);
        }
      }
#line 3596
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 3599
      tmp___32 = gettext(" DW_MACRO_GNU_end_file\n");
#line 3599
      printf((char const   */* __restrict  */)tmp___32);
      }
#line 3600
      goto switch_break___0;
      case_1: /* CIL Label */ 
      {
#line 3603
      tmp___33 = read_leb128(curr, & bytes_read, 0);
#line 3603
      lineno = (unsigned int )tmp___33;
#line 3604
      curr += bytes_read;
#line 3605
      string = (char const   *)((char *)curr);
#line 3606
      tmp___34 = strlen(string);
#line 3606
      curr += tmp___34 + 1UL;
#line 3607
      tmp___35 = gettext(" DW_MACRO_GNU_define - lineno : %d macro : %s\n");
#line 3607
      printf((char const   */* __restrict  */)tmp___35, lineno, string);
      }
#line 3609
      goto switch_break___0;
      case_2: /* CIL Label */ 
      {
#line 3612
      tmp___36 = read_leb128(curr, & bytes_read, 0);
#line 3612
      lineno = (unsigned int )tmp___36;
#line 3613
      curr += bytes_read;
#line 3614
      string = (char const   *)((char *)curr);
#line 3615
      tmp___37 = strlen(string);
#line 3615
      curr += tmp___37 + 1UL;
#line 3616
      tmp___38 = gettext(" DW_MACRO_GNU_undef - lineno : %d macro : %s\n");
#line 3616
      printf((char const   */* __restrict  */)tmp___38, lineno, string);
      }
#line 3618
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      {
#line 3621
      tmp___39 = read_leb128(curr, & bytes_read, 0);
#line 3621
      lineno = (unsigned int )tmp___39;
#line 3622
      curr += bytes_read;
#line 3623
      offset = (*byte_get)(curr, (int )offset_size);
#line 3624
      curr += offset_size;
#line 3625
      string = fetch_indirect_string(offset);
#line 3626
      tmp___40 = gettext(" DW_MACRO_GNU_define_indirect - lineno : %d macro : %s\n");
#line 3626
      printf((char const   */* __restrict  */)tmp___40, lineno, string);
      }
#line 3628
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
      {
#line 3631
      tmp___41 = read_leb128(curr, & bytes_read, 0);
#line 3631
      lineno = (unsigned int )tmp___41;
#line 3632
      curr += bytes_read;
#line 3633
      offset = (*byte_get)(curr, (int )offset_size);
#line 3634
      curr += offset_size;
#line 3635
      string = fetch_indirect_string(offset);
#line 3636
      tmp___42 = gettext(" DW_MACRO_GNU_undef_indirect - lineno : %d macro : %s\n");
#line 3636
      printf((char const   */* __restrict  */)tmp___42, lineno, string);
      }
#line 3638
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 3641
      offset = (*byte_get)(curr, (int )offset_size);
#line 3642
      curr += offset_size;
#line 3643
      tmp___43 = gettext(" DW_MACRO_GNU_transparent_include - offset : 0x%lx\n");
#line 3643
      printf((char const   */* __restrict  */)tmp___43, (unsigned long )offset);
      }
#line 3645
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 3648
      tmp___44 = read_leb128(curr, & bytes_read, 0);
#line 3648
      lineno = (unsigned int )tmp___44;
#line 3649
      curr += bytes_read;
#line 3650
      offset = (*byte_get)(curr, (int )offset_size);
#line 3651
      curr += offset_size;
#line 3652
      tmp___45 = gettext(" DW_MACRO_GNU_define_indirect_alt - lineno : %d macro offset : 0x%lx\n");
#line 3652
      printf((char const   */* __restrict  */)tmp___45, lineno, (unsigned long )offset);
      }
#line 3654
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
      {
#line 3657
      tmp___46 = read_leb128(curr, & bytes_read, 0);
#line 3657
      lineno = (unsigned int )tmp___46;
#line 3658
      curr += bytes_read;
#line 3659
      offset = (*byte_get)(curr, (int )offset_size);
#line 3660
      curr += offset_size;
#line 3661
      tmp___47 = gettext(" DW_MACRO_GNU_undef_indirect_alt - lineno : %d macro offset : 0x%lx\n");
#line 3661
      printf((char const   */* __restrict  */)tmp___47, lineno, (unsigned long )offset);
      }
#line 3663
      goto switch_break___0;
      case_10___0: /* CIL Label */ 
      {
#line 3666
      offset = (*byte_get)(curr, (int )offset_size);
#line 3667
      curr += offset_size;
#line 3668
      tmp___48 = gettext(" DW_MACRO_GNU_transparent_include_alt - offset : 0x%lx\n");
#line 3668
      printf((char const   */* __restrict  */)tmp___48, (unsigned long )offset);
      }
#line 3670
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 3673
      if ((unsigned long )extended_ops == (unsigned long )((void *)0)) {
        {
#line 3675
        tmp___49 = gettext(" Unknown macro opcode %02x seen\n");
#line 3675
        error((char const   *)tmp___49, op___0);
        }
#line 3676
        return (0);
      } else
#line 3673
      if ((unsigned long )*(extended_ops + op___0) == (unsigned long )((void *)0)) {
        {
#line 3675
        tmp___49 = gettext(" Unknown macro opcode %02x seen\n");
#line 3675
        error((char const   *)tmp___49, op___0);
        }
#line 3676
        return (0);
      } else {
        {
#line 3682
        desc = *(extended_ops + op___0);
#line 3683
        nargs___0 = read_leb128(desc, & bytes_read, 0);
#line 3684
        desc += bytes_read;
        }
#line 3685
        if (nargs___0 == 0ULL) {
          {
#line 3687
          tmp___50 = gettext(" DW_MACRO_GNU_%02x\n");
#line 3687
          printf((char const   */* __restrict  */)tmp___50, op___0);
          }
#line 3688
          goto switch_break___0;
        }
        {
#line 3690
        tmp___51 = gettext(" DW_MACRO_GNU_%02x -");
#line 3690
        printf((char const   */* __restrict  */)tmp___51, op___0);
#line 3691
        n___0 = (dwarf_vma )0;
        }
        {
#line 3691
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 3691
          if (! (n___0 < nargs___0)) {
#line 3691
            goto while_break___3;
          }
          {
#line 3693
          tmp___52 = desc;
#line 3693
          desc ++;
#line 3693
          tmp___53 = (*byte_get)(tmp___52, 1);
#line 3693
          curr = read_and_display_attr_value(0UL, (unsigned long )tmp___53, curr,
                                             (dwarf_vma )0, (dwarf_vma )0, (dwarf_vma )offset_size,
                                             (int )version, (debug_info *)((void *)0),
                                             0, (struct dwarf_section *)((void *)0));
          }
#line 3697
          if (n___0 != nargs___0 - 1ULL) {
            {
#line 3698
            printf((char const   */* __restrict  */)",");
            }
          }
#line 3691
          n___0 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 3700
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 3702
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3706
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3709
  return (1);
}
}
#line 3712 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_abbrev(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  abbrev_entry *entry ;
  unsigned char *start ;
  unsigned char *end ;
  char *tmp___0 ;
  unsigned char *last ;
  char *tmp___1 ;
  abbrev_attr *attr ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;

  {
  {
#line 3717
  start = section->start;
#line 3718
  end = start + section->size;
#line 3720
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 3720
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
  {
#line 3722
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3726
    free_abbrevs();
#line 3728
    last = start;
#line 3729
    start = process_abbrev_section(start, end);
    }
#line 3731
    if ((unsigned long )first_abbrev == (unsigned long )((void *)0)) {
#line 3732
      goto __Cont;
    }
    {
#line 3734
    tmp___1 = gettext("  Number TAG (0x%lx)\n");
#line 3734
    printf((char const   */* __restrict  */)tmp___1, last - section->start);
#line 3736
    entry = first_abbrev;
    }
    {
#line 3736
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3736
      if (! entry) {
#line 3736
        goto while_break___0;
      }
#line 3740
      if (entry->children) {
        {
#line 3740
        tmp___2 = gettext("has children");
#line 3740
        tmp___4 = tmp___2;
        }
      } else {
        {
#line 3740
        tmp___3 = gettext("no children");
#line 3740
        tmp___4 = tmp___3;
        }
      }
      {
#line 3740
      tmp___5 = get_TAG_name(entry->tag);
#line 3740
      printf((char const   */* __restrict  */)"   %ld      %s    [%s]\n", entry->entry,
             tmp___5, tmp___4);
#line 3745
      attr = entry->first_attr;
      }
      {
#line 3745
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3745
        if (! attr) {
#line 3745
          goto while_break___1;
        }
        {
#line 3746
        tmp___6 = get_FORM_name(attr->form);
#line 3746
        tmp___7 = get_AT_name(attr->attribute);
#line 3746
        printf((char const   */* __restrict  */)"    %-18s %s\n", tmp___7, tmp___6);
#line 3745
        attr = attr->next;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3736
      entry = entry->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3722
    if (! start) {
#line 3722
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3753
  printf((char const   */* __restrict  */)"\n");
  }
#line 3755
  return (1);
}
}
#line 3760 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void display_loc_list(struct dwarf_section *section , unsigned char **start_ptr ,
                             int debug_info_entry , unsigned long offset , unsigned long base_address ,
                             int has_frame_base ) 
{ 
  unsigned char *start ;
  unsigned char *section_end ;
  unsigned long cu_offset ;
  unsigned int pointer_size ;
  unsigned int offset_size ;
  int dwarf_version ;
  dwarf_vma begin ;
  dwarf_vma end ;
  unsigned short length ;
  int need_frame_base ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 3768
  start = *start_ptr;
#line 3769
  section_end = section->start + section->size;
#line 3770
  cu_offset = (unsigned long )(debug_information + debug_info_entry)->cu_offset;
#line 3771
  pointer_size = (debug_information + debug_info_entry)->pointer_size;
#line 3772
  offset_size = (debug_information + debug_info_entry)->offset_size;
#line 3773
  dwarf_version = (debug_information + debug_info_entry)->dwarf_version;
  {
#line 3780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3782
    if ((unsigned long )(start + 2U * pointer_size) > (unsigned long )section_end) {
      {
#line 3784
      tmp___0 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3784
      warn((char const   *)tmp___0, offset);
      }
#line 3786
      goto while_break;
    }
    {
#line 3793
    begin = byte_get_signed(start, (int )pointer_size);
#line 3794
    start += pointer_size;
#line 3795
    end = byte_get_signed(start, (int )pointer_size);
#line 3796
    start += pointer_size;
#line 3798
    printf((char const   */* __restrict  */)"    %8.8lx ", offset);
    }
#line 3800
    if (begin == 0ULL) {
#line 3800
      if (end == 0ULL) {
        {
#line 3802
        tmp___1 = gettext("<End of list>\n");
#line 3802
        printf((char const   */* __restrict  */)tmp___1);
        }
#line 3803
        goto while_break;
      }
    }
#line 3807
    if (begin == 0xffffffffffffffffULL) {
#line 3807
      if (end != 0xffffffffffffffffULL) {
        {
#line 3809
        base_address = (unsigned long )end;
#line 3810
        print_dwarf_vma(begin, pointer_size);
#line 3811
        print_dwarf_vma(end, pointer_size);
#line 3812
        tmp___2 = gettext("(base address)\n");
#line 3812
        printf((char const   */* __restrict  */)tmp___2);
        }
#line 3813
        goto while_continue;
      }
    }
#line 3816
    if ((unsigned long )(start + 2) > (unsigned long )section_end) {
      {
#line 3818
      tmp___3 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3818
      warn((char const   *)tmp___3, offset);
      }
#line 3820
      goto while_break;
    }
    {
#line 3823
    tmp___4 = (*byte_get)(start, 2);
#line 3823
    length = (unsigned short )tmp___4;
#line 3824
    start += 2;
    }
#line 3826
    if ((unsigned long )(start + (int )length) > (unsigned long )section_end) {
      {
#line 3828
      tmp___5 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3828
      warn((char const   *)tmp___5, offset);
      }
#line 3830
      goto while_break;
    }
    {
#line 3833
    print_dwarf_vma(begin + (dwarf_vma )base_address, pointer_size);
#line 3834
    print_dwarf_vma(end + (dwarf_vma )base_address, pointer_size);
#line 3836
    putchar('(');
#line 3837
    need_frame_base = decode_location_expression(start, pointer_size, offset_size,
                                                 dwarf_version, (dwarf_vma )length,
                                                 (dwarf_vma )cu_offset, section);
#line 3843
    putchar(')');
    }
#line 3845
    if (need_frame_base) {
#line 3845
      if (! has_frame_base) {
        {
#line 3846
        tmp___6 = gettext(" [without DW_AT_frame_base]");
#line 3846
        printf((char const   */* __restrict  */)tmp___6);
        }
      }
    }
#line 3848
    if (begin == end) {
      {
#line 3849
      tmp___7 = gettext(" (start == end)");
#line 3849
      fputs((char const   */* __restrict  */)tmp___7, (FILE */* __restrict  */)stdout);
      }
    } else
#line 3850
    if (begin > end) {
      {
#line 3851
      tmp___8 = gettext(" (start > end)");
#line 3851
      fputs((char const   */* __restrict  */)tmp___8, (FILE */* __restrict  */)stdout);
      }
    }
    {
#line 3853
    putchar('\n');
#line 3855
    start += (int )length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3858
  *start_ptr = start;
#line 3859
  return;
}
}
#line 3865 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void display_loc_list_dwo(struct dwarf_section *section , unsigned char **start_ptr ,
                                 int debug_info_entry , unsigned long offset , int has_frame_base ) 
{ 
  unsigned char *start ;
  unsigned char *section_end ;
  unsigned long cu_offset ;
  unsigned int pointer_size ;
  unsigned int offset_size ;
  int dwarf_version ;
  int entry_type ;
  unsigned short length ;
  int need_frame_base ;
  dwarf_vma idx___0 ;
  unsigned int bytes_read ;
  char *tmp___0 ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  elf_vma tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 3872
  start = *start_ptr;
#line 3873
  section_end = section->start + section->size;
#line 3874
  cu_offset = (unsigned long )(debug_information + debug_info_entry)->cu_offset;
#line 3875
  pointer_size = (debug_information + debug_info_entry)->pointer_size;
#line 3876
  offset_size = (debug_information + debug_info_entry)->offset_size;
#line 3877
  dwarf_version = (debug_information + debug_info_entry)->dwarf_version;
  {
#line 3884
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3886
    printf((char const   */* __restrict  */)"    %8.8lx ", offset);
    }
#line 3888
    if ((unsigned long )(start + 2) > (unsigned long )section_end) {
      {
#line 3890
      tmp___0 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3890
      warn((char const   *)tmp___0, offset);
      }
#line 3892
      goto while_break;
    }
    {
#line 3895
    tmp___1 = (*byte_get)(start, 1);
#line 3895
    entry_type = (int )tmp___1;
#line 3896
    start ++;
    }
    {
#line 3899
    if (entry_type == 0) {
#line 3899
      goto case_0;
    }
#line 3909
    if (entry_type == 1) {
#line 3909
      goto case_1;
    }
#line 3915
    if (entry_type == 2) {
#line 3915
      goto case_2;
    }
#line 3923
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 3900
    idx___0 = (*byte_get)(start, 1);
#line 3901
    start ++;
#line 3902
    *start_ptr = start;
    }
#line 3903
    if (idx___0 == 0ULL) {
      {
#line 3904
      tmp___2 = gettext("<End of list>\n");
#line 3904
      printf((char const   */* __restrict  */)tmp___2);
      }
    } else {
      {
#line 3906
      tmp___3 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3906
      warn((char const   *)tmp___3, offset);
      }
    }
#line 3908
    return;
    case_1: /* CIL Label */ 
    {
#line 3910
    idx___0 = read_leb128(start, & bytes_read, 0);
#line 3911
    start += bytes_read;
#line 3912
    print_dwarf_vma(idx___0, pointer_size);
#line 3913
    tmp___4 = gettext("(base address index)\n");
#line 3913
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 3914
    goto while_continue;
    case_2: /* CIL Label */ 
    {
#line 3916
    idx___0 = read_leb128(start, & bytes_read, 0);
#line 3917
    start += bytes_read;
#line 3918
    print_dwarf_vma(idx___0, pointer_size);
#line 3919
    idx___0 = read_leb128(start, & bytes_read, 0);
#line 3920
    start += bytes_read;
#line 3921
    print_dwarf_vma(idx___0, pointer_size);
    }
#line 3922
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3924
    tmp___5 = gettext("Unknown location-list type 0x%x.\n");
#line 3924
    warn((char const   *)tmp___5, entry_type);
#line 3925
    *start_ptr = start;
    }
#line 3926
    return;
    switch_break: /* CIL Label */ ;
    }
#line 3929
    if ((unsigned long )(start + 2) > (unsigned long )section_end) {
      {
#line 3931
      tmp___6 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3931
      warn((char const   *)tmp___6, offset);
      }
#line 3933
      goto while_break;
    }
    {
#line 3936
    tmp___7 = (*byte_get)(start, 2);
#line 3936
    length = (unsigned short )tmp___7;
#line 3937
    start += 2;
    }
#line 3939
    if ((unsigned long )(start + (int )length) > (unsigned long )section_end) {
      {
#line 3941
      tmp___8 = gettext("Location list starting at offset 0x%lx is not terminated.\n");
#line 3941
      warn((char const   *)tmp___8, offset);
      }
#line 3943
      goto while_break;
    }
    {
#line 3946
    putchar('(');
#line 3947
    need_frame_base = decode_location_expression(start, pointer_size, offset_size,
                                                 dwarf_version, (dwarf_vma )length,
                                                 (dwarf_vma )cu_offset, section);
#line 3953
    putchar(')');
    }
#line 3955
    if (need_frame_base) {
#line 3955
      if (! has_frame_base) {
        {
#line 3956
        tmp___9 = gettext(" [without DW_AT_frame_base]");
#line 3956
        printf((char const   */* __restrict  */)tmp___9);
        }
      }
    }
    {
#line 3958
    putchar('\n');
#line 3960
    start += (int )length;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3963
  *start_ptr = start;
#line 3964
  return;
}
}
#line 3968 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static dwarf_vma *loc_offsets  ;
#line 3970 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int loc_offsets_compar(void const   *ap , void const   *bp ) 
{ 
  dwarf_vma a ;
  dwarf_vma b ;

  {
#line 3973
  a = *(loc_offsets + *((unsigned int const   *)ap));
#line 3974
  b = *(loc_offsets + *((unsigned int const   *)bp));
#line 3976
  return ((a > b) - (b > a));
}
}
#line 3979 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_loc(struct dwarf_section *section , void *file ) 
{ 
  unsigned char *start ;
  unsigned long bytes ;
  unsigned char *section_begin ;
  unsigned int num_loc_list ;
  unsigned long last_offset ;
  unsigned int first ;
  unsigned int i ;
  unsigned int j ;
  unsigned int k ;
  int seen_first_offset ;
  int locs_sorted ;
  unsigned char *next ;
  unsigned int *array ;
  char const   *suffix ;
  char *tmp___0 ;
  int is_dwo ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int num ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned long offset ;
  unsigned long base_address ;
  int has_frame_base ;
  unsigned int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 3982
  start = section->start;
#line 3984
  section_begin = start;
#line 3985
  num_loc_list = 0U;
#line 3986
  last_offset = 0UL;
#line 3987
  first = 0U;
#line 3991
  seen_first_offset = 0;
#line 3992
  locs_sorted = 1;
#line 3994
  array = (unsigned int *)((void *)0);
#line 3995
  tmp___0 = strrchr(section->name, '.');
#line 3995
  suffix = (char const   *)tmp___0;
#line 3996
  is_dwo = 0;
  }
#line 3998
  if (suffix) {
    {
#line 3998
    tmp___1 = strcmp(suffix, ".dwo");
    }
#line 3998
    if (tmp___1 == 0) {
#line 3999
      is_dwo = 1;
    }
  }
#line 4001
  bytes = (unsigned long )section->size;
#line 4003
  if (bytes == 0UL) {
    {
#line 4005
    tmp___2 = gettext("\nThe %s section is empty.\n");
#line 4005
    printf((char const   */* __restrict  */)tmp___2, section->name);
    }
#line 4006
    return (0);
  }
  {
#line 4009
  tmp___4 = load_debug_info(file);
  }
#line 4009
  if (tmp___4 == 0U) {
    {
#line 4011
    tmp___3 = gettext("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n");
#line 4011
    warn((char const   *)tmp___3, section->name);
    }
#line 4013
    return (0);
  }
#line 4019
  i = 0U;
  {
#line 4019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4019
    if (! (i < num_debug_info_entries)) {
#line 4019
      goto while_break;
    }
#line 4023
    num = (debug_information + i)->num_loc_offsets;
#line 4024
    if (num > num_loc_list) {
#line 4025
      num_loc_list = num;
    }
#line 4028
    if (locs_sorted) {
#line 4028
      if (num != 0U) {
#line 4030
        if (! seen_first_offset) {
#line 4033
          last_offset = (unsigned long )*((debug_information + i)->loc_offsets + 0);
#line 4034
          first = i;
#line 4035
          seen_first_offset = 1;
#line 4036
          j = 1U;
        } else {
#line 4039
          j = 0U;
        }
        {
#line 4041
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4041
          if (! (j < num)) {
#line 4041
            goto while_break___0;
          }
#line 4043
          if ((dwarf_vma )last_offset > *((debug_information + i)->loc_offsets + j)) {
#line 4046
            locs_sorted = 0;
#line 4047
            goto while_break___0;
          }
#line 4049
          last_offset = (unsigned long )*((debug_information + i)->loc_offsets + j);
#line 4041
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 4019
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4054
  if (! seen_first_offset) {
    {
#line 4055
    tmp___5 = gettext("No location lists in .debug_info section!\n");
#line 4055
    error((char const   *)tmp___5);
    }
  }
#line 4058
  if ((debug_information + first)->num_loc_offsets > 0U) {
#line 4058
    if (*((debug_information + first)->loc_offsets + 0) != section->address) {
      {
#line 4060
      tmp___6 = dwarf_vmatoa("x", *((debug_information + first)->loc_offsets + 0));
#line 4060
      tmp___7 = gettext("Location lists in %s section start at 0x%s\n");
#line 4060
      warn((char const   *)tmp___7, section->name, tmp___6);
      }
    }
  }
#line 4064
  if (! locs_sorted) {
    {
#line 4065
    tmp___8 = xcmalloc((size_t )num_loc_list, sizeof(unsigned int ));
#line 4065
    array = (unsigned int *)tmp___8;
    }
  }
  {
#line 4066
  tmp___9 = gettext("Contents of the %s section:\n\n");
#line 4066
  printf((char const   */* __restrict  */)tmp___9, section->name);
  }
#line 4067
  if (! is_dwo) {
    {
#line 4068
    tmp___10 = gettext("    Offset   Begin    End      Expression\n");
#line 4068
    printf((char const   */* __restrict  */)tmp___10);
    }
  } else {
    {
#line 4070
    tmp___11 = gettext("    Offset   Begin idx End idx  Expression\n");
#line 4070
    printf((char const   */* __restrict  */)tmp___11);
    }
  }
#line 4072
  seen_first_offset = 0;
#line 4073
  i = first;
  {
#line 4073
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4073
    if (! (i < num_debug_info_entries)) {
#line 4073
      goto while_break___1;
    }
#line 4079
    if (! locs_sorted) {
#line 4081
      k = 0U;
      {
#line 4081
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4081
        if (! (k < (debug_information + i)->num_loc_offsets)) {
#line 4081
          goto while_break___2;
        }
#line 4082
        *(array + k) = k;
#line 4081
        k ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 4083
      loc_offsets = (debug_information + i)->loc_offsets;
#line 4084
      qsort((void *)array, (size_t )(debug_information + i)->num_loc_offsets, sizeof(*array),
            & loc_offsets_compar);
      }
    }
#line 4088
    k = 0U;
    {
#line 4088
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4088
      if (! (k < (debug_information + i)->num_loc_offsets)) {
#line 4088
        goto while_break___3;
      }
#line 4090
      if (locs_sorted) {
#line 4090
        j = k;
      } else {
#line 4090
        j = *(array + k);
      }
#line 4091
      if (k) {
#line 4091
        if (locs_sorted) {
#line 4091
          tmp___12 = k - 1U;
        } else {
#line 4091
          tmp___12 = *(array + (k - 1U));
        }
#line 4091
        if (*((debug_information + i)->loc_offsets + tmp___12) == *((debug_information + i)->loc_offsets + j)) {
#line 4095
          goto __Cont;
        }
      }
#line 4096
      has_frame_base = *((debug_information + i)->have_frame_base + j);
#line 4098
      offset = (unsigned long )(*((debug_information + i)->loc_offsets + j) - section->address);
#line 4099
      next = section_begin + offset;
#line 4100
      base_address = (unsigned long )(debug_information + i)->base_address;
#line 4102
      if (! seen_first_offset) {
#line 4103
        seen_first_offset = 1;
      } else
#line 4106
      if ((unsigned long )start < (unsigned long )next) {
        {
#line 4107
        tmp___13 = gettext("There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n");
#line 4107
        warn((char const   *)tmp___13, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin));
        }
      } else
#line 4110
      if ((unsigned long )start > (unsigned long )next) {
        {
#line 4111
        tmp___14 = gettext("There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n");
#line 4111
        warn((char const   *)tmp___14, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin));
        }
      }
#line 4115
      start = next;
#line 4117
      if (offset >= bytes) {
        {
#line 4119
        tmp___15 = gettext("Offset 0x%lx is bigger than .debug_loc section size.\n");
#line 4119
        warn((char const   *)tmp___15, offset);
        }
#line 4121
        goto __Cont;
      }
#line 4124
      if (is_dwo) {
        {
#line 4125
        display_loc_list_dwo(section, & start, (int )i, offset, has_frame_base);
        }
      } else {
        {
#line 4127
        display_loc_list(section, & start, (int )i, offset, base_address, has_frame_base);
        }
      }
      __Cont: /* CIL Label */ 
#line 4088
      k ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 4073
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 4132
  if ((unsigned long )start < (unsigned long )(section->start + section->size)) {
    {
#line 4133
    tmp___16 = gettext("There are %ld unused bytes at the end of section %s\n");
#line 4133
    warn((char const   *)tmp___16, (section->start + section->size) - start, section->name);
    }
  }
  {
#line 4135
  putchar('\n');
#line 4136
  free((void *)array);
  }
#line 4137
  return (1);
}
}
#line 4140 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_str(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned long bytes ;
  dwarf_vma addr ;
  char *tmp___0 ;
  char *tmp___1 ;
  int j ;
  int k ;
  int lbytes ;

  {
#line 4144
  start = section->start;
#line 4145
  bytes = (unsigned long )section->size;
#line 4146
  addr = section->address;
#line 4148
  if (bytes == 0UL) {
    {
#line 4150
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4150
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4151
    return (0);
  }
  {
#line 4154
  tmp___1 = gettext("Contents of the %s section:\n\n");
#line 4154
  printf((char const   */* __restrict  */)tmp___1, section->name);
  }
  {
#line 4156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4156
    if (! bytes) {
#line 4156
      goto while_break;
    }
#line 4162
    if (bytes > 16UL) {
#line 4162
      lbytes = 16;
    } else {
#line 4162
      lbytes = (int )bytes;
    }
    {
#line 4164
    printf((char const   */* __restrict  */)"  0x%8.8lx ", (unsigned long )addr);
#line 4166
    j = 0;
    }
    {
#line 4166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4166
      if (! (j < 16)) {
#line 4166
        goto while_break___0;
      }
#line 4168
      if (j < lbytes) {
        {
#line 4169
        printf((char const   */* __restrict  */)"%2.2x", (int )*(start + j));
        }
      } else {
        {
#line 4171
        printf((char const   */* __restrict  */)"  ");
        }
      }
#line 4173
      if ((j & 3) == 3) {
        {
#line 4174
        printf((char const   */* __restrict  */)" ");
        }
      }
#line 4166
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4177
    j = 0;
    {
#line 4177
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4177
      if (! (j < lbytes)) {
#line 4177
        goto while_break___1;
      }
#line 4179
      k = (int )*(start + j);
#line 4180
      if (k >= 32) {
#line 4180
        if (k < 128) {
          {
#line 4181
          printf((char const   */* __restrict  */)"%c", k);
          }
        } else {
          {
#line 4183
          printf((char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 4183
        printf((char const   */* __restrict  */)".");
        }
      }
#line 4177
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 4186
    putchar('\n');
#line 4188
    start += lbytes;
#line 4189
    addr += (dwarf_vma )lbytes;
#line 4190
    bytes -= (unsigned long )lbytes;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4193
  putchar('\n');
  }
#line 4195
  return (1);
}
}
#line 4198 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_info(struct dwarf_section *section , void *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 4201
  tmp___0 = process_debug_info(section, file, section->abbrev_sec, 0, 0);
  }
#line 4201
  return (tmp___0);
}
}
#line 4204 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_types(struct dwarf_section *section , void *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 4207
  tmp___0 = process_debug_info(section, file, section->abbrev_sec, 0, 1);
  }
#line 4207
  return (tmp___0);
}
}
#line 4210 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_trace_info(struct dwarf_section *section , void *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 4213
  tmp___0 = process_debug_info(section, file, section->abbrev_sec, 0, 0);
  }
#line 4213
  return (tmp___0);
}
}
#line 4216 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_aranges(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  char *tmp___0 ;
  unsigned char *hdrptr ;
  DWARF2_Internal_ARange arange ;
  unsigned char *addr_ranges ;
  dwarf_vma length ;
  dwarf_vma address ;
  unsigned char address_size ;
  int excess ;
  int offset_size ;
  int initial_length_size ;
  elf_vma tmp___1 ;
  char *tmp___2 ;
  debug_info *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
  {
#line 4220
  start = section->start;
#line 4221
  end = start + section->size;
#line 4223
  tmp___0 = gettext("Contents of the %s section:\n\n");
#line 4223
  printf((char const   */* __restrict  */)tmp___0, section->name);
#line 4227
  load_debug_info(file);
  }
  {
#line 4229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4229
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 4229
      goto while_break;
    }
    {
#line 4241
    hdrptr = start;
#line 4243
    arange.ar_length = (*byte_get)(hdrptr, 4);
#line 4244
    hdrptr += 4;
    }
#line 4246
    if (arange.ar_length == 4294967295ULL) {
      {
#line 4248
      arange.ar_length = (*byte_get)(hdrptr, 8);
#line 4249
      hdrptr += 8;
#line 4250
      offset_size = 8;
#line 4251
      initial_length_size = 12;
      }
    } else {
#line 4255
      offset_size = 4;
#line 4256
      initial_length_size = 4;
    }
    {
#line 4259
    tmp___1 = (*byte_get)(hdrptr, 2);
#line 4259
    arange.ar_version = (unsigned short )tmp___1;
#line 4260
    hdrptr += 2;
#line 4262
    arange.ar_info_offset = (*byte_get)(hdrptr, offset_size);
#line 4263
    hdrptr += offset_size;
    }
#line 4265
    if (num_debug_info_entries != 4294967295U) {
#line 4265
      if (num_debug_info_entries > 0U) {
        {
#line 4265
        tmp___3 = find_debug_info_for_offset((unsigned long )arange.ar_info_offset);
        }
#line 4265
        if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
          {
#line 4268
          tmp___2 = gettext(".debug_info offset of 0x%lx in %s section does not point to a CU header.\n");
#line 4268
          warn((char const   *)tmp___2, (unsigned long )arange.ar_info_offset, section->name);
          }
        }
      }
    }
    {
#line 4271
    tmp___4 = (*byte_get)(hdrptr, 1);
#line 4271
    arange.ar_pointer_size = (unsigned char )tmp___4;
#line 4272
    hdrptr ++;
#line 4274
    tmp___5 = (*byte_get)(hdrptr, 1);
#line 4274
    arange.ar_segment_size = (unsigned char )tmp___5;
#line 4275
    hdrptr ++;
    }
#line 4277
    if ((int )arange.ar_version != 2) {
#line 4277
      if ((int )arange.ar_version != 3) {
        {
#line 4279
        tmp___6 = gettext("Only DWARF 2 and 3 aranges are currently supported.\n");
#line 4279
        warn((char const   *)tmp___6);
        }
#line 4280
        goto while_break;
      }
    }
    {
#line 4283
    tmp___7 = gettext("  Length:                   %ld\n");
#line 4283
    printf((char const   */* __restrict  */)tmp___7, (long )arange.ar_length);
#line 4285
    tmp___8 = gettext("  Version:                  %d\n");
#line 4285
    printf((char const   */* __restrict  */)tmp___8, (int )arange.ar_version);
#line 4286
    tmp___9 = gettext("  Offset into .debug_info:  0x%lx\n");
#line 4286
    printf((char const   */* __restrict  */)tmp___9, (unsigned long )arange.ar_info_offset);
#line 4288
    tmp___10 = gettext("  Pointer Size:             %d\n");
#line 4288
    printf((char const   */* __restrict  */)tmp___10, (int )arange.ar_pointer_size);
#line 4289
    tmp___11 = gettext("  Segment Size:             %d\n");
#line 4289
    printf((char const   */* __restrict  */)tmp___11, (int )arange.ar_segment_size);
#line 4291
    address_size = (unsigned char )((int )arange.ar_pointer_size + (int )arange.ar_segment_size);
    }
#line 4293
    if ((int )address_size == 0) {
      {
#line 4295
      tmp___12 = gettext("Invalid address size in %s section!\n");
#line 4295
      error((char const   *)tmp___12, section->name);
      }
#line 4297
      goto while_break;
    }
#line 4303
    if (((int )address_size & ((int )address_size - 1)) != 0) {
      {
#line 4305
      tmp___13 = gettext("Pointer size + Segment size is not a power of two.\n");
#line 4305
      warn((char const   *)tmp___13);
      }
#line 4306
      goto while_break;
    }
#line 4309
    if ((int )address_size > 4) {
      {
#line 4310
      tmp___14 = gettext("\n    Address            Length\n");
#line 4310
      printf((char const   */* __restrict  */)tmp___14);
      }
    } else {
      {
#line 4312
      tmp___15 = gettext("\n    Address    Length\n");
#line 4312
      printf((char const   */* __restrict  */)tmp___15);
      }
    }
#line 4314
    addr_ranges = hdrptr;
#line 4317
    excess = (int )((hdrptr - start) % (long )(2 * (int )address_size));
#line 4318
    if (excess) {
#line 4319
      addr_ranges += 2 * (int )address_size - excess;
    }
#line 4321
    start += arange.ar_length + (dwarf_vma )initial_length_size;
    {
#line 4323
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4323
      if (! ((unsigned long )(addr_ranges + 2 * (int )address_size) <= (unsigned long )start)) {
#line 4323
        goto while_break___0;
      }
      {
#line 4325
      address = (*byte_get)(addr_ranges, (int )address_size);
#line 4327
      addr_ranges += (int )address_size;
#line 4329
      length = (*byte_get)(addr_ranges, (int )address_size);
#line 4331
      addr_ranges += (int )address_size;
#line 4333
      printf((char const   */* __restrict  */)"    ");
#line 4334
      print_dwarf_vma(address, (unsigned int )address_size);
#line 4335
      print_dwarf_vma(length, (unsigned int )address_size);
#line 4336
      putchar('\n');
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4340
  printf((char const   */* __restrict  */)"\n");
  }
#line 4342
  return (1);
}
}
#line 4346 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int comp_addr_base(void const   *v0 , void const   *v1 ) 
{ 
  debug_info *info0 ;
  debug_info *info1 ;

  {
#line 4349
  info0 = (debug_info *)v0;
#line 4350
  info1 = (debug_info *)v1;
#line 4351
  return ((int )(info0->addr_base - info1->addr_base));
}
}
#line 4355 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_addr(struct dwarf_section *section , void *file ) 
{ 
  debug_info **debug_addr_info ;
  unsigned char *entry ;
  unsigned char *end ;
  unsigned int i ;
  unsigned int count ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp___5 ;
  void *tmp___6 ;
  unsigned int idx___0 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  dwarf_vma base ;
  elf_vma tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;

  {
#line 4365
  if (section->size == 0ULL) {
    {
#line 4367
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4367
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4368
    return (0);
  }
  {
#line 4371
  tmp___2 = load_debug_info(file);
  }
#line 4371
  if (tmp___2 == 0U) {
    {
#line 4373
    tmp___1 = gettext("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n");
#line 4373
    warn((char const   *)tmp___1, section->name);
    }
#line 4375
    return (0);
  }
  {
#line 4378
  tmp___3 = gettext("Contents of the %s section:\n\n");
#line 4378
  printf((char const   */* __restrict  */)tmp___3, section->name);
#line 4380
  tmp___4 = xmalloc((unsigned long )num_debug_info_entries + sizeof(debug_info *));
#line 4380
  debug_addr_info = (debug_info **)tmp___4;
#line 4383
  count = 0U;
#line 4384
  i = 0U;
  }
  {
#line 4384
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4384
    if (! (i < num_debug_info_entries)) {
#line 4384
      goto while_break;
    }
#line 4386
    if ((debug_information + i)->addr_base != 4294967295ULL) {
#line 4387
      tmp___5 = count;
#line 4387
      count ++;
#line 4387
      *(debug_addr_info + tmp___5) = debug_information + i;
    }
#line 4384
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4391
  tmp___6 = xmalloc(sizeof(debug_info ));
#line 4391
  *(debug_addr_info + count) = (debug_info *)tmp___6;
#line 4392
  (*(debug_addr_info + count))->addr_base = section->size;
#line 4394
  qsort((void *)debug_addr_info, (size_t )count, sizeof(debug_info *), & comp_addr_base);
#line 4395
  i = 0U;
  }
  {
#line 4395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4395
    if (! (i < count)) {
#line 4395
      goto while_break___0;
    }
    {
#line 4399
    tmp___7 = dwarf_vmatoa("x", (*(debug_addr_info + i))->cu_offset);
#line 4399
    tmp___8 = gettext("  For compilation unit at offset 0x%s:\n");
#line 4399
    printf((char const   */* __restrict  */)tmp___8, tmp___7);
#line 4402
    tmp___9 = gettext("\tIndex\tOffset\n");
#line 4402
    printf((char const   */* __restrict  */)tmp___9);
#line 4403
    entry = section->start + (*(debug_addr_info + i))->addr_base;
#line 4404
    end = section->start + (*(debug_addr_info + (i + 1U)))->addr_base;
#line 4405
    idx___0 = 0U;
    }
    {
#line 4406
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4406
      if (! ((unsigned long )entry < (unsigned long )end)) {
#line 4406
        goto while_break___1;
      }
      {
#line 4408
      tmp___10 = (*byte_get)(entry, (int )(*(debug_addr_info + i))->pointer_size);
#line 4408
      base = tmp___10;
#line 4409
      tmp___11 = dwarf_vmatoa("x", base);
#line 4409
      tmp___12 = gettext("\t%d:\t%s\n");
#line 4409
      printf((char const   */* __restrict  */)tmp___12, idx___0, tmp___11);
#line 4410
      entry += (*(debug_addr_info + i))->pointer_size;
#line 4411
      idx___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4395
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4414
  printf((char const   */* __restrict  */)"\n");
#line 4416
  free((void *)debug_addr_info);
  }
#line 4417
  return (1);
}
}
#line 4421 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_str_offsets(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  char *tmp___0 ;

  {
#line 4425
  if (section->size == 0ULL) {
    {
#line 4427
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4427
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4428
    return (0);
  }
#line 4432
  return (1);
}
}
#line 4449 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int range_entry_compar(void const   *ap , void const   *bp ) 
{ 
  struct range_entry  const  *a_re ;
  struct range_entry  const  *b_re ;
  unsigned long a ;
  unsigned long b ;

  {
#line 4452
  a_re = (struct range_entry  const  *)ap;
#line 4453
  b_re = (struct range_entry  const  *)bp;
#line 4454
  a = (unsigned long )a_re->ranges_offset;
#line 4455
  b = (unsigned long )b_re->ranges_offset;
#line 4457
  return ((a > b) - (b > a));
}
}
#line 4460 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_ranges(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *last_start ;
  unsigned long bytes ;
  unsigned char *section_begin ;
  unsigned int num_range_list ;
  unsigned int i ;
  struct range_entry *range_entries ;
  struct range_entry *range_entry_fill ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  debug_info *debug_info_p ;
  unsigned int j ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  struct range_entry *range_entry ;
  debug_info *debug_info_p___0 ;
  unsigned int pointer_size ;
  unsigned long offset ;
  unsigned char *next ;
  unsigned long base_address ;
  char *tmp___8 ;
  char *tmp___9 ;
  dwarf_vma begin ;
  dwarf_vma end ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 4464
  start = section->start;
#line 4465
  last_start = start;
#line 4467
  section_begin = start;
#line 4471
  bytes = (unsigned long )section->size;
#line 4473
  if (bytes == 0UL) {
    {
#line 4475
    tmp___0 = gettext("\nThe %s section is empty.\n");
#line 4475
    printf((char const   */* __restrict  */)tmp___0, section->name);
    }
#line 4476
    return (0);
  }
  {
#line 4479
  tmp___2 = load_debug_info(file);
  }
#line 4479
  if (tmp___2 == 0U) {
    {
#line 4481
    tmp___1 = gettext("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n");
#line 4481
    warn((char const   *)tmp___1, section->name);
    }
#line 4483
    return (0);
  }
#line 4486
  num_range_list = 0U;
#line 4487
  i = 0U;
  {
#line 4487
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4487
    if (! (i < num_debug_info_entries)) {
#line 4487
      goto while_break;
    }
#line 4488
    num_range_list += (debug_information + i)->num_range_lists;
#line 4487
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4490
  if (num_range_list == 0U) {
    {
#line 4494
    tmp___3 = gettext("No range lists in .debug_info section.\n");
#line 4494
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 4495
    return (1);
  }
  {
#line 4498
  tmp___4 = xmalloc(sizeof(*range_entries) * (unsigned long )num_range_list);
#line 4498
  range_entries = (struct range_entry *)tmp___4;
#line 4500
  range_entry_fill = range_entries;
#line 4502
  i = 0U;
  }
  {
#line 4502
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4502
    if (! (i < num_debug_info_entries)) {
#line 4502
      goto while_break___0;
    }
#line 4504
    debug_info_p = debug_information + i;
#line 4507
    j = 0U;
    {
#line 4507
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4507
      if (! (j < debug_info_p->num_range_lists)) {
#line 4507
        goto while_break___1;
      }
#line 4509
      range_entry_fill->ranges_offset = (unsigned long )*(debug_info_p->range_lists + j);
#line 4510
      range_entry_fill->debug_info_p = debug_info_p;
#line 4511
      range_entry_fill ++;
#line 4507
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4502
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4515
  qsort((void *)range_entries, (size_t )num_range_list, sizeof(*range_entries), & range_entry_compar);
  }
#line 4519
  if (dwarf_check != 0) {
#line 4519
    if ((dwarf_vma )(range_entries + 0)->ranges_offset != section->address) {
      {
#line 4520
      tmp___5 = gettext("Range lists in %s section start at 0x%lx\n");
#line 4520
      warn((char const   *)tmp___5, section->name, (range_entries + 0)->ranges_offset);
      }
    }
  }
  {
#line 4523
  tmp___6 = gettext("Contents of the %s section:\n\n");
#line 4523
  printf((char const   */* __restrict  */)tmp___6, section->name);
#line 4524
  tmp___7 = gettext("    Offset   Begin    End\n");
#line 4524
  printf((char const   */* __restrict  */)tmp___7);
#line 4526
  i = 0U;
  }
  {
#line 4526
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 4526
    if (! (i < num_range_list)) {
#line 4526
      goto while_break___2;
    }
#line 4528
    range_entry = range_entries + i;
#line 4529
    debug_info_p___0 = range_entry->debug_info_p;
#line 4535
    pointer_size = debug_info_p___0->pointer_size;
#line 4538
    offset = (unsigned long )((dwarf_vma )range_entry->ranges_offset - section->address);
#line 4539
    next = section_begin + offset;
#line 4540
    base_address = (unsigned long )debug_info_p___0->base_address;
#line 4542
    if (dwarf_check != 0) {
#line 4542
      if (i > 0U) {
#line 4544
        if ((unsigned long )start < (unsigned long )next) {
          {
#line 4545
          tmp___8 = gettext("There is a hole [0x%lx - 0x%lx] in %s section.\n");
#line 4545
          warn((char const   *)tmp___8, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin),
               section->name);
          }
        } else
#line 4548
        if ((unsigned long )start > (unsigned long )next) {
#line 4550
          if ((unsigned long )next == (unsigned long )last_start) {
#line 4551
            goto __Cont;
          }
          {
#line 4552
          tmp___9 = gettext("There is an overlap [0x%lx - 0x%lx] in %s section.\n");
#line 4552
          warn((char const   *)tmp___9, (unsigned long )(start - section_begin), (unsigned long )(next - section_begin),
               section->name);
          }
        }
      }
    }
#line 4557
    start = next;
#line 4558
    last_start = next;
    {
#line 4560
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 4570
      begin = byte_get_signed(start, (int )pointer_size);
#line 4571
      start += pointer_size;
#line 4572
      end = byte_get_signed(start, (int )pointer_size);
#line 4573
      start += pointer_size;
#line 4575
      printf((char const   */* __restrict  */)"    %8.8lx ", offset);
      }
#line 4577
      if (begin == 0ULL) {
#line 4577
        if (end == 0ULL) {
          {
#line 4579
          tmp___10 = gettext("<End of list>\n");
#line 4579
          printf((char const   */* __restrict  */)tmp___10);
          }
#line 4580
          goto while_break___3;
        }
      }
#line 4584
      if (begin == 0xffffffffffffffffULL) {
#line 4584
        if (end != 0xffffffffffffffffULL) {
          {
#line 4586
          base_address = (unsigned long )end;
#line 4587
          print_dwarf_vma(begin, pointer_size);
#line 4588
          print_dwarf_vma(end, pointer_size);
#line 4589
          printf((char const   */* __restrict  */)"(base address)\n");
          }
#line 4590
          goto while_continue___3;
        }
      }
      {
#line 4593
      print_dwarf_vma(begin + (dwarf_vma )base_address, pointer_size);
#line 4594
      print_dwarf_vma(end + (dwarf_vma )base_address, pointer_size);
      }
#line 4596
      if (begin == end) {
        {
#line 4597
        tmp___11 = gettext("(start == end)");
#line 4597
        fputs((char const   */* __restrict  */)tmp___11, (FILE */* __restrict  */)stdout);
        }
      } else
#line 4598
      if (begin > end) {
        {
#line 4599
        tmp___12 = gettext("(start > end)");
#line 4599
        fputs((char const   */* __restrict  */)tmp___12, (FILE */* __restrict  */)stdout);
        }
      }
      {
#line 4601
      putchar('\n');
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 4526
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 4604
  putchar('\n');
#line 4606
  free((void *)range_entries);
  }
#line 4608
  return (1);
}
}
#line 4634 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   * const  *dwarf_regnames  ;
#line 4635 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static unsigned int dwarf_regnames_count  ;
#line 4644 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int frame_need_space(Frame_Chunk *fc , unsigned int reg___0 ) 
{ 
  int prev ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4647
  prev = fc->ncols;
#line 4649
  if (reg___0 < (unsigned int )fc->ncols) {
#line 4650
    return (0);
  }
#line 4652
  if (dwarf_regnames_count) {
#line 4652
    if (reg___0 > dwarf_regnames_count) {
#line 4654
      return (-1);
    }
  }
  {
#line 4656
  fc->ncols = (int )(reg___0 + 1U);
#line 4657
  tmp___0 = xcrealloc((void *)fc->col_type, (size_t )fc->ncols, sizeof(short ));
#line 4657
  fc->col_type = (short *)tmp___0;
#line 4659
  tmp___1 = xcrealloc((void *)fc->col_offset, (size_t )fc->ncols, sizeof(int ));
#line 4659
  fc->col_offset = (int *)tmp___1;
  }
  {
#line 4661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4661
    if (! (prev < fc->ncols)) {
#line 4661
      goto while_break;
    }
#line 4663
    *(fc->col_type + prev) = (short)-1;
#line 4664
    *(fc->col_offset + prev) = 0;
#line 4665
    prev ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4667
  return (1);
}
}
#line 4670 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   * const  dwarf_regnames_i386[50]  = 
#line 4670
  {      (char const   */* const  */)"eax",      (char const   */* const  */)"ecx",      (char const   */* const  */)"edx",      (char const   */* const  */)"ebx", 
        (char const   */* const  */)"esp",      (char const   */* const  */)"ebp",      (char const   */* const  */)"esi",      (char const   */* const  */)"edi", 
        (char const   */* const  */)"eip",      (char const   */* const  */)"eflags",      (char const   */* const  */)((void *)0),      (char const   */* const  */)"st0", 
        (char const   */* const  */)"st1",      (char const   */* const  */)"st2",      (char const   */* const  */)"st3",      (char const   */* const  */)"st4", 
        (char const   */* const  */)"st5",      (char const   */* const  */)"st6",      (char const   */* const  */)"st7",      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)"xmm0",      (char const   */* const  */)"xmm1",      (char const   */* const  */)"xmm2", 
        (char const   */* const  */)"xmm3",      (char const   */* const  */)"xmm4",      (char const   */* const  */)"xmm5",      (char const   */* const  */)"xmm6", 
        (char const   */* const  */)"xmm7",      (char const   */* const  */)"mm0",      (char const   */* const  */)"mm1",      (char const   */* const  */)"mm2", 
        (char const   */* const  */)"mm3",      (char const   */* const  */)"mm4",      (char const   */* const  */)"mm5",      (char const   */* const  */)"mm6", 
        (char const   */* const  */)"mm7",      (char const   */* const  */)"fcw",      (char const   */* const  */)"fsw",      (char const   */* const  */)"mxcsr", 
        (char const   */* const  */)"es",      (char const   */* const  */)"cs",      (char const   */* const  */)"ss",      (char const   */* const  */)"ds", 
        (char const   */* const  */)"fs",      (char const   */* const  */)"gs",      (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0), 
        (char const   */* const  */)"tr",      (char const   */* const  */)"ldtr"};
#line 4687 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void init_dwarf_regnames_i386(void) 
{ 


  {
#line 4690
  dwarf_regnames = dwarf_regnames_i386;
#line 4691
  dwarf_regnames_count = (unsigned int )(sizeof(dwarf_regnames_i386) / sizeof(dwarf_regnames_i386[0]));
#line 4692
  return;
}
}
#line 4694 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   * const  dwarf_regnames_x86_64[67]  = 
#line 4694
  {      (char const   */* const  */)"rax",      (char const   */* const  */)"rdx",      (char const   */* const  */)"rcx",      (char const   */* const  */)"rbx", 
        (char const   */* const  */)"rsi",      (char const   */* const  */)"rdi",      (char const   */* const  */)"rbp",      (char const   */* const  */)"rsp", 
        (char const   */* const  */)"r8",      (char const   */* const  */)"r9",      (char const   */* const  */)"r10",      (char const   */* const  */)"r11", 
        (char const   */* const  */)"r12",      (char const   */* const  */)"r13",      (char const   */* const  */)"r14",      (char const   */* const  */)"r15", 
        (char const   */* const  */)"rip",      (char const   */* const  */)"xmm0",      (char const   */* const  */)"xmm1",      (char const   */* const  */)"xmm2", 
        (char const   */* const  */)"xmm3",      (char const   */* const  */)"xmm4",      (char const   */* const  */)"xmm5",      (char const   */* const  */)"xmm6", 
        (char const   */* const  */)"xmm7",      (char const   */* const  */)"xmm8",      (char const   */* const  */)"xmm9",      (char const   */* const  */)"xmm10", 
        (char const   */* const  */)"xmm11",      (char const   */* const  */)"xmm12",      (char const   */* const  */)"xmm13",      (char const   */* const  */)"xmm14", 
        (char const   */* const  */)"xmm15",      (char const   */* const  */)"st0",      (char const   */* const  */)"st1",      (char const   */* const  */)"st2", 
        (char const   */* const  */)"st3",      (char const   */* const  */)"st4",      (char const   */* const  */)"st5",      (char const   */* const  */)"st6", 
        (char const   */* const  */)"st7",      (char const   */* const  */)"mm0",      (char const   */* const  */)"mm1",      (char const   */* const  */)"mm2", 
        (char const   */* const  */)"mm3",      (char const   */* const  */)"mm4",      (char const   */* const  */)"mm5",      (char const   */* const  */)"mm6", 
        (char const   */* const  */)"mm7",      (char const   */* const  */)"rflags",      (char const   */* const  */)"es",      (char const   */* const  */)"cs", 
        (char const   */* const  */)"ss",      (char const   */* const  */)"ds",      (char const   */* const  */)"fs",      (char const   */* const  */)"gs", 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)"fs.base",      (char const   */* const  */)"gs.base", 
        (char const   */* const  */)((void *)0),      (char const   */* const  */)((void *)0),      (char const   */* const  */)"tr",      (char const   */* const  */)"ldtr", 
        (char const   */* const  */)"mxcsr",      (char const   */* const  */)"fcw",      (char const   */* const  */)"fsw"};
#line 4716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void init_dwarf_regnames_x86_64(void) 
{ 


  {
#line 4719
  dwarf_regnames = dwarf_regnames_x86_64;
#line 4720
  dwarf_regnames_count = (unsigned int )(sizeof(dwarf_regnames_x86_64) / sizeof(dwarf_regnames_x86_64[0]));
#line 4721
  return;
}
}
#line 4723 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void init_dwarf_regnames(unsigned int e_machine ) 
{ 


  {
  {
#line 4729
  if (e_machine == 6U) {
#line 4729
    goto case_6;
  }
#line 4729
  if (e_machine == 3U) {
#line 4729
    goto case_6;
  }
#line 4735
  if (e_machine == 181U) {
#line 4735
    goto case_181;
  }
#line 4735
  if (e_machine == 180U) {
#line 4735
    goto case_181;
  }
#line 4735
  if (e_machine == 62U) {
#line 4735
    goto case_181;
  }
#line 4739
  goto switch_default;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 4730
  init_dwarf_regnames_i386();
  }
#line 4731
  goto switch_break;
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
  {
#line 4736
  init_dwarf_regnames_x86_64();
  }
#line 4737
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4740
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4742
  return;
}
}
#line 4747 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char reg[64]  ;
#line 4744 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *regname(unsigned int regno , int row ) 
{ 


  {
#line 4748
  if (dwarf_regnames) {
#line 4748
    if (regno < dwarf_regnames_count) {
#line 4748
      if ((unsigned long )*(dwarf_regnames + regno) != (unsigned long )((void *)0)) {
#line 4752
        if (row) {
#line 4753
          return ((char const   *)*(dwarf_regnames + regno));
        }
        {
#line 4754
        snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d (%s)",
                 regno, *(dwarf_regnames + regno));
        }
      } else {
        {
#line 4758
        snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d",
                 regno);
        }
      }
    } else {
      {
#line 4758
      snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d",
               regno);
      }
    }
  } else {
    {
#line 4758
    snprintf((char */* __restrict  */)(reg), sizeof(reg), (char const   */* __restrict  */)"r%d",
             regno);
    }
  }
#line 4759
  return ((char const   *)(reg));
}
}
#line 4773
static void frame_display_row(Frame_Chunk *fc , int *need_col_headers , int *max_regs ) ;
#line 4773 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static char const   *sloc  =    "   LOC";
#line 4762 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static void frame_display_row(Frame_Chunk *fc , int *need_col_headers , int *max_regs ) 
{ 
  int r ;
  char tmp___0[100] ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 4768
  if (*max_regs < fc->ncols) {
#line 4769
    *max_regs = fc->ncols;
  }
#line 4771
  if (*need_col_headers) {
    {
#line 4775
    *need_col_headers = 0;
#line 4777
    printf((char const   */* __restrict  */)"%-*s CFA      ", eh_addr_size * 2, sloc);
#line 4779
    r = 0;
    }
    {
#line 4779
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4779
      if (! (r < *max_regs)) {
#line 4779
        goto while_break;
      }
#line 4780
      if ((int )*(fc->col_type + r) != -1) {
#line 4782
        if (r == fc->ra) {
          {
#line 4783
          printf((char const   */* __restrict  */)"ra      ");
          }
        } else {
          {
#line 4785
          tmp___1 = regname((unsigned int )r, 1);
#line 4785
          printf((char const   */* __restrict  */)"%-5s ", tmp___1);
          }
        }
      }
#line 4779
      r ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4788
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 4791
  printf((char const   */* __restrict  */)"%0*lx ", eh_addr_size * 2, fc->pc_begin);
  }
#line 4792
  if (fc->cfa_exp) {
    {
#line 4793
    strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"exp");
    }
  } else {
    {
#line 4795
    tmp___2 = regname((unsigned int )fc->cfa_reg, 1);
#line 4795
    sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"%s%+d",
            tmp___2, fc->cfa_offset);
    }
  }
  {
#line 4796
  printf((char const   */* __restrict  */)"%-8s ", tmp___0);
#line 4798
  r = 0;
  }
  {
#line 4798
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4798
    if (! (r < fc->ncols)) {
#line 4798
      goto while_break___0;
    }
#line 4800
    if ((int )*(fc->col_type + r) != -1) {
      {
#line 4804
      if ((int )*(fc->col_type + r) == 7) {
#line 4804
        goto case_7;
      }
#line 4807
      if ((int )*(fc->col_type + r) == 8) {
#line 4807
        goto case_8;
      }
#line 4810
      if ((int )*(fc->col_type + r) == 128) {
#line 4810
        goto case_128;
      }
#line 4813
      if ((int )*(fc->col_type + r) == 20) {
#line 4813
        goto case_20;
      }
#line 4816
      if ((int )*(fc->col_type + r) == 9) {
#line 4816
        goto case_9;
      }
#line 4819
      if ((int )*(fc->col_type + r) == 16) {
#line 4819
        goto case_16;
      }
#line 4822
      if ((int )*(fc->col_type + r) == 22) {
#line 4822
        goto case_22;
      }
#line 4825
      goto switch_default;
      case_7: /* CIL Label */ 
      {
#line 4805
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"u");
      }
#line 4806
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 4808
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"s");
      }
#line 4809
      goto switch_break;
      case_128: /* CIL Label */ 
      {
#line 4811
      sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"c%+d",
              *(fc->col_offset + r));
      }
#line 4812
      goto switch_break;
      case_20: /* CIL Label */ 
      {
#line 4814
      sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"v%+d",
              *(fc->col_offset + r));
      }
#line 4815
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 4817
      tmp___3 = regname((unsigned int )*(fc->col_offset + r), 0);
#line 4817
      sprintf((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"%s",
              tmp___3);
      }
#line 4818
      goto switch_break;
      case_16: /* CIL Label */ 
      {
#line 4820
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"exp");
      }
#line 4821
      goto switch_break;
      case_22: /* CIL Label */ 
      {
#line 4823
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"vexp");
      }
#line 4824
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 4826
      strcpy((char */* __restrict  */)(tmp___0), (char const   */* __restrict  */)"n/a");
      }
#line 4827
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      {
#line 4829
      printf((char const   */* __restrict  */)"%-5s ", tmp___0);
      }
    }
#line 4798
    r ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4832
  printf((char const   */* __restrict  */)"\n");
  }
#line 4833
  return;
}
}
#line 5018 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static Frame_Chunk fde_fc  ;
#line 4839 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_frames(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  unsigned char *end ;
  unsigned char *section_start ;
  Frame_Chunk *chunks ;
  Frame_Chunk *remembered_state ;
  Frame_Chunk *rs ;
  int is_eh ;
  int tmp___0 ;
  unsigned int length_return ;
  int max_regs ;
  char const   *bad_reg ;
  char *tmp___1 ;
  int saved_eh_addr_size ;
  char *tmp___2 ;
  unsigned char *saved_start ;
  unsigned char *block_end ;
  unsigned long length ;
  unsigned long cie_id ;
  Frame_Chunk *fc ;
  Frame_Chunk *cie ;
  int need_col_headers ;
  unsigned char *augmentation_data ;
  unsigned long augmentation_data_len ;
  int encoded_ptr_size ;
  int offset_size ;
  int initial_length_size ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  int version ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  unsigned char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  dwarf_vma tmp___14 ;
  dwarf_signed_vma tmp___15 ;
  elf_vma tmp___16 ;
  dwarf_vma tmp___17 ;
  dwarf_vma tmp___18 ;
  unsigned long i ;
  unsigned char *p ;
  unsigned char *q ;
  int tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *look_for ;
  unsigned long segment_selector ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  elf_vma tmp___25 ;
  dwarf_vma tmp___26 ;
  elf_vma tmp___27 ;
  dwarf_vma tmp___28 ;
  unsigned long i___0 ;
  int tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned int op ;
  unsigned int opa ;
  unsigned long reg___0 ;
  unsigned long temp ;
  unsigned char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  dwarf_vma tmp___34 ;
  int tmp___35 ;
  dwarf_vma tmp___36 ;
  int tmp___37 ;
  dwarf_vma tmp___38 ;
  int tmp___39 ;
  dwarf_vma tmp___40 ;
  int tmp___41 ;
  dwarf_vma tmp___42 ;
  int tmp___43 ;
  dwarf_vma tmp___44 ;
  dwarf_vma tmp___45 ;
  dwarf_vma tmp___46 ;
  int tmp___47 ;
  dwarf_vma tmp___48 ;
  int tmp___49 ;
  dwarf_vma tmp___50 ;
  int tmp___51 ;
  unsigned int op___0 ;
  unsigned int opa___0 ;
  unsigned long ul ;
  unsigned long reg___1 ;
  unsigned long roffs ;
  long l ;
  long ofs ;
  dwarf_vma vma ;
  char const   *reg_prefix ;
  unsigned char *tmp___52 ;
  dwarf_vma tmp___53 ;
  char const   *tmp___54 ;
  char const   *tmp___55 ;
  elf_vma tmp___56 ;
  elf_vma tmp___57 ;
  elf_vma tmp___58 ;
  dwarf_vma tmp___59 ;
  dwarf_vma tmp___60 ;
  char const   *tmp___61 ;
  dwarf_vma tmp___62 ;
  dwarf_vma tmp___63 ;
  char const   *tmp___64 ;
  dwarf_vma tmp___65 ;
  char const   *tmp___66 ;
  dwarf_vma tmp___67 ;
  char const   *tmp___68 ;
  dwarf_vma tmp___69 ;
  char const   *tmp___70 ;
  dwarf_vma tmp___71 ;
  dwarf_vma tmp___72 ;
  char const   *tmp___73 ;
  char const   *tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  void *tmp___77 ;
  dwarf_vma tmp___78 ;
  dwarf_vma tmp___79 ;
  char const   *tmp___80 ;
  dwarf_vma tmp___81 ;
  char const   *tmp___82 ;
  dwarf_vma tmp___83 ;
  dwarf_vma tmp___84 ;
  dwarf_vma tmp___85 ;
  dwarf_vma tmp___86 ;
  char const   *tmp___87 ;
  dwarf_vma tmp___88 ;
  dwarf_vma tmp___89 ;
  char const   *tmp___90 ;
  dwarf_vma tmp___91 ;
  dwarf_signed_vma tmp___92 ;
  int tmp___93 ;
  char const   *tmp___94 ;
  dwarf_vma tmp___95 ;
  dwarf_signed_vma tmp___96 ;
  int tmp___97 ;
  char const   *tmp___98 ;
  dwarf_vma tmp___99 ;
  dwarf_signed_vma tmp___100 ;
  char const   *tmp___101 ;
  dwarf_signed_vma tmp___102 ;
  elf_vma tmp___103 ;
  dwarf_vma tmp___104 ;
  dwarf_vma tmp___105 ;
  dwarf_vma tmp___106 ;
  int tmp___107 ;
  char const   *tmp___108 ;
  char *tmp___109 ;
  char *tmp___110 ;

  {
  {
#line 4843
  start = section->start;
#line 4844
  end = start + section->size;
#line 4845
  section_start = start;
#line 4846
  chunks = (Frame_Chunk *)0;
#line 4847
  remembered_state = (Frame_Chunk *)0;
#line 4849
  tmp___0 = strcmp(section->name, ".eh_frame");
#line 4849
  is_eh = tmp___0 == 0;
#line 4851
  max_regs = 0;
#line 4852
  tmp___1 = gettext("bad register: ");
#line 4852
  bad_reg = (char const   *)tmp___1;
#line 4853
  saved_eh_addr_size = eh_addr_size;
#line 4855
  tmp___2 = gettext("Contents of the %s section:\n");
#line 4855
  printf((char const   */* __restrict  */)tmp___2, section->name);
  }
  {
#line 4857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4857
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 4857
      goto while_break;
    }
    {
#line 4865
    need_col_headers = 1;
#line 4866
    augmentation_data = (unsigned char *)((void *)0);
#line 4867
    augmentation_data_len = 0UL;
#line 4868
    encoded_ptr_size = saved_eh_addr_size;
#line 4872
    saved_start = start;
#line 4873
    tmp___3 = (*byte_get)(start, 4);
#line 4873
    length = (unsigned long )tmp___3;
#line 4873
    start += 4;
    }
#line 4875
    if (length == 0UL) {
      {
#line 4877
      printf((char const   */* __restrict  */)"\n%08lx ZERO terminator\n\n", (unsigned long )(saved_start - section_start));
      }
#line 4879
      goto while_continue;
    }
#line 4882
    if (length == 4294967295UL) {
      {
#line 4884
      tmp___4 = (*byte_get)(start, 8);
#line 4884
      length = (unsigned long )tmp___4;
#line 4885
      start += 8;
#line 4886
      offset_size = 8;
#line 4887
      initial_length_size = 12;
      }
    } else {
#line 4891
      offset_size = 4;
#line 4892
      initial_length_size = 4;
    }
#line 4895
    block_end = (saved_start + length) + initial_length_size;
#line 4896
    if ((unsigned long )block_end > (unsigned long )end) {
      {
#line 4898
      warn("Invalid length %#08lx in FDE at %#08lx\n", length, (unsigned long )(saved_start - section_start));
#line 4900
      block_end = end;
      }
    }
    {
#line 4902
    tmp___5 = (*byte_get)(start, offset_size);
#line 4902
    cie_id = (unsigned long )tmp___5;
#line 4902
    start += offset_size;
    }
#line 4904
    if (is_eh) {
#line 4904
      tmp___29 = cie_id == 0UL;
    } else {
#line 4904
      tmp___29 = cie_id == 4294967295UL;
    }
#line 4904
    if (tmp___29) {
      {
#line 4908
      tmp___6 = xmalloc(sizeof(Frame_Chunk ));
#line 4908
      fc = (Frame_Chunk *)tmp___6;
#line 4909
      memset((void *)fc, 0, sizeof(Frame_Chunk ));
#line 4911
      fc->next = chunks;
#line 4912
      chunks = fc;
#line 4913
      fc->chunk_start = saved_start;
#line 4914
      fc->ncols = 0;
#line 4915
      tmp___7 = xmalloc(sizeof(short ));
#line 4915
      fc->col_type = (short *)tmp___7;
#line 4916
      tmp___8 = xmalloc(sizeof(int ));
#line 4916
      fc->col_offset = (int *)tmp___8;
#line 4917
      frame_need_space(fc, (unsigned int )(max_regs - 1));
#line 4919
      tmp___9 = start;
#line 4919
      start ++;
#line 4919
      version = (int )*tmp___9;
#line 4921
      fc->augmentation = (char *)start;
#line 4922
      tmp___10 = strchr((char const   *)((char *)start), '\000');
#line 4922
      start = (unsigned char *)tmp___10 + 1;
#line 4924
      tmp___11 = strcmp((char const   *)fc->augmentation, "eh");
      }
#line 4924
      if (tmp___11 == 0) {
#line 4925
        start += eh_addr_size;
      }
#line 4927
      if (version >= 4) {
        {
#line 4929
        tmp___12 = (*byte_get)(start, 1);
#line 4929
        fc->ptr_size = (unsigned char )tmp___12;
#line 4929
        start ++;
#line 4930
        tmp___13 = (*byte_get)(start, 1);
#line 4930
        fc->segment_size = (unsigned char )tmp___13;
#line 4930
        start ++;
#line 4931
        eh_addr_size = (int )fc->ptr_size;
        }
      } else {
#line 4935
        fc->ptr_size = (unsigned char )eh_addr_size;
#line 4936
        fc->segment_size = (unsigned char)0;
      }
      {
#line 4938
      tmp___14 = read_leb128(start, & length_return, 0);
#line 4938
      fc->code_factor = (unsigned int )tmp___14;
#line 4938
      start += length_return;
#line 4939
      tmp___15 = read_sleb128(start, & length_return);
#line 4939
      fc->data_factor = (int )tmp___15;
#line 4939
      start += length_return;
      }
#line 4940
      if (version == 1) {
        {
#line 4942
        tmp___16 = (*byte_get)(start, 1);
#line 4942
        fc->ra = (int )tmp___16;
#line 4942
        start ++;
        }
      } else {
        {
#line 4946
        tmp___17 = read_leb128(start, & length_return, 0);
#line 4946
        fc->ra = (int )tmp___17;
#line 4946
        start += length_return;
        }
      }
#line 4949
      if ((int )*(fc->augmentation + 0) == 122) {
        {
#line 4951
        tmp___18 = read_leb128(start, & length_return, 0);
#line 4951
        augmentation_data_len = (unsigned long )tmp___18;
#line 4951
        start += length_return;
#line 4952
        augmentation_data = start;
#line 4953
        start += augmentation_data_len;
        }
      }
#line 4955
      cie = fc;
#line 4957
      if (do_debug_frames_interp) {
        {
#line 4958
        printf((char const   */* __restrict  */)"\n%08lx %08lx %08lx CIE \"%s\" cf=%d df=%d ra=%d\n",
               (unsigned long )(saved_start - section_start), length, cie_id, fc->augmentation,
               fc->code_factor, fc->data_factor, fc->ra);
        }
      } else {
        {
#line 4964
        printf((char const   */* __restrict  */)"\n%08lx %08lx %08lx CIE\n", (unsigned long )(saved_start - section_start),
               length, cie_id);
#line 4966
        printf((char const   */* __restrict  */)"  Version:               %d\n", version);
#line 4967
        printf((char const   */* __restrict  */)"  Augmentation:          \"%s\"\n",
               fc->augmentation);
        }
#line 4968
        if (version >= 4) {
          {
#line 4970
          printf((char const   */* __restrict  */)"  Pointer Size:          %u\n",
                 (int )fc->ptr_size);
#line 4971
          printf((char const   */* __restrict  */)"  Segment Size:          %u\n",
                 (int )fc->segment_size);
          }
        }
        {
#line 4973
        printf((char const   */* __restrict  */)"  Code alignment factor: %u\n", fc->code_factor);
#line 4974
        printf((char const   */* __restrict  */)"  Data alignment factor: %d\n", fc->data_factor);
#line 4975
        printf((char const   */* __restrict  */)"  Return address column: %d\n", fc->ra);
        }
#line 4977
        if (augmentation_data_len) {
          {
#line 4980
          printf((char const   */* __restrict  */)"  Augmentation data:    ");
#line 4981
          i = 0UL;
          }
          {
#line 4981
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 4981
            if (! (i < augmentation_data_len)) {
#line 4981
              goto while_break___0;
            }
            {
#line 4982
            printf((char const   */* __restrict  */)" %02x", (int )*(augmentation_data + i));
#line 4981
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 4983
          putchar('\n');
          }
        }
        {
#line 4985
        putchar('\n');
        }
      }
#line 4988
      if (augmentation_data_len) {
#line 4991
        p = (unsigned char *)fc->augmentation + 1;
#line 4992
        q = augmentation_data;
        {
#line 4994
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 4996
          if ((int )*p == 76) {
#line 4997
            q ++;
          } else
#line 4998
          if ((int )*p == 80) {
            {
#line 4999
            tmp___19 = size_of_encoded_value((int )*q);
#line 4999
            q += 1 + tmp___19;
            }
          } else
#line 5000
          if ((int )*p == 82) {
#line 5001
            tmp___20 = q;
#line 5001
            q ++;
#line 5001
            fc->fde_encoding = *tmp___20;
          } else
#line 5002
          if (! ((int )*p == 83)) {
#line 5005
            goto while_break___1;
          }
#line 5006
          p ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 5009
        if (fc->fde_encoding) {
          {
#line 5010
          encoded_ptr_size = size_of_encoded_value((int )fc->fde_encoding);
          }
        }
      }
      {
#line 5013
      frame_need_space(fc, (unsigned int )fc->ra);
      }
    } else {
      {
#line 5021
      fc = & fde_fc;
#line 5022
      memset((void *)fc, 0, sizeof(Frame_Chunk ));
      }
#line 5024
      if (is_eh) {
#line 5024
        look_for = (start - 4) - cie_id;
      } else {
#line 5024
        look_for = section_start + cie_id;
      }
#line 5026
      cie = chunks;
      {
#line 5026
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5026
        if (! cie) {
#line 5026
          goto while_break___2;
        }
#line 5027
        if ((unsigned long )cie->chunk_start == (unsigned long )look_for) {
#line 5028
          goto while_break___2;
        }
#line 5026
        cie = cie->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5030
      if (! cie) {
        {
#line 5032
        warn("Invalid CIE pointer %#08lx in FDE at %#08lx\n", cie_id, (unsigned long )(saved_start - section_start));
#line 5034
        fc->ncols = 0;
#line 5035
        tmp___21 = xmalloc(sizeof(short ));
#line 5035
        fc->col_type = (short *)tmp___21;
#line 5036
        tmp___22 = xmalloc(sizeof(int ));
#line 5036
        fc->col_offset = (int *)tmp___22;
#line 5037
        frame_need_space(fc, (unsigned int )(max_regs - 1));
#line 5038
        cie = fc;
#line 5039
        fc->augmentation = (char *)"";
#line 5040
        fc->fde_encoding = (unsigned char)0;
#line 5041
        fc->ptr_size = (unsigned char )eh_addr_size;
#line 5042
        fc->segment_size = (unsigned char)0;
        }
      } else {
        {
#line 5046
        fc->ncols = cie->ncols;
#line 5047
        tmp___23 = xcmalloc((size_t )fc->ncols, sizeof(short ));
#line 5047
        fc->col_type = (short *)tmp___23;
#line 5048
        tmp___24 = xcmalloc((size_t )fc->ncols, sizeof(int ));
#line 5048
        fc->col_offset = (int *)tmp___24;
#line 5049
        memcpy((void */* __restrict  */)fc->col_type, (void const   */* __restrict  */)cie->col_type,
               (unsigned long )fc->ncols * sizeof(short ));
#line 5050
        memcpy((void */* __restrict  */)fc->col_offset, (void const   */* __restrict  */)cie->col_offset,
               (unsigned long )fc->ncols * sizeof(int ));
#line 5051
        fc->augmentation = cie->augmentation;
#line 5052
        fc->ptr_size = cie->ptr_size;
#line 5053
        eh_addr_size = (int )cie->ptr_size;
#line 5054
        fc->segment_size = cie->segment_size;
#line 5055
        fc->code_factor = cie->code_factor;
#line 5056
        fc->data_factor = cie->data_factor;
#line 5057
        fc->cfa_reg = cie->cfa_reg;
#line 5058
        fc->cfa_offset = cie->cfa_offset;
#line 5059
        fc->ra = cie->ra;
#line 5060
        frame_need_space(fc, (unsigned int )(max_regs - 1));
#line 5061
        fc->fde_encoding = cie->fde_encoding;
        }
      }
#line 5064
      if (fc->fde_encoding) {
        {
#line 5065
        encoded_ptr_size = size_of_encoded_value((int )fc->fde_encoding);
        }
      }
#line 5067
      segment_selector = 0UL;
#line 5068
      if (fc->segment_size) {
        {
#line 5070
        tmp___25 = (*byte_get)(start, (int )fc->segment_size);
#line 5070
        segment_selector = (unsigned long )tmp___25;
#line 5071
        start += (int )fc->segment_size;
        }
      }
      {
#line 5073
      tmp___26 = get_encoded_value(start, (int )fc->fde_encoding, section);
#line 5073
      fc->pc_begin = (unsigned long )tmp___26;
#line 5074
      start += encoded_ptr_size;
#line 5075
      tmp___27 = (*byte_get)(start, encoded_ptr_size);
#line 5075
      fc->pc_range = (unsigned long )tmp___27;
#line 5076
      start += encoded_ptr_size;
      }
#line 5078
      if ((int )*(cie->augmentation + 0) == 122) {
        {
#line 5080
        tmp___28 = read_leb128(start, & length_return, 0);
#line 5080
        augmentation_data_len = (unsigned long )tmp___28;
#line 5080
        start += length_return;
#line 5081
        augmentation_data = start;
#line 5082
        start += augmentation_data_len;
        }
      }
      {
#line 5085
      printf((char const   */* __restrict  */)"\n%08lx %08lx %08lx FDE cie=%08lx pc=",
             (unsigned long )(saved_start - section_start), length, cie_id, (unsigned long )(cie->chunk_start - section_start));
      }
#line 5088
      if (fc->segment_size) {
        {
#line 5089
        printf((char const   */* __restrict  */)"%04lx:", segment_selector);
        }
      }
      {
#line 5090
      printf((char const   */* __restrict  */)"%08lx..%08lx\n", fc->pc_begin, fc->pc_begin + fc->pc_range);
      }
#line 5091
      if (! do_debug_frames_interp) {
#line 5091
        if (augmentation_data_len) {
          {
#line 5095
          printf((char const   */* __restrict  */)"  Augmentation data:    ");
#line 5096
          i___0 = 0UL;
          }
          {
#line 5096
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 5096
            if (! (i___0 < augmentation_data_len)) {
#line 5096
              goto while_break___3;
            }
            {
#line 5097
            printf((char const   */* __restrict  */)" %02x", (int )*(augmentation_data + i___0));
#line 5096
            i___0 ++;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
          {
#line 5098
          putchar('\n');
#line 5099
          putchar('\n');
          }
        }
      }
    }
#line 5114
    tmp___30 = start;
    {
#line 5116
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 5116
      if (! ((unsigned long )start < (unsigned long )block_end)) {
#line 5116
        goto while_break___4;
      }
#line 5121
      tmp___31 = start;
#line 5121
      start ++;
#line 5121
      op = (unsigned int )*tmp___31;
#line 5122
      opa = op & 63U;
#line 5123
      if (op & 192U) {
#line 5124
        op &= 192U;
      }
      {
#line 5130
      if (op == 64U) {
#line 5130
        goto case_64;
      }
#line 5132
      if (op == 128U) {
#line 5132
        goto case_128;
      }
#line 5137
      if (op == 192U) {
#line 5137
        goto case_192;
      }
#line 5141
      if (op == 1U) {
#line 5141
        goto case_1;
      }
#line 5144
      if (op == 2U) {
#line 5144
        goto case_2;
      }
#line 5147
      if (op == 3U) {
#line 5147
        goto case_3;
      }
#line 5150
      if (op == 4U) {
#line 5150
        goto case_4;
      }
#line 5154
      if (op == 20U) {
#line 5154
        goto case_20;
      }
#line 5154
      if (op == 5U) {
#line 5154
        goto case_20;
      }
#line 5159
      if (op == 6U) {
#line 5159
        goto case_6;
      }
#line 5165
      if (op == 7U) {
#line 5165
        goto case_7;
      }
#line 5170
      if (op == 8U) {
#line 5170
        goto case_8;
      }
#line 5175
      if (op == 9U) {
#line 5175
        goto case_9;
      }
#line 5180
      if (op == 12U) {
#line 5180
        goto case_12;
      }
#line 5183
      if (op == 13U) {
#line 5183
        goto case_13;
      }
#line 5186
      if (op == 14U) {
#line 5186
        goto case_14;
      }
#line 5189
      if (op == 15U) {
#line 5189
        goto case_15;
      }
#line 5194
      if (op == 22U) {
#line 5194
        goto case_22;
      }
#line 5194
      if (op == 16U) {
#line 5194
        goto case_22;
      }
#line 5202
      if (op == 21U) {
#line 5202
        goto case_21;
      }
#line 5202
      if (op == 17U) {
#line 5202
        goto case_21;
      }
#line 5207
      if (op == 18U) {
#line 5207
        goto case_18;
      }
#line 5210
      if (op == 19U) {
#line 5210
        goto case_19;
      }
#line 5213
      if (op == 29U) {
#line 5213
        goto case_29;
      }
#line 5216
      if (op == 46U) {
#line 5216
        goto case_46;
      }
#line 5219
      if (op == 47U) {
#line 5219
        goto case_47;
      }
#line 5224
      goto switch_default;
      case_64: /* CIL Label */ 
#line 5131
      goto switch_break;
      case_128: /* CIL Label */ 
      {
#line 5133
      read_leb128(start, & length_return, 0);
#line 5133
      start += length_return;
#line 5134
      tmp___32 = frame_need_space(fc, opa);
      }
#line 5134
      if (tmp___32 >= 0) {
#line 5135
        *(fc->col_type + opa) = (short)7;
      }
#line 5136
      goto switch_break;
      case_192: /* CIL Label */ 
      {
#line 5138
      tmp___33 = frame_need_space(fc, opa);
      }
#line 5138
      if (tmp___33 >= 0) {
#line 5139
        *(fc->col_type + opa) = (short)7;
      }
#line 5140
      goto switch_break;
      case_1: /* CIL Label */ 
#line 5142
      start += encoded_ptr_size;
#line 5143
      goto switch_break;
      case_2: /* CIL Label */ 
#line 5145
      start ++;
#line 5146
      goto switch_break;
      case_3: /* CIL Label */ 
#line 5148
      start += 2;
#line 5149
      goto switch_break;
      case_4: /* CIL Label */ 
#line 5151
      start += 4;
#line 5152
      goto switch_break;
      case_20: /* CIL Label */ 
      case_5: /* CIL Label */ 
      {
#line 5155
      tmp___34 = read_leb128(start, & length_return, 0);
#line 5155
      reg___0 = (unsigned long )tmp___34;
#line 5155
      start += length_return;
#line 5155
      read_leb128(start, & length_return, 0);
#line 5155
      start += length_return;
#line 5156
      tmp___35 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5156
      if (tmp___35 >= 0) {
#line 5157
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5158
      goto switch_break;
      case_6: /* CIL Label */ 
      {
#line 5160
      tmp___36 = read_leb128(start, & length_return, 0);
#line 5160
      reg___0 = (unsigned long )tmp___36;
#line 5160
      start += length_return;
#line 5161
      frame_need_space(fc, (unsigned int )reg___0);
#line 5162
      tmp___37 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5162
      if (tmp___37 >= 0) {
#line 5163
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5164
      goto switch_break;
      case_7: /* CIL Label */ 
      {
#line 5166
      tmp___38 = read_leb128(start, & length_return, 0);
#line 5166
      reg___0 = (unsigned long )tmp___38;
#line 5166
      start += length_return;
#line 5167
      tmp___39 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5167
      if (tmp___39 >= 0) {
#line 5168
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5169
      goto switch_break;
      case_8: /* CIL Label */ 
      {
#line 5171
      tmp___40 = read_leb128(start, & length_return, 0);
#line 5171
      reg___0 = (unsigned long )tmp___40;
#line 5171
      start += length_return;
#line 5172
      tmp___41 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5172
      if (tmp___41 >= 0) {
#line 5173
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5174
      goto switch_break;
      case_9: /* CIL Label */ 
      {
#line 5176
      tmp___42 = read_leb128(start, & length_return, 0);
#line 5176
      reg___0 = (unsigned long )tmp___42;
#line 5176
      start += length_return;
#line 5176
      read_leb128(start, & length_return, 0);
#line 5176
      start += length_return;
#line 5177
      tmp___43 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5177
      if (tmp___43 >= 0) {
#line 5178
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5179
      goto switch_break;
      case_12: /* CIL Label */ 
      {
#line 5181
      read_leb128(start, & length_return, 0);
#line 5181
      start += length_return;
#line 5181
      read_leb128(start, & length_return, 0);
#line 5181
      start += length_return;
      }
#line 5182
      goto switch_break;
      case_13: /* CIL Label */ 
      {
#line 5184
      read_leb128(start, & length_return, 0);
#line 5184
      start += length_return;
      }
#line 5185
      goto switch_break;
      case_14: /* CIL Label */ 
      {
#line 5187
      read_leb128(start, & length_return, 0);
#line 5187
      start += length_return;
      }
#line 5188
      goto switch_break;
      case_15: /* CIL Label */ 
      {
#line 5190
      tmp___44 = read_leb128(start, & length_return, 0);
#line 5190
      temp = (unsigned long )tmp___44;
#line 5190
      start += length_return;
#line 5191
      start += temp;
      }
#line 5192
      goto switch_break;
      case_22: /* CIL Label */ 
      case_16: /* CIL Label */ 
      {
#line 5195
      tmp___45 = read_leb128(start, & length_return, 0);
#line 5195
      reg___0 = (unsigned long )tmp___45;
#line 5195
      start += length_return;
#line 5196
      tmp___46 = read_leb128(start, & length_return, 0);
#line 5196
      temp = (unsigned long )tmp___46;
#line 5196
      start += length_return;
#line 5197
      start += temp;
#line 5198
      tmp___47 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5198
      if (tmp___47 >= 0) {
#line 5199
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5200
      goto switch_break;
      case_21: /* CIL Label */ 
      case_17: /* CIL Label */ 
      {
#line 5203
      tmp___48 = read_leb128(start, & length_return, 0);
#line 5203
      reg___0 = (unsigned long )tmp___48;
#line 5203
      start += length_return;
#line 5203
      read_sleb128(start, & length_return);
#line 5203
      start += length_return;
#line 5204
      tmp___49 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5204
      if (tmp___49 >= 0) {
#line 5205
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5206
      goto switch_break;
      case_18: /* CIL Label */ 
      {
#line 5208
      read_leb128(start, & length_return, 0);
#line 5208
      start += length_return;
#line 5208
      read_sleb128(start, & length_return);
#line 5208
      start += length_return;
      }
#line 5209
      goto switch_break;
      case_19: /* CIL Label */ 
      {
#line 5211
      read_sleb128(start, & length_return);
#line 5211
      start += length_return;
      }
#line 5212
      goto switch_break;
      case_29: /* CIL Label */ 
#line 5214
      start += 8;
#line 5215
      goto switch_break;
      case_46: /* CIL Label */ 
      {
#line 5217
      read_leb128(start, & length_return, 0);
#line 5217
      start += length_return;
      }
#line 5218
      goto switch_break;
      case_47: /* CIL Label */ 
      {
#line 5220
      tmp___50 = read_leb128(start, & length_return, 0);
#line 5220
      reg___0 = (unsigned long )tmp___50;
#line 5220
      start += length_return;
#line 5220
      read_leb128(start, & length_return, 0);
#line 5220
      start += length_return;
#line 5221
      tmp___51 = frame_need_space(fc, (unsigned int )reg___0);
      }
#line 5221
      if (tmp___51 >= 0) {
#line 5222
        *(fc->col_type + reg___0) = (short)7;
      }
#line 5223
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 5225
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 5228
    start = tmp___30;
    {
#line 5234
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 5234
      if (! ((unsigned long )start < (unsigned long )block_end)) {
#line 5234
        goto while_break___5;
      }
#line 5240
      reg_prefix = "";
#line 5242
      tmp___52 = start;
#line 5242
      start ++;
#line 5242
      op___0 = (unsigned int )*tmp___52;
#line 5243
      opa___0 = op___0 & 63U;
#line 5244
      if (op___0 & 192U) {
#line 5245
        op___0 &= 192U;
      }
      {
#line 5251
      if (op___0 == 64U) {
#line 5251
        goto case_64___0;
      }
#line 5261
      if (op___0 == 128U) {
#line 5261
        goto case_128___0;
      }
#line 5276
      if (op___0 == 192U) {
#line 5276
        goto case_192___0;
      }
#line 5293
      if (op___0 == 1U) {
#line 5293
        goto case_1___0;
      }
#line 5303
      if (op___0 == 2U) {
#line 5303
        goto case_2___0;
      }
#line 5314
      if (op___0 == 3U) {
#line 5314
        goto case_3___0;
      }
#line 5325
      if (op___0 == 4U) {
#line 5325
        goto case_4___0;
      }
#line 5336
      if (op___0 == 5U) {
#line 5336
        goto case_5___0;
      }
#line 5352
      if (op___0 == 20U) {
#line 5352
        goto case_20___0;
      }
#line 5368
      if (op___0 == 6U) {
#line 5368
        goto case_6___0;
      }
#line 5383
      if (op___0 == 7U) {
#line 5383
        goto case_7___0;
      }
#line 5397
      if (op___0 == 8U) {
#line 5397
        goto case_8___0;
      }
#line 5411
      if (op___0 == 9U) {
#line 5411
        goto case_9___0;
      }
#line 5429
      if (op___0 == 10U) {
#line 5429
        goto case_10;
      }
#line 5443
      if (op___0 == 11U) {
#line 5443
        goto case_11;
      }
#line 5462
      if (op___0 == 12U) {
#line 5462
        goto case_12___0;
      }
#line 5471
      if (op___0 == 13U) {
#line 5471
        goto case_13___0;
      }
#line 5479
      if (op___0 == 14U) {
#line 5479
        goto case_14___0;
      }
#line 5485
      if (op___0 == 0U) {
#line 5485
        goto case_0;
      }
#line 5490
      if (op___0 == 15U) {
#line 5490
        goto case_15___0;
      }
#line 5503
      if (op___0 == 16U) {
#line 5503
        goto case_16___0;
      }
#line 5521
      if (op___0 == 22U) {
#line 5521
        goto case_22___0;
      }
#line 5539
      if (op___0 == 17U) {
#line 5539
        goto case_17___0;
      }
#line 5555
      if (op___0 == 21U) {
#line 5555
        goto case_21___0;
      }
#line 5571
      if (op___0 == 18U) {
#line 5571
        goto case_18___0;
      }
#line 5581
      if (op___0 == 19U) {
#line 5581
        goto case_19___0;
      }
#line 5588
      if (op___0 == 29U) {
#line 5588
        goto case_29___0;
      }
#line 5599
      if (op___0 == 45U) {
#line 5599
        goto case_45;
      }
#line 5604
      if (op___0 == 46U) {
#line 5604
        goto case_46___0;
      }
#line 5610
      if (op___0 == 47U) {
#line 5610
        goto case_47___0;
      }
#line 5626
      goto switch_default___0;
      case_64___0: /* CIL Label */ 
#line 5252
      if (do_debug_frames_interp) {
        {
#line 5253
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5255
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc: %d to %08lx\n",
               opa___0 * fc->code_factor, fc->pc_begin + (unsigned long )(opa___0 * fc->code_factor));
        }
      }
#line 5258
      fc->pc_begin += (unsigned long )(opa___0 * fc->code_factor);
#line 5259
      goto switch_break___0;
      case_128___0: /* CIL Label */ 
      {
#line 5262
      tmp___53 = read_leb128(start, & length_return, 0);
#line 5262
      roffs = (unsigned long )tmp___53;
#line 5262
      start += length_return;
      }
#line 5263
      if (opa___0 >= (unsigned int )fc->ncols) {
#line 5264
        reg_prefix = bad_reg;
      }
#line 5265
      if (! do_debug_frames_interp) {
        {
#line 5266
        tmp___54 = regname(opa___0, 0);
#line 5266
        printf((char const   */* __restrict  */)"  DW_CFA_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___54, roffs * (unsigned long )fc->data_factor);
        }
      } else
#line 5265
      if ((int const   )*reg_prefix != 0) {
        {
#line 5266
        tmp___54 = regname(opa___0, 0);
#line 5266
        printf((char const   */* __restrict  */)"  DW_CFA_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___54, roffs * (unsigned long )fc->data_factor);
        }
      }
#line 5269
      if ((int const   )*reg_prefix == 0) {
#line 5271
        *(fc->col_type + opa___0) = (short)128;
#line 5272
        *(fc->col_offset + opa___0) = (int )(roffs * (unsigned long )fc->data_factor);
      }
#line 5274
      goto switch_break___0;
      case_192___0: /* CIL Label */ 
#line 5277
      if (opa___0 >= (unsigned int )cie->ncols) {
#line 5279
        reg_prefix = bad_reg;
      } else
#line 5277
      if (opa___0 >= (unsigned int )fc->ncols) {
#line 5279
        reg_prefix = bad_reg;
      }
#line 5280
      if (! do_debug_frames_interp) {
        {
#line 5281
        tmp___55 = regname(opa___0, 0);
#line 5281
        printf((char const   */* __restrict  */)"  DW_CFA_restore: %s%s\n", reg_prefix,
               tmp___55);
        }
      } else
#line 5280
      if ((int const   )*reg_prefix != 0) {
        {
#line 5281
        tmp___55 = regname(opa___0, 0);
#line 5281
        printf((char const   */* __restrict  */)"  DW_CFA_restore: %s%s\n", reg_prefix,
               tmp___55);
        }
      }
#line 5283
      if ((int const   )*reg_prefix == 0) {
#line 5285
        *(fc->col_type + opa___0) = *(cie->col_type + opa___0);
#line 5286
        *(fc->col_offset + opa___0) = *(cie->col_offset + opa___0);
#line 5287
        if (do_debug_frames_interp) {
#line 5287
          if ((int )*(fc->col_type + opa___0) == -1) {
#line 5289
            *(fc->col_type + opa___0) = (short)7;
          }
        }
      }
#line 5291
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 5294
      vma = get_encoded_value(start, (int )fc->fde_encoding, section);
#line 5295
      start += encoded_ptr_size;
      }
#line 5296
      if (do_debug_frames_interp) {
        {
#line 5297
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5299
        printf((char const   */* __restrict  */)"  DW_CFA_set_loc: %08lx\n", (unsigned long )vma);
        }
      }
#line 5300
      fc->pc_begin = (unsigned long )vma;
#line 5301
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
      {
#line 5304
      tmp___56 = (*byte_get)(start, 1);
#line 5304
      ofs = (long )tmp___56;
#line 5304
      start ++;
      }
#line 5305
      if (do_debug_frames_interp) {
        {
#line 5306
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5308
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc1: %ld to %08lx\n",
               ofs * (long )fc->code_factor, fc->pc_begin + (unsigned long )(ofs * (long )fc->code_factor));
        }
      }
#line 5311
      fc->pc_begin += (unsigned long )(ofs * (long )fc->code_factor);
#line 5312
      goto switch_break___0;
      case_3___0: /* CIL Label */ 
      {
#line 5315
      tmp___57 = (*byte_get)(start, 2);
#line 5315
      ofs = (long )tmp___57;
#line 5315
      start += 2;
      }
#line 5316
      if (do_debug_frames_interp) {
        {
#line 5317
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5319
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc2: %ld to %08lx\n",
               ofs * (long )fc->code_factor, fc->pc_begin + (unsigned long )(ofs * (long )fc->code_factor));
        }
      }
#line 5322
      fc->pc_begin += (unsigned long )(ofs * (long )fc->code_factor);
#line 5323
      goto switch_break___0;
      case_4___0: /* CIL Label */ 
      {
#line 5326
      tmp___58 = (*byte_get)(start, 4);
#line 5326
      ofs = (long )tmp___58;
#line 5326
      start += 4;
      }
#line 5327
      if (do_debug_frames_interp) {
        {
#line 5328
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5330
        printf((char const   */* __restrict  */)"  DW_CFA_advance_loc4: %ld to %08lx\n",
               ofs * (long )fc->code_factor, fc->pc_begin + (unsigned long )(ofs * (long )fc->code_factor));
        }
      }
#line 5333
      fc->pc_begin += (unsigned long )(ofs * (long )fc->code_factor);
#line 5334
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
      {
#line 5337
      tmp___59 = read_leb128(start, & length_return, 0);
#line 5337
      reg___1 = (unsigned long )tmp___59;
#line 5337
      start += length_return;
#line 5338
      tmp___60 = read_leb128(start, & length_return, 0);
#line 5338
      roffs = (unsigned long )tmp___60;
#line 5338
      start += length_return;
      }
#line 5339
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5340
        reg_prefix = bad_reg;
      }
#line 5341
      if (! do_debug_frames_interp) {
        {
#line 5342
        tmp___61 = regname((unsigned int )reg___1, 0);
#line 5342
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___61, roffs * (unsigned long )fc->data_factor);
        }
      } else
#line 5341
      if ((int const   )*reg_prefix != 0) {
        {
#line 5342
        tmp___61 = regname((unsigned int )reg___1, 0);
#line 5342
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___61, roffs * (unsigned long )fc->data_factor);
        }
      }
#line 5345
      if ((int const   )*reg_prefix == 0) {
#line 5347
        *(fc->col_type + reg___1) = (short)128;
#line 5348
        *(fc->col_offset + reg___1) = (int )(roffs * (unsigned long )fc->data_factor);
      }
#line 5350
      goto switch_break___0;
      case_20___0: /* CIL Label */ 
      {
#line 5353
      tmp___62 = read_leb128(start, & length_return, 0);
#line 5353
      reg___1 = (unsigned long )tmp___62;
#line 5353
      start += length_return;
#line 5354
      tmp___63 = read_leb128(start, & length_return, 0);
#line 5354
      roffs = (unsigned long )tmp___63;
#line 5354
      start += length_return;
      }
#line 5355
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5356
        reg_prefix = bad_reg;
      }
#line 5357
      if (! do_debug_frames_interp) {
        {
#line 5358
        tmp___64 = regname((unsigned int )reg___1, 0);
#line 5358
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___64, roffs * (unsigned long )fc->data_factor);
        }
      } else
#line 5357
      if ((int const   )*reg_prefix != 0) {
        {
#line 5358
        tmp___64 = regname((unsigned int )reg___1, 0);
#line 5358
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset: %s%s at cfa%+ld\n",
               reg_prefix, tmp___64, roffs * (unsigned long )fc->data_factor);
        }
      }
#line 5361
      if ((int const   )*reg_prefix == 0) {
#line 5363
        *(fc->col_type + reg___1) = (short)20;
#line 5364
        *(fc->col_offset + reg___1) = (int )(roffs * (unsigned long )fc->data_factor);
      }
#line 5366
      goto switch_break___0;
      case_6___0: /* CIL Label */ 
      {
#line 5369
      tmp___65 = read_leb128(start, & length_return, 0);
#line 5369
      reg___1 = (unsigned long )tmp___65;
#line 5369
      start += length_return;
      }
#line 5370
      if (reg___1 >= (unsigned long )((unsigned int )cie->ncols)) {
#line 5372
        reg_prefix = bad_reg;
      } else
#line 5370
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5372
        reg_prefix = bad_reg;
      }
#line 5373
      if (! do_debug_frames_interp) {
        {
#line 5374
        tmp___66 = regname((unsigned int )reg___1, 0);
#line 5374
        printf((char const   */* __restrict  */)"  DW_CFA_restore_extended: %s%s\n",
               reg_prefix, tmp___66);
        }
      } else
#line 5373
      if ((int const   )*reg_prefix != 0) {
        {
#line 5374
        tmp___66 = regname((unsigned int )reg___1, 0);
#line 5374
        printf((char const   */* __restrict  */)"  DW_CFA_restore_extended: %s%s\n",
               reg_prefix, tmp___66);
        }
      }
#line 5376
      if ((int const   )*reg_prefix == 0) {
#line 5378
        *(fc->col_type + reg___1) = *(cie->col_type + reg___1);
#line 5379
        *(fc->col_offset + reg___1) = *(cie->col_offset + reg___1);
      }
#line 5381
      goto switch_break___0;
      case_7___0: /* CIL Label */ 
      {
#line 5384
      tmp___67 = read_leb128(start, & length_return, 0);
#line 5384
      reg___1 = (unsigned long )tmp___67;
#line 5384
      start += length_return;
      }
#line 5385
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5386
        reg_prefix = bad_reg;
      }
#line 5387
      if (! do_debug_frames_interp) {
        {
#line 5388
        tmp___68 = regname((unsigned int )reg___1, 0);
#line 5388
        printf((char const   */* __restrict  */)"  DW_CFA_undefined: %s%s\n", reg_prefix,
               tmp___68);
        }
      } else
#line 5387
      if ((int const   )*reg_prefix != 0) {
        {
#line 5388
        tmp___68 = regname((unsigned int )reg___1, 0);
#line 5388
        printf((char const   */* __restrict  */)"  DW_CFA_undefined: %s%s\n", reg_prefix,
               tmp___68);
        }
      }
#line 5390
      if ((int const   )*reg_prefix == 0) {
#line 5392
        *(fc->col_type + reg___1) = (short)7;
#line 5393
        *(fc->col_offset + reg___1) = 0;
      }
#line 5395
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
      {
#line 5398
      tmp___69 = read_leb128(start, & length_return, 0);
#line 5398
      reg___1 = (unsigned long )tmp___69;
#line 5398
      start += length_return;
      }
#line 5399
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5400
        reg_prefix = bad_reg;
      }
#line 5401
      if (! do_debug_frames_interp) {
        {
#line 5402
        tmp___70 = regname((unsigned int )reg___1, 0);
#line 5402
        printf((char const   */* __restrict  */)"  DW_CFA_same_value: %s%s\n", reg_prefix,
               tmp___70);
        }
      } else
#line 5401
      if ((int const   )*reg_prefix != 0) {
        {
#line 5402
        tmp___70 = regname((unsigned int )reg___1, 0);
#line 5402
        printf((char const   */* __restrict  */)"  DW_CFA_same_value: %s%s\n", reg_prefix,
               tmp___70);
        }
      }
#line 5404
      if ((int const   )*reg_prefix == 0) {
#line 5406
        *(fc->col_type + reg___1) = (short)8;
#line 5407
        *(fc->col_offset + reg___1) = 0;
      }
#line 5409
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
      {
#line 5412
      tmp___71 = read_leb128(start, & length_return, 0);
#line 5412
      reg___1 = (unsigned long )tmp___71;
#line 5412
      start += length_return;
#line 5413
      tmp___72 = read_leb128(start, & length_return, 0);
#line 5413
      roffs = (unsigned long )tmp___72;
#line 5413
      start += length_return;
      }
#line 5414
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5415
        reg_prefix = bad_reg;
      }
#line 5416
      if (! do_debug_frames_interp) {
        {
#line 5418
        tmp___73 = regname((unsigned int )reg___1, 0);
#line 5418
        printf((char const   */* __restrict  */)"  DW_CFA_register: %s%s in ", reg_prefix,
               tmp___73);
#line 5420
        tmp___74 = regname((unsigned int )roffs, 0);
#line 5420
        puts(tmp___74);
        }
      } else
#line 5416
      if ((int const   )*reg_prefix != 0) {
        {
#line 5418
        tmp___73 = regname((unsigned int )reg___1, 0);
#line 5418
        printf((char const   */* __restrict  */)"  DW_CFA_register: %s%s in ", reg_prefix,
               tmp___73);
#line 5420
        tmp___74 = regname((unsigned int )roffs, 0);
#line 5420
        puts(tmp___74);
        }
      }
#line 5422
      if ((int const   )*reg_prefix == 0) {
#line 5424
        *(fc->col_type + reg___1) = (short)9;
#line 5425
        *(fc->col_offset + reg___1) = (int )roffs;
      }
#line 5427
      goto switch_break___0;
      case_10: /* CIL Label */ 
#line 5430
      if (! do_debug_frames_interp) {
        {
#line 5431
        printf((char const   */* __restrict  */)"  DW_CFA_remember_state\n");
        }
      }
      {
#line 5432
      tmp___75 = xmalloc(sizeof(Frame_Chunk ));
#line 5432
      rs = (Frame_Chunk *)tmp___75;
#line 5433
      rs->ncols = fc->ncols;
#line 5434
      tmp___76 = xcmalloc((size_t )rs->ncols, sizeof(short ));
#line 5434
      rs->col_type = (short *)tmp___76;
#line 5436
      tmp___77 = xcmalloc((size_t )rs->ncols, sizeof(int ));
#line 5436
      rs->col_offset = (int *)tmp___77;
#line 5437
      memcpy((void */* __restrict  */)rs->col_type, (void const   */* __restrict  */)fc->col_type,
             (size_t )rs->ncols);
#line 5438
      memcpy((void */* __restrict  */)rs->col_offset, (void const   */* __restrict  */)fc->col_offset,
             (unsigned long )rs->ncols * sizeof(int ));
#line 5439
      rs->next = remembered_state;
#line 5440
      remembered_state = rs;
      }
#line 5441
      goto switch_break___0;
      case_11: /* CIL Label */ 
#line 5444
      if (! do_debug_frames_interp) {
        {
#line 5445
        printf((char const   */* __restrict  */)"  DW_CFA_restore_state\n");
        }
      }
#line 5446
      rs = remembered_state;
#line 5447
      if (rs) {
        {
#line 5449
        remembered_state = rs->next;
#line 5450
        frame_need_space(fc, (unsigned int )(rs->ncols - 1));
#line 5451
        memcpy((void */* __restrict  */)fc->col_type, (void const   */* __restrict  */)rs->col_type,
               (size_t )rs->ncols);
#line 5452
        memcpy((void */* __restrict  */)fc->col_offset, (void const   */* __restrict  */)rs->col_offset,
               (unsigned long )rs->ncols * sizeof(int ));
#line 5454
        free((void *)rs->col_type);
#line 5455
        free((void *)rs->col_offset);
#line 5456
        free((void *)rs);
        }
      } else
#line 5458
      if (do_debug_frames_interp) {
        {
#line 5459
        printf((char const   */* __restrict  */)"Mismatched DW_CFA_restore_state\n");
        }
      }
#line 5460
      goto switch_break___0;
      case_12___0: /* CIL Label */ 
      {
#line 5463
      tmp___78 = read_leb128(start, & length_return, 0);
#line 5463
      fc->cfa_reg = (int )tmp___78;
#line 5463
      start += length_return;
#line 5464
      tmp___79 = read_leb128(start, & length_return, 0);
#line 5464
      fc->cfa_offset = (int )tmp___79;
#line 5464
      start += length_return;
#line 5465
      fc->cfa_exp = (unsigned char)0;
      }
#line 5466
      if (! do_debug_frames_interp) {
        {
#line 5467
        tmp___80 = regname((unsigned int )fc->cfa_reg, 0);
#line 5467
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa: %s ofs %d\n", tmp___80,
               fc->cfa_offset);
        }
      }
#line 5469
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
      {
#line 5472
      tmp___81 = read_leb128(start, & length_return, 0);
#line 5472
      fc->cfa_reg = (int )tmp___81;
#line 5472
      start += length_return;
#line 5473
      fc->cfa_exp = (unsigned char)0;
      }
#line 5474
      if (! do_debug_frames_interp) {
        {
#line 5475
        tmp___82 = regname((unsigned int )fc->cfa_reg, 0);
#line 5475
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_register: %s\n",
               tmp___82);
        }
      }
#line 5477
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
      {
#line 5480
      tmp___83 = read_leb128(start, & length_return, 0);
#line 5480
      fc->cfa_offset = (int )tmp___83;
#line 5480
      start += length_return;
      }
#line 5481
      if (! do_debug_frames_interp) {
        {
#line 5482
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
        }
      }
#line 5483
      goto switch_break___0;
      case_0: /* CIL Label */ 
#line 5486
      if (! do_debug_frames_interp) {
        {
#line 5487
        printf((char const   */* __restrict  */)"  DW_CFA_nop\n");
        }
      }
#line 5488
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 5491
      tmp___84 = read_leb128(start, & length_return, 0);
#line 5491
      ul = (unsigned long )tmp___84;
#line 5491
      start += length_return;
      }
#line 5492
      if (! do_debug_frames_interp) {
        {
#line 5494
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_expression (");
#line 5495
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5497
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 5499
      fc->cfa_exp = (unsigned char)1;
#line 5500
      start += ul;
#line 5501
      goto switch_break___0;
      case_16___0: /* CIL Label */ 
      {
#line 5504
      tmp___85 = read_leb128(start, & length_return, 0);
#line 5504
      reg___1 = (unsigned long )tmp___85;
#line 5504
      start += length_return;
#line 5505
      tmp___86 = read_leb128(start, & length_return, 0);
#line 5505
      ul = (unsigned long )tmp___86;
#line 5505
      start += length_return;
      }
#line 5506
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5507
        reg_prefix = bad_reg;
      }
#line 5508
      if (! do_debug_frames_interp) {
        {
#line 5510
        tmp___87 = regname((unsigned int )reg___1, 0);
#line 5510
        printf((char const   */* __restrict  */)"  DW_CFA_expression: %s%s (", reg_prefix,
               tmp___87);
#line 5512
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5514
        printf((char const   */* __restrict  */)")\n");
        }
      } else
#line 5508
      if ((int const   )*reg_prefix != 0) {
        {
#line 5510
        tmp___87 = regname((unsigned int )reg___1, 0);
#line 5510
        printf((char const   */* __restrict  */)"  DW_CFA_expression: %s%s (", reg_prefix,
               tmp___87);
#line 5512
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5514
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 5516
      if ((int const   )*reg_prefix == 0) {
#line 5517
        *(fc->col_type + reg___1) = (short)16;
      }
#line 5518
      start += ul;
#line 5519
      goto switch_break___0;
      case_22___0: /* CIL Label */ 
      {
#line 5522
      tmp___88 = read_leb128(start, & length_return, 0);
#line 5522
      reg___1 = (unsigned long )tmp___88;
#line 5522
      start += length_return;
#line 5523
      tmp___89 = read_leb128(start, & length_return, 0);
#line 5523
      ul = (unsigned long )tmp___89;
#line 5523
      start += length_return;
      }
#line 5524
      if (reg___1 >= (unsigned long )((unsigned int )fc->ncols)) {
#line 5525
        reg_prefix = bad_reg;
      }
#line 5526
      if (! do_debug_frames_interp) {
        {
#line 5528
        tmp___90 = regname((unsigned int )reg___1, 0);
#line 5528
        printf((char const   */* __restrict  */)"  DW_CFA_val_expression: %s%s (",
               reg_prefix, tmp___90);
#line 5530
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5532
        printf((char const   */* __restrict  */)")\n");
        }
      } else
#line 5526
      if ((int const   )*reg_prefix != 0) {
        {
#line 5528
        tmp___90 = regname((unsigned int )reg___1, 0);
#line 5528
        printf((char const   */* __restrict  */)"  DW_CFA_val_expression: %s%s (",
               reg_prefix, tmp___90);
#line 5530
        decode_location_expression(start, (unsigned int )eh_addr_size, 0U, -1, (dwarf_vma )ul,
                                   (dwarf_vma )0, section);
#line 5532
        printf((char const   */* __restrict  */)")\n");
        }
      }
#line 5534
      if ((int const   )*reg_prefix == 0) {
#line 5535
        *(fc->col_type + reg___1) = (short)22;
      }
#line 5536
      start += ul;
#line 5537
      goto switch_break___0;
      case_17___0: /* CIL Label */ 
      {
#line 5540
      tmp___91 = read_leb128(start, & length_return, 0);
#line 5540
      reg___1 = (unsigned long )tmp___91;
#line 5540
      start += length_return;
#line 5541
      tmp___92 = read_sleb128(start, & length_return);
#line 5541
      l = (long )tmp___92;
#line 5541
      start += length_return;
#line 5542
      tmp___93 = frame_need_space(fc, (unsigned int )reg___1);
      }
#line 5542
      if (tmp___93 < 0) {
#line 5543
        reg_prefix = bad_reg;
      }
#line 5544
      if (! do_debug_frames_interp) {
        {
#line 5545
        tmp___94 = regname((unsigned int )reg___1, 0);
#line 5545
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___94, l * (long )fc->data_factor);
        }
      } else
#line 5544
      if ((int const   )*reg_prefix != 0) {
        {
#line 5545
        tmp___94 = regname((unsigned int )reg___1, 0);
#line 5545
        printf((char const   */* __restrict  */)"  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___94, l * (long )fc->data_factor);
        }
      }
#line 5548
      if ((int const   )*reg_prefix == 0) {
#line 5550
        *(fc->col_type + reg___1) = (short)128;
#line 5551
        *(fc->col_offset + reg___1) = (int )(l * (long )fc->data_factor);
      }
#line 5553
      goto switch_break___0;
      case_21___0: /* CIL Label */ 
      {
#line 5556
      tmp___95 = read_leb128(start, & length_return, 0);
#line 5556
      reg___1 = (unsigned long )tmp___95;
#line 5556
      start += length_return;
#line 5557
      tmp___96 = read_sleb128(start, & length_return);
#line 5557
      l = (long )tmp___96;
#line 5557
      start += length_return;
#line 5558
      tmp___97 = frame_need_space(fc, (unsigned int )reg___1);
      }
#line 5558
      if (tmp___97 < 0) {
#line 5559
        reg_prefix = bad_reg;
      }
#line 5560
      if (! do_debug_frames_interp) {
        {
#line 5561
        tmp___98 = regname((unsigned int )reg___1, 0);
#line 5561
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___98, l * (long )fc->data_factor);
        }
      } else
#line 5560
      if ((int const   )*reg_prefix != 0) {
        {
#line 5561
        tmp___98 = regname((unsigned int )reg___1, 0);
#line 5561
        printf((char const   */* __restrict  */)"  DW_CFA_val_offset_sf: %s%s at cfa%+ld\n",
               reg_prefix, tmp___98, l * (long )fc->data_factor);
        }
      }
#line 5564
      if ((int const   )*reg_prefix == 0) {
#line 5566
        *(fc->col_type + reg___1) = (short)20;
#line 5567
        *(fc->col_offset + reg___1) = (int )(l * (long )fc->data_factor);
      }
#line 5569
      goto switch_break___0;
      case_18___0: /* CIL Label */ 
      {
#line 5572
      tmp___99 = read_leb128(start, & length_return, 0);
#line 5572
      fc->cfa_reg = (int )tmp___99;
#line 5572
      start += length_return;
#line 5573
      tmp___100 = read_sleb128(start, & length_return);
#line 5573
      fc->cfa_offset = (int )tmp___100;
#line 5573
      start += length_return;
#line 5574
      fc->cfa_offset *= fc->data_factor;
#line 5575
      fc->cfa_exp = (unsigned char)0;
      }
#line 5576
      if (! do_debug_frames_interp) {
        {
#line 5577
        tmp___101 = regname((unsigned int )fc->cfa_reg, 0);
#line 5577
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_sf: %s ofs %d\n",
               tmp___101, fc->cfa_offset);
        }
      }
#line 5579
      goto switch_break___0;
      case_19___0: /* CIL Label */ 
      {
#line 5582
      tmp___102 = read_sleb128(start, & length_return);
#line 5582
      fc->cfa_offset = (int )tmp___102;
#line 5582
      start += length_return;
#line 5583
      fc->cfa_offset *= fc->data_factor;
      }
#line 5584
      if (! do_debug_frames_interp) {
        {
#line 5585
        printf((char const   */* __restrict  */)"  DW_CFA_def_cfa_offset_sf: %d\n",
               fc->cfa_offset);
        }
      }
#line 5586
      goto switch_break___0;
      case_29___0: /* CIL Label */ 
      {
#line 5589
      tmp___103 = (*byte_get)(start, 8);
#line 5589
      ofs = (long )tmp___103;
#line 5589
      start += 8;
      }
#line 5590
      if (do_debug_frames_interp) {
        {
#line 5591
        frame_display_row(fc, & need_col_headers, & max_regs);
        }
      } else {
        {
#line 5593
        printf((char const   */* __restrict  */)"  DW_CFA_MIPS_advance_loc8: %ld to %08lx\n",
               ofs * (long )fc->code_factor, fc->pc_begin + (unsigned long )(ofs * (long )fc->code_factor));
        }
      }
#line 5596
      fc->pc_begin += (unsigned long )(ofs * (long )fc->code_factor);
#line 5597
      goto switch_break___0;
      case_45: /* CIL Label */ 
#line 5600
      if (! do_debug_frames_interp) {
        {
#line 5601
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_window_save\n");
        }
      }
#line 5602
      goto switch_break___0;
      case_46___0: /* CIL Label */ 
      {
#line 5605
      tmp___104 = read_leb128(start, & length_return, 0);
#line 5605
      ul = (unsigned long )tmp___104;
#line 5605
      start += length_return;
      }
#line 5606
      if (! do_debug_frames_interp) {
        {
#line 5607
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_args_size: %ld\n", ul);
        }
      }
#line 5608
      goto switch_break___0;
      case_47___0: /* CIL Label */ 
      {
#line 5611
      tmp___105 = read_leb128(start, & length_return, 0);
#line 5611
      reg___1 = (unsigned long )tmp___105;
#line 5611
      start += length_return;
#line 5612
      tmp___106 = read_leb128(start, & length_return, 0);
#line 5612
      l = (long )(- tmp___106);
#line 5612
      start += length_return;
#line 5613
      tmp___107 = frame_need_space(fc, (unsigned int )reg___1);
      }
#line 5613
      if (tmp___107 < 0) {
#line 5614
        reg_prefix = bad_reg;
      }
#line 5615
      if (! do_debug_frames_interp) {
        {
#line 5616
        tmp___108 = regname((unsigned int )reg___1, 0);
#line 5616
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___108, l * (long )fc->data_factor);
        }
      } else
#line 5615
      if ((int const   )*reg_prefix != 0) {
        {
#line 5616
        tmp___108 = regname((unsigned int )reg___1, 0);
#line 5616
        printf((char const   */* __restrict  */)"  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n",
               reg_prefix, tmp___108, l * (long )fc->data_factor);
        }
      }
#line 5619
      if ((int const   )*reg_prefix == 0) {
#line 5621
        *(fc->col_type + reg___1) = (short)128;
#line 5622
        *(fc->col_offset + reg___1) = (int )(l * (long )fc->data_factor);
      }
#line 5624
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 5627
      if (op___0 >= 28U) {
#line 5627
        if (op___0 <= 63U) {
          {
#line 5628
          tmp___109 = gettext("  DW_CFA_??? (User defined call frame op: %#x)\n");
#line 5628
          printf((char const   */* __restrict  */)tmp___109, op___0);
          }
        } else {
          {
#line 5630
          tmp___110 = gettext("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n");
#line 5630
          warn((char const   *)tmp___110, op___0);
          }
        }
      } else {
        {
#line 5630
        tmp___110 = gettext("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n");
#line 5630
        warn((char const   *)tmp___110, op___0);
        }
      }
#line 5631
      start = block_end;
      switch_break___0: /* CIL Label */ ;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 5635
    if (do_debug_frames_interp) {
      {
#line 5636
      frame_display_row(fc, & need_col_headers, & max_regs);
      }
    }
#line 5638
    start = block_end;
#line 5639
    eh_addr_size = saved_eh_addr_size;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5642
  printf((char const   */* __restrict  */)"\n");
  }
#line 5644
  return (1);
}
}
#line 5651 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_gdb_index(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  unsigned char *start ;
  uint32_t version ;
  uint32_t cu_list_offset ;
  uint32_t tu_list_offset ;
  uint32_t address_table_offset ;
  uint32_t symbol_table_offset ;
  uint32_t constant_pool_offset ;
  unsigned int cu_list_elements ;
  unsigned int tu_list_elements ;
  unsigned int address_table_size ;
  unsigned int symbol_table_slots ;
  unsigned char *cu_list ;
  unsigned char *tu_list ;
  unsigned char *address_table ;
  unsigned char *symbol_table ;
  unsigned char *constant_pool ;
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  elf_vma tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  uint64_t cu_offset ;
  elf_vma tmp___16 ;
  uint64_t cu_length ;
  elf_vma tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  uint64_t tu_offset ;
  elf_vma tmp___20 ;
  uint64_t type_offset ;
  elf_vma tmp___21 ;
  uint64_t signature ;
  elf_vma tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  uint64_t low ;
  elf_vma tmp___25 ;
  uint64_t high ;
  elf_vma tmp___26 ;
  uint32_t cu_index ;
  elf_vma tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  uint32_t name_offset ;
  elf_vma tmp___30 ;
  uint32_t cu_vector_offset ;
  elf_vma tmp___31 ;
  uint32_t num_cus ;
  uint32_t cu ;
  unsigned int j ;
  elf_vma tmp___32 ;
  gdb_index_symbol_kind kind ;
  elf_vma tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;

  {
  {
#line 5655
  start = section->start;
#line 5667
  tmp___0 = gettext("Contents of the %s section:\n");
#line 5667
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
#line 5669
  if (section->size < (dwarf_size_type )(6UL * sizeof(uint32_t ))) {
    {
#line 5671
    tmp___1 = gettext("Truncated header in the %s section.\n");
#line 5671
    warn((char const   *)tmp___1, section->name);
    }
#line 5672
    return (0);
  }
  {
#line 5675
  tmp___2 = byte_get_little_endian(start, 4);
#line 5675
  version = (uint32_t )tmp___2;
#line 5676
  tmp___3 = gettext("Version %ld\n");
#line 5676
  printf((char const   */* __restrict  */)tmp___3, (long )version);
  }
#line 5680
  if (version < 3U) {
    {
#line 5682
    tmp___4 = gettext("Unsupported version %lu.\n");
#line 5682
    warn((char const   *)tmp___4, (unsigned long )version);
    }
#line 5683
    return (0);
  } else
#line 5680
  if (version > 7U) {
    {
#line 5682
    tmp___4 = gettext("Unsupported version %lu.\n");
#line 5682
    warn((char const   *)tmp___4, (unsigned long )version);
    }
#line 5683
    return (0);
  }
#line 5685
  if (version < 4U) {
    {
#line 5686
    tmp___5 = gettext("The address table data in version 3 may be wrong.\n");
#line 5686
    warn((char const   *)tmp___5);
    }
  }
#line 5687
  if (version < 5U) {
    {
#line 5688
    tmp___6 = gettext("Version 4 does not support case insensitive lookups.\n");
#line 5688
    warn((char const   *)tmp___6);
    }
  }
#line 5689
  if (version < 6U) {
    {
#line 5690
    tmp___7 = gettext("Version 5 does not include inlined functions.\n");
#line 5690
    warn((char const   *)tmp___7);
    }
  }
#line 5691
  if (version < 7U) {
    {
#line 5692
    tmp___8 = gettext("Version 6 does not include symbol attributes.\n");
#line 5692
    warn((char const   *)tmp___8);
    }
  }
  {
#line 5694
  tmp___9 = byte_get_little_endian(start + 4, 4);
#line 5694
  cu_list_offset = (uint32_t )tmp___9;
#line 5695
  tmp___10 = byte_get_little_endian(start + 8, 4);
#line 5695
  tu_list_offset = (uint32_t )tmp___10;
#line 5696
  tmp___11 = byte_get_little_endian(start + 12, 4);
#line 5696
  address_table_offset = (uint32_t )tmp___11;
#line 5697
  tmp___12 = byte_get_little_endian(start + 16, 4);
#line 5697
  symbol_table_offset = (uint32_t )tmp___12;
#line 5698
  tmp___13 = byte_get_little_endian(start + 20, 4);
#line 5698
  constant_pool_offset = (uint32_t )tmp___13;
  }
#line 5700
  if ((dwarf_size_type )cu_list_offset > section->size) {
    {
#line 5706
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 5706
    warn((char const   *)tmp___14, section->name);
    }
#line 5707
    return (0);
  } else
#line 5700
  if ((dwarf_size_type )tu_list_offset > section->size) {
    {
#line 5706
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 5706
    warn((char const   *)tmp___14, section->name);
    }
#line 5707
    return (0);
  } else
#line 5700
  if ((dwarf_size_type )address_table_offset > section->size) {
    {
#line 5706
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 5706
    warn((char const   *)tmp___14, section->name);
    }
#line 5707
    return (0);
  } else
#line 5700
  if ((dwarf_size_type )symbol_table_offset > section->size) {
    {
#line 5706
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 5706
    warn((char const   *)tmp___14, section->name);
    }
#line 5707
    return (0);
  } else
#line 5700
  if ((dwarf_size_type )constant_pool_offset > section->size) {
    {
#line 5706
    tmp___14 = gettext("Corrupt header in the %s section.\n");
#line 5706
    warn((char const   *)tmp___14, section->name);
    }
#line 5707
    return (0);
  }
  {
#line 5710
  cu_list_elements = (tu_list_offset - cu_list_offset) / 8U;
#line 5711
  tu_list_elements = (address_table_offset - tu_list_offset) / 8U;
#line 5712
  address_table_size = symbol_table_offset - address_table_offset;
#line 5713
  symbol_table_slots = (constant_pool_offset - symbol_table_offset) / 8U;
#line 5715
  cu_list = start + cu_list_offset;
#line 5716
  tu_list = start + tu_list_offset;
#line 5717
  address_table = start + address_table_offset;
#line 5718
  symbol_table = start + symbol_table_offset;
#line 5719
  constant_pool = start + constant_pool_offset;
#line 5721
  tmp___15 = gettext("\nCU table:\n");
#line 5721
  printf((char const   */* __restrict  */)tmp___15);
#line 5722
  i = 0U;
  }
  {
#line 5722
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5722
    if (! (i < cu_list_elements)) {
#line 5722
      goto while_break;
    }
    {
#line 5724
    tmp___16 = byte_get_little_endian(cu_list + i * 8U, 8);
#line 5724
    cu_offset = (uint64_t )tmp___16;
#line 5725
    tmp___17 = byte_get_little_endian((cu_list + i * 8U) + 8, 8);
#line 5725
    cu_length = (uint64_t )tmp___17;
#line 5727
    tmp___18 = gettext("[%3u] 0x%lx - 0x%lx\n");
#line 5727
    printf((char const   */* __restrict  */)tmp___18, i / 2U, cu_offset, (cu_offset + cu_length) - 1UL);
#line 5722
    i += 2U;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5732
  tmp___19 = gettext("\nTU table:\n");
#line 5732
  printf((char const   */* __restrict  */)tmp___19);
#line 5733
  i = 0U;
  }
  {
#line 5733
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5733
    if (! (i < tu_list_elements)) {
#line 5733
      goto while_break___0;
    }
    {
#line 5735
    tmp___20 = byte_get_little_endian(tu_list + i * 8U, 8);
#line 5735
    tu_offset = (uint64_t )tmp___20;
#line 5736
    tmp___21 = byte_get_little_endian((tu_list + i * 8U) + 8, 8);
#line 5736
    type_offset = (uint64_t )tmp___21;
#line 5737
    tmp___22 = byte_get_little_endian((tu_list + i * 8U) + 16, 8);
#line 5737
    signature = (uint64_t )tmp___22;
#line 5739
    tmp___23 = gettext("[%3u] 0x%lx 0x%lx ");
#line 5739
    printf((char const   */* __restrict  */)tmp___23, i / 3U, tu_offset, type_offset);
#line 5742
    print_dwarf_vma((dwarf_vma )signature, 8U);
#line 5743
    printf((char const   */* __restrict  */)"\n");
#line 5733
    i += 3U;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5746
  tmp___24 = gettext("\nAddress table:\n");
#line 5746
  printf((char const   */* __restrict  */)tmp___24);
#line 5747
  i = 0U;
  }
  {
#line 5747
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5747
    if (! (i < address_table_size)) {
#line 5747
      goto while_break___1;
    }
    {
#line 5749
    tmp___25 = byte_get_little_endian(address_table + i, 8);
#line 5749
    low = (uint64_t )tmp___25;
#line 5750
    tmp___26 = byte_get_little_endian((address_table + i) + 8, 8);
#line 5750
    high = (uint64_t )tmp___26;
#line 5751
    tmp___27 = byte_get_little_endian((address_table + i) + 16, 4);
#line 5751
    cu_index = (uint32_t )tmp___27;
#line 5753
    print_dwarf_vma((dwarf_vma )low, 8U);
#line 5754
    print_dwarf_vma((dwarf_vma )high, 8U);
#line 5755
    tmp___28 = gettext("%lu\n");
#line 5755
    printf((char const   */* __restrict  */)tmp___28, (unsigned long )cu_index);
#line 5747
    i += 20U;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 5758
  tmp___29 = gettext("\nSymbol table:\n");
#line 5758
  printf((char const   */* __restrict  */)tmp___29);
#line 5759
  i = 0U;
  }
  {
#line 5759
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 5759
    if (! (i < symbol_table_slots)) {
#line 5759
      goto while_break___2;
    }
    {
#line 5761
    tmp___30 = byte_get_little_endian(symbol_table + i * 8U, 4);
#line 5761
    name_offset = (uint32_t )tmp___30;
#line 5762
    tmp___31 = byte_get_little_endian((symbol_table + i * 8U) + 4, 4);
#line 5762
    cu_vector_offset = (uint32_t )tmp___31;
    }
#line 5765
    if (name_offset != 0U) {
#line 5765
      goto _L;
    } else
#line 5765
    if (cu_vector_offset != 0U) {
      _L: /* CIL Label */ 
      {
#line 5770
      printf((char const   */* __restrict  */)"[%3u] %s:", i, constant_pool + name_offset);
#line 5771
      tmp___32 = byte_get_little_endian(constant_pool + cu_vector_offset, 4);
#line 5771
      num_cus = (uint32_t )tmp___32;
      }
#line 5772
      if (num_cus > 1U) {
        {
#line 5773
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 5774
      j = 0U;
      {
#line 5774
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 5774
        if (! (j < num_cus)) {
#line 5774
          goto while_break___3;
        }
        {
#line 5778
        tmp___33 = byte_get_little_endian(((constant_pool + cu_vector_offset) + 4) + j * 4U,
                                          4);
#line 5778
        cu = (uint32_t )tmp___33;
#line 5779
        kind = (gdb_index_symbol_kind )((cu >> 28) & 7U);
#line 5780
        cu &= (unsigned int )((1 << 24) - 1);
        }
#line 5782
        if (cu >= cu_list_elements / 2U) {
#line 5783
          if (num_cus > 1U) {
#line 5783
            tmp___34 = '\t';
          } else {
#line 5783
            tmp___34 = ' ';
          }
          {
#line 5783
          printf((char const   */* __restrict  */)"%cT%lu", tmp___34, (unsigned long )(cu - cu_list_elements / 2U));
          }
        } else {
#line 5786
          if (num_cus > 1U) {
#line 5786
            tmp___35 = '\t';
          } else {
#line 5786
            tmp___35 = ' ';
          }
          {
#line 5786
          printf((char const   */* __restrict  */)"%c%lu", tmp___35, (unsigned long )cu);
          }
        }
        {
#line 5790
        if ((unsigned int )kind == 0U) {
#line 5790
          goto case_0;
        }
#line 5793
        if ((unsigned int )kind == 1U) {
#line 5793
          goto case_1;
        }
#line 5796
        if ((unsigned int )kind == 2U) {
#line 5796
          goto case_2;
        }
#line 5799
        if ((unsigned int )kind == 3U) {
#line 5799
          goto case_3;
        }
#line 5802
        if ((unsigned int )kind == 4U) {
#line 5802
          goto case_4;
        }
#line 5805
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 5791
        tmp___36 = gettext(" [no symbol information]");
#line 5791
        printf((char const   */* __restrict  */)tmp___36);
        }
#line 5792
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 5794
        tmp___37 = gettext(" [type]");
#line 5794
        printf((char const   */* __restrict  */)tmp___37);
        }
#line 5795
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 5797
        tmp___38 = gettext(" [variable]");
#line 5797
        printf((char const   */* __restrict  */)tmp___38);
        }
#line 5798
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 5800
        tmp___39 = gettext(" [function]");
#line 5800
        printf((char const   */* __restrict  */)tmp___39);
        }
#line 5801
        goto switch_break;
        case_4: /* CIL Label */ 
        {
#line 5803
        tmp___40 = gettext(" [other]");
#line 5803
        printf((char const   */* __restrict  */)tmp___40);
        }
#line 5804
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 5806
        tmp___41 = gettext(" [unknown: %d]");
#line 5806
        printf((char const   */* __restrict  */)tmp___41, (unsigned int )kind);
        }
#line 5807
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 5809
        if (num_cus > 1U) {
          {
#line 5810
          printf((char const   */* __restrict  */)"\n");
          }
        }
#line 5774
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 5812
      if (num_cus <= 1U) {
        {
#line 5813
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
#line 5759
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 5817
  return (1);
}
}
#line 5820 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static int display_debug_not_supported(struct dwarf_section *section , void *file  __attribute__((__unused__)) ) 
{ 
  char *tmp___0 ;

  {
  {
#line 5824
  tmp___0 = gettext("Displaying the debug contents of section %s is not yet supported.\n");
#line 5824
  printf((char const   */* __restrict  */)tmp___0, section->name);
  }
#line 5827
  return (1);
}
}
#line 5830 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void *cmalloc(size_t nmemb , size_t size ) 
{ 
  void *tmp___0 ;

  {
#line 5834
  if (nmemb >= 0xffffffffffffffffUL / size) {
#line 5835
    return ((void *)0);
  } else {
    {
#line 5837
    tmp___0 = malloc(nmemb * size);
    }
#line 5837
    return (tmp___0);
  }
}
}
#line 5840 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void *xcmalloc(size_t nmemb , size_t size ) 
{ 
  void *tmp___0 ;

  {
#line 5844
  if (nmemb >= 0xffffffffffffffffUL / size) {
#line 5845
    return ((void *)0);
  } else {
    {
#line 5847
    tmp___0 = xmalloc(nmemb * size);
    }
#line 5847
    return (tmp___0);
  }
}
}
#line 5850 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void *xcrealloc(void *ptr , size_t nmemb , size_t size ) 
{ 
  void *tmp___0 ;

  {
#line 5854
  if (nmemb >= 0xffffffffffffffffUL / size) {
#line 5855
    return ((void *)0);
  } else {
    {
#line 5857
    tmp___0 = xrealloc(ptr, nmemb * size);
    }
#line 5857
    return (tmp___0);
  }
}
}
#line 5860 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void free_debug_memory(void) 
{ 
  unsigned int i ;

  {
  {
#line 5865
  free_abbrevs();
#line 5867
  i = 0U;
  }
  {
#line 5867
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5867
    if (! (i < 32U)) {
#line 5867
      goto while_break;
    }
    {
#line 5868
    free_debug_section((enum dwarf_section_display_enum )i);
#line 5867
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5870
  if ((unsigned long )debug_information != (unsigned long )((void *)0)) {
#line 5872
    if (num_debug_info_entries != 4294967295U) {
#line 5874
      i = 0U;
      {
#line 5874
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 5874
        if (! (i < num_debug_info_entries)) {
#line 5874
          goto while_break___0;
        }
#line 5876
        if (! (debug_information + i)->max_loc_offsets) {
          {
#line 5878
          free((void *)(debug_information + i)->loc_offsets);
#line 5879
          free((void *)(debug_information + i)->have_frame_base);
          }
        }
#line 5881
        if (! (debug_information + i)->max_range_lists) {
          {
#line 5882
          free((void *)(debug_information + i)->range_lists);
          }
        }
#line 5874
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 5886
    free((void *)debug_information);
#line 5887
    debug_information = (debug_info *)((void *)0);
#line 5888
    num_debug_info_entries = 0U;
    }
  }
#line 5890
  return;
}
}
#line 5903 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
static debug_dump_long_opts const   opts_table[20]  = 
#line 5903
  {      {"Ranges", & do_debug_ranges, 1}, 
        {"abbrev", & do_debug_abbrevs, 1}, 
        {"aranges", & do_debug_aranges, 1}, 
        {"frames", & do_debug_frames, 1}, 
        {"frames-interp", & do_debug_frames_interp, 1}, 
        {"info", & do_debug_info, 1}, 
        {"line", & do_debug_lines, 1}, 
        {"rawline", & do_debug_lines, 1}, 
        {"decodedline", & do_debug_lines, 2}, 
        {"loc", & do_debug_loc, 1}, 
        {"macro", & do_debug_macinfo, 1}, 
        {"pubnames", & do_debug_pubnames, 1}, 
        {"pubtypes", & do_debug_pubtypes, 1}, 
        {"ranges", & do_debug_aranges, 1}, 
        {"str", & do_debug_str, 1}, 
        {"gdb_index", & do_gdb_index, 1}, 
        {"trace_abbrev", & do_trace_abbrevs, 1}, 
        {"trace_aranges", & do_trace_aranges, 1}, 
        {"trace_info", & do_trace_info, 1}, 
        {(char const   *)((void *)0), (int *)((void *)0), 0}};
#line 5892 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void dwarf_select_sections_by_names(char const   *names ) 
{ 
  char const   *p ;
  debug_dump_long_opts const   *entry ;
  size_t len ;
  size_t tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 5934
  p = names;
  {
#line 5935
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5935
    if (! *p) {
#line 5935
      goto while_break;
    }
#line 5939
    entry = opts_table;
    {
#line 5939
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5939
      if (! entry->option) {
#line 5939
        goto while_break___0;
      }
      {
#line 5941
      tmp___0 = strlen((char const   *)entry->option);
#line 5941
      len = tmp___0;
#line 5943
      tmp___1 = strncmp(p, (char const   *)entry->option, len);
      }
#line 5943
      if (tmp___1 == 0) {
#line 5943
        if ((int const   )*(p + len) == 44) {
#line 5943
          goto _L;
        } else
#line 5943
        if ((int const   )*(p + len) == 0) {
          _L: /* CIL Label */ 
#line 5946
          *(entry->variable) |= (int )entry->val;
#line 5950
          if (do_debug_frames_interp) {
#line 5951
            do_debug_frames = 1;
          }
#line 5953
          p += len;
#line 5954
          goto while_break___0;
        }
      }
#line 5939
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5958
    if ((unsigned long )entry->option == (unsigned long )((void *)0)) {
      {
#line 5960
      tmp___2 = gettext("Unrecognized debug option \'%s\'\n");
#line 5960
      warn((char const   *)tmp___2, p);
#line 5961
      tmp___3 = strchr(p, ',');
#line 5961
      p = (char const   *)tmp___3;
      }
#line 5962
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5963
        goto while_break;
      }
    }
#line 5966
    if ((int const   )*p == 44) {
#line 5967
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 5969
  return;
}
}
#line 5971 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void dwarf_select_sections_by_letters(char const   *letters ) 
{ 
  unsigned int lindex ;
  unsigned int tmp___0 ;
  char *tmp___1 ;

  {
#line 5974
  lindex = 0U;
  {
#line 5976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5976
    if (! *(letters + lindex)) {
#line 5976
      goto while_break;
    }
#line 5977
    tmp___0 = lindex;
#line 5977
    lindex ++;
    {
#line 5979
    if ((int const   )*(letters + tmp___0) == 105) {
#line 5979
      goto case_105;
    }
#line 5983
    if ((int const   )*(letters + tmp___0) == 97) {
#line 5983
      goto case_97;
    }
#line 5987
    if ((int const   )*(letters + tmp___0) == 108) {
#line 5987
      goto case_108;
    }
#line 5991
    if ((int const   )*(letters + tmp___0) == 76) {
#line 5991
      goto case_76;
    }
#line 5995
    if ((int const   )*(letters + tmp___0) == 112) {
#line 5995
      goto case_112;
    }
#line 5999
    if ((int const   )*(letters + tmp___0) == 116) {
#line 5999
      goto case_116;
    }
#line 6003
    if ((int const   )*(letters + tmp___0) == 114) {
#line 6003
      goto case_114;
    }
#line 6007
    if ((int const   )*(letters + tmp___0) == 82) {
#line 6007
      goto case_82;
    }
#line 6011
    if ((int const   )*(letters + tmp___0) == 70) {
#line 6011
      goto case_70;
    }
#line 6013
    if ((int const   )*(letters + tmp___0) == 102) {
#line 6013
      goto case_102;
    }
#line 6017
    if ((int const   )*(letters + tmp___0) == 109) {
#line 6017
      goto case_109;
    }
#line 6021
    if ((int const   )*(letters + tmp___0) == 115) {
#line 6021
      goto case_115;
    }
#line 6025
    if ((int const   )*(letters + tmp___0) == 111) {
#line 6025
      goto case_111;
    }
#line 6029
    goto switch_default;
    case_105: /* CIL Label */ 
#line 5980
    do_debug_info = 1;
#line 5981
    goto switch_break;
    case_97: /* CIL Label */ 
#line 5984
    do_debug_abbrevs = 1;
#line 5985
    goto switch_break;
    case_108: /* CIL Label */ 
#line 5988
    do_debug_lines |= 1;
#line 5989
    goto switch_break;
    case_76: /* CIL Label */ 
#line 5992
    do_debug_lines |= 2;
#line 5993
    goto switch_break;
    case_112: /* CIL Label */ 
#line 5996
    do_debug_pubnames = 1;
#line 5997
    goto switch_break;
    case_116: /* CIL Label */ 
#line 6000
    do_debug_pubtypes = 1;
#line 6001
    goto switch_break;
    case_114: /* CIL Label */ 
#line 6004
    do_debug_aranges = 1;
#line 6005
    goto switch_break;
    case_82: /* CIL Label */ 
#line 6008
    do_debug_ranges = 1;
#line 6009
    goto switch_break;
    case_70: /* CIL Label */ 
#line 6012
    do_debug_frames_interp = 1;
    case_102: /* CIL Label */ 
#line 6014
    do_debug_frames = 1;
#line 6015
    goto switch_break;
    case_109: /* CIL Label */ 
#line 6018
    do_debug_macinfo = 1;
#line 6019
    goto switch_break;
    case_115: /* CIL Label */ 
#line 6022
    do_debug_str = 1;
#line 6023
    goto switch_break;
    case_111: /* CIL Label */ 
#line 6026
    do_debug_loc = 1;
#line 6027
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 6030
    tmp___1 = gettext("Unrecognized debug option \'%s\'\n");
#line 6030
    warn((char const   *)tmp___1, optarg);
    }
#line 6031
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6033
  return;
}
}
#line 6035 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
void dwarf_select_sections_all(void) 
{ 


  {
#line 6038
  do_debug_info = 1;
#line 6039
  do_debug_abbrevs = 1;
#line 6040
  do_debug_lines = 1;
#line 6041
  do_debug_pubnames = 1;
#line 6042
  do_debug_pubtypes = 1;
#line 6043
  do_debug_aranges = 1;
#line 6044
  do_debug_ranges = 1;
#line 6045
  do_debug_frames = 1;
#line 6046
  do_debug_macinfo = 1;
#line 6047
  do_debug_str = 1;
#line 6048
  do_debug_loc = 1;
#line 6049
  do_gdb_index = 1;
#line 6050
  do_trace_info = 1;
#line 6051
  do_trace_abbrevs = 1;
#line 6052
  do_trace_aranges = 1;
#line 6053
  return;
}
}
#line 6055 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/dwarf.c"
struct dwarf_section_display debug_displays[32]  = 
#line 6055
  {      {{".debug_abbrev", ".zdebug_abbrev", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_abbrev,
      & do_debug_abbrevs, 0U}, 
        {{".debug_aranges", ".zdebug_aranges", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_aranges,
      & do_debug_aranges, 1U}, 
        {{".debug_frame", ".zdebug_frame", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_frames,
      & do_debug_frames, 1U}, 
        {{".debug_info", ".zdebug_info", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_info,
      & do_debug_info, 1U}, 
        {{".debug_line", ".zdebug_line", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_lines,
      & do_debug_lines, 1U}, 
        {{".debug_pubnames", ".zdebug_pubnames", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_pubnames,
      & do_debug_pubnames, 0U}, 
        {{".eh_frame", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_frames,
      & do_debug_frames, 1U}, 
        {{".debug_macinfo", ".zdebug_macinfo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macinfo,
      & do_debug_macinfo, 0U}, 
        {{".debug_macro", ".zdebug_macro", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macro,
      & do_debug_macinfo, 1U}, 
        {{".debug_str", ".zdebug_str", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_str,
      & do_debug_str, 0U}, 
        {{".debug_loc", ".zdebug_loc", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_loc,
      & do_debug_loc, 1U}, 
        {{".debug_pubtypes", ".zdebug_pubtypes", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_pubnames,
      & do_debug_pubtypes, 0U}, 
        {{".debug_ranges", ".zdebug_ranges", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_ranges,
      & do_debug_ranges, 1U}, 
        {{".debug_static_func", ".zdebug_static_func", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_not_supported,
      (int *)((void *)0), 0U}, 
        {{".debug_static_vars", ".zdebug_static_vars", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_not_supported,
      (int *)((void *)0), 0U}, 
        {{".debug_types", ".zdebug_types", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_types,
      & do_debug_info, 1U}, 
        {{".debug_weaknames", ".zdebug_weaknames", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_not_supported,
      (int *)((void *)0), 0U}, 
        {{".gdb_index", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_gdb_index,
      & do_gdb_index, 0U}, 
        {{".trace_info", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )19},
      & display_trace_info, & do_trace_info, 1U}, 
        {{".trace_abbrev", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_abbrev,
      & do_trace_abbrevs, 0U}, 
        {{".trace_aranges", "", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_aranges,
      & do_trace_aranges, 0U}, 
        {{".debug_info.dwo", ".zdebug_info.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_info, & do_debug_info, 1U}, 
        {{".debug_abbrev.dwo", ".zdebug_abbrev.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_abbrev, & do_debug_abbrevs, 0U}, 
        {{".debug_types.dwo", ".zdebug_types.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_types, & do_debug_info, 1U}, 
        {{".debug_line.dwo", ".zdebug_line.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_lines, & do_debug_lines, 1U}, 
        {{".debug_loc.dwo", ".zdebug_loc.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )22},
      & display_debug_loc, & do_debug_loc, 1U}, 
        {{".debug_macro.dwo", ".zdebug_macro.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macro,
      & do_debug_macinfo, 1U}, 
        {{".debug_macinfo.dwo", ".zdebug_macinfo.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_macinfo,
      & do_debug_macinfo, 0U}, 
        {{".debug_str.dwo", ".zdebug_str.dwo", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )28},
      & display_debug_str, & do_debug_str, 1U}, 
        {{".debug_str_offsets", ".zdebug_str_offsets", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0}, & display_debug_str_offsets,
      (int *)((void *)0), 0U}, 
        {{".debug_str_offsets.dwo", ".zdebug_str_offsets.dwo", (char const   *)((void *)0),
       (unsigned char *)((void *)0), (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )0},
      & display_debug_str_offsets, (int *)((void *)0), 0U}, 
        {{".debug_addr", ".zdebug_addr", (char const   *)((void *)0), (unsigned char *)((void *)0),
       (dwarf_vma )0, (dwarf_size_type )0, (enum dwarf_section_display_enum )31},
      & display_debug_addr, (int *)((void *)0), 1U}};
#line 32 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.h"
unsigned char const   *unw_decode(unsigned char const   *dp , int inside_body , void *ptr_inside_body ) ;
#line 38 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static bfd_vma unw_rlen  =    (bfd_vma )0;
#line 40
static void unw_print_brmask(char *cp , unsigned int mask ) ;
#line 41
static void unw_print_grmask(char *cp , unsigned int mask ) ;
#line 42
static void unw_print_frmask(char *cp , unsigned int mask ) ;
#line 43
static void unw_print_abreg(char *cp , unsigned int abreg ) ;
#line 44
static void unw_print_xyreg(char *cp , unsigned int x , unsigned int ytreg ) ;
#line 46 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static void unw_print_brmask(char *cp , unsigned int mask ) 
{ 
  int sep ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 49
  sep = 0;
#line 52
  i = 0;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (mask) {
#line 52
      if (! (i < 5)) {
#line 52
        goto while_break;
      }
    } else {
#line 52
      goto while_break;
    }
#line 54
    if (mask & 1U) {
#line 56
      if (sep) {
#line 57
        tmp___0 = cp;
#line 57
        cp ++;
#line 57
        *tmp___0 = (char )',';
      }
#line 58
      tmp___1 = cp;
#line 58
      cp ++;
#line 58
      *tmp___1 = (char )'b';
#line 59
      tmp___2 = cp;
#line 59
      cp ++;
#line 59
      *tmp___2 = (char )((i + 1) + 48);
#line 60
      sep = 1;
    }
#line 62
    mask >>= 1;
#line 52
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 64
  *cp = (char )'\000';
#line 65
  return;
}
}
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static void unw_print_grmask(char *cp , unsigned int mask ) 
{ 
  int sep ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 70
  sep = 0;
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 4)) {
#line 73
      goto while_break;
    }
#line 75
    if (mask & 1U) {
#line 77
      if (sep) {
#line 78
        tmp___0 = cp;
#line 78
        cp ++;
#line 78
        *tmp___0 = (char )',';
      }
#line 79
      tmp___1 = cp;
#line 79
      cp ++;
#line 79
      *tmp___1 = (char )'r';
#line 80
      tmp___2 = cp;
#line 80
      cp ++;
#line 80
      *tmp___2 = (char )((i + 4) + 48);
#line 81
      sep = 1;
    }
#line 83
    mask >>= 1;
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  *cp = (char )'\000';
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static void unw_print_frmask(char *cp , unsigned int mask ) 
{ 
  int sep ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 91
  sep = 0;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < 20)) {
#line 94
      goto while_break;
    }
#line 96
    if (mask & 1U) {
#line 98
      if (sep) {
#line 99
        tmp___0 = cp;
#line 99
        cp ++;
#line 99
        *tmp___0 = (char )',';
      }
#line 100
      tmp___1 = cp;
#line 100
      cp ++;
#line 100
      *tmp___1 = (char )'f';
#line 101
      if (i < 4) {
#line 102
        tmp___2 = cp;
#line 102
        cp ++;
#line 102
        *tmp___2 = (char )((i + 2) + 48);
      } else {
#line 105
        tmp___3 = cp;
#line 105
        cp ++;
#line 105
        *tmp___3 = (char )(((i + 2) / 10 + 1) + 48);
#line 106
        tmp___4 = cp;
#line 106
        cp ++;
#line 106
        *tmp___4 = (char )((i + 2) % 10 + 48);
      }
#line 108
      sep = 1;
    }
#line 110
    mask >>= 1;
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  *cp = (char )'\000';
#line 113
  return;
}
}
#line 118 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static char const   * const  special_reg[16]  = 
#line 118
  {      (char const   */* const  */)"pr",      (char const   */* const  */)"psp",      (char const   */* const  */)"@priunat",      (char const   */* const  */)"rp", 
        (char const   */* const  */)"ar.bsp",      (char const   */* const  */)"ar.bspstore",      (char const   */* const  */)"ar.rnat",      (char const   */* const  */)"ar.unat", 
        (char const   */* const  */)"ar.fpsr",      (char const   */* const  */)"ar.pfs",      (char const   */* const  */)"ar.lc",      (char const   */* const  */)"Unknown11", 
        (char const   */* const  */)"Unknown12",      (char const   */* const  */)"Unknown13",      (char const   */* const  */)"Unknown14",      (char const   */* const  */)"Unknown15"};
#line 115 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static void unw_print_abreg(char *cp , unsigned int abreg ) 
{ 


  {
  {
#line 127
  if (((abreg >> 5) & 3U) == 0U) {
#line 127
    goto case_0;
  }
#line 131
  if (((abreg >> 5) & 3U) == 1U) {
#line 131
    goto case_1;
  }
#line 135
  if (((abreg >> 5) & 3U) == 2U) {
#line 135
    goto case_2;
  }
#line 139
  if (((abreg >> 5) & 3U) == 3U) {
#line 139
    goto case_3;
  }
#line 125
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 128
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"r%u", abreg & 31U);
  }
#line 129
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 132
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"f%u", abreg & 31U);
  }
#line 133
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 136
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"b%u", abreg & 31U);
  }
#line 137
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 140
  strcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)special_reg[abreg & 15U]);
  }
#line 141
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static void unw_print_xyreg(char *cp , unsigned int x , unsigned int ytreg ) 
{ 


  {
  {
#line 150
  if (((x << 1) | ((ytreg >> 7) & 1U)) == 0U) {
#line 150
    goto case_0;
  }
#line 154
  if (((x << 1) | ((ytreg >> 7) & 1U)) == 1U) {
#line 154
    goto case_1;
  }
#line 158
  if (((x << 1) | ((ytreg >> 7) & 1U)) == 2U) {
#line 158
    goto case_2;
  }
#line 148
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 151
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"r%u", ytreg & 31U);
  }
#line 152
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 155
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"f%u", ytreg & 31U);
  }
#line 156
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 159
  sprintf((char */* __restrict  */)cp, (char const   */* __restrict  */)"b%u", ytreg & 31U);
  }
#line 160
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 537
static unw_word unw_decode_uleb128(unsigned char const   **dpp ) ;
#line 538
static unsigned char const   *unw_decode_x1(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 540
static unsigned char const   *unw_decode_x2(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 542
static unsigned char const   *unw_decode_x3(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 544
static unsigned char const   *unw_decode_x4(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 546
static unsigned char const   *unw_decode_r1(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) ;
#line 548
static unsigned char const   *unw_decode_r2(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) ;
#line 550
static unsigned char const   *unw_decode_r3(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) ;
#line 552
static unsigned char const   *unw_decode_p1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 554
static unsigned char const   *unw_decode_p2_p5(unsigned char const   *dp , unsigned int code ,
                                               void *arg  __attribute__((__unused__)) ) ;
#line 556
static unsigned char const   *unw_decode_p6(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 558
static unsigned char const   *unw_decode_p7_p10(unsigned char const   *dp , unsigned int code ,
                                                void *arg ) ;
#line 560
static unsigned char const   *unw_decode_b1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 562
static unsigned char const   *unw_decode_b2(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) ;
#line 564
static unsigned char const   *unw_decode_b3_x4(unsigned char const   *dp , unsigned int code ,
                                               void *arg ) ;
#line 567 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unw_word unw_decode_uleb128(unsigned char const   **dpp ) 
{ 
  unsigned int shift ;
  unw_word byte ;
  unw_word result ;
  unsigned char const   *bp ;
  unsigned char const   *tmp___0 ;

  {
#line 570
  shift = 0U;
#line 571
  result = (unw_word )0;
#line 572
  bp = *dpp;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    tmp___0 = bp;
#line 576
    bp ++;
#line 576
    byte = (unw_word )*tmp___0;
#line 577
    result |= (byte & 127UL) << shift;
#line 579
    if ((byte & 128UL) == 0UL) {
#line 580
      goto while_break;
    }
#line 582
    shift += 7U;
  }
  while_break: /* CIL Label */ ;
  }
#line 585
  *dpp = bp;
#line 587
  return (result);
}
}
#line 590 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x1(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char abreg ;
  unw_word t ;
  unw_word off ;
  unsigned char const   *tmp___0 ;
  char regname___0[20] ;
  char regname___1[20] ;

  {
  {
#line 597
  tmp___0 = dp;
#line 597
  dp ++;
#line 597
  byte1 = (unsigned char )*tmp___0;
#line 598
  t = unw_decode_uleb128(& dp);
#line 599
  off = unw_decode_uleb128(& dp);
#line 600
  abreg = (unsigned char )((int )byte1 & 127);
  }
#line 601
  if ((int )byte1 & 128) {
    {
#line 602
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 602
      unw_print_abreg(regname___0, (unsigned int )abreg);
#line 602
      printf((char const   */* __restrict  */)"\t%s:spill_sprel(reg=%s,t=%lu,spoff=0x%lx)\n",
             "X1", regname___0, t, 4UL * off);
      }
#line 602
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 604
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 604
      unw_print_abreg(regname___1, (unsigned int )abreg);
#line 604
      printf((char const   */* __restrict  */)"\t%s:spill_psprel(reg=%s,t=%lu,pspoff=0x10-0x%lx)\n",
             "X1", regname___1, t, 4UL * off);
      }
#line 604
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 605
  return (dp);
}
}
#line 608 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x2(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char byte2 ;
  unsigned char abreg ;
  unsigned char x ;
  unsigned char ytreg ;
  unw_word t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  char regname___0[20] ;
  char abregname[20] ;
  char tregname[20] ;

  {
  {
#line 615
  tmp___0 = dp;
#line 615
  dp ++;
#line 615
  byte1 = (unsigned char )*tmp___0;
#line 616
  tmp___1 = dp;
#line 616
  dp ++;
#line 616
  byte2 = (unsigned char )*tmp___1;
#line 617
  t = unw_decode_uleb128(& dp);
#line 618
  abreg = (unsigned char )((int )byte1 & 127);
#line 619
  ytreg = byte2;
#line 620
  x = (unsigned char )(((int )byte1 >> 7) & 1);
  }
#line 621
  if (((int )byte1 & 128) == 0) {
#line 621
    if ((int )ytreg == 0) {
      {
#line 622
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 622
        unw_print_abreg(regname___0, (unsigned int )abreg);
#line 622
        printf((char const   */* __restrict  */)"\t%s:restore(t=%lu,reg=%s)\n", "X2",
               t, regname___0);
        }
#line 622
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 621
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 624
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 624
      unw_print_abreg(abregname, (unsigned int )abreg);
#line 624
      unw_print_xyreg(tregname, (unsigned int )x, (unsigned int )ytreg);
#line 624
      printf((char const   */* __restrict  */)"\t%s:spill_reg(t=%lu,reg=%s,treg=%s)\n",
             "X2", t, abregname, tregname);
      }
#line 624
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 625
  return (dp);
}
}
#line 628 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x3(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char byte2 ;
  unsigned char abreg ;
  unsigned char qp ;
  unw_word t ;
  unw_word off ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  char regname___0[20] ;
  char regname___1[20] ;

  {
  {
#line 635
  tmp___0 = dp;
#line 635
  dp ++;
#line 635
  byte1 = (unsigned char )*tmp___0;
#line 636
  tmp___1 = dp;
#line 636
  dp ++;
#line 636
  byte2 = (unsigned char )*tmp___1;
#line 637
  t = unw_decode_uleb128(& dp);
#line 638
  off = unw_decode_uleb128(& dp);
#line 640
  qp = (unsigned char )((int )byte1 & 63);
#line 641
  abreg = (unsigned char )((int )byte2 & 127);
  }
#line 643
  if ((int )byte1 & 128) {
    {
#line 644
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 644
      unw_print_abreg(regname___0, (unsigned int )abreg);
#line 644
      printf((char const   */* __restrict  */)"\t%s:spill_sprel_p(qp=p%u,t=%lu,reg=%s,spoff=0x%lx)\n",
             "X3", (int )qp, t, regname___0, 4UL * off);
      }
#line 644
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 646
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 646
      unw_print_abreg(regname___1, (unsigned int )abreg);
#line 646
      printf((char const   */* __restrict  */)"\t%s:spill_psprel_p(qp=p%u,t=%lu,reg=%s,pspoff=0x10-0x%lx)\n",
             "X3", (int )qp, t, regname___1, 4UL * off);
      }
#line 646
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 647
  return (dp);
}
}
#line 650 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_x4(unsigned char const   *dp , unsigned int code  __attribute__((__unused__)) ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char byte2 ;
  unsigned char byte3 ;
  unsigned char qp ;
  unsigned char abreg ;
  unsigned char x ;
  unsigned char ytreg ;
  unw_word t ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  char regname___0[20] ;
  char regname___1[20] ;
  char tregname[20] ;

  {
  {
#line 657
  tmp___0 = dp;
#line 657
  dp ++;
#line 657
  byte1 = (unsigned char )*tmp___0;
#line 658
  tmp___1 = dp;
#line 658
  dp ++;
#line 658
  byte2 = (unsigned char )*tmp___1;
#line 659
  tmp___2 = dp;
#line 659
  dp ++;
#line 659
  byte3 = (unsigned char )*tmp___2;
#line 660
  t = unw_decode_uleb128(& dp);
#line 662
  qp = (unsigned char )((int )byte1 & 63);
#line 663
  abreg = (unsigned char )((int )byte2 & 127);
#line 664
  x = (unsigned char )(((int )byte2 >> 7) & 1);
#line 665
  ytreg = byte3;
  }
#line 667
  if (((int )byte2 & 128) == 0) {
#line 667
    if ((int )byte3 == 0) {
      {
#line 668
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 668
        unw_print_abreg(regname___0, (unsigned int )abreg);
#line 668
        printf((char const   */* __restrict  */)"\t%s:restore_p(qp=p%u,t=%lu,reg=%s)\n",
               "X4", (int )qp, t, regname___0);
        }
#line 668
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 667
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 670
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 670
      unw_print_abreg(regname___1, (unsigned int )abreg);
#line 670
      unw_print_xyreg(tregname, (unsigned int )x, (unsigned int )ytreg);
#line 670
      printf((char const   */* __restrict  */)"\t%s:spill_reg_p(qp=p%u,t=%lu,reg=%s,treg=%s)\n",
             "X4", (int )qp, t, regname___1, tregname);
      }
#line 670
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 671
  return (dp);
}
}
#line 674 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_r1(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) 
{ 
  int body ;
  unw_word rlen ;
  char const   *tmp___0 ;

  {
#line 677
  body = (code & 32U) != 0U;
#line 680
  rlen = (unw_word )(code & 31U);
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 681
    unw_rlen = rlen;
#line 681
    *((int *)arg) = body;
#line 681
    if (body) {
#line 681
      tmp___0 = "body";
    } else {
#line 681
      tmp___0 = "prologue";
    }
    {
#line 681
    printf((char const   */* __restrict  */)"    %s:%s(rlen=%lu)\n", "R1", tmp___0,
           rlen);
    }
#line 681
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (dp);
}
}
#line 685 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_r2(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) 
{ 
  unsigned char byte1 ;
  unsigned char mask ;
  unsigned char grsave ;
  unw_word rlen ;
  unsigned char const   *tmp___0 ;
  char regname___0[16] ;
  char maskstr[64] ;
  char *sep ;

  {
  {
#line 691
  tmp___0 = dp;
#line 691
  dp ++;
#line 691
  byte1 = (unsigned char )*tmp___0;
#line 693
  mask = (unsigned char )(((code & 7U) << 1) | (unsigned int )(((int )byte1 >> 7) & 1));
#line 694
  grsave = (unsigned char )((int )byte1 & 127);
#line 695
  rlen = unw_decode_uleb128(& dp);
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    unw_rlen = rlen;
#line 696
    *((int *)arg) = 0;
#line 696
    maskstr[0] = (char )'\000';
#line 696
    sep = (char *)"";
#line 696
    if ((int )mask & 8) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"rp");
#line 696
      sep = (char *)",";
      }
    }
#line 696
    if ((int )mask & 4) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)sep);
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"ar.pfs");
#line 696
      sep = (char *)",";
      }
    }
#line 696
    if ((int )mask & 2) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)sep);
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"psp");
#line 696
      sep = (char *)",";
      }
    }
#line 696
    if ((int )mask & 1) {
      {
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)sep);
#line 696
      strcat((char */* __restrict  */)(maskstr), (char const   */* __restrict  */)"pr");
      }
    }
    {
#line 696
    sprintf((char */* __restrict  */)(regname___0), (char const   */* __restrict  */)"r%u",
            (int )grsave);
#line 696
    printf((char const   */* __restrict  */)"    %s:prologue_gr(mask=[%s],grsave=%s,rlen=%lu)\n",
           "R2", maskstr, regname___0, rlen);
    }
#line 696
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 697
  return (dp);
}
}
#line 700 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_r3(unsigned char const   *dp , unsigned int code ,
                                            void *arg ) 
{ 
  unw_word rlen ;
  char const   *tmp___0 ;

  {
  {
#line 705
  rlen = unw_decode_uleb128(& dp);
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    unw_rlen = rlen;
#line 706
    *((int *)arg) = (code & 3U) == 1U;
#line 706
    if ((code & 3U) == 1U) {
#line 706
      tmp___0 = "body";
    } else {
#line 706
      tmp___0 = "prologue";
    }
    {
#line 706
    printf((char const   */* __restrict  */)"    %s:%s(rlen=%lu)\n", "R3", tmp___0,
           rlen);
    }
#line 706
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  return (dp);
}
}
#line 710 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char brmask ;
  char brstr[20] ;

  {
#line 714
  brmask = (unsigned char )(code & 31U);
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 716
    unw_print_brmask(brstr, (unsigned int )brmask);
#line 716
    printf((char const   */* __restrict  */)"\t%s:br_mem(brmask=[%s])\n", "P1", brstr);
    }
#line 716
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 717
  return (dp);
}
}
#line 781 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static char const   *spill_type  =    "-frb";
#line 720 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p2_p5(unsigned char const   *dp , unsigned int code ,
                                               void *arg  __attribute__((__unused__)) ) 
{ 
  unsigned char byte1 ;
  unsigned char const   *tmp___0 ;
  char brstr[20] ;
  unsigned char byte1___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char r ;
  unsigned char dst ;
  unsigned char const   *imaskp ;
  unsigned char mask ;
  bfd_vma insn ;
  unsigned char const   *tmp___2 ;
  unw_word grmask ;
  unw_word frmask ;
  unw_word byte1___1 ;
  unw_word byte2 ;
  unw_word byte3 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char const   *tmp___5 ;
  char frstr[200] ;
  char grstr[20] ;

  {
#line 724
  if ((code & 16U) == 0U) {
#line 726
    tmp___0 = dp;
#line 726
    dp ++;
#line 726
    byte1 = (unsigned char )*tmp___0;
    {
#line 728
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 728
      unw_print_brmask(brstr, ((code & 15U) << 1) | (unsigned int )(((int )byte1 >> 7) & 1));
#line 728
      printf((char const   */* __restrict  */)"\t%s:br_gr(brmask=[%s],gr=r%u)\n",
             "P2", brstr, (int )byte1 & 127);
      }
#line 728
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 731
  if ((code & 8U) == 0U) {
#line 733
    tmp___1 = dp;
#line 733
    dp ++;
#line 733
    byte1___0 = (unsigned char )*tmp___1;
#line 735
    r = (unsigned char )(((code & 7U) << 1) | (unsigned int )(((int )byte1___0 >> 7) & 1));
#line 736
    dst = (unsigned char )((int )byte1___0 & 127);
    {
#line 739
    if ((int )r == 0) {
#line 739
      goto case_0;
    }
#line 742
    if ((int )r == 1) {
#line 742
      goto case_1;
    }
#line 745
    if ((int )r == 2) {
#line 745
      goto case_2;
    }
#line 748
    if ((int )r == 3) {
#line 748
      goto case_3;
    }
#line 751
    if ((int )r == 4) {
#line 751
      goto case_4;
    }
#line 754
    if ((int )r == 5) {
#line 754
      goto case_5;
    }
#line 757
    if ((int )r == 6) {
#line 757
      goto case_6;
    }
#line 760
    if ((int )r == 7) {
#line 760
      goto case_7;
    }
#line 763
    if ((int )r == 8) {
#line 763
      goto case_8;
    }
#line 766
    if ((int )r == 9) {
#line 766
      goto case_9;
    }
#line 769
    if ((int )r == 10) {
#line 769
      goto case_10;
    }
#line 772
    if ((int )r == 11) {
#line 772
      goto case_11;
    }
#line 775
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 740
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "psp",
           (int )dst);
    }
#line 741
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 743
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "rp", (int )dst);
    }
#line 744
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 746
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "pfs",
           (int )dst);
    }
#line 747
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 749
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "pr", (int )dst);
    }
#line 750
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 752
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "unat",
           (int )dst);
    }
#line 753
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 755
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "lc", (int )dst);
    }
#line 756
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 758
    printf((char const   */* __restrict  */)"\t%s:rp_br(reg=b%u)\n", "P3", (int )dst);
    }
#line 759
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 761
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "rnat",
           (int )dst);
    }
#line 762
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 764
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "bsp",
           (int )dst);
    }
#line 765
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 767
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "bspstore",
           (int )dst);
    }
#line 768
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 770
    printf((char const   */* __restrict  */)"\t%s:%s_gr(reg=r%u)\n", "P3", "fpsr",
           (int )dst);
    }
#line 771
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 773
    printf((char const   */* __restrict  */)"\t%s:priunat_gr(reg=r%u)\n", "P3", (int )dst);
    }
#line 774
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 776
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", (int )r);
    }
#line 777
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 780
  if ((code & 7U) == 0U) {
    {
#line 781
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 781
      imaskp = dp;
#line 781
      mask = (unsigned char)0;
#line 781
      insn = (bfd_vma )0;
#line 781
      printf((char const   */* __restrict  */)"\t%s:spill_mask(imask=[", "P4");
#line 781
      insn = (bfd_vma )0;
      }
      {
#line 781
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 781
        if (! (insn < unw_rlen)) {
#line 781
          goto while_break___1;
        }
#line 781
        if (insn % 4UL == 0UL) {
#line 781
          tmp___2 = imaskp;
#line 781
          imaskp ++;
#line 781
          mask = (unsigned char )*tmp___2;
        }
#line 781
        if (insn > 0UL) {
#line 781
          if (insn % 3UL == 0UL) {
            {
#line 781
            putchar(',');
            }
          }
        }
        {
#line 781
        putchar((int )*(spill_type + (((int )mask >> 2UL * (3UL - (insn & 3UL))) & 3)));
#line 781
        insn ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 781
      printf((char const   */* __restrict  */)"])\n");
#line 781
      dp = imaskp;
      }
#line 781
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 782
  if ((code & 7U) == 1U) {
#line 786
    tmp___3 = dp;
#line 786
    dp ++;
#line 786
    byte1___1 = (unw_word )*tmp___3;
#line 787
    tmp___4 = dp;
#line 787
    dp ++;
#line 787
    byte2 = (unw_word )*tmp___4;
#line 788
    tmp___5 = dp;
#line 788
    dp ++;
#line 788
    byte3 = (unw_word )*tmp___5;
#line 789
    grmask = (byte1___1 >> 4) & 15UL;
#line 790
    frmask = (((byte1___1 & 15UL) << 16) | (byte2 << 8)) | byte3;
    {
#line 791
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 791
      unw_print_grmask(grstr, (unsigned int )grmask);
#line 791
      unw_print_frmask(frstr, (unsigned int )frmask);
#line 791
      printf((char const   */* __restrict  */)"\t%s:frgr_mem(grmask=[%s],frmask=[%s])\n",
             "P5", grstr, frstr);
      }
#line 791
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 794
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", code);
    }
  }
#line 796
  return (dp);
}
}
#line 799 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p6(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  int gregs ;
  unsigned char mask ;
  char grstr[200] ;
  char frstr[200] ;

  {
#line 803
  gregs = (code & 16U) != 0U;
#line 804
  mask = (unsigned char )(code & 15U);
#line 806
  if (gregs) {
    {
#line 807
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 807
      unw_print_grmask(grstr, (unsigned int )mask);
#line 807
      printf((char const   */* __restrict  */)"\t%s:gr_mem(grmask=[%s])\n", "P6",
             grstr);
      }
#line 807
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 809
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 809
      unw_print_frmask(frstr, (unsigned int )mask);
#line 809
      printf((char const   */* __restrict  */)"\t%s:fr_mem(frmask=[%s])\n", "P6",
             frstr);
      }
#line 809
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 810
  return (dp);
}
}
#line 963 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static char const   * const  abiname[3]  = {      (char const   */* const  */)"@svr4",      (char const   */* const  */)"@hpux",      (char const   */* const  */)"@nt"};
#line 813 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_p7_p10(unsigned char const   *dp , unsigned int code ,
                                                void *arg ) 
{ 
  unsigned char r ;
  unsigned char byte1 ;
  unsigned char byte2 ;
  unw_word t ;
  unw_word size ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  char grstr[20] ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  char buf___4[20] ;
  char const   *abistr ;
  unsigned char const   *tmp___5 ;
  unsigned char const   *tmp___6 ;
  unsigned char const   *tmp___7 ;
  unsigned char const   *tmp___8 ;

  {
#line 819
  if ((code & 16U) == 0U) {
    {
#line 821
    r = (unsigned char )(code & 15U);
#line 822
    t = unw_decode_uleb128(& dp);
    }
    {
#line 825
    if ((int )r == 0) {
#line 825
      goto case_0;
    }
#line 830
    if ((int )r == 1) {
#line 830
      goto case_1;
    }
#line 833
    if ((int )r == 2) {
#line 833
      goto case_2;
    }
#line 836
    if ((int )r == 3) {
#line 836
      goto case_3;
    }
#line 839
    if ((int )r == 4) {
#line 839
      goto case_4;
    }
#line 842
    if ((int )r == 5) {
#line 842
      goto case_5;
    }
#line 845
    if ((int )r == 6) {
#line 845
      goto case_6;
    }
#line 848
    if ((int )r == 7) {
#line 848
      goto case_7;
    }
#line 851
    if ((int )r == 8) {
#line 851
      goto case_8;
    }
#line 854
    if ((int )r == 9) {
#line 854
      goto case_9;
    }
#line 857
    if ((int )r == 10) {
#line 857
      goto case_10;
    }
#line 860
    if ((int )r == 11) {
#line 860
      goto case_11;
    }
#line 863
    if ((int )r == 12) {
#line 863
      goto case_12;
    }
#line 866
    if ((int )r == 13) {
#line 866
      goto case_13;
    }
#line 869
    if ((int )r == 14) {
#line 869
      goto case_14;
    }
#line 872
    if ((int )r == 15) {
#line 872
      goto case_15;
    }
#line 875
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 826
    size = unw_decode_uleb128(& dp);
#line 827
    printf((char const   */* __restrict  */)"\t%s:mem_stack_f(t=%lu,size=%lu)\n",
           "P7", t, 16UL * size);
    }
#line 828
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 831
    printf((char const   */* __restrict  */)"\t%s:mem_stack_v(t=%lu)\n", "P7", t);
    }
#line 832
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 834
    printf((char const   */* __restrict  */)"\t%s:spill_base(pspoff=0x10-0x%lx)\n",
           "P7", 4UL * t);
    }
#line 835
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 837
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P7",
           "psp", 4UL * t);
    }
#line 838
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 840
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "rp", t);
    }
#line 841
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 843
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "rp", 4UL * t);
    }
#line 844
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 846
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "pfs",
           t);
    }
#line 847
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 849
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "pfs", 4UL * t);
    }
#line 850
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 852
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "pr", t);
    }
#line 853
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 855
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "pr", 4UL * t);
    }
#line 856
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 858
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "lc", t);
    }
#line 859
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 861
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "lc", 4UL * t);
    }
#line 862
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 864
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "unat",
           t);
    }
#line 865
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 867
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "unat", 4UL * t);
    }
#line 868
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 870
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P7", "fpsr",
           t);
    }
#line 871
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 873
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P7", "fpsr", 4UL * t);
    }
#line 874
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 876
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", (int )r);
    }
#line 877
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 884
    if ((code & 15U) == 0U) {
#line 884
      goto case_0___0;
    }
#line 954
    if ((code & 15U) == 1U) {
#line 954
      goto case_1___1;
    }
#line 960
    if ((code & 15U) == 15U) {
#line 960
      goto case_15___1;
    }
#line 966
    if ((code & 15U) == 9U) {
#line 966
      goto case_9___1;
    }
#line 969
    if ((code & 15U) == 10U) {
#line 969
      goto case_10___1;
    }
#line 972
    if ((code & 15U) == 11U) {
#line 972
      goto case_11___1;
    }
#line 975
    if ((code & 15U) == 12U) {
#line 975
      goto case_12___1;
    }
#line 978
    goto switch_default___1;
    case_0___0: /* CIL Label */ 
    {
#line 886
    tmp___0 = dp;
#line 886
    dp ++;
#line 886
    r = (unsigned char )*tmp___0;
#line 887
    t = unw_decode_uleb128(& dp);
    }
    {
#line 890
    if ((int )r == 1) {
#line 890
      goto case_1___0;
    }
#line 893
    if ((int )r == 2) {
#line 893
      goto case_2___0;
    }
#line 896
    if ((int )r == 3) {
#line 896
      goto case_3___0;
    }
#line 899
    if ((int )r == 4) {
#line 899
      goto case_4___0;
    }
#line 902
    if ((int )r == 5) {
#line 902
      goto case_5___0;
    }
#line 905
    if ((int )r == 6) {
#line 905
      goto case_6___0;
    }
#line 908
    if ((int )r == 7) {
#line 908
      goto case_7___0;
    }
#line 911
    if ((int )r == 8) {
#line 911
      goto case_8___0;
    }
#line 914
    if ((int )r == 9) {
#line 914
      goto case_9___0;
    }
#line 917
    if ((int )r == 10) {
#line 917
      goto case_10___0;
    }
#line 920
    if ((int )r == 11) {
#line 920
      goto case_11___0;
    }
#line 923
    if ((int )r == 12) {
#line 923
      goto case_12___0;
    }
#line 926
    if ((int )r == 13) {
#line 926
      goto case_13___0;
    }
#line 929
    if ((int )r == 14) {
#line 929
      goto case_14___0;
    }
#line 932
    if ((int )r == 15) {
#line 932
      goto case_15___0;
    }
#line 935
    if ((int )r == 16) {
#line 935
      goto case_16;
    }
#line 938
    if ((int )r == 17) {
#line 938
      goto case_17;
    }
#line 941
    if ((int )r == 18) {
#line 941
      goto case_18;
    }
#line 944
    if ((int )r == 19) {
#line 944
      goto case_19;
    }
#line 947
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 891
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "rp", 4UL * t);
    }
#line 892
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
#line 894
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "pfs", 4UL * t);
    }
#line 895
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    {
#line 897
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "pr", 4UL * t);
    }
#line 898
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
#line 900
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "lc", 4UL * t);
    }
#line 901
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
    {
#line 903
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "unat", 4UL * t);
    }
#line 904
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
    {
#line 906
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "fpsr", 4UL * t);
    }
#line 907
    goto switch_break___1;
    case_7___0: /* CIL Label */ 
    {
#line 909
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P8", "bsp",
           t);
    }
#line 910
    goto switch_break___1;
    case_8___0: /* CIL Label */ 
    {
#line 912
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P8", "bsp", 4UL * t);
    }
#line 913
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
    {
#line 915
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "bsp", 4UL * t);
    }
#line 916
    goto switch_break___1;
    case_10___0: /* CIL Label */ 
    {
#line 918
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P8", "bspstore",
           t);
    }
#line 919
    goto switch_break___1;
    case_11___0: /* CIL Label */ 
    {
#line 921
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P8", "bspstore", 4UL * t);
    }
#line 922
    goto switch_break___1;
    case_12___0: /* CIL Label */ 
    {
#line 924
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "bspstore", 4UL * t);
    }
#line 925
    goto switch_break___1;
    case_13___0: /* CIL Label */ 
    {
#line 927
    printf((char const   */* __restrict  */)"\t%s:%s_when(t=%lu)\n", "P8", "rnat",
           t);
    }
#line 928
    goto switch_break___1;
    case_14___0: /* CIL Label */ 
    {
#line 930
    printf((char const   */* __restrict  */)"\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",
           "P8", "rnat", 4UL * t);
    }
#line 931
    goto switch_break___1;
    case_15___0: /* CIL Label */ 
    {
#line 933
    printf((char const   */* __restrict  */)"\t%s:%s_sprel(spoff=0x%lx)\n", "P8",
           "rnat", 4UL * t);
    }
#line 934
    goto switch_break___1;
    case_16: /* CIL Label */ 
    {
#line 936
    printf((char const   */* __restrict  */)"\t%s:priunat_when_gr(t=%lu)\n", "P8",
           t);
    }
#line 937
    goto switch_break___1;
    case_17: /* CIL Label */ 
    {
#line 939
    printf((char const   */* __restrict  */)"\t%s:priunat_psprel(pspoff=0x10-0x%lx)\n",
           "P8", 4UL * t);
    }
#line 940
    goto switch_break___1;
    case_18: /* CIL Label */ 
    {
#line 942
    printf((char const   */* __restrict  */)"\t%s:priunat_sprel(spoff=0x%lx)\n", "P8",
           4UL * t);
    }
#line 943
    goto switch_break___1;
    case_19: /* CIL Label */ 
    {
#line 945
    printf((char const   */* __restrict  */)"\t%s:priunat_when_mem(t=%lu)\n", "P8",
           t);
    }
#line 946
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 948
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", (int )r);
    }
#line 949
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 952
    goto switch_break___0;
    case_1___1: /* CIL Label */ 
#line 955
    tmp___1 = dp;
#line 955
    dp ++;
#line 955
    byte1 = (unsigned char )*tmp___1;
#line 956
    tmp___2 = dp;
#line 956
    dp ++;
#line 956
    byte2 = (unsigned char )*tmp___2;
    {
#line 957
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 957
      unw_print_grmask(grstr, (unsigned int )((int )byte1 & 15));
#line 957
      printf((char const   */* __restrict  */)"\t%s:gr_gr(grmask=[%s],r%u)\n", "P9",
             grstr, (int )byte2 & 127);
      }
#line 957
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 958
    goto switch_break___0;
    case_15___1: /* CIL Label */ 
#line 961
    tmp___3 = dp;
#line 961
    dp ++;
#line 961
    byte1 = (unsigned char )*tmp___3;
#line 962
    tmp___4 = dp;
#line 962
    dp ++;
#line 962
    byte2 = (unsigned char )*tmp___4;
    {
#line 963
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 963
      abistr = (char const   *)(buf___4);
#line 963
      if ((int )byte1 < 3) {
#line 963
        abistr = (char const   *)abiname[byte1];
      } else {
        {
#line 963
        sprintf((char */* __restrict  */)(buf___4), (char const   */* __restrict  */)"0x%x",
                (int )byte1);
        }
      }
      {
#line 963
      printf((char const   */* __restrict  */)"\t%s:unwabi(abi=%s,context=0x%02x)\n",
             "P10", abistr, (int )byte2);
      }
#line 963
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 964
    goto switch_break___0;
    case_9___1: /* CIL Label */ 
    {
#line 967
    tmp___5 = unw_decode_x1(dp, code, arg);
    }
#line 967
    return (tmp___5);
    case_10___1: /* CIL Label */ 
    {
#line 970
    tmp___6 = unw_decode_x2(dp, code, arg);
    }
#line 970
    return (tmp___6);
    case_11___1: /* CIL Label */ 
    {
#line 973
    tmp___7 = unw_decode_x3(dp, code, arg);
    }
#line 973
    return (tmp___7);
    case_12___1: /* CIL Label */ 
    {
#line 976
    tmp___8 = unw_decode_x4(dp, code, arg);
    }
#line 976
    return (tmp___8);
    switch_default___1: /* CIL Label */ 
    {
#line 979
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", code);
    }
#line 980
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 983
  return (dp);
}
}
#line 986 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_b1(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unw_word label ;

  {
#line 990
  label = (unw_word )(code & 31U);
#line 992
  if ((code & 32U) != 0U) {
    {
#line 993
    printf((char const   */* __restrict  */)"\t%s:copy_state(label=%lu)\n", "B1",
           label);
    }
  } else {
    {
#line 995
    printf((char const   */* __restrict  */)"\t%s:label_state(label=%lu)\n", "B1",
           label);
    }
  }
#line 996
  return (dp);
}
}
#line 999 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_b2(unsigned char const   *dp , unsigned int code ,
                                            void *arg  __attribute__((__unused__)) ) 
{ 
  unw_word t ;

  {
  {
#line 1005
  t = unw_decode_uleb128(& dp);
#line 1006
  printf((char const   */* __restrict  */)"\t%s:epilogue(t=%lu,ecount=%lu)\n", "B2",
         t, (unsigned long )(code & 31U));
  }
#line 1007
  return (dp);
}
}
#line 1010 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unsigned char const   *unw_decode_b3_x4(unsigned char const   *dp , unsigned int code ,
                                               void *arg ) 
{ 
  unw_word t ;
  unw_word ecount ;
  unw_word label ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;

  {
#line 1015
  if ((code & 16U) == 0U) {
    {
#line 1017
    t = unw_decode_uleb128(& dp);
#line 1018
    ecount = unw_decode_uleb128(& dp);
#line 1019
    printf((char const   */* __restrict  */)"\t%s:epilogue(t=%lu,ecount=%lu)\n", "B3",
           t, ecount);
    }
  } else
#line 1021
  if ((code & 7U) == 0U) {
    {
#line 1023
    label = unw_decode_uleb128(& dp);
    }
#line 1024
    if ((code & 8U) != 0U) {
      {
#line 1025
      printf((char const   */* __restrict  */)"\t%s:copy_state(label=%lu)\n", "B4",
             label);
      }
    } else {
      {
#line 1027
      printf((char const   */* __restrict  */)"\t%s:label_state(label=%lu)\n", "B4",
             label);
      }
    }
  } else {
    {
#line 1032
    if ((code & 7U) == 1U) {
#line 1032
      goto case_1;
    }
#line 1034
    if ((code & 7U) == 2U) {
#line 1034
      goto case_2;
    }
#line 1036
    if ((code & 7U) == 3U) {
#line 1036
      goto case_3;
    }
#line 1038
    if ((code & 7U) == 4U) {
#line 1038
      goto case_4;
    }
#line 1040
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 1033
    tmp___0 = unw_decode_x1(dp, code, arg);
    }
#line 1033
    return (tmp___0);
    case_2: /* CIL Label */ 
    {
#line 1035
    tmp___1 = unw_decode_x2(dp, code, arg);
    }
#line 1035
    return (tmp___1);
    case_3: /* CIL Label */ 
    {
#line 1037
    tmp___2 = unw_decode_x3(dp, code, arg);
    }
#line 1037
    return (tmp___2);
    case_4: /* CIL Label */ 
    {
#line 1039
    tmp___3 = unw_decode_x4(dp, code, arg);
    }
#line 1039
    return (tmp___3);
    switch_default: /* CIL Label */ 
    {
#line 1041
    printf((char const   */* __restrict  */)"Unknown code 0x%02x\n", code);
    }
#line 1042
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1044
  return (dp);
}
}
#line 1050 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
static unw_decoder const   unw_decode_table[2][8]  = { {        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r2),        (unw_decoder const   )(& unw_decode_r3), 
            (unw_decoder const   )(& unw_decode_p1),        (unw_decoder const   )(& unw_decode_p2_p5),        (unw_decoder const   )(& unw_decode_p6),        (unw_decoder const   )(& unw_decode_p7_p10)}, 
   {        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r1),        (unw_decoder const   )(& unw_decode_r2),        (unw_decoder const   )(& unw_decode_r3), 
            (unw_decoder const   )(& unw_decode_b1),        (unw_decoder const   )(& unw_decode_b1),        (unw_decoder const   )(& unw_decode_b2),        (unw_decoder const   )(& unw_decode_b3_x4)}};
#line 1076 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/unwind-ia64.c"
unsigned char const   *unw_decode(unsigned char const   *dp , int inside_body , void *ptr_inside_body ) 
{ 
  unsigned char const   *(*decoder)(unsigned char const   * , unsigned int  , void * ) ;
  unsigned char code ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;

  {
  {
#line 1083
  tmp___0 = dp;
#line 1083
  dp ++;
#line 1083
  code = (unsigned char )*tmp___0;
#line 1084
  decoder = (unsigned char const   *(*)(unsigned char const   * , unsigned int  ,
                                        void * ))unw_decode_table[inside_body][(int )code >> 5];
#line 1085
  tmp___1 = (*decoder)(dp, (unsigned int )code, ptr_inside_body);
  }
#line 1085
  return (tmp___1);
}
}
#line 67 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/bucomm.h"
void print_version(char const   *name___0 ) ;
#line 30 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/version.c"
void print_version(char const   *name___0 ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 35
  printf((char const   */* __restrict  */)"GNU %s %s\n", name___0, "(GNU Binutils) 2.23.2");
#line 36
  tmp___0 = gettext("Copyright 2012 Free Software Foundation, Inc.\n");
#line 36
  printf((char const   */* __restrict  */)tmp___0);
#line 37
  tmp___1 = gettext("This program is free software; you may redistribute it under the terms of\nthe GNU General Public License version 3 or (at your option) any later version.\nThis program has absolutely no warranty.\n");
#line 37
  printf((char const   */* __restrict  */)tmp___1);
#line 41
  exit(0);
  }
}
}
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 377 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern int optind ;
#line 451 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 119 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 400 "/usr/include/zlib.h"
extern int inflate(z_streamp strm , int flush ) ;
#line 520
extern int inflateEnd(z_streamp strm ) ;
#line 957
extern int inflateReset(z_streamp strm ) ;
#line 1766
extern int inflateInit_(z_streamp strm , char const   *version , int stream_size ) ;
#line 296 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 41 "./../include/elf/aarch64.h"
static char const   *elf_aarch64_reloc_type(unsigned long rtype ) ;
#line 41 "./../include/elf/aarch64.h"
static char const   *elf_aarch64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 44
  if (rtype == 0UL) {
#line 44
    goto case_0;
  }
#line 48
  if (rtype == 256UL) {
#line 48
    goto case_256;
  }
#line 53
  if (rtype == 257UL) {
#line 53
    goto case_257;
  }
#line 56
  if (rtype == 258UL) {
#line 56
    goto case_258;
  }
#line 59
  if (rtype == 259UL) {
#line 59
    goto case_259;
  }
#line 62
  if (rtype == 260UL) {
#line 62
    goto case_260;
  }
#line 65
  if (rtype == 261UL) {
#line 65
    goto case_261;
  }
#line 68
  if (rtype == 262UL) {
#line 68
    goto case_262;
  }
#line 74
  if (rtype == 263UL) {
#line 74
    goto case_263;
  }
#line 77
  if (rtype == 264UL) {
#line 77
    goto case_264;
  }
#line 80
  if (rtype == 265UL) {
#line 80
    goto case_265;
  }
#line 83
  if (rtype == 266UL) {
#line 83
    goto case_266;
  }
#line 86
  if (rtype == 267UL) {
#line 86
    goto case_267;
  }
#line 89
  if (rtype == 268UL) {
#line 89
    goto case_268;
  }
#line 92
  if (rtype == 269UL) {
#line 92
    goto case_269;
  }
#line 99
  if (rtype == 270UL) {
#line 99
    goto case_270;
  }
#line 102
  if (rtype == 271UL) {
#line 102
    goto case_271;
  }
#line 105
  if (rtype == 272UL) {
#line 105
    goto case_272;
  }
#line 111
  if (rtype == 273UL) {
#line 111
    goto case_273;
  }
#line 114
  if (rtype == 274UL) {
#line 114
    goto case_274;
  }
#line 117
  if (rtype == 275UL) {
#line 117
    goto case_275;
  }
#line 120
  if (rtype == 276UL) {
#line 120
    goto case_276;
  }
#line 123
  if (rtype == 277UL) {
#line 123
    goto case_277;
  }
#line 126
  if (rtype == 278UL) {
#line 126
    goto case_278;
  }
#line 131
  if (rtype == 279UL) {
#line 131
    goto case_279;
  }
#line 134
  if (rtype == 280UL) {
#line 134
    goto case_280;
  }
#line 139
  if (rtype == 282UL) {
#line 139
    goto case_282;
  }
#line 142
  if (rtype == 283UL) {
#line 142
    goto case_283;
  }
#line 145
  if (rtype == 284UL) {
#line 145
    goto case_284;
  }
#line 148
  if (rtype == 285UL) {
#line 148
    goto case_285;
  }
#line 151
  if (rtype == 286UL) {
#line 151
    goto case_286;
  }
#line 154
  if (rtype == 299UL) {
#line 154
    goto case_299;
  }
#line 156
  if (rtype == 311UL) {
#line 156
    goto case_311;
  }
#line 157
  if (rtype == 312UL) {
#line 157
    goto case_312;
  }
#line 162
  if (rtype == 513UL) {
#line 162
    goto case_513;
  }
#line 163
  if (rtype == 514UL) {
#line 163
    goto case_514;
  }
#line 164
  if (rtype == 539UL) {
#line 164
    goto case_539;
  }
#line 165
  if (rtype == 540UL) {
#line 165
    goto case_540;
  }
#line 166
  if (rtype == 541UL) {
#line 166
    goto case_541;
  }
#line 167
  if (rtype == 542UL) {
#line 167
    goto case_542;
  }
#line 168
  if (rtype == 543UL) {
#line 168
    goto case_543;
  }
#line 169
  if (rtype == 544UL) {
#line 169
    goto case_544;
  }
#line 170
  if (rtype == 545UL) {
#line 170
    goto case_545;
  }
#line 171
  if (rtype == 546UL) {
#line 171
    goto case_546;
  }
#line 172
  if (rtype == 547UL) {
#line 172
    goto case_547;
  }
#line 173
  if (rtype == 548UL) {
#line 173
    goto case_548;
  }
#line 174
  if (rtype == 549UL) {
#line 174
    goto case_549;
  }
#line 175
  if (rtype == 550UL) {
#line 175
    goto case_550;
  }
#line 176
  if (rtype == 551UL) {
#line 176
    goto case_551;
  }
#line 180
  if (rtype == 560UL) {
#line 180
    goto case_560;
  }
#line 181
  if (rtype == 561UL) {
#line 181
    goto case_561;
  }
#line 182
  if (rtype == 562UL) {
#line 182
    goto case_562;
  }
#line 183
  if (rtype == 563UL) {
#line 183
    goto case_563;
  }
#line 184
  if (rtype == 564UL) {
#line 184
    goto case_564;
  }
#line 185
  if (rtype == 565UL) {
#line 185
    goto case_565;
  }
#line 186
  if (rtype == 566UL) {
#line 186
    goto case_566;
  }
#line 187
  if (rtype == 567UL) {
#line 187
    goto case_567;
  }
#line 188
  if (rtype == 568UL) {
#line 188
    goto case_568;
  }
#line 189
  if (rtype == 569UL) {
#line 189
    goto case_569;
  }
#line 196
  if (rtype == 1024UL) {
#line 196
    goto case_1024;
  }
#line 199
  if (rtype == 1025UL) {
#line 199
    goto case_1025;
  }
#line 202
  if (rtype == 1026UL) {
#line 202
    goto case_1026;
  }
#line 205
  if (rtype == 1027UL) {
#line 205
    goto case_1027;
  }
#line 206
  if (rtype == 1028UL) {
#line 206
    goto case_1028;
  }
#line 207
  if (rtype == 1029UL) {
#line 207
    goto case_1029;
  }
#line 208
  if (rtype == 1030UL) {
#line 208
    goto case_1030;
  }
#line 209
  if (rtype == 1031UL) {
#line 209
    goto case_1031;
  }
#line 212
  goto switch_default;
  case_0: /* CIL Label */ 
#line 44
  return ("R_AARCH64_NONE");
  case_256: /* CIL Label */ 
#line 48
  return ("R_AARCH64_NULL");
  case_257: /* CIL Label */ 
#line 53
  return ("R_AARCH64_ABS64");
  case_258: /* CIL Label */ 
#line 56
  return ("R_AARCH64_ABS32");
  case_259: /* CIL Label */ 
#line 59
  return ("R_AARCH64_ABS16");
  case_260: /* CIL Label */ 
#line 62
  return ("R_AARCH64_PREL64");
  case_261: /* CIL Label */ 
#line 65
  return ("R_AARCH64_PREL32");
  case_262: /* CIL Label */ 
#line 68
  return ("R_AARCH64_PREL16");
  case_263: /* CIL Label */ 
#line 74
  return ("R_AARCH64_MOVW_UABS_G0");
  case_264: /* CIL Label */ 
#line 77
  return ("R_AARCH64_MOVW_UABS_G0_NC");
  case_265: /* CIL Label */ 
#line 80
  return ("R_AARCH64_MOVW_UABS_G1");
  case_266: /* CIL Label */ 
#line 83
  return ("R_AARCH64_MOVW_UABS_G1_NC");
  case_267: /* CIL Label */ 
#line 86
  return ("R_AARCH64_MOVW_UABS_G2");
  case_268: /* CIL Label */ 
#line 89
  return ("R_AARCH64_MOVW_UABS_G2_NC");
  case_269: /* CIL Label */ 
#line 92
  return ("R_AARCH64_MOVW_UABS_G3");
  case_270: /* CIL Label */ 
#line 99
  return ("R_AARCH64_MOVW_SABS_G0");
  case_271: /* CIL Label */ 
#line 102
  return ("R_AARCH64_MOVW_SABS_G1");
  case_272: /* CIL Label */ 
#line 105
  return ("R_AARCH64_MOVW_SABS_G2");
  case_273: /* CIL Label */ 
#line 111
  return ("R_AARCH64_LD_PREL_LO19");
  case_274: /* CIL Label */ 
#line 114
  return ("R_AARCH64_ADR_PREL_LO21");
  case_275: /* CIL Label */ 
#line 117
  return ("R_AARCH64_ADR_PREL_PG_HI21");
  case_276: /* CIL Label */ 
#line 120
  return ("R_AARCH64_ADR_PREL_PG_HI21_NC");
  case_277: /* CIL Label */ 
#line 123
  return ("R_AARCH64_ADD_ABS_LO12_NC");
  case_278: /* CIL Label */ 
#line 126
  return ("R_AARCH64_LDST8_ABS_LO12_NC");
  case_279: /* CIL Label */ 
#line 131
  return ("R_AARCH64_TSTBR14");
  case_280: /* CIL Label */ 
#line 134
  return ("R_AARCH64_CONDBR19");
  case_282: /* CIL Label */ 
#line 139
  return ("R_AARCH64_JUMP26");
  case_283: /* CIL Label */ 
#line 142
  return ("R_AARCH64_CALL26");
  case_284: /* CIL Label */ 
#line 145
  return ("R_AARCH64_LDST16_ABS_LO12_NC");
  case_285: /* CIL Label */ 
#line 148
  return ("R_AARCH64_LDST32_ABS_LO12_NC");
  case_286: /* CIL Label */ 
#line 151
  return ("R_AARCH64_LDST64_ABS_LO12_NC");
  case_299: /* CIL Label */ 
#line 154
  return ("R_AARCH64_LDST128_ABS_LO12_NC");
  case_311: /* CIL Label */ 
#line 156
  return ("R_AARCH64_ADR_GOT_PAGE");
  case_312: /* CIL Label */ 
#line 157
  return ("R_AARCH64_LD64_GOT_LO12_NC");
  case_513: /* CIL Label */ 
#line 162
  return ("R_AARCH64_TLSGD_ADR_PAGE21");
  case_514: /* CIL Label */ 
#line 163
  return ("R_AARCH64_TLSGD_ADD_LO12_NC");
  case_539: /* CIL Label */ 
#line 164
  return ("R_AARCH64_TLSIE_MOVW_GOTTPREL_G1");
  case_540: /* CIL Label */ 
#line 165
  return ("R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC");
  case_541: /* CIL Label */ 
#line 166
  return ("R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21");
  case_542: /* CIL Label */ 
#line 167
  return ("R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC");
  case_543: /* CIL Label */ 
#line 168
  return ("R_AARCH64_TLSIE_LD_GOTTPREL_PREL19");
  case_544: /* CIL Label */ 
#line 169
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G2");
  case_545: /* CIL Label */ 
#line 170
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G1");
  case_546: /* CIL Label */ 
#line 171
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G1_NC");
  case_547: /* CIL Label */ 
#line 172
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G0");
  case_548: /* CIL Label */ 
#line 173
  return ("R_AARCH64_TLSLE_MOVW_TPREL_G0_NC");
  case_549: /* CIL Label */ 
#line 174
  return ("R_AARCH64_TLSLE_ADD_TPREL_HI12");
  case_550: /* CIL Label */ 
#line 175
  return ("R_AARCH64_TLSLE_ADD_TPREL_LO12");
  case_551: /* CIL Label */ 
#line 176
  return ("R_AARCH64_TLSLE_ADD_TPREL_LO12_NC");
  case_560: /* CIL Label */ 
#line 180
  return ("R_AARCH64_TLSDESC_LD64_PREL19");
  case_561: /* CIL Label */ 
#line 181
  return ("R_AARCH64_TLSDESC_ADR_PREL21");
  case_562: /* CIL Label */ 
#line 182
  return ("R_AARCH64_TLSDESC_ADR_PAGE");
  case_563: /* CIL Label */ 
#line 183
  return ("R_AARCH64_TLSDESC_LD64_LO12_NC");
  case_564: /* CIL Label */ 
#line 184
  return ("R_AARCH64_TLSDESC_ADD_LO12_NC");
  case_565: /* CIL Label */ 
#line 185
  return ("R_AARCH64_TLSDESC_OFF_G1");
  case_566: /* CIL Label */ 
#line 186
  return ("R_AARCH64_TLSDESC_OFF_G0_NC");
  case_567: /* CIL Label */ 
#line 187
  return ("R_AARCH64_TLSDESC_LDR");
  case_568: /* CIL Label */ 
#line 188
  return ("R_AARCH64_TLSDESC_ADD");
  case_569: /* CIL Label */ 
#line 189
  return ("R_AARCH64_TLSDESC_CALL");
  case_1024: /* CIL Label */ 
#line 196
  return ("R_AARCH64_COPY");
  case_1025: /* CIL Label */ 
#line 199
  return ("R_AARCH64_GLOB_DAT");
  case_1026: /* CIL Label */ 
#line 202
  return ("R_AARCH64_JUMP_SLOT");
  case_1027: /* CIL Label */ 
#line 205
  return ("R_AARCH64_RELATIVE");
  case_1028: /* CIL Label */ 
#line 206
  return ("R_AARCH64_TLS_DTPMOD64");
  case_1029: /* CIL Label */ 
#line 207
  return ("R_AARCH64_TLS_DTPREL64");
  case_1030: /* CIL Label */ 
#line 208
  return ("R_AARCH64_TLS_TPREL64");
  case_1031: /* CIL Label */ 
#line 209
  return ("R_AARCH64_TLSDESC");
  switch_default: /* CIL Label */ 
#line 212
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 73 "./../include/elf/alpha.h"
static char const   *elf_alpha_reloc_type(unsigned long rtype ) ;
#line 73 "./../include/elf/alpha.h"
static char const   *elf_alpha_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 74
  if (rtype == 0UL) {
#line 74
    goto case_0;
  }
#line 75
  if (rtype == 1UL) {
#line 75
    goto case_1;
  }
#line 76
  if (rtype == 2UL) {
#line 76
    goto case_2;
  }
#line 77
  if (rtype == 3UL) {
#line 77
    goto case_3;
  }
#line 78
  if (rtype == 4UL) {
#line 78
    goto case_4;
  }
#line 79
  if (rtype == 5UL) {
#line 79
    goto case_5;
  }
#line 80
  if (rtype == 6UL) {
#line 80
    goto case_6;
  }
#line 81
  if (rtype == 7UL) {
#line 81
    goto case_7;
  }
#line 82
  if (rtype == 8UL) {
#line 82
    goto case_8;
  }
#line 83
  if (rtype == 9UL) {
#line 83
    goto case_9;
  }
#line 84
  if (rtype == 10UL) {
#line 84
    goto case_10;
  }
#line 85
  if (rtype == 11UL) {
#line 85
    goto case_11;
  }
#line 89
  if (rtype == 17UL) {
#line 89
    goto case_17;
  }
#line 90
  if (rtype == 18UL) {
#line 90
    goto case_18;
  }
#line 91
  if (rtype == 19UL) {
#line 91
    goto case_19;
  }
#line 96
  if (rtype == 24UL) {
#line 96
    goto case_24;
  }
#line 97
  if (rtype == 25UL) {
#line 97
    goto case_25;
  }
#line 98
  if (rtype == 26UL) {
#line 98
    goto case_26;
  }
#line 99
  if (rtype == 27UL) {
#line 99
    goto case_27;
  }
#line 104
  if (rtype == 28UL) {
#line 104
    goto case_28;
  }
#line 107
  if (rtype == 29UL) {
#line 107
    goto case_29;
  }
#line 108
  if (rtype == 30UL) {
#line 108
    goto case_30;
  }
#line 109
  if (rtype == 31UL) {
#line 109
    goto case_31;
  }
#line 110
  if (rtype == 32UL) {
#line 110
    goto case_32;
  }
#line 111
  if (rtype == 33UL) {
#line 111
    goto case_33;
  }
#line 112
  if (rtype == 34UL) {
#line 112
    goto case_34;
  }
#line 113
  if (rtype == 35UL) {
#line 113
    goto case_35;
  }
#line 114
  if (rtype == 36UL) {
#line 114
    goto case_36;
  }
#line 115
  if (rtype == 37UL) {
#line 115
    goto case_37;
  }
#line 116
  if (rtype == 38UL) {
#line 116
    goto case_38;
  }
#line 117
  if (rtype == 39UL) {
#line 117
    goto case_39;
  }
#line 118
  if (rtype == 40UL) {
#line 118
    goto case_40;
  }
#line 119
  if (rtype == 41UL) {
#line 119
    goto case_41;
  }
#line 121
  goto switch_default;
  case_0: /* CIL Label */ 
#line 74
  return ("R_ALPHA_NONE");
  case_1: /* CIL Label */ 
#line 75
  return ("R_ALPHA_REFLONG");
  case_2: /* CIL Label */ 
#line 76
  return ("R_ALPHA_REFQUAD");
  case_3: /* CIL Label */ 
#line 77
  return ("R_ALPHA_GPREL32");
  case_4: /* CIL Label */ 
#line 78
  return ("R_ALPHA_LITERAL");
  case_5: /* CIL Label */ 
#line 79
  return ("R_ALPHA_LITUSE");
  case_6: /* CIL Label */ 
#line 80
  return ("R_ALPHA_GPDISP");
  case_7: /* CIL Label */ 
#line 81
  return ("R_ALPHA_BRADDR");
  case_8: /* CIL Label */ 
#line 82
  return ("R_ALPHA_HINT");
  case_9: /* CIL Label */ 
#line 83
  return ("R_ALPHA_SREL16");
  case_10: /* CIL Label */ 
#line 84
  return ("R_ALPHA_SREL32");
  case_11: /* CIL Label */ 
#line 85
  return ("R_ALPHA_SREL64");
  case_17: /* CIL Label */ 
#line 89
  return ("R_ALPHA_GPRELHIGH");
  case_18: /* CIL Label */ 
#line 90
  return ("R_ALPHA_GPRELLOW");
  case_19: /* CIL Label */ 
#line 91
  return ("R_ALPHA_GPREL16");
  case_24: /* CIL Label */ 
#line 96
  return ("R_ALPHA_COPY");
  case_25: /* CIL Label */ 
#line 97
  return ("R_ALPHA_GLOB_DAT");
  case_26: /* CIL Label */ 
#line 98
  return ("R_ALPHA_JMP_SLOT");
  case_27: /* CIL Label */ 
#line 99
  return ("R_ALPHA_RELATIVE");
  case_28: /* CIL Label */ 
#line 104
  return ("R_ALPHA_BRSGP");
  case_29: /* CIL Label */ 
#line 107
  return ("R_ALPHA_TLSGD");
  case_30: /* CIL Label */ 
#line 108
  return ("R_ALPHA_TLSLDM");
  case_31: /* CIL Label */ 
#line 109
  return ("R_ALPHA_DTPMOD64");
  case_32: /* CIL Label */ 
#line 110
  return ("R_ALPHA_GOTDTPREL");
  case_33: /* CIL Label */ 
#line 111
  return ("R_ALPHA_DTPREL64");
  case_34: /* CIL Label */ 
#line 112
  return ("R_ALPHA_DTPRELHI");
  case_35: /* CIL Label */ 
#line 113
  return ("R_ALPHA_DTPRELLO");
  case_36: /* CIL Label */ 
#line 114
  return ("R_ALPHA_DTPREL16");
  case_37: /* CIL Label */ 
#line 115
  return ("R_ALPHA_GOTTPREL");
  case_38: /* CIL Label */ 
#line 116
  return ("R_ALPHA_TPREL64");
  case_39: /* CIL Label */ 
#line 117
  return ("R_ALPHA_TPRELHI");
  case_40: /* CIL Label */ 
#line 118
  return ("R_ALPHA_TPRELLO");
  case_41: /* CIL Label */ 
#line 119
  return ("R_ALPHA_TPREL16");
  switch_default: /* CIL Label */ 
#line 121
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "./../include/elf/arc.h"
static char const   *elf_arc_reloc_type(unsigned long rtype ) ;
#line 31 "./../include/elf/arc.h"
static char const   *elf_arc_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 32
  if (rtype == 0UL) {
#line 32
    goto case_0;
  }
#line 33
  if (rtype == 1UL) {
#line 33
    goto case_1;
  }
#line 34
  if (rtype == 2UL) {
#line 34
    goto case_2;
  }
#line 35
  if (rtype == 3UL) {
#line 35
    goto case_3;
  }
#line 36
  goto switch_default;
  case_0: /* CIL Label */ 
#line 32
  return ("R_ARC_NONE");
  case_1: /* CIL Label */ 
#line 33
  return ("R_ARC_32");
  case_2: /* CIL Label */ 
#line 34
  return ("R_ARC_B26");
  case_3: /* CIL Label */ 
#line 35
  return ("R_ARC_B22_PCREL");
  switch_default: /* CIL Label */ 
#line 36
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 112 "./../include/elf/arm.h"
static char const   *elf_arm_reloc_type(unsigned long rtype ) ;
#line 112 "./../include/elf/arm.h"
static char const   *elf_arm_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 114
  if (rtype == 0UL) {
#line 114
    goto case_0;
  }
#line 115
  if (rtype == 1UL) {
#line 115
    goto case_1;
  }
#line 116
  if (rtype == 2UL) {
#line 116
    goto case_2;
  }
#line 117
  if (rtype == 3UL) {
#line 117
    goto case_3;
  }
#line 118
  if (rtype == 4UL) {
#line 118
    goto case_4;
  }
#line 119
  if (rtype == 5UL) {
#line 119
    goto case_5;
  }
#line 120
  if (rtype == 6UL) {
#line 120
    goto case_6;
  }
#line 121
  if (rtype == 7UL) {
#line 121
    goto case_7;
  }
#line 122
  if (rtype == 8UL) {
#line 122
    goto case_8;
  }
#line 123
  if (rtype == 9UL) {
#line 123
    goto case_9;
  }
#line 124
  if (rtype == 10UL) {
#line 124
    goto case_10;
  }
#line 125
  if (rtype == 11UL) {
#line 125
    goto case_11;
  }
#line 126
  if (rtype == 12UL) {
#line 126
    goto case_12;
  }
#line 127
  if (rtype == 13UL) {
#line 127
    goto case_13;
  }
#line 128
  if (rtype == 14UL) {
#line 128
    goto case_14;
  }
#line 129
  if (rtype == 15UL) {
#line 129
    goto case_15;
  }
#line 130
  if (rtype == 16UL) {
#line 130
    goto case_16;
  }
#line 131
  if (rtype == 17UL) {
#line 131
    goto case_17;
  }
#line 132
  if (rtype == 18UL) {
#line 132
    goto case_18;
  }
#line 133
  if (rtype == 19UL) {
#line 133
    goto case_19;
  }
#line 134
  if (rtype == 20UL) {
#line 134
    goto case_20;
  }
#line 135
  if (rtype == 21UL) {
#line 135
    goto case_21;
  }
#line 136
  if (rtype == 22UL) {
#line 136
    goto case_22;
  }
#line 137
  if (rtype == 23UL) {
#line 137
    goto case_23;
  }
#line 138
  if (rtype == 24UL) {
#line 138
    goto case_24;
  }
#line 139
  if (rtype == 25UL) {
#line 139
    goto case_25;
  }
#line 140
  if (rtype == 26UL) {
#line 140
    goto case_26;
  }
#line 141
  if (rtype == 27UL) {
#line 141
    goto case_27;
  }
#line 142
  if (rtype == 28UL) {
#line 142
    goto case_28;
  }
#line 143
  if (rtype == 29UL) {
#line 143
    goto case_29;
  }
#line 144
  if (rtype == 30UL) {
#line 144
    goto case_30;
  }
#line 145
  if (rtype == 31UL) {
#line 145
    goto case_31;
  }
#line 146
  if (rtype == 32UL) {
#line 146
    goto case_32;
  }
#line 147
  if (rtype == 33UL) {
#line 147
    goto case_33;
  }
#line 148
  if (rtype == 34UL) {
#line 148
    goto case_34;
  }
#line 149
  if (rtype == 35UL) {
#line 149
    goto case_35;
  }
#line 150
  if (rtype == 36UL) {
#line 150
    goto case_36;
  }
#line 151
  if (rtype == 37UL) {
#line 151
    goto case_37;
  }
#line 152
  if (rtype == 38UL) {
#line 152
    goto case_38;
  }
#line 153
  if (rtype == 39UL) {
#line 153
    goto case_39;
  }
#line 154
  if (rtype == 40UL) {
#line 154
    goto case_40;
  }
#line 155
  if (rtype == 41UL) {
#line 155
    goto case_41;
  }
#line 156
  if (rtype == 42UL) {
#line 156
    goto case_42;
  }
#line 157
  if (rtype == 43UL) {
#line 157
    goto case_43;
  }
#line 158
  if (rtype == 44UL) {
#line 158
    goto case_44;
  }
#line 159
  if (rtype == 45UL) {
#line 159
    goto case_45;
  }
#line 160
  if (rtype == 46UL) {
#line 160
    goto case_46;
  }
#line 161
  if (rtype == 47UL) {
#line 161
    goto case_47;
  }
#line 162
  if (rtype == 48UL) {
#line 162
    goto case_48;
  }
#line 163
  if (rtype == 49UL) {
#line 163
    goto case_49;
  }
#line 164
  if (rtype == 50UL) {
#line 164
    goto case_50;
  }
#line 165
  if (rtype == 51UL) {
#line 165
    goto case_51;
  }
#line 166
  if (rtype == 52UL) {
#line 166
    goto case_52;
  }
#line 167
  if (rtype == 53UL) {
#line 167
    goto case_53;
  }
#line 168
  if (rtype == 54UL) {
#line 168
    goto case_54;
  }
#line 169
  if (rtype == 55UL) {
#line 169
    goto case_55;
  }
#line 170
  if (rtype == 56UL) {
#line 170
    goto case_56;
  }
#line 171
  if (rtype == 57UL) {
#line 171
    goto case_57;
  }
#line 172
  if (rtype == 58UL) {
#line 172
    goto case_58;
  }
#line 173
  if (rtype == 59UL) {
#line 173
    goto case_59;
  }
#line 174
  if (rtype == 60UL) {
#line 174
    goto case_60;
  }
#line 175
  if (rtype == 61UL) {
#line 175
    goto case_61;
  }
#line 176
  if (rtype == 62UL) {
#line 176
    goto case_62;
  }
#line 177
  if (rtype == 63UL) {
#line 177
    goto case_63;
  }
#line 178
  if (rtype == 64UL) {
#line 178
    goto case_64;
  }
#line 179
  if (rtype == 65UL) {
#line 179
    goto case_65;
  }
#line 180
  if (rtype == 66UL) {
#line 180
    goto case_66;
  }
#line 181
  if (rtype == 67UL) {
#line 181
    goto case_67;
  }
#line 182
  if (rtype == 68UL) {
#line 182
    goto case_68;
  }
#line 183
  if (rtype == 69UL) {
#line 183
    goto case_69;
  }
#line 184
  if (rtype == 70UL) {
#line 184
    goto case_70;
  }
#line 185
  if (rtype == 71UL) {
#line 185
    goto case_71;
  }
#line 186
  if (rtype == 72UL) {
#line 186
    goto case_72;
  }
#line 187
  if (rtype == 73UL) {
#line 187
    goto case_73;
  }
#line 188
  if (rtype == 74UL) {
#line 188
    goto case_74;
  }
#line 189
  if (rtype == 75UL) {
#line 189
    goto case_75;
  }
#line 190
  if (rtype == 76UL) {
#line 190
    goto case_76;
  }
#line 191
  if (rtype == 77UL) {
#line 191
    goto case_77;
  }
#line 192
  if (rtype == 78UL) {
#line 192
    goto case_78;
  }
#line 193
  if (rtype == 79UL) {
#line 193
    goto case_79;
  }
#line 194
  if (rtype == 80UL) {
#line 194
    goto case_80;
  }
#line 195
  if (rtype == 81UL) {
#line 195
    goto case_81;
  }
#line 196
  if (rtype == 82UL) {
#line 196
    goto case_82;
  }
#line 197
  if (rtype == 83UL) {
#line 197
    goto case_83;
  }
#line 198
  if (rtype == 84UL) {
#line 198
    goto case_84;
  }
#line 199
  if (rtype == 85UL) {
#line 199
    goto case_85;
  }
#line 200
  if (rtype == 86UL) {
#line 200
    goto case_86;
  }
#line 201
  if (rtype == 87UL) {
#line 201
    goto case_87;
  }
#line 202
  if (rtype == 88UL) {
#line 202
    goto case_88;
  }
#line 203
  if (rtype == 89UL) {
#line 203
    goto case_89;
  }
#line 204
  if (rtype == 90UL) {
#line 204
    goto case_90;
  }
#line 205
  if (rtype == 91UL) {
#line 205
    goto case_91;
  }
#line 206
  if (rtype == 92UL) {
#line 206
    goto case_92;
  }
#line 207
  if (rtype == 93UL) {
#line 207
    goto case_93;
  }
#line 208
  if (rtype == 94UL) {
#line 208
    goto case_94;
  }
#line 209
  if (rtype == 95UL) {
#line 209
    goto case_95;
  }
#line 210
  if (rtype == 96UL) {
#line 210
    goto case_96;
  }
#line 211
  if (rtype == 97UL) {
#line 211
    goto case_97;
  }
#line 212
  if (rtype == 98UL) {
#line 212
    goto case_98;
  }
#line 213
  if (rtype == 99UL) {
#line 213
    goto case_99;
  }
#line 214
  if (rtype == 100UL) {
#line 214
    goto case_100;
  }
#line 215
  if (rtype == 101UL) {
#line 215
    goto case_101;
  }
#line 216
  if (rtype == 102UL) {
#line 216
    goto case_102;
  }
#line 217
  if (rtype == 103UL) {
#line 217
    goto case_103;
  }
#line 218
  if (rtype == 104UL) {
#line 218
    goto case_104;
  }
#line 219
  if (rtype == 105UL) {
#line 219
    goto case_105;
  }
#line 220
  if (rtype == 106UL) {
#line 220
    goto case_106;
  }
#line 221
  if (rtype == 107UL) {
#line 221
    goto case_107;
  }
#line 222
  if (rtype == 108UL) {
#line 222
    goto case_108;
  }
#line 223
  if (rtype == 109UL) {
#line 223
    goto case_109;
  }
#line 224
  if (rtype == 110UL) {
#line 224
    goto case_110;
  }
#line 225
  if (rtype == 111UL) {
#line 225
    goto case_111;
  }
#line 227
  if (rtype == 128UL) {
#line 227
    goto case_128;
  }
#line 228
  if (rtype == 129UL) {
#line 228
    goto case_129;
  }
#line 230
  if (rtype == 160UL) {
#line 230
    goto case_160;
  }
#line 233
  if (rtype == 249UL) {
#line 233
    goto case_249;
  }
#line 234
  if (rtype == 250UL) {
#line 234
    goto case_250;
  }
#line 235
  if (rtype == 251UL) {
#line 235
    goto case_251;
  }
#line 236
  if (rtype == 252UL) {
#line 236
    goto case_252;
  }
#line 237
  if (rtype == 253UL) {
#line 237
    goto case_253;
  }
#line 238
  if (rtype == 254UL) {
#line 238
    goto case_254;
  }
#line 239
  if (rtype == 255UL) {
#line 239
    goto case_255;
  }
#line 254
  goto switch_default;
  case_0: /* CIL Label */ 
#line 114
  return ("R_ARM_NONE");
  case_1: /* CIL Label */ 
#line 115
  return ("R_ARM_PC24");
  case_2: /* CIL Label */ 
#line 116
  return ("R_ARM_ABS32");
  case_3: /* CIL Label */ 
#line 117
  return ("R_ARM_REL32");
  case_4: /* CIL Label */ 
#line 118
  return ("R_ARM_LDR_PC_G0");
  case_5: /* CIL Label */ 
#line 119
  return ("R_ARM_ABS16");
  case_6: /* CIL Label */ 
#line 120
  return ("R_ARM_ABS12");
  case_7: /* CIL Label */ 
#line 121
  return ("R_ARM_THM_ABS5");
  case_8: /* CIL Label */ 
#line 122
  return ("R_ARM_ABS8");
  case_9: /* CIL Label */ 
#line 123
  return ("R_ARM_SBREL32");
  case_10: /* CIL Label */ 
#line 124
  return ("R_ARM_THM_CALL");
  case_11: /* CIL Label */ 
#line 125
  return ("R_ARM_THM_PC8");
  case_12: /* CIL Label */ 
#line 126
  return ("R_ARM_BREL_ADJ");
  case_13: /* CIL Label */ 
#line 127
  return ("R_ARM_TLS_DESC");
  case_14: /* CIL Label */ 
#line 128
  return ("R_ARM_THM_SWI8");
  case_15: /* CIL Label */ 
#line 129
  return ("R_ARM_XPC25");
  case_16: /* CIL Label */ 
#line 130
  return ("R_ARM_THM_XPC22");
  case_17: /* CIL Label */ 
#line 131
  return ("R_ARM_TLS_DTPMOD32");
  case_18: /* CIL Label */ 
#line 132
  return ("R_ARM_TLS_DTPOFF32");
  case_19: /* CIL Label */ 
#line 133
  return ("R_ARM_TLS_TPOFF32");
  case_20: /* CIL Label */ 
#line 134
  return ("R_ARM_COPY");
  case_21: /* CIL Label */ 
#line 135
  return ("R_ARM_GLOB_DAT");
  case_22: /* CIL Label */ 
#line 136
  return ("R_ARM_JUMP_SLOT");
  case_23: /* CIL Label */ 
#line 137
  return ("R_ARM_RELATIVE");
  case_24: /* CIL Label */ 
#line 138
  return ("R_ARM_GOTOFF32");
  case_25: /* CIL Label */ 
#line 139
  return ("R_ARM_BASE_PREL");
  case_26: /* CIL Label */ 
#line 140
  return ("R_ARM_GOT_BREL");
  case_27: /* CIL Label */ 
#line 141
  return ("R_ARM_PLT32");
  case_28: /* CIL Label */ 
#line 142
  return ("R_ARM_CALL");
  case_29: /* CIL Label */ 
#line 143
  return ("R_ARM_JUMP24");
  case_30: /* CIL Label */ 
#line 144
  return ("R_ARM_THM_JUMP24");
  case_31: /* CIL Label */ 
#line 145
  return ("R_ARM_BASE_ABS");
  case_32: /* CIL Label */ 
#line 146
  return ("R_ARM_ALU_PCREL7_0");
  case_33: /* CIL Label */ 
#line 147
  return ("R_ARM_ALU_PCREL15_8");
  case_34: /* CIL Label */ 
#line 148
  return ("R_ARM_ALU_PCREL23_15");
  case_35: /* CIL Label */ 
#line 149
  return ("R_ARM_LDR_SBREL_11_0");
  case_36: /* CIL Label */ 
#line 150
  return ("R_ARM_ALU_SBREL_19_12");
  case_37: /* CIL Label */ 
#line 151
  return ("R_ARM_ALU_SBREL_27_20");
  case_38: /* CIL Label */ 
#line 152
  return ("R_ARM_TARGET1");
  case_39: /* CIL Label */ 
#line 153
  return ("R_ARM_SBREL31");
  case_40: /* CIL Label */ 
#line 154
  return ("R_ARM_V4BX");
  case_41: /* CIL Label */ 
#line 155
  return ("R_ARM_TARGET2");
  case_42: /* CIL Label */ 
#line 156
  return ("R_ARM_PREL31");
  case_43: /* CIL Label */ 
#line 157
  return ("R_ARM_MOVW_ABS_NC");
  case_44: /* CIL Label */ 
#line 158
  return ("R_ARM_MOVT_ABS");
  case_45: /* CIL Label */ 
#line 159
  return ("R_ARM_MOVW_PREL_NC");
  case_46: /* CIL Label */ 
#line 160
  return ("R_ARM_MOVT_PREL");
  case_47: /* CIL Label */ 
#line 161
  return ("R_ARM_THM_MOVW_ABS_NC");
  case_48: /* CIL Label */ 
#line 162
  return ("R_ARM_THM_MOVT_ABS");
  case_49: /* CIL Label */ 
#line 163
  return ("R_ARM_THM_MOVW_PREL_NC");
  case_50: /* CIL Label */ 
#line 164
  return ("R_ARM_THM_MOVT_PREL");
  case_51: /* CIL Label */ 
#line 165
  return ("R_ARM_THM_JUMP19");
  case_52: /* CIL Label */ 
#line 166
  return ("R_ARM_THM_JUMP6");
  case_53: /* CIL Label */ 
#line 167
  return ("R_ARM_THM_ALU_PREL_11_0");
  case_54: /* CIL Label */ 
#line 168
  return ("R_ARM_THM_PC12");
  case_55: /* CIL Label */ 
#line 169
  return ("R_ARM_ABS32_NOI");
  case_56: /* CIL Label */ 
#line 170
  return ("R_ARM_REL32_NOI");
  case_57: /* CIL Label */ 
#line 171
  return ("R_ARM_ALU_PC_G0_NC");
  case_58: /* CIL Label */ 
#line 172
  return ("R_ARM_ALU_PC_G0");
  case_59: /* CIL Label */ 
#line 173
  return ("R_ARM_ALU_PC_G1_NC");
  case_60: /* CIL Label */ 
#line 174
  return ("R_ARM_ALU_PC_G1");
  case_61: /* CIL Label */ 
#line 175
  return ("R_ARM_ALU_PC_G2");
  case_62: /* CIL Label */ 
#line 176
  return ("R_ARM_LDR_PC_G1");
  case_63: /* CIL Label */ 
#line 177
  return ("R_ARM_LDR_PC_G2");
  case_64: /* CIL Label */ 
#line 178
  return ("R_ARM_LDRS_PC_G0");
  case_65: /* CIL Label */ 
#line 179
  return ("R_ARM_LDRS_PC_G1");
  case_66: /* CIL Label */ 
#line 180
  return ("R_ARM_LDRS_PC_G2");
  case_67: /* CIL Label */ 
#line 181
  return ("R_ARM_LDC_PC_G0");
  case_68: /* CIL Label */ 
#line 182
  return ("R_ARM_LDC_PC_G1");
  case_69: /* CIL Label */ 
#line 183
  return ("R_ARM_LDC_PC_G2");
  case_70: /* CIL Label */ 
#line 184
  return ("R_ARM_ALU_SB_G0_NC");
  case_71: /* CIL Label */ 
#line 185
  return ("R_ARM_ALU_SB_G0");
  case_72: /* CIL Label */ 
#line 186
  return ("R_ARM_ALU_SB_G1_NC");
  case_73: /* CIL Label */ 
#line 187
  return ("R_ARM_ALU_SB_G1");
  case_74: /* CIL Label */ 
#line 188
  return ("R_ARM_ALU_SB_G2");
  case_75: /* CIL Label */ 
#line 189
  return ("R_ARM_LDR_SB_G0");
  case_76: /* CIL Label */ 
#line 190
  return ("R_ARM_LDR_SB_G1");
  case_77: /* CIL Label */ 
#line 191
  return ("R_ARM_LDR_SB_G2");
  case_78: /* CIL Label */ 
#line 192
  return ("R_ARM_LDRS_SB_G0");
  case_79: /* CIL Label */ 
#line 193
  return ("R_ARM_LDRS_SB_G1");
  case_80: /* CIL Label */ 
#line 194
  return ("R_ARM_LDRS_SB_G2");
  case_81: /* CIL Label */ 
#line 195
  return ("R_ARM_LDC_SB_G0");
  case_82: /* CIL Label */ 
#line 196
  return ("R_ARM_LDC_SB_G1");
  case_83: /* CIL Label */ 
#line 197
  return ("R_ARM_LDC_SB_G2");
  case_84: /* CIL Label */ 
#line 198
  return ("R_ARM_MOVW_BREL_NC");
  case_85: /* CIL Label */ 
#line 199
  return ("R_ARM_MOVT_BREL");
  case_86: /* CIL Label */ 
#line 200
  return ("R_ARM_MOVW_BREL");
  case_87: /* CIL Label */ 
#line 201
  return ("R_ARM_THM_MOVW_BREL_NC");
  case_88: /* CIL Label */ 
#line 202
  return ("R_ARM_THM_MOVT_BREL");
  case_89: /* CIL Label */ 
#line 203
  return ("R_ARM_THM_MOVW_BREL");
  case_90: /* CIL Label */ 
#line 204
  return ("R_ARM_TLS_GOTDESC");
  case_91: /* CIL Label */ 
#line 205
  return ("R_ARM_TLS_CALL");
  case_92: /* CIL Label */ 
#line 206
  return ("R_ARM_TLS_DESCSEQ");
  case_93: /* CIL Label */ 
#line 207
  return ("R_ARM_THM_TLS_CALL");
  case_94: /* CIL Label */ 
#line 208
  return ("R_ARM_PLT32_ABS");
  case_95: /* CIL Label */ 
#line 209
  return ("R_ARM_GOT_ABS");
  case_96: /* CIL Label */ 
#line 210
  return ("R_ARM_GOT_PREL");
  case_97: /* CIL Label */ 
#line 211
  return ("R_ARM_GOT_BREL12");
  case_98: /* CIL Label */ 
#line 212
  return ("R_ARM_GOTOFF12");
  case_99: /* CIL Label */ 
#line 213
  return ("R_ARM_GOTRELAX");
  case_100: /* CIL Label */ 
#line 214
  return ("R_ARM_GNU_VTENTRY");
  case_101: /* CIL Label */ 
#line 215
  return ("R_ARM_GNU_VTINHERIT");
  case_102: /* CIL Label */ 
#line 216
  return ("R_ARM_THM_JUMP11");
  case_103: /* CIL Label */ 
#line 217
  return ("R_ARM_THM_JUMP8");
  case_104: /* CIL Label */ 
#line 218
  return ("R_ARM_TLS_GD32");
  case_105: /* CIL Label */ 
#line 219
  return ("R_ARM_TLS_LDM32");
  case_106: /* CIL Label */ 
#line 220
  return ("R_ARM_TLS_LDO32");
  case_107: /* CIL Label */ 
#line 221
  return ("R_ARM_TLS_IE32");
  case_108: /* CIL Label */ 
#line 222
  return ("R_ARM_TLS_LE32");
  case_109: /* CIL Label */ 
#line 223
  return ("R_ARM_TLS_LDO12");
  case_110: /* CIL Label */ 
#line 224
  return ("R_ARM_TLS_LE12");
  case_111: /* CIL Label */ 
#line 225
  return ("R_ARM_TLS_IE12GP");
  case_128: /* CIL Label */ 
#line 227
  return ("R_ARM_ME_TOO");
  case_129: /* CIL Label */ 
#line 228
  return ("R_ARM_THM_TLS_DESCSEQ");
  case_160: /* CIL Label */ 
#line 230
  return ("R_ARM_IRELATIVE");
  case_249: /* CIL Label */ 
#line 233
  return ("R_ARM_RXPC25");
  case_250: /* CIL Label */ 
#line 234
  return ("R_ARM_RSBREL32");
  case_251: /* CIL Label */ 
#line 235
  return ("R_ARM_THM_RPC22");
  case_252: /* CIL Label */ 
#line 236
  return ("R_ARM_RREL32");
  case_253: /* CIL Label */ 
#line 237
  return ("R_ARM_RABS32");
  case_254: /* CIL Label */ 
#line 238
  return ("R_ARM_RPC24");
  case_255: /* CIL Label */ 
#line 239
  return ("R_ARM_RBASE");
  switch_default: /* CIL Label */ 
#line 254
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 53 "./../include/elf/avr.h"
static char const   *elf_avr_reloc_type(unsigned long rtype ) ;
#line 53 "./../include/elf/avr.h"
static char const   *elf_avr_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 54
  if (rtype == 0UL) {
#line 54
    goto case_0;
  }
#line 55
  if (rtype == 1UL) {
#line 55
    goto case_1;
  }
#line 56
  if (rtype == 2UL) {
#line 56
    goto case_2;
  }
#line 57
  if (rtype == 3UL) {
#line 57
    goto case_3;
  }
#line 58
  if (rtype == 4UL) {
#line 58
    goto case_4;
  }
#line 59
  if (rtype == 5UL) {
#line 59
    goto case_5;
  }
#line 60
  if (rtype == 6UL) {
#line 60
    goto case_6;
  }
#line 61
  if (rtype == 7UL) {
#line 61
    goto case_7;
  }
#line 62
  if (rtype == 8UL) {
#line 62
    goto case_8;
  }
#line 63
  if (rtype == 9UL) {
#line 63
    goto case_9;
  }
#line 64
  if (rtype == 10UL) {
#line 64
    goto case_10;
  }
#line 65
  if (rtype == 11UL) {
#line 65
    goto case_11;
  }
#line 66
  if (rtype == 12UL) {
#line 66
    goto case_12;
  }
#line 67
  if (rtype == 13UL) {
#line 67
    goto case_13;
  }
#line 68
  if (rtype == 14UL) {
#line 68
    goto case_14;
  }
#line 69
  if (rtype == 15UL) {
#line 69
    goto case_15;
  }
#line 70
  if (rtype == 16UL) {
#line 70
    goto case_16;
  }
#line 71
  if (rtype == 17UL) {
#line 71
    goto case_17;
  }
#line 72
  if (rtype == 18UL) {
#line 72
    goto case_18;
  }
#line 73
  if (rtype == 19UL) {
#line 73
    goto case_19;
  }
#line 74
  if (rtype == 20UL) {
#line 74
    goto case_20;
  }
#line 75
  if (rtype == 21UL) {
#line 75
    goto case_21;
  }
#line 76
  if (rtype == 22UL) {
#line 76
    goto case_22;
  }
#line 77
  if (rtype == 23UL) {
#line 77
    goto case_23;
  }
#line 78
  if (rtype == 24UL) {
#line 78
    goto case_24;
  }
#line 79
  if (rtype == 25UL) {
#line 79
    goto case_25;
  }
#line 80
  if (rtype == 26UL) {
#line 80
    goto case_26;
  }
#line 81
  if (rtype == 27UL) {
#line 81
    goto case_27;
  }
#line 82
  if (rtype == 28UL) {
#line 82
    goto case_28;
  }
#line 83
  if (rtype == 29UL) {
#line 83
    goto case_29;
  }
#line 84
  goto switch_default;
  case_0: /* CIL Label */ 
#line 54
  return ("R_AVR_NONE");
  case_1: /* CIL Label */ 
#line 55
  return ("R_AVR_32");
  case_2: /* CIL Label */ 
#line 56
  return ("R_AVR_7_PCREL");
  case_3: /* CIL Label */ 
#line 57
  return ("R_AVR_13_PCREL");
  case_4: /* CIL Label */ 
#line 58
  return ("R_AVR_16");
  case_5: /* CIL Label */ 
#line 59
  return ("R_AVR_16_PM");
  case_6: /* CIL Label */ 
#line 60
  return ("R_AVR_LO8_LDI");
  case_7: /* CIL Label */ 
#line 61
  return ("R_AVR_HI8_LDI");
  case_8: /* CIL Label */ 
#line 62
  return ("R_AVR_HH8_LDI");
  case_9: /* CIL Label */ 
#line 63
  return ("R_AVR_LO8_LDI_NEG");
  case_10: /* CIL Label */ 
#line 64
  return ("R_AVR_HI8_LDI_NEG");
  case_11: /* CIL Label */ 
#line 65
  return ("R_AVR_HH8_LDI_NEG");
  case_12: /* CIL Label */ 
#line 66
  return ("R_AVR_LO8_LDI_PM");
  case_13: /* CIL Label */ 
#line 67
  return ("R_AVR_HI8_LDI_PM");
  case_14: /* CIL Label */ 
#line 68
  return ("R_AVR_HH8_LDI_PM");
  case_15: /* CIL Label */ 
#line 69
  return ("R_AVR_LO8_LDI_PM_NEG");
  case_16: /* CIL Label */ 
#line 70
  return ("R_AVR_HI8_LDI_PM_NEG");
  case_17: /* CIL Label */ 
#line 71
  return ("R_AVR_HH8_LDI_PM_NEG");
  case_18: /* CIL Label */ 
#line 72
  return ("R_AVR_CALL");
  case_19: /* CIL Label */ 
#line 73
  return ("R_AVR_LDI");
  case_20: /* CIL Label */ 
#line 74
  return ("R_AVR_6");
  case_21: /* CIL Label */ 
#line 75
  return ("R_AVR_6_ADIW");
  case_22: /* CIL Label */ 
#line 76
  return ("R_AVR_MS8_LDI");
  case_23: /* CIL Label */ 
#line 77
  return ("R_AVR_MS8_LDI_NEG");
  case_24: /* CIL Label */ 
#line 78
  return ("R_AVR_LO8_LDI_GS");
  case_25: /* CIL Label */ 
#line 79
  return ("R_AVR_HI8_LDI_GS");
  case_26: /* CIL Label */ 
#line 80
  return ("R_AVR_8");
  case_27: /* CIL Label */ 
#line 81
  return ("R_AVR_8_LO8");
  case_28: /* CIL Label */ 
#line 82
  return ("R_AVR_8_HI8");
  case_29: /* CIL Label */ 
#line 83
  return ("R_AVR_8_HLO8");
  switch_default: /* CIL Label */ 
#line 84
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 25 "./../include/elf/bfin.h"
static char const   *elf_bfin_reloc_type(unsigned long rtype ) ;
#line 25 "./../include/elf/bfin.h"
static char const   *elf_bfin_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 26
  if (rtype == 0UL) {
#line 26
    goto case_0;
  }
#line 27
  if (rtype == 1UL) {
#line 27
    goto case_1;
  }
#line 28
  if (rtype == 2UL) {
#line 28
    goto case_2;
  }
#line 29
  if (rtype == 3UL) {
#line 29
    goto case_3;
  }
#line 30
  if (rtype == 4UL) {
#line 30
    goto case_4;
  }
#line 31
  if (rtype == 5UL) {
#line 31
    goto case_5;
  }
#line 32
  if (rtype == 6UL) {
#line 32
    goto case_6;
  }
#line 33
  if (rtype == 7UL) {
#line 33
    goto case_7;
  }
#line 34
  if (rtype == 8UL) {
#line 34
    goto case_8;
  }
#line 35
  if (rtype == 9UL) {
#line 35
    goto case_9;
  }
#line 36
  if (rtype == 10UL) {
#line 36
    goto case_10;
  }
#line 37
  if (rtype == 11UL) {
#line 37
    goto case_11;
  }
#line 38
  if (rtype == 12UL) {
#line 38
    goto case_12;
  }
#line 39
  if (rtype == 13UL) {
#line 39
    goto case_13;
  }
#line 40
  if (rtype == 14UL) {
#line 40
    goto case_14;
  }
#line 41
  if (rtype == 15UL) {
#line 41
    goto case_15;
  }
#line 42
  if (rtype == 16UL) {
#line 42
    goto case_16;
  }
#line 43
  if (rtype == 17UL) {
#line 43
    goto case_17;
  }
#line 44
  if (rtype == 18UL) {
#line 44
    goto case_18;
  }
#line 45
  if (rtype == 19UL) {
#line 45
    goto case_19;
  }
#line 46
  if (rtype == 20UL) {
#line 46
    goto case_20;
  }
#line 47
  if (rtype == 21UL) {
#line 47
    goto case_21;
  }
#line 48
  if (rtype == 22UL) {
#line 48
    goto case_22;
  }
#line 49
  if (rtype == 23UL) {
#line 49
    goto case_23;
  }
#line 50
  if (rtype == 24UL) {
#line 50
    goto case_24;
  }
#line 51
  if (rtype == 25UL) {
#line 51
    goto case_25;
  }
#line 52
  if (rtype == 26UL) {
#line 52
    goto case_26;
  }
#line 53
  if (rtype == 27UL) {
#line 53
    goto case_27;
  }
#line 54
  if (rtype == 28UL) {
#line 54
    goto case_28;
  }
#line 55
  if (rtype == 29UL) {
#line 55
    goto case_29;
  }
#line 56
  if (rtype == 30UL) {
#line 56
    goto case_30;
  }
#line 57
  if (rtype == 31UL) {
#line 57
    goto case_31;
  }
#line 58
  if (rtype == 32UL) {
#line 58
    goto case_32;
  }
#line 59
  if (rtype == 33UL) {
#line 59
    goto case_33;
  }
#line 61
  if (rtype == 224UL) {
#line 61
    goto case_224;
  }
#line 62
  if (rtype == 225UL) {
#line 62
    goto case_225;
  }
#line 63
  if (rtype == 226UL) {
#line 63
    goto case_226;
  }
#line 64
  if (rtype == 227UL) {
#line 64
    goto case_227;
  }
#line 65
  if (rtype == 228UL) {
#line 65
    goto case_228;
  }
#line 66
  if (rtype == 229UL) {
#line 66
    goto case_229;
  }
#line 67
  if (rtype == 230UL) {
#line 67
    goto case_230;
  }
#line 68
  if (rtype == 231UL) {
#line 68
    goto case_231;
  }
#line 69
  if (rtype == 232UL) {
#line 69
    goto case_232;
  }
#line 70
  if (rtype == 233UL) {
#line 70
    goto case_233;
  }
#line 71
  if (rtype == 234UL) {
#line 71
    goto case_234;
  }
#line 72
  if (rtype == 235UL) {
#line 72
    goto case_235;
  }
#line 73
  if (rtype == 236UL) {
#line 73
    goto case_236;
  }
#line 74
  if (rtype == 237UL) {
#line 74
    goto case_237;
  }
#line 75
  if (rtype == 238UL) {
#line 75
    goto case_238;
  }
#line 76
  if (rtype == 239UL) {
#line 76
    goto case_239;
  }
#line 77
  if (rtype == 240UL) {
#line 77
    goto case_240;
  }
#line 78
  if (rtype == 241UL) {
#line 78
    goto case_241;
  }
#line 79
  if (rtype == 242UL) {
#line 79
    goto case_242;
  }
#line 80
  if (rtype == 243UL) {
#line 80
    goto case_243;
  }
#line 81
  if (rtype == 64UL) {
#line 81
    goto case_64;
  }
#line 82
  if (rtype == 65UL) {
#line 82
    goto case_65;
  }
#line 83
  if (rtype == 66UL) {
#line 83
    goto case_66;
  }
#line 84
  if (rtype == 67UL) {
#line 84
    goto case_67;
  }
#line 85
  goto switch_default;
  case_0: /* CIL Label */ 
#line 26
  return ("R_BFIN_UNUSED0");
  case_1: /* CIL Label */ 
#line 27
  return ("R_BFIN_PCREL5M2");
  case_2: /* CIL Label */ 
#line 28
  return ("R_BFIN_UNUSED1");
  case_3: /* CIL Label */ 
#line 29
  return ("R_BFIN_PCREL10");
  case_4: /* CIL Label */ 
#line 30
  return ("R_BFIN_PCREL12_JUMP");
  case_5: /* CIL Label */ 
#line 31
  return ("R_BFIN_RIMM16");
  case_6: /* CIL Label */ 
#line 32
  return ("R_BFIN_LUIMM16");
  case_7: /* CIL Label */ 
#line 33
  return ("R_BFIN_HUIMM16");
  case_8: /* CIL Label */ 
#line 34
  return ("R_BFIN_PCREL12_JUMP_S");
  case_9: /* CIL Label */ 
#line 35
  return ("R_BFIN_PCREL24_JUMP_X");
  case_10: /* CIL Label */ 
#line 36
  return ("R_BFIN_PCREL24");
  case_11: /* CIL Label */ 
#line 37
  return ("R_BFIN_UNUSEDB");
  case_12: /* CIL Label */ 
#line 38
  return ("R_BFIN_UNUSEDC");
  case_13: /* CIL Label */ 
#line 39
  return ("R_BFIN_PCREL24_JUMP_L");
  case_14: /* CIL Label */ 
#line 40
  return ("R_BFIN_PCREL24_CALL_X");
  case_15: /* CIL Label */ 
#line 41
  return ("R_BFIN_VAR_EQ_SYMB");
  case_16: /* CIL Label */ 
#line 42
  return ("R_BFIN_BYTE_DATA");
  case_17: /* CIL Label */ 
#line 43
  return ("R_BFIN_BYTE2_DATA");
  case_18: /* CIL Label */ 
#line 44
  return ("R_BFIN_BYTE4_DATA");
  case_19: /* CIL Label */ 
#line 45
  return ("R_BFIN_PCREL11");
  case_20: /* CIL Label */ 
#line 46
  return ("R_BFIN_GOT17M4");
  case_21: /* CIL Label */ 
#line 47
  return ("R_BFIN_GOTHI");
  case_22: /* CIL Label */ 
#line 48
  return ("R_BFIN_GOTLO");
  case_23: /* CIL Label */ 
#line 49
  return ("R_BFIN_FUNCDESC");
  case_24: /* CIL Label */ 
#line 50
  return ("R_BFIN_FUNCDESC_GOT17M4");
  case_25: /* CIL Label */ 
#line 51
  return ("R_BFIN_FUNCDESC_GOTHI");
  case_26: /* CIL Label */ 
#line 52
  return ("R_BFIN_FUNCDESC_GOTLO");
  case_27: /* CIL Label */ 
#line 53
  return ("R_BFIN_FUNCDESC_VALUE");
  case_28: /* CIL Label */ 
#line 54
  return ("R_BFIN_FUNCDESC_GOTOFF17M4");
  case_29: /* CIL Label */ 
#line 55
  return ("R_BFIN_FUNCDESC_GOTOFFHI");
  case_30: /* CIL Label */ 
#line 56
  return ("R_BFIN_FUNCDESC_GOTOFFLO");
  case_31: /* CIL Label */ 
#line 57
  return ("R_BFIN_GOTOFF17M4");
  case_32: /* CIL Label */ 
#line 58
  return ("R_BFIN_GOTOFFHI");
  case_33: /* CIL Label */ 
#line 59
  return ("R_BFIN_GOTOFFLO");
  case_224: /* CIL Label */ 
#line 61
  return ("R_BFIN_PUSH");
  case_225: /* CIL Label */ 
#line 62
  return ("R_BFIN_CONST");
  case_226: /* CIL Label */ 
#line 63
  return ("R_BFIN_ADD");
  case_227: /* CIL Label */ 
#line 64
  return ("R_BFIN_SUB");
  case_228: /* CIL Label */ 
#line 65
  return ("R_BFIN_MULT");
  case_229: /* CIL Label */ 
#line 66
  return ("R_BFIN_DIV");
  case_230: /* CIL Label */ 
#line 67
  return ("R_BFIN_MOD");
  case_231: /* CIL Label */ 
#line 68
  return ("R_BFIN_LSHIFT");
  case_232: /* CIL Label */ 
#line 69
  return ("R_BFIN_RSHIFT");
  case_233: /* CIL Label */ 
#line 70
  return ("R_BFIN_AND");
  case_234: /* CIL Label */ 
#line 71
  return ("R_BFIN_OR");
  case_235: /* CIL Label */ 
#line 72
  return ("R_BFIN_XOR");
  case_236: /* CIL Label */ 
#line 73
  return ("R_BFIN_LAND");
  case_237: /* CIL Label */ 
#line 74
  return ("R_BFIN_LOR");
  case_238: /* CIL Label */ 
#line 75
  return ("R_BFIN_LEN");
  case_239: /* CIL Label */ 
#line 76
  return ("R_BFIN_NEG");
  case_240: /* CIL Label */ 
#line 77
  return ("R_BFIN_COMP");
  case_241: /* CIL Label */ 
#line 78
  return ("R_BFIN_PAGE");
  case_242: /* CIL Label */ 
#line 79
  return ("R_BFIN_HWPAGE");
  case_243: /* CIL Label */ 
#line 80
  return ("R_BFIN_ADDR");
  case_64: /* CIL Label */ 
#line 81
  return ("R_BFIN_PLTPC");
  case_65: /* CIL Label */ 
#line 82
  return ("R_BFIN_GOT");
  case_66: /* CIL Label */ 
#line 83
  return ("R_BFIN_GNU_VTINHERIT");
  case_67: /* CIL Label */ 
#line 84
  return ("R_BFIN_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 85
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/cr16.h"
static char const   *elf_cr16_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/cr16.h"
static char const   *elf_cr16_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  if (rtype == 18UL) {
#line 46
    goto case_18;
  }
#line 47
  if (rtype == 19UL) {
#line 47
    goto case_19;
  }
#line 48
  if (rtype == 20UL) {
#line 48
    goto case_20;
  }
#line 49
  if (rtype == 21UL) {
#line 49
    goto case_21;
  }
#line 50
  if (rtype == 22UL) {
#line 50
    goto case_22;
  }
#line 51
  if (rtype == 23UL) {
#line 51
    goto case_23;
  }
#line 52
  if (rtype == 24UL) {
#line 52
    goto case_24;
  }
#line 53
  if (rtype == 25UL) {
#line 53
    goto case_25;
  }
#line 54
  if (rtype == 26UL) {
#line 54
    goto case_26;
  }
#line 55
  if (rtype == 27UL) {
#line 55
    goto case_27;
  }
#line 56
  if (rtype == 28UL) {
#line 56
    goto case_28;
  }
#line 57
  if (rtype == 29UL) {
#line 57
    goto case_29;
  }
#line 58
  if (rtype == 30UL) {
#line 58
    goto case_30;
  }
#line 59
  if (rtype == 31UL) {
#line 59
    goto case_31;
  }
#line 60
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_CR16_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_CR16_NUM8");
  case_2: /* CIL Label */ 
#line 30
  return ("R_CR16_NUM16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_CR16_NUM32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_CR16_NUM32a");
  case_5: /* CIL Label */ 
#line 33
  return ("R_CR16_REGREL4");
  case_6: /* CIL Label */ 
#line 34
  return ("R_CR16_REGREL4a");
  case_7: /* CIL Label */ 
#line 35
  return ("R_CR16_REGREL14");
  case_8: /* CIL Label */ 
#line 36
  return ("R_CR16_REGREL14a");
  case_9: /* CIL Label */ 
#line 37
  return ("R_CR16_REGREL16");
  case_10: /* CIL Label */ 
#line 38
  return ("R_CR16_REGREL20");
  case_11: /* CIL Label */ 
#line 39
  return ("R_CR16_REGREL20a");
  case_12: /* CIL Label */ 
#line 40
  return ("R_CR16_ABS20");
  case_13: /* CIL Label */ 
#line 41
  return ("R_CR16_ABS24");
  case_14: /* CIL Label */ 
#line 42
  return ("R_CR16_IMM4");
  case_15: /* CIL Label */ 
#line 43
  return ("R_CR16_IMM8");
  case_16: /* CIL Label */ 
#line 44
  return ("R_CR16_IMM16");
  case_17: /* CIL Label */ 
#line 45
  return ("R_CR16_IMM20");
  case_18: /* CIL Label */ 
#line 46
  return ("R_CR16_IMM24");
  case_19: /* CIL Label */ 
#line 47
  return ("R_CR16_IMM32");
  case_20: /* CIL Label */ 
#line 48
  return ("R_CR16_IMM32a");
  case_21: /* CIL Label */ 
#line 49
  return ("R_CR16_DISP4");
  case_22: /* CIL Label */ 
#line 50
  return ("R_CR16_DISP8");
  case_23: /* CIL Label */ 
#line 51
  return ("R_CR16_DISP16");
  case_24: /* CIL Label */ 
#line 52
  return ("R_CR16_DISP24");
  case_25: /* CIL Label */ 
#line 53
  return ("R_CR16_DISP24a");
  case_26: /* CIL Label */ 
#line 54
  return ("R_CR16_SWITCH8");
  case_27: /* CIL Label */ 
#line 55
  return ("R_CR16_SWITCH16");
  case_28: /* CIL Label */ 
#line 56
  return ("R_CR16_SWITCH32");
  case_29: /* CIL Label */ 
#line 57
  return ("R_CR16_GOT_REGREL20");
  case_30: /* CIL Label */ 
#line 58
  return ("R_CR16_GOTC_REGREL20");
  case_31: /* CIL Label */ 
#line 59
  return ("R_CR16_GLOB_DAT");
  switch_default: /* CIL Label */ 
#line 60
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/cris.h"
static char const   *elf_cris_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/cris.h"
static char const   *elf_cris_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 35
  if (rtype == 4UL) {
#line 35
    goto case_4;
  }
#line 36
  if (rtype == 5UL) {
#line 36
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 39
  if (rtype == 7UL) {
#line 39
    goto case_7;
  }
#line 40
  if (rtype == 8UL) {
#line 40
    goto case_8;
  }
#line 44
  if (rtype == 9UL) {
#line 44
    goto case_9;
  }
#line 48
  if (rtype == 10UL) {
#line 48
    goto case_10;
  }
#line 52
  if (rtype == 11UL) {
#line 52
    goto case_11;
  }
#line 56
  if (rtype == 12UL) {
#line 56
    goto case_12;
  }
#line 61
  if (rtype == 13UL) {
#line 61
    goto case_13;
  }
#line 66
  if (rtype == 14UL) {
#line 66
    goto case_14;
  }
#line 71
  if (rtype == 15UL) {
#line 71
    goto case_15;
  }
#line 76
  if (rtype == 16UL) {
#line 76
    goto case_16;
  }
#line 81
  if (rtype == 17UL) {
#line 81
    goto case_17;
  }
#line 86
  if (rtype == 18UL) {
#line 86
    goto case_18;
  }
#line 92
  if (rtype == 19UL) {
#line 92
    goto case_19;
  }
#line 99
  if (rtype == 20UL) {
#line 99
    goto case_20;
  }
#line 107
  if (rtype == 21UL) {
#line 107
    goto case_21;
  }
#line 112
  if (rtype == 22UL) {
#line 112
    goto case_22;
  }
#line 118
  if (rtype == 23UL) {
#line 118
    goto case_23;
  }
#line 127
  if (rtype == 24UL) {
#line 127
    goto case_24;
  }
#line 134
  if (rtype == 25UL) {
#line 134
    goto case_25;
  }
#line 141
  if (rtype == 26UL) {
#line 141
    goto case_26;
  }
#line 146
  if (rtype == 27UL) {
#line 146
    goto case_27;
  }
#line 153
  if (rtype == 28UL) {
#line 153
    goto case_28;
  }
#line 162
  if (rtype == 29UL) {
#line 162
    goto case_29;
  }
#line 167
  if (rtype == 30UL) {
#line 167
    goto case_30;
  }
#line 172
  if (rtype == 31UL) {
#line 172
    goto case_31;
  }
#line 176
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_CRIS_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_CRIS_8");
  case_2: /* CIL Label */ 
#line 31
  return ("R_CRIS_16");
  case_3: /* CIL Label */ 
#line 32
  return ("R_CRIS_32");
  case_4: /* CIL Label */ 
#line 35
  return ("R_CRIS_8_PCREL");
  case_5: /* CIL Label */ 
#line 36
  return ("R_CRIS_16_PCREL");
  case_6: /* CIL Label */ 
#line 37
  return ("R_CRIS_32_PCREL");
  case_7: /* CIL Label */ 
#line 39
  return ("R_CRIS_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 40
  return ("R_CRIS_GNU_VTENTRY");
  case_9: /* CIL Label */ 
#line 44
  return ("R_CRIS_COPY");
  case_10: /* CIL Label */ 
#line 48
  return ("R_CRIS_GLOB_DAT");
  case_11: /* CIL Label */ 
#line 52
  return ("R_CRIS_JUMP_SLOT");
  case_12: /* CIL Label */ 
#line 56
  return ("R_CRIS_RELATIVE");
  case_13: /* CIL Label */ 
#line 61
  return ("R_CRIS_16_GOT");
  case_14: /* CIL Label */ 
#line 66
  return ("R_CRIS_32_GOT");
  case_15: /* CIL Label */ 
#line 71
  return ("R_CRIS_16_GOTPLT");
  case_16: /* CIL Label */ 
#line 76
  return ("R_CRIS_32_GOTPLT");
  case_17: /* CIL Label */ 
#line 81
  return ("R_CRIS_32_GOTREL");
  case_18: /* CIL Label */ 
#line 86
  return ("R_CRIS_32_PLT_GOTREL");
  case_19: /* CIL Label */ 
#line 92
  return ("R_CRIS_32_PLT_PCREL");
  case_20: /* CIL Label */ 
#line 99
  return ("R_CRIS_32_GOT_GD");
  case_21: /* CIL Label */ 
#line 107
  return ("R_CRIS_16_GOT_GD");
  case_22: /* CIL Label */ 
#line 112
  return ("R_CRIS_32_GD");
  case_23: /* CIL Label */ 
#line 118
  return ("R_CRIS_DTP");
  case_24: /* CIL Label */ 
#line 127
  return ("R_CRIS_32_DTPREL");
  case_25: /* CIL Label */ 
#line 134
  return ("R_CRIS_16_DTPREL");
  case_26: /* CIL Label */ 
#line 141
  return ("R_CRIS_32_GOT_TPREL");
  case_27: /* CIL Label */ 
#line 146
  return ("R_CRIS_16_GOT_TPREL");
  case_28: /* CIL Label */ 
#line 153
  return ("R_CRIS_32_TPREL");
  case_29: /* CIL Label */ 
#line 162
  return ("R_CRIS_16_TPREL");
  case_30: /* CIL Label */ 
#line 167
  return ("R_CRIS_DTPMOD");
  case_31: /* CIL Label */ 
#line 172
  return ("R_CRIS_32_IE");
  switch_default: /* CIL Label */ 
#line 176
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/crx.h"
static char const   *elf_crx_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/crx.h"
static char const   *elf_crx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 39
  if (rtype == 9UL) {
#line 39
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 13UL) {
#line 43
    goto case_13;
  }
#line 44
  if (rtype == 14UL) {
#line 44
    goto case_14;
  }
#line 45
  if (rtype == 15UL) {
#line 45
    goto case_15;
  }
#line 46
  if (rtype == 16UL) {
#line 46
    goto case_16;
  }
#line 47
  if (rtype == 17UL) {
#line 47
    goto case_17;
  }
#line 48
  if (rtype == 18UL) {
#line 48
    goto case_18;
  }
#line 49
  if (rtype == 19UL) {
#line 49
    goto case_19;
  }
#line 50
  if (rtype == 20UL) {
#line 50
    goto case_20;
  }
#line 51
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_CRX_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_CRX_REL4");
  case_2: /* CIL Label */ 
#line 32
  return ("R_CRX_REL8");
  case_3: /* CIL Label */ 
#line 33
  return ("R_CRX_REL8_CMP");
  case_4: /* CIL Label */ 
#line 34
  return ("R_CRX_REL16");
  case_5: /* CIL Label */ 
#line 35
  return ("R_CRX_REL24");
  case_6: /* CIL Label */ 
#line 36
  return ("R_CRX_REL32");
  case_7: /* CIL Label */ 
#line 37
  return ("R_CRX_REGREL12");
  case_8: /* CIL Label */ 
#line 38
  return ("R_CRX_REGREL22");
  case_9: /* CIL Label */ 
#line 39
  return ("R_CRX_REGREL28");
  case_10: /* CIL Label */ 
#line 40
  return ("R_CRX_REGREL32");
  case_11: /* CIL Label */ 
#line 41
  return ("R_CRX_ABS16");
  case_12: /* CIL Label */ 
#line 42
  return ("R_CRX_ABS32");
  case_13: /* CIL Label */ 
#line 43
  return ("R_CRX_NUM8");
  case_14: /* CIL Label */ 
#line 44
  return ("R_CRX_NUM16");
  case_15: /* CIL Label */ 
#line 45
  return ("R_CRX_NUM32");
  case_16: /* CIL Label */ 
#line 46
  return ("R_CRX_IMM16");
  case_17: /* CIL Label */ 
#line 47
  return ("R_CRX_IMM32");
  case_18: /* CIL Label */ 
#line 48
  return ("R_CRX_SWITCH8");
  case_19: /* CIL Label */ 
#line 49
  return ("R_CRX_SWITCH16");
  case_20: /* CIL Label */ 
#line 50
  return ("R_CRX_SWITCH32");
  switch_default: /* CIL Label */ 
#line 51
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/d10v.h"
static char const   *elf_d10v_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/d10v.h"
static char const   *elf_d10v_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_D10V_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_D10V_10_PCREL_R");
  case_2: /* CIL Label */ 
#line 29
  return ("R_D10V_10_PCREL_L");
  case_3: /* CIL Label */ 
#line 30
  return ("R_D10V_16");
  case_4: /* CIL Label */ 
#line 31
  return ("R_D10V_18");
  case_5: /* CIL Label */ 
#line 32
  return ("R_D10V_18_PCREL");
  case_6: /* CIL Label */ 
#line 33
  return ("R_D10V_32");
  case_7: /* CIL Label */ 
#line 34
  return ("R_D10V_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 35
  return ("R_D10V_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 36
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/d30v.h"
static char const   *elf_d30v_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/d30v.h"
static char const   *elf_d30v_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_D30V_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_D30V_6");
  case_2: /* CIL Label */ 
#line 29
  return ("R_D30V_9_PCREL");
  case_3: /* CIL Label */ 
#line 30
  return ("R_D30V_9_PCREL_R");
  case_4: /* CIL Label */ 
#line 31
  return ("R_D30V_15");
  case_5: /* CIL Label */ 
#line 32
  return ("R_D30V_15_PCREL");
  case_6: /* CIL Label */ 
#line 33
  return ("R_D30V_15_PCREL_R");
  case_7: /* CIL Label */ 
#line 34
  return ("R_D30V_21");
  case_8: /* CIL Label */ 
#line 35
  return ("R_D30V_21_PCREL");
  case_9: /* CIL Label */ 
#line 36
  return ("R_D30V_21_PCREL_R");
  case_10: /* CIL Label */ 
#line 37
  return ("R_D30V_32");
  case_11: /* CIL Label */ 
#line 38
  return ("R_D30V_32_PCREL");
  case_12: /* CIL Label */ 
#line 39
  return ("R_D30V_32_NORMAL");
  switch_default: /* CIL Label */ 
#line 40
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 39 "./../include/elf/dlx.h"
static char const   *elf_dlx_reloc_type(unsigned long rtype ) ;
#line 39 "./../include/elf/dlx.h"
static char const   *elf_dlx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 40
  if (rtype == 0UL) {
#line 40
    goto case_0;
  }
#line 41
  if (rtype == 1UL) {
#line 41
    goto case_1;
  }
#line 42
  if (rtype == 2UL) {
#line 42
    goto case_2;
  }
#line 43
  if (rtype == 3UL) {
#line 43
    goto case_3;
  }
#line 44
  if (rtype == 4UL) {
#line 44
    goto case_4;
  }
#line 45
  if (rtype == 5UL) {
#line 45
    goto case_5;
  }
#line 46
  if (rtype == 6UL) {
#line 46
    goto case_6;
  }
#line 47
  if (rtype == 7UL) {
#line 47
    goto case_7;
  }
#line 48
  if (rtype == 8UL) {
#line 48
    goto case_8;
  }
#line 49
  if (rtype == 9UL) {
#line 49
    goto case_9;
  }
#line 50
  goto switch_default;
  case_0: /* CIL Label */ 
#line 40
  return ("R_DLX_NONE");
  case_1: /* CIL Label */ 
#line 41
  return ("R_DLX_RELOC_8");
  case_2: /* CIL Label */ 
#line 42
  return ("R_DLX_RELOC_16");
  case_3: /* CIL Label */ 
#line 43
  return ("R_DLX_RELOC_32");
  case_4: /* CIL Label */ 
#line 44
  return ("R_DLX_GNU_VTINHERIT");
  case_5: /* CIL Label */ 
#line 45
  return ("R_DLX_GNU_VTENTRY");
  case_6: /* CIL Label */ 
#line 46
  return ("R_DLX_RELOC_16_HI");
  case_7: /* CIL Label */ 
#line 47
  return ("R_DLX_RELOC_16_LO");
  case_8: /* CIL Label */ 
#line 48
  return ("R_DLX_RELOC_16_PCREL");
  case_9: /* CIL Label */ 
#line 49
  return ("R_DLX_RELOC_26_PCREL");
  switch_default: /* CIL Label */ 
#line 50
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/epiphany.h"
static char const   *elf_epiphany_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/epiphany.h"
static char const   *elf_epiphany_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 36
  if (rtype == 4UL) {
#line 36
    goto case_4;
  }
#line 37
  if (rtype == 5UL) {
#line 37
    goto case_5;
  }
#line 38
  if (rtype == 6UL) {
#line 38
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 50
  if (rtype == 11UL) {
#line 50
    goto case_11;
  }
#line 52
  if (rtype == 12UL) {
#line 52
    goto case_12;
  }
#line 55
  if (rtype == 13UL) {
#line 55
    goto case_13;
  }
#line 57
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_EPIPHANY_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_EPIPHANY_8");
  case_2: /* CIL Label */ 
#line 32
  return ("R_EPIPHANY_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_EPIPHANY_32");
  case_4: /* CIL Label */ 
#line 36
  return ("R_EPIPHANY_8_PCREL");
  case_5: /* CIL Label */ 
#line 37
  return ("R_EPIPHANY_16_PCREL");
  case_6: /* CIL Label */ 
#line 38
  return ("R_EPIPHANY_32_PCREL");
  case_7: /* CIL Label */ 
#line 41
  return ("R_EPIPHANY_SIMM8");
  case_8: /* CIL Label */ 
#line 42
  return ("R_EPIPHANY_SIMM24");
  case_9: /* CIL Label */ 
#line 46
  return ("R_EPIPHANY_HIGH");
  case_10: /* CIL Label */ 
#line 47
  return ("R_EPIPHANY_LOW");
  case_11: /* CIL Label */ 
#line 50
  return ("R_EPIPHANY_SIMM11");
  case_12: /* CIL Label */ 
#line 52
  return ("R_EPIPHANY_IMM11");
  case_13: /* CIL Label */ 
#line 55
  return ("R_EPIPHANY_IMM8");
  switch_default: /* CIL Label */ 
#line 57
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/fr30.h"
static char const   *elf_fr30_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/fr30.h"
static char const   *elf_fr30_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_FR30_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_FR30_8");
  case_2: /* CIL Label */ 
#line 29
  return ("R_FR30_20");
  case_3: /* CIL Label */ 
#line 30
  return ("R_FR30_32");
  case_4: /* CIL Label */ 
#line 31
  return ("R_FR30_48");
  case_5: /* CIL Label */ 
#line 32
  return ("R_FR30_6_IN_4");
  case_6: /* CIL Label */ 
#line 33
  return ("R_FR30_8_IN_8");
  case_7: /* CIL Label */ 
#line 34
  return ("R_FR30_9_IN_8");
  case_8: /* CIL Label */ 
#line 35
  return ("R_FR30_10_IN_8");
  case_9: /* CIL Label */ 
#line 36
  return ("R_FR30_9_PCREL");
  case_10: /* CIL Label */ 
#line 37
  return ("R_FR30_12_PCREL");
  case_11: /* CIL Label */ 
#line 38
  return ("R_FR30_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 39
  return ("R_FR30_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 40
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/frv.h"
static char const   *elf_frv_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/frv.h"
static char const   *elf_frv_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  if (rtype == 13UL) {
#line 40
    goto case_13;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  if (rtype == 15UL) {
#line 42
    goto case_15;
  }
#line 43
  if (rtype == 16UL) {
#line 43
    goto case_16;
  }
#line 44
  if (rtype == 17UL) {
#line 44
    goto case_17;
  }
#line 45
  if (rtype == 18UL) {
#line 45
    goto case_18;
  }
#line 46
  if (rtype == 19UL) {
#line 46
    goto case_19;
  }
#line 47
  if (rtype == 20UL) {
#line 47
    goto case_20;
  }
#line 48
  if (rtype == 21UL) {
#line 48
    goto case_21;
  }
#line 49
  if (rtype == 22UL) {
#line 49
    goto case_22;
  }
#line 50
  if (rtype == 23UL) {
#line 50
    goto case_23;
  }
#line 51
  if (rtype == 24UL) {
#line 51
    goto case_24;
  }
#line 52
  if (rtype == 25UL) {
#line 52
    goto case_25;
  }
#line 53
  if (rtype == 26UL) {
#line 53
    goto case_26;
  }
#line 54
  if (rtype == 27UL) {
#line 54
    goto case_27;
  }
#line 55
  if (rtype == 28UL) {
#line 55
    goto case_28;
  }
#line 56
  if (rtype == 29UL) {
#line 56
    goto case_29;
  }
#line 57
  if (rtype == 30UL) {
#line 57
    goto case_30;
  }
#line 58
  if (rtype == 31UL) {
#line 58
    goto case_31;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 61
  if (rtype == 34UL) {
#line 61
    goto case_34;
  }
#line 62
  if (rtype == 35UL) {
#line 62
    goto case_35;
  }
#line 63
  if (rtype == 36UL) {
#line 63
    goto case_36;
  }
#line 64
  if (rtype == 37UL) {
#line 64
    goto case_37;
  }
#line 65
  if (rtype == 38UL) {
#line 65
    goto case_38;
  }
#line 66
  if (rtype == 39UL) {
#line 66
    goto case_39;
  }
#line 67
  if (rtype == 40UL) {
#line 67
    goto case_40;
  }
#line 68
  if (rtype == 200UL) {
#line 68
    goto case_200;
  }
#line 69
  if (rtype == 201UL) {
#line 69
    goto case_201;
  }
#line 70
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_FRV_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_FRV_32");
  case_2: /* CIL Label */ 
#line 29
  return ("R_FRV_LABEL16");
  case_3: /* CIL Label */ 
#line 30
  return ("R_FRV_LABEL24");
  case_4: /* CIL Label */ 
#line 31
  return ("R_FRV_LO16");
  case_5: /* CIL Label */ 
#line 32
  return ("R_FRV_HI16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_FRV_GPREL12");
  case_7: /* CIL Label */ 
#line 34
  return ("R_FRV_GPRELU12");
  case_8: /* CIL Label */ 
#line 35
  return ("R_FRV_GPREL32");
  case_9: /* CIL Label */ 
#line 36
  return ("R_FRV_GPRELHI");
  case_10: /* CIL Label */ 
#line 37
  return ("R_FRV_GPRELLO");
  case_11: /* CIL Label */ 
#line 38
  return ("R_FRV_GOT12");
  case_12: /* CIL Label */ 
#line 39
  return ("R_FRV_GOTHI");
  case_13: /* CIL Label */ 
#line 40
  return ("R_FRV_GOTLO");
  case_14: /* CIL Label */ 
#line 41
  return ("R_FRV_FUNCDESC");
  case_15: /* CIL Label */ 
#line 42
  return ("R_FRV_FUNCDESC_GOT12");
  case_16: /* CIL Label */ 
#line 43
  return ("R_FRV_FUNCDESC_GOTHI");
  case_17: /* CIL Label */ 
#line 44
  return ("R_FRV_FUNCDESC_GOTLO");
  case_18: /* CIL Label */ 
#line 45
  return ("R_FRV_FUNCDESC_VALUE");
  case_19: /* CIL Label */ 
#line 46
  return ("R_FRV_FUNCDESC_GOTOFF12");
  case_20: /* CIL Label */ 
#line 47
  return ("R_FRV_FUNCDESC_GOTOFFHI");
  case_21: /* CIL Label */ 
#line 48
  return ("R_FRV_FUNCDESC_GOTOFFLO");
  case_22: /* CIL Label */ 
#line 49
  return ("R_FRV_GOTOFF12");
  case_23: /* CIL Label */ 
#line 50
  return ("R_FRV_GOTOFFHI");
  case_24: /* CIL Label */ 
#line 51
  return ("R_FRV_GOTOFFLO");
  case_25: /* CIL Label */ 
#line 52
  return ("R_FRV_GETTLSOFF");
  case_26: /* CIL Label */ 
#line 53
  return ("R_FRV_TLSDESC_VALUE");
  case_27: /* CIL Label */ 
#line 54
  return ("R_FRV_GOTTLSDESC12");
  case_28: /* CIL Label */ 
#line 55
  return ("R_FRV_GOTTLSDESCHI");
  case_29: /* CIL Label */ 
#line 56
  return ("R_FRV_GOTTLSDESCLO");
  case_30: /* CIL Label */ 
#line 57
  return ("R_FRV_TLSMOFF12");
  case_31: /* CIL Label */ 
#line 58
  return ("R_FRV_TLSMOFFHI");
  case_32: /* CIL Label */ 
#line 59
  return ("R_FRV_TLSMOFFLO");
  case_33: /* CIL Label */ 
#line 60
  return ("R_FRV_GOTTLSOFF12");
  case_34: /* CIL Label */ 
#line 61
  return ("R_FRV_GOTTLSOFFHI");
  case_35: /* CIL Label */ 
#line 62
  return ("R_FRV_GOTTLSOFFLO");
  case_36: /* CIL Label */ 
#line 63
  return ("R_FRV_TLSOFF");
  case_37: /* CIL Label */ 
#line 64
  return ("R_FRV_TLSDESC_RELAX");
  case_38: /* CIL Label */ 
#line 65
  return ("R_FRV_GETTLSOFF_RELAX");
  case_39: /* CIL Label */ 
#line 66
  return ("R_FRV_TLSOFF_RELAX");
  case_40: /* CIL Label */ 
#line 67
  return ("R_FRV_TLSMOFF");
  case_200: /* CIL Label */ 
#line 68
  return ("R_FRV_GNU_VTINHERIT");
  case_201: /* CIL Label */ 
#line 69
  return ("R_FRV_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 70
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/h8.h"
static char const   *elf_h8_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/h8.h"
static char const   *elf_h8_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  if (rtype == 13UL) {
#line 40
    goto case_13;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  if (rtype == 15UL) {
#line 42
    goto case_15;
  }
#line 43
  if (rtype == 16UL) {
#line 43
    goto case_16;
  }
#line 44
  if (rtype == 17UL) {
#line 44
    goto case_17;
  }
#line 45
  if (rtype == 18UL) {
#line 45
    goto case_18;
  }
#line 46
  if (rtype == 19UL) {
#line 46
    goto case_19;
  }
#line 47
  if (rtype == 20UL) {
#line 47
    goto case_20;
  }
#line 48
  if (rtype == 21UL) {
#line 48
    goto case_21;
  }
#line 49
  if (rtype == 22UL) {
#line 49
    goto case_22;
  }
#line 50
  if (rtype == 23UL) {
#line 50
    goto case_23;
  }
#line 51
  if (rtype == 24UL) {
#line 51
    goto case_24;
  }
#line 52
  if (rtype == 25UL) {
#line 52
    goto case_25;
  }
#line 53
  if (rtype == 26UL) {
#line 53
    goto case_26;
  }
#line 54
  if (rtype == 27UL) {
#line 54
    goto case_27;
  }
#line 55
  if (rtype == 28UL) {
#line 55
    goto case_28;
  }
#line 56
  if (rtype == 29UL) {
#line 56
    goto case_29;
  }
#line 57
  if (rtype == 30UL) {
#line 57
    goto case_30;
  }
#line 58
  if (rtype == 31UL) {
#line 58
    goto case_31;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 63
  if (rtype == 59UL) {
#line 63
    goto case_59;
  }
#line 64
  if (rtype == 60UL) {
#line 64
    goto case_60;
  }
#line 65
  if (rtype == 61UL) {
#line 65
    goto case_61;
  }
#line 66
  if (rtype == 62UL) {
#line 66
    goto case_62;
  }
#line 67
  if (rtype == 63UL) {
#line 67
    goto case_63;
  }
#line 68
  if (rtype == 65UL) {
#line 68
    goto case_65;
  }
#line 69
  if (rtype == 127UL) {
#line 69
    goto case_127;
  }
#line 70
  if (rtype == 128UL) {
#line 70
    goto case_128;
  }
#line 71
  if (rtype == 129UL) {
#line 71
    goto case_129;
  }
#line 72
  if (rtype == 130UL) {
#line 72
    goto case_130;
  }
#line 73
  if (rtype == 131UL) {
#line 73
    goto case_131;
  }
#line 74
  if (rtype == 132UL) {
#line 74
    goto case_132;
  }
#line 75
  if (rtype == 133UL) {
#line 75
    goto case_133;
  }
#line 76
  if (rtype == 134UL) {
#line 76
    goto case_134;
  }
#line 77
  if (rtype == 135UL) {
#line 77
    goto case_135;
  }
#line 78
  if (rtype == 136UL) {
#line 78
    goto case_136;
  }
#line 79
  if (rtype == 137UL) {
#line 79
    goto case_137;
  }
#line 80
  if (rtype == 138UL) {
#line 80
    goto case_138;
  }
#line 81
  if (rtype == 139UL) {
#line 81
    goto case_139;
  }
#line 82
  if (rtype == 140UL) {
#line 82
    goto case_140;
  }
#line 83
  if (rtype == 141UL) {
#line 83
    goto case_141;
  }
#line 84
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_H8_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_H8_DIR32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_H8_DIR32_28");
  case_3: /* CIL Label */ 
#line 31
  return ("R_H8_DIR32_24");
  case_4: /* CIL Label */ 
#line 32
  return ("R_H8_DIR32_16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_H8_DIR32U");
  case_7: /* CIL Label */ 
#line 34
  return ("R_H8_DIR32U_28");
  case_8: /* CIL Label */ 
#line 35
  return ("R_H8_DIR32U_24");
  case_9: /* CIL Label */ 
#line 36
  return ("R_H8_DIR32U_20");
  case_10: /* CIL Label */ 
#line 37
  return ("R_H8_DIR32U_16");
  case_11: /* CIL Label */ 
#line 38
  return ("R_H8_DIR24");
  case_12: /* CIL Label */ 
#line 39
  return ("R_H8_DIR24_20");
  case_13: /* CIL Label */ 
#line 40
  return ("R_H8_DIR24_16");
  case_14: /* CIL Label */ 
#line 41
  return ("R_H8_DIR24U");
  case_15: /* CIL Label */ 
#line 42
  return ("R_H8_DIR24U_20");
  case_16: /* CIL Label */ 
#line 43
  return ("R_H8_DIR24U_16");
  case_17: /* CIL Label */ 
#line 44
  return ("R_H8_DIR16");
  case_18: /* CIL Label */ 
#line 45
  return ("R_H8_DIR16U");
  case_19: /* CIL Label */ 
#line 46
  return ("R_H8_DIR16S_32");
  case_20: /* CIL Label */ 
#line 47
  return ("R_H8_DIR16S_28");
  case_21: /* CIL Label */ 
#line 48
  return ("R_H8_DIR16S_24");
  case_22: /* CIL Label */ 
#line 49
  return ("R_H8_DIR16S_20");
  case_23: /* CIL Label */ 
#line 50
  return ("R_H8_DIR16S");
  case_24: /* CIL Label */ 
#line 51
  return ("R_H8_DIR8");
  case_25: /* CIL Label */ 
#line 52
  return ("R_H8_DIR8U");
  case_26: /* CIL Label */ 
#line 53
  return ("R_H8_DIR8Z_32");
  case_27: /* CIL Label */ 
#line 54
  return ("R_H8_DIR8Z_28");
  case_28: /* CIL Label */ 
#line 55
  return ("R_H8_DIR8Z_24");
  case_29: /* CIL Label */ 
#line 56
  return ("R_H8_DIR8Z_20");
  case_30: /* CIL Label */ 
#line 57
  return ("R_H8_DIR8Z_16");
  case_31: /* CIL Label */ 
#line 58
  return ("R_H8_PCREL16");
  case_32: /* CIL Label */ 
#line 59
  return ("R_H8_PCREL8");
  case_33: /* CIL Label */ 
#line 60
  return ("R_H8_BPOS");
  case_59: /* CIL Label */ 
#line 63
  return ("R_H8_DIR16A8");
  case_60: /* CIL Label */ 
#line 64
  return ("R_H8_DIR16R8");
  case_61: /* CIL Label */ 
#line 65
  return ("R_H8_DIR24A8");
  case_62: /* CIL Label */ 
#line 66
  return ("R_H8_DIR24R8");
  case_63: /* CIL Label */ 
#line 67
  return ("R_H8_DIR32A16");
  case_65: /* CIL Label */ 
#line 68
  return ("R_H8_ABS32");
  case_127: /* CIL Label */ 
#line 69
  return ("R_H8_ABS32A16");
  case_128: /* CIL Label */ 
#line 70
  return ("R_H8_SYM");
  case_129: /* CIL Label */ 
#line 71
  return ("R_H8_OPneg");
  case_130: /* CIL Label */ 
#line 72
  return ("R_H8_OPadd");
  case_131: /* CIL Label */ 
#line 73
  return ("R_H8_OPsub");
  case_132: /* CIL Label */ 
#line 74
  return ("R_H8_OPmul");
  case_133: /* CIL Label */ 
#line 75
  return ("R_H8_OPdiv");
  case_134: /* CIL Label */ 
#line 76
  return ("R_H8_OPshla");
  case_135: /* CIL Label */ 
#line 77
  return ("R_H8_OPshra");
  case_136: /* CIL Label */ 
#line 78
  return ("R_H8_OPsctsize");
  case_137: /* CIL Label */ 
#line 79
  return ("R_H8_OPhword");
  case_138: /* CIL Label */ 
#line 80
  return ("R_H8_OPlword");
  case_139: /* CIL Label */ 
#line 81
  return ("R_H8_OPhigh");
  case_140: /* CIL Label */ 
#line 82
  return ("R_H8_OPlow");
  case_141: /* CIL Label */ 
#line 83
  return ("R_H8_OPscttop");
  switch_default: /* CIL Label */ 
#line 84
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 111 "./../include/elf/hppa.h"
static char const   *elf_hppa_reloc_type(unsigned long rtype ) ;
#line 111 "./../include/elf/hppa.h"
static char const   *elf_hppa_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 112
  if (rtype == 0UL) {
#line 112
    goto case_0;
  }
#line 116
  if (rtype == 1UL) {
#line 116
    goto case_1;
  }
#line 119
  if (rtype == 2UL) {
#line 119
    goto case_2;
  }
#line 122
  if (rtype == 3UL) {
#line 122
    goto case_3;
  }
#line 125
  if (rtype == 4UL) {
#line 125
    goto case_4;
  }
#line 128
  if (rtype == 6UL) {
#line 128
    goto case_6;
  }
#line 131
  if (rtype == 7UL) {
#line 131
    goto case_7;
  }
#line 148
  if (rtype == 8UL) {
#line 148
    goto case_8;
  }
#line 151
  if (rtype == 9UL) {
#line 151
    goto case_9;
  }
#line 154
  if (rtype == 10UL) {
#line 154
    goto case_10;
  }
#line 157
  if (rtype == 11UL) {
#line 157
    goto case_11;
  }
#line 160
  if (rtype == 12UL) {
#line 160
    goto case_12;
  }
#line 163
  if (rtype == 13UL) {
#line 163
    goto case_13;
  }
#line 166
  if (rtype == 14UL) {
#line 166
    goto case_14;
  }
#line 169
  if (rtype == 15UL) {
#line 169
    goto case_15;
  }
#line 174
  if (rtype == 18UL) {
#line 174
    goto case_18;
  }
#line 177
  if (rtype == 19UL) {
#line 177
    goto case_19;
  }
#line 180
  if (rtype == 20UL) {
#line 180
    goto case_20;
  }
#line 183
  if (rtype == 22UL) {
#line 183
    goto case_22;
  }
#line 186
  if (rtype == 23UL) {
#line 186
    goto case_23;
  }
#line 196
  if (rtype == 26UL) {
#line 196
    goto case_26;
  }
#line 199
  if (rtype == 30UL) {
#line 199
    goto case_30;
  }
#line 202
  if (rtype == 31UL) {
#line 202
    goto case_31;
  }
#line 207
  if (rtype == 34UL) {
#line 207
    goto case_34;
  }
#line 210
  if (rtype == 38UL) {
#line 210
    goto case_38;
  }
#line 213
  if (rtype == 39UL) {
#line 213
    goto case_39;
  }
#line 218
  if (rtype == 40UL) {
#line 218
    goto case_40;
  }
#line 221
  if (rtype == 41UL) {
#line 221
    goto case_41;
  }
#line 224
  if (rtype == 42UL) {
#line 224
    goto case_42;
  }
#line 227
  if (rtype == 43UL) {
#line 227
    goto case_43;
  }
#line 230
  if (rtype == 44UL) {
#line 230
    goto case_44;
  }
#line 233
  if (rtype == 46UL) {
#line 233
    goto case_46;
  }
#line 236
  if (rtype == 47UL) {
#line 236
    goto case_47;
  }
#line 241
  if (rtype == 48UL) {
#line 241
    goto case_48;
  }
#line 244
  if (rtype == 49UL) {
#line 244
    goto case_49;
  }
#line 249
  if (rtype == 50UL) {
#line 249
    goto case_50;
  }
#line 252
  if (rtype == 54UL) {
#line 252
    goto case_54;
  }
#line 255
  if (rtype == 55UL) {
#line 255
    goto case_55;
  }
#line 259
  if (rtype == 57UL) {
#line 259
    goto case_57;
  }
#line 262
  if (rtype == 58UL) {
#line 262
    goto case_58;
  }
#line 265
  if (rtype == 62UL) {
#line 265
    goto case_62;
  }
#line 269
  if (rtype == 64UL) {
#line 269
    goto case_64;
  }
#line 274
  if (rtype == 65UL) {
#line 274
    goto case_65;
  }
#line 277
  if (rtype == 66UL) {
#line 277
    goto case_66;
  }
#line 280
  if (rtype == 70UL) {
#line 280
    goto case_70;
  }
#line 285
  if (rtype == 72UL) {
#line 285
    goto case_72;
  }
#line 288
  if (rtype == 73UL) {
#line 288
    goto case_73;
  }
#line 291
  if (rtype == 74UL) {
#line 291
    goto case_74;
  }
#line 294
  if (rtype == 75UL) {
#line 294
    goto case_75;
  }
#line 297
  if (rtype == 76UL) {
#line 297
    goto case_76;
  }
#line 300
  if (rtype == 77UL) {
#line 300
    goto case_77;
  }
#line 303
  if (rtype == 78UL) {
#line 303
    goto case_78;
  }
#line 306
  if (rtype == 79UL) {
#line 306
    goto case_79;
  }
#line 310
  if (rtype == 80UL) {
#line 310
    goto case_80;
  }
#line 313
  if (rtype == 83UL) {
#line 313
    goto case_83;
  }
#line 316
  if (rtype == 84UL) {
#line 316
    goto case_84;
  }
#line 319
  if (rtype == 85UL) {
#line 319
    goto case_85;
  }
#line 322
  if (rtype == 86UL) {
#line 322
    goto case_86;
  }
#line 325
  if (rtype == 87UL) {
#line 325
    goto case_87;
  }
#line 328
  if (rtype == 88UL) {
#line 328
    goto case_88;
  }
#line 331
  if (rtype == 91UL) {
#line 331
    goto case_91;
  }
#line 334
  if (rtype == 92UL) {
#line 334
    goto case_92;
  }
#line 337
  if (rtype == 93UL) {
#line 337
    goto case_93;
  }
#line 340
  if (rtype == 94UL) {
#line 340
    goto case_94;
  }
#line 343
  if (rtype == 95UL) {
#line 343
    goto case_95;
  }
#line 347
  if (rtype == 96UL) {
#line 347
    goto case_96;
  }
#line 350
  if (rtype == 99UL) {
#line 350
    goto case_99;
  }
#line 353
  if (rtype == 100UL) {
#line 353
    goto case_100;
  }
#line 356
  if (rtype == 101UL) {
#line 356
    goto case_101;
  }
#line 359
  if (rtype == 102UL) {
#line 359
    goto case_102;
  }
#line 362
  if (rtype == 103UL) {
#line 362
    goto case_103;
  }
#line 366
  if (rtype == 104UL) {
#line 366
    goto case_104;
  }
#line 369
  if (rtype == 107UL) {
#line 369
    goto case_107;
  }
#line 372
  if (rtype == 108UL) {
#line 372
    goto case_108;
  }
#line 376
  if (rtype == 112UL) {
#line 376
    goto case_112;
  }
#line 379
  if (rtype == 115UL) {
#line 379
    goto case_115;
  }
#line 382
  if (rtype == 116UL) {
#line 382
    goto case_116;
  }
#line 385
  if (rtype == 117UL) {
#line 385
    goto case_117;
  }
#line 388
  if (rtype == 118UL) {
#line 388
    goto case_118;
  }
#line 391
  if (rtype == 119UL) {
#line 391
    goto case_119;
  }
#line 395
  if (rtype == 120UL) {
#line 395
    goto case_120;
  }
#line 398
  if (rtype == 123UL) {
#line 398
    goto case_123;
  }
#line 401
  if (rtype == 124UL) {
#line 401
    goto case_124;
  }
#line 404
  if (rtype == 125UL) {
#line 404
    goto case_125;
  }
#line 407
  if (rtype == 126UL) {
#line 407
    goto case_126;
  }
#line 410
  if (rtype == 127UL) {
#line 410
    goto case_127;
  }
#line 414
  if (rtype == 128UL) {
#line 414
    goto case_128;
  }
#line 417
  if (rtype == 129UL) {
#line 417
    goto case_129;
  }
#line 420
  if (rtype == 130UL) {
#line 420
    goto case_130;
  }
#line 424
  if (rtype == 153UL) {
#line 424
    goto case_153;
  }
#line 427
  if (rtype == 154UL) {
#line 427
    goto case_154;
  }
#line 430
  if (rtype == 158UL) {
#line 430
    goto case_158;
  }
#line 434
  if (rtype == 162UL) {
#line 434
    goto case_162;
  }
#line 437
  if (rtype == 166UL) {
#line 437
    goto case_166;
  }
#line 440
  if (rtype == 167UL) {
#line 440
    goto case_167;
  }
#line 444
  if (rtype == 216UL) {
#line 444
    goto case_216;
  }
#line 447
  if (rtype == 219UL) {
#line 447
    goto case_219;
  }
#line 450
  if (rtype == 220UL) {
#line 450
    goto case_220;
  }
#line 453
  if (rtype == 221UL) {
#line 453
    goto case_221;
  }
#line 456
  if (rtype == 222UL) {
#line 456
    goto case_222;
  }
#line 459
  if (rtype == 223UL) {
#line 459
    goto case_223;
  }
#line 463
  if (rtype == 224UL) {
#line 463
    goto case_224;
  }
#line 466
  if (rtype == 227UL) {
#line 466
    goto case_227;
  }
#line 469
  if (rtype == 228UL) {
#line 469
    goto case_228;
  }
#line 472
  if (rtype == 229UL) {
#line 472
    goto case_229;
  }
#line 475
  if (rtype == 230UL) {
#line 475
    goto case_230;
  }
#line 478
  if (rtype == 231UL) {
#line 478
    goto case_231;
  }
#line 481
  if (rtype == 232UL) {
#line 481
    goto case_232;
  }
#line 482
  if (rtype == 233UL) {
#line 482
    goto case_233;
  }
#line 484
  if (rtype == 234UL) {
#line 484
    goto case_234;
  }
#line 485
  if (rtype == 235UL) {
#line 485
    goto case_235;
  }
#line 486
  if (rtype == 236UL) {
#line 486
    goto case_236;
  }
#line 487
  if (rtype == 237UL) {
#line 487
    goto case_237;
  }
#line 488
  if (rtype == 238UL) {
#line 488
    goto case_238;
  }
#line 489
  if (rtype == 239UL) {
#line 489
    goto case_239;
  }
#line 490
  if (rtype == 240UL) {
#line 490
    goto case_240;
  }
#line 491
  if (rtype == 241UL) {
#line 491
    goto case_241;
  }
#line 492
  if (rtype == 242UL) {
#line 492
    goto case_242;
  }
#line 493
  if (rtype == 243UL) {
#line 493
    goto case_243;
  }
#line 494
  if (rtype == 244UL) {
#line 494
    goto case_244;
  }
#line 495
  if (rtype == 245UL) {
#line 495
    goto case_245;
  }
#line 497
  goto switch_default;
  case_0: /* CIL Label */ 
#line 112
  return ("R_PARISC_NONE");
  case_1: /* CIL Label */ 
#line 116
  return ("R_PARISC_DIR32");
  case_2: /* CIL Label */ 
#line 119
  return ("R_PARISC_DIR21L");
  case_3: /* CIL Label */ 
#line 122
  return ("R_PARISC_DIR17R");
  case_4: /* CIL Label */ 
#line 125
  return ("R_PARISC_DIR17F");
  case_6: /* CIL Label */ 
#line 128
  return ("R_PARISC_DIR14R");
  case_7: /* CIL Label */ 
#line 131
  return ("R_PARISC_DIR14F");
  case_8: /* CIL Label */ 
#line 148
  return ("R_PARISC_PCREL12F");
  case_9: /* CIL Label */ 
#line 151
  return ("R_PARISC_PCREL32");
  case_10: /* CIL Label */ 
#line 154
  return ("R_PARISC_PCREL21L");
  case_11: /* CIL Label */ 
#line 157
  return ("R_PARISC_PCREL17R");
  case_12: /* CIL Label */ 
#line 160
  return ("R_PARISC_PCREL17F");
  case_13: /* CIL Label */ 
#line 163
  return ("R_PARISC_PCREL17C");
  case_14: /* CIL Label */ 
#line 166
  return ("R_PARISC_PCREL14R");
  case_15: /* CIL Label */ 
#line 169
  return ("R_PARISC_PCREL14F");
  case_18: /* CIL Label */ 
#line 174
  return ("R_PARISC_DPREL21L");
  case_19: /* CIL Label */ 
#line 177
  return ("R_PARISC_DPREL14WR");
  case_20: /* CIL Label */ 
#line 180
  return ("R_PARISC_DPREL14DR");
  case_22: /* CIL Label */ 
#line 183
  return ("R_PARISC_DPREL14R");
  case_23: /* CIL Label */ 
#line 186
  return ("R_PARISC_DPREL14F");
  case_26: /* CIL Label */ 
#line 196
  return ("R_PARISC_DLTREL21L");
  case_30: /* CIL Label */ 
#line 199
  return ("R_PARISC_DLTREL14R");
  case_31: /* CIL Label */ 
#line 202
  return ("R_PARISC_DLTREL14F");
  case_34: /* CIL Label */ 
#line 207
  return ("R_PARISC_DLTIND21L");
  case_38: /* CIL Label */ 
#line 210
  return ("R_PARISC_DLTIND14R");
  case_39: /* CIL Label */ 
#line 213
  return ("R_PARISC_DLTIND14F");
  case_40: /* CIL Label */ 
#line 218
  return ("R_PARISC_SETBASE");
  case_41: /* CIL Label */ 
#line 221
  return ("R_PARISC_SECREL32");
  case_42: /* CIL Label */ 
#line 224
  return ("R_PARISC_BASEREL21L");
  case_43: /* CIL Label */ 
#line 227
  return ("R_PARISC_BASEREL17R");
  case_44: /* CIL Label */ 
#line 230
  return ("R_PARISC_BASEREL17F");
  case_46: /* CIL Label */ 
#line 233
  return ("R_PARISC_BASEREL14R");
  case_47: /* CIL Label */ 
#line 236
  return ("R_PARISC_BASEREL14F");
  case_48: /* CIL Label */ 
#line 241
  return ("R_PARISC_SEGBASE");
  case_49: /* CIL Label */ 
#line 244
  return ("R_PARISC_SEGREL32");
  case_50: /* CIL Label */ 
#line 249
  return ("R_PARISC_PLTOFF21L");
  case_54: /* CIL Label */ 
#line 252
  return ("R_PARISC_PLTOFF14R");
  case_55: /* CIL Label */ 
#line 255
  return ("R_PARISC_PLTOFF14F");
  case_57: /* CIL Label */ 
#line 259
  return ("R_PARISC_LTOFF_FPTR32");
  case_58: /* CIL Label */ 
#line 262
  return ("R_PARISC_LTOFF_FPTR21L");
  case_62: /* CIL Label */ 
#line 265
  return ("R_PARISC_LTOFF_FPTR14R");
  case_64: /* CIL Label */ 
#line 269
  return ("R_PARISC_FPTR64");
  case_65: /* CIL Label */ 
#line 274
  return ("R_PARISC_PLABEL32");
  case_66: /* CIL Label */ 
#line 277
  return ("R_PARISC_PLABEL21L");
  case_70: /* CIL Label */ 
#line 280
  return ("R_PARISC_PLABEL14R");
  case_72: /* CIL Label */ 
#line 285
  return ("R_PARISC_PCREL64");
  case_73: /* CIL Label */ 
#line 288
  return ("R_PARISC_PCREL22C");
  case_74: /* CIL Label */ 
#line 291
  return ("R_PARISC_PCREL22F");
  case_75: /* CIL Label */ 
#line 294
  return ("R_PARISC_PCREL14WR");
  case_76: /* CIL Label */ 
#line 297
  return ("R_PARISC_PCREL14DR");
  case_77: /* CIL Label */ 
#line 300
  return ("R_PARISC_PCREL16F");
  case_78: /* CIL Label */ 
#line 303
  return ("R_PARISC_PCREL16WF");
  case_79: /* CIL Label */ 
#line 306
  return ("R_PARISC_PCREL16DF");
  case_80: /* CIL Label */ 
#line 310
  return ("R_PARISC_DIR64");
  case_83: /* CIL Label */ 
#line 313
  return ("R_PARISC_DIR14WR");
  case_84: /* CIL Label */ 
#line 316
  return ("R_PARISC_DIR14DR");
  case_85: /* CIL Label */ 
#line 319
  return ("R_PARISC_DIR16F");
  case_86: /* CIL Label */ 
#line 322
  return ("R_PARISC_DIR16WF");
  case_87: /* CIL Label */ 
#line 325
  return ("R_PARISC_DIR16DF");
  case_88: /* CIL Label */ 
#line 328
  return ("R_PARISC_GPREL64");
  case_91: /* CIL Label */ 
#line 331
  return ("R_PARISC_DLTREL14WR");
  case_92: /* CIL Label */ 
#line 334
  return ("R_PARISC_DLTREL14DR");
  case_93: /* CIL Label */ 
#line 337
  return ("R_PARISC_GPREL16F");
  case_94: /* CIL Label */ 
#line 340
  return ("R_PARISC_GPREL16WF");
  case_95: /* CIL Label */ 
#line 343
  return ("R_PARISC_GPREL16DF");
  case_96: /* CIL Label */ 
#line 347
  return ("R_PARISC_LTOFF64");
  case_99: /* CIL Label */ 
#line 350
  return ("R_PARISC_DLTIND14WR");
  case_100: /* CIL Label */ 
#line 353
  return ("R_PARISC_DLTIND14DR");
  case_101: /* CIL Label */ 
#line 356
  return ("R_PARISC_LTOFF16F");
  case_102: /* CIL Label */ 
#line 359
  return ("R_PARISC_LTOFF16WF");
  case_103: /* CIL Label */ 
#line 362
  return ("R_PARISC_LTOFF16DF");
  case_104: /* CIL Label */ 
#line 366
  return ("R_PARISC_SECREL64");
  case_107: /* CIL Label */ 
#line 369
  return ("R_PARISC_BASEREL14WR");
  case_108: /* CIL Label */ 
#line 372
  return ("R_PARISC_BASEREL14DR");
  case_112: /* CIL Label */ 
#line 376
  return ("R_PARISC_SEGREL64");
  case_115: /* CIL Label */ 
#line 379
  return ("R_PARISC_PLTOFF14WR");
  case_116: /* CIL Label */ 
#line 382
  return ("R_PARISC_PLTOFF14DR");
  case_117: /* CIL Label */ 
#line 385
  return ("R_PARISC_PLTOFF16F");
  case_118: /* CIL Label */ 
#line 388
  return ("R_PARISC_PLTOFF16WF");
  case_119: /* CIL Label */ 
#line 391
  return ("R_PARISC_PLTOFF16DF");
  case_120: /* CIL Label */ 
#line 395
  return ("R_PARISC_LTOFF_FPTR64");
  case_123: /* CIL Label */ 
#line 398
  return ("R_PARISC_LTOFF_FPTR14WR");
  case_124: /* CIL Label */ 
#line 401
  return ("R_PARISC_LTOFF_FPTR14DR");
  case_125: /* CIL Label */ 
#line 404
  return ("R_PARISC_LTOFF_FPTR16F");
  case_126: /* CIL Label */ 
#line 407
  return ("R_PARISC_LTOFF_FPTR16WF");
  case_127: /* CIL Label */ 
#line 410
  return ("R_PARISC_LTOFF_FPTR16DF");
  case_128: /* CIL Label */ 
#line 414
  return ("R_PARISC_COPY");
  case_129: /* CIL Label */ 
#line 417
  return ("R_PARISC_IPLT");
  case_130: /* CIL Label */ 
#line 420
  return ("R_PARISC_EPLT");
  case_153: /* CIL Label */ 
#line 424
  return ("R_PARISC_TPREL32");
  case_154: /* CIL Label */ 
#line 427
  return ("R_PARISC_TPREL21L");
  case_158: /* CIL Label */ 
#line 430
  return ("R_PARISC_TPREL14R");
  case_162: /* CIL Label */ 
#line 434
  return ("R_PARISC_LTOFF_TP21L");
  case_166: /* CIL Label */ 
#line 437
  return ("R_PARISC_LTOFF_TP14R");
  case_167: /* CIL Label */ 
#line 440
  return ("R_PARISC_LTOFF_TP14F");
  case_216: /* CIL Label */ 
#line 444
  return ("R_PARISC_TPREL64");
  case_219: /* CIL Label */ 
#line 447
  return ("R_PARISC_TPREL14WR");
  case_220: /* CIL Label */ 
#line 450
  return ("R_PARISC_TPREL14DR");
  case_221: /* CIL Label */ 
#line 453
  return ("R_PARISC_TPREL16F");
  case_222: /* CIL Label */ 
#line 456
  return ("R_PARISC_TPREL16WF");
  case_223: /* CIL Label */ 
#line 459
  return ("R_PARISC_TPREL16DF");
  case_224: /* CIL Label */ 
#line 463
  return ("R_PARISC_LTOFF_TP64");
  case_227: /* CIL Label */ 
#line 466
  return ("R_PARISC_LTOFF_TP14WR");
  case_228: /* CIL Label */ 
#line 469
  return ("R_PARISC_LTOFF_TP14DR");
  case_229: /* CIL Label */ 
#line 472
  return ("R_PARISC_LTOFF_TP16F");
  case_230: /* CIL Label */ 
#line 475
  return ("R_PARISC_LTOFF_TP16WF");
  case_231: /* CIL Label */ 
#line 478
  return ("R_PARISC_LTOFF_TP16DF");
  case_232: /* CIL Label */ 
#line 481
  return ("R_PARISC_GNU_VTENTRY");
  case_233: /* CIL Label */ 
#line 482
  return ("R_PARISC_GNU_VTINHERIT");
  case_234: /* CIL Label */ 
#line 484
  return ("R_PARISC_TLS_GD21L");
  case_235: /* CIL Label */ 
#line 485
  return ("R_PARISC_TLS_GD14R");
  case_236: /* CIL Label */ 
#line 486
  return ("R_PARISC_TLS_GDCALL");
  case_237: /* CIL Label */ 
#line 487
  return ("R_PARISC_TLS_LDM21L");
  case_238: /* CIL Label */ 
#line 488
  return ("R_PARISC_TLS_LDM14R");
  case_239: /* CIL Label */ 
#line 489
  return ("R_PARISC_TLS_LDMCALL");
  case_240: /* CIL Label */ 
#line 490
  return ("R_PARISC_TLS_LDO21L");
  case_241: /* CIL Label */ 
#line 491
  return ("R_PARISC_TLS_LDO14R");
  case_242: /* CIL Label */ 
#line 492
  return ("R_PARISC_TLS_DTPMOD32");
  case_243: /* CIL Label */ 
#line 493
  return ("R_PARISC_TLS_DTPMOD64");
  case_244: /* CIL Label */ 
#line 494
  return ("R_PARISC_TLS_DTPOFF32");
  case_245: /* CIL Label */ 
#line 495
  return ("R_PARISC_TLS_DTPOFF64");
  switch_default: /* CIL Label */ 
#line 497
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/i386.h"
static char const   *elf_i386_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/i386.h"
static char const   *elf_i386_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  if (rtype == 15UL) {
#line 42
    goto case_15;
  }
#line 43
  if (rtype == 16UL) {
#line 43
    goto case_16;
  }
#line 44
  if (rtype == 17UL) {
#line 44
    goto case_17;
  }
#line 45
  if (rtype == 18UL) {
#line 45
    goto case_18;
  }
#line 46
  if (rtype == 19UL) {
#line 46
    goto case_19;
  }
#line 47
  if (rtype == 20UL) {
#line 47
    goto case_20;
  }
#line 48
  if (rtype == 21UL) {
#line 48
    goto case_21;
  }
#line 49
  if (rtype == 22UL) {
#line 49
    goto case_22;
  }
#line 50
  if (rtype == 23UL) {
#line 50
    goto case_23;
  }
#line 51
  if (rtype == 24UL) {
#line 51
    goto case_24;
  }
#line 52
  if (rtype == 25UL) {
#line 52
    goto case_25;
  }
#line 53
  if (rtype == 26UL) {
#line 53
    goto case_26;
  }
#line 54
  if (rtype == 27UL) {
#line 54
    goto case_27;
  }
#line 55
  if (rtype == 28UL) {
#line 55
    goto case_28;
  }
#line 56
  if (rtype == 29UL) {
#line 56
    goto case_29;
  }
#line 57
  if (rtype == 30UL) {
#line 57
    goto case_30;
  }
#line 58
  if (rtype == 31UL) {
#line 58
    goto case_31;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 61
  if (rtype == 34UL) {
#line 61
    goto case_34;
  }
#line 62
  if (rtype == 35UL) {
#line 62
    goto case_35;
  }
#line 63
  if (rtype == 36UL) {
#line 63
    goto case_36;
  }
#line 64
  if (rtype == 37UL) {
#line 64
    goto case_37;
  }
#line 66
  if (rtype == 39UL) {
#line 66
    goto case_39;
  }
#line 67
  if (rtype == 40UL) {
#line 67
    goto case_40;
  }
#line 68
  if (rtype == 41UL) {
#line 68
    goto case_41;
  }
#line 69
  if (rtype == 42UL) {
#line 69
    goto case_42;
  }
#line 72
  if (rtype == 200UL) {
#line 72
    goto case_200;
  }
#line 75
  if (rtype == 250UL) {
#line 75
    goto case_250;
  }
#line 76
  if (rtype == 251UL) {
#line 76
    goto case_251;
  }
#line 77
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_386_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_386_32");
  case_2: /* CIL Label */ 
#line 29
  return ("R_386_PC32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_386_GOT32");
  case_4: /* CIL Label */ 
#line 31
  return ("R_386_PLT32");
  case_5: /* CIL Label */ 
#line 32
  return ("R_386_COPY");
  case_6: /* CIL Label */ 
#line 33
  return ("R_386_GLOB_DAT");
  case_7: /* CIL Label */ 
#line 34
  return ("R_386_JUMP_SLOT");
  case_8: /* CIL Label */ 
#line 35
  return ("R_386_RELATIVE");
  case_9: /* CIL Label */ 
#line 36
  return ("R_386_GOTOFF");
  case_10: /* CIL Label */ 
#line 37
  return ("R_386_GOTPC");
  case_11: /* CIL Label */ 
#line 38
  return ("R_386_32PLT");
  case_14: /* CIL Label */ 
#line 41
  return ("R_386_TLS_TPOFF");
  case_15: /* CIL Label */ 
#line 42
  return ("R_386_TLS_IE");
  case_16: /* CIL Label */ 
#line 43
  return ("R_386_TLS_GOTIE");
  case_17: /* CIL Label */ 
#line 44
  return ("R_386_TLS_LE");
  case_18: /* CIL Label */ 
#line 45
  return ("R_386_TLS_GD");
  case_19: /* CIL Label */ 
#line 46
  return ("R_386_TLS_LDM");
  case_20: /* CIL Label */ 
#line 47
  return ("R_386_16");
  case_21: /* CIL Label */ 
#line 48
  return ("R_386_PC16");
  case_22: /* CIL Label */ 
#line 49
  return ("R_386_8");
  case_23: /* CIL Label */ 
#line 50
  return ("R_386_PC8");
  case_24: /* CIL Label */ 
#line 51
  return ("R_386_TLS_GD_32");
  case_25: /* CIL Label */ 
#line 52
  return ("R_386_TLS_GD_PUSH");
  case_26: /* CIL Label */ 
#line 53
  return ("R_386_TLS_GD_CALL");
  case_27: /* CIL Label */ 
#line 54
  return ("R_386_TLS_GD_POP");
  case_28: /* CIL Label */ 
#line 55
  return ("R_386_TLS_LDM_32");
  case_29: /* CIL Label */ 
#line 56
  return ("R_386_TLS_LDM_PUSH");
  case_30: /* CIL Label */ 
#line 57
  return ("R_386_TLS_LDM_CALL");
  case_31: /* CIL Label */ 
#line 58
  return ("R_386_TLS_LDM_POP");
  case_32: /* CIL Label */ 
#line 59
  return ("R_386_TLS_LDO_32");
  case_33: /* CIL Label */ 
#line 60
  return ("R_386_TLS_IE_32");
  case_34: /* CIL Label */ 
#line 61
  return ("R_386_TLS_LE_32");
  case_35: /* CIL Label */ 
#line 62
  return ("R_386_TLS_DTPMOD32");
  case_36: /* CIL Label */ 
#line 63
  return ("R_386_TLS_DTPOFF32");
  case_37: /* CIL Label */ 
#line 64
  return ("R_386_TLS_TPOFF32");
  case_39: /* CIL Label */ 
#line 66
  return ("R_386_TLS_GOTDESC");
  case_40: /* CIL Label */ 
#line 67
  return ("R_386_TLS_DESC_CALL");
  case_41: /* CIL Label */ 
#line 68
  return ("R_386_TLS_DESC");
  case_42: /* CIL Label */ 
#line 69
  return ("R_386_IRELATIVE");
  case_200: /* CIL Label */ 
#line 72
  return ("R_386_USED_BY_INTEL_200");
  case_250: /* CIL Label */ 
#line 75
  return ("R_386_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 76
  return ("R_386_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 77
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 46 "./../include/elf/i370.h"
static char const   *i370_reloc_type(unsigned long rtype ) ;
#line 46 "./../include/elf/i370.h"
static char const   *i370_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 47
  if (rtype == 0UL) {
#line 47
    goto case_0;
  }
#line 48
  if (rtype == 1UL) {
#line 48
    goto case_1;
  }
#line 49
  if (rtype == 2UL) {
#line 49
    goto case_2;
  }
#line 50
  if (rtype == 3UL) {
#line 50
    goto case_3;
  }
#line 51
  if (rtype == 4UL) {
#line 51
    goto case_4;
  }
#line 52
  if (rtype == 5UL) {
#line 52
    goto case_5;
  }
#line 53
  if (rtype == 6UL) {
#line 53
    goto case_6;
  }
#line 54
  if (rtype == 7UL) {
#line 54
    goto case_7;
  }
#line 55
  if (rtype == 8UL) {
#line 55
    goto case_8;
  }
#line 56
  if (rtype == 9UL) {
#line 56
    goto case_9;
  }
#line 57
  if (rtype == 10UL) {
#line 57
    goto case_10;
  }
#line 58
  if (rtype == 11UL) {
#line 58
    goto case_11;
  }
#line 59
  goto switch_default;
  case_0: /* CIL Label */ 
#line 47
  return ("R_I370_NONE");
  case_1: /* CIL Label */ 
#line 48
  return ("R_I370_ADDR31");
  case_2: /* CIL Label */ 
#line 49
  return ("R_I370_ADDR32");
  case_3: /* CIL Label */ 
#line 50
  return ("R_I370_ADDR16");
  case_4: /* CIL Label */ 
#line 51
  return ("R_I370_REL31");
  case_5: /* CIL Label */ 
#line 52
  return ("R_I370_REL32");
  case_6: /* CIL Label */ 
#line 53
  return ("R_I370_ADDR12");
  case_7: /* CIL Label */ 
#line 54
  return ("R_I370_REL12");
  case_8: /* CIL Label */ 
#line 55
  return ("R_I370_ADDR8");
  case_9: /* CIL Label */ 
#line 56
  return ("R_I370_REL8");
  case_10: /* CIL Label */ 
#line 57
  return ("R_I370_COPY");
  case_11: /* CIL Label */ 
#line 58
  return ("R_I370_RELATIVE");
  switch_default: /* CIL Label */ 
#line 59
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/i860.h"
static char const   *elf_i860_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/i860.h"
static char const   *elf_i860_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 48UL) {
#line 36
    goto case_48;
  }
#line 37
  if (rtype == 49UL) {
#line 37
    goto case_49;
  }
#line 38
  if (rtype == 50UL) {
#line 38
    goto case_50;
  }
#line 39
  if (rtype == 64UL) {
#line 39
    goto case_64;
  }
#line 40
  if (rtype == 66UL) {
#line 40
    goto case_66;
  }
#line 41
  if (rtype == 68UL) {
#line 41
    goto case_68;
  }
#line 42
  if (rtype == 70UL) {
#line 42
    goto case_70;
  }
#line 43
  if (rtype == 72UL) {
#line 43
    goto case_72;
  }
#line 44
  if (rtype == 74UL) {
#line 44
    goto case_74;
  }
#line 45
  if (rtype == 76UL) {
#line 45
    goto case_76;
  }
#line 46
  if (rtype == 80UL) {
#line 46
    goto case_80;
  }
#line 47
  if (rtype == 82UL) {
#line 47
    goto case_82;
  }
#line 48
  if (rtype == 84UL) {
#line 48
    goto case_84;
  }
#line 49
  if (rtype == 86UL) {
#line 49
    goto case_86;
  }
#line 50
  if (rtype == 96UL) {
#line 50
    goto case_96;
  }
#line 51
  if (rtype == 98UL) {
#line 51
    goto case_98;
  }
#line 52
  if (rtype == 100UL) {
#line 52
    goto case_100;
  }
#line 53
  if (rtype == 102UL) {
#line 53
    goto case_102;
  }
#line 54
  if (rtype == 104UL) {
#line 54
    goto case_104;
  }
#line 55
  if (rtype == 108UL) {
#line 55
    goto case_108;
  }
#line 56
  if (rtype == 112UL) {
#line 56
    goto case_112;
  }
#line 57
  if (rtype == 128UL) {
#line 57
    goto case_128;
  }
#line 58
  if (rtype == 144UL) {
#line 58
    goto case_144;
  }
#line 59
  if (rtype == 160UL) {
#line 59
    goto case_160;
  }
#line 60
  if (rtype == 176UL) {
#line 60
    goto case_176;
  }
#line 61
  if (rtype == 192UL) {
#line 61
    goto case_192;
  }
#line 62
  if (rtype == 208UL) {
#line 62
    goto case_208;
  }
#line 63
  if (rtype == 224UL) {
#line 63
    goto case_224;
  }
#line 64
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_860_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_860_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_860_COPY");
  case_3: /* CIL Label */ 
#line 33
  return ("R_860_GLOB_DAT");
  case_4: /* CIL Label */ 
#line 34
  return ("R_860_JUMP_SLOT");
  case_5: /* CIL Label */ 
#line 35
  return ("R_860_RELATIVE");
  case_48: /* CIL Label */ 
#line 36
  return ("R_860_PC26");
  case_49: /* CIL Label */ 
#line 37
  return ("R_860_PLT26");
  case_50: /* CIL Label */ 
#line 38
  return ("R_860_PC16");
  case_64: /* CIL Label */ 
#line 39
  return ("R_860_LOW0");
  case_66: /* CIL Label */ 
#line 40
  return ("R_860_SPLIT0");
  case_68: /* CIL Label */ 
#line 41
  return ("R_860_LOW1");
  case_70: /* CIL Label */ 
#line 42
  return ("R_860_SPLIT1");
  case_72: /* CIL Label */ 
#line 43
  return ("R_860_LOW2");
  case_74: /* CIL Label */ 
#line 44
  return ("R_860_SPLIT2");
  case_76: /* CIL Label */ 
#line 45
  return ("R_860_LOW3");
  case_80: /* CIL Label */ 
#line 46
  return ("R_860_LOGOT0");
  case_82: /* CIL Label */ 
#line 47
  return ("R_860_SPGOT0");
  case_84: /* CIL Label */ 
#line 48
  return ("R_860_LOGOT1");
  case_86: /* CIL Label */ 
#line 49
  return ("R_860_SPGOT1");
  case_96: /* CIL Label */ 
#line 50
  return ("R_860_LOGOTOFF0");
  case_98: /* CIL Label */ 
#line 51
  return ("R_860_SPGOTOFF0");
  case_100: /* CIL Label */ 
#line 52
  return ("R_860_LOGOTOFF1");
  case_102: /* CIL Label */ 
#line 53
  return ("R_860_SPGOTOFF1");
  case_104: /* CIL Label */ 
#line 54
  return ("R_860_LOGOTOFF2");
  case_108: /* CIL Label */ 
#line 55
  return ("R_860_LOGOTOFF3");
  case_112: /* CIL Label */ 
#line 56
  return ("R_860_LOPC");
  case_128: /* CIL Label */ 
#line 57
  return ("R_860_HIGHADJ");
  case_144: /* CIL Label */ 
#line 58
  return ("R_860_HAGOT");
  case_160: /* CIL Label */ 
#line 59
  return ("R_860_HAGOTOFF");
  case_176: /* CIL Label */ 
#line 60
  return ("R_860_HAPC");
  case_192: /* CIL Label */ 
#line 61
  return ("R_860_HIGH");
  case_208: /* CIL Label */ 
#line 62
  return ("R_860_HIGOT");
  case_224: /* CIL Label */ 
#line 63
  return ("R_860_HIGOTOFF");
  switch_default: /* CIL Label */ 
#line 64
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/i960.h"
static char const   *elf_i960_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/i960.h"
static char const   *elf_i960_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_960_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_960_12");
  case_2: /* CIL Label */ 
#line 29
  return ("R_960_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_960_IP24");
  case_4: /* CIL Label */ 
#line 31
  return ("R_960_SUB");
  case_5: /* CIL Label */ 
#line 32
  return ("R_960_OPTCALL");
  case_6: /* CIL Label */ 
#line 33
  return ("R_960_OPTCALLX");
  case_7: /* CIL Label */ 
#line 34
  return ("R_960_OPTCALLXA");
  switch_default: /* CIL Label */ 
#line 35
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 284 "./../include/elf/ia64.h"
static char const   *elf_ia64_reloc_type(unsigned long rtype ) ;
#line 284 "./../include/elf/ia64.h"
static char const   *elf_ia64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 285
  if (rtype == 0UL) {
#line 285
    goto case_0;
  }
#line 287
  if (rtype == 33UL) {
#line 287
    goto case_33;
  }
#line 288
  if (rtype == 34UL) {
#line 288
    goto case_34;
  }
#line 289
  if (rtype == 35UL) {
#line 289
    goto case_35;
  }
#line 290
  if (rtype == 36UL) {
#line 290
    goto case_36;
  }
#line 291
  if (rtype == 37UL) {
#line 291
    goto case_37;
  }
#line 292
  if (rtype == 38UL) {
#line 292
    goto case_38;
  }
#line 293
  if (rtype == 39UL) {
#line 293
    goto case_39;
  }
#line 295
  if (rtype == 42UL) {
#line 295
    goto case_42;
  }
#line 296
  if (rtype == 43UL) {
#line 296
    goto case_43;
  }
#line 297
  if (rtype == 44UL) {
#line 297
    goto case_44;
  }
#line 298
  if (rtype == 45UL) {
#line 298
    goto case_45;
  }
#line 299
  if (rtype == 46UL) {
#line 299
    goto case_46;
  }
#line 300
  if (rtype == 47UL) {
#line 300
    goto case_47;
  }
#line 302
  if (rtype == 50UL) {
#line 302
    goto case_50;
  }
#line 303
  if (rtype == 51UL) {
#line 303
    goto case_51;
  }
#line 305
  if (rtype == 58UL) {
#line 305
    goto case_58;
  }
#line 306
  if (rtype == 59UL) {
#line 306
    goto case_59;
  }
#line 307
  if (rtype == 62UL) {
#line 307
    goto case_62;
  }
#line 308
  if (rtype == 63UL) {
#line 308
    goto case_63;
  }
#line 310
  if (rtype == 67UL) {
#line 310
    goto case_67;
  }
#line 311
  if (rtype == 68UL) {
#line 311
    goto case_68;
  }
#line 312
  if (rtype == 69UL) {
#line 312
    goto case_69;
  }
#line 313
  if (rtype == 70UL) {
#line 313
    goto case_70;
  }
#line 314
  if (rtype == 71UL) {
#line 314
    goto case_71;
  }
#line 316
  if (rtype == 72UL) {
#line 316
    goto case_72;
  }
#line 317
  if (rtype == 73UL) {
#line 317
    goto case_73;
  }
#line 318
  if (rtype == 74UL) {
#line 318
    goto case_74;
  }
#line 319
  if (rtype == 75UL) {
#line 319
    goto case_75;
  }
#line 320
  if (rtype == 76UL) {
#line 320
    goto case_76;
  }
#line 321
  if (rtype == 77UL) {
#line 321
    goto case_77;
  }
#line 322
  if (rtype == 78UL) {
#line 322
    goto case_78;
  }
#line 323
  if (rtype == 79UL) {
#line 323
    goto case_79;
  }
#line 325
  if (rtype == 82UL) {
#line 325
    goto case_82;
  }
#line 326
  if (rtype == 83UL) {
#line 326
    goto case_83;
  }
#line 327
  if (rtype == 84UL) {
#line 327
    goto case_84;
  }
#line 328
  if (rtype == 85UL) {
#line 328
    goto case_85;
  }
#line 329
  if (rtype == 86UL) {
#line 329
    goto case_86;
  }
#line 330
  if (rtype == 87UL) {
#line 330
    goto case_87;
  }
#line 332
  if (rtype == 92UL) {
#line 332
    goto case_92;
  }
#line 333
  if (rtype == 93UL) {
#line 333
    goto case_93;
  }
#line 334
  if (rtype == 94UL) {
#line 334
    goto case_94;
  }
#line 335
  if (rtype == 95UL) {
#line 335
    goto case_95;
  }
#line 337
  if (rtype == 100UL) {
#line 337
    goto case_100;
  }
#line 338
  if (rtype == 101UL) {
#line 338
    goto case_101;
  }
#line 339
  if (rtype == 102UL) {
#line 339
    goto case_102;
  }
#line 340
  if (rtype == 103UL) {
#line 340
    goto case_103;
  }
#line 342
  if (rtype == 108UL) {
#line 342
    goto case_108;
  }
#line 343
  if (rtype == 109UL) {
#line 343
    goto case_109;
  }
#line 344
  if (rtype == 110UL) {
#line 344
    goto case_110;
  }
#line 345
  if (rtype == 111UL) {
#line 345
    goto case_111;
  }
#line 347
  if (rtype == 116UL) {
#line 347
    goto case_116;
  }
#line 348
  if (rtype == 117UL) {
#line 348
    goto case_117;
  }
#line 349
  if (rtype == 118UL) {
#line 349
    goto case_118;
  }
#line 350
  if (rtype == 119UL) {
#line 350
    goto case_119;
  }
#line 352
  if (rtype == 121UL) {
#line 352
    goto case_121;
  }
#line 353
  if (rtype == 122UL) {
#line 353
    goto case_122;
  }
#line 354
  if (rtype == 123UL) {
#line 354
    goto case_123;
  }
#line 356
  if (rtype == 128UL) {
#line 356
    goto case_128;
  }
#line 357
  if (rtype == 129UL) {
#line 357
    goto case_129;
  }
#line 358
  if (rtype == 132UL) {
#line 358
    goto case_132;
  }
#line 359
  if (rtype == 134UL) {
#line 359
    goto case_134;
  }
#line 360
  if (rtype == 135UL) {
#line 360
    goto case_135;
  }
#line 362
  if (rtype == 145UL) {
#line 362
    goto case_145;
  }
#line 363
  if (rtype == 146UL) {
#line 363
    goto case_146;
  }
#line 364
  if (rtype == 147UL) {
#line 364
    goto case_147;
  }
#line 365
  if (rtype == 150UL) {
#line 365
    goto case_150;
  }
#line 366
  if (rtype == 151UL) {
#line 366
    goto case_151;
  }
#line 368
  if (rtype == 154UL) {
#line 368
    goto case_154;
  }
#line 370
  if (rtype == 166UL) {
#line 370
    goto case_166;
  }
#line 371
  if (rtype == 167UL) {
#line 371
    goto case_167;
  }
#line 372
  if (rtype == 170UL) {
#line 372
    goto case_170;
  }
#line 374
  if (rtype == 177UL) {
#line 374
    goto case_177;
  }
#line 375
  if (rtype == 178UL) {
#line 375
    goto case_178;
  }
#line 376
  if (rtype == 179UL) {
#line 376
    goto case_179;
  }
#line 377
  if (rtype == 180UL) {
#line 377
    goto case_180;
  }
#line 378
  if (rtype == 181UL) {
#line 378
    goto case_181;
  }
#line 379
  if (rtype == 182UL) {
#line 379
    goto case_182;
  }
#line 380
  if (rtype == 183UL) {
#line 380
    goto case_183;
  }
#line 382
  if (rtype == 186UL) {
#line 382
    goto case_186;
  }
#line 387
  if (rtype == 1879048192UL) {
#line 387
    goto case_1879048192;
  }
#line 388
  if (rtype == 1879048193UL) {
#line 388
    goto case_1879048193;
  }
#line 389
  if (rtype == 1879048194UL) {
#line 389
    goto case_1879048194;
  }
#line 390
  if (rtype == 1879048195UL) {
#line 390
    goto case_1879048195;
  }
#line 391
  if (rtype == 1879048196UL) {
#line 391
    goto case_1879048196;
  }
#line 392
  if (rtype == 1879048197UL) {
#line 392
    goto case_1879048197;
  }
#line 393
  if (rtype == 1879048198UL) {
#line 393
    goto case_1879048198;
  }
#line 394
  if (rtype == 1879048199UL) {
#line 394
    goto case_1879048199;
  }
#line 395
  if (rtype == 1879048200UL) {
#line 395
    goto case_1879048200;
  }
#line 396
  if (rtype == 1879048201UL) {
#line 396
    goto case_1879048201;
  }
#line 397
  if (rtype == 1879048202UL) {
#line 397
    goto case_1879048202;
  }
#line 398
  if (rtype == 1879048203UL) {
#line 398
    goto case_1879048203;
  }
#line 399
  if (rtype == 1879048204UL) {
#line 399
    goto case_1879048204;
  }
#line 400
  if (rtype == 1879048205UL) {
#line 400
    goto case_1879048205;
  }
#line 401
  if (rtype == 1879048206UL) {
#line 401
    goto case_1879048206;
  }
#line 402
  if (rtype == 1879048207UL) {
#line 402
    goto case_1879048207;
  }
#line 403
  if (rtype == 1879048208UL) {
#line 403
    goto case_1879048208;
  }
#line 404
  if (rtype == 1879048209UL) {
#line 404
    goto case_1879048209;
  }
#line 405
  if (rtype == 1879048210UL) {
#line 405
    goto case_1879048210;
  }
#line 406
  if (rtype == 1879048212UL) {
#line 406
    goto case_1879048212;
  }
#line 407
  if (rtype == 1879048213UL) {
#line 407
    goto case_1879048213;
  }
#line 408
  if (rtype == 1879048214UL) {
#line 408
    goto case_1879048214;
  }
#line 409
  if (rtype == 1879048215UL) {
#line 409
    goto case_1879048215;
  }
#line 410
  goto switch_default;
  case_0: /* CIL Label */ 
#line 285
  return ("R_IA64_NONE");
  case_33: /* CIL Label */ 
#line 287
  return ("R_IA64_IMM14");
  case_34: /* CIL Label */ 
#line 288
  return ("R_IA64_IMM22");
  case_35: /* CIL Label */ 
#line 289
  return ("R_IA64_IMM64");
  case_36: /* CIL Label */ 
#line 290
  return ("R_IA64_DIR32MSB");
  case_37: /* CIL Label */ 
#line 291
  return ("R_IA64_DIR32LSB");
  case_38: /* CIL Label */ 
#line 292
  return ("R_IA64_DIR64MSB");
  case_39: /* CIL Label */ 
#line 293
  return ("R_IA64_DIR64LSB");
  case_42: /* CIL Label */ 
#line 295
  return ("R_IA64_GPREL22");
  case_43: /* CIL Label */ 
#line 296
  return ("R_IA64_GPREL64I");
  case_44: /* CIL Label */ 
#line 297
  return ("R_IA64_GPREL32MSB");
  case_45: /* CIL Label */ 
#line 298
  return ("R_IA64_GPREL32LSB");
  case_46: /* CIL Label */ 
#line 299
  return ("R_IA64_GPREL64MSB");
  case_47: /* CIL Label */ 
#line 300
  return ("R_IA64_GPREL64LSB");
  case_50: /* CIL Label */ 
#line 302
  return ("R_IA64_LTOFF22");
  case_51: /* CIL Label */ 
#line 303
  return ("R_IA64_LTOFF64I");
  case_58: /* CIL Label */ 
#line 305
  return ("R_IA64_PLTOFF22");
  case_59: /* CIL Label */ 
#line 306
  return ("R_IA64_PLTOFF64I");
  case_62: /* CIL Label */ 
#line 307
  return ("R_IA64_PLTOFF64MSB");
  case_63: /* CIL Label */ 
#line 308
  return ("R_IA64_PLTOFF64LSB");
  case_67: /* CIL Label */ 
#line 310
  return ("R_IA64_FPTR64I");
  case_68: /* CIL Label */ 
#line 311
  return ("R_IA64_FPTR32MSB");
  case_69: /* CIL Label */ 
#line 312
  return ("R_IA64_FPTR32LSB");
  case_70: /* CIL Label */ 
#line 313
  return ("R_IA64_FPTR64MSB");
  case_71: /* CIL Label */ 
#line 314
  return ("R_IA64_FPTR64LSB");
  case_72: /* CIL Label */ 
#line 316
  return ("R_IA64_PCREL60B");
  case_73: /* CIL Label */ 
#line 317
  return ("R_IA64_PCREL21B");
  case_74: /* CIL Label */ 
#line 318
  return ("R_IA64_PCREL21M");
  case_75: /* CIL Label */ 
#line 319
  return ("R_IA64_PCREL21F");
  case_76: /* CIL Label */ 
#line 320
  return ("R_IA64_PCREL32MSB");
  case_77: /* CIL Label */ 
#line 321
  return ("R_IA64_PCREL32LSB");
  case_78: /* CIL Label */ 
#line 322
  return ("R_IA64_PCREL64MSB");
  case_79: /* CIL Label */ 
#line 323
  return ("R_IA64_PCREL64LSB");
  case_82: /* CIL Label */ 
#line 325
  return ("R_IA64_LTOFF_FPTR22");
  case_83: /* CIL Label */ 
#line 326
  return ("R_IA64_LTOFF_FPTR64I");
  case_84: /* CIL Label */ 
#line 327
  return ("R_IA64_LTOFF_FPTR32MSB");
  case_85: /* CIL Label */ 
#line 328
  return ("R_IA64_LTOFF_FPTR32LSB");
  case_86: /* CIL Label */ 
#line 329
  return ("R_IA64_LTOFF_FPTR64MSB");
  case_87: /* CIL Label */ 
#line 330
  return ("R_IA64_LTOFF_FPTR64LSB");
  case_92: /* CIL Label */ 
#line 332
  return ("R_IA64_SEGREL32MSB");
  case_93: /* CIL Label */ 
#line 333
  return ("R_IA64_SEGREL32LSB");
  case_94: /* CIL Label */ 
#line 334
  return ("R_IA64_SEGREL64MSB");
  case_95: /* CIL Label */ 
#line 335
  return ("R_IA64_SEGREL64LSB");
  case_100: /* CIL Label */ 
#line 337
  return ("R_IA64_SECREL32MSB");
  case_101: /* CIL Label */ 
#line 338
  return ("R_IA64_SECREL32LSB");
  case_102: /* CIL Label */ 
#line 339
  return ("R_IA64_SECREL64MSB");
  case_103: /* CIL Label */ 
#line 340
  return ("R_IA64_SECREL64LSB");
  case_108: /* CIL Label */ 
#line 342
  return ("R_IA64_REL32MSB");
  case_109: /* CIL Label */ 
#line 343
  return ("R_IA64_REL32LSB");
  case_110: /* CIL Label */ 
#line 344
  return ("R_IA64_REL64MSB");
  case_111: /* CIL Label */ 
#line 345
  return ("R_IA64_REL64LSB");
  case_116: /* CIL Label */ 
#line 347
  return ("R_IA64_LTV32MSB");
  case_117: /* CIL Label */ 
#line 348
  return ("R_IA64_LTV32LSB");
  case_118: /* CIL Label */ 
#line 349
  return ("R_IA64_LTV64MSB");
  case_119: /* CIL Label */ 
#line 350
  return ("R_IA64_LTV64LSB");
  case_121: /* CIL Label */ 
#line 352
  return ("R_IA64_PCREL21BI");
  case_122: /* CIL Label */ 
#line 353
  return ("R_IA64_PCREL22");
  case_123: /* CIL Label */ 
#line 354
  return ("R_IA64_PCREL64I");
  case_128: /* CIL Label */ 
#line 356
  return ("R_IA64_IPLTMSB");
  case_129: /* CIL Label */ 
#line 357
  return ("R_IA64_IPLTLSB");
  case_132: /* CIL Label */ 
#line 358
  return ("R_IA64_COPY");
  case_134: /* CIL Label */ 
#line 359
  return ("R_IA64_LTOFF22X");
  case_135: /* CIL Label */ 
#line 360
  return ("R_IA64_LDXMOV");
  case_145: /* CIL Label */ 
#line 362
  return ("R_IA64_TPREL14");
  case_146: /* CIL Label */ 
#line 363
  return ("R_IA64_TPREL22");
  case_147: /* CIL Label */ 
#line 364
  return ("R_IA64_TPREL64I");
  case_150: /* CIL Label */ 
#line 365
  return ("R_IA64_TPREL64MSB");
  case_151: /* CIL Label */ 
#line 366
  return ("R_IA64_TPREL64LSB");
  case_154: /* CIL Label */ 
#line 368
  return ("R_IA64_LTOFF_TPREL22");
  case_166: /* CIL Label */ 
#line 370
  return ("R_IA64_DTPMOD64MSB");
  case_167: /* CIL Label */ 
#line 371
  return ("R_IA64_DTPMOD64LSB");
  case_170: /* CIL Label */ 
#line 372
  return ("R_IA64_LTOFF_DTPMOD22");
  case_177: /* CIL Label */ 
#line 374
  return ("R_IA64_DTPREL14");
  case_178: /* CIL Label */ 
#line 375
  return ("R_IA64_DTPREL22");
  case_179: /* CIL Label */ 
#line 376
  return ("R_IA64_DTPREL64I");
  case_180: /* CIL Label */ 
#line 377
  return ("R_IA64_DTPREL32MSB");
  case_181: /* CIL Label */ 
#line 378
  return ("R_IA64_DTPREL32LSB");
  case_182: /* CIL Label */ 
#line 379
  return ("R_IA64_DTPREL64MSB");
  case_183: /* CIL Label */ 
#line 380
  return ("R_IA64_DTPREL64LSB");
  case_186: /* CIL Label */ 
#line 382
  return ("R_IA64_LTOFF_DTPREL22");
  case_1879048192: /* CIL Label */ 
#line 387
  return ("R_IA64_VMS_DIR8");
  case_1879048193: /* CIL Label */ 
#line 388
  return ("R_IA64_VMS_DIR16LSB");
  case_1879048194: /* CIL Label */ 
#line 389
  return ("R_IA64_VMS_CALL_SIGNATURE");
  case_1879048195: /* CIL Label */ 
#line 390
  return ("R_IA64_VMS_EXECLET_FUNC");
  case_1879048196: /* CIL Label */ 
#line 391
  return ("R_IA64_VMS_EXECLET_DATA");
  case_1879048197: /* CIL Label */ 
#line 392
  return ("R_IA64_VMS_FIX8");
  case_1879048198: /* CIL Label */ 
#line 393
  return ("R_IA64_VMS_FIX16");
  case_1879048199: /* CIL Label */ 
#line 394
  return ("R_IA64_VMS_FIX32");
  case_1879048200: /* CIL Label */ 
#line 395
  return ("R_IA64_VMS_FIX64");
  case_1879048201: /* CIL Label */ 
#line 396
  return ("R_IA64_VMS_FIXFD");
  case_1879048202: /* CIL Label */ 
#line 397
  return ("R_IA64_VMS_ACC_LOAD");
  case_1879048203: /* CIL Label */ 
#line 398
  return ("R_IA64_VMS_ACC_ADD");
  case_1879048204: /* CIL Label */ 
#line 399
  return ("R_IA64_VMS_ACC_SUB");
  case_1879048205: /* CIL Label */ 
#line 400
  return ("R_IA64_VMS_ACC_MUL");
  case_1879048206: /* CIL Label */ 
#line 401
  return ("R_IA64_VMS_ACC_DIV");
  case_1879048207: /* CIL Label */ 
#line 402
  return ("R_IA64_VMS_ACC_AND");
  case_1879048208: /* CIL Label */ 
#line 403
  return ("R_IA64_VMS_ACC_IOR");
  case_1879048209: /* CIL Label */ 
#line 404
  return ("R_IA64_VMS_ACC_EOR");
  case_1879048210: /* CIL Label */ 
#line 405
  return ("R_IA64_VMS_ACC_ASH");
  case_1879048212: /* CIL Label */ 
#line 406
  return ("R_IA64_VMS_ACC_STO8");
  case_1879048213: /* CIL Label */ 
#line 407
  return ("R_IA64_VMS_ACC_STO16LSH");
  case_1879048214: /* CIL Label */ 
#line 408
  return ("R_IA64_VMS_ACC_STO32LSH");
  case_1879048215: /* CIL Label */ 
#line 409
  return ("R_IA64_VMS_ACC_STO64LSH");
  switch_default: /* CIL Label */ 
#line 410
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/ip2k.h"
static char const   *elf_ip2k_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/ip2k.h"
static char const   *elf_ip2k_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 11UL) {
#line 38
    goto case_11;
  }
#line 39
  if (rtype == 12UL) {
#line 39
    goto case_12;
  }
#line 40
  if (rtype == 13UL) {
#line 40
    goto case_13;
  }
#line 41
  if (rtype == 14UL) {
#line 41
    goto case_14;
  }
#line 42
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_IP2K_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_IP2K_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_IP2K_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_IP2K_FR9");
  case_4: /* CIL Label */ 
#line 31
  return ("R_IP2K_BANK");
  case_5: /* CIL Label */ 
#line 32
  return ("R_IP2K_ADDR16CJP");
  case_6: /* CIL Label */ 
#line 33
  return ("R_IP2K_PAGE3");
  case_7: /* CIL Label */ 
#line 34
  return ("R_IP2K_LO8DATA");
  case_8: /* CIL Label */ 
#line 35
  return ("R_IP2K_HI8DATA");
  case_9: /* CIL Label */ 
#line 36
  return ("R_IP2K_LO8INSN");
  case_10: /* CIL Label */ 
#line 37
  return ("R_IP2K_HI8INSN");
  case_11: /* CIL Label */ 
#line 38
  return ("R_IP2K_PC_SKIP");
  case_12: /* CIL Label */ 
#line 39
  return ("R_IP2K_TEXT");
  case_13: /* CIL Label */ 
#line 40
  return ("R_IP2K_FR_OFFSET");
  case_14: /* CIL Label */ 
#line 41
  return ("R_IP2K_EX8DATA");
  switch_default: /* CIL Label */ 
#line 42
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/lm32.h"
static char const   *elf_lm32_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/lm32.h"
static char const   *elf_lm32_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_LM32_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_LM32_8");
  case_2: /* CIL Label */ 
#line 30
  return ("R_LM32_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_LM32_32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_LM32_HI16");
  case_5: /* CIL Label */ 
#line 33
  return ("R_LM32_LO16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_LM32_GPREL16");
  case_7: /* CIL Label */ 
#line 35
  return ("R_LM32_CALL");
  case_8: /* CIL Label */ 
#line 36
  return ("R_LM32_BRANCH");
  case_9: /* CIL Label */ 
#line 37
  return ("R_LM32_GNU_VTINHERIT");
  case_10: /* CIL Label */ 
#line 38
  return ("R_LM32_GNU_VTENTRY");
  case_11: /* CIL Label */ 
#line 39
  return ("R_LM32_16_GOT");
  case_12: /* CIL Label */ 
#line 40
  return ("R_LM32_GOTOFF_HI16");
  case_13: /* CIL Label */ 
#line 41
  return ("R_LM32_GOTOFF_LO16");
  case_14: /* CIL Label */ 
#line 42
  return ("R_LM32_COPY");
  case_15: /* CIL Label */ 
#line 43
  return ("R_LM32_GLOB_DAT");
  case_16: /* CIL Label */ 
#line 44
  return ("R_LM32_JMP_SLOT");
  case_17: /* CIL Label */ 
#line 45
  return ("R_LM32_RELATIVE");
  switch_default: /* CIL Label */ 
#line 46
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/iq2000.h"
static char const   *elf_iq2000_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/iq2000.h"
static char const   *elf_iq2000_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 36
  if (rtype == 9UL) {
#line 36
    goto case_9;
  }
#line 37
  if (rtype == 10UL) {
#line 37
    goto case_10;
  }
#line 38
  if (rtype == 200UL) {
#line 38
    goto case_200;
  }
#line 39
  if (rtype == 201UL) {
#line 39
    goto case_201;
  }
#line 40
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_IQ2000_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_IQ2000_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_IQ2000_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_IQ2000_26");
  case_4: /* CIL Label */ 
#line 31
  return ("R_IQ2000_PC16");
  case_5: /* CIL Label */ 
#line 32
  return ("R_IQ2000_HI16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_IQ2000_LO16");
  case_7: /* CIL Label */ 
#line 34
  return ("R_IQ2000_OFFSET_16");
  case_8: /* CIL Label */ 
#line 35
  return ("R_IQ2000_OFFSET_21");
  case_9: /* CIL Label */ 
#line 36
  return ("R_IQ2000_UHI16");
  case_10: /* CIL Label */ 
#line 37
  return ("R_IQ2000_32_DEBUG");
  case_200: /* CIL Label */ 
#line 38
  return ("R_IQ2000_GNU_VTINHERIT");
  case_201: /* CIL Label */ 
#line 39
  return ("R_IQ2000_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 40
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/m32c.h"
static char const   *elf_m32c_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/m32c.h"
static char const   *elf_m32c_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 41
  if (rtype == 9UL) {
#line 41
    goto case_9;
  }
#line 45
  if (rtype == 10UL) {
#line 45
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 51
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_M32C_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_M32C_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_M32C_24");
  case_3: /* CIL Label */ 
#line 30
  return ("R_M32C_32");
  case_4: /* CIL Label */ 
#line 31
  return ("R_M32C_8_PCREL");
  case_5: /* CIL Label */ 
#line 32
  return ("R_M32C_16_PCREL");
  case_6: /* CIL Label */ 
#line 35
  return ("R_M32C_8");
  case_7: /* CIL Label */ 
#line 37
  return ("R_M32C_LO16");
  case_8: /* CIL Label */ 
#line 39
  return ("R_M32C_HI8");
  case_9: /* CIL Label */ 
#line 41
  return ("R_M32C_HI16");
  case_10: /* CIL Label */ 
#line 45
  return ("R_M32C_RL_JUMP");
  case_11: /* CIL Label */ 
#line 47
  return ("R_M32C_RL_1ADDR");
  case_12: /* CIL Label */ 
#line 49
  return ("R_M32C_RL_2ADDR");
  switch_default: /* CIL Label */ 
#line 51
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/m32r.h"
static char const   *elf_m32r_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/m32r.h"
static char const   *elf_m32r_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 44
  if (rtype == 33UL) {
#line 44
    goto case_33;
  }
#line 45
  if (rtype == 34UL) {
#line 45
    goto case_34;
  }
#line 46
  if (rtype == 35UL) {
#line 46
    goto case_35;
  }
#line 47
  if (rtype == 36UL) {
#line 47
    goto case_36;
  }
#line 48
  if (rtype == 37UL) {
#line 48
    goto case_37;
  }
#line 49
  if (rtype == 38UL) {
#line 49
    goto case_38;
  }
#line 50
  if (rtype == 39UL) {
#line 50
    goto case_39;
  }
#line 51
  if (rtype == 40UL) {
#line 51
    goto case_40;
  }
#line 52
  if (rtype == 41UL) {
#line 52
    goto case_41;
  }
#line 53
  if (rtype == 42UL) {
#line 53
    goto case_42;
  }
#line 54
  if (rtype == 43UL) {
#line 54
    goto case_43;
  }
#line 55
  if (rtype == 44UL) {
#line 55
    goto case_44;
  }
#line 57
  if (rtype == 45UL) {
#line 57
    goto case_45;
  }
#line 59
  if (rtype == 48UL) {
#line 59
    goto case_48;
  }
#line 60
  if (rtype == 49UL) {
#line 60
    goto case_49;
  }
#line 61
  if (rtype == 50UL) {
#line 61
    goto case_50;
  }
#line 62
  if (rtype == 51UL) {
#line 62
    goto case_51;
  }
#line 63
  if (rtype == 52UL) {
#line 63
    goto case_52;
  }
#line 64
  if (rtype == 53UL) {
#line 64
    goto case_53;
  }
#line 65
  if (rtype == 54UL) {
#line 65
    goto case_54;
  }
#line 66
  if (rtype == 55UL) {
#line 66
    goto case_55;
  }
#line 67
  if (rtype == 56UL) {
#line 67
    goto case_56;
  }
#line 68
  if (rtype == 57UL) {
#line 68
    goto case_57;
  }
#line 69
  if (rtype == 58UL) {
#line 69
    goto case_58;
  }
#line 70
  if (rtype == 59UL) {
#line 70
    goto case_59;
  }
#line 71
  if (rtype == 60UL) {
#line 71
    goto case_60;
  }
#line 72
  if (rtype == 61UL) {
#line 72
    goto case_61;
  }
#line 73
  if (rtype == 62UL) {
#line 73
    goto case_62;
  }
#line 74
  if (rtype == 63UL) {
#line 74
    goto case_63;
  }
#line 75
  if (rtype == 64UL) {
#line 75
    goto case_64;
  }
#line 77
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_M32R_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_M32R_16");
  case_2: /* CIL Label */ 
#line 31
  return ("R_M32R_32");
  case_3: /* CIL Label */ 
#line 32
  return ("R_M32R_24");
  case_4: /* CIL Label */ 
#line 33
  return ("R_M32R_10_PCREL");
  case_5: /* CIL Label */ 
#line 34
  return ("R_M32R_18_PCREL");
  case_6: /* CIL Label */ 
#line 35
  return ("R_M32R_26_PCREL");
  case_7: /* CIL Label */ 
#line 36
  return ("R_M32R_HI16_ULO");
  case_8: /* CIL Label */ 
#line 37
  return ("R_M32R_HI16_SLO");
  case_9: /* CIL Label */ 
#line 38
  return ("R_M32R_LO16");
  case_10: /* CIL Label */ 
#line 39
  return ("R_M32R_SDA16");
  case_11: /* CIL Label */ 
#line 40
  return ("R_M32R_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 41
  return ("R_M32R_GNU_VTENTRY");
  case_33: /* CIL Label */ 
#line 44
  return ("R_M32R_16_RELA");
  case_34: /* CIL Label */ 
#line 45
  return ("R_M32R_32_RELA");
  case_35: /* CIL Label */ 
#line 46
  return ("R_M32R_24_RELA");
  case_36: /* CIL Label */ 
#line 47
  return ("R_M32R_10_PCREL_RELA");
  case_37: /* CIL Label */ 
#line 48
  return ("R_M32R_18_PCREL_RELA");
  case_38: /* CIL Label */ 
#line 49
  return ("R_M32R_26_PCREL_RELA");
  case_39: /* CIL Label */ 
#line 50
  return ("R_M32R_HI16_ULO_RELA");
  case_40: /* CIL Label */ 
#line 51
  return ("R_M32R_HI16_SLO_RELA");
  case_41: /* CIL Label */ 
#line 52
  return ("R_M32R_LO16_RELA");
  case_42: /* CIL Label */ 
#line 53
  return ("R_M32R_SDA16_RELA");
  case_43: /* CIL Label */ 
#line 54
  return ("R_M32R_RELA_GNU_VTINHERIT");
  case_44: /* CIL Label */ 
#line 55
  return ("R_M32R_RELA_GNU_VTENTRY");
  case_45: /* CIL Label */ 
#line 57
  return ("R_M32R_REL32");
  case_48: /* CIL Label */ 
#line 59
  return ("R_M32R_GOT24");
  case_49: /* CIL Label */ 
#line 60
  return ("R_M32R_26_PLTREL");
  case_50: /* CIL Label */ 
#line 61
  return ("R_M32R_COPY");
  case_51: /* CIL Label */ 
#line 62
  return ("R_M32R_GLOB_DAT");
  case_52: /* CIL Label */ 
#line 63
  return ("R_M32R_JMP_SLOT");
  case_53: /* CIL Label */ 
#line 64
  return ("R_M32R_RELATIVE");
  case_54: /* CIL Label */ 
#line 65
  return ("R_M32R_GOTOFF");
  case_55: /* CIL Label */ 
#line 66
  return ("R_M32R_GOTPC24");
  case_56: /* CIL Label */ 
#line 67
  return ("R_M32R_GOT16_HI_ULO");
  case_57: /* CIL Label */ 
#line 68
  return ("R_M32R_GOT16_HI_SLO");
  case_58: /* CIL Label */ 
#line 69
  return ("R_M32R_GOT16_LO");
  case_59: /* CIL Label */ 
#line 70
  return ("R_M32R_GOTPC_HI_ULO");
  case_60: /* CIL Label */ 
#line 71
  return ("R_M32R_GOTPC_HI_SLO");
  case_61: /* CIL Label */ 
#line 72
  return ("R_M32R_GOTPC_LO");
  case_62: /* CIL Label */ 
#line 73
  return ("R_M32R_GOTOFF_HI_ULO");
  case_63: /* CIL Label */ 
#line 74
  return ("R_M32R_GOTOFF_HI_SLO");
  case_64: /* CIL Label */ 
#line 75
  return ("R_M32R_GOTOFF_LO");
  switch_default: /* CIL Label */ 
#line 77
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/m68k.h"
static char const   *elf_m68k_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/m68k.h"
static char const   *elf_m68k_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  if (rtype == 18UL) {
#line 46
    goto case_18;
  }
#line 47
  if (rtype == 19UL) {
#line 47
    goto case_19;
  }
#line 48
  if (rtype == 20UL) {
#line 48
    goto case_20;
  }
#line 49
  if (rtype == 21UL) {
#line 49
    goto case_21;
  }
#line 50
  if (rtype == 22UL) {
#line 50
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 55
  if (rtype == 25UL) {
#line 55
    goto case_25;
  }
#line 56
  if (rtype == 26UL) {
#line 56
    goto case_26;
  }
#line 57
  if (rtype == 27UL) {
#line 57
    goto case_27;
  }
#line 58
  if (rtype == 28UL) {
#line 58
    goto case_28;
  }
#line 59
  if (rtype == 29UL) {
#line 59
    goto case_29;
  }
#line 60
  if (rtype == 30UL) {
#line 60
    goto case_30;
  }
#line 61
  if (rtype == 31UL) {
#line 61
    goto case_31;
  }
#line 62
  if (rtype == 32UL) {
#line 62
    goto case_32;
  }
#line 63
  if (rtype == 33UL) {
#line 63
    goto case_33;
  }
#line 64
  if (rtype == 34UL) {
#line 64
    goto case_34;
  }
#line 65
  if (rtype == 35UL) {
#line 65
    goto case_35;
  }
#line 66
  if (rtype == 36UL) {
#line 66
    goto case_36;
  }
#line 67
  if (rtype == 37UL) {
#line 67
    goto case_37;
  }
#line 68
  if (rtype == 38UL) {
#line 68
    goto case_38;
  }
#line 69
  if (rtype == 39UL) {
#line 69
    goto case_39;
  }
#line 70
  if (rtype == 40UL) {
#line 70
    goto case_40;
  }
#line 71
  if (rtype == 41UL) {
#line 71
    goto case_41;
  }
#line 72
  if (rtype == 42UL) {
#line 72
    goto case_42;
  }
#line 73
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_68K_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_68K_32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_68K_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_68K_8");
  case_4: /* CIL Label */ 
#line 32
  return ("R_68K_PC32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_68K_PC16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_68K_PC8");
  case_7: /* CIL Label */ 
#line 35
  return ("R_68K_GOT32");
  case_8: /* CIL Label */ 
#line 36
  return ("R_68K_GOT16");
  case_9: /* CIL Label */ 
#line 37
  return ("R_68K_GOT8");
  case_10: /* CIL Label */ 
#line 38
  return ("R_68K_GOT32O");
  case_11: /* CIL Label */ 
#line 39
  return ("R_68K_GOT16O");
  case_12: /* CIL Label */ 
#line 40
  return ("R_68K_GOT8O");
  case_13: /* CIL Label */ 
#line 41
  return ("R_68K_PLT32");
  case_14: /* CIL Label */ 
#line 42
  return ("R_68K_PLT16");
  case_15: /* CIL Label */ 
#line 43
  return ("R_68K_PLT8");
  case_16: /* CIL Label */ 
#line 44
  return ("R_68K_PLT32O");
  case_17: /* CIL Label */ 
#line 45
  return ("R_68K_PLT16O");
  case_18: /* CIL Label */ 
#line 46
  return ("R_68K_PLT8O");
  case_19: /* CIL Label */ 
#line 47
  return ("R_68K_COPY");
  case_20: /* CIL Label */ 
#line 48
  return ("R_68K_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 49
  return ("R_68K_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 50
  return ("R_68K_RELATIVE");
  case_23: /* CIL Label */ 
#line 52
  return ("R_68K_GNU_VTINHERIT");
  case_24: /* CIL Label */ 
#line 53
  return ("R_68K_GNU_VTENTRY");
  case_25: /* CIL Label */ 
#line 55
  return ("R_68K_TLS_GD32");
  case_26: /* CIL Label */ 
#line 56
  return ("R_68K_TLS_GD16");
  case_27: /* CIL Label */ 
#line 57
  return ("R_68K_TLS_GD8");
  case_28: /* CIL Label */ 
#line 58
  return ("R_68K_TLS_LDM32");
  case_29: /* CIL Label */ 
#line 59
  return ("R_68K_TLS_LDM16");
  case_30: /* CIL Label */ 
#line 60
  return ("R_68K_TLS_LDM8");
  case_31: /* CIL Label */ 
#line 61
  return ("R_68K_TLS_LDO32");
  case_32: /* CIL Label */ 
#line 62
  return ("R_68K_TLS_LDO16");
  case_33: /* CIL Label */ 
#line 63
  return ("R_68K_TLS_LDO8");
  case_34: /* CIL Label */ 
#line 64
  return ("R_68K_TLS_IE32");
  case_35: /* CIL Label */ 
#line 65
  return ("R_68K_TLS_IE16");
  case_36: /* CIL Label */ 
#line 66
  return ("R_68K_TLS_IE8");
  case_37: /* CIL Label */ 
#line 67
  return ("R_68K_TLS_LE32");
  case_38: /* CIL Label */ 
#line 68
  return ("R_68K_TLS_LE16");
  case_39: /* CIL Label */ 
#line 69
  return ("R_68K_TLS_LE8");
  case_40: /* CIL Label */ 
#line 70
  return ("R_68K_TLS_DTPMOD32");
  case_41: /* CIL Label */ 
#line 71
  return ("R_68K_TLS_DTPREL32");
  case_42: /* CIL Label */ 
#line 72
  return ("R_68K_TLS_TPREL32");
  switch_default: /* CIL Label */ 
#line 73
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/m68hc11.h"
static char const   *elf_m68hc11_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/m68hc11.h"
static char const   *elf_m68hc11_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  if (rtype == 7UL) {
#line 34
    goto case_7;
  }
#line 35
  if (rtype == 8UL) {
#line 35
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 13UL) {
#line 43
    goto case_13;
  }
#line 45
  if (rtype == 15UL) {
#line 45
    goto case_15;
  }
#line 46
  if (rtype == 16UL) {
#line 46
    goto case_16;
  }
#line 47
  if (rtype == 17UL) {
#line 47
    goto case_17;
  }
#line 48
  if (rtype == 18UL) {
#line 48
    goto case_18;
  }
#line 49
  if (rtype == 19UL) {
#line 49
    goto case_19;
  }
#line 53
  if (rtype == 20UL) {
#line 53
    goto case_20;
  }
#line 56
  if (rtype == 21UL) {
#line 56
    goto case_21;
  }
#line 57
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_M68HC11_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_M68HC11_8");
  case_2: /* CIL Label */ 
#line 29
  return ("R_M68HC11_HI8");
  case_3: /* CIL Label */ 
#line 30
  return ("R_M68HC11_LO8");
  case_4: /* CIL Label */ 
#line 31
  return ("R_M68HC11_PCREL_8");
  case_5: /* CIL Label */ 
#line 32
  return ("R_M68HC11_16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_M68HC11_32");
  case_7: /* CIL Label */ 
#line 34
  return ("R_M68HC11_3B");
  case_8: /* CIL Label */ 
#line 35
  return ("R_M68HC11_PCREL_16");
  case_9: /* CIL Label */ 
#line 38
  return ("R_M68HC11_GNU_VTINHERIT");
  case_10: /* CIL Label */ 
#line 39
  return ("R_M68HC11_GNU_VTENTRY");
  case_11: /* CIL Label */ 
#line 41
  return ("R_M68HC11_24");
  case_12: /* CIL Label */ 
#line 42
  return ("R_M68HC11_LO16");
  case_13: /* CIL Label */ 
#line 43
  return ("R_M68HC11_PAGE");
  case_15: /* CIL Label */ 
#line 45
  return ("R_M68HC12_16B");
  case_16: /* CIL Label */ 
#line 46
  return ("R_M68HC12_PCREL_9");
  case_17: /* CIL Label */ 
#line 47
  return ("R_M68HC12_PCREL_10");
  case_18: /* CIL Label */ 
#line 48
  return ("R_M68HC12_HI8XG");
  case_19: /* CIL Label */ 
#line 49
  return ("R_M68HC12_LO8XG");
  case_20: /* CIL Label */ 
#line 53
  return ("R_M68HC11_RL_JUMP");
  case_21: /* CIL Label */ 
#line 56
  return ("R_M68HC11_RL_GROUP");
  switch_default: /* CIL Label */ 
#line 57
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/mcore.h"
static char const   *elf_mcore_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/mcore.h"
static char const   *elf_mcore_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_MCORE_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_MCORE_ADDR32");
  case_2: /* CIL Label */ 
#line 31
  return ("R_MCORE_PCRELIMM8BY4");
  case_3: /* CIL Label */ 
#line 32
  return ("R_MCORE_PCRELIMM11BY2");
  case_4: /* CIL Label */ 
#line 33
  return ("R_MCORE_PCRELIMM4BY2");
  case_5: /* CIL Label */ 
#line 34
  return ("R_MCORE_PCREL32");
  case_6: /* CIL Label */ 
#line 35
  return ("R_MCORE_PCRELJSR_IMM11BY2");
  case_7: /* CIL Label */ 
#line 36
  return ("R_MCORE_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 37
  return ("R_MCORE_GNU_VTENTRY");
  case_9: /* CIL Label */ 
#line 38
  return ("R_MCORE_RELATIVE");
  case_10: /* CIL Label */ 
#line 39
  return ("R_MCORE_COPY");
  case_11: /* CIL Label */ 
#line 40
  return ("R_MCORE_GLOB_DAT");
  case_12: /* CIL Label */ 
#line 41
  return ("R_MCORE_JUMP_SLOT");
  switch_default: /* CIL Label */ 
#line 42
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 38 "./../include/elf/mep.h"
static char const   *elf_mep_reloc_type(unsigned long rtype ) ;
#line 38 "./../include/elf/mep.h"
static char const   *elf_mep_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 41
  if (rtype == 0UL) {
#line 41
    goto case_0;
  }
#line 42
  if (rtype == 1UL) {
#line 42
    goto case_1;
  }
#line 44
  if (rtype == 2UL) {
#line 44
    goto case_2;
  }
#line 45
  if (rtype == 3UL) {
#line 45
    goto case_3;
  }
#line 46
  if (rtype == 4UL) {
#line 46
    goto case_4;
  }
#line 48
  if (rtype == 5UL) {
#line 48
    goto case_5;
  }
#line 49
  if (rtype == 6UL) {
#line 49
    goto case_6;
  }
#line 50
  if (rtype == 7UL) {
#line 50
    goto case_7;
  }
#line 51
  if (rtype == 8UL) {
#line 51
    goto case_8;
  }
#line 52
  if (rtype == 9UL) {
#line 52
    goto case_9;
  }
#line 54
  if (rtype == 10UL) {
#line 54
    goto case_10;
  }
#line 55
  if (rtype == 11UL) {
#line 55
    goto case_11;
  }
#line 56
  if (rtype == 12UL) {
#line 56
    goto case_12;
  }
#line 57
  if (rtype == 13UL) {
#line 57
    goto case_13;
  }
#line 58
  if (rtype == 14UL) {
#line 58
    goto case_14;
  }
#line 60
  if (rtype == 15UL) {
#line 60
    goto case_15;
  }
#line 61
  if (rtype == 16UL) {
#line 61
    goto case_16;
  }
#line 62
  if (rtype == 17UL) {
#line 62
    goto case_17;
  }
#line 64
  if (rtype == 18UL) {
#line 64
    goto case_18;
  }
#line 65
  if (rtype == 19UL) {
#line 65
    goto case_19;
  }
#line 67
  if (rtype == 20UL) {
#line 67
    goto case_20;
  }
#line 68
  if (rtype == 21UL) {
#line 68
    goto case_21;
  }
#line 70
  goto switch_default;
  case_0: /* CIL Label */ 
#line 41
  return ("R_MEP_NONE");
  case_1: /* CIL Label */ 
#line 42
  return ("R_RELC");
  case_2: /* CIL Label */ 
#line 44
  return ("R_MEP_8");
  case_3: /* CIL Label */ 
#line 45
  return ("R_MEP_16");
  case_4: /* CIL Label */ 
#line 46
  return ("R_MEP_32");
  case_5: /* CIL Label */ 
#line 48
  return ("R_MEP_PCREL8A2");
  case_6: /* CIL Label */ 
#line 49
  return ("R_MEP_PCREL12A2");
  case_7: /* CIL Label */ 
#line 50
  return ("R_MEP_PCREL17A2");
  case_8: /* CIL Label */ 
#line 51
  return ("R_MEP_PCREL24A2");
  case_9: /* CIL Label */ 
#line 52
  return ("R_MEP_PCABS24A2");
  case_10: /* CIL Label */ 
#line 54
  return ("R_MEP_LOW16");
  case_11: /* CIL Label */ 
#line 55
  return ("R_MEP_HI16U");
  case_12: /* CIL Label */ 
#line 56
  return ("R_MEP_HI16S");
  case_13: /* CIL Label */ 
#line 57
  return ("R_MEP_GPREL");
  case_14: /* CIL Label */ 
#line 58
  return ("R_MEP_TPREL");
  case_15: /* CIL Label */ 
#line 60
  return ("R_MEP_TPREL7");
  case_16: /* CIL Label */ 
#line 61
  return ("R_MEP_TPREL7A2");
  case_17: /* CIL Label */ 
#line 62
  return ("R_MEP_TPREL7A4");
  case_18: /* CIL Label */ 
#line 64
  return ("R_MEP_UIMM24");
  case_19: /* CIL Label */ 
#line 65
  return ("R_MEP_ADDR24A4");
  case_20: /* CIL Label */ 
#line 67
  return ("R_MEP_GNU_VTINHERIT");
  case_21: /* CIL Label */ 
#line 68
  return ("R_MEP_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 70
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 30 "./../include/elf/microblaze.h"
static char const   *elf_microblaze_reloc_type(unsigned long rtype ) ;
#line 30 "./../include/elf/microblaze.h"
static char const   *elf_microblaze_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 31
  if (rtype == 0UL) {
#line 31
    goto case_0;
  }
#line 32
  if (rtype == 1UL) {
#line 32
    goto case_1;
  }
#line 33
  if (rtype == 2UL) {
#line 33
    goto case_2;
  }
#line 34
  if (rtype == 3UL) {
#line 34
    goto case_3;
  }
#line 35
  if (rtype == 4UL) {
#line 35
    goto case_4;
  }
#line 36
  if (rtype == 5UL) {
#line 36
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 38
  if (rtype == 7UL) {
#line 38
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 40
  if (rtype == 9UL) {
#line 40
    goto case_9;
  }
#line 41
  if (rtype == 10UL) {
#line 41
    goto case_10;
  }
#line 42
  if (rtype == 11UL) {
#line 42
    goto case_11;
  }
#line 43
  if (rtype == 12UL) {
#line 43
    goto case_12;
  }
#line 44
  if (rtype == 13UL) {
#line 44
    goto case_13;
  }
#line 45
  if (rtype == 14UL) {
#line 45
    goto case_14;
  }
#line 46
  if (rtype == 15UL) {
#line 46
    goto case_15;
  }
#line 47
  if (rtype == 16UL) {
#line 47
    goto case_16;
  }
#line 48
  if (rtype == 17UL) {
#line 48
    goto case_17;
  }
#line 49
  if (rtype == 18UL) {
#line 49
    goto case_18;
  }
#line 50
  if (rtype == 19UL) {
#line 50
    goto case_19;
  }
#line 51
  if (rtype == 20UL) {
#line 51
    goto case_20;
  }
#line 52
  if (rtype == 21UL) {
#line 52
    goto case_21;
  }
#line 54
  goto switch_default;
  case_0: /* CIL Label */ 
#line 31
  return ("R_MICROBLAZE_NONE");
  case_1: /* CIL Label */ 
#line 32
  return ("R_MICROBLAZE_32");
  case_2: /* CIL Label */ 
#line 33
  return ("R_MICROBLAZE_32_PCREL");
  case_3: /* CIL Label */ 
#line 34
  return ("R_MICROBLAZE_64_PCREL");
  case_4: /* CIL Label */ 
#line 35
  return ("R_MICROBLAZE_32_PCREL_LO");
  case_5: /* CIL Label */ 
#line 36
  return ("R_MICROBLAZE_64");
  case_6: /* CIL Label */ 
#line 37
  return ("R_MICROBLAZE_32_LO");
  case_7: /* CIL Label */ 
#line 38
  return ("R_MICROBLAZE_SRO32");
  case_8: /* CIL Label */ 
#line 39
  return ("R_MICROBLAZE_SRW32");
  case_9: /* CIL Label */ 
#line 40
  return ("R_MICROBLAZE_64_NONE");
  case_10: /* CIL Label */ 
#line 41
  return ("R_MICROBLAZE_32_SYM_OP_SYM");
  case_11: /* CIL Label */ 
#line 42
  return ("R_MICROBLAZE_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 43
  return ("R_MICROBLAZE_GNU_VTENTRY");
  case_13: /* CIL Label */ 
#line 44
  return ("R_MICROBLAZE_GOTPC_64");
  case_14: /* CIL Label */ 
#line 45
  return ("R_MICROBLAZE_GOT_64");
  case_15: /* CIL Label */ 
#line 46
  return ("R_MICROBLAZE_PLT_64");
  case_16: /* CIL Label */ 
#line 47
  return ("R_MICROBLAZE_REL");
  case_17: /* CIL Label */ 
#line 48
  return ("R_MICROBLAZE_JUMP_SLOT");
  case_18: /* CIL Label */ 
#line 49
  return ("R_MICROBLAZE_GLOB_DAT");
  case_19: /* CIL Label */ 
#line 50
  return ("R_MICROBLAZE_GOTOFF_64");
  case_20: /* CIL Label */ 
#line 51
  return ("R_MICROBLAZE_GOTOFF_32");
  case_21: /* CIL Label */ 
#line 52
  return ("R_MICROBLAZE_COPY");
  switch_default: /* CIL Label */ 
#line 54
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 36 "./../include/elf/mips.h"
static char const   *elf_mips_reloc_type(unsigned long rtype ) ;
#line 36 "./../include/elf/mips.h"
static char const   *elf_mips_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 37
  if (rtype == 0UL) {
#line 37
    goto case_0;
  }
#line 38
  if (rtype == 1UL) {
#line 38
    goto case_1;
  }
#line 39
  if (rtype == 2UL) {
#line 39
    goto case_2;
  }
#line 40
  if (rtype == 3UL) {
#line 40
    goto case_3;
  }
#line 41
  if (rtype == 4UL) {
#line 41
    goto case_4;
  }
#line 42
  if (rtype == 5UL) {
#line 42
    goto case_5;
  }
#line 43
  if (rtype == 6UL) {
#line 43
    goto case_6;
  }
#line 44
  if (rtype == 7UL) {
#line 44
    goto case_7;
  }
#line 45
  if (rtype == 8UL) {
#line 45
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 48
  if (rtype == 11UL) {
#line 48
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 52
  if (rtype == 13UL) {
#line 52
    goto case_13;
  }
#line 53
  if (rtype == 14UL) {
#line 53
    goto case_14;
  }
#line 54
  if (rtype == 15UL) {
#line 54
    goto case_15;
  }
#line 55
  if (rtype == 16UL) {
#line 55
    goto case_16;
  }
#line 56
  if (rtype == 17UL) {
#line 56
    goto case_17;
  }
#line 57
  if (rtype == 18UL) {
#line 57
    goto case_18;
  }
#line 58
  if (rtype == 19UL) {
#line 58
    goto case_19;
  }
#line 59
  if (rtype == 20UL) {
#line 59
    goto case_20;
  }
#line 60
  if (rtype == 21UL) {
#line 60
    goto case_21;
  }
#line 61
  if (rtype == 22UL) {
#line 61
    goto case_22;
  }
#line 62
  if (rtype == 23UL) {
#line 62
    goto case_23;
  }
#line 63
  if (rtype == 24UL) {
#line 63
    goto case_24;
  }
#line 64
  if (rtype == 25UL) {
#line 64
    goto case_25;
  }
#line 65
  if (rtype == 26UL) {
#line 65
    goto case_26;
  }
#line 66
  if (rtype == 27UL) {
#line 66
    goto case_27;
  }
#line 67
  if (rtype == 28UL) {
#line 67
    goto case_28;
  }
#line 68
  if (rtype == 29UL) {
#line 68
    goto case_29;
  }
#line 69
  if (rtype == 30UL) {
#line 69
    goto case_30;
  }
#line 70
  if (rtype == 31UL) {
#line 70
    goto case_31;
  }
#line 71
  if (rtype == 32UL) {
#line 71
    goto case_32;
  }
#line 72
  if (rtype == 33UL) {
#line 72
    goto case_33;
  }
#line 73
  if (rtype == 34UL) {
#line 73
    goto case_34;
  }
#line 74
  if (rtype == 35UL) {
#line 74
    goto case_35;
  }
#line 75
  if (rtype == 36UL) {
#line 75
    goto case_36;
  }
#line 76
  if (rtype == 37UL) {
#line 76
    goto case_37;
  }
#line 78
  if (rtype == 38UL) {
#line 78
    goto case_38;
  }
#line 79
  if (rtype == 39UL) {
#line 79
    goto case_39;
  }
#line 80
  if (rtype == 40UL) {
#line 80
    goto case_40;
  }
#line 81
  if (rtype == 41UL) {
#line 81
    goto case_41;
  }
#line 82
  if (rtype == 42UL) {
#line 82
    goto case_42;
  }
#line 83
  if (rtype == 43UL) {
#line 83
    goto case_43;
  }
#line 84
  if (rtype == 44UL) {
#line 84
    goto case_44;
  }
#line 85
  if (rtype == 45UL) {
#line 85
    goto case_45;
  }
#line 86
  if (rtype == 46UL) {
#line 86
    goto case_46;
  }
#line 87
  if (rtype == 47UL) {
#line 87
    goto case_47;
  }
#line 88
  if (rtype == 48UL) {
#line 88
    goto case_48;
  }
#line 89
  if (rtype == 49UL) {
#line 89
    goto case_49;
  }
#line 90
  if (rtype == 50UL) {
#line 90
    goto case_50;
  }
#line 91
  if (rtype == 51UL) {
#line 91
    goto case_51;
  }
#line 95
  if (rtype == 100UL) {
#line 95
    goto case_100;
  }
#line 96
  if (rtype == 101UL) {
#line 96
    goto case_101;
  }
#line 97
  if (rtype == 102UL) {
#line 97
    goto case_102;
  }
#line 98
  if (rtype == 103UL) {
#line 98
    goto case_103;
  }
#line 99
  if (rtype == 104UL) {
#line 99
    goto case_104;
  }
#line 100
  if (rtype == 105UL) {
#line 100
    goto case_105;
  }
#line 101
  if (rtype == 106UL) {
#line 101
    goto case_106;
  }
#line 102
  if (rtype == 107UL) {
#line 102
    goto case_107;
  }
#line 103
  if (rtype == 108UL) {
#line 103
    goto case_108;
  }
#line 104
  if (rtype == 109UL) {
#line 104
    goto case_109;
  }
#line 105
  if (rtype == 110UL) {
#line 105
    goto case_110;
  }
#line 106
  if (rtype == 111UL) {
#line 106
    goto case_111;
  }
#line 107
  if (rtype == 112UL) {
#line 107
    goto case_112;
  }
#line 110
  if (rtype == 126UL) {
#line 110
    goto case_126;
  }
#line 111
  if (rtype == 127UL) {
#line 111
    goto case_127;
  }
#line 115
  if (rtype == 133UL) {
#line 115
    goto case_133;
  }
#line 116
  if (rtype == 134UL) {
#line 116
    goto case_134;
  }
#line 117
  if (rtype == 135UL) {
#line 117
    goto case_135;
  }
#line 118
  if (rtype == 136UL) {
#line 118
    goto case_136;
  }
#line 120
  if (rtype == 137UL) {
#line 120
    goto case_137;
  }
#line 121
  if (rtype == 138UL) {
#line 121
    goto case_138;
  }
#line 123
  if (rtype == 139UL) {
#line 123
    goto case_139;
  }
#line 124
  if (rtype == 140UL) {
#line 124
    goto case_140;
  }
#line 125
  if (rtype == 141UL) {
#line 125
    goto case_141;
  }
#line 126
  if (rtype == 142UL) {
#line 126
    goto case_142;
  }
#line 128
  if (rtype == 145UL) {
#line 128
    goto case_145;
  }
#line 129
  if (rtype == 146UL) {
#line 129
    goto case_146;
  }
#line 130
  if (rtype == 147UL) {
#line 130
    goto case_147;
  }
#line 131
  if (rtype == 148UL) {
#line 131
    goto case_148;
  }
#line 132
  if (rtype == 149UL) {
#line 132
    goto case_149;
  }
#line 133
  if (rtype == 150UL) {
#line 133
    goto case_150;
  }
#line 134
  if (rtype == 151UL) {
#line 134
    goto case_151;
  }
#line 135
  if (rtype == 152UL) {
#line 135
    goto case_152;
  }
#line 136
  if (rtype == 153UL) {
#line 136
    goto case_153;
  }
#line 137
  if (rtype == 154UL) {
#line 137
    goto case_154;
  }
#line 138
  if (rtype == 155UL) {
#line 138
    goto case_155;
  }
#line 139
  if (rtype == 156UL) {
#line 139
    goto case_156;
  }
#line 140
  if (rtype == 157UL) {
#line 140
    goto case_157;
  }
#line 142
  if (rtype == 162UL) {
#line 142
    goto case_162;
  }
#line 143
  if (rtype == 163UL) {
#line 143
    goto case_163;
  }
#line 144
  if (rtype == 164UL) {
#line 144
    goto case_164;
  }
#line 145
  if (rtype == 165UL) {
#line 145
    goto case_165;
  }
#line 146
  if (rtype == 166UL) {
#line 146
    goto case_166;
  }
#line 147
  if (rtype == 169UL) {
#line 147
    goto case_169;
  }
#line 148
  if (rtype == 170UL) {
#line 148
    goto case_170;
  }
#line 150
  if (rtype == 172UL) {
#line 150
    goto case_172;
  }
#line 151
  if (rtype == 173UL) {
#line 151
    goto case_173;
  }
#line 158
  if (rtype == 248UL) {
#line 158
    goto case_248;
  }
#line 160
  if (rtype == 250UL) {
#line 160
    goto case_250;
  }
#line 162
  if (rtype == 253UL) {
#line 162
    goto case_253;
  }
#line 163
  if (rtype == 254UL) {
#line 163
    goto case_254;
  }
#line 164
  goto switch_default;
  case_0: /* CIL Label */ 
#line 37
  return ("R_MIPS_NONE");
  case_1: /* CIL Label */ 
#line 38
  return ("R_MIPS_16");
  case_2: /* CIL Label */ 
#line 39
  return ("R_MIPS_32");
  case_3: /* CIL Label */ 
#line 40
  return ("R_MIPS_REL32");
  case_4: /* CIL Label */ 
#line 41
  return ("R_MIPS_26");
  case_5: /* CIL Label */ 
#line 42
  return ("R_MIPS_HI16");
  case_6: /* CIL Label */ 
#line 43
  return ("R_MIPS_LO16");
  case_7: /* CIL Label */ 
#line 44
  return ("R_MIPS_GPREL16");
  case_8: /* CIL Label */ 
#line 45
  return ("R_MIPS_LITERAL");
  case_9: /* CIL Label */ 
#line 46
  return ("R_MIPS_GOT16");
  case_10: /* CIL Label */ 
#line 47
  return ("R_MIPS_PC16");
  case_11: /* CIL Label */ 
#line 48
  return ("R_MIPS_CALL16");
  case_12: /* CIL Label */ 
#line 49
  return ("R_MIPS_GPREL32");
  case_13: /* CIL Label */ 
#line 52
  return ("R_MIPS_UNUSED1");
  case_14: /* CIL Label */ 
#line 53
  return ("R_MIPS_UNUSED2");
  case_15: /* CIL Label */ 
#line 54
  return ("R_MIPS_UNUSED3");
  case_16: /* CIL Label */ 
#line 55
  return ("R_MIPS_SHIFT5");
  case_17: /* CIL Label */ 
#line 56
  return ("R_MIPS_SHIFT6");
  case_18: /* CIL Label */ 
#line 57
  return ("R_MIPS_64");
  case_19: /* CIL Label */ 
#line 58
  return ("R_MIPS_GOT_DISP");
  case_20: /* CIL Label */ 
#line 59
  return ("R_MIPS_GOT_PAGE");
  case_21: /* CIL Label */ 
#line 60
  return ("R_MIPS_GOT_OFST");
  case_22: /* CIL Label */ 
#line 61
  return ("R_MIPS_GOT_HI16");
  case_23: /* CIL Label */ 
#line 62
  return ("R_MIPS_GOT_LO16");
  case_24: /* CIL Label */ 
#line 63
  return ("R_MIPS_SUB");
  case_25: /* CIL Label */ 
#line 64
  return ("R_MIPS_INSERT_A");
  case_26: /* CIL Label */ 
#line 65
  return ("R_MIPS_INSERT_B");
  case_27: /* CIL Label */ 
#line 66
  return ("R_MIPS_DELETE");
  case_28: /* CIL Label */ 
#line 67
  return ("R_MIPS_HIGHER");
  case_29: /* CIL Label */ 
#line 68
  return ("R_MIPS_HIGHEST");
  case_30: /* CIL Label */ 
#line 69
  return ("R_MIPS_CALL_HI16");
  case_31: /* CIL Label */ 
#line 70
  return ("R_MIPS_CALL_LO16");
  case_32: /* CIL Label */ 
#line 71
  return ("R_MIPS_SCN_DISP");
  case_33: /* CIL Label */ 
#line 72
  return ("R_MIPS_REL16");
  case_34: /* CIL Label */ 
#line 73
  return ("R_MIPS_ADD_IMMEDIATE");
  case_35: /* CIL Label */ 
#line 74
  return ("R_MIPS_PJUMP");
  case_36: /* CIL Label */ 
#line 75
  return ("R_MIPS_RELGOT");
  case_37: /* CIL Label */ 
#line 76
  return ("R_MIPS_JALR");
  case_38: /* CIL Label */ 
#line 78
  return ("R_MIPS_TLS_DTPMOD32");
  case_39: /* CIL Label */ 
#line 79
  return ("R_MIPS_TLS_DTPREL32");
  case_40: /* CIL Label */ 
#line 80
  return ("R_MIPS_TLS_DTPMOD64");
  case_41: /* CIL Label */ 
#line 81
  return ("R_MIPS_TLS_DTPREL64");
  case_42: /* CIL Label */ 
#line 82
  return ("R_MIPS_TLS_GD");
  case_43: /* CIL Label */ 
#line 83
  return ("R_MIPS_TLS_LDM");
  case_44: /* CIL Label */ 
#line 84
  return ("R_MIPS_TLS_DTPREL_HI16");
  case_45: /* CIL Label */ 
#line 85
  return ("R_MIPS_TLS_DTPREL_LO16");
  case_46: /* CIL Label */ 
#line 86
  return ("R_MIPS_TLS_GOTTPREL");
  case_47: /* CIL Label */ 
#line 87
  return ("R_MIPS_TLS_TPREL32");
  case_48: /* CIL Label */ 
#line 88
  return ("R_MIPS_TLS_TPREL64");
  case_49: /* CIL Label */ 
#line 89
  return ("R_MIPS_TLS_TPREL_HI16");
  case_50: /* CIL Label */ 
#line 90
  return ("R_MIPS_TLS_TPREL_LO16");
  case_51: /* CIL Label */ 
#line 91
  return ("R_MIPS_GLOB_DAT");
  case_100: /* CIL Label */ 
#line 95
  return ("R_MIPS16_26");
  case_101: /* CIL Label */ 
#line 96
  return ("R_MIPS16_GPREL");
  case_102: /* CIL Label */ 
#line 97
  return ("R_MIPS16_GOT16");
  case_103: /* CIL Label */ 
#line 98
  return ("R_MIPS16_CALL16");
  case_104: /* CIL Label */ 
#line 99
  return ("R_MIPS16_HI16");
  case_105: /* CIL Label */ 
#line 100
  return ("R_MIPS16_LO16");
  case_106: /* CIL Label */ 
#line 101
  return ("R_MIPS16_TLS_GD");
  case_107: /* CIL Label */ 
#line 102
  return ("R_MIPS16_TLS_LDM");
  case_108: /* CIL Label */ 
#line 103
  return ("R_MIPS16_TLS_DTPREL_HI16");
  case_109: /* CIL Label */ 
#line 104
  return ("R_MIPS16_TLS_DTPREL_LO16");
  case_110: /* CIL Label */ 
#line 105
  return ("R_MIPS16_TLS_GOTTPREL");
  case_111: /* CIL Label */ 
#line 106
  return ("R_MIPS16_TLS_TPREL_HI16");
  case_112: /* CIL Label */ 
#line 107
  return ("R_MIPS16_TLS_TPREL_LO16");
  case_126: /* CIL Label */ 
#line 110
  return ("R_MIPS_COPY");
  case_127: /* CIL Label */ 
#line 111
  return ("R_MIPS_JUMP_SLOT");
  case_133: /* CIL Label */ 
#line 115
  return ("R_MICROMIPS_26_S1");
  case_134: /* CIL Label */ 
#line 116
  return ("R_MICROMIPS_HI16");
  case_135: /* CIL Label */ 
#line 117
  return ("R_MICROMIPS_LO16");
  case_136: /* CIL Label */ 
#line 118
  return ("R_MICROMIPS_GPREL16");
  case_137: /* CIL Label */ 
#line 120
  return ("R_MICROMIPS_LITERAL");
  case_138: /* CIL Label */ 
#line 121
  return ("R_MICROMIPS_GOT16");
  case_139: /* CIL Label */ 
#line 123
  return ("R_MICROMIPS_PC7_S1");
  case_140: /* CIL Label */ 
#line 124
  return ("R_MICROMIPS_PC10_S1");
  case_141: /* CIL Label */ 
#line 125
  return ("R_MICROMIPS_PC16_S1");
  case_142: /* CIL Label */ 
#line 126
  return ("R_MICROMIPS_CALL16");
  case_145: /* CIL Label */ 
#line 128
  return ("R_MICROMIPS_GOT_DISP");
  case_146: /* CIL Label */ 
#line 129
  return ("R_MICROMIPS_GOT_PAGE");
  case_147: /* CIL Label */ 
#line 130
  return ("R_MICROMIPS_GOT_OFST");
  case_148: /* CIL Label */ 
#line 131
  return ("R_MICROMIPS_GOT_HI16");
  case_149: /* CIL Label */ 
#line 132
  return ("R_MICROMIPS_GOT_LO16");
  case_150: /* CIL Label */ 
#line 133
  return ("R_MICROMIPS_SUB");
  case_151: /* CIL Label */ 
#line 134
  return ("R_MICROMIPS_HIGHER");
  case_152: /* CIL Label */ 
#line 135
  return ("R_MICROMIPS_HIGHEST");
  case_153: /* CIL Label */ 
#line 136
  return ("R_MICROMIPS_CALL_HI16");
  case_154: /* CIL Label */ 
#line 137
  return ("R_MICROMIPS_CALL_LO16");
  case_155: /* CIL Label */ 
#line 138
  return ("R_MICROMIPS_SCN_DISP");
  case_156: /* CIL Label */ 
#line 139
  return ("R_MICROMIPS_JALR");
  case_157: /* CIL Label */ 
#line 140
  return ("R_MICROMIPS_HI0_LO16");
  case_162: /* CIL Label */ 
#line 142
  return ("R_MICROMIPS_TLS_GD");
  case_163: /* CIL Label */ 
#line 143
  return ("R_MICROMIPS_TLS_LDM");
  case_164: /* CIL Label */ 
#line 144
  return ("R_MICROMIPS_TLS_DTPREL_HI16");
  case_165: /* CIL Label */ 
#line 145
  return ("R_MICROMIPS_TLS_DTPREL_LO16");
  case_166: /* CIL Label */ 
#line 146
  return ("R_MICROMIPS_TLS_GOTTPREL");
  case_169: /* CIL Label */ 
#line 147
  return ("R_MICROMIPS_TLS_TPREL_HI16");
  case_170: /* CIL Label */ 
#line 148
  return ("R_MICROMIPS_TLS_TPREL_LO16");
  case_172: /* CIL Label */ 
#line 150
  return ("R_MICROMIPS_GPREL7_S2");
  case_173: /* CIL Label */ 
#line 151
  return ("R_MICROMIPS_PC23_S2");
  case_248: /* CIL Label */ 
#line 158
  return ("R_MIPS_PC32");
  case_250: /* CIL Label */ 
#line 160
  return ("R_MIPS_GNU_REL16_S2");
  case_253: /* CIL Label */ 
#line 162
  return ("R_MIPS_GNU_VTINHERIT");
  case_254: /* CIL Label */ 
#line 163
  return ("R_MIPS_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 164
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/mmix.h"
static char const   *elf_mmix_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/mmix.h"
static char const   *elf_mmix_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 33
  if (rtype == 1UL) {
#line 33
    goto case_1;
  }
#line 34
  if (rtype == 2UL) {
#line 34
    goto case_2;
  }
#line 35
  if (rtype == 3UL) {
#line 35
    goto case_3;
  }
#line 36
  if (rtype == 4UL) {
#line 36
    goto case_4;
  }
#line 37
  if (rtype == 5UL) {
#line 37
    goto case_5;
  }
#line 40
  if (rtype == 6UL) {
#line 40
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 43
  if (rtype == 9UL) {
#line 43
    goto case_9;
  }
#line 44
  if (rtype == 10UL) {
#line 44
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 48
  if (rtype == 12UL) {
#line 48
    goto case_12;
  }
#line 51
  if (rtype == 13UL) {
#line 51
    goto case_13;
  }
#line 52
  if (rtype == 14UL) {
#line 52
    goto case_14;
  }
#line 53
  if (rtype == 15UL) {
#line 53
    goto case_15;
  }
#line 54
  if (rtype == 16UL) {
#line 54
    goto case_16;
  }
#line 57
  if (rtype == 17UL) {
#line 57
    goto case_17;
  }
#line 58
  if (rtype == 18UL) {
#line 58
    goto case_18;
  }
#line 59
  if (rtype == 19UL) {
#line 59
    goto case_19;
  }
#line 60
  if (rtype == 20UL) {
#line 60
    goto case_20;
  }
#line 61
  if (rtype == 21UL) {
#line 61
    goto case_21;
  }
#line 64
  if (rtype == 22UL) {
#line 64
    goto case_22;
  }
#line 65
  if (rtype == 23UL) {
#line 65
    goto case_23;
  }
#line 66
  if (rtype == 24UL) {
#line 66
    goto case_24;
  }
#line 67
  if (rtype == 25UL) {
#line 67
    goto case_25;
  }
#line 70
  if (rtype == 26UL) {
#line 70
    goto case_26;
  }
#line 71
  if (rtype == 27UL) {
#line 71
    goto case_27;
  }
#line 72
  if (rtype == 28UL) {
#line 72
    goto case_28;
  }
#line 73
  if (rtype == 29UL) {
#line 73
    goto case_29;
  }
#line 76
  if (rtype == 30UL) {
#line 76
    goto case_30;
  }
#line 79
  if (rtype == 31UL) {
#line 79
    goto case_31;
  }
#line 82
  if (rtype == 32UL) {
#line 82
    goto case_32;
  }
#line 85
  if (rtype == 33UL) {
#line 85
    goto case_33;
  }
#line 91
  if (rtype == 34UL) {
#line 91
    goto case_34;
  }
#line 94
  if (rtype == 35UL) {
#line 94
    goto case_35;
  }
#line 97
  if (rtype == 36UL) {
#line 97
    goto case_36;
  }
#line 98
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_MMIX_NONE");
  case_1: /* CIL Label */ 
#line 33
  return ("R_MMIX_8");
  case_2: /* CIL Label */ 
#line 34
  return ("R_MMIX_16");
  case_3: /* CIL Label */ 
#line 35
  return ("R_MMIX_24");
  case_4: /* CIL Label */ 
#line 36
  return ("R_MMIX_32");
  case_5: /* CIL Label */ 
#line 37
  return ("R_MMIX_64");
  case_6: /* CIL Label */ 
#line 40
  return ("R_MMIX_PC_8");
  case_7: /* CIL Label */ 
#line 41
  return ("R_MMIX_PC_16");
  case_8: /* CIL Label */ 
#line 42
  return ("R_MMIX_PC_24");
  case_9: /* CIL Label */ 
#line 43
  return ("R_MMIX_PC_32");
  case_10: /* CIL Label */ 
#line 44
  return ("R_MMIX_PC_64");
  case_11: /* CIL Label */ 
#line 47
  return ("R_MMIX_GNU_VTINHERIT");
  case_12: /* CIL Label */ 
#line 48
  return ("R_MMIX_GNU_VTENTRY");
  case_13: /* CIL Label */ 
#line 51
  return ("R_MMIX_GETA");
  case_14: /* CIL Label */ 
#line 52
  return ("R_MMIX_GETA_1");
  case_15: /* CIL Label */ 
#line 53
  return ("R_MMIX_GETA_2");
  case_16: /* CIL Label */ 
#line 54
  return ("R_MMIX_GETA_3");
  case_17: /* CIL Label */ 
#line 57
  return ("R_MMIX_CBRANCH");
  case_18: /* CIL Label */ 
#line 58
  return ("R_MMIX_CBRANCH_J");
  case_19: /* CIL Label */ 
#line 59
  return ("R_MMIX_CBRANCH_1");
  case_20: /* CIL Label */ 
#line 60
  return ("R_MMIX_CBRANCH_2");
  case_21: /* CIL Label */ 
#line 61
  return ("R_MMIX_CBRANCH_3");
  case_22: /* CIL Label */ 
#line 64
  return ("R_MMIX_PUSHJ");
  case_23: /* CIL Label */ 
#line 65
  return ("R_MMIX_PUSHJ_1");
  case_24: /* CIL Label */ 
#line 66
  return ("R_MMIX_PUSHJ_2");
  case_25: /* CIL Label */ 
#line 67
  return ("R_MMIX_PUSHJ_3");
  case_26: /* CIL Label */ 
#line 70
  return ("R_MMIX_JMP");
  case_27: /* CIL Label */ 
#line 71
  return ("R_MMIX_JMP_1");
  case_28: /* CIL Label */ 
#line 72
  return ("R_MMIX_JMP_2");
  case_29: /* CIL Label */ 
#line 73
  return ("R_MMIX_JMP_3");
  case_30: /* CIL Label */ 
#line 76
  return ("R_MMIX_ADDR19");
  case_31: /* CIL Label */ 
#line 79
  return ("R_MMIX_ADDR27");
  case_32: /* CIL Label */ 
#line 82
  return ("R_MMIX_REG_OR_BYTE");
  case_33: /* CIL Label */ 
#line 85
  return ("R_MMIX_REG");
  case_34: /* CIL Label */ 
#line 91
  return ("R_MMIX_BASE_PLUS_OFFSET");
  case_35: /* CIL Label */ 
#line 94
  return ("R_MMIX_LOCAL");
  case_36: /* CIL Label */ 
#line 97
  return ("R_MMIX_PUSHJ_STUBBABLE");
  switch_default: /* CIL Label */ 
#line 98
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/mn10200.h"
static char const   *elf_mn10200_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/mn10200.h"
static char const   *elf_mn10200_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_MN10200_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_MN10200_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_MN10200_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_MN10200_8");
  case_4: /* CIL Label */ 
#line 34
  return ("R_MN10200_24");
  case_5: /* CIL Label */ 
#line 35
  return ("R_MN10200_PCREL8");
  case_6: /* CIL Label */ 
#line 36
  return ("R_MN10200_PCREL16");
  case_7: /* CIL Label */ 
#line 37
  return ("R_MN10200_PCREL24");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 29 "./../include/elf/mn10300.h"
static char const   *elf_mn10300_reloc_type(unsigned long rtype ) ;
#line 29 "./../include/elf/mn10300.h"
static char const   *elf_mn10300_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 30
  if (rtype == 0UL) {
#line 30
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 39
  if (rtype == 9UL) {
#line 39
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 13UL) {
#line 43
    goto case_13;
  }
#line 44
  if (rtype == 14UL) {
#line 44
    goto case_14;
  }
#line 45
  if (rtype == 15UL) {
#line 45
    goto case_15;
  }
#line 46
  if (rtype == 16UL) {
#line 46
    goto case_16;
  }
#line 47
  if (rtype == 17UL) {
#line 47
    goto case_17;
  }
#line 48
  if (rtype == 18UL) {
#line 48
    goto case_18;
  }
#line 49
  if (rtype == 19UL) {
#line 49
    goto case_19;
  }
#line 50
  if (rtype == 20UL) {
#line 50
    goto case_20;
  }
#line 51
  if (rtype == 21UL) {
#line 51
    goto case_21;
  }
#line 52
  if (rtype == 22UL) {
#line 52
    goto case_22;
  }
#line 53
  if (rtype == 23UL) {
#line 53
    goto case_23;
  }
#line 54
  if (rtype == 24UL) {
#line 54
    goto case_24;
  }
#line 55
  if (rtype == 25UL) {
#line 55
    goto case_25;
  }
#line 56
  if (rtype == 26UL) {
#line 56
    goto case_26;
  }
#line 57
  if (rtype == 27UL) {
#line 57
    goto case_27;
  }
#line 58
  if (rtype == 28UL) {
#line 58
    goto case_28;
  }
#line 59
  if (rtype == 29UL) {
#line 59
    goto case_29;
  }
#line 60
  if (rtype == 30UL) {
#line 60
    goto case_30;
  }
#line 61
  if (rtype == 31UL) {
#line 61
    goto case_31;
  }
#line 62
  if (rtype == 32UL) {
#line 62
    goto case_32;
  }
#line 63
  if (rtype == 33UL) {
#line 63
    goto case_33;
  }
#line 64
  if (rtype == 34UL) {
#line 64
    goto case_34;
  }
#line 65
  goto switch_default;
  case_0: /* CIL Label */ 
#line 30
  return ("R_MN10300_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_MN10300_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_MN10300_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_MN10300_8");
  case_4: /* CIL Label */ 
#line 34
  return ("R_MN10300_PCREL32");
  case_5: /* CIL Label */ 
#line 35
  return ("R_MN10300_PCREL16");
  case_6: /* CIL Label */ 
#line 36
  return ("R_MN10300_PCREL8");
  case_7: /* CIL Label */ 
#line 37
  return ("R_MN10300_GNU_VTINHERIT");
  case_8: /* CIL Label */ 
#line 38
  return ("R_MN10300_GNU_VTENTRY");
  case_9: /* CIL Label */ 
#line 39
  return ("R_MN10300_24");
  case_10: /* CIL Label */ 
#line 40
  return ("R_MN10300_GOTPC32");
  case_11: /* CIL Label */ 
#line 41
  return ("R_MN10300_GOTPC16");
  case_12: /* CIL Label */ 
#line 42
  return ("R_MN10300_GOTOFF32");
  case_13: /* CIL Label */ 
#line 43
  return ("R_MN10300_GOTOFF24");
  case_14: /* CIL Label */ 
#line 44
  return ("R_MN10300_GOTOFF16");
  case_15: /* CIL Label */ 
#line 45
  return ("R_MN10300_PLT32");
  case_16: /* CIL Label */ 
#line 46
  return ("R_MN10300_PLT16");
  case_17: /* CIL Label */ 
#line 47
  return ("R_MN10300_GOT32");
  case_18: /* CIL Label */ 
#line 48
  return ("R_MN10300_GOT24");
  case_19: /* CIL Label */ 
#line 49
  return ("R_MN10300_GOT16");
  case_20: /* CIL Label */ 
#line 50
  return ("R_MN10300_COPY");
  case_21: /* CIL Label */ 
#line 51
  return ("R_MN10300_GLOB_DAT");
  case_22: /* CIL Label */ 
#line 52
  return ("R_MN10300_JMP_SLOT");
  case_23: /* CIL Label */ 
#line 53
  return ("R_MN10300_RELATIVE");
  case_24: /* CIL Label */ 
#line 54
  return ("R_MN10300_TLS_GD");
  case_25: /* CIL Label */ 
#line 55
  return ("R_MN10300_TLS_LD");
  case_26: /* CIL Label */ 
#line 56
  return ("R_MN10300_TLS_LDO");
  case_27: /* CIL Label */ 
#line 57
  return ("R_MN10300_TLS_GOTIE");
  case_28: /* CIL Label */ 
#line 58
  return ("R_MN10300_TLS_IE");
  case_29: /* CIL Label */ 
#line 59
  return ("R_MN10300_TLS_LE");
  case_30: /* CIL Label */ 
#line 60
  return ("R_MN10300_TLS_DTPMOD");
  case_31: /* CIL Label */ 
#line 61
  return ("R_MN10300_TLS_DTPOFF");
  case_32: /* CIL Label */ 
#line 62
  return ("R_MN10300_TLS_TPOFF");
  case_33: /* CIL Label */ 
#line 63
  return ("R_MN10300_SYM_DIFF");
  case_34: /* CIL Label */ 
#line 64
  return ("R_MN10300_ALIGN");
  switch_default: /* CIL Label */ 
#line 65
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/moxie.h"
static char const   *elf_moxie_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/moxie.h"
static char const   *elf_moxie_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_MOXIE_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_MOXIE_32");
  case_2: /* CIL Label */ 
#line 29
  return ("R_MOXIE_PCREL10");
  switch_default: /* CIL Label */ 
#line 30
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/mt.h"
static char const   *elf_mt_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/mt.h"
static char const   *elf_mt_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 33
  if (rtype == 6UL) {
#line 33
    goto case_6;
  }
#line 34
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_MT_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_MT_16");
  case_2: /* CIL Label */ 
#line 29
  return ("R_MT_32");
  case_3: /* CIL Label */ 
#line 30
  return ("R_MT_32_PCREL");
  case_4: /* CIL Label */ 
#line 31
  return ("R_MT_PC16");
  case_5: /* CIL Label */ 
#line 32
  return ("R_MT_HI16");
  case_6: /* CIL Label */ 
#line 33
  return ("R_MT_LO16");
  switch_default: /* CIL Label */ 
#line 34
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 45 "./../include/elf/msp430.h"
static char const   *elf_msp430_reloc_type(unsigned long rtype ) ;
#line 45 "./../include/elf/msp430.h"
static char const   *elf_msp430_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 46
  if (rtype == 0UL) {
#line 46
    goto case_0;
  }
#line 47
  if (rtype == 1UL) {
#line 47
    goto case_1;
  }
#line 48
  if (rtype == 2UL) {
#line 48
    goto case_2;
  }
#line 49
  if (rtype == 3UL) {
#line 49
    goto case_3;
  }
#line 50
  if (rtype == 4UL) {
#line 50
    goto case_4;
  }
#line 51
  if (rtype == 5UL) {
#line 51
    goto case_5;
  }
#line 52
  if (rtype == 6UL) {
#line 52
    goto case_6;
  }
#line 53
  if (rtype == 7UL) {
#line 53
    goto case_7;
  }
#line 54
  if (rtype == 8UL) {
#line 54
    goto case_8;
  }
#line 56
  goto switch_default;
  case_0: /* CIL Label */ 
#line 46
  return ("R_MSP430_NONE");
  case_1: /* CIL Label */ 
#line 47
  return ("R_MSP430_32");
  case_2: /* CIL Label */ 
#line 48
  return ("R_MSP430_10_PCREL");
  case_3: /* CIL Label */ 
#line 49
  return ("R_MSP430_16");
  case_4: /* CIL Label */ 
#line 50
  return ("R_MSP430_16_PCREL");
  case_5: /* CIL Label */ 
#line 51
  return ("R_MSP430_16_BYTE");
  case_6: /* CIL Label */ 
#line 52
  return ("R_MSP430_16_PCREL_BYTE");
  case_7: /* CIL Label */ 
#line 53
  return ("R_MSP430_2X_PCREL");
  case_8: /* CIL Label */ 
#line 54
  return ("R_MSP430_RL_PCREL");
  switch_default: /* CIL Label */ 
#line 56
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/or32.h"
static char const   *elf_or32_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/or32.h"
static char const   *elf_or32_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_OR32_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_OR32_32");
  case_2: /* CIL Label */ 
#line 31
  return ("R_OR32_16");
  case_3: /* CIL Label */ 
#line 32
  return ("R_OR32_8");
  case_4: /* CIL Label */ 
#line 33
  return ("R_OR32_CONST");
  case_5: /* CIL Label */ 
#line 34
  return ("R_OR32_CONSTH");
  case_6: /* CIL Label */ 
#line 35
  return ("R_OR32_JUMPTARG");
  case_7: /* CIL Label */ 
#line 36
  return ("R_OR32_GNU_VTENTRY");
  case_8: /* CIL Label */ 
#line 37
  return ("R_OR32_GNU_VTINHERIT");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/pj.h"
static char const   *elf_pj_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/pj.h"
static char const   *elf_pj_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 6UL) {
#line 32
    goto case_6;
  }
#line 33
  if (rtype == 7UL) {
#line 33
    goto case_7;
  }
#line 34
  if (rtype == 13UL) {
#line 34
    goto case_13;
  }
#line 35
  if (rtype == 14UL) {
#line 35
    goto case_14;
  }
#line 36
  if (rtype == 15UL) {
#line 36
    goto case_15;
  }
#line 37
  if (rtype == 16UL) {
#line 37
    goto case_16;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_PJ_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_PJ_DATA_DIR32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_PJ_CODE_REL32");
  case_3: /* CIL Label */ 
#line 31
  return ("R_PJ_CODE_REL16");
  case_6: /* CIL Label */ 
#line 32
  return ("R_PJ_CODE_DIR32");
  case_7: /* CIL Label */ 
#line 33
  return ("R_PJ_CODE_DIR16");
  case_13: /* CIL Label */ 
#line 34
  return ("R_PJ_CODE_LO16");
  case_14: /* CIL Label */ 
#line 35
  return ("R_PJ_CODE_HI16");
  case_15: /* CIL Label */ 
#line 36
  return ("R_PJ_GNU_VTINHERIT");
  case_16: /* CIL Label */ 
#line 37
  return ("R_PJ_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 36 "./../include/elf/ppc.h"
static char const   *elf_ppc_reloc_type(unsigned long rtype ) ;
#line 36 "./../include/elf/ppc.h"
static char const   *elf_ppc_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 37
  if (rtype == 0UL) {
#line 37
    goto case_0;
  }
#line 38
  if (rtype == 1UL) {
#line 38
    goto case_1;
  }
#line 39
  if (rtype == 2UL) {
#line 39
    goto case_2;
  }
#line 40
  if (rtype == 3UL) {
#line 40
    goto case_3;
  }
#line 41
  if (rtype == 4UL) {
#line 41
    goto case_4;
  }
#line 42
  if (rtype == 5UL) {
#line 42
    goto case_5;
  }
#line 43
  if (rtype == 6UL) {
#line 43
    goto case_6;
  }
#line 44
  if (rtype == 7UL) {
#line 44
    goto case_7;
  }
#line 45
  if (rtype == 8UL) {
#line 45
    goto case_8;
  }
#line 46
  if (rtype == 9UL) {
#line 46
    goto case_9;
  }
#line 47
  if (rtype == 10UL) {
#line 47
    goto case_10;
  }
#line 48
  if (rtype == 11UL) {
#line 48
    goto case_11;
  }
#line 49
  if (rtype == 12UL) {
#line 49
    goto case_12;
  }
#line 50
  if (rtype == 13UL) {
#line 50
    goto case_13;
  }
#line 51
  if (rtype == 14UL) {
#line 51
    goto case_14;
  }
#line 52
  if (rtype == 15UL) {
#line 52
    goto case_15;
  }
#line 53
  if (rtype == 16UL) {
#line 53
    goto case_16;
  }
#line 54
  if (rtype == 17UL) {
#line 54
    goto case_17;
  }
#line 55
  if (rtype == 18UL) {
#line 55
    goto case_18;
  }
#line 56
  if (rtype == 19UL) {
#line 56
    goto case_19;
  }
#line 57
  if (rtype == 20UL) {
#line 57
    goto case_20;
  }
#line 58
  if (rtype == 21UL) {
#line 58
    goto case_21;
  }
#line 59
  if (rtype == 22UL) {
#line 59
    goto case_22;
  }
#line 60
  if (rtype == 23UL) {
#line 60
    goto case_23;
  }
#line 61
  if (rtype == 24UL) {
#line 61
    goto case_24;
  }
#line 62
  if (rtype == 25UL) {
#line 62
    goto case_25;
  }
#line 63
  if (rtype == 26UL) {
#line 63
    goto case_26;
  }
#line 64
  if (rtype == 27UL) {
#line 64
    goto case_27;
  }
#line 65
  if (rtype == 28UL) {
#line 65
    goto case_28;
  }
#line 66
  if (rtype == 29UL) {
#line 66
    goto case_29;
  }
#line 67
  if (rtype == 30UL) {
#line 67
    goto case_30;
  }
#line 68
  if (rtype == 31UL) {
#line 68
    goto case_31;
  }
#line 69
  if (rtype == 32UL) {
#line 69
    goto case_32;
  }
#line 70
  if (rtype == 33UL) {
#line 70
    goto case_33;
  }
#line 71
  if (rtype == 34UL) {
#line 71
    goto case_34;
  }
#line 72
  if (rtype == 35UL) {
#line 72
    goto case_35;
  }
#line 73
  if (rtype == 36UL) {
#line 73
    goto case_36;
  }
#line 74
  if (rtype == 37UL) {
#line 74
    goto case_37;
  }
#line 84
  if (rtype == 67UL) {
#line 84
    goto case_67;
  }
#line 85
  if (rtype == 68UL) {
#line 85
    goto case_68;
  }
#line 86
  if (rtype == 69UL) {
#line 86
    goto case_69;
  }
#line 87
  if (rtype == 70UL) {
#line 87
    goto case_70;
  }
#line 88
  if (rtype == 71UL) {
#line 88
    goto case_71;
  }
#line 89
  if (rtype == 72UL) {
#line 89
    goto case_72;
  }
#line 90
  if (rtype == 73UL) {
#line 90
    goto case_73;
  }
#line 91
  if (rtype == 74UL) {
#line 91
    goto case_74;
  }
#line 92
  if (rtype == 75UL) {
#line 92
    goto case_75;
  }
#line 93
  if (rtype == 76UL) {
#line 93
    goto case_76;
  }
#line 94
  if (rtype == 77UL) {
#line 94
    goto case_77;
  }
#line 95
  if (rtype == 78UL) {
#line 95
    goto case_78;
  }
#line 96
  if (rtype == 79UL) {
#line 96
    goto case_79;
  }
#line 97
  if (rtype == 80UL) {
#line 97
    goto case_80;
  }
#line 98
  if (rtype == 81UL) {
#line 98
    goto case_81;
  }
#line 99
  if (rtype == 82UL) {
#line 99
    goto case_82;
  }
#line 100
  if (rtype == 83UL) {
#line 100
    goto case_83;
  }
#line 101
  if (rtype == 84UL) {
#line 101
    goto case_84;
  }
#line 102
  if (rtype == 85UL) {
#line 102
    goto case_85;
  }
#line 103
  if (rtype == 86UL) {
#line 103
    goto case_86;
  }
#line 104
  if (rtype == 87UL) {
#line 104
    goto case_87;
  }
#line 105
  if (rtype == 88UL) {
#line 105
    goto case_88;
  }
#line 106
  if (rtype == 89UL) {
#line 106
    goto case_89;
  }
#line 107
  if (rtype == 90UL) {
#line 107
    goto case_90;
  }
#line 108
  if (rtype == 91UL) {
#line 108
    goto case_91;
  }
#line 109
  if (rtype == 92UL) {
#line 109
    goto case_92;
  }
#line 110
  if (rtype == 93UL) {
#line 110
    goto case_93;
  }
#line 111
  if (rtype == 94UL) {
#line 111
    goto case_94;
  }
#line 112
  if (rtype == 95UL) {
#line 112
    goto case_95;
  }
#line 113
  if (rtype == 96UL) {
#line 113
    goto case_96;
  }
#line 117
  if (rtype == 101UL) {
#line 117
    goto case_101;
  }
#line 118
  if (rtype == 102UL) {
#line 118
    goto case_102;
  }
#line 119
  if (rtype == 103UL) {
#line 119
    goto case_103;
  }
#line 120
  if (rtype == 104UL) {
#line 120
    goto case_104;
  }
#line 121
  if (rtype == 105UL) {
#line 121
    goto case_105;
  }
#line 122
  if (rtype == 106UL) {
#line 122
    goto case_106;
  }
#line 123
  if (rtype == 107UL) {
#line 123
    goto case_107;
  }
#line 124
  if (rtype == 108UL) {
#line 124
    goto case_108;
  }
#line 125
  if (rtype == 109UL) {
#line 125
    goto case_109;
  }
#line 126
  if (rtype == 110UL) {
#line 126
    goto case_110;
  }
#line 127
  if (rtype == 111UL) {
#line 127
    goto case_111;
  }
#line 128
  if (rtype == 112UL) {
#line 128
    goto case_112;
  }
#line 129
  if (rtype == 113UL) {
#line 129
    goto case_113;
  }
#line 130
  if (rtype == 114UL) {
#line 130
    goto case_114;
  }
#line 131
  if (rtype == 115UL) {
#line 131
    goto case_115;
  }
#line 132
  if (rtype == 116UL) {
#line 132
    goto case_116;
  }
#line 135
  if (rtype == 216UL) {
#line 135
    goto case_216;
  }
#line 136
  if (rtype == 217UL) {
#line 136
    goto case_217;
  }
#line 137
  if (rtype == 218UL) {
#line 137
    goto case_218;
  }
#line 138
  if (rtype == 219UL) {
#line 138
    goto case_219;
  }
#line 139
  if (rtype == 220UL) {
#line 139
    goto case_220;
  }
#line 140
  if (rtype == 221UL) {
#line 140
    goto case_221;
  }
#line 141
  if (rtype == 222UL) {
#line 141
    goto case_222;
  }
#line 142
  if (rtype == 223UL) {
#line 142
    goto case_223;
  }
#line 143
  if (rtype == 224UL) {
#line 143
    goto case_224;
  }
#line 144
  if (rtype == 225UL) {
#line 144
    goto case_225;
  }
#line 145
  if (rtype == 226UL) {
#line 145
    goto case_226;
  }
#line 146
  if (rtype == 227UL) {
#line 146
    goto case_227;
  }
#line 147
  if (rtype == 228UL) {
#line 147
    goto case_228;
  }
#line 148
  if (rtype == 229UL) {
#line 148
    goto case_229;
  }
#line 149
  if (rtype == 230UL) {
#line 149
    goto case_230;
  }
#line 150
  if (rtype == 231UL) {
#line 150
    goto case_231;
  }
#line 151
  if (rtype == 232UL) {
#line 151
    goto case_232;
  }
#line 154
  if (rtype == 248UL) {
#line 154
    goto case_248;
  }
#line 157
  if (rtype == 249UL) {
#line 157
    goto case_249;
  }
#line 158
  if (rtype == 250UL) {
#line 158
    goto case_250;
  }
#line 159
  if (rtype == 251UL) {
#line 159
    goto case_251;
  }
#line 160
  if (rtype == 252UL) {
#line 160
    goto case_252;
  }
#line 163
  if (rtype == 253UL) {
#line 163
    goto case_253;
  }
#line 164
  if (rtype == 254UL) {
#line 164
    goto case_254;
  }
#line 168
  if (rtype == 255UL) {
#line 168
    goto case_255;
  }
#line 170
  goto switch_default;
  case_0: /* CIL Label */ 
#line 37
  return ("R_PPC_NONE");
  case_1: /* CIL Label */ 
#line 38
  return ("R_PPC_ADDR32");
  case_2: /* CIL Label */ 
#line 39
  return ("R_PPC_ADDR24");
  case_3: /* CIL Label */ 
#line 40
  return ("R_PPC_ADDR16");
  case_4: /* CIL Label */ 
#line 41
  return ("R_PPC_ADDR16_LO");
  case_5: /* CIL Label */ 
#line 42
  return ("R_PPC_ADDR16_HI");
  case_6: /* CIL Label */ 
#line 43
  return ("R_PPC_ADDR16_HA");
  case_7: /* CIL Label */ 
#line 44
  return ("R_PPC_ADDR14");
  case_8: /* CIL Label */ 
#line 45
  return ("R_PPC_ADDR14_BRTAKEN");
  case_9: /* CIL Label */ 
#line 46
  return ("R_PPC_ADDR14_BRNTAKEN");
  case_10: /* CIL Label */ 
#line 47
  return ("R_PPC_REL24");
  case_11: /* CIL Label */ 
#line 48
  return ("R_PPC_REL14");
  case_12: /* CIL Label */ 
#line 49
  return ("R_PPC_REL14_BRTAKEN");
  case_13: /* CIL Label */ 
#line 50
  return ("R_PPC_REL14_BRNTAKEN");
  case_14: /* CIL Label */ 
#line 51
  return ("R_PPC_GOT16");
  case_15: /* CIL Label */ 
#line 52
  return ("R_PPC_GOT16_LO");
  case_16: /* CIL Label */ 
#line 53
  return ("R_PPC_GOT16_HI");
  case_17: /* CIL Label */ 
#line 54
  return ("R_PPC_GOT16_HA");
  case_18: /* CIL Label */ 
#line 55
  return ("R_PPC_PLTREL24");
  case_19: /* CIL Label */ 
#line 56
  return ("R_PPC_COPY");
  case_20: /* CIL Label */ 
#line 57
  return ("R_PPC_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 58
  return ("R_PPC_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 59
  return ("R_PPC_RELATIVE");
  case_23: /* CIL Label */ 
#line 60
  return ("R_PPC_LOCAL24PC");
  case_24: /* CIL Label */ 
#line 61
  return ("R_PPC_UADDR32");
  case_25: /* CIL Label */ 
#line 62
  return ("R_PPC_UADDR16");
  case_26: /* CIL Label */ 
#line 63
  return ("R_PPC_REL32");
  case_27: /* CIL Label */ 
#line 64
  return ("R_PPC_PLT32");
  case_28: /* CIL Label */ 
#line 65
  return ("R_PPC_PLTREL32");
  case_29: /* CIL Label */ 
#line 66
  return ("R_PPC_PLT16_LO");
  case_30: /* CIL Label */ 
#line 67
  return ("R_PPC_PLT16_HI");
  case_31: /* CIL Label */ 
#line 68
  return ("R_PPC_PLT16_HA");
  case_32: /* CIL Label */ 
#line 69
  return ("R_PPC_SDAREL16");
  case_33: /* CIL Label */ 
#line 70
  return ("R_PPC_SECTOFF");
  case_34: /* CIL Label */ 
#line 71
  return ("R_PPC_SECTOFF_LO");
  case_35: /* CIL Label */ 
#line 72
  return ("R_PPC_SECTOFF_HI");
  case_36: /* CIL Label */ 
#line 73
  return ("R_PPC_SECTOFF_HA");
  case_37: /* CIL Label */ 
#line 74
  return ("R_PPC_ADDR30");
  case_67: /* CIL Label */ 
#line 84
  return ("R_PPC_TLS");
  case_68: /* CIL Label */ 
#line 85
  return ("R_PPC_DTPMOD32");
  case_69: /* CIL Label */ 
#line 86
  return ("R_PPC_TPREL16");
  case_70: /* CIL Label */ 
#line 87
  return ("R_PPC_TPREL16_LO");
  case_71: /* CIL Label */ 
#line 88
  return ("R_PPC_TPREL16_HI");
  case_72: /* CIL Label */ 
#line 89
  return ("R_PPC_TPREL16_HA");
  case_73: /* CIL Label */ 
#line 90
  return ("R_PPC_TPREL32");
  case_74: /* CIL Label */ 
#line 91
  return ("R_PPC_DTPREL16");
  case_75: /* CIL Label */ 
#line 92
  return ("R_PPC_DTPREL16_LO");
  case_76: /* CIL Label */ 
#line 93
  return ("R_PPC_DTPREL16_HI");
  case_77: /* CIL Label */ 
#line 94
  return ("R_PPC_DTPREL16_HA");
  case_78: /* CIL Label */ 
#line 95
  return ("R_PPC_DTPREL32");
  case_79: /* CIL Label */ 
#line 96
  return ("R_PPC_GOT_TLSGD16");
  case_80: /* CIL Label */ 
#line 97
  return ("R_PPC_GOT_TLSGD16_LO");
  case_81: /* CIL Label */ 
#line 98
  return ("R_PPC_GOT_TLSGD16_HI");
  case_82: /* CIL Label */ 
#line 99
  return ("R_PPC_GOT_TLSGD16_HA");
  case_83: /* CIL Label */ 
#line 100
  return ("R_PPC_GOT_TLSLD16");
  case_84: /* CIL Label */ 
#line 101
  return ("R_PPC_GOT_TLSLD16_LO");
  case_85: /* CIL Label */ 
#line 102
  return ("R_PPC_GOT_TLSLD16_HI");
  case_86: /* CIL Label */ 
#line 103
  return ("R_PPC_GOT_TLSLD16_HA");
  case_87: /* CIL Label */ 
#line 104
  return ("R_PPC_GOT_TPREL16");
  case_88: /* CIL Label */ 
#line 105
  return ("R_PPC_GOT_TPREL16_LO");
  case_89: /* CIL Label */ 
#line 106
  return ("R_PPC_GOT_TPREL16_HI");
  case_90: /* CIL Label */ 
#line 107
  return ("R_PPC_GOT_TPREL16_HA");
  case_91: /* CIL Label */ 
#line 108
  return ("R_PPC_GOT_DTPREL16");
  case_92: /* CIL Label */ 
#line 109
  return ("R_PPC_GOT_DTPREL16_LO");
  case_93: /* CIL Label */ 
#line 110
  return ("R_PPC_GOT_DTPREL16_HI");
  case_94: /* CIL Label */ 
#line 111
  return ("R_PPC_GOT_DTPREL16_HA");
  case_95: /* CIL Label */ 
#line 112
  return ("R_PPC_TLSGD");
  case_96: /* CIL Label */ 
#line 113
  return ("R_PPC_TLSLD");
  case_101: /* CIL Label */ 
#line 117
  return ("R_PPC_EMB_NADDR32");
  case_102: /* CIL Label */ 
#line 118
  return ("R_PPC_EMB_NADDR16");
  case_103: /* CIL Label */ 
#line 119
  return ("R_PPC_EMB_NADDR16_LO");
  case_104: /* CIL Label */ 
#line 120
  return ("R_PPC_EMB_NADDR16_HI");
  case_105: /* CIL Label */ 
#line 121
  return ("R_PPC_EMB_NADDR16_HA");
  case_106: /* CIL Label */ 
#line 122
  return ("R_PPC_EMB_SDAI16");
  case_107: /* CIL Label */ 
#line 123
  return ("R_PPC_EMB_SDA2I16");
  case_108: /* CIL Label */ 
#line 124
  return ("R_PPC_EMB_SDA2REL");
  case_109: /* CIL Label */ 
#line 125
  return ("R_PPC_EMB_SDA21");
  case_110: /* CIL Label */ 
#line 126
  return ("R_PPC_EMB_MRKREF");
  case_111: /* CIL Label */ 
#line 127
  return ("R_PPC_EMB_RELSEC16");
  case_112: /* CIL Label */ 
#line 128
  return ("R_PPC_EMB_RELST_LO");
  case_113: /* CIL Label */ 
#line 129
  return ("R_PPC_EMB_RELST_HI");
  case_114: /* CIL Label */ 
#line 130
  return ("R_PPC_EMB_RELST_HA");
  case_115: /* CIL Label */ 
#line 131
  return ("R_PPC_EMB_BIT_FLD");
  case_116: /* CIL Label */ 
#line 132
  return ("R_PPC_EMB_RELSDA");
  case_216: /* CIL Label */ 
#line 135
  return ("R_PPC_VLE_REL8");
  case_217: /* CIL Label */ 
#line 136
  return ("R_PPC_VLE_REL15");
  case_218: /* CIL Label */ 
#line 137
  return ("R_PPC_VLE_REL24");
  case_219: /* CIL Label */ 
#line 138
  return ("R_PPC_VLE_LO16A");
  case_220: /* CIL Label */ 
#line 139
  return ("R_PPC_VLE_LO16D");
  case_221: /* CIL Label */ 
#line 140
  return ("R_PPC_VLE_HI16A");
  case_222: /* CIL Label */ 
#line 141
  return ("R_PPC_VLE_HI16D");
  case_223: /* CIL Label */ 
#line 142
  return ("R_PPC_VLE_HA16A");
  case_224: /* CIL Label */ 
#line 143
  return ("R_PPC_VLE_HA16D");
  case_225: /* CIL Label */ 
#line 144
  return ("R_PPC_VLE_SDA21");
  case_226: /* CIL Label */ 
#line 145
  return ("R_PPC_VLE_SDA21_LO");
  case_227: /* CIL Label */ 
#line 146
  return ("R_PPC_VLE_SDAREL_LO16A");
  case_228: /* CIL Label */ 
#line 147
  return ("R_PPC_VLE_SDAREL_LO16D");
  case_229: /* CIL Label */ 
#line 148
  return ("R_PPC_VLE_SDAREL_HI16A");
  case_230: /* CIL Label */ 
#line 149
  return ("R_PPC_VLE_SDAREL_HI16D");
  case_231: /* CIL Label */ 
#line 150
  return ("R_PPC_VLE_SDAREL_HA16A");
  case_232: /* CIL Label */ 
#line 151
  return ("R_PPC_VLE_SDAREL_HA16D");
  case_248: /* CIL Label */ 
#line 154
  return ("R_PPC_IRELATIVE");
  case_249: /* CIL Label */ 
#line 157
  return ("R_PPC_REL16");
  case_250: /* CIL Label */ 
#line 158
  return ("R_PPC_REL16_LO");
  case_251: /* CIL Label */ 
#line 159
  return ("R_PPC_REL16_HI");
  case_252: /* CIL Label */ 
#line 160
  return ("R_PPC_REL16_HA");
  case_253: /* CIL Label */ 
#line 163
  return ("R_PPC_GNU_VTINHERIT");
  case_254: /* CIL Label */ 
#line 164
  return ("R_PPC_GNU_VTENTRY");
  case_255: /* CIL Label */ 
#line 168
  return ("R_PPC_TOC16");
  switch_default: /* CIL Label */ 
#line 170
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/ppc64.h"
static char const   *elf_ppc64_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/ppc64.h"
static char const   *elf_ppc64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 47
  if (rtype == 19UL) {
#line 47
    goto case_19;
  }
#line 48
  if (rtype == 20UL) {
#line 48
    goto case_20;
  }
#line 49
  if (rtype == 21UL) {
#line 49
    goto case_21;
  }
#line 50
  if (rtype == 22UL) {
#line 50
    goto case_22;
  }
#line 52
  if (rtype == 24UL) {
#line 52
    goto case_24;
  }
#line 53
  if (rtype == 25UL) {
#line 53
    goto case_25;
  }
#line 54
  if (rtype == 26UL) {
#line 54
    goto case_26;
  }
#line 55
  if (rtype == 27UL) {
#line 55
    goto case_27;
  }
#line 56
  if (rtype == 28UL) {
#line 56
    goto case_28;
  }
#line 57
  if (rtype == 29UL) {
#line 57
    goto case_29;
  }
#line 58
  if (rtype == 30UL) {
#line 58
    goto case_30;
  }
#line 59
  if (rtype == 31UL) {
#line 59
    goto case_31;
  }
#line 61
  if (rtype == 33UL) {
#line 61
    goto case_33;
  }
#line 62
  if (rtype == 34UL) {
#line 62
    goto case_34;
  }
#line 63
  if (rtype == 35UL) {
#line 63
    goto case_35;
  }
#line 64
  if (rtype == 36UL) {
#line 64
    goto case_36;
  }
#line 65
  if (rtype == 37UL) {
#line 65
    goto case_37;
  }
#line 66
  if (rtype == 38UL) {
#line 66
    goto case_38;
  }
#line 67
  if (rtype == 39UL) {
#line 67
    goto case_39;
  }
#line 68
  if (rtype == 40UL) {
#line 68
    goto case_40;
  }
#line 69
  if (rtype == 41UL) {
#line 69
    goto case_41;
  }
#line 70
  if (rtype == 42UL) {
#line 70
    goto case_42;
  }
#line 71
  if (rtype == 43UL) {
#line 71
    goto case_43;
  }
#line 72
  if (rtype == 44UL) {
#line 72
    goto case_44;
  }
#line 73
  if (rtype == 45UL) {
#line 73
    goto case_45;
  }
#line 74
  if (rtype == 46UL) {
#line 74
    goto case_46;
  }
#line 75
  if (rtype == 47UL) {
#line 75
    goto case_47;
  }
#line 76
  if (rtype == 48UL) {
#line 76
    goto case_48;
  }
#line 77
  if (rtype == 49UL) {
#line 77
    goto case_49;
  }
#line 78
  if (rtype == 50UL) {
#line 78
    goto case_50;
  }
#line 79
  if (rtype == 51UL) {
#line 79
    goto case_51;
  }
#line 80
  if (rtype == 52UL) {
#line 80
    goto case_52;
  }
#line 81
  if (rtype == 53UL) {
#line 81
    goto case_53;
  }
#line 82
  if (rtype == 54UL) {
#line 82
    goto case_54;
  }
#line 83
  if (rtype == 55UL) {
#line 83
    goto case_55;
  }
#line 87
  if (rtype == 56UL) {
#line 87
    goto case_56;
  }
#line 88
  if (rtype == 57UL) {
#line 88
    goto case_57;
  }
#line 89
  if (rtype == 58UL) {
#line 89
    goto case_58;
  }
#line 90
  if (rtype == 59UL) {
#line 90
    goto case_59;
  }
#line 91
  if (rtype == 60UL) {
#line 91
    goto case_60;
  }
#line 92
  if (rtype == 61UL) {
#line 92
    goto case_61;
  }
#line 93
  if (rtype == 62UL) {
#line 93
    goto case_62;
  }
#line 94
  if (rtype == 63UL) {
#line 94
    goto case_63;
  }
#line 95
  if (rtype == 64UL) {
#line 95
    goto case_64;
  }
#line 96
  if (rtype == 65UL) {
#line 96
    goto case_65;
  }
#line 97
  if (rtype == 66UL) {
#line 97
    goto case_66;
  }
#line 100
  if (rtype == 67UL) {
#line 100
    goto case_67;
  }
#line 101
  if (rtype == 68UL) {
#line 101
    goto case_68;
  }
#line 102
  if (rtype == 69UL) {
#line 102
    goto case_69;
  }
#line 103
  if (rtype == 70UL) {
#line 103
    goto case_70;
  }
#line 104
  if (rtype == 71UL) {
#line 104
    goto case_71;
  }
#line 105
  if (rtype == 72UL) {
#line 105
    goto case_72;
  }
#line 106
  if (rtype == 73UL) {
#line 106
    goto case_73;
  }
#line 107
  if (rtype == 74UL) {
#line 107
    goto case_74;
  }
#line 108
  if (rtype == 75UL) {
#line 108
    goto case_75;
  }
#line 109
  if (rtype == 76UL) {
#line 109
    goto case_76;
  }
#line 110
  if (rtype == 77UL) {
#line 110
    goto case_77;
  }
#line 111
  if (rtype == 78UL) {
#line 111
    goto case_78;
  }
#line 112
  if (rtype == 79UL) {
#line 112
    goto case_79;
  }
#line 113
  if (rtype == 80UL) {
#line 113
    goto case_80;
  }
#line 114
  if (rtype == 81UL) {
#line 114
    goto case_81;
  }
#line 115
  if (rtype == 82UL) {
#line 115
    goto case_82;
  }
#line 116
  if (rtype == 83UL) {
#line 116
    goto case_83;
  }
#line 117
  if (rtype == 84UL) {
#line 117
    goto case_84;
  }
#line 118
  if (rtype == 85UL) {
#line 118
    goto case_85;
  }
#line 119
  if (rtype == 86UL) {
#line 119
    goto case_86;
  }
#line 120
  if (rtype == 87UL) {
#line 120
    goto case_87;
  }
#line 121
  if (rtype == 88UL) {
#line 121
    goto case_88;
  }
#line 122
  if (rtype == 89UL) {
#line 122
    goto case_89;
  }
#line 123
  if (rtype == 90UL) {
#line 123
    goto case_90;
  }
#line 124
  if (rtype == 91UL) {
#line 124
    goto case_91;
  }
#line 125
  if (rtype == 92UL) {
#line 125
    goto case_92;
  }
#line 126
  if (rtype == 93UL) {
#line 126
    goto case_93;
  }
#line 127
  if (rtype == 94UL) {
#line 127
    goto case_94;
  }
#line 128
  if (rtype == 95UL) {
#line 128
    goto case_95;
  }
#line 129
  if (rtype == 96UL) {
#line 129
    goto case_96;
  }
#line 130
  if (rtype == 97UL) {
#line 130
    goto case_97;
  }
#line 131
  if (rtype == 98UL) {
#line 131
    goto case_98;
  }
#line 132
  if (rtype == 99UL) {
#line 132
    goto case_99;
  }
#line 133
  if (rtype == 100UL) {
#line 133
    goto case_100;
  }
#line 134
  if (rtype == 101UL) {
#line 134
    goto case_101;
  }
#line 135
  if (rtype == 102UL) {
#line 135
    goto case_102;
  }
#line 136
  if (rtype == 103UL) {
#line 136
    goto case_103;
  }
#line 137
  if (rtype == 104UL) {
#line 137
    goto case_104;
  }
#line 138
  if (rtype == 105UL) {
#line 138
    goto case_105;
  }
#line 139
  if (rtype == 106UL) {
#line 139
    goto case_106;
  }
#line 140
  if (rtype == 107UL) {
#line 140
    goto case_107;
  }
#line 141
  if (rtype == 108UL) {
#line 141
    goto case_108;
  }
#line 142
  if (rtype == 109UL) {
#line 142
    goto case_109;
  }
#line 149
  if (rtype == 247UL) {
#line 149
    goto case_247;
  }
#line 150
  if (rtype == 248UL) {
#line 150
    goto case_248;
  }
#line 153
  if (rtype == 249UL) {
#line 153
    goto case_249;
  }
#line 154
  if (rtype == 250UL) {
#line 154
    goto case_250;
  }
#line 155
  if (rtype == 251UL) {
#line 155
    goto case_251;
  }
#line 156
  if (rtype == 252UL) {
#line 156
    goto case_252;
  }
#line 159
  if (rtype == 253UL) {
#line 159
    goto case_253;
  }
#line 160
  if (rtype == 254UL) {
#line 160
    goto case_254;
  }
#line 162
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_PPC64_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_PPC64_ADDR32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_PPC64_ADDR24");
  case_3: /* CIL Label */ 
#line 31
  return ("R_PPC64_ADDR16");
  case_4: /* CIL Label */ 
#line 32
  return ("R_PPC64_ADDR16_LO");
  case_5: /* CIL Label */ 
#line 33
  return ("R_PPC64_ADDR16_HI");
  case_6: /* CIL Label */ 
#line 34
  return ("R_PPC64_ADDR16_HA");
  case_7: /* CIL Label */ 
#line 35
  return ("R_PPC64_ADDR14");
  case_8: /* CIL Label */ 
#line 36
  return ("R_PPC64_ADDR14_BRTAKEN");
  case_9: /* CIL Label */ 
#line 37
  return ("R_PPC64_ADDR14_BRNTAKEN");
  case_10: /* CIL Label */ 
#line 38
  return ("R_PPC64_REL24");
  case_11: /* CIL Label */ 
#line 39
  return ("R_PPC64_REL14");
  case_12: /* CIL Label */ 
#line 40
  return ("R_PPC64_REL14_BRTAKEN");
  case_13: /* CIL Label */ 
#line 41
  return ("R_PPC64_REL14_BRNTAKEN");
  case_14: /* CIL Label */ 
#line 42
  return ("R_PPC64_GOT16");
  case_15: /* CIL Label */ 
#line 43
  return ("R_PPC64_GOT16_LO");
  case_16: /* CIL Label */ 
#line 44
  return ("R_PPC64_GOT16_HI");
  case_17: /* CIL Label */ 
#line 45
  return ("R_PPC64_GOT16_HA");
  case_19: /* CIL Label */ 
#line 47
  return ("R_PPC64_COPY");
  case_20: /* CIL Label */ 
#line 48
  return ("R_PPC64_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 49
  return ("R_PPC64_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 50
  return ("R_PPC64_RELATIVE");
  case_24: /* CIL Label */ 
#line 52
  return ("R_PPC64_UADDR32");
  case_25: /* CIL Label */ 
#line 53
  return ("R_PPC64_UADDR16");
  case_26: /* CIL Label */ 
#line 54
  return ("R_PPC64_REL32");
  case_27: /* CIL Label */ 
#line 55
  return ("R_PPC64_PLT32");
  case_28: /* CIL Label */ 
#line 56
  return ("R_PPC64_PLTREL32");
  case_29: /* CIL Label */ 
#line 57
  return ("R_PPC64_PLT16_LO");
  case_30: /* CIL Label */ 
#line 58
  return ("R_PPC64_PLT16_HI");
  case_31: /* CIL Label */ 
#line 59
  return ("R_PPC64_PLT16_HA");
  case_33: /* CIL Label */ 
#line 61
  return ("R_PPC64_SECTOFF");
  case_34: /* CIL Label */ 
#line 62
  return ("R_PPC64_SECTOFF_LO");
  case_35: /* CIL Label */ 
#line 63
  return ("R_PPC64_SECTOFF_HI");
  case_36: /* CIL Label */ 
#line 64
  return ("R_PPC64_SECTOFF_HA");
  case_37: /* CIL Label */ 
#line 65
  return ("R_PPC64_REL30");
  case_38: /* CIL Label */ 
#line 66
  return ("R_PPC64_ADDR64");
  case_39: /* CIL Label */ 
#line 67
  return ("R_PPC64_ADDR16_HIGHER");
  case_40: /* CIL Label */ 
#line 68
  return ("R_PPC64_ADDR16_HIGHERA");
  case_41: /* CIL Label */ 
#line 69
  return ("R_PPC64_ADDR16_HIGHEST");
  case_42: /* CIL Label */ 
#line 70
  return ("R_PPC64_ADDR16_HIGHESTA");
  case_43: /* CIL Label */ 
#line 71
  return ("R_PPC64_UADDR64");
  case_44: /* CIL Label */ 
#line 72
  return ("R_PPC64_REL64");
  case_45: /* CIL Label */ 
#line 73
  return ("R_PPC64_PLT64");
  case_46: /* CIL Label */ 
#line 74
  return ("R_PPC64_PLTREL64");
  case_47: /* CIL Label */ 
#line 75
  return ("R_PPC64_TOC16");
  case_48: /* CIL Label */ 
#line 76
  return ("R_PPC64_TOC16_LO");
  case_49: /* CIL Label */ 
#line 77
  return ("R_PPC64_TOC16_HI");
  case_50: /* CIL Label */ 
#line 78
  return ("R_PPC64_TOC16_HA");
  case_51: /* CIL Label */ 
#line 79
  return ("R_PPC64_TOC");
  case_52: /* CIL Label */ 
#line 80
  return ("R_PPC64_PLTGOT16");
  case_53: /* CIL Label */ 
#line 81
  return ("R_PPC64_PLTGOT16_LO");
  case_54: /* CIL Label */ 
#line 82
  return ("R_PPC64_PLTGOT16_HI");
  case_55: /* CIL Label */ 
#line 83
  return ("R_PPC64_PLTGOT16_HA");
  case_56: /* CIL Label */ 
#line 87
  return ("R_PPC64_ADDR16_DS");
  case_57: /* CIL Label */ 
#line 88
  return ("R_PPC64_ADDR16_LO_DS");
  case_58: /* CIL Label */ 
#line 89
  return ("R_PPC64_GOT16_DS");
  case_59: /* CIL Label */ 
#line 90
  return ("R_PPC64_GOT16_LO_DS");
  case_60: /* CIL Label */ 
#line 91
  return ("R_PPC64_PLT16_LO_DS");
  case_61: /* CIL Label */ 
#line 92
  return ("R_PPC64_SECTOFF_DS");
  case_62: /* CIL Label */ 
#line 93
  return ("R_PPC64_SECTOFF_LO_DS");
  case_63: /* CIL Label */ 
#line 94
  return ("R_PPC64_TOC16_DS");
  case_64: /* CIL Label */ 
#line 95
  return ("R_PPC64_TOC16_LO_DS");
  case_65: /* CIL Label */ 
#line 96
  return ("R_PPC64_PLTGOT16_DS");
  case_66: /* CIL Label */ 
#line 97
  return ("R_PPC64_PLTGOT16_LO_DS");
  case_67: /* CIL Label */ 
#line 100
  return ("R_PPC64_TLS");
  case_68: /* CIL Label */ 
#line 101
  return ("R_PPC64_DTPMOD64");
  case_69: /* CIL Label */ 
#line 102
  return ("R_PPC64_TPREL16");
  case_70: /* CIL Label */ 
#line 103
  return ("R_PPC64_TPREL16_LO");
  case_71: /* CIL Label */ 
#line 104
  return ("R_PPC64_TPREL16_HI");
  case_72: /* CIL Label */ 
#line 105
  return ("R_PPC64_TPREL16_HA");
  case_73: /* CIL Label */ 
#line 106
  return ("R_PPC64_TPREL64");
  case_74: /* CIL Label */ 
#line 107
  return ("R_PPC64_DTPREL16");
  case_75: /* CIL Label */ 
#line 108
  return ("R_PPC64_DTPREL16_LO");
  case_76: /* CIL Label */ 
#line 109
  return ("R_PPC64_DTPREL16_HI");
  case_77: /* CIL Label */ 
#line 110
  return ("R_PPC64_DTPREL16_HA");
  case_78: /* CIL Label */ 
#line 111
  return ("R_PPC64_DTPREL64");
  case_79: /* CIL Label */ 
#line 112
  return ("R_PPC64_GOT_TLSGD16");
  case_80: /* CIL Label */ 
#line 113
  return ("R_PPC64_GOT_TLSGD16_LO");
  case_81: /* CIL Label */ 
#line 114
  return ("R_PPC64_GOT_TLSGD16_HI");
  case_82: /* CIL Label */ 
#line 115
  return ("R_PPC64_GOT_TLSGD16_HA");
  case_83: /* CIL Label */ 
#line 116
  return ("R_PPC64_GOT_TLSLD16");
  case_84: /* CIL Label */ 
#line 117
  return ("R_PPC64_GOT_TLSLD16_LO");
  case_85: /* CIL Label */ 
#line 118
  return ("R_PPC64_GOT_TLSLD16_HI");
  case_86: /* CIL Label */ 
#line 119
  return ("R_PPC64_GOT_TLSLD16_HA");
  case_87: /* CIL Label */ 
#line 120
  return ("R_PPC64_GOT_TPREL16_DS");
  case_88: /* CIL Label */ 
#line 121
  return ("R_PPC64_GOT_TPREL16_LO_DS");
  case_89: /* CIL Label */ 
#line 122
  return ("R_PPC64_GOT_TPREL16_HI");
  case_90: /* CIL Label */ 
#line 123
  return ("R_PPC64_GOT_TPREL16_HA");
  case_91: /* CIL Label */ 
#line 124
  return ("R_PPC64_GOT_DTPREL16_DS");
  case_92: /* CIL Label */ 
#line 125
  return ("R_PPC64_GOT_DTPREL16_LO_DS");
  case_93: /* CIL Label */ 
#line 126
  return ("R_PPC64_GOT_DTPREL16_HI");
  case_94: /* CIL Label */ 
#line 127
  return ("R_PPC64_GOT_DTPREL16_HA");
  case_95: /* CIL Label */ 
#line 128
  return ("R_PPC64_TPREL16_DS");
  case_96: /* CIL Label */ 
#line 129
  return ("R_PPC64_TPREL16_LO_DS");
  case_97: /* CIL Label */ 
#line 130
  return ("R_PPC64_TPREL16_HIGHER");
  case_98: /* CIL Label */ 
#line 131
  return ("R_PPC64_TPREL16_HIGHERA");
  case_99: /* CIL Label */ 
#line 132
  return ("R_PPC64_TPREL16_HIGHEST");
  case_100: /* CIL Label */ 
#line 133
  return ("R_PPC64_TPREL16_HIGHESTA");
  case_101: /* CIL Label */ 
#line 134
  return ("R_PPC64_DTPREL16_DS");
  case_102: /* CIL Label */ 
#line 135
  return ("R_PPC64_DTPREL16_LO_DS");
  case_103: /* CIL Label */ 
#line 136
  return ("R_PPC64_DTPREL16_HIGHER");
  case_104: /* CIL Label */ 
#line 137
  return ("R_PPC64_DTPREL16_HIGHERA");
  case_105: /* CIL Label */ 
#line 138
  return ("R_PPC64_DTPREL16_HIGHEST");
  case_106: /* CIL Label */ 
#line 139
  return ("R_PPC64_DTPREL16_HIGHESTA");
  case_107: /* CIL Label */ 
#line 140
  return ("R_PPC64_TLSGD");
  case_108: /* CIL Label */ 
#line 141
  return ("R_PPC64_TLSLD");
  case_109: /* CIL Label */ 
#line 142
  return ("R_PPC64_TOCSAVE");
  case_247: /* CIL Label */ 
#line 149
  return ("R_PPC64_JMP_IREL");
  case_248: /* CIL Label */ 
#line 150
  return ("R_PPC64_IRELATIVE");
  case_249: /* CIL Label */ 
#line 153
  return ("R_PPC64_REL16");
  case_250: /* CIL Label */ 
#line 154
  return ("R_PPC64_REL16_LO");
  case_251: /* CIL Label */ 
#line 155
  return ("R_PPC64_REL16_HI");
  case_252: /* CIL Label */ 
#line 156
  return ("R_PPC64_REL16_HA");
  case_253: /* CIL Label */ 
#line 159
  return ("R_PPC64_GNU_VTINHERIT");
  case_254: /* CIL Label */ 
#line 160
  return ("R_PPC64_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 162
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "./../include/elf/rl78.h"
static char const   *elf_rl78_reloc_type(unsigned long rtype ) ;
#line 31 "./../include/elf/rl78.h"
static char const   *elf_rl78_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 33
  if (rtype == 0UL) {
#line 33
    goto case_0;
  }
#line 35
  if (rtype == 1UL) {
#line 35
    goto case_1;
  }
#line 36
  if (rtype == 2UL) {
#line 36
    goto case_2;
  }
#line 37
  if (rtype == 3UL) {
#line 37
    goto case_3;
  }
#line 38
  if (rtype == 4UL) {
#line 38
    goto case_4;
  }
#line 39
  if (rtype == 5UL) {
#line 39
    goto case_5;
  }
#line 40
  if (rtype == 6UL) {
#line 40
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 45
  if (rtype == 9UL) {
#line 45
    goto case_9;
  }
#line 46
  if (rtype == 10UL) {
#line 46
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 50
  if (rtype == 12UL) {
#line 50
    goto case_12;
  }
#line 51
  if (rtype == 13UL) {
#line 51
    goto case_13;
  }
#line 52
  if (rtype == 14UL) {
#line 52
    goto case_14;
  }
#line 53
  if (rtype == 15UL) {
#line 53
    goto case_15;
  }
#line 54
  if (rtype == 16UL) {
#line 54
    goto case_16;
  }
#line 55
  if (rtype == 17UL) {
#line 55
    goto case_17;
  }
#line 56
  if (rtype == 18UL) {
#line 56
    goto case_18;
  }
#line 59
  if (rtype == 45UL) {
#line 59
    goto case_45;
  }
#line 60
  if (rtype == 46UL) {
#line 60
    goto case_46;
  }
#line 61
  if (rtype == 47UL) {
#line 61
    goto case_47;
  }
#line 64
  if (rtype == 65UL) {
#line 64
    goto case_65;
  }
#line 65
  if (rtype == 66UL) {
#line 65
    goto case_66;
  }
#line 66
  if (rtype == 67UL) {
#line 66
    goto case_67;
  }
#line 67
  if (rtype == 68UL) {
#line 67
    goto case_68;
  }
#line 68
  if (rtype == 69UL) {
#line 68
    goto case_69;
  }
#line 69
  if (rtype == 70UL) {
#line 69
    goto case_70;
  }
#line 70
  if (rtype == 71UL) {
#line 70
    goto case_71;
  }
#line 71
  if (rtype == 72UL) {
#line 71
    goto case_72;
  }
#line 72
  if (rtype == 73UL) {
#line 72
    goto case_73;
  }
#line 73
  if (rtype == 74UL) {
#line 73
    goto case_74;
  }
#line 74
  if (rtype == 75UL) {
#line 74
    goto case_75;
  }
#line 75
  if (rtype == 76UL) {
#line 75
    goto case_76;
  }
#line 76
  if (rtype == 77UL) {
#line 76
    goto case_77;
  }
#line 77
  if (rtype == 78UL) {
#line 77
    goto case_78;
  }
#line 78
  if (rtype == 79UL) {
#line 78
    goto case_79;
  }
#line 79
  if (rtype == 80UL) {
#line 79
    goto case_80;
  }
#line 80
  if (rtype == 81UL) {
#line 80
    goto case_81;
  }
#line 82
  if (rtype == 128UL) {
#line 82
    goto case_128;
  }
#line 83
  if (rtype == 129UL) {
#line 83
    goto case_129;
  }
#line 84
  if (rtype == 130UL) {
#line 84
    goto case_130;
  }
#line 85
  if (rtype == 131UL) {
#line 85
    goto case_131;
  }
#line 86
  if (rtype == 132UL) {
#line 86
    goto case_132;
  }
#line 87
  if (rtype == 133UL) {
#line 87
    goto case_133;
  }
#line 88
  if (rtype == 134UL) {
#line 88
    goto case_134;
  }
#line 89
  if (rtype == 135UL) {
#line 89
    goto case_135;
  }
#line 90
  if (rtype == 136UL) {
#line 90
    goto case_136;
  }
#line 91
  if (rtype == 141UL) {
#line 91
    goto case_141;
  }
#line 92
  if (rtype == 144UL) {
#line 92
    goto case_144;
  }
#line 93
  if (rtype == 145UL) {
#line 93
    goto case_145;
  }
#line 94
  if (rtype == 146UL) {
#line 94
    goto case_146;
  }
#line 95
  if (rtype == 147UL) {
#line 95
    goto case_147;
  }
#line 96
  if (rtype == 148UL) {
#line 96
    goto case_148;
  }
#line 97
  if (rtype == 149UL) {
#line 97
    goto case_149;
  }
#line 98
  if (rtype == 150UL) {
#line 98
    goto case_150;
  }
#line 100
  goto switch_default;
  case_0: /* CIL Label */ 
#line 33
  return ("R_RL78_NONE");
  case_1: /* CIL Label */ 
#line 35
  return ("R_RL78_DIR32");
  case_2: /* CIL Label */ 
#line 36
  return ("R_RL78_DIR24S");
  case_3: /* CIL Label */ 
#line 37
  return ("R_RL78_DIR16");
  case_4: /* CIL Label */ 
#line 38
  return ("R_RL78_DIR16U");
  case_5: /* CIL Label */ 
#line 39
  return ("R_RL78_DIR16S");
  case_6: /* CIL Label */ 
#line 40
  return ("R_RL78_DIR8");
  case_7: /* CIL Label */ 
#line 41
  return ("R_RL78_DIR8U");
  case_8: /* CIL Label */ 
#line 42
  return ("R_RL78_DIR8S");
  case_9: /* CIL Label */ 
#line 45
  return ("R_RL78_DIR24S_PCREL");
  case_10: /* CIL Label */ 
#line 46
  return ("R_RL78_DIR16S_PCREL");
  case_11: /* CIL Label */ 
#line 47
  return ("R_RL78_DIR8S_PCREL");
  case_12: /* CIL Label */ 
#line 50
  return ("R_RL78_DIR16UL");
  case_13: /* CIL Label */ 
#line 51
  return ("R_RL78_DIR16UW");
  case_14: /* CIL Label */ 
#line 52
  return ("R_RL78_DIR8UL");
  case_15: /* CIL Label */ 
#line 53
  return ("R_RL78_DIR8UW");
  case_16: /* CIL Label */ 
#line 54
  return ("R_RL78_DIR32_REV");
  case_17: /* CIL Label */ 
#line 55
  return ("R_RL78_DIR16_REV");
  case_18: /* CIL Label */ 
#line 56
  return ("R_RL78_DIR3U_PCREL");
  case_45: /* CIL Label */ 
#line 59
  return ("R_RL78_RH_RELAX");
  case_46: /* CIL Label */ 
#line 60
  return ("R_RL78_RH_SFR");
  case_47: /* CIL Label */ 
#line 61
  return ("R_RL78_RH_SADDR");
  case_65: /* CIL Label */ 
#line 64
  return ("R_RL78_ABS32");
  case_66: /* CIL Label */ 
#line 65
  return ("R_RL78_ABS24S");
  case_67: /* CIL Label */ 
#line 66
  return ("R_RL78_ABS16");
  case_68: /* CIL Label */ 
#line 67
  return ("R_RL78_ABS16U");
  case_69: /* CIL Label */ 
#line 68
  return ("R_RL78_ABS16S");
  case_70: /* CIL Label */ 
#line 69
  return ("R_RL78_ABS8");
  case_71: /* CIL Label */ 
#line 70
  return ("R_RL78_ABS8U");
  case_72: /* CIL Label */ 
#line 71
  return ("R_RL78_ABS8S");
  case_73: /* CIL Label */ 
#line 72
  return ("R_RL78_ABS24S_PCREL");
  case_74: /* CIL Label */ 
#line 73
  return ("R_RL78_ABS16S_PCREL");
  case_75: /* CIL Label */ 
#line 74
  return ("R_RL78_ABS8S_PCREL");
  case_76: /* CIL Label */ 
#line 75
  return ("R_RL78_ABS16UL");
  case_77: /* CIL Label */ 
#line 76
  return ("R_RL78_ABS16UW");
  case_78: /* CIL Label */ 
#line 77
  return ("R_RL78_ABS8UL");
  case_79: /* CIL Label */ 
#line 78
  return ("R_RL78_ABS8UW");
  case_80: /* CIL Label */ 
#line 79
  return ("R_RL78_ABS32_REV");
  case_81: /* CIL Label */ 
#line 80
  return ("R_RL78_ABS16_REV");
  case_128: /* CIL Label */ 
#line 82
  return ("R_RL78_SYM");
  case_129: /* CIL Label */ 
#line 83
  return ("R_RL78_OPneg");
  case_130: /* CIL Label */ 
#line 84
  return ("R_RL78_OPadd");
  case_131: /* CIL Label */ 
#line 85
  return ("R_RL78_OPsub");
  case_132: /* CIL Label */ 
#line 86
  return ("R_RL78_OPmul");
  case_133: /* CIL Label */ 
#line 87
  return ("R_RL78_OPdiv");
  case_134: /* CIL Label */ 
#line 88
  return ("R_RL78_OPshla");
  case_135: /* CIL Label */ 
#line 89
  return ("R_RL78_OPshra");
  case_136: /* CIL Label */ 
#line 90
  return ("R_RL78_OPsctsize");
  case_141: /* CIL Label */ 
#line 91
  return ("R_RL78_OPscttop");
  case_144: /* CIL Label */ 
#line 92
  return ("R_RL78_OPand");
  case_145: /* CIL Label */ 
#line 93
  return ("R_RL78_OPor");
  case_146: /* CIL Label */ 
#line 94
  return ("R_RL78_OPxor");
  case_147: /* CIL Label */ 
#line 95
  return ("R_RL78_OPnot");
  case_148: /* CIL Label */ 
#line 96
  return ("R_RL78_OPmod");
  case_149: /* CIL Label */ 
#line 97
  return ("R_RL78_OPromtop");
  case_150: /* CIL Label */ 
#line 98
  return ("R_RL78_OPramtop");
  switch_default: /* CIL Label */ 
#line 100
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 31 "./../include/elf/rx.h"
static char const   *elf_rx_reloc_type(unsigned long rtype ) ;
#line 31 "./../include/elf/rx.h"
static char const   *elf_rx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 33
  if (rtype == 0UL) {
#line 33
    goto case_0;
  }
#line 35
  if (rtype == 1UL) {
#line 35
    goto case_1;
  }
#line 36
  if (rtype == 2UL) {
#line 36
    goto case_2;
  }
#line 37
  if (rtype == 3UL) {
#line 37
    goto case_3;
  }
#line 38
  if (rtype == 4UL) {
#line 38
    goto case_4;
  }
#line 39
  if (rtype == 5UL) {
#line 39
    goto case_5;
  }
#line 40
  if (rtype == 6UL) {
#line 40
    goto case_6;
  }
#line 41
  if (rtype == 7UL) {
#line 41
    goto case_7;
  }
#line 42
  if (rtype == 8UL) {
#line 42
    goto case_8;
  }
#line 45
  if (rtype == 9UL) {
#line 45
    goto case_9;
  }
#line 46
  if (rtype == 10UL) {
#line 46
    goto case_10;
  }
#line 47
  if (rtype == 11UL) {
#line 47
    goto case_11;
  }
#line 50
  if (rtype == 12UL) {
#line 50
    goto case_12;
  }
#line 51
  if (rtype == 13UL) {
#line 51
    goto case_13;
  }
#line 52
  if (rtype == 14UL) {
#line 52
    goto case_14;
  }
#line 53
  if (rtype == 15UL) {
#line 53
    goto case_15;
  }
#line 54
  if (rtype == 16UL) {
#line 54
    goto case_16;
  }
#line 55
  if (rtype == 17UL) {
#line 55
    goto case_17;
  }
#line 56
  if (rtype == 18UL) {
#line 56
    goto case_18;
  }
#line 59
  if (rtype == 32UL) {
#line 59
    goto case_32;
  }
#line 60
  if (rtype == 33UL) {
#line 60
    goto case_33;
  }
#line 61
  if (rtype == 34UL) {
#line 61
    goto case_34;
  }
#line 62
  if (rtype == 35UL) {
#line 62
    goto case_35;
  }
#line 63
  if (rtype == 36UL) {
#line 63
    goto case_36;
  }
#line 64
  if (rtype == 37UL) {
#line 64
    goto case_37;
  }
#line 65
  if (rtype == 38UL) {
#line 65
    goto case_38;
  }
#line 66
  if (rtype == 39UL) {
#line 66
    goto case_39;
  }
#line 67
  if (rtype == 40UL) {
#line 67
    goto case_40;
  }
#line 68
  if (rtype == 41UL) {
#line 68
    goto case_41;
  }
#line 69
  if (rtype == 42UL) {
#line 69
    goto case_42;
  }
#line 70
  if (rtype == 43UL) {
#line 70
    goto case_43;
  }
#line 71
  if (rtype == 44UL) {
#line 71
    goto case_44;
  }
#line 72
  if (rtype == 45UL) {
#line 72
    goto case_45;
  }
#line 75
  if (rtype == 65UL) {
#line 75
    goto case_65;
  }
#line 76
  if (rtype == 66UL) {
#line 76
    goto case_66;
  }
#line 77
  if (rtype == 67UL) {
#line 77
    goto case_67;
  }
#line 78
  if (rtype == 68UL) {
#line 78
    goto case_68;
  }
#line 79
  if (rtype == 69UL) {
#line 79
    goto case_69;
  }
#line 80
  if (rtype == 70UL) {
#line 80
    goto case_70;
  }
#line 81
  if (rtype == 71UL) {
#line 81
    goto case_71;
  }
#line 82
  if (rtype == 72UL) {
#line 82
    goto case_72;
  }
#line 83
  if (rtype == 73UL) {
#line 83
    goto case_73;
  }
#line 84
  if (rtype == 74UL) {
#line 84
    goto case_74;
  }
#line 85
  if (rtype == 75UL) {
#line 85
    goto case_75;
  }
#line 86
  if (rtype == 76UL) {
#line 86
    goto case_76;
  }
#line 87
  if (rtype == 77UL) {
#line 87
    goto case_77;
  }
#line 88
  if (rtype == 78UL) {
#line 88
    goto case_78;
  }
#line 89
  if (rtype == 79UL) {
#line 89
    goto case_79;
  }
#line 90
  if (rtype == 80UL) {
#line 90
    goto case_80;
  }
#line 91
  if (rtype == 81UL) {
#line 91
    goto case_81;
  }
#line 93
  if (rtype == 128UL) {
#line 93
    goto case_128;
  }
#line 94
  if (rtype == 129UL) {
#line 94
    goto case_129;
  }
#line 95
  if (rtype == 130UL) {
#line 95
    goto case_130;
  }
#line 96
  if (rtype == 131UL) {
#line 96
    goto case_131;
  }
#line 97
  if (rtype == 132UL) {
#line 97
    goto case_132;
  }
#line 98
  if (rtype == 133UL) {
#line 98
    goto case_133;
  }
#line 99
  if (rtype == 134UL) {
#line 99
    goto case_134;
  }
#line 100
  if (rtype == 135UL) {
#line 100
    goto case_135;
  }
#line 101
  if (rtype == 136UL) {
#line 101
    goto case_136;
  }
#line 102
  if (rtype == 141UL) {
#line 102
    goto case_141;
  }
#line 103
  if (rtype == 144UL) {
#line 103
    goto case_144;
  }
#line 104
  if (rtype == 145UL) {
#line 104
    goto case_145;
  }
#line 105
  if (rtype == 146UL) {
#line 105
    goto case_146;
  }
#line 106
  if (rtype == 147UL) {
#line 106
    goto case_147;
  }
#line 107
  if (rtype == 148UL) {
#line 107
    goto case_148;
  }
#line 108
  if (rtype == 149UL) {
#line 108
    goto case_149;
  }
#line 109
  if (rtype == 150UL) {
#line 109
    goto case_150;
  }
#line 111
  goto switch_default;
  case_0: /* CIL Label */ 
#line 33
  return ("R_RX_NONE");
  case_1: /* CIL Label */ 
#line 35
  return ("R_RX_DIR32");
  case_2: /* CIL Label */ 
#line 36
  return ("R_RX_DIR24S");
  case_3: /* CIL Label */ 
#line 37
  return ("R_RX_DIR16");
  case_4: /* CIL Label */ 
#line 38
  return ("R_RX_DIR16U");
  case_5: /* CIL Label */ 
#line 39
  return ("R_RX_DIR16S");
  case_6: /* CIL Label */ 
#line 40
  return ("R_RX_DIR8");
  case_7: /* CIL Label */ 
#line 41
  return ("R_RX_DIR8U");
  case_8: /* CIL Label */ 
#line 42
  return ("R_RX_DIR8S");
  case_9: /* CIL Label */ 
#line 45
  return ("R_RX_DIR24S_PCREL");
  case_10: /* CIL Label */ 
#line 46
  return ("R_RX_DIR16S_PCREL");
  case_11: /* CIL Label */ 
#line 47
  return ("R_RX_DIR8S_PCREL");
  case_12: /* CIL Label */ 
#line 50
  return ("R_RX_DIR16UL");
  case_13: /* CIL Label */ 
#line 51
  return ("R_RX_DIR16UW");
  case_14: /* CIL Label */ 
#line 52
  return ("R_RX_DIR8UL");
  case_15: /* CIL Label */ 
#line 53
  return ("R_RX_DIR8UW");
  case_16: /* CIL Label */ 
#line 54
  return ("R_RX_DIR32_REV");
  case_17: /* CIL Label */ 
#line 55
  return ("R_RX_DIR16_REV");
  case_18: /* CIL Label */ 
#line 56
  return ("R_RX_DIR3U_PCREL");
  case_32: /* CIL Label */ 
#line 59
  return ("R_RX_RH_3_PCREL");
  case_33: /* CIL Label */ 
#line 60
  return ("R_RX_RH_16_OP");
  case_34: /* CIL Label */ 
#line 61
  return ("R_RX_RH_24_OP");
  case_35: /* CIL Label */ 
#line 62
  return ("R_RX_RH_32_OP");
  case_36: /* CIL Label */ 
#line 63
  return ("R_RX_RH_24_UNS");
  case_37: /* CIL Label */ 
#line 64
  return ("R_RX_RH_8_NEG");
  case_38: /* CIL Label */ 
#line 65
  return ("R_RX_RH_16_NEG");
  case_39: /* CIL Label */ 
#line 66
  return ("R_RX_RH_24_NEG");
  case_40: /* CIL Label */ 
#line 67
  return ("R_RX_RH_32_NEG");
  case_41: /* CIL Label */ 
#line 68
  return ("R_RX_RH_DIFF");
  case_42: /* CIL Label */ 
#line 69
  return ("R_RX_RH_GPRELB");
  case_43: /* CIL Label */ 
#line 70
  return ("R_RX_RH_GPRELW");
  case_44: /* CIL Label */ 
#line 71
  return ("R_RX_RH_GPRELL");
  case_45: /* CIL Label */ 
#line 72
  return ("R_RX_RH_RELAX");
  case_65: /* CIL Label */ 
#line 75
  return ("R_RX_ABS32");
  case_66: /* CIL Label */ 
#line 76
  return ("R_RX_ABS24S");
  case_67: /* CIL Label */ 
#line 77
  return ("R_RX_ABS16");
  case_68: /* CIL Label */ 
#line 78
  return ("R_RX_ABS16U");
  case_69: /* CIL Label */ 
#line 79
  return ("R_RX_ABS16S");
  case_70: /* CIL Label */ 
#line 80
  return ("R_RX_ABS8");
  case_71: /* CIL Label */ 
#line 81
  return ("R_RX_ABS8U");
  case_72: /* CIL Label */ 
#line 82
  return ("R_RX_ABS8S");
  case_73: /* CIL Label */ 
#line 83
  return ("R_RX_ABS24S_PCREL");
  case_74: /* CIL Label */ 
#line 84
  return ("R_RX_ABS16S_PCREL");
  case_75: /* CIL Label */ 
#line 85
  return ("R_RX_ABS8S_PCREL");
  case_76: /* CIL Label */ 
#line 86
  return ("R_RX_ABS16UL");
  case_77: /* CIL Label */ 
#line 87
  return ("R_RX_ABS16UW");
  case_78: /* CIL Label */ 
#line 88
  return ("R_RX_ABS8UL");
  case_79: /* CIL Label */ 
#line 89
  return ("R_RX_ABS8UW");
  case_80: /* CIL Label */ 
#line 90
  return ("R_RX_ABS32_REV");
  case_81: /* CIL Label */ 
#line 91
  return ("R_RX_ABS16_REV");
  case_128: /* CIL Label */ 
#line 93
  return ("R_RX_SYM");
  case_129: /* CIL Label */ 
#line 94
  return ("R_RX_OPneg");
  case_130: /* CIL Label */ 
#line 95
  return ("R_RX_OPadd");
  case_131: /* CIL Label */ 
#line 96
  return ("R_RX_OPsub");
  case_132: /* CIL Label */ 
#line 97
  return ("R_RX_OPmul");
  case_133: /* CIL Label */ 
#line 98
  return ("R_RX_OPdiv");
  case_134: /* CIL Label */ 
#line 99
  return ("R_RX_OPshla");
  case_135: /* CIL Label */ 
#line 100
  return ("R_RX_OPshra");
  case_136: /* CIL Label */ 
#line 101
  return ("R_RX_OPsctsize");
  case_141: /* CIL Label */ 
#line 102
  return ("R_RX_OPscttop");
  case_144: /* CIL Label */ 
#line 103
  return ("R_RX_OPand");
  case_145: /* CIL Label */ 
#line 104
  return ("R_RX_OPor");
  case_146: /* CIL Label */ 
#line 105
  return ("R_RX_OPxor");
  case_147: /* CIL Label */ 
#line 106
  return ("R_RX_OPnot");
  case_148: /* CIL Label */ 
#line 107
  return ("R_RX_OPmod");
  case_149: /* CIL Label */ 
#line 108
  return ("R_RX_OPromtop");
  case_150: /* CIL Label */ 
#line 109
  return ("R_RX_OPramtop");
  switch_default: /* CIL Label */ 
#line 111
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 42 "./../include/elf/s390.h"
static char const   *elf_s390_reloc_type(unsigned long rtype ) ;
#line 42 "./../include/elf/s390.h"
static char const   *elf_s390_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 43
  if (rtype == 0UL) {
#line 43
    goto case_0;
  }
#line 44
  if (rtype == 1UL) {
#line 44
    goto case_1;
  }
#line 45
  if (rtype == 2UL) {
#line 45
    goto case_2;
  }
#line 46
  if (rtype == 3UL) {
#line 46
    goto case_3;
  }
#line 47
  if (rtype == 4UL) {
#line 47
    goto case_4;
  }
#line 48
  if (rtype == 5UL) {
#line 48
    goto case_5;
  }
#line 49
  if (rtype == 6UL) {
#line 49
    goto case_6;
  }
#line 50
  if (rtype == 7UL) {
#line 50
    goto case_7;
  }
#line 51
  if (rtype == 8UL) {
#line 51
    goto case_8;
  }
#line 52
  if (rtype == 9UL) {
#line 52
    goto case_9;
  }
#line 53
  if (rtype == 10UL) {
#line 53
    goto case_10;
  }
#line 54
  if (rtype == 11UL) {
#line 54
    goto case_11;
  }
#line 55
  if (rtype == 12UL) {
#line 55
    goto case_12;
  }
#line 56
  if (rtype == 13UL) {
#line 56
    goto case_13;
  }
#line 57
  if (rtype == 14UL) {
#line 57
    goto case_14;
  }
#line 58
  if (rtype == 15UL) {
#line 58
    goto case_15;
  }
#line 59
  if (rtype == 16UL) {
#line 59
    goto case_16;
  }
#line 60
  if (rtype == 17UL) {
#line 60
    goto case_17;
  }
#line 61
  if (rtype == 18UL) {
#line 61
    goto case_18;
  }
#line 62
  if (rtype == 19UL) {
#line 62
    goto case_19;
  }
#line 63
  if (rtype == 20UL) {
#line 63
    goto case_20;
  }
#line 64
  if (rtype == 21UL) {
#line 64
    goto case_21;
  }
#line 65
  if (rtype == 22UL) {
#line 65
    goto case_22;
  }
#line 66
  if (rtype == 23UL) {
#line 66
    goto case_23;
  }
#line 67
  if (rtype == 24UL) {
#line 67
    goto case_24;
  }
#line 68
  if (rtype == 25UL) {
#line 68
    goto case_25;
  }
#line 69
  if (rtype == 26UL) {
#line 69
    goto case_26;
  }
#line 70
  if (rtype == 27UL) {
#line 70
    goto case_27;
  }
#line 71
  if (rtype == 28UL) {
#line 71
    goto case_28;
  }
#line 72
  if (rtype == 29UL) {
#line 72
    goto case_29;
  }
#line 73
  if (rtype == 30UL) {
#line 73
    goto case_30;
  }
#line 74
  if (rtype == 31UL) {
#line 74
    goto case_31;
  }
#line 75
  if (rtype == 32UL) {
#line 75
    goto case_32;
  }
#line 76
  if (rtype == 33UL) {
#line 76
    goto case_33;
  }
#line 77
  if (rtype == 34UL) {
#line 77
    goto case_34;
  }
#line 78
  if (rtype == 35UL) {
#line 78
    goto case_35;
  }
#line 79
  if (rtype == 36UL) {
#line 79
    goto case_36;
  }
#line 80
  if (rtype == 37UL) {
#line 80
    goto case_37;
  }
#line 81
  if (rtype == 38UL) {
#line 81
    goto case_38;
  }
#line 83
  if (rtype == 39UL) {
#line 83
    goto case_39;
  }
#line 85
  if (rtype == 40UL) {
#line 85
    goto case_40;
  }
#line 87
  if (rtype == 41UL) {
#line 87
    goto case_41;
  }
#line 89
  if (rtype == 42UL) {
#line 89
    goto case_42;
  }
#line 91
  if (rtype == 43UL) {
#line 91
    goto case_43;
  }
#line 93
  if (rtype == 44UL) {
#line 93
    goto case_44;
  }
#line 95
  if (rtype == 45UL) {
#line 95
    goto case_45;
  }
#line 97
  if (rtype == 46UL) {
#line 97
    goto case_46;
  }
#line 99
  if (rtype == 47UL) {
#line 99
    goto case_47;
  }
#line 101
  if (rtype == 48UL) {
#line 101
    goto case_48;
  }
#line 103
  if (rtype == 49UL) {
#line 103
    goto case_49;
  }
#line 105
  if (rtype == 50UL) {
#line 105
    goto case_50;
  }
#line 107
  if (rtype == 51UL) {
#line 107
    goto case_51;
  }
#line 109
  if (rtype == 52UL) {
#line 109
    goto case_52;
  }
#line 111
  if (rtype == 53UL) {
#line 111
    goto case_53;
  }
#line 113
  if (rtype == 54UL) {
#line 113
    goto case_54;
  }
#line 114
  if (rtype == 55UL) {
#line 114
    goto case_55;
  }
#line 115
  if (rtype == 56UL) {
#line 115
    goto case_56;
  }
#line 117
  if (rtype == 57UL) {
#line 117
    goto case_57;
  }
#line 118
  if (rtype == 58UL) {
#line 118
    goto case_58;
  }
#line 119
  if (rtype == 59UL) {
#line 119
    goto case_59;
  }
#line 120
  if (rtype == 60UL) {
#line 120
    goto case_60;
  }
#line 122
  if (rtype == 61UL) {
#line 122
    goto case_61;
  }
#line 124
  if (rtype == 250UL) {
#line 124
    goto case_250;
  }
#line 125
  if (rtype == 251UL) {
#line 125
    goto case_251;
  }
#line 126
  goto switch_default;
  case_0: /* CIL Label */ 
#line 43
  return ("R_390_NONE");
  case_1: /* CIL Label */ 
#line 44
  return ("R_390_8");
  case_2: /* CIL Label */ 
#line 45
  return ("R_390_12");
  case_3: /* CIL Label */ 
#line 46
  return ("R_390_16");
  case_4: /* CIL Label */ 
#line 47
  return ("R_390_32");
  case_5: /* CIL Label */ 
#line 48
  return ("R_390_PC32");
  case_6: /* CIL Label */ 
#line 49
  return ("R_390_GOT12");
  case_7: /* CIL Label */ 
#line 50
  return ("R_390_GOT32");
  case_8: /* CIL Label */ 
#line 51
  return ("R_390_PLT32");
  case_9: /* CIL Label */ 
#line 52
  return ("R_390_COPY");
  case_10: /* CIL Label */ 
#line 53
  return ("R_390_GLOB_DAT");
  case_11: /* CIL Label */ 
#line 54
  return ("R_390_JMP_SLOT");
  case_12: /* CIL Label */ 
#line 55
  return ("R_390_RELATIVE");
  case_13: /* CIL Label */ 
#line 56
  return ("R_390_GOTOFF32");
  case_14: /* CIL Label */ 
#line 57
  return ("R_390_GOTPC");
  case_15: /* CIL Label */ 
#line 58
  return ("R_390_GOT16");
  case_16: /* CIL Label */ 
#line 59
  return ("R_390_PC16");
  case_17: /* CIL Label */ 
#line 60
  return ("R_390_PC16DBL");
  case_18: /* CIL Label */ 
#line 61
  return ("R_390_PLT16DBL");
  case_19: /* CIL Label */ 
#line 62
  return ("R_390_PC32DBL");
  case_20: /* CIL Label */ 
#line 63
  return ("R_390_PLT32DBL");
  case_21: /* CIL Label */ 
#line 64
  return ("R_390_GOTPCDBL");
  case_22: /* CIL Label */ 
#line 65
  return ("R_390_64");
  case_23: /* CIL Label */ 
#line 66
  return ("R_390_PC64");
  case_24: /* CIL Label */ 
#line 67
  return ("R_390_GOT64");
  case_25: /* CIL Label */ 
#line 68
  return ("R_390_PLT64");
  case_26: /* CIL Label */ 
#line 69
  return ("R_390_GOTENT");
  case_27: /* CIL Label */ 
#line 70
  return ("R_390_GOTOFF16");
  case_28: /* CIL Label */ 
#line 71
  return ("R_390_GOTOFF64");
  case_29: /* CIL Label */ 
#line 72
  return ("R_390_GOTPLT12");
  case_30: /* CIL Label */ 
#line 73
  return ("R_390_GOTPLT16");
  case_31: /* CIL Label */ 
#line 74
  return ("R_390_GOTPLT32");
  case_32: /* CIL Label */ 
#line 75
  return ("R_390_GOTPLT64");
  case_33: /* CIL Label */ 
#line 76
  return ("R_390_GOTPLTENT");
  case_34: /* CIL Label */ 
#line 77
  return ("R_390_PLTOFF16");
  case_35: /* CIL Label */ 
#line 78
  return ("R_390_PLTOFF32");
  case_36: /* CIL Label */ 
#line 79
  return ("R_390_PLTOFF64");
  case_37: /* CIL Label */ 
#line 80
  return ("R_390_TLS_LOAD");
  case_38: /* CIL Label */ 
#line 81
  return ("R_390_TLS_GDCALL");
  case_39: /* CIL Label */ 
#line 83
  return ("R_390_TLS_LDCALL");
  case_40: /* CIL Label */ 
#line 85
  return ("R_390_TLS_GD32");
  case_41: /* CIL Label */ 
#line 87
  return ("R_390_TLS_GD64");
  case_42: /* CIL Label */ 
#line 89
  return ("R_390_TLS_GOTIE12");
  case_43: /* CIL Label */ 
#line 91
  return ("R_390_TLS_GOTIE32");
  case_44: /* CIL Label */ 
#line 93
  return ("R_390_TLS_GOTIE64");
  case_45: /* CIL Label */ 
#line 95
  return ("R_390_TLS_LDM32");
  case_46: /* CIL Label */ 
#line 97
  return ("R_390_TLS_LDM64");
  case_47: /* CIL Label */ 
#line 99
  return ("R_390_TLS_IE32");
  case_48: /* CIL Label */ 
#line 101
  return ("R_390_TLS_IE64");
  case_49: /* CIL Label */ 
#line 103
  return ("R_390_TLS_IEENT");
  case_50: /* CIL Label */ 
#line 105
  return ("R_390_TLS_LE32");
  case_51: /* CIL Label */ 
#line 107
  return ("R_390_TLS_LE64");
  case_52: /* CIL Label */ 
#line 109
  return ("R_390_TLS_LDO32");
  case_53: /* CIL Label */ 
#line 111
  return ("R_390_TLS_LDO64");
  case_54: /* CIL Label */ 
#line 113
  return ("R_390_TLS_DTPMOD");
  case_55: /* CIL Label */ 
#line 114
  return ("R_390_TLS_DTPOFF");
  case_56: /* CIL Label */ 
#line 115
  return ("R_390_TLS_TPOFF");
  case_57: /* CIL Label */ 
#line 117
  return ("R_390_20");
  case_58: /* CIL Label */ 
#line 118
  return ("R_390_GOT20");
  case_59: /* CIL Label */ 
#line 119
  return ("R_390_GOTPLT20");
  case_60: /* CIL Label */ 
#line 120
  return ("R_390_TLS_GOTIE20");
  case_61: /* CIL Label */ 
#line 122
  return ("R_390_IRELATIVE");
  case_250: /* CIL Label */ 
#line 124
  return ("R_390_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 125
  return ("R_390_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 126
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 105 "./../include/elf/score.h"
static char const   *elf_score_reloc_type(unsigned long rtype ) ;
#line 105 "./../include/elf/score.h"
static char const   *elf_score_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 106
  if (rtype == 0UL) {
#line 106
    goto case_0;
  }
#line 107
  if (rtype == 1UL) {
#line 107
    goto case_1;
  }
#line 108
  if (rtype == 2UL) {
#line 108
    goto case_2;
  }
#line 109
  if (rtype == 3UL) {
#line 109
    goto case_3;
  }
#line 110
  if (rtype == 4UL) {
#line 110
    goto case_4;
  }
#line 111
  if (rtype == 5UL) {
#line 111
    goto case_5;
  }
#line 112
  if (rtype == 6UL) {
#line 112
    goto case_6;
  }
#line 113
  if (rtype == 7UL) {
#line 113
    goto case_7;
  }
#line 114
  if (rtype == 8UL) {
#line 114
    goto case_8;
  }
#line 115
  if (rtype == 9UL) {
#line 115
    goto case_9;
  }
#line 116
  if (rtype == 10UL) {
#line 116
    goto case_10;
  }
#line 117
  if (rtype == 11UL) {
#line 117
    goto case_11;
  }
#line 118
  if (rtype == 12UL) {
#line 118
    goto case_12;
  }
#line 119
  if (rtype == 13UL) {
#line 119
    goto case_13;
  }
#line 120
  if (rtype == 14UL) {
#line 120
    goto case_14;
  }
#line 121
  if (rtype == 15UL) {
#line 121
    goto case_15;
  }
#line 122
  if (rtype == 16UL) {
#line 122
    goto case_16;
  }
#line 123
  if (rtype == 17UL) {
#line 123
    goto case_17;
  }
#line 124
  if (rtype == 18UL) {
#line 124
    goto case_18;
  }
#line 125
  if (rtype == 19UL) {
#line 125
    goto case_19;
  }
#line 126
  if (rtype == 20UL) {
#line 126
    goto case_20;
  }
#line 127
  if (rtype == 21UL) {
#line 127
    goto case_21;
  }
#line 128
  goto switch_default;
  case_0: /* CIL Label */ 
#line 106
  return ("R_SCORE_NONE");
  case_1: /* CIL Label */ 
#line 107
  return ("R_SCORE_HI16");
  case_2: /* CIL Label */ 
#line 108
  return ("R_SCORE_LO16");
  case_3: /* CIL Label */ 
#line 109
  return ("R_SCORE_BCMP");
  case_4: /* CIL Label */ 
#line 110
  return ("R_SCORE_24");
  case_5: /* CIL Label */ 
#line 111
  return ("R_SCORE_PC19");
  case_6: /* CIL Label */ 
#line 112
  return ("R_SCORE16_11");
  case_7: /* CIL Label */ 
#line 113
  return ("R_SCORE16_PC8");
  case_8: /* CIL Label */ 
#line 114
  return ("R_SCORE_ABS32");
  case_9: /* CIL Label */ 
#line 115
  return ("R_SCORE_ABS16");
  case_10: /* CIL Label */ 
#line 116
  return ("R_SCORE_DUMMY2");
  case_11: /* CIL Label */ 
#line 117
  return ("R_SCORE_GP15");
  case_12: /* CIL Label */ 
#line 118
  return ("R_SCORE_GNU_VTINHERIT");
  case_13: /* CIL Label */ 
#line 119
  return ("R_SCORE_GNU_VTENTRY");
  case_14: /* CIL Label */ 
#line 120
  return ("R_SCORE_GOT15");
  case_15: /* CIL Label */ 
#line 121
  return ("R_SCORE_GOT_LO16");
  case_16: /* CIL Label */ 
#line 122
  return ("R_SCORE_CALL15");
  case_17: /* CIL Label */ 
#line 123
  return ("R_SCORE_GPREL32");
  case_18: /* CIL Label */ 
#line 124
  return ("R_SCORE_REL32");
  case_19: /* CIL Label */ 
#line 125
  return ("R_SCORE_DUMMY_HI16");
  case_20: /* CIL Label */ 
#line 126
  return ("R_SCORE_IMM30");
  case_21: /* CIL Label */ 
#line 127
  return ("R_SCORE_IMM32");
  switch_default: /* CIL Label */ 
#line 128
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 121 "./../include/elf/sh.h"
static char const   *elf_sh_reloc_type(unsigned long rtype ) ;
#line 121 "./../include/elf/sh.h"
static char const   *elf_sh_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 122
  if (rtype == 0UL) {
#line 122
    goto case_0;
  }
#line 123
  if (rtype == 1UL) {
#line 123
    goto case_1;
  }
#line 124
  if (rtype == 2UL) {
#line 124
    goto case_2;
  }
#line 125
  if (rtype == 3UL) {
#line 125
    goto case_3;
  }
#line 126
  if (rtype == 4UL) {
#line 126
    goto case_4;
  }
#line 127
  if (rtype == 5UL) {
#line 127
    goto case_5;
  }
#line 128
  if (rtype == 6UL) {
#line 128
    goto case_6;
  }
#line 129
  if (rtype == 7UL) {
#line 129
    goto case_7;
  }
#line 130
  if (rtype == 8UL) {
#line 130
    goto case_8;
  }
#line 131
  if (rtype == 9UL) {
#line 131
    goto case_9;
  }
#line 133
  if (rtype == 10UL) {
#line 133
    goto case_10;
  }
#line 134
  if (rtype == 11UL) {
#line 134
    goto case_11;
  }
#line 139
  if (rtype == 22UL) {
#line 139
    goto case_22;
  }
#line 140
  if (rtype == 23UL) {
#line 140
    goto case_23;
  }
#line 141
  if (rtype == 24UL) {
#line 141
    goto case_24;
  }
#line 142
  if (rtype == 25UL) {
#line 142
    goto case_25;
  }
#line 143
  if (rtype == 26UL) {
#line 143
    goto case_26;
  }
#line 144
  if (rtype == 27UL) {
#line 144
    goto case_27;
  }
#line 145
  if (rtype == 28UL) {
#line 145
    goto case_28;
  }
#line 146
  if (rtype == 29UL) {
#line 146
    goto case_29;
  }
#line 147
  if (rtype == 30UL) {
#line 147
    goto case_30;
  }
#line 148
  if (rtype == 31UL) {
#line 148
    goto case_31;
  }
#line 149
  if (rtype == 32UL) {
#line 149
    goto case_32;
  }
#line 151
  if (rtype == 33UL) {
#line 151
    goto case_33;
  }
#line 152
  if (rtype == 34UL) {
#line 152
    goto case_34;
  }
#line 153
  if (rtype == 35UL) {
#line 153
    goto case_35;
  }
#line 154
  if (rtype == 36UL) {
#line 154
    goto case_36;
  }
#line 155
  if (rtype == 37UL) {
#line 155
    goto case_37;
  }
#line 156
  if (rtype == 38UL) {
#line 156
    goto case_38;
  }
#line 157
  if (rtype == 39UL) {
#line 157
    goto case_39;
  }
#line 158
  if (rtype == 40UL) {
#line 158
    goto case_40;
  }
#line 159
  if (rtype == 41UL) {
#line 159
    goto case_41;
  }
#line 160
  if (rtype == 42UL) {
#line 160
    goto case_42;
  }
#line 161
  if (rtype == 43UL) {
#line 161
    goto case_43;
  }
#line 162
  if (rtype == 44UL) {
#line 162
    goto case_44;
  }
#line 163
  if (rtype == 45UL) {
#line 163
    goto case_45;
  }
#line 164
  if (rtype == 46UL) {
#line 164
    goto case_46;
  }
#line 165
  if (rtype == 47UL) {
#line 165
    goto case_47;
  }
#line 166
  if (rtype == 48UL) {
#line 166
    goto case_48;
  }
#line 167
  if (rtype == 49UL) {
#line 167
    goto case_49;
  }
#line 168
  if (rtype == 50UL) {
#line 168
    goto case_50;
  }
#line 169
  if (rtype == 51UL) {
#line 169
    goto case_51;
  }
#line 172
  if (rtype == 53UL) {
#line 172
    goto case_53;
  }
#line 175
  if (rtype == 144UL) {
#line 175
    goto case_144;
  }
#line 176
  if (rtype == 145UL) {
#line 176
    goto case_145;
  }
#line 177
  if (rtype == 146UL) {
#line 177
    goto case_146;
  }
#line 178
  if (rtype == 147UL) {
#line 178
    goto case_147;
  }
#line 179
  if (rtype == 148UL) {
#line 179
    goto case_148;
  }
#line 180
  if (rtype == 149UL) {
#line 180
    goto case_149;
  }
#line 181
  if (rtype == 150UL) {
#line 181
    goto case_150;
  }
#line 182
  if (rtype == 151UL) {
#line 182
    goto case_151;
  }
#line 185
  if (rtype == 160UL) {
#line 185
    goto case_160;
  }
#line 186
  if (rtype == 161UL) {
#line 186
    goto case_161;
  }
#line 187
  if (rtype == 162UL) {
#line 187
    goto case_162;
  }
#line 188
  if (rtype == 163UL) {
#line 188
    goto case_163;
  }
#line 189
  if (rtype == 164UL) {
#line 189
    goto case_164;
  }
#line 190
  if (rtype == 165UL) {
#line 190
    goto case_165;
  }
#line 191
  if (rtype == 166UL) {
#line 191
    goto case_166;
  }
#line 192
  if (rtype == 167UL) {
#line 192
    goto case_167;
  }
#line 193
  if (rtype == 168UL) {
#line 193
    goto case_168;
  }
#line 194
  if (rtype == 169UL) {
#line 194
    goto case_169;
  }
#line 195
  if (rtype == 170UL) {
#line 195
    goto case_170;
  }
#line 196
  if (rtype == 171UL) {
#line 196
    goto case_171;
  }
#line 197
  if (rtype == 172UL) {
#line 197
    goto case_172;
  }
#line 198
  if (rtype == 173UL) {
#line 198
    goto case_173;
  }
#line 199
  if (rtype == 174UL) {
#line 199
    goto case_174;
  }
#line 200
  if (rtype == 175UL) {
#line 200
    goto case_175;
  }
#line 201
  if (rtype == 176UL) {
#line 201
    goto case_176;
  }
#line 202
  if (rtype == 177UL) {
#line 202
    goto case_177;
  }
#line 203
  if (rtype == 178UL) {
#line 203
    goto case_178;
  }
#line 204
  if (rtype == 179UL) {
#line 204
    goto case_179;
  }
#line 205
  if (rtype == 180UL) {
#line 205
    goto case_180;
  }
#line 206
  if (rtype == 181UL) {
#line 206
    goto case_181;
  }
#line 207
  if (rtype == 182UL) {
#line 207
    goto case_182;
  }
#line 208
  if (rtype == 183UL) {
#line 208
    goto case_183;
  }
#line 209
  if (rtype == 184UL) {
#line 209
    goto case_184;
  }
#line 210
  if (rtype == 185UL) {
#line 210
    goto case_185;
  }
#line 211
  if (rtype == 186UL) {
#line 211
    goto case_186;
  }
#line 212
  if (rtype == 187UL) {
#line 212
    goto case_187;
  }
#line 213
  if (rtype == 188UL) {
#line 213
    goto case_188;
  }
#line 214
  if (rtype == 189UL) {
#line 214
    goto case_189;
  }
#line 215
  if (rtype == 190UL) {
#line 215
    goto case_190;
  }
#line 216
  if (rtype == 191UL) {
#line 216
    goto case_191;
  }
#line 217
  if (rtype == 192UL) {
#line 217
    goto case_192;
  }
#line 218
  if (rtype == 193UL) {
#line 218
    goto case_193;
  }
#line 219
  if (rtype == 194UL) {
#line 219
    goto case_194;
  }
#line 220
  if (rtype == 195UL) {
#line 220
    goto case_195;
  }
#line 221
  if (rtype == 196UL) {
#line 221
    goto case_196;
  }
#line 224
  if (rtype == 201UL) {
#line 224
    goto case_201;
  }
#line 225
  if (rtype == 202UL) {
#line 225
    goto case_202;
  }
#line 226
  if (rtype == 203UL) {
#line 226
    goto case_203;
  }
#line 227
  if (rtype == 204UL) {
#line 227
    goto case_204;
  }
#line 228
  if (rtype == 205UL) {
#line 228
    goto case_205;
  }
#line 229
  if (rtype == 206UL) {
#line 229
    goto case_206;
  }
#line 230
  if (rtype == 207UL) {
#line 230
    goto case_207;
  }
#line 231
  if (rtype == 208UL) {
#line 231
    goto case_208;
  }
#line 234
  if (rtype == 242UL) {
#line 234
    goto case_242;
  }
#line 235
  if (rtype == 243UL) {
#line 235
    goto case_243;
  }
#line 236
  if (rtype == 244UL) {
#line 236
    goto case_244;
  }
#line 237
  if (rtype == 245UL) {
#line 237
    goto case_245;
  }
#line 238
  if (rtype == 246UL) {
#line 238
    goto case_246;
  }
#line 239
  if (rtype == 247UL) {
#line 239
    goto case_247;
  }
#line 240
  if (rtype == 248UL) {
#line 240
    goto case_248;
  }
#line 241
  if (rtype == 249UL) {
#line 241
    goto case_249;
  }
#line 242
  if (rtype == 250UL) {
#line 242
    goto case_250;
  }
#line 243
  if (rtype == 251UL) {
#line 243
    goto case_251;
  }
#line 244
  if (rtype == 252UL) {
#line 244
    goto case_252;
  }
#line 245
  if (rtype == 253UL) {
#line 245
    goto case_253;
  }
#line 246
  if (rtype == 254UL) {
#line 246
    goto case_254;
  }
#line 247
  if (rtype == 255UL) {
#line 247
    goto case_255;
  }
#line 248
  goto switch_default;
  case_0: /* CIL Label */ 
#line 122
  return ("R_SH_NONE");
  case_1: /* CIL Label */ 
#line 123
  return ("R_SH_DIR32");
  case_2: /* CIL Label */ 
#line 124
  return ("R_SH_REL32");
  case_3: /* CIL Label */ 
#line 125
  return ("R_SH_DIR8WPN");
  case_4: /* CIL Label */ 
#line 126
  return ("R_SH_IND12W");
  case_5: /* CIL Label */ 
#line 127
  return ("R_SH_DIR8WPL");
  case_6: /* CIL Label */ 
#line 128
  return ("R_SH_DIR8WPZ");
  case_7: /* CIL Label */ 
#line 129
  return ("R_SH_DIR8BP");
  case_8: /* CIL Label */ 
#line 130
  return ("R_SH_DIR8W");
  case_9: /* CIL Label */ 
#line 131
  return ("R_SH_DIR8L");
  case_10: /* CIL Label */ 
#line 133
  return ("R_SH_LOOP_START");
  case_11: /* CIL Label */ 
#line 134
  return ("R_SH_LOOP_END");
  case_22: /* CIL Label */ 
#line 139
  return ("R_SH_GNU_VTINHERIT");
  case_23: /* CIL Label */ 
#line 140
  return ("R_SH_GNU_VTENTRY");
  case_24: /* CIL Label */ 
#line 141
  return ("R_SH_SWITCH8");
  case_25: /* CIL Label */ 
#line 142
  return ("R_SH_SWITCH16");
  case_26: /* CIL Label */ 
#line 143
  return ("R_SH_SWITCH32");
  case_27: /* CIL Label */ 
#line 144
  return ("R_SH_USES");
  case_28: /* CIL Label */ 
#line 145
  return ("R_SH_COUNT");
  case_29: /* CIL Label */ 
#line 146
  return ("R_SH_ALIGN");
  case_30: /* CIL Label */ 
#line 147
  return ("R_SH_CODE");
  case_31: /* CIL Label */ 
#line 148
  return ("R_SH_DATA");
  case_32: /* CIL Label */ 
#line 149
  return ("R_SH_LABEL");
  case_33: /* CIL Label */ 
#line 151
  return ("R_SH_DIR16");
  case_34: /* CIL Label */ 
#line 152
  return ("R_SH_DIR8");
  case_35: /* CIL Label */ 
#line 153
  return ("R_SH_DIR8UL");
  case_36: /* CIL Label */ 
#line 154
  return ("R_SH_DIR8UW");
  case_37: /* CIL Label */ 
#line 155
  return ("R_SH_DIR8U");
  case_38: /* CIL Label */ 
#line 156
  return ("R_SH_DIR8SW");
  case_39: /* CIL Label */ 
#line 157
  return ("R_SH_DIR8S");
  case_40: /* CIL Label */ 
#line 158
  return ("R_SH_DIR4UL");
  case_41: /* CIL Label */ 
#line 159
  return ("R_SH_DIR4UW");
  case_42: /* CIL Label */ 
#line 160
  return ("R_SH_DIR4U");
  case_43: /* CIL Label */ 
#line 161
  return ("R_SH_PSHA");
  case_44: /* CIL Label */ 
#line 162
  return ("R_SH_PSHL");
  case_45: /* CIL Label */ 
#line 163
  return ("R_SH_DIR5U");
  case_46: /* CIL Label */ 
#line 164
  return ("R_SH_DIR6U");
  case_47: /* CIL Label */ 
#line 165
  return ("R_SH_DIR6S");
  case_48: /* CIL Label */ 
#line 166
  return ("R_SH_DIR10S");
  case_49: /* CIL Label */ 
#line 167
  return ("R_SH_DIR10SW");
  case_50: /* CIL Label */ 
#line 168
  return ("R_SH_DIR10SL");
  case_51: /* CIL Label */ 
#line 169
  return ("R_SH_DIR10SQ");
  case_53: /* CIL Label */ 
#line 172
  return ("R_SH_DIR16S");
  case_144: /* CIL Label */ 
#line 175
  return ("R_SH_TLS_GD_32");
  case_145: /* CIL Label */ 
#line 176
  return ("R_SH_TLS_LD_32");
  case_146: /* CIL Label */ 
#line 177
  return ("R_SH_TLS_LDO_32");
  case_147: /* CIL Label */ 
#line 178
  return ("R_SH_TLS_IE_32");
  case_148: /* CIL Label */ 
#line 179
  return ("R_SH_TLS_LE_32");
  case_149: /* CIL Label */ 
#line 180
  return ("R_SH_TLS_DTPMOD32");
  case_150: /* CIL Label */ 
#line 181
  return ("R_SH_TLS_DTPOFF32");
  case_151: /* CIL Label */ 
#line 182
  return ("R_SH_TLS_TPOFF32");
  case_160: /* CIL Label */ 
#line 185
  return ("R_SH_GOT32");
  case_161: /* CIL Label */ 
#line 186
  return ("R_SH_PLT32");
  case_162: /* CIL Label */ 
#line 187
  return ("R_SH_COPY");
  case_163: /* CIL Label */ 
#line 188
  return ("R_SH_GLOB_DAT");
  case_164: /* CIL Label */ 
#line 189
  return ("R_SH_JMP_SLOT");
  case_165: /* CIL Label */ 
#line 190
  return ("R_SH_RELATIVE");
  case_166: /* CIL Label */ 
#line 191
  return ("R_SH_GOTOFF");
  case_167: /* CIL Label */ 
#line 192
  return ("R_SH_GOTPC");
  case_168: /* CIL Label */ 
#line 193
  return ("R_SH_GOTPLT32");
  case_169: /* CIL Label */ 
#line 194
  return ("R_SH_GOT_LOW16");
  case_170: /* CIL Label */ 
#line 195
  return ("R_SH_GOT_MEDLOW16");
  case_171: /* CIL Label */ 
#line 196
  return ("R_SH_GOT_MEDHI16");
  case_172: /* CIL Label */ 
#line 197
  return ("R_SH_GOT_HI16");
  case_173: /* CIL Label */ 
#line 198
  return ("R_SH_GOTPLT_LOW16");
  case_174: /* CIL Label */ 
#line 199
  return ("R_SH_GOTPLT_MEDLOW16");
  case_175: /* CIL Label */ 
#line 200
  return ("R_SH_GOTPLT_MEDHI16");
  case_176: /* CIL Label */ 
#line 201
  return ("R_SH_GOTPLT_HI16");
  case_177: /* CIL Label */ 
#line 202
  return ("R_SH_PLT_LOW16");
  case_178: /* CIL Label */ 
#line 203
  return ("R_SH_PLT_MEDLOW16");
  case_179: /* CIL Label */ 
#line 204
  return ("R_SH_PLT_MEDHI16");
  case_180: /* CIL Label */ 
#line 205
  return ("R_SH_PLT_HI16");
  case_181: /* CIL Label */ 
#line 206
  return ("R_SH_GOTOFF_LOW16");
  case_182: /* CIL Label */ 
#line 207
  return ("R_SH_GOTOFF_MEDLOW16");
  case_183: /* CIL Label */ 
#line 208
  return ("R_SH_GOTOFF_MEDHI16");
  case_184: /* CIL Label */ 
#line 209
  return ("R_SH_GOTOFF_HI16");
  case_185: /* CIL Label */ 
#line 210
  return ("R_SH_GOTPC_LOW16");
  case_186: /* CIL Label */ 
#line 211
  return ("R_SH_GOTPC_MEDLOW16");
  case_187: /* CIL Label */ 
#line 212
  return ("R_SH_GOTPC_MEDHI16");
  case_188: /* CIL Label */ 
#line 213
  return ("R_SH_GOTPC_HI16");
  case_189: /* CIL Label */ 
#line 214
  return ("R_SH_GOT10BY4");
  case_190: /* CIL Label */ 
#line 215
  return ("R_SH_GOTPLT10BY4");
  case_191: /* CIL Label */ 
#line 216
  return ("R_SH_GOT10BY8");
  case_192: /* CIL Label */ 
#line 217
  return ("R_SH_GOTPLT10BY8");
  case_193: /* CIL Label */ 
#line 218
  return ("R_SH_COPY64");
  case_194: /* CIL Label */ 
#line 219
  return ("R_SH_GLOB_DAT64");
  case_195: /* CIL Label */ 
#line 220
  return ("R_SH_JMP_SLOT64");
  case_196: /* CIL Label */ 
#line 221
  return ("R_SH_RELATIVE64");
  case_201: /* CIL Label */ 
#line 224
  return ("R_SH_GOT20");
  case_202: /* CIL Label */ 
#line 225
  return ("R_SH_GOTOFF20");
  case_203: /* CIL Label */ 
#line 226
  return ("R_SH_GOTFUNCDESC");
  case_204: /* CIL Label */ 
#line 227
  return ("R_SH_GOTFUNCDESC20");
  case_205: /* CIL Label */ 
#line 228
  return ("R_SH_GOTOFFFUNCDESC");
  case_206: /* CIL Label */ 
#line 229
  return ("R_SH_GOTOFFFUNCDESC20");
  case_207: /* CIL Label */ 
#line 230
  return ("R_SH_FUNCDESC");
  case_208: /* CIL Label */ 
#line 231
  return ("R_SH_FUNCDESC_VALUE");
  case_242: /* CIL Label */ 
#line 234
  return ("R_SH_SHMEDIA_CODE");
  case_243: /* CIL Label */ 
#line 235
  return ("R_SH_PT_16");
  case_244: /* CIL Label */ 
#line 236
  return ("R_SH_IMMS16");
  case_245: /* CIL Label */ 
#line 237
  return ("R_SH_IMMU16");
  case_246: /* CIL Label */ 
#line 238
  return ("R_SH_IMM_LOW16");
  case_247: /* CIL Label */ 
#line 239
  return ("R_SH_IMM_LOW16_PCREL");
  case_248: /* CIL Label */ 
#line 240
  return ("R_SH_IMM_MEDLOW16");
  case_249: /* CIL Label */ 
#line 241
  return ("R_SH_IMM_MEDLOW16_PCREL");
  case_250: /* CIL Label */ 
#line 242
  return ("R_SH_IMM_MEDHI16");
  case_251: /* CIL Label */ 
#line 243
  return ("R_SH_IMM_MEDHI16_PCREL");
  case_252: /* CIL Label */ 
#line 244
  return ("R_SH_IMM_HI16");
  case_253: /* CIL Label */ 
#line 245
  return ("R_SH_IMM_HI16_PCREL");
  case_254: /* CIL Label */ 
#line 246
  return ("R_SH_64");
  case_255: /* CIL Label */ 
#line 247
  return ("R_SH_64_PCREL");
  switch_default: /* CIL Label */ 
#line 248
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 64 "./../include/elf/sparc.h"
static char const   *elf_sparc_reloc_type(unsigned long rtype ) ;
#line 64 "./../include/elf/sparc.h"
static char const   *elf_sparc_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 65
  if (rtype == 0UL) {
#line 65
    goto case_0;
  }
#line 66
  if (rtype == 1UL) {
#line 66
    goto case_1;
  }
#line 67
  if (rtype == 2UL) {
#line 67
    goto case_2;
  }
#line 68
  if (rtype == 3UL) {
#line 68
    goto case_3;
  }
#line 69
  if (rtype == 4UL) {
#line 69
    goto case_4;
  }
#line 70
  if (rtype == 5UL) {
#line 70
    goto case_5;
  }
#line 71
  if (rtype == 6UL) {
#line 71
    goto case_6;
  }
#line 72
  if (rtype == 7UL) {
#line 72
    goto case_7;
  }
#line 73
  if (rtype == 8UL) {
#line 73
    goto case_8;
  }
#line 74
  if (rtype == 9UL) {
#line 74
    goto case_9;
  }
#line 75
  if (rtype == 10UL) {
#line 75
    goto case_10;
  }
#line 76
  if (rtype == 11UL) {
#line 76
    goto case_11;
  }
#line 77
  if (rtype == 12UL) {
#line 77
    goto case_12;
  }
#line 78
  if (rtype == 13UL) {
#line 78
    goto case_13;
  }
#line 79
  if (rtype == 14UL) {
#line 79
    goto case_14;
  }
#line 80
  if (rtype == 15UL) {
#line 80
    goto case_15;
  }
#line 81
  if (rtype == 16UL) {
#line 81
    goto case_16;
  }
#line 82
  if (rtype == 17UL) {
#line 82
    goto case_17;
  }
#line 83
  if (rtype == 18UL) {
#line 83
    goto case_18;
  }
#line 84
  if (rtype == 19UL) {
#line 84
    goto case_19;
  }
#line 85
  if (rtype == 20UL) {
#line 85
    goto case_20;
  }
#line 86
  if (rtype == 21UL) {
#line 86
    goto case_21;
  }
#line 87
  if (rtype == 22UL) {
#line 87
    goto case_22;
  }
#line 88
  if (rtype == 23UL) {
#line 88
    goto case_23;
  }
#line 95
  if (rtype == 24UL) {
#line 95
    goto case_24;
  }
#line 96
  if (rtype == 25UL) {
#line 96
    goto case_25;
  }
#line 97
  if (rtype == 26UL) {
#line 97
    goto case_26;
  }
#line 98
  if (rtype == 27UL) {
#line 98
    goto case_27;
  }
#line 99
  if (rtype == 28UL) {
#line 99
    goto case_28;
  }
#line 100
  if (rtype == 29UL) {
#line 100
    goto case_29;
  }
#line 104
  if (rtype == 30UL) {
#line 104
    goto case_30;
  }
#line 105
  if (rtype == 31UL) {
#line 105
    goto case_31;
  }
#line 106
  if (rtype == 32UL) {
#line 106
    goto case_32;
  }
#line 107
  if (rtype == 33UL) {
#line 107
    goto case_33;
  }
#line 108
  if (rtype == 34UL) {
#line 108
    goto case_34;
  }
#line 109
  if (rtype == 35UL) {
#line 109
    goto case_35;
  }
#line 110
  if (rtype == 36UL) {
#line 110
    goto case_36;
  }
#line 111
  if (rtype == 37UL) {
#line 111
    goto case_37;
  }
#line 112
  if (rtype == 38UL) {
#line 112
    goto case_38;
  }
#line 113
  if (rtype == 39UL) {
#line 113
    goto case_39;
  }
#line 114
  if (rtype == 40UL) {
#line 114
    goto case_40;
  }
#line 115
  if (rtype == 41UL) {
#line 115
    goto case_41;
  }
#line 116
  if (rtype == 42UL) {
#line 116
    goto case_42;
  }
#line 117
  if (rtype == 43UL) {
#line 117
    goto case_43;
  }
#line 118
  if (rtype == 44UL) {
#line 118
    goto case_44;
  }
#line 119
  if (rtype == 45UL) {
#line 119
    goto case_45;
  }
#line 120
  if (rtype == 46UL) {
#line 120
    goto case_46;
  }
#line 121
  if (rtype == 47UL) {
#line 121
    goto case_47;
  }
#line 122
  if (rtype == 48UL) {
#line 122
    goto case_48;
  }
#line 123
  if (rtype == 49UL) {
#line 123
    goto case_49;
  }
#line 124
  if (rtype == 50UL) {
#line 124
    goto case_50;
  }
#line 125
  if (rtype == 51UL) {
#line 125
    goto case_51;
  }
#line 126
  if (rtype == 52UL) {
#line 126
    goto case_52;
  }
#line 127
  if (rtype == 53UL) {
#line 127
    goto case_53;
  }
#line 128
  if (rtype == 54UL) {
#line 128
    goto case_54;
  }
#line 129
  if (rtype == 55UL) {
#line 129
    goto case_55;
  }
#line 131
  if (rtype == 56UL) {
#line 131
    goto case_56;
  }
#line 132
  if (rtype == 57UL) {
#line 132
    goto case_57;
  }
#line 133
  if (rtype == 58UL) {
#line 133
    goto case_58;
  }
#line 134
  if (rtype == 59UL) {
#line 134
    goto case_59;
  }
#line 135
  if (rtype == 60UL) {
#line 135
    goto case_60;
  }
#line 136
  if (rtype == 61UL) {
#line 136
    goto case_61;
  }
#line 137
  if (rtype == 62UL) {
#line 137
    goto case_62;
  }
#line 138
  if (rtype == 63UL) {
#line 138
    goto case_63;
  }
#line 139
  if (rtype == 64UL) {
#line 139
    goto case_64;
  }
#line 140
  if (rtype == 65UL) {
#line 140
    goto case_65;
  }
#line 141
  if (rtype == 66UL) {
#line 141
    goto case_66;
  }
#line 142
  if (rtype == 67UL) {
#line 142
    goto case_67;
  }
#line 143
  if (rtype == 68UL) {
#line 143
    goto case_68;
  }
#line 144
  if (rtype == 69UL) {
#line 144
    goto case_69;
  }
#line 145
  if (rtype == 70UL) {
#line 145
    goto case_70;
  }
#line 146
  if (rtype == 71UL) {
#line 146
    goto case_71;
  }
#line 147
  if (rtype == 72UL) {
#line 147
    goto case_72;
  }
#line 148
  if (rtype == 73UL) {
#line 148
    goto case_73;
  }
#line 149
  if (rtype == 74UL) {
#line 149
    goto case_74;
  }
#line 150
  if (rtype == 75UL) {
#line 150
    goto case_75;
  }
#line 151
  if (rtype == 76UL) {
#line 151
    goto case_76;
  }
#line 152
  if (rtype == 77UL) {
#line 152
    goto case_77;
  }
#line 153
  if (rtype == 78UL) {
#line 153
    goto case_78;
  }
#line 154
  if (rtype == 79UL) {
#line 154
    goto case_79;
  }
#line 156
  if (rtype == 80UL) {
#line 156
    goto case_80;
  }
#line 157
  if (rtype == 81UL) {
#line 157
    goto case_81;
  }
#line 158
  if (rtype == 82UL) {
#line 158
    goto case_82;
  }
#line 159
  if (rtype == 83UL) {
#line 159
    goto case_83;
  }
#line 160
  if (rtype == 84UL) {
#line 160
    goto case_84;
  }
#line 162
  if (rtype == 85UL) {
#line 162
    goto case_85;
  }
#line 163
  if (rtype == 86UL) {
#line 163
    goto case_86;
  }
#line 164
  if (rtype == 87UL) {
#line 164
    goto case_87;
  }
#line 165
  if (rtype == 88UL) {
#line 165
    goto case_88;
  }
#line 169
  if (rtype == 248UL) {
#line 169
    goto case_248;
  }
#line 170
  if (rtype == 249UL) {
#line 170
    goto case_249;
  }
#line 171
  if (rtype == 250UL) {
#line 171
    goto case_250;
  }
#line 172
  if (rtype == 251UL) {
#line 172
    goto case_251;
  }
#line 173
  if (rtype == 252UL) {
#line 173
    goto case_252;
  }
#line 175
  goto switch_default;
  case_0: /* CIL Label */ 
#line 65
  return ("R_SPARC_NONE");
  case_1: /* CIL Label */ 
#line 66
  return ("R_SPARC_8");
  case_2: /* CIL Label */ 
#line 67
  return ("R_SPARC_16");
  case_3: /* CIL Label */ 
#line 68
  return ("R_SPARC_32");
  case_4: /* CIL Label */ 
#line 69
  return ("R_SPARC_DISP8");
  case_5: /* CIL Label */ 
#line 70
  return ("R_SPARC_DISP16");
  case_6: /* CIL Label */ 
#line 71
  return ("R_SPARC_DISP32");
  case_7: /* CIL Label */ 
#line 72
  return ("R_SPARC_WDISP30");
  case_8: /* CIL Label */ 
#line 73
  return ("R_SPARC_WDISP22");
  case_9: /* CIL Label */ 
#line 74
  return ("R_SPARC_HI22");
  case_10: /* CIL Label */ 
#line 75
  return ("R_SPARC_22");
  case_11: /* CIL Label */ 
#line 76
  return ("R_SPARC_13");
  case_12: /* CIL Label */ 
#line 77
  return ("R_SPARC_LO10");
  case_13: /* CIL Label */ 
#line 78
  return ("R_SPARC_GOT10");
  case_14: /* CIL Label */ 
#line 79
  return ("R_SPARC_GOT13");
  case_15: /* CIL Label */ 
#line 80
  return ("R_SPARC_GOT22");
  case_16: /* CIL Label */ 
#line 81
  return ("R_SPARC_PC10");
  case_17: /* CIL Label */ 
#line 82
  return ("R_SPARC_PC22");
  case_18: /* CIL Label */ 
#line 83
  return ("R_SPARC_WPLT30");
  case_19: /* CIL Label */ 
#line 84
  return ("R_SPARC_COPY");
  case_20: /* CIL Label */ 
#line 85
  return ("R_SPARC_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 86
  return ("R_SPARC_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 87
  return ("R_SPARC_RELATIVE");
  case_23: /* CIL Label */ 
#line 88
  return ("R_SPARC_UA32");
  case_24: /* CIL Label */ 
#line 95
  return ("R_SPARC_PLT32");
  case_25: /* CIL Label */ 
#line 96
  return ("R_SPARC_HIPLT22");
  case_26: /* CIL Label */ 
#line 97
  return ("R_SPARC_LOPLT10");
  case_27: /* CIL Label */ 
#line 98
  return ("R_SPARC_PCPLT32");
  case_28: /* CIL Label */ 
#line 99
  return ("R_SPARC_PCPLT22");
  case_29: /* CIL Label */ 
#line 100
  return ("R_SPARC_PCPLT10");
  case_30: /* CIL Label */ 
#line 104
  return ("R_SPARC_10");
  case_31: /* CIL Label */ 
#line 105
  return ("R_SPARC_11");
  case_32: /* CIL Label */ 
#line 106
  return ("R_SPARC_64");
  case_33: /* CIL Label */ 
#line 107
  return ("R_SPARC_OLO10");
  case_34: /* CIL Label */ 
#line 108
  return ("R_SPARC_HH22");
  case_35: /* CIL Label */ 
#line 109
  return ("R_SPARC_HM10");
  case_36: /* CIL Label */ 
#line 110
  return ("R_SPARC_LM22");
  case_37: /* CIL Label */ 
#line 111
  return ("R_SPARC_PC_HH22");
  case_38: /* CIL Label */ 
#line 112
  return ("R_SPARC_PC_HM10");
  case_39: /* CIL Label */ 
#line 113
  return ("R_SPARC_PC_LM22");
  case_40: /* CIL Label */ 
#line 114
  return ("R_SPARC_WDISP16");
  case_41: /* CIL Label */ 
#line 115
  return ("R_SPARC_WDISP19");
  case_42: /* CIL Label */ 
#line 116
  return ("R_SPARC_UNUSED_42");
  case_43: /* CIL Label */ 
#line 117
  return ("R_SPARC_7");
  case_44: /* CIL Label */ 
#line 118
  return ("R_SPARC_5");
  case_45: /* CIL Label */ 
#line 119
  return ("R_SPARC_6");
  case_46: /* CIL Label */ 
#line 120
  return ("R_SPARC_DISP64");
  case_47: /* CIL Label */ 
#line 121
  return ("R_SPARC_PLT64");
  case_48: /* CIL Label */ 
#line 122
  return ("R_SPARC_HIX22");
  case_49: /* CIL Label */ 
#line 123
  return ("R_SPARC_LOX10");
  case_50: /* CIL Label */ 
#line 124
  return ("R_SPARC_H44");
  case_51: /* CIL Label */ 
#line 125
  return ("R_SPARC_M44");
  case_52: /* CIL Label */ 
#line 126
  return ("R_SPARC_L44");
  case_53: /* CIL Label */ 
#line 127
  return ("R_SPARC_REGISTER");
  case_54: /* CIL Label */ 
#line 128
  return ("R_SPARC_UA64");
  case_55: /* CIL Label */ 
#line 129
  return ("R_SPARC_UA16");
  case_56: /* CIL Label */ 
#line 131
  return ("R_SPARC_TLS_GD_HI22");
  case_57: /* CIL Label */ 
#line 132
  return ("R_SPARC_TLS_GD_LO10");
  case_58: /* CIL Label */ 
#line 133
  return ("R_SPARC_TLS_GD_ADD");
  case_59: /* CIL Label */ 
#line 134
  return ("R_SPARC_TLS_GD_CALL");
  case_60: /* CIL Label */ 
#line 135
  return ("R_SPARC_TLS_LDM_HI22");
  case_61: /* CIL Label */ 
#line 136
  return ("R_SPARC_TLS_LDM_LO10");
  case_62: /* CIL Label */ 
#line 137
  return ("R_SPARC_TLS_LDM_ADD");
  case_63: /* CIL Label */ 
#line 138
  return ("R_SPARC_TLS_LDM_CALL");
  case_64: /* CIL Label */ 
#line 139
  return ("R_SPARC_TLS_LDO_HIX22");
  case_65: /* CIL Label */ 
#line 140
  return ("R_SPARC_TLS_LDO_LOX10");
  case_66: /* CIL Label */ 
#line 141
  return ("R_SPARC_TLS_LDO_ADD");
  case_67: /* CIL Label */ 
#line 142
  return ("R_SPARC_TLS_IE_HI22");
  case_68: /* CIL Label */ 
#line 143
  return ("R_SPARC_TLS_IE_LO10");
  case_69: /* CIL Label */ 
#line 144
  return ("R_SPARC_TLS_IE_LD");
  case_70: /* CIL Label */ 
#line 145
  return ("R_SPARC_TLS_IE_LDX");
  case_71: /* CIL Label */ 
#line 146
  return ("R_SPARC_TLS_IE_ADD");
  case_72: /* CIL Label */ 
#line 147
  return ("R_SPARC_TLS_LE_HIX22");
  case_73: /* CIL Label */ 
#line 148
  return ("R_SPARC_TLS_LE_LOX10");
  case_74: /* CIL Label */ 
#line 149
  return ("R_SPARC_TLS_DTPMOD32");
  case_75: /* CIL Label */ 
#line 150
  return ("R_SPARC_TLS_DTPMOD64");
  case_76: /* CIL Label */ 
#line 151
  return ("R_SPARC_TLS_DTPOFF32");
  case_77: /* CIL Label */ 
#line 152
  return ("R_SPARC_TLS_DTPOFF64");
  case_78: /* CIL Label */ 
#line 153
  return ("R_SPARC_TLS_TPOFF32");
  case_79: /* CIL Label */ 
#line 154
  return ("R_SPARC_TLS_TPOFF64");
  case_80: /* CIL Label */ 
#line 156
  return ("R_SPARC_GOTDATA_HIX22");
  case_81: /* CIL Label */ 
#line 157
  return ("R_SPARC_GOTDATA_LOX10");
  case_82: /* CIL Label */ 
#line 158
  return ("R_SPARC_GOTDATA_OP_HIX22");
  case_83: /* CIL Label */ 
#line 159
  return ("R_SPARC_GOTDATA_OP_LOX10");
  case_84: /* CIL Label */ 
#line 160
  return ("R_SPARC_GOTDATA_OP");
  case_85: /* CIL Label */ 
#line 162
  return ("R_SPARC_H34");
  case_86: /* CIL Label */ 
#line 163
  return ("R_SPARC_SIZE32");
  case_87: /* CIL Label */ 
#line 164
  return ("R_SPARC_SIZE64");
  case_88: /* CIL Label */ 
#line 165
  return ("R_SPARC_WDISP10");
  case_248: /* CIL Label */ 
#line 169
  return ("R_SPARC_JMP_IREL");
  case_249: /* CIL Label */ 
#line 170
  return ("R_SPARC_IRELATIVE");
  case_250: /* CIL Label */ 
#line 171
  return ("R_SPARC_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 172
  return ("R_SPARC_GNU_VTENTRY");
  case_252: /* CIL Label */ 
#line 173
  return ("R_SPARC_REV32");
  switch_default: /* CIL Label */ 
#line 175
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/spu.h"
static char const   *elf_spu_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/spu.h"
static char const   *elf_spu_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 38
  if (rtype == 10UL) {
#line 38
    goto case_10;
  }
#line 39
  if (rtype == 11UL) {
#line 39
    goto case_11;
  }
#line 40
  if (rtype == 12UL) {
#line 40
    goto case_12;
  }
#line 41
  if (rtype == 13UL) {
#line 41
    goto case_13;
  }
#line 42
  if (rtype == 14UL) {
#line 42
    goto case_14;
  }
#line 43
  if (rtype == 15UL) {
#line 43
    goto case_15;
  }
#line 44
  if (rtype == 16UL) {
#line 44
    goto case_16;
  }
#line 45
  if (rtype == 17UL) {
#line 45
    goto case_17;
  }
#line 46
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_SPU_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_SPU_ADDR10");
  case_2: /* CIL Label */ 
#line 30
  return ("R_SPU_ADDR16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_SPU_ADDR16_HI");
  case_4: /* CIL Label */ 
#line 32
  return ("R_SPU_ADDR16_LO");
  case_5: /* CIL Label */ 
#line 33
  return ("R_SPU_ADDR18");
  case_6: /* CIL Label */ 
#line 34
  return ("R_SPU_ADDR32");
  case_7: /* CIL Label */ 
#line 35
  return ("R_SPU_REL16");
  case_8: /* CIL Label */ 
#line 36
  return ("R_SPU_ADDR7");
  case_9: /* CIL Label */ 
#line 37
  return ("R_SPU_REL9");
  case_10: /* CIL Label */ 
#line 38
  return ("R_SPU_REL9I");
  case_11: /* CIL Label */ 
#line 39
  return ("R_SPU_ADDR10I");
  case_12: /* CIL Label */ 
#line 40
  return ("R_SPU_ADDR16I");
  case_13: /* CIL Label */ 
#line 41
  return ("R_SPU_REL32");
  case_14: /* CIL Label */ 
#line 42
  return ("R_SPU_ADDR16X");
  case_15: /* CIL Label */ 
#line 43
  return ("R_SPU_PPU32");
  case_16: /* CIL Label */ 
#line 44
  return ("R_SPU_PPU64");
  case_17: /* CIL Label */ 
#line 45
  return ("R_SPU_ADD_PIC");
  switch_default: /* CIL Label */ 
#line 46
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 28 "./../include/elf/tic6x.h"
static char const   *elf_tic6x_reloc_type(unsigned long rtype ) ;
#line 28 "./../include/elf/tic6x.h"
static char const   *elf_tic6x_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 29
  if (rtype == 0UL) {
#line 29
    goto case_0;
  }
#line 30
  if (rtype == 1UL) {
#line 30
    goto case_1;
  }
#line 31
  if (rtype == 2UL) {
#line 31
    goto case_2;
  }
#line 32
  if (rtype == 3UL) {
#line 32
    goto case_3;
  }
#line 33
  if (rtype == 4UL) {
#line 33
    goto case_4;
  }
#line 34
  if (rtype == 5UL) {
#line 34
    goto case_5;
  }
#line 35
  if (rtype == 6UL) {
#line 35
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  if (rtype == 13UL) {
#line 42
    goto case_13;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 47
  if (rtype == 18UL) {
#line 47
    goto case_18;
  }
#line 48
  if (rtype == 19UL) {
#line 48
    goto case_19;
  }
#line 49
  if (rtype == 20UL) {
#line 49
    goto case_20;
  }
#line 50
  if (rtype == 21UL) {
#line 50
    goto case_21;
  }
#line 51
  if (rtype == 22UL) {
#line 51
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 54
  if (rtype == 25UL) {
#line 54
    goto case_25;
  }
#line 55
  if (rtype == 26UL) {
#line 55
    goto case_26;
  }
#line 56
  if (rtype == 27UL) {
#line 56
    goto case_27;
  }
#line 57
  if (rtype == 28UL) {
#line 57
    goto case_28;
  }
#line 58
  if (rtype == 29UL) {
#line 58
    goto case_29;
  }
#line 59
  if (rtype == 30UL) {
#line 59
    goto case_30;
  }
#line 60
  if (rtype == 253UL) {
#line 60
    goto case_253;
  }
#line 61
  if (rtype == 254UL) {
#line 61
    goto case_254;
  }
#line 62
  if (rtype == 255UL) {
#line 62
    goto case_255;
  }
#line 63
  goto switch_default;
  case_0: /* CIL Label */ 
#line 29
  return ("R_C6000_NONE");
  case_1: /* CIL Label */ 
#line 30
  return ("R_C6000_ABS32");
  case_2: /* CIL Label */ 
#line 31
  return ("R_C6000_ABS16");
  case_3: /* CIL Label */ 
#line 32
  return ("R_C6000_ABS8");
  case_4: /* CIL Label */ 
#line 33
  return ("R_C6000_PCR_S21");
  case_5: /* CIL Label */ 
#line 34
  return ("R_C6000_PCR_S12");
  case_6: /* CIL Label */ 
#line 35
  return ("R_C6000_PCR_S10");
  case_7: /* CIL Label */ 
#line 36
  return ("R_C6000_PCR_S7");
  case_8: /* CIL Label */ 
#line 37
  return ("R_C6000_ABS_S16");
  case_9: /* CIL Label */ 
#line 38
  return ("R_C6000_ABS_L16");
  case_10: /* CIL Label */ 
#line 39
  return ("R_C6000_ABS_H16");
  case_11: /* CIL Label */ 
#line 40
  return ("R_C6000_SBR_U15_B");
  case_12: /* CIL Label */ 
#line 41
  return ("R_C6000_SBR_U15_H");
  case_13: /* CIL Label */ 
#line 42
  return ("R_C6000_SBR_U15_W");
  case_14: /* CIL Label */ 
#line 43
  return ("R_C6000_SBR_S16");
  case_15: /* CIL Label */ 
#line 44
  return ("R_C6000_SBR_L16_B");
  case_16: /* CIL Label */ 
#line 45
  return ("R_C6000_SBR_L16_H");
  case_17: /* CIL Label */ 
#line 46
  return ("R_C6000_SBR_L16_W");
  case_18: /* CIL Label */ 
#line 47
  return ("R_C6000_SBR_H16_B");
  case_19: /* CIL Label */ 
#line 48
  return ("R_C6000_SBR_H16_H");
  case_20: /* CIL Label */ 
#line 49
  return ("R_C6000_SBR_H16_W");
  case_21: /* CIL Label */ 
#line 50
  return ("R_C6000_SBR_GOT_U15_W");
  case_22: /* CIL Label */ 
#line 51
  return ("R_C6000_SBR_GOT_L16_W");
  case_23: /* CIL Label */ 
#line 52
  return ("R_C6000_SBR_GOT_H16_W");
  case_24: /* CIL Label */ 
#line 53
  return ("R_C6000_DSBT_INDEX");
  case_25: /* CIL Label */ 
#line 54
  return ("R_C6000_PREL31");
  case_26: /* CIL Label */ 
#line 55
  return ("R_C6000_COPY");
  case_27: /* CIL Label */ 
#line 56
  return ("R_C6000_JUMP_SLOT");
  case_28: /* CIL Label */ 
#line 57
  return ("R_C6000_EHTYPE");
  case_29: /* CIL Label */ 
#line 58
  return ("R_C6000_PCR_H16");
  case_30: /* CIL Label */ 
#line 59
  return ("R_C6000_PCR_L16");
  case_253: /* CIL Label */ 
#line 60
  return ("R_C6000_ALIGN");
  case_254: /* CIL Label */ 
#line 61
  return ("R_C6000_FPHEAD");
  case_255: /* CIL Label */ 
#line 62
  return ("R_C6000_NOCMP");
  switch_default: /* CIL Label */ 
#line 63
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/tilegx.h"
static char const   *elf_tilegx_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/tilegx.h"
static char const   *elf_tilegx_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 37
  if (rtype == 7UL) {
#line 37
    goto case_7;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 42
  if (rtype == 9UL) {
#line 42
    goto case_9;
  }
#line 43
  if (rtype == 10UL) {
#line 43
    goto case_10;
  }
#line 44
  if (rtype == 11UL) {
#line 44
    goto case_11;
  }
#line 45
  if (rtype == 12UL) {
#line 45
    goto case_12;
  }
#line 46
  if (rtype == 13UL) {
#line 46
    goto case_13;
  }
#line 47
  if (rtype == 14UL) {
#line 47
    goto case_14;
  }
#line 48
  if (rtype == 15UL) {
#line 48
    goto case_15;
  }
#line 50
  if (rtype == 16UL) {
#line 50
    goto case_16;
  }
#line 51
  if (rtype == 17UL) {
#line 51
    goto case_17;
  }
#line 52
  if (rtype == 18UL) {
#line 52
    goto case_18;
  }
#line 53
  if (rtype == 19UL) {
#line 53
    goto case_19;
  }
#line 56
  if (rtype == 20UL) {
#line 56
    goto case_20;
  }
#line 57
  if (rtype == 21UL) {
#line 57
    goto case_21;
  }
#line 58
  if (rtype == 22UL) {
#line 58
    goto case_22;
  }
#line 61
  if (rtype == 23UL) {
#line 61
    goto case_23;
  }
#line 62
  if (rtype == 24UL) {
#line 62
    goto case_24;
  }
#line 63
  if (rtype == 25UL) {
#line 63
    goto case_25;
  }
#line 64
  if (rtype == 26UL) {
#line 64
    goto case_26;
  }
#line 65
  if (rtype == 27UL) {
#line 65
    goto case_27;
  }
#line 66
  if (rtype == 28UL) {
#line 66
    goto case_28;
  }
#line 67
  if (rtype == 29UL) {
#line 67
    goto case_29;
  }
#line 68
  if (rtype == 30UL) {
#line 68
    goto case_30;
  }
#line 69
  if (rtype == 31UL) {
#line 69
    goto case_31;
  }
#line 70
  if (rtype == 32UL) {
#line 70
    goto case_32;
  }
#line 71
  if (rtype == 33UL) {
#line 71
    goto case_33;
  }
#line 72
  if (rtype == 34UL) {
#line 72
    goto case_34;
  }
#line 73
  if (rtype == 35UL) {
#line 73
    goto case_35;
  }
#line 75
  if (rtype == 36UL) {
#line 75
    goto case_36;
  }
#line 76
  if (rtype == 37UL) {
#line 76
    goto case_37;
  }
#line 77
  if (rtype == 38UL) {
#line 77
    goto case_38;
  }
#line 78
  if (rtype == 39UL) {
#line 78
    goto case_39;
  }
#line 79
  if (rtype == 40UL) {
#line 79
    goto case_40;
  }
#line 80
  if (rtype == 41UL) {
#line 80
    goto case_41;
  }
#line 81
  if (rtype == 42UL) {
#line 81
    goto case_42;
  }
#line 82
  if (rtype == 43UL) {
#line 82
    goto case_43;
  }
#line 83
  if (rtype == 44UL) {
#line 83
    goto case_44;
  }
#line 84
  if (rtype == 45UL) {
#line 84
    goto case_45;
  }
#line 85
  if (rtype == 46UL) {
#line 85
    goto case_46;
  }
#line 86
  if (rtype == 47UL) {
#line 86
    goto case_47;
  }
#line 87
  if (rtype == 48UL) {
#line 87
    goto case_48;
  }
#line 88
  if (rtype == 49UL) {
#line 88
    goto case_49;
  }
#line 90
  if (rtype == 50UL) {
#line 90
    goto case_50;
  }
#line 91
  if (rtype == 51UL) {
#line 91
    goto case_51;
  }
#line 92
  if (rtype == 52UL) {
#line 92
    goto case_52;
  }
#line 93
  if (rtype == 53UL) {
#line 93
    goto case_53;
  }
#line 94
  if (rtype == 54UL) {
#line 94
    goto case_54;
  }
#line 95
  if (rtype == 55UL) {
#line 95
    goto case_55;
  }
#line 96
  if (rtype == 56UL) {
#line 96
    goto case_56;
  }
#line 97
  if (rtype == 57UL) {
#line 97
    goto case_57;
  }
#line 98
  if (rtype == 58UL) {
#line 98
    goto case_58;
  }
#line 99
  if (rtype == 59UL) {
#line 99
    goto case_59;
  }
#line 100
  if (rtype == 60UL) {
#line 100
    goto case_60;
  }
#line 101
  if (rtype == 61UL) {
#line 101
    goto case_61;
  }
#line 102
  if (rtype == 62UL) {
#line 102
    goto case_62;
  }
#line 103
  if (rtype == 63UL) {
#line 103
    goto case_63;
  }
#line 105
  if (rtype == 64UL) {
#line 105
    goto case_64;
  }
#line 106
  if (rtype == 65UL) {
#line 106
    goto case_65;
  }
#line 109
  if (rtype == 72UL) {
#line 109
    goto case_72;
  }
#line 110
  if (rtype == 73UL) {
#line 110
    goto case_73;
  }
#line 111
  if (rtype == 74UL) {
#line 111
    goto case_74;
  }
#line 112
  if (rtype == 75UL) {
#line 112
    goto case_75;
  }
#line 115
  if (rtype == 78UL) {
#line 115
    goto case_78;
  }
#line 116
  if (rtype == 79UL) {
#line 116
    goto case_79;
  }
#line 117
  if (rtype == 80UL) {
#line 117
    goto case_80;
  }
#line 118
  if (rtype == 81UL) {
#line 118
    goto case_81;
  }
#line 119
  if (rtype == 82UL) {
#line 119
    goto case_82;
  }
#line 120
  if (rtype == 83UL) {
#line 120
    goto case_83;
  }
#line 121
  if (rtype == 84UL) {
#line 121
    goto case_84;
  }
#line 122
  if (rtype == 85UL) {
#line 122
    goto case_85;
  }
#line 123
  if (rtype == 86UL) {
#line 123
    goto case_86;
  }
#line 124
  if (rtype == 87UL) {
#line 124
    goto case_87;
  }
#line 125
  if (rtype == 88UL) {
#line 125
    goto case_88;
  }
#line 126
  if (rtype == 89UL) {
#line 126
    goto case_89;
  }
#line 129
  if (rtype == 92UL) {
#line 129
    goto case_92;
  }
#line 130
  if (rtype == 93UL) {
#line 130
    goto case_93;
  }
#line 133
  if (rtype == 100UL) {
#line 133
    goto case_100;
  }
#line 134
  if (rtype == 101UL) {
#line 134
    goto case_101;
  }
#line 135
  if (rtype == 102UL) {
#line 135
    goto case_102;
  }
#line 136
  if (rtype == 103UL) {
#line 136
    goto case_103;
  }
#line 139
  if (rtype == 106UL) {
#line 139
    goto case_106;
  }
#line 140
  if (rtype == 107UL) {
#line 140
    goto case_107;
  }
#line 141
  if (rtype == 108UL) {
#line 141
    goto case_108;
  }
#line 142
  if (rtype == 109UL) {
#line 142
    goto case_109;
  }
#line 143
  if (rtype == 110UL) {
#line 143
    goto case_110;
  }
#line 144
  if (rtype == 111UL) {
#line 144
    goto case_111;
  }
#line 146
  if (rtype == 112UL) {
#line 146
    goto case_112;
  }
#line 147
  if (rtype == 113UL) {
#line 147
    goto case_113;
  }
#line 148
  if (rtype == 114UL) {
#line 148
    goto case_114;
  }
#line 149
  if (rtype == 115UL) {
#line 149
    goto case_115;
  }
#line 150
  if (rtype == 116UL) {
#line 150
    goto case_116;
  }
#line 151
  if (rtype == 117UL) {
#line 151
    goto case_117;
  }
#line 152
  if (rtype == 118UL) {
#line 152
    goto case_118;
  }
#line 153
  if (rtype == 119UL) {
#line 153
    goto case_119;
  }
#line 154
  if (rtype == 120UL) {
#line 154
    goto case_120;
  }
#line 155
  if (rtype == 121UL) {
#line 155
    goto case_121;
  }
#line 158
  if (rtype == 128UL) {
#line 158
    goto case_128;
  }
#line 159
  if (rtype == 129UL) {
#line 159
    goto case_129;
  }
#line 160
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_TILEGX_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_TILEGX_64");
  case_2: /* CIL Label */ 
#line 32
  return ("R_TILEGX_32");
  case_3: /* CIL Label */ 
#line 33
  return ("R_TILEGX_16");
  case_4: /* CIL Label */ 
#line 34
  return ("R_TILEGX_8");
  case_5: /* CIL Label */ 
#line 35
  return ("R_TILEGX_64_PCREL");
  case_6: /* CIL Label */ 
#line 36
  return ("R_TILEGX_32_PCREL");
  case_7: /* CIL Label */ 
#line 37
  return ("R_TILEGX_16_PCREL");
  case_8: /* CIL Label */ 
#line 38
  return ("R_TILEGX_8_PCREL");
  case_9: /* CIL Label */ 
#line 42
  return ("R_TILEGX_HW0");
  case_10: /* CIL Label */ 
#line 43
  return ("R_TILEGX_HW1");
  case_11: /* CIL Label */ 
#line 44
  return ("R_TILEGX_HW2");
  case_12: /* CIL Label */ 
#line 45
  return ("R_TILEGX_HW3");
  case_13: /* CIL Label */ 
#line 46
  return ("R_TILEGX_HW0_LAST");
  case_14: /* CIL Label */ 
#line 47
  return ("R_TILEGX_HW1_LAST");
  case_15: /* CIL Label */ 
#line 48
  return ("R_TILEGX_HW2_LAST");
  case_16: /* CIL Label */ 
#line 50
  return ("R_TILEGX_COPY");
  case_17: /* CIL Label */ 
#line 51
  return ("R_TILEGX_GLOB_DAT");
  case_18: /* CIL Label */ 
#line 52
  return ("R_TILEGX_JMP_SLOT");
  case_19: /* CIL Label */ 
#line 53
  return ("R_TILEGX_RELATIVE");
  case_20: /* CIL Label */ 
#line 56
  return ("R_TILEGX_BROFF_X1");
  case_21: /* CIL Label */ 
#line 57
  return ("R_TILEGX_JUMPOFF_X1");
  case_22: /* CIL Label */ 
#line 58
  return ("R_TILEGX_JUMPOFF_X1_PLT");
  case_23: /* CIL Label */ 
#line 61
  return ("R_TILEGX_IMM8_X0");
  case_24: /* CIL Label */ 
#line 62
  return ("R_TILEGX_IMM8_Y0");
  case_25: /* CIL Label */ 
#line 63
  return ("R_TILEGX_IMM8_X1");
  case_26: /* CIL Label */ 
#line 64
  return ("R_TILEGX_IMM8_Y1");
  case_27: /* CIL Label */ 
#line 65
  return ("R_TILEGX_DEST_IMM8_X1");
  case_28: /* CIL Label */ 
#line 66
  return ("R_TILEGX_MT_IMM14_X1");
  case_29: /* CIL Label */ 
#line 67
  return ("R_TILEGX_MF_IMM14_X1");
  case_30: /* CIL Label */ 
#line 68
  return ("R_TILEGX_MMSTART_X0");
  case_31: /* CIL Label */ 
#line 69
  return ("R_TILEGX_MMEND_X0");
  case_32: /* CIL Label */ 
#line 70
  return ("R_TILEGX_SHAMT_X0");
  case_33: /* CIL Label */ 
#line 71
  return ("R_TILEGX_SHAMT_X1");
  case_34: /* CIL Label */ 
#line 72
  return ("R_TILEGX_SHAMT_Y0");
  case_35: /* CIL Label */ 
#line 73
  return ("R_TILEGX_SHAMT_Y1");
  case_36: /* CIL Label */ 
#line 75
  return ("R_TILEGX_IMM16_X0_HW0");
  case_37: /* CIL Label */ 
#line 76
  return ("R_TILEGX_IMM16_X1_HW0");
  case_38: /* CIL Label */ 
#line 77
  return ("R_TILEGX_IMM16_X0_HW1");
  case_39: /* CIL Label */ 
#line 78
  return ("R_TILEGX_IMM16_X1_HW1");
  case_40: /* CIL Label */ 
#line 79
  return ("R_TILEGX_IMM16_X0_HW2");
  case_41: /* CIL Label */ 
#line 80
  return ("R_TILEGX_IMM16_X1_HW2");
  case_42: /* CIL Label */ 
#line 81
  return ("R_TILEGX_IMM16_X0_HW3");
  case_43: /* CIL Label */ 
#line 82
  return ("R_TILEGX_IMM16_X1_HW3");
  case_44: /* CIL Label */ 
#line 83
  return ("R_TILEGX_IMM16_X0_HW0_LAST");
  case_45: /* CIL Label */ 
#line 84
  return ("R_TILEGX_IMM16_X1_HW0_LAST");
  case_46: /* CIL Label */ 
#line 85
  return ("R_TILEGX_IMM16_X0_HW1_LAST");
  case_47: /* CIL Label */ 
#line 86
  return ("R_TILEGX_IMM16_X1_HW1_LAST");
  case_48: /* CIL Label */ 
#line 87
  return ("R_TILEGX_IMM16_X0_HW2_LAST");
  case_49: /* CIL Label */ 
#line 88
  return ("R_TILEGX_IMM16_X1_HW2_LAST");
  case_50: /* CIL Label */ 
#line 90
  return ("R_TILEGX_IMM16_X0_HW0_PCREL");
  case_51: /* CIL Label */ 
#line 91
  return ("R_TILEGX_IMM16_X1_HW0_PCREL");
  case_52: /* CIL Label */ 
#line 92
  return ("R_TILEGX_IMM16_X0_HW1_PCREL");
  case_53: /* CIL Label */ 
#line 93
  return ("R_TILEGX_IMM16_X1_HW1_PCREL");
  case_54: /* CIL Label */ 
#line 94
  return ("R_TILEGX_IMM16_X0_HW2_PCREL");
  case_55: /* CIL Label */ 
#line 95
  return ("R_TILEGX_IMM16_X1_HW2_PCREL");
  case_56: /* CIL Label */ 
#line 96
  return ("R_TILEGX_IMM16_X0_HW3_PCREL");
  case_57: /* CIL Label */ 
#line 97
  return ("R_TILEGX_IMM16_X1_HW3_PCREL");
  case_58: /* CIL Label */ 
#line 98
  return ("R_TILEGX_IMM16_X0_HW0_LAST_PCREL");
  case_59: /* CIL Label */ 
#line 99
  return ("R_TILEGX_IMM16_X1_HW0_LAST_PCREL");
  case_60: /* CIL Label */ 
#line 100
  return ("R_TILEGX_IMM16_X0_HW1_LAST_PCREL");
  case_61: /* CIL Label */ 
#line 101
  return ("R_TILEGX_IMM16_X1_HW1_LAST_PCREL");
  case_62: /* CIL Label */ 
#line 102
  return ("R_TILEGX_IMM16_X0_HW2_LAST_PCREL");
  case_63: /* CIL Label */ 
#line 103
  return ("R_TILEGX_IMM16_X1_HW2_LAST_PCREL");
  case_64: /* CIL Label */ 
#line 105
  return ("R_TILEGX_IMM16_X0_HW0_GOT");
  case_65: /* CIL Label */ 
#line 106
  return ("R_TILEGX_IMM16_X1_HW0_GOT");
  case_72: /* CIL Label */ 
#line 109
  return ("R_TILEGX_IMM16_X0_HW0_LAST_GOT");
  case_73: /* CIL Label */ 
#line 110
  return ("R_TILEGX_IMM16_X1_HW0_LAST_GOT");
  case_74: /* CIL Label */ 
#line 111
  return ("R_TILEGX_IMM16_X0_HW1_LAST_GOT");
  case_75: /* CIL Label */ 
#line 112
  return ("R_TILEGX_IMM16_X1_HW1_LAST_GOT");
  case_78: /* CIL Label */ 
#line 115
  return ("R_TILEGX_IMM16_X0_HW0_TLS_GD");
  case_79: /* CIL Label */ 
#line 116
  return ("R_TILEGX_IMM16_X1_HW0_TLS_GD");
  case_80: /* CIL Label */ 
#line 117
  return ("R_TILEGX_IMM16_X0_HW0_TLS_LE");
  case_81: /* CIL Label */ 
#line 118
  return ("R_TILEGX_IMM16_X1_HW0_TLS_LE");
  case_82: /* CIL Label */ 
#line 119
  return ("R_TILEGX_IMM16_X0_HW0_LAST_TLS_LE");
  case_83: /* CIL Label */ 
#line 120
  return ("R_TILEGX_IMM16_X1_HW0_LAST_TLS_LE");
  case_84: /* CIL Label */ 
#line 121
  return ("R_TILEGX_IMM16_X0_HW1_LAST_TLS_LE");
  case_85: /* CIL Label */ 
#line 122
  return ("R_TILEGX_IMM16_X1_HW1_LAST_TLS_LE");
  case_86: /* CIL Label */ 
#line 123
  return ("R_TILEGX_IMM16_X0_HW0_LAST_TLS_GD");
  case_87: /* CIL Label */ 
#line 124
  return ("R_TILEGX_IMM16_X1_HW0_LAST_TLS_GD");
  case_88: /* CIL Label */ 
#line 125
  return ("R_TILEGX_IMM16_X0_HW1_LAST_TLS_GD");
  case_89: /* CIL Label */ 
#line 126
  return ("R_TILEGX_IMM16_X1_HW1_LAST_TLS_GD");
  case_92: /* CIL Label */ 
#line 129
  return ("R_TILEGX_IMM16_X0_HW0_TLS_IE");
  case_93: /* CIL Label */ 
#line 130
  return ("R_TILEGX_IMM16_X1_HW0_TLS_IE");
  case_100: /* CIL Label */ 
#line 133
  return ("R_TILEGX_IMM16_X0_HW0_LAST_TLS_IE");
  case_101: /* CIL Label */ 
#line 134
  return ("R_TILEGX_IMM16_X1_HW0_LAST_TLS_IE");
  case_102: /* CIL Label */ 
#line 135
  return ("R_TILEGX_IMM16_X0_HW1_LAST_TLS_IE");
  case_103: /* CIL Label */ 
#line 136
  return ("R_TILEGX_IMM16_X1_HW1_LAST_TLS_IE");
  case_106: /* CIL Label */ 
#line 139
  return ("R_TILEGX_TLS_DTPMOD64");
  case_107: /* CIL Label */ 
#line 140
  return ("R_TILEGX_TLS_DTPOFF64");
  case_108: /* CIL Label */ 
#line 141
  return ("R_TILEGX_TLS_TPOFF64");
  case_109: /* CIL Label */ 
#line 142
  return ("R_TILEGX_TLS_DTPMOD32");
  case_110: /* CIL Label */ 
#line 143
  return ("R_TILEGX_TLS_DTPOFF32");
  case_111: /* CIL Label */ 
#line 144
  return ("R_TILEGX_TLS_TPOFF32");
  case_112: /* CIL Label */ 
#line 146
  return ("R_TILEGX_TLS_GD_CALL");
  case_113: /* CIL Label */ 
#line 147
  return ("R_TILEGX_IMM8_X0_TLS_GD_ADD");
  case_114: /* CIL Label */ 
#line 148
  return ("R_TILEGX_IMM8_X1_TLS_GD_ADD");
  case_115: /* CIL Label */ 
#line 149
  return ("R_TILEGX_IMM8_Y0_TLS_GD_ADD");
  case_116: /* CIL Label */ 
#line 150
  return ("R_TILEGX_IMM8_Y1_TLS_GD_ADD");
  case_117: /* CIL Label */ 
#line 151
  return ("R_TILEGX_TLS_IE_LOAD");
  case_118: /* CIL Label */ 
#line 152
  return ("R_TILEGX_IMM8_X0_TLS_ADD");
  case_119: /* CIL Label */ 
#line 153
  return ("R_TILEGX_IMM8_X1_TLS_ADD");
  case_120: /* CIL Label */ 
#line 154
  return ("R_TILEGX_IMM8_Y0_TLS_ADD");
  case_121: /* CIL Label */ 
#line 155
  return ("R_TILEGX_IMM8_Y1_TLS_ADD");
  case_128: /* CIL Label */ 
#line 158
  return ("R_TILEGX_GNU_VTINHERIT");
  case_129: /* CIL Label */ 
#line 159
  return ("R_TILEGX_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 160
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/tilepro.h"
static char const   *elf_tilepro_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/tilepro.h"
static char const   *elf_tilepro_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 31
  if (rtype == 1UL) {
#line 31
    goto case_1;
  }
#line 32
  if (rtype == 2UL) {
#line 32
    goto case_2;
  }
#line 33
  if (rtype == 3UL) {
#line 33
    goto case_3;
  }
#line 34
  if (rtype == 4UL) {
#line 34
    goto case_4;
  }
#line 35
  if (rtype == 5UL) {
#line 35
    goto case_5;
  }
#line 36
  if (rtype == 6UL) {
#line 36
    goto case_6;
  }
#line 38
  if (rtype == 7UL) {
#line 38
    goto case_7;
  }
#line 39
  if (rtype == 8UL) {
#line 39
    goto case_8;
  }
#line 40
  if (rtype == 9UL) {
#line 40
    goto case_9;
  }
#line 42
  if (rtype == 10UL) {
#line 42
    goto case_10;
  }
#line 43
  if (rtype == 11UL) {
#line 43
    goto case_11;
  }
#line 44
  if (rtype == 12UL) {
#line 44
    goto case_12;
  }
#line 45
  if (rtype == 13UL) {
#line 45
    goto case_13;
  }
#line 48
  if (rtype == 14UL) {
#line 48
    goto case_14;
  }
#line 49
  if (rtype == 15UL) {
#line 49
    goto case_15;
  }
#line 50
  if (rtype == 16UL) {
#line 50
    goto case_16;
  }
#line 53
  if (rtype == 17UL) {
#line 53
    goto case_17;
  }
#line 54
  if (rtype == 18UL) {
#line 54
    goto case_18;
  }
#line 55
  if (rtype == 19UL) {
#line 55
    goto case_19;
  }
#line 56
  if (rtype == 20UL) {
#line 56
    goto case_20;
  }
#line 57
  if (rtype == 21UL) {
#line 57
    goto case_21;
  }
#line 58
  if (rtype == 22UL) {
#line 58
    goto case_22;
  }
#line 60
  if (rtype == 23UL) {
#line 60
    goto case_23;
  }
#line 61
  if (rtype == 24UL) {
#line 61
    goto case_24;
  }
#line 62
  if (rtype == 25UL) {
#line 62
    goto case_25;
  }
#line 63
  if (rtype == 26UL) {
#line 63
    goto case_26;
  }
#line 64
  if (rtype == 27UL) {
#line 64
    goto case_27;
  }
#line 65
  if (rtype == 28UL) {
#line 65
    goto case_28;
  }
#line 66
  if (rtype == 29UL) {
#line 66
    goto case_29;
  }
#line 67
  if (rtype == 30UL) {
#line 67
    goto case_30;
  }
#line 69
  if (rtype == 31UL) {
#line 69
    goto case_31;
  }
#line 70
  if (rtype == 32UL) {
#line 70
    goto case_32;
  }
#line 71
  if (rtype == 33UL) {
#line 71
    goto case_33;
  }
#line 72
  if (rtype == 34UL) {
#line 72
    goto case_34;
  }
#line 73
  if (rtype == 35UL) {
#line 73
    goto case_35;
  }
#line 74
  if (rtype == 36UL) {
#line 74
    goto case_36;
  }
#line 75
  if (rtype == 37UL) {
#line 75
    goto case_37;
  }
#line 76
  if (rtype == 38UL) {
#line 76
    goto case_38;
  }
#line 78
  if (rtype == 39UL) {
#line 78
    goto case_39;
  }
#line 79
  if (rtype == 40UL) {
#line 79
    goto case_40;
  }
#line 80
  if (rtype == 41UL) {
#line 80
    goto case_41;
  }
#line 81
  if (rtype == 42UL) {
#line 81
    goto case_42;
  }
#line 82
  if (rtype == 43UL) {
#line 82
    goto case_43;
  }
#line 83
  if (rtype == 44UL) {
#line 83
    goto case_44;
  }
#line 84
  if (rtype == 45UL) {
#line 84
    goto case_45;
  }
#line 85
  if (rtype == 46UL) {
#line 85
    goto case_46;
  }
#line 87
  if (rtype == 47UL) {
#line 87
    goto case_47;
  }
#line 88
  if (rtype == 48UL) {
#line 88
    goto case_48;
  }
#line 89
  if (rtype == 49UL) {
#line 89
    goto case_49;
  }
#line 90
  if (rtype == 50UL) {
#line 90
    goto case_50;
  }
#line 92
  if (rtype == 51UL) {
#line 92
    goto case_51;
  }
#line 93
  if (rtype == 52UL) {
#line 93
    goto case_52;
  }
#line 94
  if (rtype == 53UL) {
#line 94
    goto case_53;
  }
#line 95
  if (rtype == 54UL) {
#line 95
    goto case_54;
  }
#line 97
  if (rtype == 55UL) {
#line 97
    goto case_55;
  }
#line 101
  if (rtype == 60UL) {
#line 101
    goto case_60;
  }
#line 102
  if (rtype == 61UL) {
#line 102
    goto case_61;
  }
#line 103
  if (rtype == 62UL) {
#line 103
    goto case_62;
  }
#line 104
  if (rtype == 63UL) {
#line 104
    goto case_63;
  }
#line 105
  if (rtype == 64UL) {
#line 105
    goto case_64;
  }
#line 106
  if (rtype == 65UL) {
#line 106
    goto case_65;
  }
#line 108
  if (rtype == 66UL) {
#line 108
    goto case_66;
  }
#line 109
  if (rtype == 67UL) {
#line 109
    goto case_67;
  }
#line 110
  if (rtype == 68UL) {
#line 110
    goto case_68;
  }
#line 111
  if (rtype == 69UL) {
#line 111
    goto case_69;
  }
#line 112
  if (rtype == 70UL) {
#line 112
    goto case_70;
  }
#line 113
  if (rtype == 71UL) {
#line 113
    goto case_71;
  }
#line 114
  if (rtype == 72UL) {
#line 114
    goto case_72;
  }
#line 115
  if (rtype == 73UL) {
#line 115
    goto case_73;
  }
#line 117
  if (rtype == 74UL) {
#line 117
    goto case_74;
  }
#line 118
  if (rtype == 75UL) {
#line 118
    goto case_75;
  }
#line 119
  if (rtype == 76UL) {
#line 119
    goto case_76;
  }
#line 120
  if (rtype == 77UL) {
#line 120
    goto case_77;
  }
#line 121
  if (rtype == 78UL) {
#line 121
    goto case_78;
  }
#line 122
  if (rtype == 79UL) {
#line 122
    goto case_79;
  }
#line 123
  if (rtype == 80UL) {
#line 123
    goto case_80;
  }
#line 124
  if (rtype == 81UL) {
#line 124
    goto case_81;
  }
#line 126
  if (rtype == 82UL) {
#line 126
    goto case_82;
  }
#line 127
  if (rtype == 83UL) {
#line 127
    goto case_83;
  }
#line 128
  if (rtype == 84UL) {
#line 128
    goto case_84;
  }
#line 130
  if (rtype == 85UL) {
#line 130
    goto case_85;
  }
#line 131
  if (rtype == 86UL) {
#line 131
    goto case_86;
  }
#line 132
  if (rtype == 87UL) {
#line 132
    goto case_87;
  }
#line 133
  if (rtype == 88UL) {
#line 133
    goto case_88;
  }
#line 134
  if (rtype == 89UL) {
#line 134
    goto case_89;
  }
#line 135
  if (rtype == 90UL) {
#line 135
    goto case_90;
  }
#line 136
  if (rtype == 91UL) {
#line 136
    goto case_91;
  }
#line 137
  if (rtype == 92UL) {
#line 137
    goto case_92;
  }
#line 140
  if (rtype == 128UL) {
#line 140
    goto case_128;
  }
#line 141
  if (rtype == 129UL) {
#line 141
    goto case_129;
  }
#line 142
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_TILEPRO_NONE");
  case_1: /* CIL Label */ 
#line 31
  return ("R_TILEPRO_32");
  case_2: /* CIL Label */ 
#line 32
  return ("R_TILEPRO_16");
  case_3: /* CIL Label */ 
#line 33
  return ("R_TILEPRO_8");
  case_4: /* CIL Label */ 
#line 34
  return ("R_TILEPRO_32_PCREL");
  case_5: /* CIL Label */ 
#line 35
  return ("R_TILEPRO_16_PCREL");
  case_6: /* CIL Label */ 
#line 36
  return ("R_TILEPRO_8_PCREL");
  case_7: /* CIL Label */ 
#line 38
  return ("R_TILEPRO_LO16");
  case_8: /* CIL Label */ 
#line 39
  return ("R_TILEPRO_HI16");
  case_9: /* CIL Label */ 
#line 40
  return ("R_TILEPRO_HA16");
  case_10: /* CIL Label */ 
#line 42
  return ("R_TILEPRO_COPY");
  case_11: /* CIL Label */ 
#line 43
  return ("R_TILEPRO_GLOB_DAT");
  case_12: /* CIL Label */ 
#line 44
  return ("R_TILEPRO_JMP_SLOT");
  case_13: /* CIL Label */ 
#line 45
  return ("R_TILEPRO_RELATIVE");
  case_14: /* CIL Label */ 
#line 48
  return ("R_TILEPRO_BROFF_X1");
  case_15: /* CIL Label */ 
#line 49
  return ("R_TILEPRO_JOFFLONG_X1");
  case_16: /* CIL Label */ 
#line 50
  return ("R_TILEPRO_JOFFLONG_X1_PLT");
  case_17: /* CIL Label */ 
#line 53
  return ("R_TILEPRO_IMM8_X0");
  case_18: /* CIL Label */ 
#line 54
  return ("R_TILEPRO_IMM8_Y0");
  case_19: /* CIL Label */ 
#line 55
  return ("R_TILEPRO_IMM8_X1");
  case_20: /* CIL Label */ 
#line 56
  return ("R_TILEPRO_IMM8_Y1");
  case_21: /* CIL Label */ 
#line 57
  return ("R_TILEPRO_MT_IMM15_X1");
  case_22: /* CIL Label */ 
#line 58
  return ("R_TILEPRO_MF_IMM15_X1");
  case_23: /* CIL Label */ 
#line 60
  return ("R_TILEPRO_IMM16_X0");
  case_24: /* CIL Label */ 
#line 61
  return ("R_TILEPRO_IMM16_X1");
  case_25: /* CIL Label */ 
#line 62
  return ("R_TILEPRO_IMM16_X0_LO");
  case_26: /* CIL Label */ 
#line 63
  return ("R_TILEPRO_IMM16_X1_LO");
  case_27: /* CIL Label */ 
#line 64
  return ("R_TILEPRO_IMM16_X0_HI");
  case_28: /* CIL Label */ 
#line 65
  return ("R_TILEPRO_IMM16_X1_HI");
  case_29: /* CIL Label */ 
#line 66
  return ("R_TILEPRO_IMM16_X0_HA");
  case_30: /* CIL Label */ 
#line 67
  return ("R_TILEPRO_IMM16_X1_HA");
  case_31: /* CIL Label */ 
#line 69
  return ("R_TILEPRO_IMM16_X0_PCREL");
  case_32: /* CIL Label */ 
#line 70
  return ("R_TILEPRO_IMM16_X1_PCREL");
  case_33: /* CIL Label */ 
#line 71
  return ("R_TILEPRO_IMM16_X0_LO_PCREL");
  case_34: /* CIL Label */ 
#line 72
  return ("R_TILEPRO_IMM16_X1_LO_PCREL");
  case_35: /* CIL Label */ 
#line 73
  return ("R_TILEPRO_IMM16_X0_HI_PCREL");
  case_36: /* CIL Label */ 
#line 74
  return ("R_TILEPRO_IMM16_X1_HI_PCREL");
  case_37: /* CIL Label */ 
#line 75
  return ("R_TILEPRO_IMM16_X0_HA_PCREL");
  case_38: /* CIL Label */ 
#line 76
  return ("R_TILEPRO_IMM16_X1_HA_PCREL");
  case_39: /* CIL Label */ 
#line 78
  return ("R_TILEPRO_IMM16_X0_GOT");
  case_40: /* CIL Label */ 
#line 79
  return ("R_TILEPRO_IMM16_X1_GOT");
  case_41: /* CIL Label */ 
#line 80
  return ("R_TILEPRO_IMM16_X0_GOT_LO");
  case_42: /* CIL Label */ 
#line 81
  return ("R_TILEPRO_IMM16_X1_GOT_LO");
  case_43: /* CIL Label */ 
#line 82
  return ("R_TILEPRO_IMM16_X0_GOT_HI");
  case_44: /* CIL Label */ 
#line 83
  return ("R_TILEPRO_IMM16_X1_GOT_HI");
  case_45: /* CIL Label */ 
#line 84
  return ("R_TILEPRO_IMM16_X0_GOT_HA");
  case_46: /* CIL Label */ 
#line 85
  return ("R_TILEPRO_IMM16_X1_GOT_HA");
  case_47: /* CIL Label */ 
#line 87
  return ("R_TILEPRO_MMSTART_X0");
  case_48: /* CIL Label */ 
#line 88
  return ("R_TILEPRO_MMEND_X0");
  case_49: /* CIL Label */ 
#line 89
  return ("R_TILEPRO_MMSTART_X1");
  case_50: /* CIL Label */ 
#line 90
  return ("R_TILEPRO_MMEND_X1");
  case_51: /* CIL Label */ 
#line 92
  return ("R_TILEPRO_SHAMT_X0");
  case_52: /* CIL Label */ 
#line 93
  return ("R_TILEPRO_SHAMT_X1");
  case_53: /* CIL Label */ 
#line 94
  return ("R_TILEPRO_SHAMT_Y0");
  case_54: /* CIL Label */ 
#line 95
  return ("R_TILEPRO_SHAMT_Y1");
  case_55: /* CIL Label */ 
#line 97
  return ("R_TILEPRO_DEST_IMM8_X1");
  case_60: /* CIL Label */ 
#line 101
  return ("R_TILEPRO_TLS_GD_CALL");
  case_61: /* CIL Label */ 
#line 102
  return ("R_TILEPRO_IMM8_X0_TLS_GD_ADD");
  case_62: /* CIL Label */ 
#line 103
  return ("R_TILEPRO_IMM8_X1_TLS_GD_ADD");
  case_63: /* CIL Label */ 
#line 104
  return ("R_TILEPRO_IMM8_Y0_TLS_GD_ADD");
  case_64: /* CIL Label */ 
#line 105
  return ("R_TILEPRO_IMM8_Y1_TLS_GD_ADD");
  case_65: /* CIL Label */ 
#line 106
  return ("R_TILEPRO_TLS_IE_LOAD");
  case_66: /* CIL Label */ 
#line 108
  return ("R_TILEPRO_IMM16_X0_TLS_GD");
  case_67: /* CIL Label */ 
#line 109
  return ("R_TILEPRO_IMM16_X1_TLS_GD");
  case_68: /* CIL Label */ 
#line 110
  return ("R_TILEPRO_IMM16_X0_TLS_GD_LO");
  case_69: /* CIL Label */ 
#line 111
  return ("R_TILEPRO_IMM16_X1_TLS_GD_LO");
  case_70: /* CIL Label */ 
#line 112
  return ("R_TILEPRO_IMM16_X0_TLS_GD_HI");
  case_71: /* CIL Label */ 
#line 113
  return ("R_TILEPRO_IMM16_X1_TLS_GD_HI");
  case_72: /* CIL Label */ 
#line 114
  return ("R_TILEPRO_IMM16_X0_TLS_GD_HA");
  case_73: /* CIL Label */ 
#line 115
  return ("R_TILEPRO_IMM16_X1_TLS_GD_HA");
  case_74: /* CIL Label */ 
#line 117
  return ("R_TILEPRO_IMM16_X0_TLS_IE");
  case_75: /* CIL Label */ 
#line 118
  return ("R_TILEPRO_IMM16_X1_TLS_IE");
  case_76: /* CIL Label */ 
#line 119
  return ("R_TILEPRO_IMM16_X0_TLS_IE_LO");
  case_77: /* CIL Label */ 
#line 120
  return ("R_TILEPRO_IMM16_X1_TLS_IE_LO");
  case_78: /* CIL Label */ 
#line 121
  return ("R_TILEPRO_IMM16_X0_TLS_IE_HI");
  case_79: /* CIL Label */ 
#line 122
  return ("R_TILEPRO_IMM16_X1_TLS_IE_HI");
  case_80: /* CIL Label */ 
#line 123
  return ("R_TILEPRO_IMM16_X0_TLS_IE_HA");
  case_81: /* CIL Label */ 
#line 124
  return ("R_TILEPRO_IMM16_X1_TLS_IE_HA");
  case_82: /* CIL Label */ 
#line 126
  return ("R_TILEPRO_TLS_DTPMOD32");
  case_83: /* CIL Label */ 
#line 127
  return ("R_TILEPRO_TLS_DTPOFF32");
  case_84: /* CIL Label */ 
#line 128
  return ("R_TILEPRO_TLS_TPOFF32");
  case_85: /* CIL Label */ 
#line 130
  return ("R_TILEPRO_IMM16_X0_TLS_LE");
  case_86: /* CIL Label */ 
#line 131
  return ("R_TILEPRO_IMM16_X1_TLS_LE");
  case_87: /* CIL Label */ 
#line 132
  return ("R_TILEPRO_IMM16_X0_TLS_LE_LO");
  case_88: /* CIL Label */ 
#line 133
  return ("R_TILEPRO_IMM16_X1_TLS_LE_LO");
  case_89: /* CIL Label */ 
#line 134
  return ("R_TILEPRO_IMM16_X0_TLS_LE_HI");
  case_90: /* CIL Label */ 
#line 135
  return ("R_TILEPRO_IMM16_X1_TLS_LE_HI");
  case_91: /* CIL Label */ 
#line 136
  return ("R_TILEPRO_IMM16_X0_TLS_LE_HA");
  case_92: /* CIL Label */ 
#line 137
  return ("R_TILEPRO_IMM16_X1_TLS_LE_HA");
  case_128: /* CIL Label */ 
#line 140
  return ("R_TILEPRO_GNU_VTINHERIT");
  case_129: /* CIL Label */ 
#line 141
  return ("R_TILEPRO_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 142
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 58 "./../include/elf/v850.h"
static char const   *v850_reloc_type(unsigned long rtype ) ;
#line 58 "./../include/elf/v850.h"
static char const   *v850_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 59
  if (rtype == 0UL) {
#line 59
    goto case_0;
  }
#line 60
  if (rtype == 1UL) {
#line 60
    goto case_1;
  }
#line 61
  if (rtype == 2UL) {
#line 61
    goto case_2;
  }
#line 62
  if (rtype == 3UL) {
#line 62
    goto case_3;
  }
#line 63
  if (rtype == 4UL) {
#line 63
    goto case_4;
  }
#line 64
  if (rtype == 5UL) {
#line 64
    goto case_5;
  }
#line 65
  if (rtype == 6UL) {
#line 65
    goto case_6;
  }
#line 66
  if (rtype == 7UL) {
#line 66
    goto case_7;
  }
#line 67
  if (rtype == 8UL) {
#line 67
    goto case_8;
  }
#line 68
  if (rtype == 9UL) {
#line 68
    goto case_9;
  }
#line 69
  if (rtype == 10UL) {
#line 69
    goto case_10;
  }
#line 70
  if (rtype == 11UL) {
#line 70
    goto case_11;
  }
#line 71
  if (rtype == 12UL) {
#line 71
    goto case_12;
  }
#line 72
  if (rtype == 13UL) {
#line 72
    goto case_13;
  }
#line 73
  if (rtype == 14UL) {
#line 73
    goto case_14;
  }
#line 74
  if (rtype == 15UL) {
#line 74
    goto case_15;
  }
#line 75
  if (rtype == 16UL) {
#line 75
    goto case_16;
  }
#line 76
  if (rtype == 17UL) {
#line 76
    goto case_17;
  }
#line 77
  if (rtype == 18UL) {
#line 77
    goto case_18;
  }
#line 78
  if (rtype == 19UL) {
#line 78
    goto case_19;
  }
#line 79
  if (rtype == 20UL) {
#line 79
    goto case_20;
  }
#line 80
  if (rtype == 21UL) {
#line 80
    goto case_21;
  }
#line 81
  if (rtype == 22UL) {
#line 81
    goto case_22;
  }
#line 82
  if (rtype == 23UL) {
#line 82
    goto case_23;
  }
#line 83
  if (rtype == 24UL) {
#line 83
    goto case_24;
  }
#line 84
  if (rtype == 25UL) {
#line 84
    goto case_25;
  }
#line 85
  if (rtype == 26UL) {
#line 85
    goto case_26;
  }
#line 86
  if (rtype == 27UL) {
#line 86
    goto case_27;
  }
#line 87
  if (rtype == 28UL) {
#line 87
    goto case_28;
  }
#line 88
  if (rtype == 29UL) {
#line 88
    goto case_29;
  }
#line 89
  if (rtype == 30UL) {
#line 89
    goto case_30;
  }
#line 90
  if (rtype == 31UL) {
#line 90
    goto case_31;
  }
#line 91
  if (rtype == 32UL) {
#line 91
    goto case_32;
  }
#line 92
  if (rtype == 33UL) {
#line 92
    goto case_33;
  }
#line 93
  if (rtype == 34UL) {
#line 93
    goto case_34;
  }
#line 94
  if (rtype == 35UL) {
#line 94
    goto case_35;
  }
#line 95
  if (rtype == 36UL) {
#line 95
    goto case_36;
  }
#line 96
  if (rtype == 37UL) {
#line 96
    goto case_37;
  }
#line 97
  if (rtype == 38UL) {
#line 97
    goto case_38;
  }
#line 98
  if (rtype == 39UL) {
#line 98
    goto case_39;
  }
#line 99
  if (rtype == 40UL) {
#line 99
    goto case_40;
  }
#line 100
  if (rtype == 41UL) {
#line 100
    goto case_41;
  }
#line 101
  if (rtype == 42UL) {
#line 101
    goto case_42;
  }
#line 102
  if (rtype == 43UL) {
#line 102
    goto case_43;
  }
#line 103
  if (rtype == 44UL) {
#line 103
    goto case_44;
  }
#line 104
  if (rtype == 45UL) {
#line 104
    goto case_45;
  }
#line 105
  if (rtype == 46UL) {
#line 105
    goto case_46;
  }
#line 106
  if (rtype == 47UL) {
#line 106
    goto case_47;
  }
#line 107
  if (rtype == 48UL) {
#line 107
    goto case_48;
  }
#line 108
  if (rtype == 49UL) {
#line 108
    goto case_49;
  }
#line 109
  if (rtype == 50UL) {
#line 109
    goto case_50;
  }
#line 110
  if (rtype == 51UL) {
#line 110
    goto case_51;
  }
#line 112
  goto switch_default;
  case_0: /* CIL Label */ 
#line 59
  return ("R_V850_NONE");
  case_1: /* CIL Label */ 
#line 60
  return ("R_V850_9_PCREL");
  case_2: /* CIL Label */ 
#line 61
  return ("R_V850_22_PCREL");
  case_3: /* CIL Label */ 
#line 62
  return ("R_V850_HI16_S");
  case_4: /* CIL Label */ 
#line 63
  return ("R_V850_HI16");
  case_5: /* CIL Label */ 
#line 64
  return ("R_V850_LO16");
  case_6: /* CIL Label */ 
#line 65
  return ("R_V850_ABS32");
  case_7: /* CIL Label */ 
#line 66
  return ("R_V850_16");
  case_8: /* CIL Label */ 
#line 67
  return ("R_V850_8");
  case_9: /* CIL Label */ 
#line 68
  return ("R_V850_SDA_16_16_OFFSET");
  case_10: /* CIL Label */ 
#line 69
  return ("R_V850_SDA_15_16_OFFSET");
  case_11: /* CIL Label */ 
#line 70
  return ("R_V850_ZDA_16_16_OFFSET");
  case_12: /* CIL Label */ 
#line 71
  return ("R_V850_ZDA_15_16_OFFSET");
  case_13: /* CIL Label */ 
#line 72
  return ("R_V850_TDA_6_8_OFFSET");
  case_14: /* CIL Label */ 
#line 73
  return ("R_V850_TDA_7_8_OFFSET");
  case_15: /* CIL Label */ 
#line 74
  return ("R_V850_TDA_7_7_OFFSET");
  case_16: /* CIL Label */ 
#line 75
  return ("R_V850_TDA_16_16_OFFSET");
  case_17: /* CIL Label */ 
#line 76
  return ("R_V850_TDA_4_5_OFFSET");
  case_18: /* CIL Label */ 
#line 77
  return ("R_V850_TDA_4_4_OFFSET");
  case_19: /* CIL Label */ 
#line 78
  return ("R_V850_SDA_16_16_SPLIT_OFFSET");
  case_20: /* CIL Label */ 
#line 79
  return ("R_V850_ZDA_16_16_SPLIT_OFFSET");
  case_21: /* CIL Label */ 
#line 80
  return ("R_V850_CALLT_6_7_OFFSET");
  case_22: /* CIL Label */ 
#line 81
  return ("R_V850_CALLT_16_16_OFFSET");
  case_23: /* CIL Label */ 
#line 82
  return ("R_V850_GNU_VTINHERIT");
  case_24: /* CIL Label */ 
#line 83
  return ("R_V850_GNU_VTENTRY");
  case_25: /* CIL Label */ 
#line 84
  return ("R_V850_LONGCALL");
  case_26: /* CIL Label */ 
#line 85
  return ("R_V850_LONGJUMP");
  case_27: /* CIL Label */ 
#line 86
  return ("R_V850_ALIGN");
  case_28: /* CIL Label */ 
#line 87
  return ("R_V850_REL32");
  case_29: /* CIL Label */ 
#line 88
  return ("R_V850_LO16_SPLIT_OFFSET");
  case_30: /* CIL Label */ 
#line 89
  return ("R_V850_16_PCREL");
  case_31: /* CIL Label */ 
#line 90
  return ("R_V850_17_PCREL");
  case_32: /* CIL Label */ 
#line 91
  return ("R_V850_23");
  case_33: /* CIL Label */ 
#line 92
  return ("R_V850_32_PCREL");
  case_34: /* CIL Label */ 
#line 93
  return ("R_V850_32_ABS");
  case_35: /* CIL Label */ 
#line 94
  return ("R_V850_16_SPLIT_OFFSET");
  case_36: /* CIL Label */ 
#line 95
  return ("R_V850_16_S1");
  case_37: /* CIL Label */ 
#line 96
  return ("R_V850_LO16_S1");
  case_38: /* CIL Label */ 
#line 97
  return ("R_V850_CALLT_15_16_OFFSET");
  case_39: /* CIL Label */ 
#line 98
  return ("R_V850_32_GOTPCREL");
  case_40: /* CIL Label */ 
#line 99
  return ("R_V850_16_GOT");
  case_41: /* CIL Label */ 
#line 100
  return ("R_V850_32_GOT");
  case_42: /* CIL Label */ 
#line 101
  return ("R_V850_22_PLT");
  case_43: /* CIL Label */ 
#line 102
  return ("R_V850_32_PLT");
  case_44: /* CIL Label */ 
#line 103
  return ("R_V850_COPY");
  case_45: /* CIL Label */ 
#line 104
  return ("R_V850_GLOB_DAT");
  case_46: /* CIL Label */ 
#line 105
  return ("R_V850_JMP_SLOT");
  case_47: /* CIL Label */ 
#line 106
  return ("R_V850_RELATIVE");
  case_48: /* CIL Label */ 
#line 107
  return ("R_V850_16_GOTOFF");
  case_49: /* CIL Label */ 
#line 108
  return ("R_V850_32_GOTOFF");
  case_50: /* CIL Label */ 
#line 109
  return ("R_V850_CODE");
  case_51: /* CIL Label */ 
#line 110
  return ("R_V850_DATA");
  switch_default: /* CIL Label */ 
#line 112
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/vax.h"
static char const   *elf_vax_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/vax.h"
static char const   *elf_vax_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 13UL) {
#line 36
    goto case_13;
  }
#line 37
  if (rtype == 19UL) {
#line 37
    goto case_19;
  }
#line 38
  if (rtype == 20UL) {
#line 38
    goto case_20;
  }
#line 39
  if (rtype == 21UL) {
#line 39
    goto case_21;
  }
#line 40
  if (rtype == 22UL) {
#line 40
    goto case_22;
  }
#line 42
  if (rtype == 23UL) {
#line 42
    goto case_23;
  }
#line 43
  if (rtype == 24UL) {
#line 43
    goto case_24;
  }
#line 44
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_VAX_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_VAX_32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_VAX_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_VAX_8");
  case_4: /* CIL Label */ 
#line 32
  return ("R_VAX_PC32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_VAX_PC16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_VAX_PC8");
  case_7: /* CIL Label */ 
#line 35
  return ("R_VAX_GOT32");
  case_13: /* CIL Label */ 
#line 36
  return ("R_VAX_PLT32");
  case_19: /* CIL Label */ 
#line 37
  return ("R_VAX_COPY");
  case_20: /* CIL Label */ 
#line 38
  return ("R_VAX_GLOB_DAT");
  case_21: /* CIL Label */ 
#line 39
  return ("R_VAX_JMP_SLOT");
  case_22: /* CIL Label */ 
#line 40
  return ("R_VAX_RELATIVE");
  case_23: /* CIL Label */ 
#line 42
  return ("R_VAX_GNU_VTINHERIT");
  case_24: /* CIL Label */ 
#line 43
  return ("R_VAX_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 44
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/x86-64.h"
static char const   *elf_x86_64_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/x86-64.h"
static char const   *elf_x86_64_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 37
  if (rtype == 9UL) {
#line 37
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  if (rtype == 13UL) {
#line 42
    goto case_13;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 47
  if (rtype == 18UL) {
#line 47
    goto case_18;
  }
#line 48
  if (rtype == 19UL) {
#line 48
    goto case_19;
  }
#line 49
  if (rtype == 20UL) {
#line 49
    goto case_20;
  }
#line 50
  if (rtype == 21UL) {
#line 50
    goto case_21;
  }
#line 51
  if (rtype == 22UL) {
#line 51
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 54
  if (rtype == 25UL) {
#line 54
    goto case_25;
  }
#line 55
  if (rtype == 26UL) {
#line 55
    goto case_26;
  }
#line 57
  if (rtype == 27UL) {
#line 57
    goto case_27;
  }
#line 58
  if (rtype == 28UL) {
#line 58
    goto case_28;
  }
#line 60
  if (rtype == 29UL) {
#line 60
    goto case_29;
  }
#line 62
  if (rtype == 30UL) {
#line 62
    goto case_30;
  }
#line 64
  if (rtype == 31UL) {
#line 64
    goto case_31;
  }
#line 67
  if (rtype == 34UL) {
#line 67
    goto case_34;
  }
#line 71
  if (rtype == 35UL) {
#line 71
    goto case_35;
  }
#line 73
  if (rtype == 36UL) {
#line 73
    goto case_36;
  }
#line 74
  if (rtype == 37UL) {
#line 74
    goto case_37;
  }
#line 75
  if (rtype == 38UL) {
#line 75
    goto case_38;
  }
#line 76
  if (rtype == 250UL) {
#line 76
    goto case_250;
  }
#line 77
  if (rtype == 251UL) {
#line 77
    goto case_251;
  }
#line 78
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_X86_64_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_X86_64_64");
  case_2: /* CIL Label */ 
#line 30
  return ("R_X86_64_PC32");
  case_3: /* CIL Label */ 
#line 31
  return ("R_X86_64_GOT32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_X86_64_PLT32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_X86_64_COPY");
  case_6: /* CIL Label */ 
#line 34
  return ("R_X86_64_GLOB_DAT");
  case_7: /* CIL Label */ 
#line 35
  return ("R_X86_64_JUMP_SLOT");
  case_8: /* CIL Label */ 
#line 36
  return ("R_X86_64_RELATIVE");
  case_9: /* CIL Label */ 
#line 37
  return ("R_X86_64_GOTPCREL");
  case_10: /* CIL Label */ 
#line 39
  return ("R_X86_64_32");
  case_11: /* CIL Label */ 
#line 40
  return ("R_X86_64_32S");
  case_12: /* CIL Label */ 
#line 41
  return ("R_X86_64_16");
  case_13: /* CIL Label */ 
#line 42
  return ("R_X86_64_PC16");
  case_14: /* CIL Label */ 
#line 43
  return ("R_X86_64_8");
  case_15: /* CIL Label */ 
#line 44
  return ("R_X86_64_PC8");
  case_16: /* CIL Label */ 
#line 45
  return ("R_X86_64_DTPMOD64");
  case_17: /* CIL Label */ 
#line 46
  return ("R_X86_64_DTPOFF64");
  case_18: /* CIL Label */ 
#line 47
  return ("R_X86_64_TPOFF64");
  case_19: /* CIL Label */ 
#line 48
  return ("R_X86_64_TLSGD");
  case_20: /* CIL Label */ 
#line 49
  return ("R_X86_64_TLSLD");
  case_21: /* CIL Label */ 
#line 50
  return ("R_X86_64_DTPOFF32");
  case_22: /* CIL Label */ 
#line 51
  return ("R_X86_64_GOTTPOFF");
  case_23: /* CIL Label */ 
#line 52
  return ("R_X86_64_TPOFF32");
  case_24: /* CIL Label */ 
#line 53
  return ("R_X86_64_PC64");
  case_25: /* CIL Label */ 
#line 54
  return ("R_X86_64_GOTOFF64");
  case_26: /* CIL Label */ 
#line 55
  return ("R_X86_64_GOTPC32");
  case_27: /* CIL Label */ 
#line 57
  return ("R_X86_64_GOT64");
  case_28: /* CIL Label */ 
#line 58
  return ("R_X86_64_GOTPCREL64");
  case_29: /* CIL Label */ 
#line 60
  return ("R_X86_64_GOTPC64");
  case_30: /* CIL Label */ 
#line 62
  return ("R_X86_64_GOTPLT64");
  case_31: /* CIL Label */ 
#line 64
  return ("R_X86_64_PLTOFF64");
  case_34: /* CIL Label */ 
#line 67
  return ("R_X86_64_GOTPC32_TLSDESC");
  case_35: /* CIL Label */ 
#line 71
  return ("R_X86_64_TLSDESC_CALL");
  case_36: /* CIL Label */ 
#line 73
  return ("R_X86_64_TLSDESC");
  case_37: /* CIL Label */ 
#line 74
  return ("R_X86_64_IRELATIVE");
  case_38: /* CIL Label */ 
#line 75
  return ("R_X86_64_RELATIVE64");
  case_250: /* CIL Label */ 
#line 76
  return ("R_X86_64_GNU_VTINHERIT");
  case_251: /* CIL Label */ 
#line 77
  return ("R_X86_64_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 78
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 27 "./../include/elf/xc16x.h"
static char const   *elf_xc16x_reloc_type(unsigned long rtype ) ;
#line 27 "./../include/elf/xc16x.h"
static char const   *elf_xc16x_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 28
  if (rtype == 0UL) {
#line 28
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 36
  if (rtype == 8UL) {
#line 36
    goto case_8;
  }
#line 38
  goto switch_default;
  case_0: /* CIL Label */ 
#line 28
  return ("R_XC16X_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_XC16X_ABS_8");
  case_2: /* CIL Label */ 
#line 30
  return ("R_XC16X_ABS_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_XC16X_ABS_32");
  case_4: /* CIL Label */ 
#line 32
  return ("R_XC16X_8_PCREL");
  case_5: /* CIL Label */ 
#line 33
  return ("R_XC16X_PAG");
  case_6: /* CIL Label */ 
#line 34
  return ("R_XC16X_POF");
  case_7: /* CIL Label */ 
#line 35
  return ("R_XC16X_SEG");
  case_8: /* CIL Label */ 
#line 36
  return ("R_XC16X_SOF");
  switch_default: /* CIL Label */ 
#line 38
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/xgate.h"
static char const   *elf_xgate_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/xgate.h"
static char const   *elf_xgate_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 28
  if (rtype == 1UL) {
#line 28
    goto case_1;
  }
#line 29
  if (rtype == 2UL) {
#line 29
    goto case_2;
  }
#line 30
  if (rtype == 3UL) {
#line 30
    goto case_3;
  }
#line 31
  if (rtype == 4UL) {
#line 31
    goto case_4;
  }
#line 32
  if (rtype == 5UL) {
#line 32
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 35
  if (rtype == 7UL) {
#line 35
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 39
  if (rtype == 10UL) {
#line 39
    goto case_10;
  }
#line 40
  if (rtype == 11UL) {
#line 40
    goto case_11;
  }
#line 41
  if (rtype == 12UL) {
#line 41
    goto case_12;
  }
#line 42
  if (rtype == 13UL) {
#line 42
    goto case_13;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 50
  if (rtype == 18UL) {
#line 50
    goto case_18;
  }
#line 53
  if (rtype == 19UL) {
#line 53
    goto case_19;
  }
#line 54
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_XGATE_NONE");
  case_1: /* CIL Label */ 
#line 28
  return ("R_XGATE_8");
  case_2: /* CIL Label */ 
#line 29
  return ("R_XGATE_PCREL_8");
  case_3: /* CIL Label */ 
#line 30
  return ("R_XGATE_16");
  case_4: /* CIL Label */ 
#line 31
  return ("R_XGATE_32");
  case_5: /* CIL Label */ 
#line 32
  return ("R_XGATE_PCREL_16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_XGATE_GNU_VTINHERIT");
  case_7: /* CIL Label */ 
#line 35
  return ("R_XGATE_GNU_VTENTRY");
  case_8: /* CIL Label */ 
#line 37
  return ("R_XGATE_24");
  case_9: /* CIL Label */ 
#line 38
  return ("R_XGATE_LO16");
  case_10: /* CIL Label */ 
#line 39
  return ("R_XGATE_GPAGE");
  case_11: /* CIL Label */ 
#line 40
  return ("R_XGATE_PCREL_9");
  case_12: /* CIL Label */ 
#line 41
  return ("R_XGATE_PCREL_10");
  case_13: /* CIL Label */ 
#line 42
  return ("R_XGATE_IMM8_LO");
  case_14: /* CIL Label */ 
#line 43
  return ("R_XGATE_IMM8_HI");
  case_15: /* CIL Label */ 
#line 44
  return ("R_XGATE_IMM3");
  case_16: /* CIL Label */ 
#line 45
  return ("R_XGATE_IMM4");
  case_17: /* CIL Label */ 
#line 46
  return ("R_XGATE_IMM5");
  case_18: /* CIL Label */ 
#line 50
  return ("R_XGATE_RL_JUMP");
  case_19: /* CIL Label */ 
#line 53
  return ("R_XGATE_RL_GROUP");
  switch_default: /* CIL Label */ 
#line 54
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 26 "./../include/elf/xstormy16.h"
static char const   *elf_xstormy16_reloc_type(unsigned long rtype ) ;
#line 26 "./../include/elf/xstormy16.h"
static char const   *elf_xstormy16_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 27
  if (rtype == 0UL) {
#line 27
    goto case_0;
  }
#line 29
  if (rtype == 1UL) {
#line 29
    goto case_1;
  }
#line 30
  if (rtype == 2UL) {
#line 30
    goto case_2;
  }
#line 31
  if (rtype == 3UL) {
#line 31
    goto case_3;
  }
#line 32
  if (rtype == 4UL) {
#line 32
    goto case_4;
  }
#line 33
  if (rtype == 5UL) {
#line 33
    goto case_5;
  }
#line 34
  if (rtype == 6UL) {
#line 34
    goto case_6;
  }
#line 36
  if (rtype == 7UL) {
#line 36
    goto case_7;
  }
#line 37
  if (rtype == 8UL) {
#line 37
    goto case_8;
  }
#line 38
  if (rtype == 9UL) {
#line 38
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 44
  if (rtype == 128UL) {
#line 44
    goto case_128;
  }
#line 45
  if (rtype == 129UL) {
#line 45
    goto case_129;
  }
#line 46
  goto switch_default;
  case_0: /* CIL Label */ 
#line 27
  return ("R_XSTORMY16_NONE");
  case_1: /* CIL Label */ 
#line 29
  return ("R_XSTORMY16_32");
  case_2: /* CIL Label */ 
#line 30
  return ("R_XSTORMY16_16");
  case_3: /* CIL Label */ 
#line 31
  return ("R_XSTORMY16_8");
  case_4: /* CIL Label */ 
#line 32
  return ("R_XSTORMY16_PC32");
  case_5: /* CIL Label */ 
#line 33
  return ("R_XSTORMY16_PC16");
  case_6: /* CIL Label */ 
#line 34
  return ("R_XSTORMY16_PC8");
  case_7: /* CIL Label */ 
#line 36
  return ("R_XSTORMY16_REL_12");
  case_8: /* CIL Label */ 
#line 37
  return ("R_XSTORMY16_24");
  case_9: /* CIL Label */ 
#line 38
  return ("R_XSTORMY16_FPTR16");
  case_10: /* CIL Label */ 
#line 40
  return ("R_XSTORMY16_LO16");
  case_11: /* CIL Label */ 
#line 41
  return ("R_XSTORMY16_HI16");
  case_12: /* CIL Label */ 
#line 42
  return ("R_XSTORMY16_12");
  case_128: /* CIL Label */ 
#line 44
  return ("R_XSTORMY16_GNU_VTINHERIT");
  case_129: /* CIL Label */ 
#line 45
  return ("R_XSTORMY16_GNU_VTENTRY");
  switch_default: /* CIL Label */ 
#line 46
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 30 "./../include/elf/xtensa.h"
static char const   *elf_xtensa_reloc_type(unsigned long rtype ) ;
#line 30 "./../include/elf/xtensa.h"
static char const   *elf_xtensa_reloc_type(unsigned long rtype ) 
{ 


  {
  {
#line 31
  if (rtype == 0UL) {
#line 31
    goto case_0;
  }
#line 32
  if (rtype == 1UL) {
#line 32
    goto case_1;
  }
#line 33
  if (rtype == 2UL) {
#line 33
    goto case_2;
  }
#line 34
  if (rtype == 3UL) {
#line 34
    goto case_3;
  }
#line 35
  if (rtype == 4UL) {
#line 35
    goto case_4;
  }
#line 36
  if (rtype == 5UL) {
#line 36
    goto case_5;
  }
#line 37
  if (rtype == 6UL) {
#line 37
    goto case_6;
  }
#line 38
  if (rtype == 8UL) {
#line 38
    goto case_8;
  }
#line 39
  if (rtype == 9UL) {
#line 39
    goto case_9;
  }
#line 40
  if (rtype == 10UL) {
#line 40
    goto case_10;
  }
#line 41
  if (rtype == 11UL) {
#line 41
    goto case_11;
  }
#line 42
  if (rtype == 12UL) {
#line 42
    goto case_12;
  }
#line 43
  if (rtype == 14UL) {
#line 43
    goto case_14;
  }
#line 44
  if (rtype == 15UL) {
#line 44
    goto case_15;
  }
#line 45
  if (rtype == 16UL) {
#line 45
    goto case_16;
  }
#line 46
  if (rtype == 17UL) {
#line 46
    goto case_17;
  }
#line 47
  if (rtype == 18UL) {
#line 47
    goto case_18;
  }
#line 48
  if (rtype == 19UL) {
#line 48
    goto case_19;
  }
#line 49
  if (rtype == 20UL) {
#line 49
    goto case_20;
  }
#line 50
  if (rtype == 21UL) {
#line 50
    goto case_21;
  }
#line 51
  if (rtype == 22UL) {
#line 51
    goto case_22;
  }
#line 52
  if (rtype == 23UL) {
#line 52
    goto case_23;
  }
#line 53
  if (rtype == 24UL) {
#line 53
    goto case_24;
  }
#line 54
  if (rtype == 25UL) {
#line 54
    goto case_25;
  }
#line 55
  if (rtype == 26UL) {
#line 55
    goto case_26;
  }
#line 56
  if (rtype == 27UL) {
#line 56
    goto case_27;
  }
#line 57
  if (rtype == 28UL) {
#line 57
    goto case_28;
  }
#line 58
  if (rtype == 29UL) {
#line 58
    goto case_29;
  }
#line 59
  if (rtype == 30UL) {
#line 59
    goto case_30;
  }
#line 60
  if (rtype == 31UL) {
#line 60
    goto case_31;
  }
#line 61
  if (rtype == 32UL) {
#line 61
    goto case_32;
  }
#line 62
  if (rtype == 33UL) {
#line 62
    goto case_33;
  }
#line 63
  if (rtype == 34UL) {
#line 63
    goto case_34;
  }
#line 64
  if (rtype == 35UL) {
#line 64
    goto case_35;
  }
#line 65
  if (rtype == 36UL) {
#line 65
    goto case_36;
  }
#line 66
  if (rtype == 37UL) {
#line 66
    goto case_37;
  }
#line 67
  if (rtype == 38UL) {
#line 67
    goto case_38;
  }
#line 68
  if (rtype == 39UL) {
#line 68
    goto case_39;
  }
#line 69
  if (rtype == 40UL) {
#line 69
    goto case_40;
  }
#line 70
  if (rtype == 41UL) {
#line 70
    goto case_41;
  }
#line 71
  if (rtype == 42UL) {
#line 71
    goto case_42;
  }
#line 72
  if (rtype == 43UL) {
#line 72
    goto case_43;
  }
#line 73
  if (rtype == 44UL) {
#line 73
    goto case_44;
  }
#line 74
  if (rtype == 45UL) {
#line 74
    goto case_45;
  }
#line 75
  if (rtype == 46UL) {
#line 75
    goto case_46;
  }
#line 76
  if (rtype == 47UL) {
#line 76
    goto case_47;
  }
#line 77
  if (rtype == 48UL) {
#line 77
    goto case_48;
  }
#line 78
  if (rtype == 49UL) {
#line 78
    goto case_49;
  }
#line 79
  if (rtype == 50UL) {
#line 79
    goto case_50;
  }
#line 80
  if (rtype == 51UL) {
#line 80
    goto case_51;
  }
#line 81
  if (rtype == 52UL) {
#line 81
    goto case_52;
  }
#line 82
  if (rtype == 53UL) {
#line 82
    goto case_53;
  }
#line 83
  if (rtype == 54UL) {
#line 83
    goto case_54;
  }
#line 84
  if (rtype == 55UL) {
#line 84
    goto case_55;
  }
#line 85
  if (rtype == 56UL) {
#line 85
    goto case_56;
  }
#line 86
  goto switch_default;
  case_0: /* CIL Label */ 
#line 31
  return ("R_XTENSA_NONE");
  case_1: /* CIL Label */ 
#line 32
  return ("R_XTENSA_32");
  case_2: /* CIL Label */ 
#line 33
  return ("R_XTENSA_RTLD");
  case_3: /* CIL Label */ 
#line 34
  return ("R_XTENSA_GLOB_DAT");
  case_4: /* CIL Label */ 
#line 35
  return ("R_XTENSA_JMP_SLOT");
  case_5: /* CIL Label */ 
#line 36
  return ("R_XTENSA_RELATIVE");
  case_6: /* CIL Label */ 
#line 37
  return ("R_XTENSA_PLT");
  case_8: /* CIL Label */ 
#line 38
  return ("R_XTENSA_OP0");
  case_9: /* CIL Label */ 
#line 39
  return ("R_XTENSA_OP1");
  case_10: /* CIL Label */ 
#line 40
  return ("R_XTENSA_OP2");
  case_11: /* CIL Label */ 
#line 41
  return ("R_XTENSA_ASM_EXPAND");
  case_12: /* CIL Label */ 
#line 42
  return ("R_XTENSA_ASM_SIMPLIFY");
  case_14: /* CIL Label */ 
#line 43
  return ("R_XTENSA_32_PCREL");
  case_15: /* CIL Label */ 
#line 44
  return ("R_XTENSA_GNU_VTINHERIT");
  case_16: /* CIL Label */ 
#line 45
  return ("R_XTENSA_GNU_VTENTRY");
  case_17: /* CIL Label */ 
#line 46
  return ("R_XTENSA_DIFF8");
  case_18: /* CIL Label */ 
#line 47
  return ("R_XTENSA_DIFF16");
  case_19: /* CIL Label */ 
#line 48
  return ("R_XTENSA_DIFF32");
  case_20: /* CIL Label */ 
#line 49
  return ("R_XTENSA_SLOT0_OP");
  case_21: /* CIL Label */ 
#line 50
  return ("R_XTENSA_SLOT1_OP");
  case_22: /* CIL Label */ 
#line 51
  return ("R_XTENSA_SLOT2_OP");
  case_23: /* CIL Label */ 
#line 52
  return ("R_XTENSA_SLOT3_OP");
  case_24: /* CIL Label */ 
#line 53
  return ("R_XTENSA_SLOT4_OP");
  case_25: /* CIL Label */ 
#line 54
  return ("R_XTENSA_SLOT5_OP");
  case_26: /* CIL Label */ 
#line 55
  return ("R_XTENSA_SLOT6_OP");
  case_27: /* CIL Label */ 
#line 56
  return ("R_XTENSA_SLOT7_OP");
  case_28: /* CIL Label */ 
#line 57
  return ("R_XTENSA_SLOT8_OP");
  case_29: /* CIL Label */ 
#line 58
  return ("R_XTENSA_SLOT9_OP");
  case_30: /* CIL Label */ 
#line 59
  return ("R_XTENSA_SLOT10_OP");
  case_31: /* CIL Label */ 
#line 60
  return ("R_XTENSA_SLOT11_OP");
  case_32: /* CIL Label */ 
#line 61
  return ("R_XTENSA_SLOT12_OP");
  case_33: /* CIL Label */ 
#line 62
  return ("R_XTENSA_SLOT13_OP");
  case_34: /* CIL Label */ 
#line 63
  return ("R_XTENSA_SLOT14_OP");
  case_35: /* CIL Label */ 
#line 64
  return ("R_XTENSA_SLOT0_ALT");
  case_36: /* CIL Label */ 
#line 65
  return ("R_XTENSA_SLOT1_ALT");
  case_37: /* CIL Label */ 
#line 66
  return ("R_XTENSA_SLOT2_ALT");
  case_38: /* CIL Label */ 
#line 67
  return ("R_XTENSA_SLOT3_ALT");
  case_39: /* CIL Label */ 
#line 68
  return ("R_XTENSA_SLOT4_ALT");
  case_40: /* CIL Label */ 
#line 69
  return ("R_XTENSA_SLOT5_ALT");
  case_41: /* CIL Label */ 
#line 70
  return ("R_XTENSA_SLOT6_ALT");
  case_42: /* CIL Label */ 
#line 71
  return ("R_XTENSA_SLOT7_ALT");
  case_43: /* CIL Label */ 
#line 72
  return ("R_XTENSA_SLOT8_ALT");
  case_44: /* CIL Label */ 
#line 73
  return ("R_XTENSA_SLOT9_ALT");
  case_45: /* CIL Label */ 
#line 74
  return ("R_XTENSA_SLOT10_ALT");
  case_46: /* CIL Label */ 
#line 75
  return ("R_XTENSA_SLOT11_ALT");
  case_47: /* CIL Label */ 
#line 76
  return ("R_XTENSA_SLOT12_ALT");
  case_48: /* CIL Label */ 
#line 77
  return ("R_XTENSA_SLOT13_ALT");
  case_49: /* CIL Label */ 
#line 78
  return ("R_XTENSA_SLOT14_ALT");
  case_50: /* CIL Label */ 
#line 79
  return ("R_XTENSA_TLSDESC_FN");
  case_51: /* CIL Label */ 
#line 80
  return ("R_XTENSA_TLSDESC_ARG");
  case_52: /* CIL Label */ 
#line 81
  return ("R_XTENSA_TLS_DTPOFF");
  case_53: /* CIL Label */ 
#line 82
  return ("R_XTENSA_TLS_TPOFF");
  case_54: /* CIL Label */ 
#line 83
  return ("R_XTENSA_TLS_FUNC");
  case_55: /* CIL Label */ 
#line 84
  return ("R_XTENSA_TLS_ARG");
  case_56: /* CIL Label */ 
#line 85
  return ("R_XTENSA_TLS_CALL");
  switch_default: /* CIL Label */ 
#line 86
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 121 "./../include/getopt.h"
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 162 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
char *program_name  =    (char *)"readelf";
#line 163 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static long archive_file_offset  ;
#line 164 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long archive_file_size  ;
#line 165 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long dynamic_addr  ;
#line 166 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_size_type dynamic_size  ;
#line 167 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned int dynamic_nent  ;
#line 168 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *dynamic_strings  ;
#line 169 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long dynamic_strings_length  ;
#line 170 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *string_table  ;
#line 171 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long string_table_length  ;
#line 172 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long num_dynamic_syms  ;
#line 173 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Sym *dynamic_symbols  ;
#line 174 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Syminfo *dynamic_syminfo  ;
#line 175 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long dynamic_syminfo_offset  ;
#line 176 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned int dynamic_syminfo_nent  ;
#line 177 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char program_interpreter[4096]  ;
#line 178 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma dynamic_info[32]  ;
#line 179 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma dynamic_info_DT_GNU_HASH  ;
#line 180 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma version_info[16]  ;
#line 181 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Ehdr elf_header  ;
#line 182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Shdr *section_headers  ;
#line 183 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Phdr *program_headers  ;
#line 184 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Dyn *dynamic_section  ;
#line 185 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Shdr *symtab_shndx_hdr  ;
#line 186 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int show_name  ;
#line 187 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_dynamic  ;
#line 188 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_syms  ;
#line 189 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_dyn_syms  ;
#line 190 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_reloc  ;
#line 191 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_sections  ;
#line 192 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_section_groups  ;
#line 193 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_section_details  ;
#line 194 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_segments  ;
#line 195 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_unwind  ;
#line 196 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_using_dynamic  ;
#line 197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_header  ;
#line 198 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_dump  ;
#line 199 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_version  ;
#line 200 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_histogram  ;
#line 201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_debugging  ;
#line 202 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_arch  ;
#line 203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_notes  ;
#line 204 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int do_archive_index  ;
#line 205 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int is_32bit_elf  ;
#line 219 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static size_t group_count  ;
#line 220 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct group *section_groups  ;
#line 221 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct group **section_headers_groups  ;
#line 240 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct dump_list_entry *dump_sects_byname  ;
#line 244 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static dump_type *cmdline_dump_sects  =    (dump_type *)((void *)0);
#line 245 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned int num_cmdline_dump_sects  =    0U;
#line 252 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static dump_type *dump_sects  =    (dump_type *)((void *)0);
#line 253 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned int num_dump_sects  =    0U;
#line 302 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void *get_data(void *var , FILE *file , long offset , size_t size , size_t nmemb ,
                      char const   *reason ) 
{ 
  void *mvar ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 308
  if (size == 0UL) {
#line 309
    return ((void *)0);
  } else
#line 308
  if (nmemb == 0UL) {
#line 309
    return ((void *)0);
  }
  {
#line 311
  tmp___1 = fseek(file, archive_file_offset + offset, 0);
  }
#line 311
  if (tmp___1) {
    {
#line 313
    tmp___0 = gettext("Unable to seek to 0x%lx for %s\n");
#line 313
    error((char const   *)tmp___0, (unsigned long )archive_file_offset + (unsigned long )offset,
          reason);
    }
#line 315
    return ((void *)0);
  }
#line 318
  mvar = var;
#line 319
  if ((unsigned long )mvar == (unsigned long )((void *)0)) {
#line 322
    if (nmemb < 0xfffffffffffffffeUL / size) {
      {
#line 324
      mvar = malloc(size * nmemb + 1UL);
      }
    }
#line 326
    if ((unsigned long )mvar == (unsigned long )((void *)0)) {
      {
#line 328
      tmp___2 = gettext("Out of memory allocating 0x%lx bytes for %s\n");
#line 328
      error((char const   *)tmp___2, size * nmemb, reason);
      }
#line 330
      return ((void *)0);
    }
#line 333
    *((char *)mvar + size * nmemb) = (char )'\000';
  }
  {
#line 336
  tmp___4 = fread((void */* __restrict  */)mvar, size, nmemb, (FILE */* __restrict  */)file);
  }
#line 336
  if (tmp___4 != nmemb) {
    {
#line 338
    tmp___3 = gettext("Unable to read in 0x%lx bytes of %s\n");
#line 338
    error((char const   *)tmp___3, size * nmemb, reason);
    }
#line 340
    if ((unsigned long )mvar != (unsigned long )var) {
      {
#line 341
      free(mvar);
      }
    }
#line 342
    return ((void *)0);
  }
#line 345
  return (mvar);
}
}
#line 350 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int print_vma(bfd_vma vma , print_mode mode ) 
{ 
  int nc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 353
  nc = 0;
  {
#line 357
  if ((unsigned int )mode == 5U) {
#line 357
    goto case_5;
  }
#line 361
  if ((unsigned int )mode == 6U) {
#line 361
    goto case_6;
  }
#line 369
  if ((unsigned int )mode == 2U) {
#line 369
    goto case_2;
  }
#line 374
  if ((unsigned int )mode == 4U) {
#line 374
    goto case_4;
  }
#line 378
  if ((unsigned int )mode == 0U) {
#line 378
    goto case_0;
  }
#line 381
  if ((unsigned int )mode == 1U) {
#line 381
    goto case_1;
  }
#line 384
  if ((unsigned int )mode == 3U) {
#line 384
    goto case_3;
  }
#line 355
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 358
  nc = printf((char const   */* __restrict  */)"0x");
  }
  case_6: /* CIL Label */ 
#line 363
  if (is_32bit_elf) {
    {
#line 364
    tmp___0 = printf((char const   */* __restrict  */)"%8.8lx", vma);
    }
#line 364
    return (nc + tmp___0);
  }
  {
#line 366
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
          vma);
  }
#line 367
  return (nc + 16);
  case_2: /* CIL Label */ 
#line 370
  if (vma <= 99999UL) {
    {
#line 371
    tmp___1 = printf((char const   */* __restrict  */)"%5ld", vma);
    }
#line 371
    return (tmp___1);
  }
  case_4: /* CIL Label */ 
  {
#line 375
  nc = printf((char const   */* __restrict  */)"0x");
  }
  case_0: /* CIL Label */ 
  {
#line 379
  tmp___2 = printf((char const   */* __restrict  */)"%lx", vma);
  }
#line 379
  return (nc + tmp___2);
  case_1: /* CIL Label */ 
  {
#line 382
  tmp___3 = printf((char const   */* __restrict  */)"%ld", vma);
  }
#line 382
  return (tmp___3);
  case_3: /* CIL Label */ 
  {
#line 385
  tmp___4 = printf((char const   */* __restrict  */)"%lu", vma);
  }
#line 385
  return (tmp___4);
  switch_break: /* CIL Label */ ;
  }
#line 387
  return (0);
}
}
#line 400 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned int print_symbol(int width , char const   *symbol ) 
{ 
  bfd_boolean extra_padding ;
  int num_printed ;
  mbstate_t state ;
  int width_remaining ;
  size_t n ;
  char c ;
  char const   *tmp___0 ;
  wchar_t w ;
  size_t tmp___1 ;

  {
#line 403
  extra_padding = 0;
#line 404
  num_printed = 0;
#line 410
  if (width < 0) {
#line 413
    width = - width;
#line 414
    extra_padding = 1;
  }
#line 417
  if (do_wide) {
#line 420
    width_remaining = 2147483647;
  } else {
#line 422
    width_remaining = width;
  }
  {
#line 426
  memset((void *)(& state), 0, sizeof(state));
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! width_remaining) {
#line 429
      goto while_break;
    }
#line 432
    tmp___0 = symbol;
#line 432
    symbol ++;
#line 432
    c = (char )*tmp___0;
#line 434
    if ((int )c == 0) {
#line 435
      goto while_break;
    }
#line 440
    if ((int const   )_sch_istable[(int )c & 255] & 2) {
#line 442
      if (width_remaining < 2) {
#line 443
        goto while_break;
      }
      {
#line 445
      printf((char const   */* __restrict  */)"^%c", (int )c + 64);
#line 446
      width_remaining -= 2;
#line 447
      num_printed += 2;
      }
    } else
#line 449
    if ((int const   )_sch_istable[(int )c & 255] & 16) {
      {
#line 451
      putchar((int )c);
#line 452
      width_remaining --;
#line 453
      num_printed ++;
      }
    } else {
      {
#line 461
      printf((char const   */* __restrict  */)"%.1s", symbol - 1);
#line 462
      width_remaining --;
#line 463
      num_printed ++;
#line 469
      tmp___1 = __ctype_get_mb_cur_max();
#line 469
      n = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(symbol - 1),
                  tmp___1, (mbstate_t */* __restrict  */)(& state));
      }
#line 473
      if (n != 0xffffffffffffffffUL) {
#line 473
        if (n != 0xfffffffffffffffeUL) {
#line 473
          if (n > 0UL) {
#line 474
            symbol += n - 1UL;
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 478
  if (extra_padding) {
#line 478
    if (num_printed < width) {
      {
#line 481
      printf((char const   */* __restrict  */)"%-*s", width - num_printed, " ");
#line 482
      num_printed = width;
      }
    }
  }
#line 485
  return ((unsigned int )num_printed);
}
}
#line 490 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Shdr *find_section(char const   *name___0 ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 495
  i = 0U;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! (i < elf_header.e_shnum)) {
#line 495
      goto while_break;
    }
#line 496
    if ((unsigned long )(section_headers + i) == (unsigned long )((void *)0)) {
      {
#line 496
      tmp___0 = gettext("<none>");
#line 496
      tmp___5 = tmp___0;
      }
    } else {
#line 496
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 496
        tmp___1 = gettext("<no-name>");
#line 496
        tmp___4 = tmp___1;
        }
      } else {
#line 496
        if ((unsigned long )(section_headers + i)->sh_name >= string_table_length) {
          {
#line 496
          tmp___2 = gettext("<corrupt>");
#line 496
          tmp___3 = tmp___2;
          }
        } else {
#line 496
          tmp___3 = string_table + (section_headers + i)->sh_name;
        }
#line 496
        tmp___4 = tmp___3;
      }
#line 496
      tmp___5 = tmp___4;
    }
    {
#line 496
    tmp___6 = strcmp((char const   *)tmp___5, name___0);
    }
#line 496
    if (tmp___6 == 0) {
#line 497
      return (section_headers + i);
    }
#line 495
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 499
  return ((Elf_Internal_Shdr *)((void *)0));
}
}
#line 505 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Shdr *find_section_by_address(bfd_vma addr ) 
{ 
  unsigned int i ;
  Elf_Internal_Shdr *sec ;

  {
#line 510
  i = 0U;
  {
#line 510
  while (1) {
    while_continue: /* CIL Label */ ;
#line 510
    if (! (i < elf_header.e_shnum)) {
#line 510
      goto while_break;
    }
#line 512
    sec = section_headers + i;
#line 513
    if (addr >= sec->sh_addr) {
#line 513
      if (addr < sec->sh_addr + sec->sh_size) {
#line 514
        return (sec);
      }
    }
#line 510
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 517
  return ((Elf_Internal_Shdr *)((void *)0));
}
}
#line 523 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned long read_uleb128(unsigned char *data , unsigned int *length_return ) 
{ 
  dwarf_vma tmp___0 ;

  {
  {
#line 526
  tmp___0 = read_leb128(data, length_return, 0);
  }
#line 526
  return ((unsigned long )tmp___0);
}
}
#line 533 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
__inline static int is_ia64_vms(void) 
{ 
  int tmp___0 ;

  {
#line 536
  if ((int )elf_header.e_machine == 50) {
#line 536
    if ((int )elf_header.e_ident[7] == 13) {
#line 536
      tmp___0 = 1;
    } else {
#line 536
      tmp___0 = 0;
    }
  } else {
#line 536
    tmp___0 = 0;
  }
#line 536
  return (tmp___0);
}
}
#line 542 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int guess_is_rela(unsigned int e_machine ) 
{ 
  char *tmp___0 ;

  {
  {
#line 561
  if (e_machine == 115U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 135U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 33906U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 92U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 36929U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 10U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 8U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 23205U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 30288U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 85U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 40U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 19U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 6U) {
#line 561
    goto case_115;
  }
#line 561
  if (e_machine == 3U) {
#line 561
    goto case_115;
  }
#line 629
  if (e_machine == 47787U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 189U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 43975U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 94U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 44357U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 181U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 180U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 62U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 75U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 36992U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 87U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 188U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 191U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 140U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 23U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 43U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 18U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 2U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 42U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 41872U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 22U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 173U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 197U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 20U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 21U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 65211U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 9520U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 4185U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 105U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 65261U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 48879U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 89U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 57005U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 90U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 80U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 61453U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 39U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 88U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 120U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 65200U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 138U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 65210U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 33303U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 101U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 50U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 47U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 46U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 48U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 21569U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 13104U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 84U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 30326U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 86U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 114U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 76U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 177U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 106U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 4183U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 83U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 113U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 36902U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 4643U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 183U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 7U) {
#line 629
    goto case_47787;
  }
#line 629
  if (e_machine == 4U) {
#line 629
    goto case_47787;
  }
#line 649
  goto switch_default;
  case_115: /* CIL Label */ 
  case_135: /* CIL Label */ 
  case_33906: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_36929: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_23205: /* CIL Label */ 
  case_30288: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 562
  return (0);
  case_47787: /* CIL Label */ 
  case_189: /* CIL Label */ 
  case_43975: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_44357: /* CIL Label */ 
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_36992: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_188: /* CIL Label */ 
  case_191: /* CIL Label */ 
  case_140: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41872: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_173: /* CIL Label */ 
  case_197: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_65211: /* CIL Label */ 
  case_9520: /* CIL Label */ 
  case_4185: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_65261: /* CIL Label */ 
  case_48879: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_57005: /* CIL Label */ 
  case_90: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_61453: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
  case_138: /* CIL Label */ 
  case_65210: /* CIL Label */ 
  case_33303: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_21569: /* CIL Label */ 
  case_13104: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_30326: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_177: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_4183: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_36902: /* CIL Label */ 
  case_4643: /* CIL Label */ 
  case_183: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 630
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 650
  tmp___0 = gettext("Don\'t know about relocations on this machine architecture\n");
#line 650
  warn((char const   *)tmp___0);
  }
#line 651
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 655 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int slurp_rela_relocs(FILE *file , unsigned long rel_offset , unsigned long rel_size ,
                             Elf_Internal_Rela **relasp , unsigned long *nrelasp ) 
{ 
  Elf_Internal_Rela *relas ;
  unsigned long nrelas ;
  unsigned int i ;
  Elf32_External_Rela *erelas ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  Elf64_External_Rela *erelas___0 ;
  char *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  bfd_vma inf ;

  {
#line 666
  if (is_32bit_elf) {
    {
#line 670
    tmp___0 = gettext("32-bit relocation data");
#line 670
    tmp___1 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___0);
#line 670
    erelas = (Elf32_External_Rela *)tmp___1;
    }
#line 672
    if (! erelas) {
#line 673
      return (0);
    }
    {
#line 675
    nrelas = rel_size / sizeof(Elf32_External_Rela );
#line 677
    tmp___2 = cmalloc(nrelas, sizeof(Elf_Internal_Rela ));
#line 677
    relas = (Elf_Internal_Rela *)tmp___2;
    }
#line 680
    if ((unsigned long )relas == (unsigned long )((void *)0)) {
      {
#line 682
      free((void *)erelas);
#line 683
      tmp___3 = gettext("out of memory parsing relocs\n");
#line 683
      error((char const   *)tmp___3);
      }
#line 684
      return (0);
    }
#line 687
    i = 0U;
    {
#line 687
    while (1) {
      while_continue: /* CIL Label */ ;
#line 687
      if (! ((unsigned long )i < nrelas)) {
#line 687
        goto while_break;
      }
      {
#line 689
      tmp___4 = (*byte_get)((erelas + i)->r_offset, (int )sizeof((erelas + i)->r_offset));
#line 689
      (relas + i)->r_offset = (bfd_vma )tmp___4;
#line 690
      tmp___5 = (*byte_get)((erelas + i)->r_info, (int )sizeof((erelas + i)->r_info));
#line 690
      (relas + i)->r_info = (bfd_vma )tmp___5;
#line 691
      tmp___6 = byte_get_signed((erelas + i)->r_addend, (int )sizeof((erelas + i)->r_addend));
#line 691
      (relas + i)->r_addend = (bfd_vma )tmp___6;
#line 687
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 694
    free((void *)erelas);
    }
  } else {
    {
#line 700
    tmp___7 = gettext("64-bit relocation data");
#line 700
    tmp___8 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___7);
#line 700
    erelas___0 = (Elf64_External_Rela *)tmp___8;
    }
#line 702
    if (! erelas___0) {
#line 703
      return (0);
    }
    {
#line 705
    nrelas = rel_size / sizeof(Elf64_External_Rela );
#line 707
    tmp___9 = cmalloc(nrelas, sizeof(Elf_Internal_Rela ));
#line 707
    relas = (Elf_Internal_Rela *)tmp___9;
    }
#line 710
    if ((unsigned long )relas == (unsigned long )((void *)0)) {
      {
#line 712
      free((void *)erelas___0);
#line 713
      tmp___10 = gettext("out of memory parsing relocs\n");
#line 713
      error((char const   *)tmp___10);
      }
#line 714
      return (0);
    }
#line 717
    i = 0U;
    {
#line 717
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 717
      if (! ((unsigned long )i < nrelas)) {
#line 717
        goto while_break___0;
      }
      {
#line 719
      tmp___11 = (*byte_get)((erelas___0 + i)->r_offset, (int )sizeof((erelas___0 + i)->r_offset));
#line 719
      (relas + i)->r_offset = (bfd_vma )tmp___11;
#line 720
      tmp___12 = (*byte_get)((erelas___0 + i)->r_info, (int )sizeof((erelas___0 + i)->r_info));
#line 720
      (relas + i)->r_info = (bfd_vma )tmp___12;
#line 721
      tmp___13 = byte_get_signed((erelas___0 + i)->r_addend, (int )sizeof((erelas___0 + i)->r_addend));
#line 721
      (relas + i)->r_addend = (bfd_vma )tmp___13;
      }
#line 727
      if ((int )elf_header.e_machine == 8) {
#line 727
        if ((int )elf_header.e_ident[5] != 2) {
#line 735
          inf = (relas + i)->r_info;
#line 736
          inf = (((((inf & 4294967295UL) << 32) | ((inf >> 56) & 255UL)) | ((inf >> 40) & 65280UL)) | ((inf >> 24) & 16711680UL)) | ((inf >> 8) & 4278190080UL);
#line 741
          (relas + i)->r_info = inf;
        }
      }
#line 717
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 746
    free((void *)erelas___0);
    }
  }
#line 748
  *relasp = relas;
#line 749
  *nrelasp = nrelas;
#line 750
  return (1);
}
}
#line 753 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int slurp_rel_relocs(FILE *file , unsigned long rel_offset , unsigned long rel_size ,
                            Elf_Internal_Rela **relsp , unsigned long *nrelsp ) 
{ 
  Elf_Internal_Rela *rels ;
  unsigned long nrels ;
  unsigned int i ;
  Elf32_External_Rel *erels ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  Elf64_External_Rel *erels___0 ;
  char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  bfd_vma inf ;

  {
#line 764
  if (is_32bit_elf) {
    {
#line 768
    tmp___0 = gettext("32-bit relocation data");
#line 768
    tmp___1 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___0);
#line 768
    erels = (Elf32_External_Rel *)tmp___1;
    }
#line 770
    if (! erels) {
#line 771
      return (0);
    }
    {
#line 773
    nrels = rel_size / sizeof(Elf32_External_Rel );
#line 775
    tmp___2 = cmalloc(nrels, sizeof(Elf_Internal_Rela ));
#line 775
    rels = (Elf_Internal_Rela *)tmp___2;
    }
#line 777
    if ((unsigned long )rels == (unsigned long )((void *)0)) {
      {
#line 779
      free((void *)erels);
#line 780
      tmp___3 = gettext("out of memory parsing relocs\n");
#line 780
      error((char const   *)tmp___3);
      }
#line 781
      return (0);
    }
#line 784
    i = 0U;
    {
#line 784
    while (1) {
      while_continue: /* CIL Label */ ;
#line 784
      if (! ((unsigned long )i < nrels)) {
#line 784
        goto while_break;
      }
      {
#line 786
      tmp___4 = (*byte_get)((erels + i)->r_offset, (int )sizeof((erels + i)->r_offset));
#line 786
      (rels + i)->r_offset = (bfd_vma )tmp___4;
#line 787
      tmp___5 = (*byte_get)((erels + i)->r_info, (int )sizeof((erels + i)->r_info));
#line 787
      (rels + i)->r_info = (bfd_vma )tmp___5;
#line 788
      (rels + i)->r_addend = (bfd_vma )0;
#line 784
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 791
    free((void *)erels);
    }
  } else {
    {
#line 797
    tmp___6 = gettext("64-bit relocation data");
#line 797
    tmp___7 = get_data((void *)0, file, (long )rel_offset, (size_t )1, rel_size, (char const   *)tmp___6);
#line 797
    erels___0 = (Elf64_External_Rel *)tmp___7;
    }
#line 799
    if (! erels___0) {
#line 800
      return (0);
    }
    {
#line 802
    nrels = rel_size / sizeof(Elf64_External_Rel );
#line 804
    tmp___8 = cmalloc(nrels, sizeof(Elf_Internal_Rela ));
#line 804
    rels = (Elf_Internal_Rela *)tmp___8;
    }
#line 806
    if ((unsigned long )rels == (unsigned long )((void *)0)) {
      {
#line 808
      free((void *)erels___0);
#line 809
      tmp___9 = gettext("out of memory parsing relocs\n");
#line 809
      error((char const   *)tmp___9);
      }
#line 810
      return (0);
    }
#line 813
    i = 0U;
    {
#line 813
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 813
      if (! ((unsigned long )i < nrels)) {
#line 813
        goto while_break___0;
      }
      {
#line 815
      tmp___10 = (*byte_get)((erels___0 + i)->r_offset, (int )sizeof((erels___0 + i)->r_offset));
#line 815
      (rels + i)->r_offset = (bfd_vma )tmp___10;
#line 816
      tmp___11 = (*byte_get)((erels___0 + i)->r_info, (int )sizeof((erels___0 + i)->r_info));
#line 816
      (rels + i)->r_info = (bfd_vma )tmp___11;
#line 817
      (rels + i)->r_addend = (bfd_vma )0;
      }
#line 823
      if ((int )elf_header.e_machine == 8) {
#line 823
        if ((int )elf_header.e_ident[5] != 2) {
#line 831
          inf = (rels + i)->r_info;
#line 832
          inf = (((((inf & 4294967295UL) << 32) | ((inf >> 56) & 255UL)) | ((inf >> 40) & 65280UL)) | ((inf >> 24) & 16711680UL)) | ((inf >> 8) & 4278190080UL);
#line 837
          (rels + i)->r_info = inf;
        }
      }
#line 813
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 842
    free((void *)erels___0);
    }
  }
#line 844
  *relsp = rels;
#line 845
  *nrelsp = nrels;
#line 846
  return (1);
}
}
#line 851 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned int get_reloc_type(bfd_vma reloc_info ) 
{ 


  {
#line 854
  if (is_32bit_elf) {
#line 855
    return ((unsigned int )(reloc_info & 255UL));
  }
  {
#line 859
  if ((int )elf_header.e_machine == 8) {
#line 859
    goto case_8;
  }
#line 863
  if ((int )elf_header.e_machine == 43) {
#line 863
    goto case_43;
  }
#line 866
  goto switch_default;
  case_8: /* CIL Label */ 
#line 861
  return ((unsigned int )(reloc_info & 255UL));
  case_43: /* CIL Label */ 
#line 864
  return ((unsigned int )(reloc_info & 255UL));
  switch_default: /* CIL Label */ 
#line 867
  return ((unsigned int )(reloc_info & 4294967295UL));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 873 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma get_reloc_symindex(bfd_vma reloc_info ) 
{ 
  bfd_vma tmp___0 ;

  {
#line 876
  if (is_32bit_elf) {
#line 876
    tmp___0 = reloc_info >> 8;
  } else {
#line 876
    tmp___0 = reloc_info >> 32;
  }
#line 876
  return (tmp___0);
}
}
#line 882 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_relocations(FILE *file , unsigned long rel_offset , unsigned long rel_size ,
                             Elf_Internal_Sym *symtab , unsigned long nsyms , char *strtab ,
                             unsigned long strtablen , int is_rela ) 
{ 
  unsigned int i ;
  Elf_Internal_Rela *rels ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char const   *rtype ;
  bfd_vma offset ;
  bfd_vma inf ;
  bfd_vma symtab_index ;
  bfd_vma type ;
  unsigned int tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  Elf_Internal_Sym *psym ;
  char const   *name___0 ;
  unsigned int len ;
  unsigned int width ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  char const   *tmp___18 ;
  char const   *sec_name ;
  char name_buf[40] ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  bfd_signed_vma off ;
  bfd_signed_vma off___0 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  bfd_vma type2 ;
  bfd_vma type3 ;
  char const   *rtype2 ;
  char const   *tmp___30 ;
  char const   *rtype3 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;

  {
#line 895
  if (is_rela == -1) {
    {
#line 896
    is_rela = guess_is_rela((unsigned int )elf_header.e_machine);
    }
  }
#line 898
  if (is_rela) {
    {
#line 900
    tmp___0 = slurp_rela_relocs(file, rel_offset, rel_size, & rels, & rel_size);
    }
#line 900
    if (! tmp___0) {
#line 901
      return;
    }
  } else {
    {
#line 905
    tmp___1 = slurp_rel_relocs(file, rel_offset, rel_size, & rels, & rel_size);
    }
#line 905
    if (! tmp___1) {
#line 906
      return;
    }
  }
#line 909
  if (is_32bit_elf) {
#line 911
    if (is_rela) {
#line 913
      if (do_wide) {
        {
#line 914
        tmp___2 = gettext(" Offset     Info    Type                Sym. Value  Symbol\'s Name + Addend\n");
#line 914
        printf((char const   */* __restrict  */)tmp___2);
        }
      } else {
        {
#line 916
        tmp___3 = gettext(" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n");
#line 916
        printf((char const   */* __restrict  */)tmp___3);
        }
      }
    } else
#line 920
    if (do_wide) {
      {
#line 921
      tmp___4 = gettext(" Offset     Info    Type                Sym. Value  Symbol\'s Name\n");
#line 921
      printf((char const   */* __restrict  */)tmp___4);
      }
    } else {
      {
#line 923
      tmp___5 = gettext(" Offset     Info    Type            Sym.Value  Sym. Name\n");
#line 923
      printf((char const   */* __restrict  */)tmp___5);
      }
    }
  } else
#line 928
  if (is_rela) {
#line 930
    if (do_wide) {
      {
#line 931
      tmp___6 = gettext("    Offset             Info             Type               Symbol\'s Value  Symbol\'s Name + Addend\n");
#line 931
      printf((char const   */* __restrict  */)tmp___6);
      }
    } else {
      {
#line 933
      tmp___7 = gettext("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n");
#line 933
      printf((char const   */* __restrict  */)tmp___7);
      }
    }
  } else
#line 937
  if (do_wide) {
    {
#line 938
    tmp___8 = gettext("    Offset             Info             Type               Symbol\'s Value  Symbol\'s Name\n");
#line 938
    printf((char const   */* __restrict  */)tmp___8);
    }
  } else {
    {
#line 940
    tmp___9 = gettext("  Offset          Info           Type           Sym. Value    Sym. Name\n");
#line 940
    printf((char const   */* __restrict  */)tmp___9);
    }
  }
#line 944
  i = 0U;
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    if (! ((unsigned long )i < rel_size)) {
#line 944
      goto while_break;
    }
    {
#line 952
    offset = (rels + i)->r_offset;
#line 953
    inf = (rels + i)->r_info;
#line 955
    tmp___10 = get_reloc_type(inf);
#line 955
    type = (bfd_vma )tmp___10;
#line 956
    symtab_index = get_reloc_symindex(inf);
    }
#line 958
    if (is_32bit_elf) {
      {
#line 960
      printf((char const   */* __restrict  */)"%8.8lx  %8.8lx ", offset & 4294967295UL,
             inf & 4294967295UL);
      }
    } else {
#line 967
      if (do_wide) {
#line 967
        tmp___11 = "%16.16lx  %16.16lx ";
      } else {
#line 967
        tmp___11 = "%12.12lx  %12.12lx ";
      }
      {
#line 967
      printf((char const   */* __restrict  */)tmp___11, offset, inf);
      }
    }
    {
#line 1000
    if ((int )elf_header.e_machine == 183) {
#line 1000
      goto case_183;
    }
#line 1005
    if ((int )elf_header.e_machine == 36929) {
#line 1005
      goto case_36929;
    }
#line 1005
    if ((int )elf_header.e_machine == 88) {
#line 1005
      goto case_36929;
    }
#line 1010
    if ((int )elf_header.e_machine == 6) {
#line 1010
      goto case_6;
    }
#line 1010
    if ((int )elf_header.e_machine == 3) {
#line 1010
      goto case_6;
    }
#line 1015
    if ((int )elf_header.e_machine == 53) {
#line 1015
      goto case_53;
    }
#line 1015
    if ((int )elf_header.e_machine == 70) {
#line 1015
      goto case_53;
    }
#line 1019
    if ((int )elf_header.e_machine == 4) {
#line 1019
      goto case_4;
    }
#line 1023
    if ((int )elf_header.e_machine == 19) {
#line 1023
      goto case_19;
    }
#line 1028
    if ((int )elf_header.e_machine == 4183) {
#line 1028
      goto case_4183;
    }
#line 1028
    if ((int )elf_header.e_machine == 83) {
#line 1028
      goto case_4183;
    }
#line 1035
    if ((int )elf_header.e_machine == 2) {
#line 1035
      goto case_2;
    }
#line 1035
    if ((int )elf_header.e_machine == 43) {
#line 1035
      goto case_2;
    }
#line 1035
    if ((int )elf_header.e_machine == 18) {
#line 1035
      goto case_2;
    }
#line 1035
    if ((int )elf_header.e_machine == 11) {
#line 1035
      goto case_2;
    }
#line 1039
    if ((int )elf_header.e_machine == 23) {
#line 1039
      goto case_23;
    }
#line 1044
    if ((int )elf_header.e_machine == 36992) {
#line 1044
      goto case_36992;
    }
#line 1044
    if ((int )elf_header.e_machine == 87) {
#line 1044
      goto case_36992;
    }
#line 1049
    if ((int )elf_header.e_machine == 30288) {
#line 1049
      goto case_30288;
    }
#line 1049
    if ((int )elf_header.e_machine == 85) {
#line 1049
      goto case_30288;
    }
#line 1054
    if ((int )elf_header.e_machine == 30326) {
#line 1054
      goto case_30326;
    }
#line 1054
    if ((int )elf_header.e_machine == 86) {
#line 1054
      goto case_30326;
    }
#line 1058
    if ((int )elf_header.e_machine == 23205) {
#line 1058
      goto case_23205;
    }
#line 1062
    if ((int )elf_header.e_machine == 42) {
#line 1062
      goto case_42;
    }
#line 1067
    if ((int )elf_header.e_machine == 48879) {
#line 1067
      goto case_48879;
    }
#line 1067
    if ((int )elf_header.e_machine == 89) {
#line 1067
      goto case_48879;
    }
#line 1072
    if ((int )elf_header.e_machine == 57005) {
#line 1072
      goto case_57005;
    }
#line 1072
    if ((int )elf_header.e_machine == 90) {
#line 1072
      goto case_57005;
    }
#line 1077
    if ((int )elf_header.e_machine == 13104) {
#line 1077
      goto case_13104;
    }
#line 1077
    if ((int )elf_header.e_machine == 84) {
#line 1077
      goto case_13104;
    }
#line 1081
    if ((int )elf_header.e_machine == 21569) {
#line 1081
      goto case_21569;
    }
#line 1085
    if ((int )elf_header.e_machine == 39) {
#line 1085
      goto case_39;
    }
#line 1089
    if ((int )elf_header.e_machine == 80) {
#line 1089
      goto case_80;
    }
#line 1093
    if ((int )elf_header.e_machine == 65261) {
#line 1093
      goto case_65261;
    }
#line 1098
    if ((int )elf_header.e_machine == 4185) {
#line 1098
      goto case_4185;
    }
#line 1098
    if ((int )elf_header.e_machine == 105) {
#line 1098
      goto case_4185;
    }
#line 1102
    if ((int )elf_header.e_machine == 20) {
#line 1102
      goto case_20;
    }
#line 1106
    if ((int )elf_header.e_machine == 21) {
#line 1106
      goto case_21;
    }
#line 1111
    if ((int )elf_header.e_machine == 10) {
#line 1111
      goto case_10;
    }
#line 1111
    if ((int )elf_header.e_machine == 8) {
#line 1111
      goto case_10;
    }
#line 1115
    if ((int )elf_header.e_machine == 36902) {
#line 1115
      goto case_36902;
    }
#line 1119
    if ((int )elf_header.e_machine == 40) {
#line 1119
      goto case_40;
    }
#line 1123
    if ((int )elf_header.e_machine == 45) {
#line 1123
      goto case_45;
    }
#line 1127
    if ((int )elf_header.e_machine == 15) {
#line 1127
      goto case_15;
    }
#line 1133
    if ((int )elf_header.e_machine == 48) {
#line 1133
      goto case_48;
    }
#line 1133
    if ((int )elf_header.e_machine == 47) {
#line 1133
      goto case_48;
    }
#line 1133
    if ((int )elf_header.e_machine == 46) {
#line 1133
      goto case_48;
    }
#line 1138
    if ((int )elf_header.e_machine == 33906) {
#line 1138
      goto case_33906;
    }
#line 1138
    if ((int )elf_header.e_machine == 92) {
#line 1138
      goto case_33906;
    }
#line 1143
    if ((int )elf_header.e_machine == 99) {
#line 1143
      goto case_99;
    }
#line 1143
    if ((int )elf_header.e_machine == 91) {
#line 1143
      goto case_99;
    }
#line 1146
    if ((int )elf_header.e_machine == 50) {
#line 1146
      goto case_50;
    }
#line 1150
    if ((int )elf_header.e_machine == 76) {
#line 1150
      goto case_76;
    }
#line 1154
    if ((int )elf_header.e_machine == 7) {
#line 1154
      goto case_7;
    }
#line 1160
    if ((int )elf_header.e_machine == 181) {
#line 1160
      goto case_181;
    }
#line 1160
    if ((int )elf_header.e_machine == 180) {
#line 1160
      goto case_181;
    }
#line 1160
    if ((int )elf_header.e_machine == 62) {
#line 1160
      goto case_181;
    }
#line 1164
    if ((int )elf_header.e_machine == 9) {
#line 1164
      goto case_9;
    }
#line 1169
    if ((int )elf_header.e_machine == 22) {
#line 1169
      goto case_22;
    }
#line 1169
    if ((int )elf_header.e_machine == 41872) {
#line 1169
      goto case_22;
    }
#line 1173
    if ((int )elf_header.e_machine == 135) {
#line 1173
      goto case_135;
    }
#line 1177
    if ((int )elf_header.e_machine == 44357) {
#line 1177
      goto case_44357;
    }
#line 1181
    if ((int )elf_header.e_machine == 114) {
#line 1181
      goto case_114;
    }
#line 1185
    if ((int )elf_header.e_machine == 75) {
#line 1185
      goto case_75;
    }
#line 1189
    if ((int )elf_header.e_machine == 4643) {
#line 1189
      goto case_4643;
    }
#line 1194
    if ((int )elf_header.e_machine == 33303) {
#line 1194
      goto case_33303;
    }
#line 1194
    if ((int )elf_header.e_machine == 101) {
#line 1194
      goto case_33303;
    }
#line 1198
    if ((int )elf_header.e_machine == 65210) {
#line 1198
      goto case_65210;
    }
#line 1203
    if ((int )elf_header.e_machine == 94) {
#line 1203
      goto case_94;
    }
#line 1203
    if ((int )elf_header.e_machine == 43975) {
#line 1203
      goto case_94;
    }
#line 1207
    if ((int )elf_header.e_machine == 138) {
#line 1207
      goto case_138;
    }
#line 1212
    if ((int )elf_header.e_machine == 120) {
#line 1212
      goto case_120;
    }
#line 1212
    if ((int )elf_header.e_machine == 65200) {
#line 1212
      goto case_120;
    }
#line 1216
    if ((int )elf_header.e_machine == 9520) {
#line 1216
      goto case_9520;
    }
#line 1220
    if ((int )elf_header.e_machine == 106) {
#line 1220
      goto case_106;
    }
#line 1224
    if ((int )elf_header.e_machine == 61453) {
#line 1224
      goto case_61453;
    }
#line 1228
    if ((int )elf_header.e_machine == 177) {
#line 1228
      goto case_177;
    }
#line 1233
    if ((int )elf_header.e_machine == 47787) {
#line 1233
      goto case_47787;
    }
#line 1233
    if ((int )elf_header.e_machine == 189) {
#line 1233
      goto case_47787;
    }
#line 1237
    if ((int )elf_header.e_machine == 197) {
#line 1237
      goto case_197;
    }
#line 1241
    if ((int )elf_header.e_machine == 173) {
#line 1241
      goto case_173;
    }
#line 1246
    if ((int )elf_header.e_machine == 116) {
#line 1246
      goto case_116;
    }
#line 1246
    if ((int )elf_header.e_machine == 18056) {
#line 1246
      goto case_116;
    }
#line 1250
    if ((int )elf_header.e_machine == 140) {
#line 1250
      goto case_140;
    }
#line 1254
    if ((int )elf_header.e_machine == 191) {
#line 1254
      goto case_191;
    }
#line 1258
    if ((int )elf_header.e_machine == 188) {
#line 1258
      goto case_188;
    }
#line 1262
    if ((int )elf_header.e_machine == 115) {
#line 1262
      goto case_115;
    }
#line 996
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 997
    rtype = (char const   *)((void *)0);
#line 998
    goto switch_break;
    case_183: /* CIL Label */ 
    {
#line 1001
    rtype = elf_aarch64_reloc_type(type);
    }
#line 1002
    goto switch_break;
    case_36929: /* CIL Label */ 
    case_88: /* CIL Label */ 
    {
#line 1006
    rtype = elf_m32r_reloc_type(type);
    }
#line 1007
    goto switch_break;
    case_6: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 1011
    rtype = elf_i386_reloc_type(type);
    }
#line 1012
    goto switch_break;
    case_53: /* CIL Label */ 
    case_70: /* CIL Label */ 
    {
#line 1016
    rtype = elf_m68hc11_reloc_type(type);
    }
#line 1017
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1020
    rtype = elf_m68k_reloc_type(type);
    }
#line 1021
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1024
    rtype = elf_i960_reloc_type(type);
    }
#line 1025
    goto switch_break;
    case_4183: /* CIL Label */ 
    case_83: /* CIL Label */ 
    {
#line 1029
    rtype = elf_avr_reloc_type(type);
    }
#line 1030
    goto switch_break;
    case_2: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_11: /* CIL Label */ 
    {
#line 1036
    rtype = elf_sparc_reloc_type(type);
    }
#line 1037
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 1040
    rtype = elf_spu_reloc_type(type);
    }
#line 1041
    goto switch_break;
    case_36992: /* CIL Label */ 
    case_87: /* CIL Label */ 
    {
#line 1045
    rtype = v850_reloc_type(type);
    }
#line 1046
    goto switch_break;
    case_30288: /* CIL Label */ 
    case_85: /* CIL Label */ 
    {
#line 1050
    rtype = elf_d10v_reloc_type(type);
    }
#line 1051
    goto switch_break;
    case_30326: /* CIL Label */ 
    case_86: /* CIL Label */ 
    {
#line 1055
    rtype = elf_d30v_reloc_type(type);
    }
#line 1056
    goto switch_break;
    case_23205: /* CIL Label */ 
    {
#line 1059
    rtype = elf_dlx_reloc_type(type);
    }
#line 1060
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 1063
    rtype = elf_sh_reloc_type(type);
    }
#line 1064
    goto switch_break;
    case_48879: /* CIL Label */ 
    case_89: /* CIL Label */ 
    {
#line 1068
    rtype = elf_mn10300_reloc_type(type);
    }
#line 1069
    goto switch_break;
    case_57005: /* CIL Label */ 
    case_90: /* CIL Label */ 
    {
#line 1073
    rtype = elf_mn10200_reloc_type(type);
    }
#line 1074
    goto switch_break;
    case_13104: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 1078
    rtype = elf_fr30_reloc_type(type);
    }
#line 1079
    goto switch_break;
    case_21569: /* CIL Label */ 
    {
#line 1082
    rtype = elf_frv_reloc_type(type);
    }
#line 1083
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 1086
    rtype = elf_mcore_reloc_type(type);
    }
#line 1087
    goto switch_break;
    case_80: /* CIL Label */ 
    {
#line 1090
    rtype = elf_mmix_reloc_type(type);
    }
#line 1091
    goto switch_break;
    case_65261: /* CIL Label */ 
    {
#line 1094
    rtype = elf_moxie_reloc_type(type);
    }
#line 1095
    goto switch_break;
    case_4185: /* CIL Label */ 
    case_105: /* CIL Label */ 
    {
#line 1099
    rtype = elf_msp430_reloc_type(type);
    }
#line 1100
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 1103
    rtype = elf_ppc_reloc_type(type);
    }
#line 1104
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 1107
    rtype = elf_ppc64_reloc_type(type);
    }
#line 1108
    goto switch_break;
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    {
#line 1112
    rtype = elf_mips_reloc_type(type);
    }
#line 1113
    goto switch_break;
    case_36902: /* CIL Label */ 
    {
#line 1116
    rtype = elf_alpha_reloc_type(type);
    }
#line 1117
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 1120
    rtype = elf_arm_reloc_type(type);
    }
#line 1121
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 1124
    rtype = elf_arc_reloc_type(type);
    }
#line 1125
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1128
    rtype = elf_hppa_reloc_type(type);
    }
#line 1129
    goto switch_break;
    case_48: /* CIL Label */ 
    case_47: /* CIL Label */ 
    case_46: /* CIL Label */ 
    {
#line 1134
    rtype = elf_h8_reloc_type(type);
    }
#line 1135
    goto switch_break;
    case_33906: /* CIL Label */ 
    case_92: /* CIL Label */ 
    {
#line 1139
    rtype = elf_or32_reloc_type(type);
    }
#line 1140
    goto switch_break;
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
    {
#line 1144
    rtype = elf_pj_reloc_type(type);
    }
#line 1145
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 1147
    rtype = elf_ia64_reloc_type(type);
    }
#line 1148
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 1151
    rtype = elf_cris_reloc_type(type);
    }
#line 1152
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1155
    rtype = elf_i860_reloc_type(type);
    }
#line 1156
    goto switch_break;
    case_181: /* CIL Label */ 
    case_180: /* CIL Label */ 
    case_62: /* CIL Label */ 
    {
#line 1161
    rtype = elf_x86_64_reloc_type(type);
    }
#line 1162
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 1165
    rtype = i370_reloc_type(type);
    }
#line 1166
    goto switch_break;
    case_22: /* CIL Label */ 
    case_41872: /* CIL Label */ 
    {
#line 1170
    rtype = elf_s390_reloc_type(type);
    }
#line 1171
    goto switch_break;
    case_135: /* CIL Label */ 
    {
#line 1174
    rtype = elf_score_reloc_type(type);
    }
#line 1175
    goto switch_break;
    case_44357: /* CIL Label */ 
    {
#line 1178
    rtype = elf_xstormy16_reloc_type(type);
    }
#line 1179
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 1182
    rtype = elf_crx_reloc_type(type);
    }
#line 1183
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 1186
    rtype = elf_vax_reloc_type(type);
    }
#line 1187
    goto switch_break;
    case_4643: /* CIL Label */ 
    {
#line 1190
    rtype = elf_epiphany_reloc_type(type);
    }
#line 1191
    goto switch_break;
    case_33303: /* CIL Label */ 
    case_101: /* CIL Label */ 
    {
#line 1195
    rtype = elf_ip2k_reloc_type(type);
    }
#line 1196
    goto switch_break;
    case_65210: /* CIL Label */ 
    {
#line 1199
    rtype = elf_iq2000_reloc_type(type);
    }
#line 1200
    goto switch_break;
    case_94: /* CIL Label */ 
    case_43975: /* CIL Label */ 
    {
#line 1204
    rtype = elf_xtensa_reloc_type(type);
    }
#line 1205
    goto switch_break;
    case_138: /* CIL Label */ 
    {
#line 1208
    rtype = elf_lm32_reloc_type(type);
    }
#line 1209
    goto switch_break;
    case_120: /* CIL Label */ 
    case_65200: /* CIL Label */ 
    {
#line 1213
    rtype = elf_m32c_reloc_type(type);
    }
#line 1214
    goto switch_break;
    case_9520: /* CIL Label */ 
    {
#line 1217
    rtype = elf_mt_reloc_type(type);
    }
#line 1218
    goto switch_break;
    case_106: /* CIL Label */ 
    {
#line 1221
    rtype = elf_bfin_reloc_type(type);
    }
#line 1222
    goto switch_break;
    case_61453: /* CIL Label */ 
    {
#line 1225
    rtype = elf_mep_reloc_type(type);
    }
#line 1226
    goto switch_break;
    case_177: /* CIL Label */ 
    {
#line 1229
    rtype = elf_cr16_reloc_type(type);
    }
#line 1230
    goto switch_break;
    case_47787: /* CIL Label */ 
    case_189: /* CIL Label */ 
    {
#line 1234
    rtype = elf_microblaze_reloc_type(type);
    }
#line 1235
    goto switch_break;
    case_197: /* CIL Label */ 
    {
#line 1238
    rtype = elf_rl78_reloc_type(type);
    }
#line 1239
    goto switch_break;
    case_173: /* CIL Label */ 
    {
#line 1242
    rtype = elf_rx_reloc_type(type);
    }
#line 1243
    goto switch_break;
    case_116: /* CIL Label */ 
    case_18056: /* CIL Label */ 
    {
#line 1247
    rtype = elf_xc16x_reloc_type(type);
    }
#line 1248
    goto switch_break;
    case_140: /* CIL Label */ 
    {
#line 1251
    rtype = elf_tic6x_reloc_type(type);
    }
#line 1252
    goto switch_break;
    case_191: /* CIL Label */ 
    {
#line 1255
    rtype = elf_tilegx_reloc_type(type);
    }
#line 1256
    goto switch_break;
    case_188: /* CIL Label */ 
    {
#line 1259
    rtype = elf_tilepro_reloc_type(type);
    }
#line 1260
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 1263
    rtype = elf_xgate_reloc_type(type);
    }
#line 1264
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1267
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
      {
#line 1268
      tmp___12 = gettext("unrecognized: %-7lx");
#line 1268
      printf((char const   */* __restrict  */)tmp___12, type & 4294967295UL);
      }
    } else {
#line 1270
      if (do_wide) {
#line 1270
        tmp___13 = "%-22.22s";
      } else {
#line 1270
        tmp___13 = "%-17.17s";
      }
      {
#line 1270
      printf((char const   */* __restrict  */)tmp___13, rtype);
      }
    }
#line 1272
    if ((int )elf_header.e_machine == 36902) {
#line 1272
      if ((unsigned long )rtype != (unsigned long )((void *)0)) {
        {
#line 1272
        tmp___28 = strcmp(rtype, "R_ALPHA_LITUSE");
        }
#line 1272
        if (tmp___28 == 0) {
#line 1272
          if (is_rela) {
            {
#line 1279
            if ((rels + i)->r_addend == 0UL) {
#line 1279
              goto case_0;
            }
#line 1280
            if ((rels + i)->r_addend == 1UL) {
#line 1280
              goto case_1;
            }
#line 1281
            if ((rels + i)->r_addend == 2UL) {
#line 1281
              goto case_2___0;
            }
#line 1282
            if ((rels + i)->r_addend == 3UL) {
#line 1282
              goto case_3___0;
            }
#line 1283
            if ((rels + i)->r_addend == 4UL) {
#line 1283
              goto case_4___0;
            }
#line 1284
            if ((rels + i)->r_addend == 5UL) {
#line 1284
              goto case_5;
            }
#line 1285
            if ((rels + i)->r_addend == 6UL) {
#line 1285
              goto case_6___0;
            }
#line 1286
            goto switch_default___0;
            case_0: /* CIL Label */ 
#line 1279
            rtype = "ADDR";
#line 1279
            goto switch_break___0;
            case_1: /* CIL Label */ 
#line 1280
            rtype = "BASE";
#line 1280
            goto switch_break___0;
            case_2___0: /* CIL Label */ 
#line 1281
            rtype = "BYTOFF";
#line 1281
            goto switch_break___0;
            case_3___0: /* CIL Label */ 
#line 1282
            rtype = "JSR";
#line 1282
            goto switch_break___0;
            case_4___0: /* CIL Label */ 
#line 1283
            rtype = "TLSGD";
#line 1283
            goto switch_break___0;
            case_5: /* CIL Label */ 
#line 1284
            rtype = "TLSLDM";
#line 1284
            goto switch_break___0;
            case_6___0: /* CIL Label */ 
#line 1285
            rtype = "JSRDIRECT";
#line 1285
            goto switch_break___0;
            switch_default___0: /* CIL Label */ 
#line 1286
            rtype = (char const   *)((void *)0);
            switch_break___0: /* CIL Label */ ;
            }
#line 1288
            if (rtype) {
              {
#line 1289
              printf((char const   */* __restrict  */)" (%s)", rtype);
              }
            } else {
              {
#line 1292
              putchar(' ');
#line 1293
              tmp___14 = gettext("<unknown addend: %lx>");
#line 1293
              printf((char const   */* __restrict  */)tmp___14, (rels + i)->r_addend);
              }
            }
          } else {
#line 1272
            goto _L___8;
          }
        } else {
#line 1272
          goto _L___8;
        }
      } else {
#line 1272
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 1297
    if (symtab_index) {
#line 1299
      if ((unsigned long )symtab == (unsigned long )((void *)0)) {
        {
#line 1300
        tmp___15 = gettext(" bad symbol index: %08lx");
#line 1300
        printf((char const   */* __restrict  */)tmp___15, symtab_index);
        }
      } else
#line 1299
      if (symtab_index >= nsyms) {
        {
#line 1300
        tmp___15 = gettext(" bad symbol index: %08lx");
#line 1300
        printf((char const   */* __restrict  */)tmp___15, symtab_index);
        }
      } else {
        {
#line 1305
        psym = symtab + symtab_index;
#line 1307
        printf((char const   */* __restrict  */)" ");
        }
#line 1309
        if (((int )psym->st_info & 15) == 10) {
#line 1313
          if (is_32bit_elf) {
#line 1313
            tmp___16 = 8;
          } else {
#line 1313
            tmp___16 = 14;
          }
#line 1313
          width = (unsigned int )tmp___16;
#line 1325
          if ((unsigned long )strtab == (unsigned long )((void *)0)) {
#line 1328
            name___0 = "??";
          } else
#line 1325
          if (psym->st_name == 0UL) {
#line 1328
            name___0 = "??";
          } else
#line 1325
          if (psym->st_name >= strtablen) {
#line 1328
            name___0 = "??";
          } else {
#line 1330
            name___0 = (char const   *)(strtab + psym->st_name);
          }
          {
#line 1332
          len = print_symbol((int )width, name___0);
          }
#line 1333
          if (len <= width) {
#line 1333
            tmp___17 = (width + 1U) - len;
          } else {
#line 1333
            tmp___17 = 1U;
          }
          {
#line 1333
          printf((char const   */* __restrict  */)"()%-*s", tmp___17, " ");
          }
        } else {
          {
#line 1337
          print_vma(psym->st_value, (print_mode )6);
          }
#line 1339
          if (is_32bit_elf) {
#line 1339
            tmp___18 = "   ";
          } else {
#line 1339
            tmp___18 = " ";
          }
          {
#line 1339
          printf((char const   */* __restrict  */)tmp___18);
          }
        }
#line 1342
        if (psym->st_name == 0UL) {
#line 1344
          sec_name = "<null>";
#line 1347
          if (((int )psym->st_info & 15) == 3) {
#line 1349
            if (psym->st_shndx < elf_header.e_shnum) {
#line 1350
              if ((unsigned long )(section_headers + psym->st_shndx) == (unsigned long )((void *)0)) {
                {
#line 1350
                tmp___19 = gettext("<none>");
#line 1350
                sec_name = (char const   *)tmp___19;
                }
              } else {
#line 1350
                if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                  {
#line 1350
                  tmp___20 = gettext("<no-name>");
#line 1350
                  tmp___23 = tmp___20;
                  }
                } else {
#line 1350
                  if ((unsigned long )(section_headers + psym->st_shndx)->sh_name >= string_table_length) {
                    {
#line 1350
                    tmp___21 = gettext("<corrupt>");
#line 1350
                    tmp___22 = tmp___21;
                    }
                  } else {
#line 1350
                    tmp___22 = string_table + (section_headers + psym->st_shndx)->sh_name;
                  }
#line 1350
                  tmp___23 = tmp___22;
                }
#line 1350
                sec_name = (char const   *)tmp___23;
              }
            } else
#line 1352
            if (psym->st_shndx == 4294967281U) {
#line 1353
              sec_name = "ABS";
            } else
#line 1354
            if (psym->st_shndx == 4294967282U) {
#line 1355
              sec_name = "COMMON";
            } else
#line 1356
            if ((int )elf_header.e_machine == 8) {
#line 1356
              if (psym->st_shndx == 4294967043U) {
#line 1360
                sec_name = "SCOMMON";
              } else {
#line 1356
                goto _L___5;
              }
            } else
            _L___5: /* CIL Label */ 
#line 1356
            if ((int )elf_header.e_machine == 140) {
#line 1356
              if (psym->st_shndx == 4294967040U) {
#line 1360
                sec_name = "SCOMMON";
              } else {
#line 1356
                goto _L___4;
              }
            } else
            _L___4: /* CIL Label */ 
#line 1361
            if ((int )elf_header.e_machine == 8) {
#line 1361
              if (psym->st_shndx == 4294967044U) {
#line 1363
                sec_name = "SUNDEF";
              } else {
#line 1361
                goto _L___3;
              }
            } else
            _L___3: /* CIL Label */ 
#line 1364
            if ((int )elf_header.e_machine == 62) {
#line 1364
              goto _L___2;
            } else
#line 1364
            if ((int )elf_header.e_machine == 180) {
#line 1364
              goto _L___2;
            } else
#line 1364
            if ((int )elf_header.e_machine == 181) {
              _L___2: /* CIL Label */ 
#line 1364
              if (psym->st_shndx == 4294967042U) {
#line 1368
                sec_name = "LARGE_COMMON";
              } else {
#line 1364
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 1369
            if ((int )elf_header.e_machine == 50) {
#line 1369
              if ((int )elf_header.e_ident[7] == 1) {
#line 1369
                if (psym->st_shndx == 4294967040U) {
#line 1372
                  sec_name = "ANSI_COM";
                } else {
#line 1369
                  goto _L___0;
                }
              } else {
#line 1369
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              {
#line 1373
              tmp___24 = is_ia64_vms();
              }
#line 1373
              if (tmp___24) {
#line 1373
                if (psym->st_shndx == 4294967072U) {
#line 1375
                  sec_name = "VMS_SYMVEC";
                } else {
                  {
#line 1378
                  sprintf((char */* __restrict  */)(name_buf), (char const   */* __restrict  */)"<section 0x%x>",
                          psym->st_shndx);
#line 1380
                  sec_name = (char const   *)(name_buf);
                  }
                }
              } else {
                {
#line 1378
                sprintf((char */* __restrict  */)(name_buf), (char const   */* __restrict  */)"<section 0x%x>",
                        psym->st_shndx);
#line 1380
                sec_name = (char const   *)(name_buf);
                }
              }
            }
          }
          {
#line 1383
          print_symbol(22, sec_name);
          }
        } else
#line 1385
        if ((unsigned long )strtab == (unsigned long )((void *)0)) {
          {
#line 1386
          tmp___25 = gettext("<string table index: %3ld>");
#line 1386
          printf((char const   */* __restrict  */)tmp___25, psym->st_name);
          }
        } else
#line 1387
        if (psym->st_name >= strtablen) {
          {
#line 1388
          tmp___26 = gettext("<corrupt string table index: %3ld>");
#line 1388
          printf((char const   */* __restrict  */)tmp___26, psym->st_name);
          }
        } else {
          {
#line 1390
          print_symbol(22, (char const   *)(strtab + psym->st_name));
          }
        }
#line 1392
        if (is_rela) {
#line 1394
          off = (bfd_signed_vma )(rels + i)->r_addend;
#line 1396
          if (off < 0L) {
            {
#line 1397
            printf((char const   */* __restrict  */)" - %lx", - off);
            }
          } else {
            {
#line 1399
            printf((char const   */* __restrict  */)" + %lx", off);
            }
          }
        }
      }
    } else
#line 1403
    if (is_rela) {
#line 1405
      off___0 = (bfd_signed_vma )(rels + i)->r_addend;
#line 1407
      if (is_32bit_elf) {
#line 1407
        tmp___27 = 12;
      } else {
#line 1407
        tmp___27 = 20;
      }
      {
#line 1407
      printf((char const   */* __restrict  */)"%*c", tmp___27, ' ');
      }
#line 1408
      if (off___0 < 0L) {
        {
#line 1409
        printf((char const   */* __restrict  */)"-%lx", - off___0);
        }
      } else {
        {
#line 1411
        printf((char const   */* __restrict  */)"%lx", off___0);
        }
      }
    }
#line 1414
    if ((int )elf_header.e_machine == 43) {
#line 1414
      if ((unsigned long )rtype != (unsigned long )((void *)0)) {
        {
#line 1414
        tmp___29 = strcmp(rtype, "R_SPARC_OLO10");
        }
#line 1414
        if (tmp___29 == 0) {
          {
#line 1417
          printf((char const   */* __restrict  */)" + %lx", (unsigned long )(((bfd_signed_vma )((inf & 4294967295UL) >> 8) ^ 8388608L) - 8388608L));
          }
        }
      }
    }
    {
#line 1419
    putchar('\n');
    }
#line 1422
    if (! is_32bit_elf) {
#line 1422
      if ((int )elf_header.e_machine == 8) {
        {
#line 1424
        type2 = (inf >> 8) & 255UL;
#line 1425
        type3 = (inf >> 16) & 255UL;
#line 1426
        tmp___30 = elf_mips_reloc_type(type2);
#line 1426
        rtype2 = tmp___30;
#line 1427
        tmp___31 = elf_mips_reloc_type(type3);
#line 1427
        rtype3 = tmp___31;
#line 1429
        printf((char const   */* __restrict  */)"                    Type2: ");
        }
#line 1431
        if ((unsigned long )rtype2 == (unsigned long )((void *)0)) {
          {
#line 1432
          tmp___32 = gettext("unrecognized: %-7lx");
#line 1432
          printf((char const   */* __restrict  */)tmp___32, type2 & 4294967295UL);
          }
        } else {
          {
#line 1435
          printf((char const   */* __restrict  */)"%-17.17s", rtype2);
          }
        }
        {
#line 1437
        printf((char const   */* __restrict  */)"\n                    Type3: ");
        }
#line 1439
        if ((unsigned long )rtype3 == (unsigned long )((void *)0)) {
          {
#line 1440
          tmp___33 = gettext("unrecognized: %-7lx");
#line 1440
          printf((char const   */* __restrict  */)tmp___33, type3 & 4294967295UL);
          }
        } else {
          {
#line 1443
          printf((char const   */* __restrict  */)"%-17.17s", rtype3);
          }
        }
        {
#line 1445
        putchar('\n');
        }
      }
    }
#line 944
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1450
  free((void *)rels);
  }
#line 1451
  return;
}
}
#line 1453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_mips_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1458
  if (type == 1879048193UL) {
#line 1458
    goto case_1879048193;
  }
#line 1459
  if (type == 1879048194UL) {
#line 1459
    goto case_1879048194;
  }
#line 1460
  if (type == 1879048195UL) {
#line 1460
    goto case_1879048195;
  }
#line 1461
  if (type == 1879048196UL) {
#line 1461
    goto case_1879048196;
  }
#line 1462
  if (type == 1879048197UL) {
#line 1462
    goto case_1879048197;
  }
#line 1463
  if (type == 1879048198UL) {
#line 1463
    goto case_1879048198;
  }
#line 1464
  if (type == 1879048199UL) {
#line 1464
    goto case_1879048199;
  }
#line 1465
  if (type == 1879048200UL) {
#line 1465
    goto case_1879048200;
  }
#line 1466
  if (type == 1879048201UL) {
#line 1466
    goto case_1879048201;
  }
#line 1467
  if (type == 1879048202UL) {
#line 1467
    goto case_1879048202;
  }
#line 1468
  if (type == 1879048203UL) {
#line 1468
    goto case_1879048203;
  }
#line 1469
  if (type == 1879048208UL) {
#line 1469
    goto case_1879048208;
  }
#line 1470
  if (type == 1879048209UL) {
#line 1470
    goto case_1879048209;
  }
#line 1471
  if (type == 1879048210UL) {
#line 1471
    goto case_1879048210;
  }
#line 1472
  if (type == 1879048211UL) {
#line 1472
    goto case_1879048211;
  }
#line 1473
  if (type == 1879048212UL) {
#line 1473
    goto case_1879048212;
  }
#line 1474
  if (type == 1879048214UL) {
#line 1474
    goto case_1879048214;
  }
#line 1475
  if (type == 1879048215UL) {
#line 1475
    goto case_1879048215;
  }
#line 1476
  if (type == 1879048216UL) {
#line 1476
    goto case_1879048216;
  }
#line 1477
  if (type == 1879048217UL) {
#line 1477
    goto case_1879048217;
  }
#line 1478
  if (type == 1879048218UL) {
#line 1478
    goto case_1879048218;
  }
#line 1479
  if (type == 1879048219UL) {
#line 1479
    goto case_1879048219;
  }
#line 1480
  if (type == 1879048220UL) {
#line 1480
    goto case_1879048220;
  }
#line 1481
  if (type == 1879048221UL) {
#line 1481
    goto case_1879048221;
  }
#line 1482
  if (type == 1879048222UL) {
#line 1482
    goto case_1879048222;
  }
#line 1483
  if (type == 1879048224UL) {
#line 1483
    goto case_1879048224;
  }
#line 1484
  if (type == 1879048225UL) {
#line 1484
    goto case_1879048225;
  }
#line 1485
  if (type == 1879048226UL) {
#line 1485
    goto case_1879048226;
  }
#line 1486
  if (type == 1879048227UL) {
#line 1486
    goto case_1879048227;
  }
#line 1487
  if (type == 1879048228UL) {
#line 1487
    goto case_1879048228;
  }
#line 1488
  if (type == 1879048229UL) {
#line 1488
    goto case_1879048229;
  }
#line 1489
  if (type == 1879048230UL) {
#line 1489
    goto case_1879048230;
  }
#line 1490
  if (type == 1879048231UL) {
#line 1490
    goto case_1879048231;
  }
#line 1491
  if (type == 1879048232UL) {
#line 1491
    goto case_1879048232;
  }
#line 1492
  if (type == 1879048233UL) {
#line 1492
    goto case_1879048233;
  }
#line 1493
  if (type == 1879048234UL) {
#line 1493
    goto case_1879048234;
  }
#line 1494
  if (type == 1879048235UL) {
#line 1494
    goto case_1879048235;
  }
#line 1495
  if (type == 1879048236UL) {
#line 1495
    goto case_1879048236;
  }
#line 1496
  if (type == 1879048237UL) {
#line 1496
    goto case_1879048237;
  }
#line 1497
  if (type == 1879048238UL) {
#line 1497
    goto case_1879048238;
  }
#line 1498
  if (type == 1879048239UL) {
#line 1498
    goto case_1879048239;
  }
#line 1499
  if (type == 1879048240UL) {
#line 1499
    goto case_1879048240;
  }
#line 1500
  if (type == 1879048241UL) {
#line 1500
    goto case_1879048241;
  }
#line 1501
  if (type == 1879048242UL) {
#line 1501
    goto case_1879048242;
  }
#line 1502
  if (type == 1879048244UL) {
#line 1502
    goto case_1879048244;
  }
#line 1503
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 1458
  return ("MIPS_RLD_VERSION");
  case_1879048194: /* CIL Label */ 
#line 1459
  return ("MIPS_TIME_STAMP");
  case_1879048195: /* CIL Label */ 
#line 1460
  return ("MIPS_ICHECKSUM");
  case_1879048196: /* CIL Label */ 
#line 1461
  return ("MIPS_IVERSION");
  case_1879048197: /* CIL Label */ 
#line 1462
  return ("MIPS_FLAGS");
  case_1879048198: /* CIL Label */ 
#line 1463
  return ("MIPS_BASE_ADDRESS");
  case_1879048199: /* CIL Label */ 
#line 1464
  return ("MIPS_MSYM");
  case_1879048200: /* CIL Label */ 
#line 1465
  return ("MIPS_CONFLICT");
  case_1879048201: /* CIL Label */ 
#line 1466
  return ("MIPS_LIBLIST");
  case_1879048202: /* CIL Label */ 
#line 1467
  return ("MIPS_LOCAL_GOTNO");
  case_1879048203: /* CIL Label */ 
#line 1468
  return ("MIPS_CONFLICTNO");
  case_1879048208: /* CIL Label */ 
#line 1469
  return ("MIPS_LIBLISTNO");
  case_1879048209: /* CIL Label */ 
#line 1470
  return ("MIPS_SYMTABNO");
  case_1879048210: /* CIL Label */ 
#line 1471
  return ("MIPS_UNREFEXTNO");
  case_1879048211: /* CIL Label */ 
#line 1472
  return ("MIPS_GOTSYM");
  case_1879048212: /* CIL Label */ 
#line 1473
  return ("MIPS_HIPAGENO");
  case_1879048214: /* CIL Label */ 
#line 1474
  return ("MIPS_RLD_MAP");
  case_1879048215: /* CIL Label */ 
#line 1475
  return ("MIPS_DELTA_CLASS");
  case_1879048216: /* CIL Label */ 
#line 1476
  return ("MIPS_DELTA_CLASS_NO");
  case_1879048217: /* CIL Label */ 
#line 1477
  return ("MIPS_DELTA_INSTANCE");
  case_1879048218: /* CIL Label */ 
#line 1478
  return ("MIPS_DELTA_INSTANCE_NO");
  case_1879048219: /* CIL Label */ 
#line 1479
  return ("MIPS_DELTA_RELOC");
  case_1879048220: /* CIL Label */ 
#line 1480
  return ("MIPS_DELTA_RELOC_NO");
  case_1879048221: /* CIL Label */ 
#line 1481
  return ("MIPS_DELTA_SYM");
  case_1879048222: /* CIL Label */ 
#line 1482
  return ("MIPS_DELTA_SYM_NO");
  case_1879048224: /* CIL Label */ 
#line 1483
  return ("MIPS_DELTA_CLASSSYM");
  case_1879048225: /* CIL Label */ 
#line 1484
  return ("MIPS_DELTA_CLASSSYM_NO");
  case_1879048226: /* CIL Label */ 
#line 1485
  return ("MIPS_CXX_FLAGS");
  case_1879048227: /* CIL Label */ 
#line 1486
  return ("MIPS_PIXIE_INIT");
  case_1879048228: /* CIL Label */ 
#line 1487
  return ("MIPS_SYMBOL_LIB");
  case_1879048229: /* CIL Label */ 
#line 1488
  return ("MIPS_LOCALPAGE_GOTIDX");
  case_1879048230: /* CIL Label */ 
#line 1489
  return ("MIPS_LOCAL_GOTIDX");
  case_1879048231: /* CIL Label */ 
#line 1490
  return ("MIPS_HIDDEN_GOTIDX");
  case_1879048232: /* CIL Label */ 
#line 1491
  return ("MIPS_PROTECTED_GOTIDX");
  case_1879048233: /* CIL Label */ 
#line 1492
  return ("MIPS_OPTIONS");
  case_1879048234: /* CIL Label */ 
#line 1493
  return ("MIPS_INTERFACE");
  case_1879048235: /* CIL Label */ 
#line 1494
  return ("MIPS_DYNSTR_ALIGN");
  case_1879048236: /* CIL Label */ 
#line 1495
  return ("MIPS_INTERFACE_SIZE");
  case_1879048237: /* CIL Label */ 
#line 1496
  return ("MIPS_RLD_TEXT_RESOLVE_ADDR");
  case_1879048238: /* CIL Label */ 
#line 1497
  return ("MIPS_PERF_SUFFIX");
  case_1879048239: /* CIL Label */ 
#line 1498
  return ("MIPS_COMPACT_SIZE");
  case_1879048240: /* CIL Label */ 
#line 1499
  return ("MIPS_GP_VALUE");
  case_1879048241: /* CIL Label */ 
#line 1500
  return ("MIPS_AUX_DYNAMIC");
  case_1879048242: /* CIL Label */ 
#line 1501
  return ("MIPS_PLTGOT");
  case_1879048244: /* CIL Label */ 
#line 1502
  return ("MIPS_RWPLT");
  switch_default: /* CIL Label */ 
#line 1504
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1508 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_sparc64_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1513
  if (type == 1879048193UL) {
#line 1513
    goto case_1879048193;
  }
#line 1514
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 1513
  return ("SPARC_REGISTER");
  switch_default: /* CIL Label */ 
#line 1515
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1519 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ppc_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1524
  if (type == 1879048192UL) {
#line 1524
    goto case_1879048192;
  }
#line 1525
  if (type == 1879048193UL) {
#line 1525
    goto case_1879048193;
  }
#line 1526
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1524
  return ("PPC_GOT");
  case_1879048193: /* CIL Label */ 
#line 1525
  return ("PPC_TLSOPT");
  switch_default: /* CIL Label */ 
#line 1527
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1531 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ppc64_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1536
  if (type == 1879048192UL) {
#line 1536
    goto case_1879048192;
  }
#line 1537
  if (type == 1879048193UL) {
#line 1537
    goto case_1879048193;
  }
#line 1538
  if (type == 1879048194UL) {
#line 1538
    goto case_1879048194;
  }
#line 1539
  if (type == 1879048195UL) {
#line 1539
    goto case_1879048195;
  }
#line 1540
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1536
  return ("PPC64_GLINK");
  case_1879048193: /* CIL Label */ 
#line 1537
  return ("PPC64_OPD");
  case_1879048194: /* CIL Label */ 
#line 1538
  return ("PPC64_OPDSZ");
  case_1879048195: /* CIL Label */ 
#line 1539
  return ("PPC64_TLSOPT");
  switch_default: /* CIL Label */ 
#line 1541
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1545 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_parisc_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1550
  if (type == 1610612736UL) {
#line 1550
    goto case_1610612736;
  }
#line 1551
  if (type == 1610612737UL) {
#line 1551
    goto case_1610612737;
  }
#line 1552
  if (type == 1610612738UL) {
#line 1552
    goto case_1610612738;
  }
#line 1553
  if (type == 1610612739UL) {
#line 1553
    goto case_1610612739;
  }
#line 1554
  if (type == 1610612740UL) {
#line 1554
    goto case_1610612740;
  }
#line 1555
  if (type == 1610612741UL) {
#line 1555
    goto case_1610612741;
  }
#line 1556
  if (type == 1610612742UL) {
#line 1556
    goto case_1610612742;
  }
#line 1557
  if (type == 1610612743UL) {
#line 1557
    goto case_1610612743;
  }
#line 1558
  if (type == 1610612744UL) {
#line 1558
    goto case_1610612744;
  }
#line 1559
  if (type == 1610612745UL) {
#line 1559
    goto case_1610612745;
  }
#line 1560
  if (type == 1610612746UL) {
#line 1560
    goto case_1610612746;
  }
#line 1561
  if (type == 1610612747UL) {
#line 1561
    goto case_1610612747;
  }
#line 1562
  if (type == 1610612748UL) {
#line 1562
    goto case_1610612748;
  }
#line 1563
  if (type == 1610612749UL) {
#line 1563
    goto case_1610612749;
  }
#line 1564
  if (type == 1610612750UL) {
#line 1564
    goto case_1610612750;
  }
#line 1565
  if (type == 1610612751UL) {
#line 1565
    goto case_1610612751;
  }
#line 1566
  if (type == 1610612752UL) {
#line 1566
    goto case_1610612752;
  }
#line 1567
  if (type == 1610612753UL) {
#line 1567
    goto case_1610612753;
  }
#line 1568
  if (type == 1610612754UL) {
#line 1568
    goto case_1610612754;
  }
#line 1569
  if (type == 1610612755UL) {
#line 1569
    goto case_1610612755;
  }
#line 1570
  if (type == 1610612756UL) {
#line 1570
    goto case_1610612756;
  }
#line 1571
  if (type == 1610612757UL) {
#line 1571
    goto case_1610612757;
  }
#line 1572
  if (type == 1610612758UL) {
#line 1572
    goto case_1610612758;
  }
#line 1573
  if (type == 1610612759UL) {
#line 1573
    goto case_1610612759;
  }
#line 1574
  goto switch_default;
  case_1610612736: /* CIL Label */ 
#line 1550
  return ("HP_LOAD_MAP");
  case_1610612737: /* CIL Label */ 
#line 1551
  return ("HP_DLD_FLAGS");
  case_1610612738: /* CIL Label */ 
#line 1552
  return ("HP_DLD_HOOK");
  case_1610612739: /* CIL Label */ 
#line 1553
  return ("HP_UX10_INIT");
  case_1610612740: /* CIL Label */ 
#line 1554
  return ("HP_UX10_INITSZ");
  case_1610612741: /* CIL Label */ 
#line 1555
  return ("HP_PREINIT");
  case_1610612742: /* CIL Label */ 
#line 1556
  return ("HP_PREINITSZ");
  case_1610612743: /* CIL Label */ 
#line 1557
  return ("HP_NEEDED");
  case_1610612744: /* CIL Label */ 
#line 1558
  return ("HP_TIME_STAMP");
  case_1610612745: /* CIL Label */ 
#line 1559
  return ("HP_CHECKSUM");
  case_1610612746: /* CIL Label */ 
#line 1560
  return ("HP_GST_SIZE");
  case_1610612747: /* CIL Label */ 
#line 1561
  return ("HP_GST_VERSION");
  case_1610612748: /* CIL Label */ 
#line 1562
  return ("HP_GST_HASHVAL");
  case_1610612749: /* CIL Label */ 
#line 1563
  return ("HP_GST_EPLTREL");
  case_1610612750: /* CIL Label */ 
#line 1564
  return ("HP_GST_EPLTRELSZ");
  case_1610612751: /* CIL Label */ 
#line 1565
  return ("HP_FILTERED");
  case_1610612752: /* CIL Label */ 
#line 1566
  return ("HP_FILTER_TLS");
  case_1610612753: /* CIL Label */ 
#line 1567
  return ("HP_COMPAT_FILTERED");
  case_1610612754: /* CIL Label */ 
#line 1568
  return ("HP_LAZYLOAD");
  case_1610612755: /* CIL Label */ 
#line 1569
  return ("HP_BIND_NOW_COUNT");
  case_1610612756: /* CIL Label */ 
#line 1570
  return ("PLT");
  case_1610612757: /* CIL Label */ 
#line 1571
  return ("PLT_SIZE");
  case_1610612758: /* CIL Label */ 
#line 1572
  return ("DLT");
  case_1610612759: /* CIL Label */ 
#line 1573
  return ("DLT_SIZE");
  switch_default: /* CIL Label */ 
#line 1575
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1579 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ia64_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1584
  if (type == 1879048192UL) {
#line 1584
    goto case_1879048192;
  }
#line 1585
  if (type == 1610612749UL) {
#line 1585
    goto case_1610612749;
  }
#line 1586
  if (type == 1610612751UL) {
#line 1586
    goto case_1610612751;
  }
#line 1587
  if (type == 1610612757UL) {
#line 1587
    goto case_1610612757;
  }
#line 1588
  if (type == 1610612759UL) {
#line 1588
    goto case_1610612759;
  }
#line 1589
  if (type == 1610612761UL) {
#line 1589
    goto case_1610612761;
  }
#line 1590
  if (type == 1610612765UL) {
#line 1590
    goto case_1610612765;
  }
#line 1591
  if (type == 1610612767UL) {
#line 1591
    goto case_1610612767;
  }
#line 1592
  if (type == 1610612769UL) {
#line 1592
    goto case_1610612769;
  }
#line 1593
  if (type == 1610612771UL) {
#line 1593
    goto case_1610612771;
  }
#line 1594
  if (type == 1610612773UL) {
#line 1594
    goto case_1610612773;
  }
#line 1595
  if (type == 1610612775UL) {
#line 1595
    goto case_1610612775;
  }
#line 1596
  if (type == 1610612779UL) {
#line 1596
    goto case_1610612779;
  }
#line 1597
  if (type == 1610612781UL) {
#line 1597
    goto case_1610612781;
  }
#line 1598
  if (type == 1610612783UL) {
#line 1598
    goto case_1610612783;
  }
#line 1599
  if (type == 1610612785UL) {
#line 1599
    goto case_1610612785;
  }
#line 1600
  if (type == 1610612787UL) {
#line 1600
    goto case_1610612787;
  }
#line 1601
  if (type == 1610612789UL) {
#line 1601
    goto case_1610612789;
  }
#line 1602
  if (type == 1610612791UL) {
#line 1602
    goto case_1610612791;
  }
#line 1603
  if (type == 1610612793UL) {
#line 1603
    goto case_1610612793;
  }
#line 1604
  if (type == 1610612795UL) {
#line 1604
    goto case_1610612795;
  }
#line 1605
  if (type == 1610612797UL) {
#line 1605
    goto case_1610612797;
  }
#line 1606
  if (type == 1610612799UL) {
#line 1606
    goto case_1610612799;
  }
#line 1607
  if (type == 1610612801UL) {
#line 1607
    goto case_1610612801;
  }
#line 1608
  if (type == 1610612803UL) {
#line 1608
    goto case_1610612803;
  }
#line 1609
  if (type == 1610612805UL) {
#line 1609
    goto case_1610612805;
  }
#line 1610
  if (type == 1610612807UL) {
#line 1610
    goto case_1610612807;
  }
#line 1611
  if (type == 1610612809UL) {
#line 1611
    goto case_1610612809;
  }
#line 1612
  if (type == 1610612811UL) {
#line 1612
    goto case_1610612811;
  }
#line 1613
  if (type == 1610612813UL) {
#line 1613
    goto case_1610612813;
  }
#line 1614
  if (type == 1610612815UL) {
#line 1614
    goto case_1610612815;
  }
#line 1615
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1584
  return ("IA_64_PLT_RESERVE");
  case_1610612749: /* CIL Label */ 
#line 1585
  return ("VMS_SUBTYPE");
  case_1610612751: /* CIL Label */ 
#line 1586
  return ("VMS_IMGIOCNT");
  case_1610612757: /* CIL Label */ 
#line 1587
  return ("VMS_LNKFLAGS");
  case_1610612759: /* CIL Label */ 
#line 1588
  return ("VMS_VIR_MEM_BLK_SIZ");
  case_1610612761: /* CIL Label */ 
#line 1589
  return ("VMS_IDENT");
  case_1610612765: /* CIL Label */ 
#line 1590
  return ("VMS_NEEDED_IDENT");
  case_1610612767: /* CIL Label */ 
#line 1591
  return ("VMS_IMG_RELA_CNT");
  case_1610612769: /* CIL Label */ 
#line 1592
  return ("VMS_SEG_RELA_CNT");
  case_1610612771: /* CIL Label */ 
#line 1593
  return ("VMS_FIXUP_RELA_CNT");
  case_1610612773: /* CIL Label */ 
#line 1594
  return ("VMS_FIXUP_NEEDED");
  case_1610612775: /* CIL Label */ 
#line 1595
  return ("VMS_SYMVEC_CNT");
  case_1610612779: /* CIL Label */ 
#line 1596
  return ("VMS_XLATED");
  case_1610612781: /* CIL Label */ 
#line 1597
  return ("VMS_STACKSIZE");
  case_1610612783: /* CIL Label */ 
#line 1598
  return ("VMS_UNWINDSZ");
  case_1610612785: /* CIL Label */ 
#line 1599
  return ("VMS_UNWIND_CODSEG");
  case_1610612787: /* CIL Label */ 
#line 1600
  return ("VMS_UNWIND_INFOSEG");
  case_1610612789: /* CIL Label */ 
#line 1601
  return ("VMS_LINKTIME");
  case_1610612791: /* CIL Label */ 
#line 1602
  return ("VMS_SEG_NO");
  case_1610612793: /* CIL Label */ 
#line 1603
  return ("VMS_SYMVEC_OFFSET");
  case_1610612795: /* CIL Label */ 
#line 1604
  return ("VMS_SYMVEC_SEG");
  case_1610612797: /* CIL Label */ 
#line 1605
  return ("VMS_UNWIND_OFFSET");
  case_1610612799: /* CIL Label */ 
#line 1606
  return ("VMS_UNWIND_SEG");
  case_1610612801: /* CIL Label */ 
#line 1607
  return ("VMS_STRTAB_OFFSET");
  case_1610612803: /* CIL Label */ 
#line 1608
  return ("VMS_SYSVER_OFFSET");
  case_1610612805: /* CIL Label */ 
#line 1609
  return ("VMS_IMG_RELA_OFF");
  case_1610612807: /* CIL Label */ 
#line 1610
  return ("VMS_SEG_RELA_OFF");
  case_1610612809: /* CIL Label */ 
#line 1611
  return ("VMS_FIXUP_RELA_OFF");
  case_1610612811: /* CIL Label */ 
#line 1612
  return ("VMS_PLTGOT_OFFSET");
  case_1610612813: /* CIL Label */ 
#line 1613
  return ("VMS_PLTGOT_SEG");
  case_1610612815: /* CIL Label */ 
#line 1614
  return ("VMS_FPMODE");
  switch_default: /* CIL Label */ 
#line 1616
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1620 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_alpha_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1625
  if (type == 1879048192UL) {
#line 1625
    goto case_1879048192;
  }
#line 1626
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 1625
  return ("ALPHA_PLTRO");
  switch_default: /* CIL Label */ 
#line 1627
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1631 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_score_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1636
  if (type == 1879048193UL) {
#line 1636
    goto case_1879048193;
  }
#line 1637
  if (type == 1879048194UL) {
#line 1637
    goto case_1879048194;
  }
#line 1638
  if (type == 1879048195UL) {
#line 1638
    goto case_1879048195;
  }
#line 1639
  if (type == 1879048196UL) {
#line 1639
    goto case_1879048196;
  }
#line 1640
  if (type == 1879048197UL) {
#line 1640
    goto case_1879048197;
  }
#line 1641
  if (type == 1879048198UL) {
#line 1641
    goto case_1879048198;
  }
#line 1642
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 1636
  return ("SCORE_BASE_ADDRESS");
  case_1879048194: /* CIL Label */ 
#line 1637
  return ("SCORE_LOCAL_GOTNO");
  case_1879048195: /* CIL Label */ 
#line 1638
  return ("SCORE_SYMTABNO");
  case_1879048196: /* CIL Label */ 
#line 1639
  return ("SCORE_GOTSYM");
  case_1879048197: /* CIL Label */ 
#line 1640
  return ("SCORE_UNREFEXTNO");
  case_1879048198: /* CIL Label */ 
#line 1641
  return ("SCORE_HIPAGENO");
  switch_default: /* CIL Label */ 
#line 1643
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1647 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_tic6x_dynamic_type(unsigned long type ) 
{ 


  {
  {
#line 1652
  if (type == 1610612749UL) {
#line 1652
    goto case_1610612749;
  }
#line 1653
  if (type == 1610612751UL) {
#line 1653
    goto case_1610612751;
  }
#line 1654
  if (type == 1879048192UL) {
#line 1654
    goto case_1879048192;
  }
#line 1655
  if (type == 1879048193UL) {
#line 1655
    goto case_1879048193;
  }
#line 1656
  if (type == 1879048194UL) {
#line 1656
    goto case_1879048194;
  }
#line 1657
  if (type == 1879048195UL) {
#line 1657
    goto case_1879048195;
  }
#line 1658
  goto switch_default;
  case_1610612749: /* CIL Label */ 
#line 1652
  return ("C6000_GSYM_OFFSET");
  case_1610612751: /* CIL Label */ 
#line 1653
  return ("C6000_GSTR_OFFSET");
  case_1879048192: /* CIL Label */ 
#line 1654
  return ("C6000_DSBT_BASE");
  case_1879048193: /* CIL Label */ 
#line 1655
  return ("C6000_DSBT_SIZE");
  case_1879048194: /* CIL Label */ 
#line 1656
  return ("C6000_PREEMPTMAP");
  case_1879048195: /* CIL Label */ 
#line 1657
  return ("C6000_DSBT_INDEX");
  switch_default: /* CIL Label */ 
#line 1659
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1666 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___0[64]  ;
#line 1663 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_dynamic_type(unsigned long type ) 
{ 
  char const   *result ;
  char *tmp___0 ;
  char const   *result___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1670
  if (type == 0UL) {
#line 1670
    goto case_0;
  }
#line 1671
  if (type == 1UL) {
#line 1671
    goto case_1;
  }
#line 1672
  if (type == 2UL) {
#line 1672
    goto case_2;
  }
#line 1673
  if (type == 3UL) {
#line 1673
    goto case_3;
  }
#line 1674
  if (type == 4UL) {
#line 1674
    goto case_4;
  }
#line 1675
  if (type == 5UL) {
#line 1675
    goto case_5;
  }
#line 1676
  if (type == 6UL) {
#line 1676
    goto case_6;
  }
#line 1677
  if (type == 7UL) {
#line 1677
    goto case_7;
  }
#line 1678
  if (type == 8UL) {
#line 1678
    goto case_8;
  }
#line 1679
  if (type == 9UL) {
#line 1679
    goto case_9;
  }
#line 1680
  if (type == 10UL) {
#line 1680
    goto case_10;
  }
#line 1681
  if (type == 11UL) {
#line 1681
    goto case_11;
  }
#line 1682
  if (type == 12UL) {
#line 1682
    goto case_12;
  }
#line 1683
  if (type == 13UL) {
#line 1683
    goto case_13;
  }
#line 1684
  if (type == 14UL) {
#line 1684
    goto case_14;
  }
#line 1685
  if (type == 15UL) {
#line 1685
    goto case_15;
  }
#line 1686
  if (type == 16UL) {
#line 1686
    goto case_16;
  }
#line 1687
  if (type == 17UL) {
#line 1687
    goto case_17;
  }
#line 1688
  if (type == 18UL) {
#line 1688
    goto case_18;
  }
#line 1689
  if (type == 19UL) {
#line 1689
    goto case_19;
  }
#line 1690
  if (type == 20UL) {
#line 1690
    goto case_20;
  }
#line 1691
  if (type == 21UL) {
#line 1691
    goto case_21;
  }
#line 1692
  if (type == 22UL) {
#line 1692
    goto case_22;
  }
#line 1693
  if (type == 23UL) {
#line 1693
    goto case_23;
  }
#line 1694
  if (type == 24UL) {
#line 1694
    goto case_24;
  }
#line 1695
  if (type == 25UL) {
#line 1695
    goto case_25;
  }
#line 1696
  if (type == 26UL) {
#line 1696
    goto case_26;
  }
#line 1697
  if (type == 27UL) {
#line 1697
    goto case_27;
  }
#line 1698
  if (type == 28UL) {
#line 1698
    goto case_28;
  }
#line 1699
  if (type == 29UL) {
#line 1699
    goto case_29;
  }
#line 1700
  if (type == 30UL) {
#line 1700
    goto case_30;
  }
#line 1702
  if (type == 32UL) {
#line 1702
    goto case_32;
  }
#line 1703
  if (type == 33UL) {
#line 1703
    goto case_33;
  }
#line 1705
  if (type == 1879047672UL) {
#line 1705
    goto case_1879047672;
  }
#line 1706
  if (type == 1879047673UL) {
#line 1706
    goto case_1879047673;
  }
#line 1707
  if (type == 1879047674UL) {
#line 1707
    goto case_1879047674;
  }
#line 1708
  if (type == 1879047675UL) {
#line 1708
    goto case_1879047675;
  }
#line 1709
  if (type == 1879047676UL) {
#line 1709
    goto case_1879047676;
  }
#line 1710
  if (type == 1879047677UL) {
#line 1710
    goto case_1879047677;
  }
#line 1711
  if (type == 1879047678UL) {
#line 1711
    goto case_1879047678;
  }
#line 1712
  if (type == 1879047679UL) {
#line 1712
    goto case_1879047679;
  }
#line 1714
  if (type == 1879047680UL) {
#line 1714
    goto case_1879047680;
  }
#line 1715
  if (type == 1879047930UL) {
#line 1715
    goto case_1879047930;
  }
#line 1716
  if (type == 1879047931UL) {
#line 1716
    goto case_1879047931;
  }
#line 1717
  if (type == 1879047932UL) {
#line 1717
    goto case_1879047932;
  }
#line 1718
  if (type == 1879047933UL) {
#line 1718
    goto case_1879047933;
  }
#line 1719
  if (type == 1879047934UL) {
#line 1719
    goto case_1879047934;
  }
#line 1720
  if (type == 1879047935UL) {
#line 1720
    goto case_1879047935;
  }
#line 1722
  if (type == 1879048176UL) {
#line 1722
    goto case_1879048176;
  }
#line 1724
  if (type == 1879047927UL) {
#line 1724
    goto case_1879047927;
  }
#line 1725
  if (type == 1879047926UL) {
#line 1725
    goto case_1879047926;
  }
#line 1726
  if (type == 1879048185UL) {
#line 1726
    goto case_1879048185;
  }
#line 1727
  if (type == 1879048186UL) {
#line 1727
    goto case_1879048186;
  }
#line 1728
  if (type == 1879048187UL) {
#line 1728
    goto case_1879048187;
  }
#line 1729
  if (type == 1879048188UL) {
#line 1729
    goto case_1879048188;
  }
#line 1730
  if (type == 1879048189UL) {
#line 1730
    goto case_1879048189;
  }
#line 1731
  if (type == 1879048190UL) {
#line 1731
    goto case_1879048190;
  }
#line 1732
  if (type == 1879048191UL) {
#line 1732
    goto case_1879048191;
  }
#line 1734
  if (type == 2147483645UL) {
#line 1734
    goto case_2147483645;
  }
#line 1735
  if (type == 2147483646UL) {
#line 1735
    goto case_2147483646;
  }
#line 1736
  if (type == 2147483647UL) {
#line 1736
    goto case_2147483647;
  }
#line 1738
  if (type == 1879047669UL) {
#line 1738
    goto case_1879047669;
  }
#line 1739
  if (type == 1879047928UL) {
#line 1739
    goto case_1879047928;
  }
#line 1740
  if (type == 1879047670UL) {
#line 1740
    goto case_1879047670;
  }
#line 1741
  if (type == 1879047929UL) {
#line 1741
    goto case_1879047929;
  }
#line 1742
  if (type == 1879047671UL) {
#line 1742
    goto case_1879047671;
  }
#line 1743
  if (type == 1879047925UL) {
#line 1743
    goto case_1879047925;
  }
#line 1745
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1670
  return ("NULL");
  case_1: /* CIL Label */ 
#line 1671
  return ("NEEDED");
  case_2: /* CIL Label */ 
#line 1672
  return ("PLTRELSZ");
  case_3: /* CIL Label */ 
#line 1673
  return ("PLTGOT");
  case_4: /* CIL Label */ 
#line 1674
  return ("HASH");
  case_5: /* CIL Label */ 
#line 1675
  return ("STRTAB");
  case_6: /* CIL Label */ 
#line 1676
  return ("SYMTAB");
  case_7: /* CIL Label */ 
#line 1677
  return ("RELA");
  case_8: /* CIL Label */ 
#line 1678
  return ("RELASZ");
  case_9: /* CIL Label */ 
#line 1679
  return ("RELAENT");
  case_10: /* CIL Label */ 
#line 1680
  return ("STRSZ");
  case_11: /* CIL Label */ 
#line 1681
  return ("SYMENT");
  case_12: /* CIL Label */ 
#line 1682
  return ("INIT");
  case_13: /* CIL Label */ 
#line 1683
  return ("FINI");
  case_14: /* CIL Label */ 
#line 1684
  return ("SONAME");
  case_15: /* CIL Label */ 
#line 1685
  return ("RPATH");
  case_16: /* CIL Label */ 
#line 1686
  return ("SYMBOLIC");
  case_17: /* CIL Label */ 
#line 1687
  return ("REL");
  case_18: /* CIL Label */ 
#line 1688
  return ("RELSZ");
  case_19: /* CIL Label */ 
#line 1689
  return ("RELENT");
  case_20: /* CIL Label */ 
#line 1690
  return ("PLTREL");
  case_21: /* CIL Label */ 
#line 1691
  return ("DEBUG");
  case_22: /* CIL Label */ 
#line 1692
  return ("TEXTREL");
  case_23: /* CIL Label */ 
#line 1693
  return ("JMPREL");
  case_24: /* CIL Label */ 
#line 1694
  return ("BIND_NOW");
  case_25: /* CIL Label */ 
#line 1695
  return ("INIT_ARRAY");
  case_26: /* CIL Label */ 
#line 1696
  return ("FINI_ARRAY");
  case_27: /* CIL Label */ 
#line 1697
  return ("INIT_ARRAYSZ");
  case_28: /* CIL Label */ 
#line 1698
  return ("FINI_ARRAYSZ");
  case_29: /* CIL Label */ 
#line 1699
  return ("RUNPATH");
  case_30: /* CIL Label */ 
#line 1700
  return ("FLAGS");
  case_32: /* CIL Label */ 
#line 1702
  return ("PREINIT_ARRAY");
  case_33: /* CIL Label */ 
#line 1703
  return ("PREINIT_ARRAYSZ");
  case_1879047672: /* CIL Label */ 
#line 1705
  return ("CHECKSUM");
  case_1879047673: /* CIL Label */ 
#line 1706
  return ("PLTPADSZ");
  case_1879047674: /* CIL Label */ 
#line 1707
  return ("MOVEENT");
  case_1879047675: /* CIL Label */ 
#line 1708
  return ("MOVESZ");
  case_1879047676: /* CIL Label */ 
#line 1709
  return ("FEATURE");
  case_1879047677: /* CIL Label */ 
#line 1710
  return ("POSFLAG_1");
  case_1879047678: /* CIL Label */ 
#line 1711
  return ("SYMINSZ");
  case_1879047679: /* CIL Label */ 
#line 1712
  return ("SYMINENT");
  case_1879047680: /* CIL Label */ 
#line 1714
  return ("ADDRRNGLO");
  case_1879047930: /* CIL Label */ 
#line 1715
  return ("CONFIG");
  case_1879047931: /* CIL Label */ 
#line 1716
  return ("DEPAUDIT");
  case_1879047932: /* CIL Label */ 
#line 1717
  return ("AUDIT");
  case_1879047933: /* CIL Label */ 
#line 1718
  return ("PLTPAD");
  case_1879047934: /* CIL Label */ 
#line 1719
  return ("MOVETAB");
  case_1879047935: /* CIL Label */ 
#line 1720
  return ("SYMINFO");
  case_1879048176: /* CIL Label */ 
#line 1722
  return ("VERSYM");
  case_1879047927: /* CIL Label */ 
#line 1724
  return ("TLSDESC_GOT");
  case_1879047926: /* CIL Label */ 
#line 1725
  return ("TLSDESC_PLT");
  case_1879048185: /* CIL Label */ 
#line 1726
  return ("RELACOUNT");
  case_1879048186: /* CIL Label */ 
#line 1727
  return ("RELCOUNT");
  case_1879048187: /* CIL Label */ 
#line 1728
  return ("FLAGS_1");
  case_1879048188: /* CIL Label */ 
#line 1729
  return ("VERDEF");
  case_1879048189: /* CIL Label */ 
#line 1730
  return ("VERDEFNUM");
  case_1879048190: /* CIL Label */ 
#line 1731
  return ("VERNEED");
  case_1879048191: /* CIL Label */ 
#line 1732
  return ("VERNEEDNUM");
  case_2147483645: /* CIL Label */ 
#line 1734
  return ("AUXILIARY");
  case_2147483646: /* CIL Label */ 
#line 1735
  return ("USED");
  case_2147483647: /* CIL Label */ 
#line 1736
  return ("FILTER");
  case_1879047669: /* CIL Label */ 
#line 1738
  return ("GNU_PRELINKED");
  case_1879047928: /* CIL Label */ 
#line 1739
  return ("GNU_CONFLICT");
  case_1879047670: /* CIL Label */ 
#line 1740
  return ("GNU_CONFLICTSZ");
  case_1879047929: /* CIL Label */ 
#line 1741
  return ("GNU_LIBLIST");
  case_1879047671: /* CIL Label */ 
#line 1742
  return ("GNU_LIBLISTSZ");
  case_1879047925: /* CIL Label */ 
#line 1743
  return ("GNU_HASH");
  switch_default: /* CIL Label */ 
#line 1746
  if (type >= 1879048192UL) {
#line 1746
    if (type <= 2147483647UL) {
      {
#line 1753
      if ((int )elf_header.e_machine == 10) {
#line 1753
        goto case_10___0;
      }
#line 1753
      if ((int )elf_header.e_machine == 8) {
#line 1753
        goto case_10___0;
      }
#line 1756
      if ((int )elf_header.e_machine == 43) {
#line 1756
        goto case_43;
      }
#line 1759
      if ((int )elf_header.e_machine == 20) {
#line 1759
        goto case_20___0;
      }
#line 1762
      if ((int )elf_header.e_machine == 21) {
#line 1762
        goto case_21___0;
      }
#line 1765
      if ((int )elf_header.e_machine == 50) {
#line 1765
        goto case_50;
      }
#line 1768
      if ((int )elf_header.e_machine == 36902) {
#line 1768
        goto case_36902;
      }
#line 1771
      if ((int )elf_header.e_machine == 135) {
#line 1771
        goto case_135;
      }
#line 1774
      if ((int )elf_header.e_machine == 140) {
#line 1774
        goto case_140;
      }
#line 1777
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_8___0: /* CIL Label */ 
      {
#line 1754
      result = get_mips_dynamic_type(type);
      }
#line 1755
      goto switch_break___0;
      case_43: /* CIL Label */ 
      {
#line 1757
      result = get_sparc64_dynamic_type(type);
      }
#line 1758
      goto switch_break___0;
      case_20___0: /* CIL Label */ 
      {
#line 1760
      result = get_ppc_dynamic_type(type);
      }
#line 1761
      goto switch_break___0;
      case_21___0: /* CIL Label */ 
      {
#line 1763
      result = get_ppc64_dynamic_type(type);
      }
#line 1764
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 1766
      result = get_ia64_dynamic_type(type);
      }
#line 1767
      goto switch_break___0;
      case_36902: /* CIL Label */ 
      {
#line 1769
      result = get_alpha_dynamic_type(type);
      }
#line 1770
      goto switch_break___0;
      case_135: /* CIL Label */ 
      {
#line 1772
      result = get_score_dynamic_type(type);
      }
#line 1773
      goto switch_break___0;
      case_140: /* CIL Label */ 
      {
#line 1775
      result = get_tic6x_dynamic_type(type);
      }
#line 1776
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1778
      result = (char const   *)((void *)0);
#line 1779
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 1782
      if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 1783
        return (result);
      }
      {
#line 1785
      tmp___0 = gettext("Processor Specific: %lx");
#line 1785
      snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___0,
               type);
      }
    } else {
#line 1746
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1787
  if (type >= 1610612749UL) {
#line 1787
    if (type <= 1879044096UL) {
#line 1787
      goto _L;
    } else {
#line 1787
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1787
  if ((int )elf_header.e_machine == 15) {
#line 1787
    if (type >= 1610612736UL) {
#line 1787
      if (type <= 1879048191UL) {
        _L: /* CIL Label */ 
        {
#line 1795
        if ((int )elf_header.e_machine == 15) {
#line 1795
          goto case_15___0;
        }
#line 1798
        if ((int )elf_header.e_machine == 50) {
#line 1798
          goto case_50___0;
        }
#line 1801
        goto switch_default___1;
        case_15___0: /* CIL Label */ 
        {
#line 1796
        result___0 = get_parisc_dynamic_type(type);
        }
#line 1797
        goto switch_break___1;
        case_50___0: /* CIL Label */ 
        {
#line 1799
        result___0 = get_ia64_dynamic_type(type);
        }
#line 1800
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 1802
        result___0 = (char const   *)((void *)0);
#line 1803
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
#line 1806
        if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 1807
          return (result___0);
        }
        {
#line 1809
        tmp___1 = gettext("Operating System specific: %lx");
#line 1809
        snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___1,
                 type);
        }
      } else {
        {
#line 1813
        tmp___2 = gettext("<unknown>: %lx");
#line 1813
        snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___2,
                 type);
        }
      }
    } else {
      {
#line 1813
      tmp___2 = gettext("<unknown>: %lx");
#line 1813
      snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___2,
               type);
      }
    }
  } else {
    {
#line 1813
    tmp___2 = gettext("<unknown>: %lx");
#line 1813
    snprintf((char */* __restrict  */)(buff___0), sizeof(buff___0), (char const   */* __restrict  */)tmp___2,
             type);
    }
  }
#line 1815
  return ((char const   *)(buff___0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1822 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___1[32]  ;
#line 1819 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *get_file_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1826
  if (e_type == 0U) {
#line 1826
    goto case_0;
  }
#line 1827
  if (e_type == 1U) {
#line 1827
    goto case_1;
  }
#line 1828
  if (e_type == 2U) {
#line 1828
    goto case_2;
  }
#line 1829
  if (e_type == 3U) {
#line 1829
    goto case_3;
  }
#line 1830
  if (e_type == 4U) {
#line 1830
    goto case_4;
  }
#line 1832
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1826
  tmp___0 = gettext("NONE (None)");
  }
#line 1826
  return (tmp___0);
  case_1: /* CIL Label */ 
  {
#line 1827
  tmp___1 = gettext("REL (Relocatable file)");
  }
#line 1827
  return (tmp___1);
  case_2: /* CIL Label */ 
  {
#line 1828
  tmp___2 = gettext("EXEC (Executable file)");
  }
#line 1828
  return (tmp___2);
  case_3: /* CIL Label */ 
  {
#line 1829
  tmp___3 = gettext("DYN (Shared object file)");
  }
#line 1829
  return (tmp___3);
  case_4: /* CIL Label */ 
  {
#line 1830
  tmp___4 = gettext("CORE (Core file)");
  }
#line 1830
  return (tmp___4);
  switch_default: /* CIL Label */ 
#line 1833
  if (e_type >= 65280U) {
#line 1833
    if (e_type <= 65535U) {
      {
#line 1834
      tmp___5 = gettext("Processor Specific: (%x)");
#line 1834
      snprintf((char */* __restrict  */)(buff___1), sizeof(buff___1), (char const   */* __restrict  */)tmp___5,
               e_type);
      }
    } else {
#line 1833
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1835
  if (e_type >= 65024U) {
#line 1835
    if (e_type <= 65279U) {
      {
#line 1836
      tmp___6 = gettext("OS Specific: (%x)");
#line 1836
      snprintf((char */* __restrict  */)(buff___1), sizeof(buff___1), (char const   */* __restrict  */)tmp___6,
               e_type);
      }
    } else {
      {
#line 1838
      tmp___7 = gettext("<unknown>: %x");
#line 1838
      snprintf((char */* __restrict  */)(buff___1), sizeof(buff___1), (char const   */* __restrict  */)tmp___7,
               e_type);
      }
    }
  } else {
    {
#line 1838
    tmp___7 = gettext("<unknown>: %x");
#line 1838
    snprintf((char */* __restrict  */)(buff___1), sizeof(buff___1), (char const   */* __restrict  */)tmp___7,
             e_type);
    }
  }
#line 1839
  return (buff___1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1846 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___2[64]  ;
#line 1843 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *get_machine_name(unsigned int e_machine ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1850
  if (e_machine == 0U) {
#line 1850
    goto case_0;
  }
#line 1851
  if (e_machine == 183U) {
#line 1851
    goto case_183;
  }
#line 1852
  if (e_machine == 1U) {
#line 1852
    goto case_1;
  }
#line 1853
  if (e_machine == 2U) {
#line 1853
    goto case_2;
  }
#line 1854
  if (e_machine == 23U) {
#line 1854
    goto case_23;
  }
#line 1855
  if (e_machine == 3U) {
#line 1855
    goto case_3;
  }
#line 1856
  if (e_machine == 4U) {
#line 1856
    goto case_4;
  }
#line 1857
  if (e_machine == 5U) {
#line 1857
    goto case_5;
  }
#line 1858
  if (e_machine == 6U) {
#line 1858
    goto case_6;
  }
#line 1859
  if (e_machine == 7U) {
#line 1859
    goto case_7;
  }
#line 1860
  if (e_machine == 8U) {
#line 1860
    goto case_8;
  }
#line 1861
  if (e_machine == 9U) {
#line 1861
    goto case_9;
  }
#line 1862
  if (e_machine == 10U) {
#line 1862
    goto case_10;
  }
#line 1863
  if (e_machine == 11U) {
#line 1863
    goto case_11;
  }
#line 1864
  if (e_machine == 15U) {
#line 1864
    goto case_15;
  }
#line 1865
  if (e_machine == 17U) {
#line 1865
    goto case_17;
  }
#line 1866
  if (e_machine == 18U) {
#line 1866
    goto case_18;
  }
#line 1867
  if (e_machine == 19U) {
#line 1867
    goto case_19;
  }
#line 1868
  if (e_machine == 20U) {
#line 1868
    goto case_20;
  }
#line 1869
  if (e_machine == 21U) {
#line 1869
    goto case_21;
  }
#line 1870
  if (e_machine == 36U) {
#line 1870
    goto case_36;
  }
#line 1871
  if (e_machine == 37U) {
#line 1871
    goto case_37;
  }
#line 1872
  if (e_machine == 38U) {
#line 1872
    goto case_38;
  }
#line 1873
  if (e_machine == 39U) {
#line 1873
    goto case_39;
  }
#line 1874
  if (e_machine == 40U) {
#line 1874
    goto case_40;
  }
#line 1875
  if (e_machine == 41U) {
#line 1875
    goto case_41;
  }
#line 1876
  if (e_machine == 42U) {
#line 1876
    goto case_42;
  }
#line 1877
  if (e_machine == 43U) {
#line 1877
    goto case_43;
  }
#line 1878
  if (e_machine == 44U) {
#line 1878
    goto case_44;
  }
#line 1879
  if (e_machine == 45U) {
#line 1879
    goto case_45;
  }
#line 1880
  if (e_machine == 46U) {
#line 1880
    goto case_46;
  }
#line 1881
  if (e_machine == 47U) {
#line 1881
    goto case_47;
  }
#line 1882
  if (e_machine == 48U) {
#line 1882
    goto case_48;
  }
#line 1883
  if (e_machine == 49U) {
#line 1883
    goto case_49;
  }
#line 1884
  if (e_machine == 50U) {
#line 1884
    goto case_50;
  }
#line 1885
  if (e_machine == 51U) {
#line 1885
    goto case_51;
  }
#line 1886
  if (e_machine == 52U) {
#line 1886
    goto case_52;
  }
#line 1887
  if (e_machine == 36902U) {
#line 1887
    goto case_36902;
  }
#line 1889
  if (e_machine == 85U) {
#line 1889
    goto case_85;
  }
#line 1889
  if (e_machine == 30288U) {
#line 1889
    goto case_85;
  }
#line 1891
  if (e_machine == 86U) {
#line 1891
    goto case_86;
  }
#line 1891
  if (e_machine == 30326U) {
#line 1891
    goto case_86;
  }
#line 1893
  if (e_machine == 88U) {
#line 1893
    goto case_88;
  }
#line 1893
  if (e_machine == 36929U) {
#line 1893
    goto case_88;
  }
#line 1895
  if (e_machine == 87U) {
#line 1895
    goto case_87;
  }
#line 1895
  if (e_machine == 36992U) {
#line 1895
    goto case_87;
  }
#line 1897
  if (e_machine == 89U) {
#line 1897
    goto case_89;
  }
#line 1897
  if (e_machine == 48879U) {
#line 1897
    goto case_89;
  }
#line 1899
  if (e_machine == 90U) {
#line 1899
    goto case_90;
  }
#line 1899
  if (e_machine == 57005U) {
#line 1899
    goto case_90;
  }
#line 1900
  if (e_machine == 65261U) {
#line 1900
    goto case_65261;
  }
#line 1902
  if (e_machine == 84U) {
#line 1902
    goto case_84;
  }
#line 1902
  if (e_machine == 13104U) {
#line 1902
    goto case_84;
  }
#line 1903
  if (e_machine == 21569U) {
#line 1903
    goto case_21569;
  }
#line 1905
  if (e_machine == 91U) {
#line 1905
    goto case_91;
  }
#line 1905
  if (e_machine == 99U) {
#line 1905
    goto case_91;
  }
#line 1906
  if (e_machine == 54U) {
#line 1906
    goto case_54;
  }
#line 1907
  if (e_machine == 55U) {
#line 1907
    goto case_55;
  }
#line 1908
  if (e_machine == 56U) {
#line 1908
    goto case_56;
  }
#line 1909
  if (e_machine == 57U) {
#line 1909
    goto case_57;
  }
#line 1910
  if (e_machine == 58U) {
#line 1910
    goto case_58;
  }
#line 1911
  if (e_machine == 59U) {
#line 1911
    goto case_59;
  }
#line 1912
  if (e_machine == 60U) {
#line 1912
    goto case_60;
  }
#line 1913
  if (e_machine == 61U) {
#line 1913
    goto case_61;
  }
#line 1914
  if (e_machine == 63U) {
#line 1914
    goto case_63;
  }
#line 1915
  if (e_machine == 64U) {
#line 1915
    goto case_64;
  }
#line 1916
  if (e_machine == 65U) {
#line 1916
    goto case_65;
  }
#line 1917
  if (e_machine == 66U) {
#line 1917
    goto case_66;
  }
#line 1918
  if (e_machine == 67U) {
#line 1918
    goto case_67;
  }
#line 1919
  if (e_machine == 68U) {
#line 1919
    goto case_68;
  }
#line 1920
  if (e_machine == 69U) {
#line 1920
    goto case_69;
  }
#line 1921
  if (e_machine == 53U) {
#line 1921
    goto case_53;
  }
#line 1922
  if (e_machine == 70U) {
#line 1922
    goto case_70;
  }
#line 1923
  if (e_machine == 71U) {
#line 1923
    goto case_71;
  }
#line 1924
  if (e_machine == 72U) {
#line 1924
    goto case_72;
  }
#line 1925
  if (e_machine == 73U) {
#line 1925
    goto case_73;
  }
#line 1926
  if (e_machine == 74U) {
#line 1926
    goto case_74;
  }
#line 1927
  if (e_machine == 75U) {
#line 1927
    goto case_75;
  }
#line 1929
  if (e_machine == 83U) {
#line 1929
    goto case_83;
  }
#line 1929
  if (e_machine == 4183U) {
#line 1929
    goto case_83;
  }
#line 1930
  if (e_machine == 76U) {
#line 1930
    goto case_76;
  }
#line 1931
  if (e_machine == 77U) {
#line 1931
    goto case_77;
  }
#line 1932
  if (e_machine == 78U) {
#line 1932
    goto case_78;
  }
#line 1933
  if (e_machine == 79U) {
#line 1933
    goto case_79;
  }
#line 1934
  if (e_machine == 80U) {
#line 1934
    goto case_80;
  }
#line 1935
  if (e_machine == 81U) {
#line 1935
    goto case_81;
  }
#line 1936
  if (e_machine == 82U) {
#line 1936
    goto case_82;
  }
#line 1937
  if (e_machine == 62U) {
#line 1937
    goto case_62;
  }
#line 1938
  if (e_machine == 180U) {
#line 1938
    goto case_180;
  }
#line 1939
  if (e_machine == 181U) {
#line 1939
    goto case_181;
  }
#line 1941
  if (e_machine == 22U) {
#line 1941
    goto case_22;
  }
#line 1941
  if (e_machine == 41872U) {
#line 1941
    goto case_22;
  }
#line 1942
  if (e_machine == 135U) {
#line 1942
    goto case_135;
  }
#line 1943
  if (e_machine == 44357U) {
#line 1943
    goto case_44357;
  }
#line 1945
  if (e_machine == 33906U) {
#line 1945
    goto case_33906;
  }
#line 1945
  if (e_machine == 92U) {
#line 1945
    goto case_33906;
  }
#line 1946
  if (e_machine == 93U) {
#line 1946
    goto case_93;
  }
#line 1947
  if (e_machine == 114U) {
#line 1947
    goto case_114;
  }
#line 1948
  if (e_machine == 4643U) {
#line 1948
    goto case_4643;
  }
#line 1949
  if (e_machine == 23205U) {
#line 1949
    goto case_23205;
  }
#line 1951
  if (e_machine == 101U) {
#line 1951
    goto case_101;
  }
#line 1951
  if (e_machine == 33303U) {
#line 1951
    goto case_101;
  }
#line 1952
  if (e_machine == 65210U) {
#line 1952
    goto case_65210;
  }
#line 1954
  if (e_machine == 94U) {
#line 1954
    goto case_94;
  }
#line 1954
  if (e_machine == 43975U) {
#line 1954
    goto case_94;
  }
#line 1955
  if (e_machine == 95U) {
#line 1955
    goto case_95;
  }
#line 1956
  if (e_machine == 96U) {
#line 1956
    goto case_96;
  }
#line 1957
  if (e_machine == 97U) {
#line 1957
    goto case_97;
  }
#line 1958
  if (e_machine == 98U) {
#line 1958
    goto case_98;
  }
#line 1959
  if (e_machine == 100U) {
#line 1959
    goto case_100;
  }
#line 1960
  if (e_machine == 102U) {
#line 1960
    goto case_102;
  }
#line 1961
  if (e_machine == 103U) {
#line 1961
    goto case_103;
  }
#line 1962
  if (e_machine == 104U) {
#line 1962
    goto case_104;
  }
#line 1963
  if (e_machine == 105U) {
#line 1963
    goto case_105;
  }
#line 1964
  if (e_machine == 138U) {
#line 1964
    goto case_138;
  }
#line 1966
  if (e_machine == 120U) {
#line 1966
    goto case_120;
  }
#line 1966
  if (e_machine == 65200U) {
#line 1966
    goto case_120;
  }
#line 1967
  if (e_machine == 9520U) {
#line 1967
    goto case_9520;
  }
#line 1968
  if (e_machine == 106U) {
#line 1968
    goto case_106;
  }
#line 1969
  if (e_machine == 107U) {
#line 1969
    goto case_107;
  }
#line 1970
  if (e_machine == 108U) {
#line 1970
    goto case_108;
  }
#line 1971
  if (e_machine == 109U) {
#line 1971
    goto case_109;
  }
#line 1972
  if (e_machine == 110U) {
#line 1972
    goto case_110;
  }
#line 1973
  if (e_machine == 111U) {
#line 1973
    goto case_111;
  }
#line 1974
  if (e_machine == 112U) {
#line 1974
    goto case_112;
  }
#line 1975
  if (e_machine == 65211U) {
#line 1975
    goto case_65211;
  }
#line 1976
  if (e_machine == 113U) {
#line 1976
    goto case_113;
  }
#line 1978
  if (e_machine == 18056U) {
#line 1978
    goto case_18056;
  }
#line 1978
  if (e_machine == 116U) {
#line 1978
    goto case_18056;
  }
#line 1979
  if (e_machine == 117U) {
#line 1979
    goto case_117;
  }
#line 1980
  if (e_machine == 118U) {
#line 1980
    goto case_118;
  }
#line 1981
  if (e_machine == 119U) {
#line 1981
    goto case_119;
  }
#line 1982
  if (e_machine == 131U) {
#line 1982
    goto case_131;
  }
#line 1983
  if (e_machine == 132U) {
#line 1983
    goto case_132;
  }
#line 1984
  if (e_machine == 134U) {
#line 1984
    goto case_134;
  }
#line 1985
  if (e_machine == 136U) {
#line 1985
    goto case_136;
  }
#line 1986
  if (e_machine == 137U) {
#line 1986
    goto case_137;
  }
#line 1987
  if (e_machine == 139U) {
#line 1987
    goto case_139;
  }
#line 1988
  if (e_machine == 140U) {
#line 1988
    goto case_140;
  }
#line 1989
  if (e_machine == 141U) {
#line 1989
    goto case_141;
  }
#line 1990
  if (e_machine == 142U) {
#line 1990
    goto case_142;
  }
#line 1991
  if (e_machine == 160U) {
#line 1991
    goto case_160;
  }
#line 1992
  if (e_machine == 161U) {
#line 1992
    goto case_161;
  }
#line 1993
  if (e_machine == 162U) {
#line 1993
    goto case_162;
  }
#line 1994
  if (e_machine == 163U) {
#line 1994
    goto case_163;
  }
#line 1995
  if (e_machine == 164U) {
#line 1995
    goto case_164;
  }
#line 1996
  if (e_machine == 165U) {
#line 1996
    goto case_165;
  }
#line 1997
  if (e_machine == 166U) {
#line 1997
    goto case_166;
  }
#line 1998
  if (e_machine == 167U) {
#line 1998
    goto case_167;
  }
#line 1999
  if (e_machine == 168U) {
#line 1999
    goto case_168;
  }
#line 2000
  if (e_machine == 169U) {
#line 2000
    goto case_169;
  }
#line 2001
  if (e_machine == 170U) {
#line 2001
    goto case_170;
  }
#line 2002
  if (e_machine == 171U) {
#line 2002
    goto case_171;
  }
#line 2003
  if (e_machine == 172U) {
#line 2003
    goto case_172;
  }
#line 2004
  if (e_machine == 61453U) {
#line 2004
    goto case_61453;
  }
#line 2007
  if (e_machine == 47787U) {
#line 2007
    goto case_47787;
  }
#line 2007
  if (e_machine == 189U) {
#line 2007
    goto case_47787;
  }
#line 2007
  if (e_machine == 177U) {
#line 2007
    goto case_47787;
  }
#line 2008
  if (e_machine == 197U) {
#line 2008
    goto case_197;
  }
#line 2009
  if (e_machine == 173U) {
#line 2009
    goto case_173;
  }
#line 2010
  if (e_machine == 174U) {
#line 2010
    goto case_174;
  }
#line 2011
  if (e_machine == 175U) {
#line 2011
    goto case_175;
  }
#line 2012
  if (e_machine == 176U) {
#line 2012
    goto case_176;
  }
#line 2013
  if (e_machine == 178U) {
#line 2013
    goto case_178;
  }
#line 2014
  if (e_machine == 179U) {
#line 2014
    goto case_179;
  }
#line 2015
  if (e_machine == 185U) {
#line 2015
    goto case_185;
  }
#line 2016
  if (e_machine == 186U) {
#line 2016
    goto case_186;
  }
#line 2017
  if (e_machine == 187U) {
#line 2017
    goto case_187;
  }
#line 2018
  if (e_machine == 188U) {
#line 2018
    goto case_188;
  }
#line 2019
  if (e_machine == 191U) {
#line 2019
    goto case_191;
  }
#line 2020
  if (e_machine == 190U) {
#line 2020
    goto case_190;
  }
#line 2021
  if (e_machine == 115U) {
#line 2021
    goto case_115;
  }
#line 2022
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1850
  tmp___0 = gettext("None");
  }
#line 1850
  return (tmp___0);
  case_183: /* CIL Label */ 
#line 1851
  return ((char *)"AArch64");
  case_1: /* CIL Label */ 
#line 1852
  return ((char *)"WE32100");
  case_2: /* CIL Label */ 
#line 1853
  return ((char *)"Sparc");
  case_23: /* CIL Label */ 
#line 1854
  return ((char *)"SPU");
  case_3: /* CIL Label */ 
#line 1855
  return ((char *)"Intel 80386");
  case_4: /* CIL Label */ 
#line 1856
  return ((char *)"MC68000");
  case_5: /* CIL Label */ 
#line 1857
  return ((char *)"MC88000");
  case_6: /* CIL Label */ 
#line 1858
  return ((char *)"Intel 80486");
  case_7: /* CIL Label */ 
#line 1859
  return ((char *)"Intel 80860");
  case_8: /* CIL Label */ 
#line 1860
  return ((char *)"MIPS R3000");
  case_9: /* CIL Label */ 
#line 1861
  return ((char *)"IBM System/370");
  case_10: /* CIL Label */ 
#line 1862
  return ((char *)"MIPS R4000 big-endian");
  case_11: /* CIL Label */ 
#line 1863
  return ((char *)"Sparc v9 (old)");
  case_15: /* CIL Label */ 
#line 1864
  return ((char *)"HPPA");
  case_17: /* CIL Label */ 
#line 1865
  return ((char *)"Power PC (old)");
  case_18: /* CIL Label */ 
#line 1866
  return ((char *)"Sparc v8+");
  case_19: /* CIL Label */ 
#line 1867
  return ((char *)"Intel 90860");
  case_20: /* CIL Label */ 
#line 1868
  return ((char *)"PowerPC");
  case_21: /* CIL Label */ 
#line 1869
  return ((char *)"PowerPC64");
  case_36: /* CIL Label */ 
#line 1870
  return ((char *)"NEC V800");
  case_37: /* CIL Label */ 
#line 1871
  return ((char *)"Fujitsu FR20");
  case_38: /* CIL Label */ 
#line 1872
  return ((char *)"TRW RH32");
  case_39: /* CIL Label */ 
#line 1873
  return ((char *)"MCORE");
  case_40: /* CIL Label */ 
#line 1874
  return ((char *)"ARM");
  case_41: /* CIL Label */ 
#line 1875
  return ((char *)"Digital Alpha (old)");
  case_42: /* CIL Label */ 
#line 1876
  return ((char *)"Renesas / SuperH SH");
  case_43: /* CIL Label */ 
#line 1877
  return ((char *)"Sparc v9");
  case_44: /* CIL Label */ 
#line 1878
  return ((char *)"Siemens Tricore");
  case_45: /* CIL Label */ 
#line 1879
  return ((char *)"ARC");
  case_46: /* CIL Label */ 
#line 1880
  return ((char *)"Renesas H8/300");
  case_47: /* CIL Label */ 
#line 1881
  return ((char *)"Renesas H8/300H");
  case_48: /* CIL Label */ 
#line 1882
  return ((char *)"Renesas H8S");
  case_49: /* CIL Label */ 
#line 1883
  return ((char *)"Renesas H8/500");
  case_50: /* CIL Label */ 
#line 1884
  return ((char *)"Intel IA-64");
  case_51: /* CIL Label */ 
#line 1885
  return ((char *)"Stanford MIPS-X");
  case_52: /* CIL Label */ 
#line 1886
  return ((char *)"Motorola Coldfire");
  case_36902: /* CIL Label */ 
#line 1887
  return ((char *)"Alpha");
  case_85: /* CIL Label */ 
  case_30288: /* CIL Label */ 
#line 1889
  return ((char *)"d10v");
  case_86: /* CIL Label */ 
  case_30326: /* CIL Label */ 
#line 1891
  return ((char *)"d30v");
  case_88: /* CIL Label */ 
  case_36929: /* CIL Label */ 
#line 1893
  return ((char *)"Renesas M32R (formerly Mitsubishi M32r)");
  case_87: /* CIL Label */ 
  case_36992: /* CIL Label */ 
#line 1895
  return ((char *)"Renesas V850");
  case_89: /* CIL Label */ 
  case_48879: /* CIL Label */ 
#line 1897
  return ((char *)"mn10300");
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 1899
  return ((char *)"mn10200");
  case_65261: /* CIL Label */ 
#line 1900
  return ((char *)"Moxie");
  case_84: /* CIL Label */ 
  case_13104: /* CIL Label */ 
#line 1902
  return ((char *)"Fujitsu FR30");
  case_21569: /* CIL Label */ 
#line 1903
  return ((char *)"Fujitsu FR-V");
  case_91: /* CIL Label */ 
  case_99: /* CIL Label */ 
#line 1905
  return ((char *)"picoJava");
  case_54: /* CIL Label */ 
#line 1906
  return ((char *)"Fujitsu Multimedia Accelerator");
  case_55: /* CIL Label */ 
#line 1907
  return ((char *)"Siemens PCP");
  case_56: /* CIL Label */ 
#line 1908
  return ((char *)"Sony nCPU embedded RISC processor");
  case_57: /* CIL Label */ 
#line 1909
  return ((char *)"Denso NDR1 microprocesspr");
  case_58: /* CIL Label */ 
#line 1910
  return ((char *)"Motorola Star*Core processor");
  case_59: /* CIL Label */ 
#line 1911
  return ((char *)"Toyota ME16 processor");
  case_60: /* CIL Label */ 
#line 1912
  return ((char *)"STMicroelectronics ST100 processor");
  case_61: /* CIL Label */ 
#line 1913
  return ((char *)"Advanced Logic Corp. TinyJ embedded processor");
  case_63: /* CIL Label */ 
#line 1914
  return ((char *)"Sony DSP processor");
  case_64: /* CIL Label */ 
#line 1915
  return ((char *)"Digital Equipment Corp. PDP-10");
  case_65: /* CIL Label */ 
#line 1916
  return ((char *)"Digital Equipment Corp. PDP-11");
  case_66: /* CIL Label */ 
#line 1917
  return ((char *)"Siemens FX66 microcontroller");
  case_67: /* CIL Label */ 
#line 1918
  return ((char *)"STMicroelectronics ST9+ 8/16 bit microcontroller");
  case_68: /* CIL Label */ 
#line 1919
  return ((char *)"STMicroelectronics ST7 8-bit microcontroller");
  case_69: /* CIL Label */ 
#line 1920
  return ((char *)"Motorola MC68HC16 Microcontroller");
  case_53: /* CIL Label */ 
#line 1921
  return ((char *)"Motorola MC68HC12 Microcontroller");
  case_70: /* CIL Label */ 
#line 1922
  return ((char *)"Motorola MC68HC11 Microcontroller");
  case_71: /* CIL Label */ 
#line 1923
  return ((char *)"Motorola MC68HC08 Microcontroller");
  case_72: /* CIL Label */ 
#line 1924
  return ((char *)"Motorola MC68HC05 Microcontroller");
  case_73: /* CIL Label */ 
#line 1925
  return ((char *)"Silicon Graphics SVx");
  case_74: /* CIL Label */ 
#line 1926
  return ((char *)"STMicroelectronics ST19 8-bit microcontroller");
  case_75: /* CIL Label */ 
#line 1927
  return ((char *)"Digital VAX");
  case_83: /* CIL Label */ 
  case_4183: /* CIL Label */ 
#line 1929
  return ((char *)"Atmel AVR 8-bit microcontroller");
  case_76: /* CIL Label */ 
#line 1930
  return ((char *)"Axis Communications 32-bit embedded processor");
  case_77: /* CIL Label */ 
#line 1931
  return ((char *)"Infineon Technologies 32-bit embedded cpu");
  case_78: /* CIL Label */ 
#line 1932
  return ((char *)"Element 14 64-bit DSP processor");
  case_79: /* CIL Label */ 
#line 1933
  return ((char *)"LSI Logic\'s 16-bit DSP processor");
  case_80: /* CIL Label */ 
#line 1934
  return ((char *)"Donald Knuth\'s educational 64-bit processor");
  case_81: /* CIL Label */ 
#line 1935
  return ((char *)"Harvard Universitys\'s machine-independent object format");
  case_82: /* CIL Label */ 
#line 1936
  return ((char *)"Vitesse Prism");
  case_62: /* CIL Label */ 
#line 1937
  return ((char *)"Advanced Micro Devices X86-64");
  case_180: /* CIL Label */ 
#line 1938
  return ((char *)"Intel L1OM");
  case_181: /* CIL Label */ 
#line 1939
  return ((char *)"Intel K1OM");
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 1941
  return ((char *)"IBM S/390");
  case_135: /* CIL Label */ 
#line 1942
  return ((char *)"SUNPLUS S+Core");
  case_44357: /* CIL Label */ 
#line 1943
  return ((char *)"Sanyo XStormy16 CPU core");
  case_33906: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 1945
  return ((char *)"OpenRISC");
  case_93: /* CIL Label */ 
#line 1946
  return ((char *)"ARC International ARCompact processor");
  case_114: /* CIL Label */ 
#line 1947
  return ((char *)"National Semiconductor CRX microprocessor");
  case_4643: /* CIL Label */ 
#line 1948
  return ((char *)"Adapteva EPIPHANY");
  case_23205: /* CIL Label */ 
#line 1949
  return ((char *)"OpenDLX");
  case_101: /* CIL Label */ 
  case_33303: /* CIL Label */ 
#line 1951
  return ((char *)"Ubicom IP2xxx 8-bit microcontrollers");
  case_65210: /* CIL Label */ 
#line 1952
  return ((char *)"Vitesse IQ2000");
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 1954
  return ((char *)"Tensilica Xtensa Processor");
  case_95: /* CIL Label */ 
#line 1955
  return ((char *)"Alphamosaic VideoCore processor");
  case_96: /* CIL Label */ 
#line 1956
  return ((char *)"Thompson Multimedia General Purpose Processor");
  case_97: /* CIL Label */ 
#line 1957
  return ((char *)"National Semiconductor 32000 series");
  case_98: /* CIL Label */ 
#line 1958
  return ((char *)"Tenor Network TPC processor");
  case_100: /* CIL Label */ 
#line 1959
  return ((char *)"STMicroelectronics ST200 microcontroller");
  case_102: /* CIL Label */ 
#line 1960
  return ((char *)"MAX Processor");
  case_103: /* CIL Label */ 
#line 1961
  return ((char *)"National Semiconductor CompactRISC");
  case_104: /* CIL Label */ 
#line 1962
  return ((char *)"Fujitsu F2MC16");
  case_105: /* CIL Label */ 
#line 1963
  return ((char *)"Texas Instruments msp430 microcontroller");
  case_138: /* CIL Label */ 
#line 1964
  return ((char *)"Lattice Mico32");
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
#line 1966
  return ((char *)"Renesas M32c");
  case_9520: /* CIL Label */ 
#line 1967
  return ((char *)"Morpho Techologies MT processor");
  case_106: /* CIL Label */ 
#line 1968
  return ((char *)"Analog Devices Blackfin");
  case_107: /* CIL Label */ 
#line 1969
  return ((char *)"S1C33 Family of Seiko Epson processors");
  case_108: /* CIL Label */ 
#line 1970
  return ((char *)"Sharp embedded microprocessor");
  case_109: /* CIL Label */ 
#line 1971
  return ((char *)"Arca RISC microprocessor");
  case_110: /* CIL Label */ 
#line 1972
  return ((char *)"Unicore");
  case_111: /* CIL Label */ 
#line 1973
  return ((char *)"eXcess 16/32/64-bit configurable embedded CPU");
  case_112: /* CIL Label */ 
#line 1974
  return ((char *)"Icera Semiconductor Inc. Deep Execution Processor");
  case_65211: /* CIL Label */ 
#line 1975
  return ((char *)"Altera Nios");
  case_113: /* CIL Label */ 
#line 1976
  return ((char *)"Altera Nios II");
  case_18056: /* CIL Label */ 
  case_116: /* CIL Label */ 
#line 1978
  return ((char *)"Infineon Technologies xc16x");
  case_117: /* CIL Label */ 
#line 1979
  return ((char *)"Renesas M16C series microprocessors");
  case_118: /* CIL Label */ 
#line 1980
  return ((char *)"Microchip Technology dsPIC30F Digital Signal Controller");
  case_119: /* CIL Label */ 
#line 1981
  return ((char *)"Freescale Communication Engine RISC core");
  case_131: /* CIL Label */ 
#line 1982
  return ((char *)"Altium TSK3000 core");
  case_132: /* CIL Label */ 
#line 1983
  return ((char *)"Freescale RS08 embedded processor");
  case_134: /* CIL Label */ 
#line 1984
  return ((char *)"Cyan Technology eCOG2 microprocessor");
  case_136: /* CIL Label */ 
#line 1985
  return ((char *)"New Japan Radio (NJR) 24-bit DSP Processor");
  case_137: /* CIL Label */ 
#line 1986
  return ((char *)"Broadcom VideoCore III processor");
  case_139: /* CIL Label */ 
#line 1987
  return ((char *)"Seiko Epson C17 family");
  case_140: /* CIL Label */ 
#line 1988
  return ((char *)"Texas Instruments TMS320C6000 DSP family");
  case_141: /* CIL Label */ 
#line 1989
  return ((char *)"Texas Instruments TMS320C2000 DSP family");
  case_142: /* CIL Label */ 
#line 1990
  return ((char *)"Texas Instruments TMS320C55x DSP family");
  case_160: /* CIL Label */ 
#line 1991
  return ((char *)"STMicroelectronics 64bit VLIW Data Signal Processor");
  case_161: /* CIL Label */ 
#line 1992
  return ((char *)"Cypress M8C microprocessor");
  case_162: /* CIL Label */ 
#line 1993
  return ((char *)"Renesas R32C series microprocessors");
  case_163: /* CIL Label */ 
#line 1994
  return ((char *)"NXP Semiconductors TriMedia architecture family");
  case_164: /* CIL Label */ 
#line 1995
  return ((char *)"QUALCOMM DSP6 Processor");
  case_165: /* CIL Label */ 
#line 1996
  return ((char *)"Intel 8051 and variants");
  case_166: /* CIL Label */ 
#line 1997
  return ((char *)"STMicroelectronics STxP7x family");
  case_167: /* CIL Label */ 
#line 1998
  return ((char *)"Andes Technology compact code size embedded RISC processor family");
  case_168: /* CIL Label */ 
#line 1999
  return ((char *)"Cyan Technology eCOG1X family");
  case_169: /* CIL Label */ 
#line 2000
  return ((char *)"Dallas Semiconductor MAXQ30 Core microcontrollers");
  case_170: /* CIL Label */ 
#line 2001
  return ((char *)"New Japan Radio (NJR) 16-bit DSP Processor");
  case_171: /* CIL Label */ 
#line 2002
  return ((char *)"M2000 Reconfigurable RISC Microprocessor");
  case_172: /* CIL Label */ 
#line 2003
  return ((char *)"Cray Inc. NV2 vector architecture");
  case_61453: /* CIL Label */ 
#line 2004
  return ((char *)"Toshiba MeP Media Engine");
  case_47787: /* CIL Label */ 
  case_189: /* CIL Label */ 
  case_177: /* CIL Label */ 
#line 2007
  return ((char *)"Xilinx MicroBlaze");
  case_197: /* CIL Label */ 
#line 2008
  return ((char *)"Renesas RL78");
  case_173: /* CIL Label */ 
#line 2009
  return ((char *)"Renesas RX");
  case_174: /* CIL Label */ 
#line 2010
  return ((char *)"Imagination Technologies META processor architecture");
  case_175: /* CIL Label */ 
#line 2011
  return ((char *)"MCST Elbrus general purpose hardware architecture");
  case_176: /* CIL Label */ 
#line 2012
  return ((char *)"Cyan Technology eCOG16 family");
  case_178: /* CIL Label */ 
#line 2013
  return ((char *)"Freescale Extended Time Processing Unit");
  case_179: /* CIL Label */ 
#line 2014
  return ((char *)"Infineon Technologies SLE9X core");
  case_185: /* CIL Label */ 
#line 2015
  return ((char *)"Atmel Corporation 32-bit microprocessor family");
  case_186: /* CIL Label */ 
#line 2016
  return ((char *)"STMicroeletronics STM8 8-bit microcontroller");
  case_187: /* CIL Label */ 
#line 2017
  return ((char *)"Tilera TILE64 multicore architecture family");
  case_188: /* CIL Label */ 
#line 2018
  return ((char *)"Tilera TILEPro multicore architecture family");
  case_191: /* CIL Label */ 
#line 2019
  return ((char *)"Tilera TILE-Gx multicore architecture family");
  case_190: /* CIL Label */ 
#line 2020
  return ((char *)"NVIDIA CUDA architecture");
  case_115: /* CIL Label */ 
#line 2021
  return ((char *)"Motorola XGATE embedded processor");
  switch_default: /* CIL Label */ 
  {
#line 2023
  tmp___1 = gettext("<unknown>: 0x%x");
#line 2023
  snprintf((char */* __restrict  */)(buff___2), sizeof(buff___2), (char const   */* __restrict  */)tmp___1,
           e_machine);
  }
#line 2024
  return (buff___2);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2028 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void decode_ARM_machine_flags(unsigned int e_flags , char *buf___4 ) 
{ 
  unsigned int eabi ;
  int unknown ;
  unsigned int flag ;
  unsigned int flag___0 ;
  unsigned int flag___1 ;
  unsigned int flag___2 ;
  char *tmp___0 ;

  {
#line 2032
  unknown = 0;
#line 2034
  eabi = e_flags & 4278190080U;
#line 2035
  e_flags &= 16777215U;
#line 2038
  if (e_flags & 1U) {
    {
#line 2040
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", relocatable executable");
#line 2041
    e_flags &= 4294967294U;
    }
  }
#line 2044
  if (e_flags & 2U) {
    {
#line 2046
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", has entry point");
#line 2047
    e_flags &= 4294967293U;
    }
  }
  {
#line 2059
  if (eabi == 16777216U) {
#line 2059
    goto case_16777216;
  }
#line 2082
  if (eabi == 33554432U) {
#line 2082
    goto case_33554432;
  }
#line 2113
  if (eabi == 50331648U) {
#line 2113
    goto case_50331648;
  }
#line 2117
  if (eabi == 67108864U) {
#line 2117
    goto case_67108864;
  }
#line 2121
  if (eabi == 83886080U) {
#line 2121
    goto case_83886080;
  }
#line 2149
  if (eabi == 0U) {
#line 2149
    goto case_0;
  }
#line 2053
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 2054
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", <unrecognized EABI>");
  }
#line 2055
  if (e_flags) {
#line 2056
    unknown = 1;
  }
#line 2057
  goto switch_break;
  case_16777216: /* CIL Label */ 
  {
#line 2060
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", Version1 EABI");
  }
  {
#line 2061
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2061
    if (! e_flags) {
#line 2061
      goto while_break;
    }
#line 2066
    flag = e_flags & - e_flags;
#line 2067
    e_flags &= ~ flag;
    {
#line 2071
    if (flag == 4U) {
#line 2071
      goto case_4;
    }
#line 2075
    goto switch_default___0;
    case_4: /* CIL Label */ 
    {
#line 2072
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", sorted symbol tables");
    }
#line 2073
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 2076
    unknown = 1;
#line 2077
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2080
  goto switch_break;
  case_33554432: /* CIL Label */ 
  {
#line 2083
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", Version2 EABI");
  }
  {
#line 2084
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2084
    if (! e_flags) {
#line 2084
      goto while_break___0;
    }
#line 2089
    flag___0 = e_flags & - e_flags;
#line 2090
    e_flags &= ~ flag___0;
    {
#line 2094
    if (flag___0 == 4U) {
#line 2094
      goto case_4___0;
    }
#line 2098
    if (flag___0 == 8U) {
#line 2098
      goto case_8;
    }
#line 2102
    if (flag___0 == 16U) {
#line 2102
      goto case_16;
    }
#line 2106
    goto switch_default___1;
    case_4___0: /* CIL Label */ 
    {
#line 2095
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", sorted symbol tables");
    }
#line 2096
    goto switch_break___1;
    case_8: /* CIL Label */ 
    {
#line 2099
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", dynamic symbols use segment index");
    }
#line 2100
    goto switch_break___1;
    case_16: /* CIL Label */ 
    {
#line 2103
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", mapping symbols precede others");
    }
#line 2104
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 2107
    unknown = 1;
#line 2108
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2111
  goto switch_break;
  case_50331648: /* CIL Label */ 
  {
#line 2114
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", Version3 EABI");
  }
#line 2115
  goto switch_break;
  case_67108864: /* CIL Label */ 
  {
#line 2118
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", Version4 EABI");
  }
#line 2119
  goto eabi;
  case_83886080: /* CIL Label */ 
  {
#line 2122
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", Version5 EABI");
  }
  eabi: 
  {
#line 2124
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2124
    if (! e_flags) {
#line 2124
      goto while_break___1;
    }
#line 2129
    flag___1 = e_flags & - e_flags;
#line 2130
    e_flags &= ~ flag___1;
    {
#line 2134
    if (flag___1 == 8388608U) {
#line 2134
      goto case_8388608;
    }
#line 2138
    if (flag___1 == 4194304U) {
#line 2138
      goto case_4194304;
    }
#line 2142
    goto switch_default___2;
    case_8388608: /* CIL Label */ 
    {
#line 2135
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", BE8");
    }
#line 2136
    goto switch_break___2;
    case_4194304: /* CIL Label */ 
    {
#line 2139
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", LE8");
    }
#line 2140
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2143
    unknown = 1;
#line 2144
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2147
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2150
  strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", GNU EABI");
  }
  {
#line 2151
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2151
    if (! e_flags) {
#line 2151
      goto while_break___2;
    }
#line 2156
    flag___2 = e_flags & - e_flags;
#line 2157
    e_flags &= ~ flag___2;
    {
#line 2161
    if (flag___2 == 4U) {
#line 2161
      goto case_4___1;
    }
#line 2165
    if (flag___2 == 8U) {
#line 2165
      goto case_8___0;
    }
#line 2169
    if (flag___2 == 16U) {
#line 2169
      goto case_16___0;
    }
#line 2173
    if (flag___2 == 32U) {
#line 2173
      goto case_32;
    }
#line 2177
    if (flag___2 == 64U) {
#line 2177
      goto case_64;
    }
#line 2181
    if (flag___2 == 128U) {
#line 2181
      goto case_128;
    }
#line 2185
    if (flag___2 == 256U) {
#line 2185
      goto case_256;
    }
#line 2189
    if (flag___2 == 512U) {
#line 2189
      goto case_512;
    }
#line 2193
    if (flag___2 == 1024U) {
#line 2193
      goto case_1024;
    }
#line 2197
    if (flag___2 == 2048U) {
#line 2197
      goto case_2048;
    }
#line 2201
    goto switch_default___3;
    case_4___1: /* CIL Label */ 
    {
#line 2162
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", interworking enabled");
    }
#line 2163
    goto switch_break___3;
    case_8___0: /* CIL Label */ 
    {
#line 2166
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", uses APCS/26");
    }
#line 2167
    goto switch_break___3;
    case_16___0: /* CIL Label */ 
    {
#line 2170
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", uses APCS/float");
    }
#line 2171
    goto switch_break___3;
    case_32: /* CIL Label */ 
    {
#line 2174
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", position independent");
    }
#line 2175
    goto switch_break___3;
    case_64: /* CIL Label */ 
    {
#line 2178
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", 8 bit structure alignment");
    }
#line 2179
    goto switch_break___3;
    case_128: /* CIL Label */ 
    {
#line 2182
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", uses new ABI");
    }
#line 2183
    goto switch_break___3;
    case_256: /* CIL Label */ 
    {
#line 2186
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", uses old ABI");
    }
#line 2187
    goto switch_break___3;
    case_512: /* CIL Label */ 
    {
#line 2190
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", software FP");
    }
#line 2191
    goto switch_break___3;
    case_1024: /* CIL Label */ 
    {
#line 2194
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", VFP");
    }
#line 2195
    goto switch_break___3;
    case_2048: /* CIL Label */ 
    {
#line 2198
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)", Maverick FP");
    }
#line 2199
    goto switch_break___3;
    switch_default___3: /* CIL Label */ 
#line 2202
    unknown = 1;
#line 2203
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 2208
  if (unknown) {
    {
#line 2209
    tmp___0 = gettext(", <unknown>");
#line 2209
    strcat((char */* __restrict  */)buf___4, (char const   */* __restrict  */)tmp___0);
    }
  }
#line 2210
  return;
}
}
#line 2215 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buf___3[1024]  ;
#line 2212 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *get_machine_flags(unsigned int e_flags , unsigned int e_machine ) 
{ 
  char const   *isa ;
  char *tmp___0 ;
  char const   *mac ;
  char *tmp___1 ;
  char const   *additional ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 2217
  buf___3[0] = (char )'\000';
#line 2219
  if (e_flags) {
    {
#line 2226
    if (e_machine == 40U) {
#line 2226
      goto case_40;
    }
#line 2230
    if (e_machine == 106U) {
#line 2230
      goto case_106;
    }
#line 2245
    if (e_machine == 21569U) {
#line 2245
      goto case_21569;
    }
#line 2286
    if (e_machine == 4U) {
#line 2286
      goto case_4;
    }
#line 2355
    if (e_machine == 20U) {
#line 2355
      goto case_20;
    }
#line 2367
    if (e_machine == 36992U) {
#line 2367
      goto case_36992;
    }
#line 2367
    if (e_machine == 87U) {
#line 2367
      goto case_36992;
    }
#line 2392
    if (e_machine == 36929U) {
#line 2392
      goto case_36929;
    }
#line 2392
    if (e_machine == 88U) {
#line 2392
      goto case_36929;
    }
#line 2398
    if (e_machine == 10U) {
#line 2398
      goto case_10;
    }
#line 2398
    if (e_machine == 8U) {
#line 2398
      goto case_10;
    }
#line 2491
    if (e_machine == 42U) {
#line 2491
      goto case_42;
    }
#line 2520
    if (e_machine == 43U) {
#line 2520
      goto case_43;
    }
#line 2546
    if (e_machine == 15U) {
#line 2546
      goto case_15;
    }
#line 2576
    if (e_machine == 99U) {
#line 2576
      goto case_99;
    }
#line 2576
    if (e_machine == 91U) {
#line 2576
      goto case_99;
    }
#line 2584
    if (e_machine == 50U) {
#line 2584
      goto case_50;
    }
#line 2620
    if (e_machine == 75U) {
#line 2620
      goto case_75;
    }
#line 2629
    if (e_machine == 173U) {
#line 2629
      goto case_173;
    }
#line 2638
    if (e_machine == 22U) {
#line 2638
      goto case_22___0;
    }
#line 2643
    if (e_machine == 140U) {
#line 2643
      goto case_140;
    }
#line 2223
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 2224
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 2227
    decode_ARM_machine_flags(e_flags, buf___3);
    }
#line 2228
    goto switch_break;
    case_106: /* CIL Label */ 
#line 2231
    if (e_flags & 1U) {
      {
#line 2232
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", PIC");
      }
    }
#line 2234
    if (e_flags & 2U) {
      {
#line 2235
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", FDPIC");
      }
    }
#line 2237
    if (e_flags & 16U) {
      {
#line 2238
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", code in L1");
      }
    }
#line 2240
    if (e_flags & 32U) {
      {
#line 2241
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", data in L1");
      }
    }
#line 2243
    goto switch_break;
    case_21569: /* CIL Label */ 
    {
#line 2248
    if ((e_flags & 4278190080U) == 0U) {
#line 2248
      goto case_0;
    }
#line 2255
    if ((e_flags & 4278190080U) == 33554432U) {
#line 2255
      goto case_33554432;
    }
#line 2259
    if ((e_flags & 4278190080U) == 83886080U) {
#line 2259
      goto case_83886080;
    }
#line 2262
    if ((e_flags & 4278190080U) == 117440512U) {
#line 2262
      goto case_117440512;
    }
#line 2266
    if ((e_flags & 4278190080U) == 134217728U) {
#line 2266
      goto case_134217728;
    }
#line 2270
    if ((e_flags & 4278190080U) == 16777216U) {
#line 2270
      goto case_16777216;
    }
#line 2273
    if ((e_flags & 4278190080U) == 100663296U) {
#line 2273
      goto case_100663296;
    }
#line 2277
    if ((e_flags & 4278190080U) == 50331648U) {
#line 2277
      goto case_50331648;
    }
#line 2280
    if ((e_flags & 4278190080U) == 67108864U) {
#line 2280
      goto case_67108864;
    }
#line 2251
    goto switch_default___0;
    case_0: /* CIL Label */ 
#line 2249
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 2252
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr???");
    }
#line 2253
    goto switch_break___0;
    case_33554432: /* CIL Label */ 
    {
#line 2256
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr300");
    }
#line 2257
    goto switch_break___0;
    case_83886080: /* CIL Label */ 
    {
#line 2260
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr400");
    }
#line 2261
    goto switch_break___0;
    case_117440512: /* CIL Label */ 
    {
#line 2263
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr405");
    }
#line 2264
    goto switch_break___0;
    case_134217728: /* CIL Label */ 
    {
#line 2267
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr450");
    }
#line 2268
    goto switch_break___0;
    case_16777216: /* CIL Label */ 
    {
#line 2271
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr500");
    }
#line 2272
    goto switch_break___0;
    case_100663296: /* CIL Label */ 
    {
#line 2274
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fr550");
    }
#line 2275
    goto switch_break___0;
    case_50331648: /* CIL Label */ 
    {
#line 2278
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", simple");
    }
#line 2279
    goto switch_break___0;
    case_67108864: /* CIL Label */ 
    {
#line 2281
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", tomcat");
    }
#line 2282
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 2284
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2287
    if ((e_flags & 58818560U) == 16777216U) {
      {
#line 2288
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", m68000");
      }
    } else
#line 2289
    if ((e_flags & 58818560U) == 8454144U) {
      {
#line 2290
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", cpu32");
      }
    } else
#line 2291
    if ((e_flags & 58818560U) == 33554432U) {
      {
#line 2292
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fido_a");
      }
    } else {
      {
#line 2295
      tmp___0 = gettext("unknown");
#line 2295
      isa = (char const   *)tmp___0;
#line 2296
      tmp___1 = gettext("unknown mac");
#line 2296
      mac = (char const   *)tmp___1;
#line 2297
      additional = (char const   *)((void *)0);
      }
      {
#line 2301
      if ((e_flags & 15U) == 1U) {
#line 2301
        goto case_1;
      }
#line 2305
      if ((e_flags & 15U) == 2U) {
#line 2305
        goto case_2;
      }
#line 2308
      if ((e_flags & 15U) == 3U) {
#line 2308
        goto case_3;
      }
#line 2311
      if ((e_flags & 15U) == 4U) {
#line 2311
        goto case_4___0;
      }
#line 2315
      if ((e_flags & 15U) == 5U) {
#line 2315
        goto case_5;
      }
#line 2318
      if ((e_flags & 15U) == 6U) {
#line 2318
        goto case_6;
      }
#line 2321
      if ((e_flags & 15U) == 7U) {
#line 2321
        goto case_7;
      }
#line 2299
      goto switch_break___1;
      case_1: /* CIL Label */ 
#line 2302
      isa = "A";
#line 2303
      additional = ", nodiv";
#line 2304
      goto switch_break___1;
      case_2: /* CIL Label */ 
#line 2306
      isa = "A";
#line 2307
      goto switch_break___1;
      case_3: /* CIL Label */ 
#line 2309
      isa = "A+";
#line 2310
      goto switch_break___1;
      case_4___0: /* CIL Label */ 
#line 2312
      isa = "B";
#line 2313
      additional = ", nousp";
#line 2314
      goto switch_break___1;
      case_5: /* CIL Label */ 
#line 2316
      isa = "B";
#line 2317
      goto switch_break___1;
      case_6: /* CIL Label */ 
#line 2319
      isa = "C";
#line 2320
      goto switch_break___1;
      case_7: /* CIL Label */ 
#line 2322
      isa = "C";
#line 2323
      additional = ", nodiv";
#line 2324
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
      {
#line 2326
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", cf, isa ");
#line 2327
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)isa);
      }
#line 2328
      if (additional) {
        {
#line 2329
        strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)additional);
        }
      }
#line 2330
      if (e_flags & 64U) {
        {
#line 2331
        strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", float");
        }
      }
      {
#line 2334
      if ((e_flags & 48U) == 0U) {
#line 2334
        goto case_0___0;
      }
#line 2337
      if ((e_flags & 48U) == 16U) {
#line 2337
        goto case_16;
      }
#line 2340
      if ((e_flags & 48U) == 32U) {
#line 2340
        goto case_32;
      }
#line 2343
      if ((e_flags & 48U) == 48U) {
#line 2343
        goto case_48;
      }
#line 2332
      goto switch_break___2;
      case_0___0: /* CIL Label */ 
#line 2335
      mac = (char const   *)((void *)0);
#line 2336
      goto switch_break___2;
      case_16: /* CIL Label */ 
#line 2338
      mac = "mac";
#line 2339
      goto switch_break___2;
      case_32: /* CIL Label */ 
#line 2341
      mac = "emac";
#line 2342
      goto switch_break___2;
      case_48: /* CIL Label */ 
#line 2344
      mac = "emac_b";
#line 2345
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 2347
      if (mac) {
        {
#line 2349
        strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", ");
#line 2350
        strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)mac);
        }
      }
    }
#line 2353
    goto switch_break;
    case_20: /* CIL Label */ 
#line 2356
    if (e_flags & 2147483648U) {
      {
#line 2357
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", emb");
      }
    }
#line 2359
    if (e_flags & 65536U) {
      {
#line 2360
      tmp___2 = gettext(", relocatable");
#line 2360
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___2);
      }
    }
#line 2362
    if (e_flags & 32768U) {
      {
#line 2363
      tmp___3 = gettext(", relocatable-lib");
#line 2363
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___3);
      }
    }
#line 2364
    goto switch_break;
    case_36992: /* CIL Label */ 
    case_87: /* CIL Label */ 
    {
#line 2370
    if ((e_flags & 4026531840U) == 1073741824U) {
#line 2370
      goto case_1073741824;
    }
#line 2373
    if ((e_flags & 4026531840U) == 805306368U) {
#line 2373
      goto case_805306368;
    }
#line 2376
    if ((e_flags & 4026531840U) == 536870912U) {
#line 2376
      goto case_536870912;
    }
#line 2379
    if ((e_flags & 4026531840U) == 268435456U) {
#line 2379
      goto case_268435456;
    }
#line 2382
    if ((e_flags & 4026531840U) == 0U) {
#line 2382
      goto case_0___1;
    }
#line 2385
    goto switch_default___1;
    case_1073741824: /* CIL Label */ 
    {
#line 2371
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", v850e2v3");
    }
#line 2372
    goto switch_break___3;
    case_805306368: /* CIL Label */ 
    {
#line 2374
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", v850e2");
    }
#line 2375
    goto switch_break___3;
    case_536870912: /* CIL Label */ 
    {
#line 2377
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", v850e1");
    }
#line 2378
    goto switch_break___3;
    case_268435456: /* CIL Label */ 
    {
#line 2380
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", v850e");
    }
#line 2381
    goto switch_break___3;
    case_0___1: /* CIL Label */ 
    {
#line 2383
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", v850");
    }
#line 2384
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
    {
#line 2386
    tmp___4 = gettext(", unknown v850 architecture variant");
#line 2386
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___4);
    }
#line 2387
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 2389
    goto switch_break;
    case_36929: /* CIL Label */ 
    case_88: /* CIL Label */ 
#line 2393
    if ((e_flags & 805306368U) == 0U) {
      {
#line 2394
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", m32r");
      }
    }
#line 2395
    goto switch_break;
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 2399
    if (e_flags & 1U) {
      {
#line 2400
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", noreorder");
      }
    }
#line 2402
    if (e_flags & 2U) {
      {
#line 2403
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", pic");
      }
    }
#line 2405
    if (e_flags & 4U) {
      {
#line 2406
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", cpic");
      }
    }
#line 2408
    if (e_flags & 16U) {
      {
#line 2409
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", ugen_reserved");
      }
    }
#line 2411
    if (e_flags & 32U) {
      {
#line 2412
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", abi2");
      }
    }
#line 2414
    if (e_flags & 128U) {
      {
#line 2415
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", odk first");
      }
    }
#line 2417
    if (e_flags & 256U) {
      {
#line 2418
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 32bitmode");
      }
    }
    {
#line 2422
    if ((e_flags & 16711680U) == 8454144U) {
#line 2422
      goto case_8454144;
    }
#line 2423
    if ((e_flags & 16711680U) == 8519680U) {
#line 2423
      goto case_8519680;
    }
#line 2424
    if ((e_flags & 16711680U) == 8585216U) {
#line 2424
      goto case_8585216;
    }
#line 2425
    if ((e_flags & 16711680U) == 8912896U) {
#line 2425
      goto case_8912896;
    }
#line 2426
    if ((e_flags & 16711680U) == 8847360U) {
#line 2426
      goto case_8847360;
    }
#line 2427
    if ((e_flags & 16711680U) == 8716288U) {
#line 2427
      goto case_8716288;
    }
#line 2428
    if ((e_flags & 16711680U) == 9502720U) {
#line 2428
      goto case_9502720;
    }
#line 2429
    if ((e_flags & 16711680U) == 9961472U) {
#line 2429
      goto case_9961472;
    }
#line 2430
    if ((e_flags & 16711680U) == 9043968U) {
#line 2430
      goto case_9043968;
    }
#line 2431
    if ((e_flags & 16711680U) == 10027008U) {
#line 2431
      goto case_10027008;
    }
#line 2432
    if ((e_flags & 16711680U) == 10485760U) {
#line 2432
      goto case_10485760;
    }
#line 2433
    if ((e_flags & 16711680U) == 10551296U) {
#line 2433
      goto case_10551296;
    }
#line 2434
    if ((e_flags & 16711680U) == 10616832U) {
#line 2434
      goto case_10616832;
    }
#line 2435
    if ((e_flags & 16711680U) == 9109504U) {
#line 2435
      goto case_9109504;
    }
#line 2436
    if ((e_flags & 16711680U) == 9240576U) {
#line 2436
      goto case_9240576;
    }
#line 2437
    if ((e_flags & 16711680U) == 9175040U) {
#line 2437
      goto case_9175040;
    }
#line 2438
    if ((e_flags & 16711680U) == 0U) {
#line 2438
      goto case_0___2;
    }
#line 2443
    goto switch_default___2;
    case_8454144: /* CIL Label */ 
    {
#line 2422
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 3900");
    }
#line 2422
    goto switch_break___4;
    case_8519680: /* CIL Label */ 
    {
#line 2423
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 4010");
    }
#line 2423
    goto switch_break___4;
    case_8585216: /* CIL Label */ 
    {
#line 2424
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 4100");
    }
#line 2424
    goto switch_break___4;
    case_8912896: /* CIL Label */ 
    {
#line 2425
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 4111");
    }
#line 2425
    goto switch_break___4;
    case_8847360: /* CIL Label */ 
    {
#line 2426
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 4120");
    }
#line 2426
    goto switch_break___4;
    case_8716288: /* CIL Label */ 
    {
#line 2427
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 4650");
    }
#line 2427
    goto switch_break___4;
    case_9502720: /* CIL Label */ 
    {
#line 2428
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 5400");
    }
#line 2428
    goto switch_break___4;
    case_9961472: /* CIL Label */ 
    {
#line 2429
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 5500");
    }
#line 2429
    goto switch_break___4;
    case_9043968: /* CIL Label */ 
    {
#line 2430
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sb1");
    }
#line 2430
    goto switch_break___4;
    case_10027008: /* CIL Label */ 
    {
#line 2431
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 9000");
    }
#line 2431
    goto switch_break___4;
    case_10485760: /* CIL Label */ 
    {
#line 2432
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", loongson-2e");
    }
#line 2432
    goto switch_break___4;
    case_10551296: /* CIL Label */ 
    {
#line 2433
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", loongson-2f");
    }
#line 2433
    goto switch_break___4;
    case_10616832: /* CIL Label */ 
    {
#line 2434
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", loongson-3a");
    }
#line 2434
    goto switch_break___4;
    case_9109504: /* CIL Label */ 
    {
#line 2435
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", octeon");
    }
#line 2435
    goto switch_break___4;
    case_9240576: /* CIL Label */ 
    {
#line 2436
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", octeon2");
    }
#line 2436
    goto switch_break___4;
    case_9175040: /* CIL Label */ 
    {
#line 2437
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", xlr");
    }
#line 2437
    goto switch_break___4;
    case_0___2: /* CIL Label */ 
#line 2442
    goto switch_break___4;
    switch_default___2: /* CIL Label */ 
    {
#line 2443
    tmp___5 = gettext(", unknown CPU");
#line 2443
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___5);
    }
#line 2443
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
    {
#line 2448
    if ((e_flags & 61440U) == 4096U) {
#line 2448
      goto case_4096;
    }
#line 2449
    if ((e_flags & 61440U) == 8192U) {
#line 2449
      goto case_8192;
    }
#line 2450
    if ((e_flags & 61440U) == 12288U) {
#line 2450
      goto case_12288;
    }
#line 2451
    if ((e_flags & 61440U) == 16384U) {
#line 2451
      goto case_16384;
    }
#line 2452
    if ((e_flags & 61440U) == 0U) {
#line 2452
      goto case_0___3;
    }
#line 2458
    goto switch_default___3;
    case_4096: /* CIL Label */ 
    {
#line 2448
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", o32");
    }
#line 2448
    goto switch_break___5;
    case_8192: /* CIL Label */ 
    {
#line 2449
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", o64");
    }
#line 2449
    goto switch_break___5;
    case_12288: /* CIL Label */ 
    {
#line 2450
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", eabi32");
    }
#line 2450
    goto switch_break___5;
    case_16384: /* CIL Label */ 
    {
#line 2451
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", eabi64");
    }
#line 2451
    goto switch_break___5;
    case_0___3: /* CIL Label */ 
#line 2457
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
    {
#line 2458
    tmp___6 = gettext(", unknown ABI");
#line 2458
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___6);
    }
#line 2458
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 2461
    if (e_flags & 134217728U) {
      {
#line 2462
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mdmx");
      }
    }
#line 2464
    if (e_flags & 67108864U) {
      {
#line 2465
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips16");
      }
    }
#line 2467
    if (e_flags & 33554432U) {
      {
#line 2468
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", micromips");
      }
    }
    {
#line 2472
    if ((e_flags & 4026531840U) == 0U) {
#line 2472
      goto case_0___4;
    }
#line 2473
    if ((e_flags & 4026531840U) == 268435456U) {
#line 2473
      goto case_268435456___0;
    }
#line 2474
    if ((e_flags & 4026531840U) == 536870912U) {
#line 2474
      goto case_536870912___0;
    }
#line 2475
    if ((e_flags & 4026531840U) == 805306368U) {
#line 2475
      goto case_805306368___0;
    }
#line 2476
    if ((e_flags & 4026531840U) == 1073741824U) {
#line 2476
      goto case_1073741824___0;
    }
#line 2477
    if ((e_flags & 4026531840U) == 1342177280U) {
#line 2477
      goto case_1342177280;
    }
#line 2478
    if ((e_flags & 4026531840U) == 1879048192U) {
#line 2478
      goto case_1879048192;
    }
#line 2479
    if ((e_flags & 4026531840U) == 1610612736U) {
#line 2479
      goto case_1610612736;
    }
#line 2480
    if ((e_flags & 4026531840U) == 2147483648U) {
#line 2480
      goto case_2147483648;
    }
#line 2481
    goto switch_default___4;
    case_0___4: /* CIL Label */ 
    {
#line 2472
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips1");
    }
#line 2472
    goto switch_break___6;
    case_268435456___0: /* CIL Label */ 
    {
#line 2473
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips2");
    }
#line 2473
    goto switch_break___6;
    case_536870912___0: /* CIL Label */ 
    {
#line 2474
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips3");
    }
#line 2474
    goto switch_break___6;
    case_805306368___0: /* CIL Label */ 
    {
#line 2475
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips4");
    }
#line 2475
    goto switch_break___6;
    case_1073741824___0: /* CIL Label */ 
    {
#line 2476
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips5");
    }
#line 2476
    goto switch_break___6;
    case_1342177280: /* CIL Label */ 
    {
#line 2477
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips32");
    }
#line 2477
    goto switch_break___6;
    case_1879048192: /* CIL Label */ 
    {
#line 2478
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips32r2");
    }
#line 2478
    goto switch_break___6;
    case_1610612736: /* CIL Label */ 
    {
#line 2479
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips64");
    }
#line 2479
    goto switch_break___6;
    case_2147483648: /* CIL Label */ 
    {
#line 2480
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", mips64r2");
    }
#line 2480
    goto switch_break___6;
    switch_default___4: /* CIL Label */ 
    {
#line 2481
    tmp___7 = gettext(", unknown ISA");
#line 2481
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___7);
    }
#line 2481
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 2484
    if (e_flags & 256U) {
      {
#line 2485
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", pic");
      }
    }
#line 2487
    if (e_flags & 32768U) {
      {
#line 2488
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", fdpic");
      }
    }
#line 2489
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 2494
    if ((e_flags & 31U) == 1U) {
#line 2494
      goto case_1___0;
    }
#line 2495
    if ((e_flags & 31U) == 2U) {
#line 2495
      goto case_2___0;
    }
#line 2496
    if ((e_flags & 31U) == 3U) {
#line 2496
      goto case_3___0;
    }
#line 2497
    if ((e_flags & 31U) == 4U) {
#line 2497
      goto case_4___1;
    }
#line 2498
    if ((e_flags & 31U) == 5U) {
#line 2498
      goto case_5___0;
    }
#line 2499
    if ((e_flags & 31U) == 6U) {
#line 2499
      goto case_6___0;
    }
#line 2500
    if ((e_flags & 31U) == 8U) {
#line 2500
      goto case_8___0;
    }
#line 2501
    if ((e_flags & 31U) == 9U) {
#line 2501
      goto case_9;
    }
#line 2502
    if ((e_flags & 31U) == 10U) {
#line 2502
      goto case_10___0;
    }
#line 2503
    if ((e_flags & 31U) == 11U) {
#line 2503
      goto case_11;
    }
#line 2504
    if ((e_flags & 31U) == 12U) {
#line 2504
      goto case_12;
    }
#line 2505
    if ((e_flags & 31U) == 13U) {
#line 2505
      goto case_13;
    }
#line 2506
    if ((e_flags & 31U) == 16U) {
#line 2506
      goto case_16___0;
    }
#line 2507
    if ((e_flags & 31U) == 17U) {
#line 2507
      goto case_17;
    }
#line 2508
    if ((e_flags & 31U) == 19U) {
#line 2508
      goto case_19;
    }
#line 2509
    if ((e_flags & 31U) == 20U) {
#line 2509
      goto case_20___0;
    }
#line 2510
    if ((e_flags & 31U) == 18U) {
#line 2510
      goto case_18;
    }
#line 2511
    if ((e_flags & 31U) == 21U) {
#line 2511
      goto case_21;
    }
#line 2512
    if ((e_flags & 31U) == 22U) {
#line 2512
      goto case_22;
    }
#line 2513
    if ((e_flags & 31U) == 23U) {
#line 2513
      goto case_23;
    }
#line 2514
    if ((e_flags & 31U) == 24U) {
#line 2514
      goto case_24;
    }
#line 2515
    goto switch_default___5;
    case_1___0: /* CIL Label */ 
    {
#line 2494
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh1");
    }
#line 2494
    goto switch_break___7;
    case_2___0: /* CIL Label */ 
    {
#line 2495
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2");
    }
#line 2495
    goto switch_break___7;
    case_3___0: /* CIL Label */ 
    {
#line 2496
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh3");
    }
#line 2496
    goto switch_break___7;
    case_4___1: /* CIL Label */ 
    {
#line 2497
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh-dsp");
    }
#line 2497
    goto switch_break___7;
    case_5___0: /* CIL Label */ 
    {
#line 2498
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh3-dsp");
    }
#line 2498
    goto switch_break___7;
    case_6___0: /* CIL Label */ 
    {
#line 2499
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh4al-dsp");
    }
#line 2499
    goto switch_break___7;
    case_8___0: /* CIL Label */ 
    {
#line 2500
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh3e");
    }
#line 2500
    goto switch_break___7;
    case_9: /* CIL Label */ 
    {
#line 2501
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh4");
    }
#line 2501
    goto switch_break___7;
    case_10___0: /* CIL Label */ 
    {
#line 2502
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh5");
    }
#line 2502
    goto switch_break___7;
    case_11: /* CIL Label */ 
    {
#line 2503
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2e");
    }
#line 2503
    goto switch_break___7;
    case_12: /* CIL Label */ 
    {
#line 2504
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh4a");
    }
#line 2504
    goto switch_break___7;
    case_13: /* CIL Label */ 
    {
#line 2505
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2a");
    }
#line 2505
    goto switch_break___7;
    case_16___0: /* CIL Label */ 
    {
#line 2506
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh4-nofpu");
    }
#line 2506
    goto switch_break___7;
    case_17: /* CIL Label */ 
    {
#line 2507
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh4a-nofpu");
    }
#line 2507
    goto switch_break___7;
    case_19: /* CIL Label */ 
    {
#line 2508
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2a-nofpu");
    }
#line 2508
    goto switch_break___7;
    case_20___0: /* CIL Label */ 
    {
#line 2509
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh3-nommu");
    }
#line 2509
    goto switch_break___7;
    case_18: /* CIL Label */ 
    {
#line 2510
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh4-nommu-nofpu");
    }
#line 2510
    goto switch_break___7;
    case_21: /* CIL Label */ 
    {
#line 2511
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2a-nofpu-or-sh4-nommu-nofpu");
    }
#line 2511
    goto switch_break___7;
    case_22: /* CIL Label */ 
    {
#line 2512
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2a-nofpu-or-sh3-nommu");
    }
#line 2512
    goto switch_break___7;
    case_23: /* CIL Label */ 
    {
#line 2513
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2a-or-sh4");
    }
#line 2513
    goto switch_break___7;
    case_24: /* CIL Label */ 
    {
#line 2514
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", sh2a-or-sh3e");
    }
#line 2514
    goto switch_break___7;
    switch_default___5: /* CIL Label */ 
    {
#line 2515
    tmp___8 = gettext(", unknown ISA");
#line 2515
    strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)tmp___8);
    }
#line 2515
    goto switch_break___7;
    switch_break___7: /* CIL Label */ ;
    }
#line 2518
    goto switch_break;
    case_43: /* CIL Label */ 
#line 2521
    if (e_flags & 256U) {
      {
#line 2522
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", v8+");
      }
    }
#line 2524
    if (e_flags & 512U) {
      {
#line 2525
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", ultrasparcI");
      }
    }
#line 2527
    if (e_flags & 2048U) {
      {
#line 2528
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", ultrasparcIII");
      }
    }
#line 2530
    if (e_flags & 1024U) {
      {
#line 2531
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", halr1");
      }
    }
#line 2533
    if (e_flags & 8388608U) {
      {
#line 2534
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", ledata");
      }
    }
#line 2536
    if ((e_flags & 3U) == 0U) {
      {
#line 2537
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", tso");
      }
    }
#line 2539
    if ((e_flags & 3U) == 1U) {
      {
#line 2540
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", pso");
      }
    }
#line 2542
    if ((e_flags & 3U) == 2U) {
      {
#line 2543
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", rmo");
      }
    }
#line 2544
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 2549
    if ((e_flags & 65535U) == 523U) {
#line 2549
      goto case_523;
    }
#line 2552
    if ((e_flags & 65535U) == 528U) {
#line 2552
      goto case_528;
    }
#line 2555
    if ((e_flags & 65535U) == 532U) {
#line 2555
      goto case_532;
    }
#line 2558
    goto switch_default___6;
    case_523: /* CIL Label */ 
    {
#line 2550
    strcpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", PA-RISC 1.0");
    }
#line 2551
    goto switch_break___8;
    case_528: /* CIL Label */ 
    {
#line 2553
    strcpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", PA-RISC 1.1");
    }
#line 2554
    goto switch_break___8;
    case_532: /* CIL Label */ 
    {
#line 2556
    strcpy((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", PA-RISC 2.0");
    }
#line 2557
    goto switch_break___8;
    switch_default___6: /* CIL Label */ 
#line 2559
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 2561
    if (e_flags & 65536U) {
      {
#line 2562
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", trapnil");
      }
    }
#line 2563
    if (e_flags & 131072U) {
      {
#line 2564
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", ext");
      }
    }
#line 2565
    if (e_flags & 262144U) {
      {
#line 2566
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", lsb");
      }
    }
#line 2567
    if (e_flags & 524288U) {
      {
#line 2568
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", wide");
      }
    }
#line 2569
    if (e_flags & 1048576U) {
      {
#line 2570
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", no kabp");
      }
    }
#line 2571
    if (e_flags & 4194304U) {
      {
#line 2572
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", lazyswap");
      }
    }
#line 2573
    goto switch_break;
    case_99: /* CIL Label */ 
    case_91: /* CIL Label */ 
#line 2577
    if ((e_flags & 16U) == 16U) {
      {
#line 2578
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", new calling convention");
      }
    }
#line 2580
    if ((e_flags & 32U) == 32U) {
      {
#line 2581
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", gnu calling convention");
      }
    }
#line 2582
    goto switch_break;
    case_50: /* CIL Label */ 
#line 2585
    if (e_flags & (unsigned int )(1 << 4)) {
      {
#line 2586
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 64-bit");
      }
    } else {
      {
#line 2588
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 32-bit");
      }
    }
#line 2589
    if (e_flags & (unsigned int )(1 << 5)) {
      {
#line 2590
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", reduced fp model");
      }
    }
#line 2591
    if (e_flags & (unsigned int )(1 << 7)) {
      {
#line 2592
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", no function descriptors, constant gp");
      }
    } else
#line 2593
    if (e_flags & (unsigned int )(1 << 6)) {
      {
#line 2594
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", constant gp");
      }
    }
#line 2595
    if (e_flags & (unsigned int )(1 << 8)) {
      {
#line 2596
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", absolute");
      }
    }
#line 2597
    if ((int )elf_header.e_ident[7] == 13) {
#line 2599
      if (e_flags & 4U) {
        {
#line 2600
        strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", vms_linkages");
        }
      }
      {
#line 2603
      if ((e_flags & 3U) == 0U) {
#line 2603
        goto case_0___5;
      }
#line 2605
      if ((e_flags & 3U) == 1U) {
#line 2605
        goto case_1___1;
      }
#line 2608
      if ((e_flags & 3U) == 2U) {
#line 2608
        goto case_2___1;
      }
#line 2611
      if ((e_flags & 3U) == 3U) {
#line 2611
        goto case_3___1;
      }
#line 2614
      goto switch_default___7;
      case_0___5: /* CIL Label */ 
#line 2604
      goto switch_break___9;
      case_1___1: /* CIL Label */ 
      {
#line 2606
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", warning");
      }
#line 2607
      goto switch_break___9;
      case_2___1: /* CIL Label */ 
      {
#line 2609
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", error");
      }
#line 2610
      goto switch_break___9;
      case_3___1: /* CIL Label */ 
      {
#line 2612
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", abort");
      }
#line 2613
      goto switch_break___9;
      switch_default___7: /* CIL Label */ 
      {
#line 2615
      abort();
      }
      switch_break___9: /* CIL Label */ ;
      }
    }
#line 2618
    goto switch_break;
    case_75: /* CIL Label */ 
#line 2621
    if (e_flags & 1U) {
      {
#line 2622
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", non-PIC");
      }
    }
#line 2623
    if (e_flags & 256U) {
      {
#line 2624
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", D-Float");
      }
    }
#line 2625
    if (e_flags & 512U) {
      {
#line 2626
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", G-Float");
      }
    }
#line 2627
    goto switch_break;
    case_173: /* CIL Label */ 
#line 2630
    if (e_flags & 1U) {
      {
#line 2631
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", 64-bit doubles");
      }
    }
#line 2632
    if (e_flags & (unsigned int )(1 << 1)) {
      {
#line 2633
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", dsp");
      }
    }
#line 2634
    if (e_flags & (unsigned int )(1 << 2)) {
      {
#line 2635
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", pid");
      }
    }
#line 2636
    goto switch_break;
    case_22___0: /* CIL Label */ 
#line 2639
    if (e_flags & 1U) {
      {
#line 2640
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", highgprs");
      }
    }
#line 2641
    goto switch_break;
    case_140: /* CIL Label */ 
#line 2644
    if (e_flags & 1U) {
      {
#line 2645
      strcat((char */* __restrict  */)(buf___3), (char const   */* __restrict  */)", relocatable module");
      }
    }
#line 2646
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 2650
  return (buf___3);
}
}
#line 2656 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___3[32]  ;
#line 2653 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_osabi_name(unsigned int osabi ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 2660
  if (osabi == 0U) {
#line 2660
    goto case_0;
  }
#line 2661
  if (osabi == 1U) {
#line 2661
    goto case_1;
  }
#line 2662
  if (osabi == 2U) {
#line 2662
    goto case_2;
  }
#line 2663
  if (osabi == 3U) {
#line 2663
    goto case_3;
  }
#line 2664
  if (osabi == 6U) {
#line 2664
    goto case_6;
  }
#line 2665
  if (osabi == 7U) {
#line 2665
    goto case_7;
  }
#line 2666
  if (osabi == 8U) {
#line 2666
    goto case_8;
  }
#line 2667
  if (osabi == 9U) {
#line 2667
    goto case_9;
  }
#line 2668
  if (osabi == 10U) {
#line 2668
    goto case_10;
  }
#line 2669
  if (osabi == 11U) {
#line 2669
    goto case_11;
  }
#line 2670
  if (osabi == 12U) {
#line 2670
    goto case_12;
  }
#line 2671
  if (osabi == 13U) {
#line 2671
    goto case_13;
  }
#line 2672
  if (osabi == 14U) {
#line 2672
    goto case_14;
  }
#line 2673
  if (osabi == 15U) {
#line 2673
    goto case_15;
  }
#line 2674
  if (osabi == 16U) {
#line 2674
    goto case_16;
  }
#line 2675
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2660
  return ("UNIX - System V");
  case_1: /* CIL Label */ 
#line 2661
  return ("UNIX - HP-UX");
  case_2: /* CIL Label */ 
#line 2662
  return ("UNIX - NetBSD");
  case_3: /* CIL Label */ 
#line 2663
  return ("UNIX - GNU");
  case_6: /* CIL Label */ 
#line 2664
  return ("UNIX - Solaris");
  case_7: /* CIL Label */ 
#line 2665
  return ("UNIX - AIX");
  case_8: /* CIL Label */ 
#line 2666
  return ("UNIX - IRIX");
  case_9: /* CIL Label */ 
#line 2667
  return ("UNIX - FreeBSD");
  case_10: /* CIL Label */ 
#line 2668
  return ("UNIX - TRU64");
  case_11: /* CIL Label */ 
#line 2669
  return ("Novell - Modesto");
  case_12: /* CIL Label */ 
#line 2670
  return ("UNIX - OpenBSD");
  case_13: /* CIL Label */ 
#line 2671
  return ("VMS - OpenVMS");
  case_14: /* CIL Label */ 
#line 2672
  return ("HP - Non-Stop Kernel");
  case_15: /* CIL Label */ 
#line 2673
  return ("AROS");
  case_16: /* CIL Label */ 
#line 2674
  return ("FenixOS");
  switch_default: /* CIL Label */ 
#line 2676
  if (osabi >= 64U) {
    {
#line 2679
    if ((int )elf_header.e_machine == 40) {
#line 2679
      goto case_40;
    }
#line 2689
    if ((int )elf_header.e_machine == 4185) {
#line 2689
      goto case_4185;
    }
#line 2689
    if ((int )elf_header.e_machine == 105) {
#line 2689
      goto case_4185;
    }
#line 2698
    if ((int )elf_header.e_machine == 140) {
#line 2698
      goto case_140;
    }
#line 2708
    goto switch_default___3;
    case_40: /* CIL Label */ 
    {
#line 2682
    if (osabi == 97U) {
#line 2682
      goto case_97;
    }
#line 2683
    goto switch_default___0;
    case_97: /* CIL Label */ 
#line 2682
    return ("ARM");
    switch_default___0: /* CIL Label */ 
#line 2684
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 2686
    goto switch_break___0;
    case_4185: /* CIL Label */ 
    case_105: /* CIL Label */ 
    {
#line 2692
    if (osabi == 255U) {
#line 2692
      goto case_255;
    }
#line 2693
    goto switch_default___1;
    case_255: /* CIL Label */ 
    {
#line 2692
    tmp___0 = gettext("Standalone App");
    }
#line 2692
    return ((char const   *)tmp___0);
    switch_default___1: /* CIL Label */ 
#line 2694
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 2696
    goto switch_break___0;
    case_140: /* CIL Label */ 
    {
#line 2701
    if (osabi == 64U) {
#line 2701
      goto case_64;
    }
#line 2702
    if (osabi == 65U) {
#line 2702
      goto case_65;
    }
#line 2703
    goto switch_default___2;
    case_64: /* CIL Label */ 
    {
#line 2701
    tmp___1 = gettext("Bare-metal C6000");
    }
#line 2701
    return ((char const   *)tmp___1);
    case_65: /* CIL Label */ 
#line 2702
    return ("Linux C6000");
    switch_default___2: /* CIL Label */ 
#line 2704
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 2706
    goto switch_break___0;
    switch_default___3: /* CIL Label */ 
#line 2709
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 2711
  tmp___2 = gettext("<unknown: %x>");
#line 2711
  snprintf((char */* __restrict  */)(buff___3), sizeof(buff___3), (char const   */* __restrict  */)tmp___2,
           osabi);
  }
#line 2712
  return ((char const   *)(buff___3));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2716 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_aarch64_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2721
  if (type == 1879048192UL) {
#line 2721
    goto case_1879048192;
  }
#line 2723
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2722
  return ("AARCH64_ARCHEXT");
  switch_default: /* CIL Label */ 
#line 2724
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2727
  return ((char const   *)((void *)0));
}
}
#line 2730 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_arm_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2735
  if (type == 1879048193UL) {
#line 2735
    goto case_1879048193;
  }
#line 2737
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 2736
  return ("EXIDX");
  switch_default: /* CIL Label */ 
#line 2738
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2741
  return ((char const   *)((void *)0));
}
}
#line 2744 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_mips_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2749
  if (type == 1879048192UL) {
#line 2749
    goto case_1879048192;
  }
#line 2751
  if (type == 1879048193UL) {
#line 2751
    goto case_1879048193;
  }
#line 2753
  if (type == 1879048194UL) {
#line 2753
    goto case_1879048194;
  }
#line 2755
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2750
  return ("REGINFO");
  case_1879048193: /* CIL Label */ 
#line 2752
  return ("RTPROC");
  case_1879048194: /* CIL Label */ 
#line 2754
  return ("OPTIONS");
  switch_default: /* CIL Label */ 
#line 2756
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2759
  return ((char const   *)((void *)0));
}
}
#line 2762 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_parisc_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2767
  if (type == 1610612736UL) {
#line 2767
    goto case_1610612736;
  }
#line 2768
  if (type == 1610612737UL) {
#line 2768
    goto case_1610612737;
  }
#line 2769
  if (type == 1610612738UL) {
#line 2769
    goto case_1610612738;
  }
#line 2770
  if (type == 1610612739UL) {
#line 2770
    goto case_1610612739;
  }
#line 2771
  if (type == 1610612740UL) {
#line 2771
    goto case_1610612740;
  }
#line 2772
  if (type == 1610612741UL) {
#line 2772
    goto case_1610612741;
  }
#line 2773
  if (type == 1610612742UL) {
#line 2773
    goto case_1610612742;
  }
#line 2774
  if (type == 1610612743UL) {
#line 2774
    goto case_1610612743;
  }
#line 2775
  if (type == 1610612744UL) {
#line 2775
    goto case_1610612744;
  }
#line 2776
  if (type == 1610612745UL) {
#line 2776
    goto case_1610612745;
  }
#line 2777
  if (type == 1610612752UL) {
#line 2777
    goto case_1610612752;
  }
#line 2778
  if (type == 1610612753UL) {
#line 2778
    goto case_1610612753;
  }
#line 2779
  if (type == 1610612754UL) {
#line 2779
    goto case_1610612754;
  }
#line 2780
  if (type == 1610612755UL) {
#line 2780
    goto case_1610612755;
  }
#line 2781
  if (type == 1610612756UL) {
#line 2781
    goto case_1610612756;
  }
#line 2782
  if (type == 1610612757UL) {
#line 2782
    goto case_1610612757;
  }
#line 2783
  if (type == 1879048192UL) {
#line 2783
    goto case_1879048192;
  }
#line 2784
  if (type == 1879048193UL) {
#line 2784
    goto case_1879048193;
  }
#line 2785
  if (type == 1879048194UL) {
#line 2785
    goto case_1879048194;
  }
#line 2786
  goto switch_default;
  case_1610612736: /* CIL Label */ 
#line 2767
  return ("HP_TLS");
  case_1610612737: /* CIL Label */ 
#line 2768
  return ("HP_CORE_NONE");
  case_1610612738: /* CIL Label */ 
#line 2769
  return ("HP_CORE_VERSION");
  case_1610612739: /* CIL Label */ 
#line 2770
  return ("HP_CORE_KERNEL");
  case_1610612740: /* CIL Label */ 
#line 2771
  return ("HP_CORE_COMM");
  case_1610612741: /* CIL Label */ 
#line 2772
  return ("HP_CORE_PROC");
  case_1610612742: /* CIL Label */ 
#line 2773
  return ("HP_CORE_LOADABLE");
  case_1610612743: /* CIL Label */ 
#line 2774
  return ("HP_CORE_STACK");
  case_1610612744: /* CIL Label */ 
#line 2775
  return ("HP_CORE_SHM");
  case_1610612745: /* CIL Label */ 
#line 2776
  return ("HP_CORE_MMF");
  case_1610612752: /* CIL Label */ 
#line 2777
  return ("HP_PARALLEL");
  case_1610612753: /* CIL Label */ 
#line 2778
  return ("HP_FASTBIND");
  case_1610612754: /* CIL Label */ 
#line 2779
  return ("HP_OPT_ANNOT");
  case_1610612755: /* CIL Label */ 
#line 2780
  return ("HP_HSL_ANNOT");
  case_1610612756: /* CIL Label */ 
#line 2781
  return ("HP_STACK");
  case_1610612757: /* CIL Label */ 
#line 2782
  return ("HP_CORE_UTSNAME");
  case_1879048192: /* CIL Label */ 
#line 2783
  return ("PARISC_ARCHEXT");
  case_1879048193: /* CIL Label */ 
#line 2784
  return ("PARISC_UNWIND");
  case_1879048194: /* CIL Label */ 
#line 2785
  return ("PARISC_WEAKORDER");
  switch_default: /* CIL Label */ 
#line 2787
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2790
  return ((char const   *)((void *)0));
}
}
#line 2793 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ia64_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2798
  if (type == 1879048192UL) {
#line 2798
    goto case_1879048192;
  }
#line 2799
  if (type == 1879048193UL) {
#line 2799
    goto case_1879048193;
  }
#line 2800
  if (type == 1610612736UL) {
#line 2800
    goto case_1610612736;
  }
#line 2801
  if (type == 1610612754UL) {
#line 2801
    goto case_1610612754;
  }
#line 2802
  if (type == 1610612755UL) {
#line 2802
    goto case_1610612755;
  }
#line 2803
  if (type == 1610612756UL) {
#line 2803
    goto case_1610612756;
  }
#line 2804
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2798
  return ("IA_64_ARCHEXT");
  case_1879048193: /* CIL Label */ 
#line 2799
  return ("IA_64_UNWIND");
  case_1610612736: /* CIL Label */ 
#line 2800
  return ("HP_TLS");
  case_1610612754: /* CIL Label */ 
#line 2801
  return ("HP_OPT_ANNOT");
  case_1610612755: /* CIL Label */ 
#line 2802
  return ("HP_HSL_ANNOT");
  case_1610612756: /* CIL Label */ 
#line 2803
  return ("HP_STACK");
  switch_default: /* CIL Label */ 
#line 2805
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2808
  return ((char const   *)((void *)0));
}
}
#line 2811 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_tic6x_segment_type(unsigned long type ) 
{ 


  {
  {
#line 2816
  if (type == 1879048192UL) {
#line 2816
    goto case_1879048192;
  }
#line 2817
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2816
  return ("C6000_PHATTR");
  switch_default: /* CIL Label */ 
#line 2818
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2821
  return ((char const   *)((void *)0));
}
}
#line 2827 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___4[32]  ;
#line 2824 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_segment_type(unsigned long p_type ) 
{ 
  char const   *result ;
  char const   *result___0 ;
  char *tmp___0 ;

  {
  {
#line 2831
  if (p_type == 0UL) {
#line 2831
    goto case_0;
  }
#line 2832
  if (p_type == 1UL) {
#line 2832
    goto case_1;
  }
#line 2833
  if (p_type == 2UL) {
#line 2833
    goto case_2;
  }
#line 2834
  if (p_type == 3UL) {
#line 2834
    goto case_3;
  }
#line 2835
  if (p_type == 4UL) {
#line 2835
    goto case_4;
  }
#line 2836
  if (p_type == 5UL) {
#line 2836
    goto case_5;
  }
#line 2837
  if (p_type == 6UL) {
#line 2837
    goto case_6;
  }
#line 2838
  if (p_type == 7UL) {
#line 2838
    goto case_7;
  }
#line 2840
  if (p_type == 1685382480UL) {
#line 2840
    goto case_1685382480;
  }
#line 2842
  if (p_type == 1685382481UL) {
#line 2842
    goto case_1685382481;
  }
#line 2843
  if (p_type == 1685382482UL) {
#line 2843
    goto case_1685382482;
  }
#line 2845
  goto switch_default;
  case_0: /* CIL Label */ 
#line 2831
  return ("NULL");
  case_1: /* CIL Label */ 
#line 2832
  return ("LOAD");
  case_2: /* CIL Label */ 
#line 2833
  return ("DYNAMIC");
  case_3: /* CIL Label */ 
#line 2834
  return ("INTERP");
  case_4: /* CIL Label */ 
#line 2835
  return ("NOTE");
  case_5: /* CIL Label */ 
#line 2836
  return ("SHLIB");
  case_6: /* CIL Label */ 
#line 2837
  return ("PHDR");
  case_7: /* CIL Label */ 
#line 2838
  return ("TLS");
  case_1685382480: /* CIL Label */ 
#line 2841
  return ("GNU_EH_FRAME");
  case_1685382481: /* CIL Label */ 
#line 2842
  return ("GNU_STACK");
  case_1685382482: /* CIL Label */ 
#line 2843
  return ("GNU_RELRO");
  switch_default: /* CIL Label */ 
#line 2846
  if (p_type >= 1879048192UL) {
#line 2846
    if (p_type <= 2147483647UL) {
      {
#line 2852
      if ((int )elf_header.e_machine == 183) {
#line 2852
        goto case_183;
      }
#line 2855
      if ((int )elf_header.e_machine == 40) {
#line 2855
        goto case_40;
      }
#line 2859
      if ((int )elf_header.e_machine == 10) {
#line 2859
        goto case_10;
      }
#line 2859
      if ((int )elf_header.e_machine == 8) {
#line 2859
        goto case_10;
      }
#line 2862
      if ((int )elf_header.e_machine == 15) {
#line 2862
        goto case_15;
      }
#line 2865
      if ((int )elf_header.e_machine == 50) {
#line 2865
        goto case_50;
      }
#line 2868
      if ((int )elf_header.e_machine == 140) {
#line 2868
        goto case_140;
      }
#line 2871
      goto switch_default___0;
      case_183: /* CIL Label */ 
      {
#line 2853
      result = get_aarch64_segment_type(p_type);
      }
#line 2854
      goto switch_break___0;
      case_40: /* CIL Label */ 
      {
#line 2856
      result = get_arm_segment_type(p_type);
      }
#line 2857
      goto switch_break___0;
      case_10: /* CIL Label */ 
      case_8: /* CIL Label */ 
      {
#line 2860
      result = get_mips_segment_type(p_type);
      }
#line 2861
      goto switch_break___0;
      case_15: /* CIL Label */ 
      {
#line 2863
      result = get_parisc_segment_type(p_type);
      }
#line 2864
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 2866
      result = get_ia64_segment_type(p_type);
      }
#line 2867
      goto switch_break___0;
      case_140: /* CIL Label */ 
      {
#line 2869
      result = get_tic6x_segment_type(p_type);
      }
#line 2870
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 2872
      result = (char const   *)((void *)0);
#line 2873
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 2876
      if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 2877
        return (result);
      }
      {
#line 2879
      sprintf((char */* __restrict  */)(buff___4), (char const   */* __restrict  */)"LOPROC+%lx",
              p_type - 1879048192UL);
      }
    } else {
#line 2846
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2881
  if (p_type >= 1610612736UL) {
#line 2881
    if (p_type <= 1879048191UL) {
      {
#line 2887
      if ((int )elf_header.e_machine == 15) {
#line 2887
        goto case_15___0;
      }
#line 2890
      if ((int )elf_header.e_machine == 50) {
#line 2890
        goto case_50___0;
      }
#line 2893
      goto switch_default___1;
      case_15___0: /* CIL Label */ 
      {
#line 2888
      result___0 = get_parisc_segment_type(p_type);
      }
#line 2889
      goto switch_break___1;
      case_50___0: /* CIL Label */ 
      {
#line 2891
      result___0 = get_ia64_segment_type(p_type);
      }
#line 2892
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 2894
      result___0 = (char const   *)((void *)0);
#line 2895
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 2898
      if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 2899
        return (result___0);
      }
      {
#line 2901
      sprintf((char */* __restrict  */)(buff___4), (char const   */* __restrict  */)"LOOS+%lx",
              p_type - 1610612736UL);
      }
    } else {
      {
#line 2904
      tmp___0 = gettext("<unknown>: %lx");
#line 2904
      snprintf((char */* __restrict  */)(buff___4), sizeof(buff___4), (char const   */* __restrict  */)tmp___0,
               p_type);
      }
    }
  } else {
    {
#line 2904
    tmp___0 = gettext("<unknown>: %lx");
#line 2904
    snprintf((char */* __restrict  */)(buff___4), sizeof(buff___4), (char const   */* __restrict  */)tmp___0,
             p_type);
    }
  }
#line 2906
  return ((char const   *)(buff___4));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2910 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_mips_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 2915
  if (sh_type == 1879048192U) {
#line 2915
    goto case_1879048192;
  }
#line 2916
  if (sh_type == 1879048193U) {
#line 2916
    goto case_1879048193;
  }
#line 2917
  if (sh_type == 1879048194U) {
#line 2917
    goto case_1879048194;
  }
#line 2918
  if (sh_type == 1879048195U) {
#line 2918
    goto case_1879048195;
  }
#line 2919
  if (sh_type == 1879048196U) {
#line 2919
    goto case_1879048196;
  }
#line 2920
  if (sh_type == 1879048197U) {
#line 2920
    goto case_1879048197;
  }
#line 2921
  if (sh_type == 1879048198U) {
#line 2921
    goto case_1879048198;
  }
#line 2922
  if (sh_type == 1879048199U) {
#line 2922
    goto case_1879048199;
  }
#line 2923
  if (sh_type == 1879048200U) {
#line 2923
    goto case_1879048200;
  }
#line 2924
  if (sh_type == 1879048201U) {
#line 2924
    goto case_1879048201;
  }
#line 2925
  if (sh_type == 1879048203U) {
#line 2925
    goto case_1879048203;
  }
#line 2926
  if (sh_type == 1879048204U) {
#line 2926
    goto case_1879048204;
  }
#line 2927
  if (sh_type == 1879048205U) {
#line 2927
    goto case_1879048205;
  }
#line 2928
  if (sh_type == 1879048208U) {
#line 2928
    goto case_1879048208;
  }
#line 2929
  if (sh_type == 1879048209U) {
#line 2929
    goto case_1879048209;
  }
#line 2930
  if (sh_type == 1879048210U) {
#line 2930
    goto case_1879048210;
  }
#line 2931
  if (sh_type == 1879048211U) {
#line 2931
    goto case_1879048211;
  }
#line 2932
  if (sh_type == 1879048212U) {
#line 2932
    goto case_1879048212;
  }
#line 2933
  if (sh_type == 1879048213U) {
#line 2933
    goto case_1879048213;
  }
#line 2934
  if (sh_type == 1879048214U) {
#line 2934
    goto case_1879048214;
  }
#line 2935
  if (sh_type == 1879048215U) {
#line 2935
    goto case_1879048215;
  }
#line 2936
  if (sh_type == 1879048216U) {
#line 2936
    goto case_1879048216;
  }
#line 2937
  if (sh_type == 1879048217U) {
#line 2937
    goto case_1879048217;
  }
#line 2938
  if (sh_type == 1879048218U) {
#line 2938
    goto case_1879048218;
  }
#line 2939
  if (sh_type == 1879048219U) {
#line 2939
    goto case_1879048219;
  }
#line 2940
  if (sh_type == 1879048220U) {
#line 2940
    goto case_1879048220;
  }
#line 2941
  if (sh_type == 1879048221U) {
#line 2941
    goto case_1879048221;
  }
#line 2942
  if (sh_type == 1879048222U) {
#line 2942
    goto case_1879048222;
  }
#line 2943
  if (sh_type == 1879048223U) {
#line 2943
    goto case_1879048223;
  }
#line 2944
  if (sh_type == 1879048224U) {
#line 2944
    goto case_1879048224;
  }
#line 2945
  if (sh_type == 1879048225U) {
#line 2945
    goto case_1879048225;
  }
#line 2946
  if (sh_type == 1879048226U) {
#line 2946
    goto case_1879048226;
  }
#line 2947
  if (sh_type == 1879048227U) {
#line 2947
    goto case_1879048227;
  }
#line 2948
  if (sh_type == 1879048228U) {
#line 2948
    goto case_1879048228;
  }
#line 2949
  if (sh_type == 1879048229U) {
#line 2949
    goto case_1879048229;
  }
#line 2950
  if (sh_type == 1879048230U) {
#line 2950
    goto case_1879048230;
  }
#line 2951
  if (sh_type == 1879048231U) {
#line 2951
    goto case_1879048231;
  }
#line 2952
  if (sh_type == 1879048232U) {
#line 2952
    goto case_1879048232;
  }
#line 2953
  if (sh_type == 1879048233U) {
#line 2953
    goto case_1879048233;
  }
#line 2954
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2915
  return ("MIPS_LIBLIST");
  case_1879048193: /* CIL Label */ 
#line 2916
  return ("MIPS_MSYM");
  case_1879048194: /* CIL Label */ 
#line 2917
  return ("MIPS_CONFLICT");
  case_1879048195: /* CIL Label */ 
#line 2918
  return ("MIPS_GPTAB");
  case_1879048196: /* CIL Label */ 
#line 2919
  return ("MIPS_UCODE");
  case_1879048197: /* CIL Label */ 
#line 2920
  return ("MIPS_DEBUG");
  case_1879048198: /* CIL Label */ 
#line 2921
  return ("MIPS_REGINFO");
  case_1879048199: /* CIL Label */ 
#line 2922
  return ("MIPS_PACKAGE");
  case_1879048200: /* CIL Label */ 
#line 2923
  return ("MIPS_PACKSYM");
  case_1879048201: /* CIL Label */ 
#line 2924
  return ("MIPS_RELD");
  case_1879048203: /* CIL Label */ 
#line 2925
  return ("MIPS_IFACE");
  case_1879048204: /* CIL Label */ 
#line 2926
  return ("MIPS_CONTENT");
  case_1879048205: /* CIL Label */ 
#line 2927
  return ("MIPS_OPTIONS");
  case_1879048208: /* CIL Label */ 
#line 2928
  return ("MIPS_SHDR");
  case_1879048209: /* CIL Label */ 
#line 2929
  return ("MIPS_FDESC");
  case_1879048210: /* CIL Label */ 
#line 2930
  return ("MIPS_EXTSYM");
  case_1879048211: /* CIL Label */ 
#line 2931
  return ("MIPS_DENSE");
  case_1879048212: /* CIL Label */ 
#line 2932
  return ("MIPS_PDESC");
  case_1879048213: /* CIL Label */ 
#line 2933
  return ("MIPS_LOCSYM");
  case_1879048214: /* CIL Label */ 
#line 2934
  return ("MIPS_AUXSYM");
  case_1879048215: /* CIL Label */ 
#line 2935
  return ("MIPS_OPTSYM");
  case_1879048216: /* CIL Label */ 
#line 2936
  return ("MIPS_LOCSTR");
  case_1879048217: /* CIL Label */ 
#line 2937
  return ("MIPS_LINE");
  case_1879048218: /* CIL Label */ 
#line 2938
  return ("MIPS_RFDESC");
  case_1879048219: /* CIL Label */ 
#line 2939
  return ("MIPS_DELTASYM");
  case_1879048220: /* CIL Label */ 
#line 2940
  return ("MIPS_DELTAINST");
  case_1879048221: /* CIL Label */ 
#line 2941
  return ("MIPS_DELTACLASS");
  case_1879048222: /* CIL Label */ 
#line 2942
  return ("MIPS_DWARF");
  case_1879048223: /* CIL Label */ 
#line 2943
  return ("MIPS_DELTADECL");
  case_1879048224: /* CIL Label */ 
#line 2944
  return ("MIPS_SYMBOL_LIB");
  case_1879048225: /* CIL Label */ 
#line 2945
  return ("MIPS_EVENTS");
  case_1879048226: /* CIL Label */ 
#line 2946
  return ("MIPS_TRANSLATE");
  case_1879048227: /* CIL Label */ 
#line 2947
  return ("MIPS_PIXIE");
  case_1879048228: /* CIL Label */ 
#line 2948
  return ("MIPS_XLATE");
  case_1879048229: /* CIL Label */ 
#line 2949
  return ("MIPS_XLATE_DEBUG");
  case_1879048230: /* CIL Label */ 
#line 2950
  return ("MIPS_WHIRL");
  case_1879048231: /* CIL Label */ 
#line 2951
  return ("MIPS_EH_REGION");
  case_1879048232: /* CIL Label */ 
#line 2952
  return ("MIPS_XLATE_OLD");
  case_1879048233: /* CIL Label */ 
#line 2953
  return ("MIPS_PDR_EXCEPTION");
  switch_default: /* CIL Label */ 
#line 2955
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2957
  return ((char const   *)((void *)0));
}
}
#line 2960 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_parisc_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 2965
  if (sh_type == 1879048192U) {
#line 2965
    goto case_1879048192;
  }
#line 2966
  if (sh_type == 1879048193U) {
#line 2966
    goto case_1879048193;
  }
#line 2967
  if (sh_type == 1879048194U) {
#line 2967
    goto case_1879048194;
  }
#line 2968
  if (sh_type == 1879048195U) {
#line 2968
    goto case_1879048195;
  }
#line 2969
  if (sh_type == 1879048200U) {
#line 2969
    goto case_1879048200;
  }
#line 2970
  if (sh_type == 1879048201U) {
#line 2970
    goto case_1879048201;
  }
#line 2971
  if (sh_type == 1879048196U) {
#line 2971
    goto case_1879048196;
  }
#line 2972
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2965
  return ("PARISC_EXT");
  case_1879048193: /* CIL Label */ 
#line 2966
  return ("PARISC_UNWIND");
  case_1879048194: /* CIL Label */ 
#line 2967
  return ("PARISC_DOC");
  case_1879048195: /* CIL Label */ 
#line 2968
  return ("PARISC_ANNOT");
  case_1879048200: /* CIL Label */ 
#line 2969
  return ("PARISC_SYMEXTN");
  case_1879048201: /* CIL Label */ 
#line 2970
  return ("PARISC_STUBS");
  case_1879048196: /* CIL Label */ 
#line 2971
  return ("PARISC_DLKM");
  switch_default: /* CIL Label */ 
#line 2973
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2975
  return ((char const   *)((void *)0));
}
}
#line 2978 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ia64_section_type_name(unsigned int sh_type ) 
{ 
  char const   *tmp___0 ;

  {
#line 2982
  if ((sh_type & 4278190080U) == 2013265920U) {
    {
#line 2983
    tmp___0 = get_osabi_name((sh_type & 16711680U) >> 16);
    }
#line 2983
    return (tmp___0);
  }
  {
#line 2987
  if (sh_type == 1879048192U) {
#line 2987
    goto case_1879048192;
  }
#line 2988
  if (sh_type == 1879048193U) {
#line 2988
    goto case_1879048193;
  }
#line 2989
  if (sh_type == 2030043136U) {
#line 2989
    goto case_2030043136;
  }
#line 2990
  if (sh_type == 1610612736U) {
#line 2990
    goto case_1610612736;
  }
#line 2991
  if (sh_type == 1610612737U) {
#line 2991
    goto case_1610612737;
  }
#line 2992
  if (sh_type == 1610612738U) {
#line 2992
    goto case_1610612738;
  }
#line 2993
  if (sh_type == 1610612739U) {
#line 2993
    goto case_1610612739;
  }
#line 2994
  if (sh_type == 1610612740U) {
#line 2994
    goto case_1610612740;
  }
#line 2995
  if (sh_type == 1610612741U) {
#line 2995
    goto case_1610612741;
  }
#line 2996
  if (sh_type == 1610612742U) {
#line 2996
    goto case_1610612742;
  }
#line 2997
  goto switch_default;
  case_1879048192: /* CIL Label */ 
#line 2987
  return ("IA_64_EXT");
  case_1879048193: /* CIL Label */ 
#line 2988
  return ("IA_64_UNWIND");
  case_2030043136: /* CIL Label */ 
#line 2989
  return ("IA_64_PRIORITY_INIT");
  case_1610612736: /* CIL Label */ 
#line 2990
  return ("VMS_TRACE");
  case_1610612737: /* CIL Label */ 
#line 2991
  return ("VMS_TIE_SIGNATURES");
  case_1610612738: /* CIL Label */ 
#line 2992
  return ("VMS_DEBUG");
  case_1610612739: /* CIL Label */ 
#line 2993
  return ("VMS_DEBUG_STR");
  case_1610612740: /* CIL Label */ 
#line 2994
  return ("VMS_LINKAGES");
  case_1610612741: /* CIL Label */ 
#line 2995
  return ("VMS_SYMBOL_VECTOR");
  case_1610612742: /* CIL Label */ 
#line 2996
  return ("VMS_FIXUP");
  switch_default: /* CIL Label */ 
#line 2998
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3000
  return ((char const   *)((void *)0));
}
}
#line 3003 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_x86_64_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3008
  if (sh_type == 1879048193U) {
#line 3008
    goto case_1879048193;
  }
#line 3009
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 3008
  return ("X86_64_UNWIND");
  switch_default: /* CIL Label */ 
#line 3010
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3012
  return ((char const   *)((void *)0));
}
}
#line 3015 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_aarch64_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3020
  if (sh_type == 1879048195U) {
#line 3020
    goto case_1879048195;
  }
#line 3022
  goto switch_default;
  case_1879048195: /* CIL Label */ 
#line 3021
  return ("AARCH64_ATTRIBUTES");
  switch_default: /* CIL Label */ 
#line 3023
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3025
  return ((char const   *)((void *)0));
}
}
#line 3028 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_arm_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3033
  if (sh_type == 1879048193U) {
#line 3033
    goto case_1879048193;
  }
#line 3034
  if (sh_type == 1879048194U) {
#line 3034
    goto case_1879048194;
  }
#line 3035
  if (sh_type == 1879048195U) {
#line 3035
    goto case_1879048195;
  }
#line 3036
  if (sh_type == 1879048196U) {
#line 3036
    goto case_1879048196;
  }
#line 3037
  if (sh_type == 1879048197U) {
#line 3037
    goto case_1879048197;
  }
#line 3038
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 3033
  return ("ARM_EXIDX");
  case_1879048194: /* CIL Label */ 
#line 3034
  return ("ARM_PREEMPTMAP");
  case_1879048195: /* CIL Label */ 
#line 3035
  return ("ARM_ATTRIBUTES");
  case_1879048196: /* CIL Label */ 
#line 3036
  return ("ARM_DEBUGOVERLAY");
  case_1879048197: /* CIL Label */ 
#line 3037
  return ("ARM_OVERLAYSECTION");
  switch_default: /* CIL Label */ 
#line 3039
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3041
  return ((char const   *)((void *)0));
}
}
#line 3044 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_tic6x_section_type_name(unsigned int sh_type ) 
{ 


  {
  {
#line 3049
  if (sh_type == 1879048193U) {
#line 3049
    goto case_1879048193;
  }
#line 3051
  if (sh_type == 1879048194U) {
#line 3051
    goto case_1879048194;
  }
#line 3053
  if (sh_type == 1879048195U) {
#line 3053
    goto case_1879048195;
  }
#line 3055
  if (sh_type == 2130706432U) {
#line 3055
    goto case_2130706432;
  }
#line 3057
  if (sh_type == 2130706433U) {
#line 3057
    goto case_2130706433;
  }
#line 3059
  if (sh_type == 2130706434U) {
#line 3059
    goto case_2130706434;
  }
#line 3061
  if (sh_type == 2130706435U) {
#line 3061
    goto case_2130706435;
  }
#line 3063
  if (sh_type == 2130706436U) {
#line 3063
    goto case_2130706436;
  }
#line 3065
  goto switch_default;
  case_1879048193: /* CIL Label */ 
#line 3050
  return ("C6000_UNWIND");
  case_1879048194: /* CIL Label */ 
#line 3052
  return ("C6000_PREEMPTMAP");
  case_1879048195: /* CIL Label */ 
#line 3054
  return ("C6000_ATTRIBUTES");
  case_2130706432: /* CIL Label */ 
#line 3056
  return ("TI_ICODE");
  case_2130706433: /* CIL Label */ 
#line 3058
  return ("TI_XREF");
  case_2130706434: /* CIL Label */ 
#line 3060
  return ("TI_HANDLER");
  case_2130706435: /* CIL Label */ 
#line 3062
  return ("TI_INITINFO");
  case_2130706436: /* CIL Label */ 
#line 3064
  return ("TI_PHATTRS");
  switch_default: /* CIL Label */ 
#line 3066
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3068
  return ((char const   *)((void *)0));
}
}
#line 3074 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___5[32]  ;
#line 3071 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_section_type_name(unsigned int sh_type ) 
{ 
  char const   *result ;
  char const   *result___0 ;
  char *tmp___0 ;

  {
  {
#line 3078
  if (sh_type == 0U) {
#line 3078
    goto case_0;
  }
#line 3079
  if (sh_type == 1U) {
#line 3079
    goto case_1;
  }
#line 3080
  if (sh_type == 2U) {
#line 3080
    goto case_2;
  }
#line 3081
  if (sh_type == 3U) {
#line 3081
    goto case_3;
  }
#line 3082
  if (sh_type == 4U) {
#line 3082
    goto case_4;
  }
#line 3083
  if (sh_type == 5U) {
#line 3083
    goto case_5;
  }
#line 3084
  if (sh_type == 6U) {
#line 3084
    goto case_6;
  }
#line 3085
  if (sh_type == 7U) {
#line 3085
    goto case_7;
  }
#line 3086
  if (sh_type == 8U) {
#line 3086
    goto case_8;
  }
#line 3087
  if (sh_type == 9U) {
#line 3087
    goto case_9;
  }
#line 3088
  if (sh_type == 10U) {
#line 3088
    goto case_10;
  }
#line 3089
  if (sh_type == 11U) {
#line 3089
    goto case_11;
  }
#line 3090
  if (sh_type == 14U) {
#line 3090
    goto case_14;
  }
#line 3091
  if (sh_type == 15U) {
#line 3091
    goto case_15;
  }
#line 3092
  if (sh_type == 16U) {
#line 3092
    goto case_16;
  }
#line 3093
  if (sh_type == 1879048182U) {
#line 3093
    goto case_1879048182;
  }
#line 3094
  if (sh_type == 17U) {
#line 3094
    goto case_17;
  }
#line 3095
  if (sh_type == 18U) {
#line 3095
    goto case_18;
  }
#line 3096
  if (sh_type == 1879048189U) {
#line 3096
    goto case_1879048189;
  }
#line 3097
  if (sh_type == 1879048190U) {
#line 3097
    goto case_1879048190;
  }
#line 3098
  if (sh_type == 1879048191U) {
#line 3098
    goto case_1879048191;
  }
#line 3099
  if (sh_type == 1879048176U) {
#line 3099
    goto case_1879048176;
  }
#line 3100
  if (sh_type == 1879048188U) {
#line 3100
    goto case_1879048188;
  }
#line 3101
  if (sh_type == 2147483645U) {
#line 3101
    goto case_2147483645;
  }
#line 3102
  if (sh_type == 2147483647U) {
#line 3102
    goto case_2147483647;
  }
#line 3103
  if (sh_type == 1879048183U) {
#line 3103
    goto case_1879048183;
  }
#line 3105
  goto switch_default;
  case_0: /* CIL Label */ 
#line 3078
  return ("NULL");
  case_1: /* CIL Label */ 
#line 3079
  return ("PROGBITS");
  case_2: /* CIL Label */ 
#line 3080
  return ("SYMTAB");
  case_3: /* CIL Label */ 
#line 3081
  return ("STRTAB");
  case_4: /* CIL Label */ 
#line 3082
  return ("RELA");
  case_5: /* CIL Label */ 
#line 3083
  return ("HASH");
  case_6: /* CIL Label */ 
#line 3084
  return ("DYNAMIC");
  case_7: /* CIL Label */ 
#line 3085
  return ("NOTE");
  case_8: /* CIL Label */ 
#line 3086
  return ("NOBITS");
  case_9: /* CIL Label */ 
#line 3087
  return ("REL");
  case_10: /* CIL Label */ 
#line 3088
  return ("SHLIB");
  case_11: /* CIL Label */ 
#line 3089
  return ("DYNSYM");
  case_14: /* CIL Label */ 
#line 3090
  return ("INIT_ARRAY");
  case_15: /* CIL Label */ 
#line 3091
  return ("FINI_ARRAY");
  case_16: /* CIL Label */ 
#line 3092
  return ("PREINIT_ARRAY");
  case_1879048182: /* CIL Label */ 
#line 3093
  return ("GNU_HASH");
  case_17: /* CIL Label */ 
#line 3094
  return ("GROUP");
  case_18: /* CIL Label */ 
#line 3095
  return ("SYMTAB SECTION INDICIES");
  case_1879048189: /* CIL Label */ 
#line 3096
  return ("VERDEF");
  case_1879048190: /* CIL Label */ 
#line 3097
  return ("VERNEED");
  case_1879048191: /* CIL Label */ 
#line 3098
  return ("VERSYM");
  case_1879048176: /* CIL Label */ 
#line 3099
  return ("VERSYM");
  case_1879048188: /* CIL Label */ 
#line 3100
  return ("VERDEF");
  case_2147483645: /* CIL Label */ 
#line 3101
  return ("AUXILIARY");
  case_2147483647: /* CIL Label */ 
#line 3102
  return ("FILTER");
  case_1879048183: /* CIL Label */ 
#line 3103
  return ("GNU_LIBLIST");
  switch_default: /* CIL Label */ 
#line 3106
  if (sh_type >= 1879048192U) {
#line 3106
    if (sh_type <= 2147483647U) {
      {
#line 3113
      if ((int )elf_header.e_machine == 10) {
#line 3113
        goto case_10___0;
      }
#line 3113
      if ((int )elf_header.e_machine == 8) {
#line 3113
        goto case_10___0;
      }
#line 3116
      if ((int )elf_header.e_machine == 15) {
#line 3116
        goto case_15___0;
      }
#line 3119
      if ((int )elf_header.e_machine == 50) {
#line 3119
        goto case_50;
      }
#line 3124
      if ((int )elf_header.e_machine == 181) {
#line 3124
        goto case_181;
      }
#line 3124
      if ((int )elf_header.e_machine == 180) {
#line 3124
        goto case_181;
      }
#line 3124
      if ((int )elf_header.e_machine == 62) {
#line 3124
        goto case_181;
      }
#line 3127
      if ((int )elf_header.e_machine == 183) {
#line 3127
        goto case_183;
      }
#line 3130
      if ((int )elf_header.e_machine == 40) {
#line 3130
        goto case_40;
      }
#line 3133
      if ((int )elf_header.e_machine == 140) {
#line 3133
        goto case_140;
      }
#line 3136
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
      case_8___0: /* CIL Label */ 
      {
#line 3114
      result = get_mips_section_type_name(sh_type);
      }
#line 3115
      goto switch_break___0;
      case_15___0: /* CIL Label */ 
      {
#line 3117
      result = get_parisc_section_type_name(sh_type);
      }
#line 3118
      goto switch_break___0;
      case_50: /* CIL Label */ 
      {
#line 3120
      result = get_ia64_section_type_name(sh_type);
      }
#line 3121
      goto switch_break___0;
      case_181: /* CIL Label */ 
      case_180: /* CIL Label */ 
      case_62: /* CIL Label */ 
      {
#line 3125
      result = get_x86_64_section_type_name(sh_type);
      }
#line 3126
      goto switch_break___0;
      case_183: /* CIL Label */ 
      {
#line 3128
      result = get_aarch64_section_type_name(sh_type);
      }
#line 3129
      goto switch_break___0;
      case_40: /* CIL Label */ 
      {
#line 3131
      result = get_arm_section_type_name(sh_type);
      }
#line 3132
      goto switch_break___0;
      case_140: /* CIL Label */ 
      {
#line 3134
      result = get_tic6x_section_type_name(sh_type);
      }
#line 3135
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 3137
      result = (char const   *)((void *)0);
#line 3138
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 3141
      if ((unsigned long )result != (unsigned long )((void *)0)) {
#line 3142
        return (result);
      }
      {
#line 3144
      sprintf((char */* __restrict  */)(buff___5), (char const   */* __restrict  */)"LOPROC+%x",
              sh_type - 1879048192U);
      }
    } else {
#line 3106
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3146
  if (sh_type >= 1610612736U) {
#line 3146
    if (sh_type <= 1879048191U) {
      {
#line 3152
      if ((int )elf_header.e_machine == 50) {
#line 3152
        goto case_50___0;
      }
#line 3155
      goto switch_default___1;
      case_50___0: /* CIL Label */ 
      {
#line 3153
      result___0 = get_ia64_section_type_name(sh_type);
      }
#line 3154
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 3156
      result___0 = (char const   *)((void *)0);
#line 3157
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 3160
      if ((unsigned long )result___0 != (unsigned long )((void *)0)) {
#line 3161
        return (result___0);
      }
      {
#line 3163
      sprintf((char */* __restrict  */)(buff___5), (char const   */* __restrict  */)"LOOS+%x",
              sh_type - 1610612736U);
      }
    } else {
#line 3146
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3165
  if (sh_type >= 2147483648U) {
#line 3165
    if (sh_type <= 4294967295U) {
      {
#line 3166
      sprintf((char */* __restrict  */)(buff___5), (char const   */* __restrict  */)"LOUSER+%x",
              sh_type - 2147483648U);
      }
    } else {
      {
#line 3170
      tmp___0 = gettext("%08x: <unknown>");
#line 3170
      snprintf((char */* __restrict  */)(buff___5), sizeof(buff___5), (char const   */* __restrict  */)tmp___0,
               sh_type);
      }
    }
  } else {
    {
#line 3170
    tmp___0 = gettext("%08x: <unknown>");
#line 3170
    snprintf((char */* __restrict  */)(buff___5), sizeof(buff___5), (char const   */* __restrict  */)tmp___0,
             sh_type);
    }
  }
#line 3172
  return ((char const   *)(buff___5));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct option options[33]  = 
#line 3182
  {      {"all", 0, (int *)0, 'a'}, 
        {"file-header", 0, (int *)0, 'h'}, 
        {"program-headers", 0, (int *)0, 'l'}, 
        {"headers", 0, (int *)0, 'e'}, 
        {"histogram", 0, (int *)0, 'I'}, 
        {"segments", 0, (int *)0, 'l'}, 
        {"sections", 0, (int *)0, 'S'}, 
        {"section-headers", 0, (int *)0, 'S'}, 
        {"section-groups", 0, (int *)0, 'g'}, 
        {"section-details", 0, (int *)0, 't'}, 
        {"full-section-name", 0, (int *)0, 'N'}, 
        {"symbols", 0, (int *)0, 's'}, 
        {"syms", 0, (int *)0, 's'}, 
        {"dyn-syms", 0, (int *)0, 513}, 
        {"relocs", 0, (int *)0, 'r'}, 
        {"notes", 0, (int *)0, 'n'}, 
        {"dynamic", 0, (int *)0, 'd'}, 
        {"arch-specific", 0, (int *)0, 'A'}, 
        {"version-info", 0, (int *)0, 'V'}, 
        {"use-dynamic", 0, (int *)0, 'D'}, 
        {"unwind", 0, (int *)0, 'u'}, 
        {"archive-index", 0, (int *)0, 'c'}, 
        {"hex-dump", 1, (int *)0, 'x'}, 
        {"relocated-dump", 1, (int *)0, 'R'}, 
        {"string-dump", 1, (int *)0, 'p'}, 
        {"debug-dump", 2, (int *)0, 512}, 
        {"dwarf-depth", 1, (int *)0, 514}, 
        {"dwarf-start", 1, (int *)0, 515}, 
        {"dwarf-check", 0, (int *)0, 516}, 
        {"version", 0, (int *)0, 'v'}, 
        {"wide", 0, (int *)0, 'W'}, 
        {"help", 0, (int *)0, 'H'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 3224 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void usage(FILE *stream ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3227
  tmp___0 = gettext("Usage: readelf <option(s)> elf-file(s)\n");
#line 3227
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___0);
#line 3228
  tmp___1 = gettext(" Display information about the contents of ELF format files\n");
#line 3228
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1);
#line 3229
  tmp___2 = gettext(" Options are:\n  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n  -h --file-header       Display the ELF file header\n  -l --program-headers   Display the program headers\n     --segments          An alias for --program-headers\n  -S --section-headers   Display the sections\' header\n     --sections          An alias for --section-headers\n  -g --section-groups    Display the section groups\n  -t --section-details   Display the section details\n  -e --headers           Equivalent to: -h -l -S\n  -s --syms              Display the symbol table\n     --symbols           An alias for --syms\n  --dyn-syms             Display the dynamic symbol table\n  -n --notes             Display the core notes (if present)\n  -r --relocs            Display the relocations (if present)\n  -u --unwind            Display the unwind info (if present)\n  -d --dynamic           Display the dynamic section (if present)\n  -V --version-info      Display the version sections (if present)\n  -A --arch-specific     Display architecture specific information (if any)\n  -c --archive-index     Display the symbol/file index in an archive\n  -D --use-dynamic       Use the dynamic section info when displaying symbols\n  -x --hex-dump=<number|name>\n                         Dump the contents of section <number|name> as bytes\n  -p --string-dump=<number|name>\n                         Dump the contents of section <number|name> as strings\n  -R --relocated-dump=<number|name>\n                         Dump the contents of section <number|name> as relocated bytes\n  -w[lLiaprmfFsoRt] or\n  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n               =frames-interp,=str,=loc,=Ranges,=pubtypes,\n               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges]\n                         Display the contents of DWARF2 debug sections\n");
#line 3229
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2);
#line 3261
  tmp___3 = gettext("  --dwarf-depth=N        Do not display DIEs at depth N or greater\n  --dwarf-start=N        Display DIEs starting with N, at the same depth\n                         or deeper\n");
#line 3261
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3);
#line 3270
  tmp___4 = gettext("  -I --histogram         Display histogram of bucket list lengths\n  -W --wide              Allow output width to exceed 80 characters\n  @<file>                Read options from <file>\n  -H --help              Display this information\n  -v --version           Display the version number of readelf\n");
#line 3270
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4);
  }
#line 3277
  if (*("<http://www.sourceware.org/bugzilla/>" + 0)) {
#line 3277
    if ((unsigned long )stream == (unsigned long )stdout) {
      {
#line 3278
      tmp___5 = gettext("Report bugs to %s\n");
#line 3278
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)tmp___5,
              "<http://www.sourceware.org/bugzilla/>");
      }
    }
  }
#line 3280
  if ((unsigned long )stream == (unsigned long )stdout) {
#line 3280
    tmp___6 = 0;
  } else {
#line 3280
    tmp___6 = 1;
  }
  {
#line 3280
  exit(tmp___6);
  }
}
}
#line 3288 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void request_dump_bynumber(unsigned int section , dump_type type ) 
{ 
  dump_type *new_dump_sects ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 3291
  if (section >= num_dump_sects) {
    {
#line 3295
    tmp___0 = calloc((size_t )(section + 1U), sizeof(*dump_sects));
#line 3295
    new_dump_sects = (dump_type *)tmp___0;
    }
#line 3298
    if ((unsigned long )new_dump_sects == (unsigned long )((void *)0)) {
      {
#line 3299
      tmp___1 = gettext("Out of memory allocating dump request table.\n");
#line 3299
      error((char const   *)tmp___1);
      }
    } else {
      {
#line 3303
      memcpy((void */* __restrict  */)new_dump_sects, (void const   */* __restrict  */)dump_sects,
             (unsigned long )num_dump_sects * sizeof(*dump_sects));
#line 3305
      free((void *)dump_sects);
#line 3307
      dump_sects = new_dump_sects;
#line 3308
      num_dump_sects = section + 1U;
      }
    }
  }
#line 3312
  if (dump_sects) {
#line 3313
    *(dump_sects + section) = (dump_type )((int )*(dump_sects + section) | (int )type);
  }
#line 3315
  return;
}
}
#line 3320 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void request_dump_byname(char const   *section , dump_type type ) 
{ 
  struct dump_list_entry *new_request ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 3325
  tmp___0 = malloc(sizeof(struct dump_list_entry ));
#line 3325
  new_request = (struct dump_list_entry *)tmp___0;
  }
#line 3327
  if (! new_request) {
    {
#line 3328
    tmp___1 = gettext("Out of memory allocating dump request table.\n");
#line 3328
    error((char const   *)tmp___1);
    }
  }
  {
#line 3330
  new_request->name = strdup(section);
  }
#line 3331
  if (! new_request->name) {
    {
#line 3332
    tmp___2 = gettext("Out of memory allocating dump request table.\n");
#line 3332
    error((char const   *)tmp___2);
    }
  }
#line 3334
  new_request->type = type;
#line 3336
  new_request->next = dump_sects_byname;
#line 3337
  dump_sects_byname = new_request;
#line 3338
  return;
}
}
#line 3340 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
__inline static void request_dump(dump_type type ) 
{ 
  int section ;
  char *cp ;
  unsigned long tmp___0 ;

  {
  {
#line 3346
  do_dump ++;
#line 3347
  tmp___0 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& cp),
                    0);
#line 3347
  section = (int )tmp___0;
  }
#line 3349
  if (! *cp) {
#line 3349
    if (section >= 0) {
      {
#line 3350
      request_dump_bynumber((unsigned int )section, type);
      }
    } else {
      {
#line 3352
      request_dump_byname((char const   *)optarg, type);
      }
    }
  } else {
    {
#line 3352
    request_dump_byname((char const   *)optarg, type);
    }
  }
#line 3353
  return;
}
}
#line 3356 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void parse_args(int argc , char **argv ) 
{ 
  int c ;
  char *cp ;
  unsigned long tmp___0 ;
  char *cp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 3361
  if (argc < 2) {
    {
#line 3362
    usage(stderr);
    }
  }
  {
#line 3364
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3364
    c = getopt_long(argc, (char * const  *)argv, "ADHINR:SVWacdeghi:lnp:rstuvw::x:",
                    (struct option  const  *)(options), (int *)((void *)0));
    }
#line 3364
    if (! (c != -1)) {
#line 3364
      goto while_break;
    }
    {
#line 3369
    if (c == 0) {
#line 3369
      goto case_0;
    }
#line 3372
    if (c == 72) {
#line 3372
      goto case_72;
    }
#line 3376
    if (c == 97) {
#line 3376
      goto case_97;
    }
#line 3390
    if (c == 103) {
#line 3390
      goto case_103;
    }
#line 3394
    if (c == 78) {
#line 3394
      goto case_78;
    }
#line 3394
    if (c == 116) {
#line 3394
      goto case_78;
    }
#line 3398
    if (c == 101) {
#line 3398
      goto case_101;
    }
#line 3403
    if (c == 65) {
#line 3403
      goto case_65;
    }
#line 3406
    if (c == 68) {
#line 3406
      goto case_68;
    }
#line 3409
    if (c == 114) {
#line 3409
      goto case_114;
    }
#line 3412
    if (c == 117) {
#line 3412
      goto case_117;
    }
#line 3415
    if (c == 104) {
#line 3415
      goto case_104;
    }
#line 3418
    if (c == 108) {
#line 3418
      goto case_108;
    }
#line 3421
    if (c == 115) {
#line 3421
      goto case_115;
    }
#line 3424
    if (c == 83) {
#line 3424
      goto case_83;
    }
#line 3427
    if (c == 100) {
#line 3427
      goto case_100;
    }
#line 3430
    if (c == 73) {
#line 3430
      goto case_73;
    }
#line 3433
    if (c == 110) {
#line 3433
      goto case_110;
    }
#line 3436
    if (c == 99) {
#line 3436
      goto case_99;
    }
#line 3439
    if (c == 120) {
#line 3439
      goto case_120;
    }
#line 3442
    if (c == 112) {
#line 3442
      goto case_112;
    }
#line 3445
    if (c == 82) {
#line 3445
      goto case_82;
    }
#line 3448
    if (c == 119) {
#line 3448
      goto case_119;
    }
#line 3461
    if (c == 512) {
#line 3461
      goto case_512;
    }
#line 3471
    if (c == 514) {
#line 3471
      goto case_514;
    }
#line 3478
    if (c == 515) {
#line 3478
      goto case_515;
    }
#line 3485
    if (c == 516) {
#line 3485
      goto case_516;
    }
#line 3488
    if (c == 513) {
#line 3488
      goto case_513;
    }
#line 3496
    if (c == 118) {
#line 3496
      goto case_118;
    }
#line 3499
    if (c == 86) {
#line 3499
      goto case_86;
    }
#line 3502
    if (c == 87) {
#line 3502
      goto case_87;
    }
#line 3509
    if (c == 63) {
#line 3509
      goto case_63;
    }
#line 3505
    goto switch_default;
    case_0: /* CIL Label */ 
#line 3371
    goto switch_break;
    case_72: /* CIL Label */ 
    {
#line 3373
    usage(stdout);
    }
#line 3374
    goto switch_break;
    case_97: /* CIL Label */ 
#line 3377
    do_syms ++;
#line 3378
    do_reloc ++;
#line 3379
    do_unwind ++;
#line 3380
    do_dynamic ++;
#line 3381
    do_header ++;
#line 3382
    do_sections ++;
#line 3383
    do_section_groups ++;
#line 3384
    do_segments ++;
#line 3385
    do_version ++;
#line 3386
    do_histogram ++;
#line 3387
    do_arch ++;
#line 3388
    do_notes ++;
#line 3389
    goto switch_break;
    case_103: /* CIL Label */ 
#line 3391
    do_section_groups ++;
#line 3392
    goto switch_break;
    case_78: /* CIL Label */ 
    case_116: /* CIL Label */ 
#line 3395
    do_sections ++;
#line 3396
    do_section_details ++;
#line 3397
    goto switch_break;
    case_101: /* CIL Label */ 
#line 3399
    do_header ++;
#line 3400
    do_sections ++;
#line 3401
    do_segments ++;
#line 3402
    goto switch_break;
    case_65: /* CIL Label */ 
#line 3404
    do_arch ++;
#line 3405
    goto switch_break;
    case_68: /* CIL Label */ 
#line 3407
    do_using_dynamic ++;
#line 3408
    goto switch_break;
    case_114: /* CIL Label */ 
#line 3410
    do_reloc ++;
#line 3411
    goto switch_break;
    case_117: /* CIL Label */ 
#line 3413
    do_unwind ++;
#line 3414
    goto switch_break;
    case_104: /* CIL Label */ 
#line 3416
    do_header ++;
#line 3417
    goto switch_break;
    case_108: /* CIL Label */ 
#line 3419
    do_segments ++;
#line 3420
    goto switch_break;
    case_115: /* CIL Label */ 
#line 3422
    do_syms ++;
#line 3423
    goto switch_break;
    case_83: /* CIL Label */ 
#line 3425
    do_sections ++;
#line 3426
    goto switch_break;
    case_100: /* CIL Label */ 
#line 3428
    do_dynamic ++;
#line 3429
    goto switch_break;
    case_73: /* CIL Label */ 
#line 3431
    do_histogram ++;
#line 3432
    goto switch_break;
    case_110: /* CIL Label */ 
#line 3434
    do_notes ++;
#line 3435
    goto switch_break;
    case_99: /* CIL Label */ 
#line 3437
    do_archive_index ++;
#line 3438
    goto switch_break;
    case_120: /* CIL Label */ 
    {
#line 3440
    request_dump((dump_type )1);
    }
#line 3441
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 3443
    request_dump((dump_type )(1 << 3));
    }
#line 3444
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 3446
    request_dump((dump_type )(1 << 4));
    }
#line 3447
    goto switch_break;
    case_119: /* CIL Label */ 
#line 3449
    do_dump ++;
#line 3450
    if ((unsigned long )optarg == (unsigned long )((char *)0)) {
      {
#line 3452
      do_debugging = 1;
#line 3453
      dwarf_select_sections_all();
      }
    } else {
      {
#line 3457
      do_debugging = 0;
#line 3458
      dwarf_select_sections_by_letters((char const   *)optarg);
      }
    }
#line 3460
    goto switch_break;
    case_512: /* CIL Label */ 
#line 3462
    do_dump ++;
#line 3463
    if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 3464
      do_debugging = 1;
    } else {
      {
#line 3467
      do_debugging = 0;
#line 3468
      dwarf_select_sections_by_names((char const   *)optarg);
      }
    }
#line 3470
    goto switch_break;
    case_514: /* CIL Label */ 
    {
#line 3475
    tmp___0 = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& cp),
                      0);
#line 3475
    dwarf_cutoff_level = (int )tmp___0;
    }
#line 3477
    goto switch_break;
    case_515: /* CIL Label */ 
    {
#line 3482
    dwarf_start_die = strtoul((char const   */* __restrict  */)optarg, (char **/* __restrict  */)(& cp___0),
                              0);
    }
#line 3484
    goto switch_break;
    case_516: /* CIL Label */ 
#line 3486
    dwarf_check = 1;
#line 3487
    goto switch_break;
    case_513: /* CIL Label */ 
#line 3489
    do_dyn_syms ++;
#line 3490
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 3497
    print_version((char const   *)program_name);
    }
#line 3498
    goto switch_break;
    case_86: /* CIL Label */ 
#line 3500
    do_version ++;
#line 3501
    goto switch_break;
    case_87: /* CIL Label */ 
#line 3503
    do_wide ++;
#line 3504
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 3507
    tmp___1 = gettext("Invalid option \'-%c\'\n");
#line 3507
    error((char const   *)tmp___1, c);
    }
    case_63: /* CIL Label */ 
    {
#line 3510
    usage(stderr);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3514
  if (! do_dynamic) {
#line 3514
    if (! do_syms) {
#line 3514
      if (! do_reloc) {
#line 3514
        if (! do_unwind) {
#line 3514
          if (! do_sections) {
#line 3514
            if (! do_segments) {
#line 3514
              if (! do_header) {
#line 3514
                if (! do_dump) {
#line 3514
                  if (! do_version) {
#line 3514
                    if (! do_histogram) {
#line 3514
                      if (! do_debugging) {
#line 3514
                        if (! do_arch) {
#line 3514
                          if (! do_notes) {
#line 3514
                            if (! do_section_groups) {
#line 3514
                              if (! do_archive_index) {
#line 3514
                                if (! do_dyn_syms) {
                                  {
#line 3519
                                  usage(stderr);
                                  }
                                } else {
#line 3514
                                  goto _L___13;
                                }
                              } else {
#line 3514
                                goto _L___13;
                              }
                            } else {
#line 3514
                              goto _L___13;
                            }
                          } else {
#line 3514
                            goto _L___13;
                          }
                        } else {
#line 3514
                          goto _L___13;
                        }
                      } else {
#line 3514
                        goto _L___13;
                      }
                    } else {
#line 3514
                      goto _L___13;
                    }
                  } else {
#line 3514
                    goto _L___13;
                  }
                } else {
#line 3514
                  goto _L___13;
                }
              } else {
#line 3514
                goto _L___13;
              }
            } else {
#line 3514
              goto _L___13;
            }
          } else {
#line 3514
            goto _L___13;
          }
        } else {
#line 3514
          goto _L___13;
        }
      } else {
#line 3514
        goto _L___13;
      }
    } else {
#line 3514
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 3520
  if (argc < 3) {
    {
#line 3522
    tmp___2 = gettext("Nothing to do.\n");
#line 3522
    warn((char const   *)tmp___2);
#line 3523
    usage(stderr);
    }
  }
#line 3525
  return;
}
}
#line 3530 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___6[32]  ;
#line 3527 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_elf_class(unsigned int elf_class ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 3534
  if (elf_class == 0U) {
#line 3534
    goto case_0;
  }
#line 3535
  if (elf_class == 1U) {
#line 3535
    goto case_1;
  }
#line 3536
  if (elf_class == 2U) {
#line 3536
    goto case_2;
  }
#line 3537
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 3534
  tmp___0 = gettext("none");
  }
#line 3534
  return ((char const   *)tmp___0);
  case_1: /* CIL Label */ 
#line 3535
  return ("ELF32");
  case_2: /* CIL Label */ 
#line 3536
  return ("ELF64");
  switch_default: /* CIL Label */ 
  {
#line 3538
  tmp___1 = gettext("<unknown: %x>");
#line 3538
  snprintf((char */* __restrict  */)(buff___6), sizeof(buff___6), (char const   */* __restrict  */)tmp___1,
           elf_class);
  }
#line 3539
  return ((char const   *)(buff___6));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3546 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___7[32]  ;
#line 3543 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_data_encoding(unsigned int encoding ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 3550
  if (encoding == 0U) {
#line 3550
    goto case_0;
  }
#line 3551
  if (encoding == 1U) {
#line 3551
    goto case_1;
  }
#line 3552
  if (encoding == 2U) {
#line 3552
    goto case_2;
  }
#line 3553
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 3550
  tmp___0 = gettext("none");
  }
#line 3550
  return ((char const   *)tmp___0);
  case_1: /* CIL Label */ 
  {
#line 3551
  tmp___1 = gettext("2\'s complement, little endian");
  }
#line 3551
  return ((char const   *)tmp___1);
  case_2: /* CIL Label */ 
  {
#line 3552
  tmp___2 = gettext("2\'s complement, big endian");
  }
#line 3552
  return ((char const   *)tmp___2);
  switch_default: /* CIL Label */ 
  {
#line 3554
  tmp___3 = gettext("<unknown: %x>");
#line 3554
  snprintf((char */* __restrict  */)(buff___7), sizeof(buff___7), (char const   */* __restrict  */)tmp___3,
           encoding);
  }
#line 3555
  return ((char const   *)(buff___7));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 3561 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_file_header(void) 
{ 
  char *tmp___0 ;
  int i ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;

  {
#line 3564
  if ((int )elf_header.e_ident[0] != 127) {
    {
#line 3569
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3569
    error((char const   *)tmp___0);
    }
#line 3571
    return (0);
  } else
#line 3564
  if ((int )elf_header.e_ident[1] != 69) {
    {
#line 3569
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3569
    error((char const   *)tmp___0);
    }
#line 3571
    return (0);
  } else
#line 3564
  if ((int )elf_header.e_ident[2] != 76) {
    {
#line 3569
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3569
    error((char const   *)tmp___0);
    }
#line 3571
    return (0);
  } else
#line 3564
  if ((int )elf_header.e_ident[3] != 70) {
    {
#line 3569
    tmp___0 = gettext("Not an ELF file - it has the wrong magic bytes at the start\n");
#line 3569
    error((char const   *)tmp___0);
    }
#line 3571
    return (0);
  }
  {
#line 3574
  init_dwarf_regnames((unsigned int )elf_header.e_machine);
  }
#line 3576
  if (do_header) {
    {
#line 3580
    tmp___1 = gettext("ELF Header:\n");
#line 3580
    printf((char const   */* __restrict  */)tmp___1);
#line 3581
    tmp___2 = gettext("  Magic:   ");
#line 3581
    printf((char const   */* __restrict  */)tmp___2);
#line 3582
    i = 0;
    }
    {
#line 3582
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3582
      if (! (i < 16)) {
#line 3582
        goto while_break;
      }
      {
#line 3583
      printf((char const   */* __restrict  */)"%2.2x ", (int )elf_header.e_ident[i]);
#line 3582
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 3584
    printf((char const   */* __restrict  */)"\n");
#line 3585
    tmp___3 = get_elf_class((unsigned int )elf_header.e_ident[4]);
#line 3585
    tmp___4 = gettext("  Class:                             %s\n");
#line 3585
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 3587
    tmp___5 = get_data_encoding((unsigned int )elf_header.e_ident[5]);
#line 3587
    tmp___6 = gettext("  Data:                              %s\n");
#line 3587
    printf((char const   */* __restrict  */)tmp___6, tmp___5);
    }
#line 3589
    if ((int )elf_header.e_ident[6] == 1) {
#line 3589
      tmp___9 = "(current)";
    } else {
#line 3589
      if ((int )elf_header.e_ident[6] != 0) {
        {
#line 3589
        tmp___7 = gettext("<unknown: %lx>");
#line 3589
        tmp___8 = (char const   *)tmp___7;
        }
      } else {
#line 3589
        tmp___8 = "";
      }
#line 3589
      tmp___9 = tmp___8;
    }
    {
#line 3589
    tmp___10 = gettext("  Version:                           %d %s\n");
#line 3589
    printf((char const   */* __restrict  */)tmp___10, (int )elf_header.e_ident[6],
           tmp___9);
#line 3596
    tmp___11 = get_osabi_name((unsigned int )elf_header.e_ident[7]);
#line 3596
    tmp___12 = gettext("  OS/ABI:                            %s\n");
#line 3596
    printf((char const   */* __restrict  */)tmp___12, tmp___11);
#line 3598
    tmp___13 = gettext("  ABI Version:                       %d\n");
#line 3598
    printf((char const   */* __restrict  */)tmp___13, (int )elf_header.e_ident[8]);
#line 3600
    tmp___14 = get_file_type((unsigned int )elf_header.e_type);
#line 3600
    tmp___15 = gettext("  Type:                              %s\n");
#line 3600
    printf((char const   */* __restrict  */)tmp___15, tmp___14);
#line 3602
    tmp___16 = get_machine_name((unsigned int )elf_header.e_machine);
#line 3602
    tmp___17 = gettext("  Machine:                           %s\n");
#line 3602
    printf((char const   */* __restrict  */)tmp___17, tmp___16);
#line 3604
    tmp___18 = gettext("  Version:                           0x%lx\n");
#line 3604
    printf((char const   */* __restrict  */)tmp___18, elf_header.e_version);
#line 3607
    tmp___19 = gettext("  Entry point address:               ");
#line 3607
    printf((char const   */* __restrict  */)tmp___19);
#line 3608
    print_vma(elf_header.e_entry, (print_mode )4);
#line 3609
    tmp___20 = gettext("\n  Start of program headers:          ");
#line 3609
    printf((char const   */* __restrict  */)tmp___20);
#line 3610
    print_vma(elf_header.e_phoff, (print_mode )1);
#line 3611
    tmp___21 = gettext(" (bytes into file)\n  Start of section headers:          ");
#line 3611
    printf((char const   */* __restrict  */)tmp___21);
#line 3612
    print_vma(elf_header.e_shoff, (print_mode )1);
#line 3613
    tmp___22 = gettext(" (bytes into file)\n");
#line 3613
    printf((char const   */* __restrict  */)tmp___22);
#line 3615
    tmp___23 = get_machine_flags((unsigned int )elf_header.e_flags, (unsigned int )elf_header.e_machine);
#line 3615
    tmp___24 = gettext("  Flags:                             0x%lx%s\n");
#line 3615
    printf((char const   */* __restrict  */)tmp___24, elf_header.e_flags, tmp___23);
#line 3618
    tmp___25 = gettext("  Size of this header:               %ld (bytes)\n");
#line 3618
    printf((char const   */* __restrict  */)tmp___25, (long )elf_header.e_ehsize);
#line 3620
    tmp___26 = gettext("  Size of program headers:           %ld (bytes)\n");
#line 3620
    printf((char const   */* __restrict  */)tmp___26, (long )elf_header.e_phentsize);
#line 3622
    tmp___27 = gettext("  Number of program headers:         %ld");
#line 3622
    printf((char const   */* __restrict  */)tmp___27, (long )elf_header.e_phnum);
    }
#line 3624
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3624
      if (elf_header.e_phnum == 65535U) {
#line 3624
        if ((section_headers + 0)->sh_info != 0U) {
          {
#line 3627
          printf((char const   */* __restrict  */)" (%ld)", (long )(section_headers + 0)->sh_info);
          }
        }
      }
    }
    {
#line 3628
    _IO_putc('\n', stdout);
#line 3629
    tmp___28 = gettext("  Size of section headers:           %ld (bytes)\n");
#line 3629
    printf((char const   */* __restrict  */)tmp___28, (long )elf_header.e_shentsize);
#line 3631
    tmp___29 = gettext("  Number of section headers:         %ld");
#line 3631
    printf((char const   */* __restrict  */)tmp___29, (long )elf_header.e_shnum);
    }
#line 3633
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3633
      if (elf_header.e_shnum == 0U) {
        {
#line 3634
        printf((char const   */* __restrict  */)" (%ld)", (long )(section_headers + 0)->sh_size);
        }
      }
    }
    {
#line 3635
    _IO_putc('\n', stdout);
#line 3636
    tmp___30 = gettext("  Section header string table index: %ld");
#line 3636
    printf((char const   */* __restrict  */)tmp___30, (long )elf_header.e_shstrndx);
    }
#line 3638
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3638
      if (elf_header.e_shstrndx == 65535U) {
        {
#line 3640
        printf((char const   */* __restrict  */)" (%u)", (section_headers + 0)->sh_link);
        }
      } else {
#line 3638
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3641
    if (elf_header.e_shstrndx != 0U) {
#line 3641
      if (elf_header.e_shstrndx >= elf_header.e_shnum) {
        {
#line 3643
        tmp___31 = gettext(" <corrupt: out of range>");
#line 3643
        printf((char const   */* __restrict  */)tmp___31);
        }
      }
    }
    {
#line 3644
    _IO_putc('\n', stdout);
    }
  }
#line 3647
  if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3649
    if (elf_header.e_phnum == 65535U) {
#line 3649
      if ((section_headers + 0)->sh_info != 0U) {
#line 3651
        elf_header.e_phnum = (section_headers + 0)->sh_info;
      }
    }
#line 3652
    if (elf_header.e_shnum == 0U) {
#line 3653
      elf_header.e_shnum = (unsigned int )(section_headers + 0)->sh_size;
    }
#line 3654
    if (elf_header.e_shstrndx == 65535U) {
#line 3655
      elf_header.e_shstrndx = (section_headers + 0)->sh_link;
    } else
#line 3656
    if (elf_header.e_shstrndx >= elf_header.e_shnum) {
#line 3657
      elf_header.e_shstrndx = 0U;
    }
    {
#line 3658
    free((void *)section_headers);
#line 3659
    section_headers = (Elf_Internal_Shdr *)((void *)0);
    }
  }
#line 3662
  return (1);
}
}
#line 3666 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_32bit_program_headers(FILE *file , Elf_Internal_Phdr *pheaders ) 
{ 
  Elf32_External_Phdr *phdrs ;
  Elf32_External_Phdr *external ;
  Elf_Internal_Phdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;

  {
  {
#line 3674
  tmp___0 = gettext("program headers");
#line 3674
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_phoff, (size_t )elf_header.e_phentsize,
                     (size_t )elf_header.e_phnum, (char const   *)tmp___0);
#line 3674
  phdrs = (Elf32_External_Phdr *)tmp___1;
  }
#line 3678
  if (! phdrs) {
#line 3679
    return (0);
  }
#line 3681
  i = 0U;
#line 3681
  internal = pheaders;
#line 3681
  external = phdrs;
  {
#line 3681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3681
    if (! (i < elf_header.e_phnum)) {
#line 3681
      goto while_break;
    }
    {
#line 3685
    tmp___2 = (*byte_get)(external->p_type, (int )sizeof(external->p_type));
#line 3685
    internal->p_type = (unsigned long )tmp___2;
#line 3686
    tmp___3 = (*byte_get)(external->p_offset, (int )sizeof(external->p_offset));
#line 3686
    internal->p_offset = (bfd_vma )tmp___3;
#line 3687
    tmp___4 = (*byte_get)(external->p_vaddr, (int )sizeof(external->p_vaddr));
#line 3687
    internal->p_vaddr = (bfd_vma )tmp___4;
#line 3688
    tmp___5 = (*byte_get)(external->p_paddr, (int )sizeof(external->p_paddr));
#line 3688
    internal->p_paddr = (bfd_vma )tmp___5;
#line 3689
    tmp___6 = (*byte_get)(external->p_filesz, (int )sizeof(external->p_filesz));
#line 3689
    internal->p_filesz = (bfd_vma )tmp___6;
#line 3690
    tmp___7 = (*byte_get)(external->p_memsz, (int )sizeof(external->p_memsz));
#line 3690
    internal->p_memsz = (bfd_vma )tmp___7;
#line 3691
    tmp___8 = (*byte_get)(external->p_flags, (int )sizeof(external->p_flags));
#line 3691
    internal->p_flags = (unsigned long )tmp___8;
#line 3692
    tmp___9 = (*byte_get)(external->p_align, (int )sizeof(external->p_align));
#line 3692
    internal->p_align = (bfd_vma )tmp___9;
#line 3681
    i ++;
#line 3681
    internal ++;
#line 3681
    external ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3695
  free((void *)phdrs);
  }
#line 3697
  return (1);
}
}
#line 3700 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_64bit_program_headers(FILE *file , Elf_Internal_Phdr *pheaders ) 
{ 
  Elf64_External_Phdr *phdrs ;
  Elf64_External_Phdr *external ;
  Elf_Internal_Phdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;

  {
  {
#line 3708
  tmp___0 = gettext("program headers");
#line 3708
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_phoff, (size_t )elf_header.e_phentsize,
                     (size_t )elf_header.e_phnum, (char const   *)tmp___0);
#line 3708
  phdrs = (Elf64_External_Phdr *)tmp___1;
  }
#line 3712
  if (! phdrs) {
#line 3713
    return (0);
  }
#line 3715
  i = 0U;
#line 3715
  internal = pheaders;
#line 3715
  external = phdrs;
  {
#line 3715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3715
    if (! (i < elf_header.e_phnum)) {
#line 3715
      goto while_break;
    }
    {
#line 3719
    tmp___2 = (*byte_get)(external->p_type, (int )sizeof(external->p_type));
#line 3719
    internal->p_type = (unsigned long )tmp___2;
#line 3720
    tmp___3 = (*byte_get)(external->p_flags, (int )sizeof(external->p_flags));
#line 3720
    internal->p_flags = (unsigned long )tmp___3;
#line 3721
    tmp___4 = (*byte_get)(external->p_offset, (int )sizeof(external->p_offset));
#line 3721
    internal->p_offset = (bfd_vma )tmp___4;
#line 3722
    tmp___5 = (*byte_get)(external->p_vaddr, (int )sizeof(external->p_vaddr));
#line 3722
    internal->p_vaddr = (bfd_vma )tmp___5;
#line 3723
    tmp___6 = (*byte_get)(external->p_paddr, (int )sizeof(external->p_paddr));
#line 3723
    internal->p_paddr = (bfd_vma )tmp___6;
#line 3724
    tmp___7 = (*byte_get)(external->p_filesz, (int )sizeof(external->p_filesz));
#line 3724
    internal->p_filesz = (bfd_vma )tmp___7;
#line 3725
    tmp___8 = (*byte_get)(external->p_memsz, (int )sizeof(external->p_memsz));
#line 3725
    internal->p_memsz = (bfd_vma )tmp___8;
#line 3726
    tmp___9 = (*byte_get)(external->p_align, (int )sizeof(external->p_align));
#line 3726
    internal->p_align = (bfd_vma )tmp___9;
#line 3715
    i ++;
#line 3715
    internal ++;
#line 3715
    external ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3729
  free((void *)phdrs);
  }
#line 3731
  return (1);
}
}
#line 3736 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_program_headers(FILE *file ) 
{ 
  Elf_Internal_Phdr *phdrs ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3742
  if ((unsigned long )program_headers != (unsigned long )((void *)0)) {
#line 3743
    return (1);
  }
  {
#line 3745
  tmp___0 = cmalloc((size_t )elf_header.e_phnum, sizeof(Elf_Internal_Phdr ));
#line 3745
  phdrs = (Elf_Internal_Phdr *)tmp___0;
  }
#line 3748
  if ((unsigned long )phdrs == (unsigned long )((void *)0)) {
    {
#line 3750
    tmp___1 = gettext("Out of memory\n");
#line 3750
    error((char const   *)tmp___1);
    }
#line 3751
    return (0);
  }
#line 3754
  if (is_32bit_elf) {
    {
#line 3754
    tmp___2 = get_32bit_program_headers(file, phdrs);
#line 3754
    tmp___4 = tmp___2;
    }
  } else {
    {
#line 3754
    tmp___3 = get_64bit_program_headers(file, phdrs);
#line 3754
    tmp___4 = tmp___3;
    }
  }
#line 3754
  if (tmp___4) {
#line 3758
    program_headers = phdrs;
#line 3759
    return (1);
  }
  {
#line 3762
  free((void *)phdrs);
  }
#line 3763
  return (0);
}
}
#line 3768 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_program_headers(FILE *file ) 
{ 
  Elf_Internal_Phdr *segment ;
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  Elf_Internal_Shdr *sec ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char fmt[32] ;
  int ret ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  unsigned int j ;
  Elf_Internal_Shdr *section ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  bfd_size_type tmp___43 ;
  bfd_size_type tmp___44 ;

  {
#line 3774
  if (elf_header.e_phnum == 0U) {
#line 3777
    if (elf_header.e_phoff != 0UL) {
      {
#line 3778
      tmp___0 = gettext("possibly corrupt ELF header - it has a non-zero program header offset, but no program headers");
#line 3778
      warn((char const   *)tmp___0);
      }
    } else
#line 3780
    if (do_segments) {
      {
#line 3781
      tmp___1 = gettext("\nThere are no program headers in this file.\n");
#line 3781
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 3782
    return (0);
  }
#line 3785
  if (do_segments) {
#line 3785
    if (! do_header) {
      {
#line 3787
      tmp___2 = get_file_type((unsigned int )elf_header.e_type);
#line 3787
      tmp___3 = gettext("\nElf file type is %s\n");
#line 3787
      printf((char const   */* __restrict  */)tmp___3, tmp___2);
#line 3788
      tmp___4 = gettext("Entry point ");
#line 3788
      printf((char const   */* __restrict  */)tmp___4);
#line 3789
      print_vma(elf_header.e_entry, (print_mode )4);
#line 3790
      tmp___5 = gettext("\nThere are %d program headers, starting at offset ");
#line 3790
      printf((char const   */* __restrict  */)tmp___5, elf_header.e_phnum);
#line 3792
      print_vma(elf_header.e_phoff, (print_mode )1);
#line 3793
      printf((char const   */* __restrict  */)"\n");
      }
    }
  }
  {
#line 3796
  tmp___6 = get_program_headers(file);
  }
#line 3796
  if (! tmp___6) {
#line 3797
    return (0);
  }
#line 3799
  if (do_segments) {
#line 3801
    if (elf_header.e_phnum > 1U) {
      {
#line 3802
      tmp___7 = gettext("\nProgram Headers:\n");
#line 3802
      printf((char const   */* __restrict  */)tmp___7);
      }
    } else {
      {
#line 3804
      tmp___8 = gettext("\nProgram Headers:\n");
#line 3804
      printf((char const   */* __restrict  */)tmp___8);
      }
    }
#line 3806
    if (is_32bit_elf) {
      {
#line 3807
      tmp___9 = gettext("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n");
#line 3807
      printf((char const   */* __restrict  */)tmp___9);
      }
    } else
#line 3809
    if (do_wide) {
      {
#line 3810
      tmp___10 = gettext("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n");
#line 3810
      printf((char const   */* __restrict  */)tmp___10);
      }
    } else {
      {
#line 3814
      tmp___11 = gettext("  Type           Offset             VirtAddr           PhysAddr\n");
#line 3814
      printf((char const   */* __restrict  */)tmp___11);
#line 3816
      tmp___12 = gettext("                 FileSiz            MemSiz              Flags  Align\n");
#line 3816
      printf((char const   */* __restrict  */)tmp___12);
      }
    }
  }
#line 3821
  dynamic_addr = 0UL;
#line 3822
  dynamic_size = (bfd_size_type )0;
#line 3824
  i = 0U;
#line 3824
  segment = program_headers;
  {
#line 3824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3824
    if (! (i < elf_header.e_phnum)) {
#line 3824
      goto while_break;
    }
#line 3828
    if (do_segments) {
      {
#line 3830
      tmp___13 = get_segment_type(segment->p_type);
#line 3830
      printf((char const   */* __restrict  */)"  %-14.14s ", tmp___13);
      }
#line 3832
      if (is_32bit_elf) {
        {
#line 3834
        printf((char const   */* __restrict  */)"0x%6.6lx ", segment->p_offset);
#line 3835
        printf((char const   */* __restrict  */)"0x%8.8lx ", segment->p_vaddr);
#line 3836
        printf((char const   */* __restrict  */)"0x%8.8lx ", segment->p_paddr);
#line 3837
        printf((char const   */* __restrict  */)"0x%5.5lx ", segment->p_filesz);
#line 3838
        printf((char const   */* __restrict  */)"0x%5.5lx ", segment->p_memsz);
        }
#line 3839
        if (segment->p_flags & 1UL) {
#line 3839
          tmp___14 = 'E';
        } else {
#line 3839
          tmp___14 = ' ';
        }
#line 3839
        if (segment->p_flags & (unsigned long )(1 << 1)) {
#line 3839
          tmp___15 = 'W';
        } else {
#line 3839
          tmp___15 = ' ';
        }
#line 3839
        if (segment->p_flags & (unsigned long )(1 << 2)) {
#line 3839
          tmp___16 = 'R';
        } else {
#line 3839
          tmp___16 = ' ';
        }
        {
#line 3839
        printf((char const   */* __restrict  */)"%c%c%c ", tmp___16, tmp___15, tmp___14);
#line 3843
        printf((char const   */* __restrict  */)"%#lx", segment->p_align);
        }
      } else
#line 3845
      if (do_wide) {
#line 3847
        if (segment->p_offset == segment->p_offset) {
          {
#line 3848
          printf((char const   */* __restrict  */)"0x%6.6lx ", segment->p_offset);
          }
        } else {
          {
#line 3851
          print_vma(segment->p_offset, (print_mode )5);
#line 3852
          putchar(' ');
          }
        }
        {
#line 3855
        print_vma(segment->p_vaddr, (print_mode )5);
#line 3856
        putchar(' ');
#line 3857
        print_vma(segment->p_paddr, (print_mode )5);
#line 3858
        putchar(' ');
        }
#line 3860
        if (segment->p_filesz == segment->p_filesz) {
          {
#line 3861
          printf((char const   */* __restrict  */)"0x%6.6lx ", segment->p_filesz);
          }
        } else {
          {
#line 3864
          print_vma(segment->p_filesz, (print_mode )5);
#line 3865
          putchar(' ');
          }
        }
#line 3868
        if (segment->p_memsz == segment->p_memsz) {
          {
#line 3869
          printf((char const   */* __restrict  */)"0x%6.6lx", segment->p_memsz);
          }
        } else {
          {
#line 3872
          print_vma(segment->p_memsz, (print_mode )5);
          }
        }
#line 3875
        if (segment->p_flags & 1UL) {
#line 3875
          tmp___17 = 'E';
        } else {
#line 3875
          tmp___17 = ' ';
        }
#line 3875
        if (segment->p_flags & (unsigned long )(1 << 1)) {
#line 3875
          tmp___18 = 'W';
        } else {
#line 3875
          tmp___18 = ' ';
        }
#line 3875
        if (segment->p_flags & (unsigned long )(1 << 2)) {
#line 3875
          tmp___19 = 'R';
        } else {
#line 3875
          tmp___19 = ' ';
        }
        {
#line 3875
        printf((char const   */* __restrict  */)" %c%c%c ", tmp___19, tmp___18, tmp___17);
        }
#line 3880
        if (segment->p_align == segment->p_align) {
          {
#line 3881
          printf((char const   */* __restrict  */)"%#lx", segment->p_align);
          }
        } else {
          {
#line 3884
          print_vma(segment->p_align, (print_mode )4);
          }
        }
      } else {
        {
#line 3889
        print_vma(segment->p_offset, (print_mode )5);
#line 3890
        putchar(' ');
#line 3891
        print_vma(segment->p_vaddr, (print_mode )5);
#line 3892
        putchar(' ');
#line 3893
        print_vma(segment->p_paddr, (print_mode )5);
#line 3894
        printf((char const   */* __restrict  */)"\n                 ");
#line 3895
        print_vma(segment->p_filesz, (print_mode )5);
#line 3896
        putchar(' ');
#line 3897
        print_vma(segment->p_memsz, (print_mode )5);
        }
#line 3898
        if (segment->p_flags & 1UL) {
#line 3898
          tmp___20 = 'E';
        } else {
#line 3898
          tmp___20 = ' ';
        }
#line 3898
        if (segment->p_flags & (unsigned long )(1 << 1)) {
#line 3898
          tmp___21 = 'W';
        } else {
#line 3898
          tmp___21 = ' ';
        }
#line 3898
        if (segment->p_flags & (unsigned long )(1 << 2)) {
#line 3898
          tmp___22 = 'R';
        } else {
#line 3898
          tmp___22 = ' ';
        }
        {
#line 3898
        printf((char const   */* __restrict  */)"  %c%c%c    ", tmp___22, tmp___21,
               tmp___20);
#line 3902
        print_vma(segment->p_align, (print_mode )0);
        }
      }
    }
    {
#line 3908
    if (segment->p_type == 2UL) {
#line 3908
      goto case_2;
    }
#line 3952
    if (segment->p_type == 3UL) {
#line 3952
      goto case_3;
    }
#line 3906
    goto switch_break;
    case_2: /* CIL Label */ 
#line 3909
    if (dynamic_addr) {
      {
#line 3910
      tmp___23 = gettext("more than one dynamic segment\n");
#line 3910
      error((char const   *)tmp___23);
      }
    }
#line 3914
    dynamic_addr = segment->p_offset;
#line 3915
    dynamic_size = segment->p_filesz;
#line 3919
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
      {
#line 3923
      sec = find_section(".dynamic");
      }
#line 3924
      if ((unsigned long )sec == (unsigned long )((void *)0)) {
#line 3924
        goto _L;
      } else
#line 3924
      if (sec->sh_size == 0UL) {
        _L: /* CIL Label */ 
        {
#line 3928
        tmp___25 = is_ia64_vms();
        }
#line 3928
        if (! tmp___25) {
          {
#line 3929
          tmp___24 = gettext("no .dynamic section in the dynamic segment\n");
#line 3929
          error((char const   *)tmp___24);
          }
        }
#line 3930
        goto switch_break;
      }
#line 3933
      if (sec->sh_type == 8U) {
#line 3935
        dynamic_size = (bfd_size_type )0;
#line 3936
        goto switch_break;
      }
#line 3939
      dynamic_addr = (unsigned long )sec->sh_offset;
#line 3940
      dynamic_size = sec->sh_size;
#line 3942
      if (dynamic_addr < segment->p_offset) {
        {
#line 3944
        tmp___26 = gettext("the .dynamic section is not contained within the dynamic segment\n");
#line 3944
        warn((char const   *)tmp___26);
        }
      } else
#line 3942
      if (dynamic_addr > segment->p_offset + segment->p_filesz) {
        {
#line 3944
        tmp___26 = gettext("the .dynamic section is not contained within the dynamic segment\n");
#line 3944
        warn((char const   *)tmp___26);
        }
      } else
#line 3946
      if (dynamic_addr > segment->p_offset) {
        {
#line 3947
        tmp___27 = gettext("the .dynamic section is not the first section in the dynamic segment.\n");
#line 3947
        warn((char const   *)tmp___27);
        }
      }
    }
#line 3950
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 3953
    tmp___34 = fseek(file, archive_file_offset + (long )segment->p_offset, 0);
    }
#line 3953
    if (tmp___34) {
      {
#line 3955
      tmp___28 = gettext("Unable to find program interpreter name\n");
#line 3955
      error((char const   *)tmp___28);
      }
    } else {
      {
#line 3959
      tmp___29 = snprintf((char */* __restrict  */)(fmt), sizeof(fmt), (char const   */* __restrict  */)"%%%ds",
                          4096);
#line 3959
      ret = tmp___29;
      }
#line 3961
      if (ret >= (int )sizeof(fmt)) {
        {
#line 3962
        tmp___30 = gettext("Internal error: failed to create format string to display program interpreter\n");
#line 3962
        error((char const   *)tmp___30);
        }
      } else
#line 3961
      if (ret < 0) {
        {
#line 3962
        tmp___30 = gettext("Internal error: failed to create format string to display program interpreter\n");
#line 3962
        error((char const   *)tmp___30);
        }
      }
      {
#line 3964
      program_interpreter[0] = (char)0;
#line 3965
      tmp___32 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)(fmt),
                        program_interpreter);
      }
#line 3965
      if (tmp___32 <= 0) {
        {
#line 3966
        tmp___31 = gettext("Unable to read program interpreter name\n");
#line 3966
        error((char const   *)tmp___31);
        }
      }
#line 3968
      if (do_segments) {
        {
#line 3969
        tmp___33 = gettext("\n      [Requesting program interpreter: %s]");
#line 3969
        printf((char const   */* __restrict  */)tmp___33, program_interpreter);
        }
      }
    }
#line 3972
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3975
    if (do_segments) {
      {
#line 3976
      _IO_putc('\n', stdout);
      }
    }
#line 3824
    i ++;
#line 3824
    segment ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3979
  if (do_segments) {
#line 3979
    if ((unsigned long )section_headers != (unsigned long )((void *)0)) {
#line 3979
      if ((unsigned long )string_table != (unsigned long )((void *)0)) {
        {
#line 3981
        tmp___35 = gettext("\n Section to Segment mapping:\n");
#line 3981
        printf((char const   */* __restrict  */)tmp___35);
#line 3982
        tmp___36 = gettext("  Segment Sections...\n");
#line 3982
        printf((char const   */* __restrict  */)tmp___36);
#line 3984
        i = 0U;
        }
        {
#line 3984
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 3984
          if (! (i < elf_header.e_phnum)) {
#line 3984
            goto while_break___0;
          }
          {
#line 3989
          segment = program_headers + i;
#line 3990
          section = section_headers + 1;
#line 3992
          printf((char const   */* __restrict  */)"   %2.2d     ", i);
#line 3994
          j = 1U;
          }
          {
#line 3994
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 3994
            if (! (j < elf_header.e_shnum)) {
#line 3994
              goto while_break___1;
            }
#line 3996
            if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 3996
              if (section->sh_type == 8U) {
#line 3996
                if (! (segment->p_type != 7UL)) {
#line 3996
                  goto _L___8;
                }
              } else {
#line 3996
                goto _L___8;
              }
            } else
            _L___8: /* CIL Label */ 
#line 3996
            if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 3996
              if (segment->p_type == 7UL) {
#line 3996
                goto _L___5;
              } else
#line 3996
              if (segment->p_type == 1685382482UL) {
#line 3996
                goto _L___5;
              } else
#line 3996
              if (segment->p_type == 1UL) {
#line 3996
                goto _L___5;
              } else {
#line 3996
                goto _L___6;
              }
            } else
            _L___6: /* CIL Label */ 
#line 3996
            if ((section->sh_flags & (unsigned long )(1 << 10)) == 0UL) {
#line 3996
              if (segment->p_type != 7UL) {
#line 3996
                if (segment->p_type != 6UL) {
                  _L___5: /* CIL Label */ 
#line 3996
                  if (section->sh_type == 8U) {
#line 3996
                    goto _L___4;
                  } else
#line 3996
                  if ((bfd_vma )section->sh_offset >= segment->p_offset) {
#line 3996
                    if ((bfd_vma )section->sh_offset - segment->p_offset <= segment->p_filesz - 1UL) {
#line 3996
                      if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 3996
                        if (section->sh_type == 8U) {
#line 3996
                          if (segment->p_type != 7UL) {
#line 3996
                            tmp___43 = (bfd_size_type )0;
                          } else {
#line 3996
                            tmp___43 = section->sh_size;
                          }
                        } else {
#line 3996
                          tmp___43 = section->sh_size;
                        }
                      } else {
#line 3996
                        tmp___43 = section->sh_size;
                      }
#line 3996
                      if (((bfd_vma )section->sh_offset - segment->p_offset) + tmp___43 <= segment->p_filesz) {
                        _L___4: /* CIL Label */ 
#line 3996
                        if ((section->sh_flags & (unsigned long )(1 << 1)) == 0UL) {
#line 3996
                          goto _L___3;
                        } else
#line 3996
                        if (section->sh_addr >= segment->p_vaddr) {
#line 3996
                          if (section->sh_addr - segment->p_vaddr <= segment->p_memsz - 1UL) {
#line 3996
                            if ((section->sh_flags & (unsigned long )(1 << 10)) != 0UL) {
#line 3996
                              if (section->sh_type == 8U) {
#line 3996
                                if (segment->p_type != 7UL) {
#line 3996
                                  tmp___44 = (bfd_size_type )0;
                                } else {
#line 3996
                                  tmp___44 = section->sh_size;
                                }
                              } else {
#line 3996
                                tmp___44 = section->sh_size;
                              }
                            } else {
#line 3996
                              tmp___44 = section->sh_size;
                            }
#line 3996
                            if ((section->sh_addr - segment->p_vaddr) + tmp___44 <= segment->p_memsz) {
                              _L___3: /* CIL Label */ 
#line 3996
                              if (segment->p_type != 2UL) {
#line 3996
                                goto _L___1;
                              } else
#line 3996
                              if (section->sh_size != 0UL) {
#line 3996
                                goto _L___1;
                              } else
#line 3996
                              if (segment->p_memsz == 0UL) {
#line 3996
                                goto _L___1;
                              } else
#line 3996
                              if (section->sh_type == 8U) {
#line 3996
                                goto _L___2;
                              } else
#line 3996
                              if ((bfd_vma )section->sh_offset > segment->p_offset) {
#line 3996
                                if ((bfd_vma )section->sh_offset - segment->p_offset < segment->p_filesz) {
                                  _L___2: /* CIL Label */ 
#line 3996
                                  if ((section->sh_flags & (unsigned long )(1 << 1)) == 0UL) {
#line 3996
                                    goto _L___1;
                                  } else
#line 3996
                                  if (section->sh_addr > segment->p_vaddr) {
#line 3996
                                    if (section->sh_addr - segment->p_vaddr < segment->p_memsz) {
                                      _L___1: /* CIL Label */ 
#line 3998
                                      if ((unsigned long )section == (unsigned long )((void *)0)) {
                                        {
#line 3998
                                        tmp___37 = gettext("<none>");
#line 3998
                                        tmp___42 = tmp___37;
                                        }
                                      } else {
#line 3998
                                        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                                          {
#line 3998
                                          tmp___38 = gettext("<no-name>");
#line 3998
                                          tmp___41 = tmp___38;
                                          }
                                        } else {
#line 3998
                                          if ((unsigned long )section->sh_name >= string_table_length) {
                                            {
#line 3998
                                            tmp___39 = gettext("<corrupt>");
#line 3998
                                            tmp___40 = tmp___39;
                                            }
                                          } else {
#line 3998
                                            tmp___40 = string_table + section->sh_name;
                                          }
#line 3998
                                          tmp___41 = tmp___40;
                                        }
#line 3998
                                        tmp___42 = tmp___41;
                                      }
                                      {
#line 3998
                                      printf((char const   */* __restrict  */)"%s ",
                                             tmp___42);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 3994
            j ++;
#line 3994
            section ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 4001
          _IO_putc('\n', stdout);
#line 3984
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  }
#line 4005
  return (1);
}
}
#line 4011 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static long offset_from_vma(FILE *file , bfd_vma vma , bfd_size_type size ) 
{ 
  Elf_Internal_Phdr *seg ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 4016
  tmp___1 = get_program_headers(file);
  }
#line 4016
  if (! tmp___1) {
    {
#line 4018
    tmp___0 = gettext("Cannot interpret virtual addresses without program headers.\n");
#line 4018
    warn((char const   *)tmp___0);
    }
#line 4019
    return ((long )vma);
  }
#line 4022
  seg = program_headers;
  {
#line 4022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4022
    if (! ((unsigned long )seg < (unsigned long )(program_headers + elf_header.e_phnum))) {
#line 4022
      goto while_break;
    }
#line 4026
    if (seg->p_type != 1UL) {
#line 4027
      goto __Cont;
    }
#line 4029
    if (vma >= (seg->p_vaddr & - seg->p_align)) {
#line 4029
      if (vma + size <= seg->p_vaddr + seg->p_filesz) {
#line 4031
        return ((long )((vma - seg->p_vaddr) + seg->p_offset));
      }
    }
    __Cont: /* CIL Label */ 
#line 4022
    seg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4034
  tmp___2 = gettext("Virtual address 0x%lx not located in any PT_LOAD segment.\n");
#line 4034
  warn((char const   *)tmp___2, vma);
  }
#line 4036
  return ((long )vma);
}
}
#line 4040 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_32bit_section_headers(FILE *file , unsigned int num ) 
{ 
  Elf32_External_Shdr *shdrs ;
  Elf_Internal_Shdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;

  {
  {
#line 4047
  tmp___0 = gettext("section headers");
#line 4047
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_shoff, (size_t )elf_header.e_shentsize,
                     (size_t )num, (char const   *)tmp___0);
#line 4047
  shdrs = (Elf32_External_Shdr *)tmp___1;
  }
#line 4050
  if (! shdrs) {
#line 4051
    return (0);
  }
  {
#line 4053
  tmp___2 = cmalloc((size_t )num, sizeof(Elf_Internal_Shdr ));
#line 4053
  section_headers = (Elf_Internal_Shdr *)tmp___2;
  }
#line 4056
  if ((unsigned long )section_headers == (unsigned long )((void *)0)) {
    {
#line 4058
    tmp___3 = gettext("Out of memory\n");
#line 4058
    error((char const   *)tmp___3);
    }
#line 4059
    return (0);
  }
#line 4062
  i = 0U;
#line 4062
  internal = section_headers;
  {
#line 4062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4062
    if (! (i < num)) {
#line 4062
      goto while_break;
    }
    {
#line 4066
    tmp___4 = (*byte_get)((shdrs + i)->sh_name, (int )sizeof((shdrs + i)->sh_name));
#line 4066
    internal->sh_name = (unsigned int )tmp___4;
#line 4067
    tmp___5 = (*byte_get)((shdrs + i)->sh_type, (int )sizeof((shdrs + i)->sh_type));
#line 4067
    internal->sh_type = (unsigned int )tmp___5;
#line 4068
    tmp___6 = (*byte_get)((shdrs + i)->sh_flags, (int )sizeof((shdrs + i)->sh_flags));
#line 4068
    internal->sh_flags = (bfd_vma )tmp___6;
#line 4069
    tmp___7 = (*byte_get)((shdrs + i)->sh_addr, (int )sizeof((shdrs + i)->sh_addr));
#line 4069
    internal->sh_addr = (bfd_vma )tmp___7;
#line 4070
    tmp___8 = (*byte_get)((shdrs + i)->sh_offset, (int )sizeof((shdrs + i)->sh_offset));
#line 4070
    internal->sh_offset = (file_ptr )tmp___8;
#line 4071
    tmp___9 = (*byte_get)((shdrs + i)->sh_size, (int )sizeof((shdrs + i)->sh_size));
#line 4071
    internal->sh_size = (bfd_size_type )tmp___9;
#line 4072
    tmp___10 = (*byte_get)((shdrs + i)->sh_link, (int )sizeof((shdrs + i)->sh_link));
#line 4072
    internal->sh_link = (unsigned int )tmp___10;
#line 4073
    tmp___11 = (*byte_get)((shdrs + i)->sh_info, (int )sizeof((shdrs + i)->sh_info));
#line 4073
    internal->sh_info = (unsigned int )tmp___11;
#line 4074
    tmp___12 = (*byte_get)((shdrs + i)->sh_addralign, (int )sizeof((shdrs + i)->sh_addralign));
#line 4074
    internal->sh_addralign = (bfd_vma )tmp___12;
#line 4075
    tmp___13 = (*byte_get)((shdrs + i)->sh_entsize, (int )sizeof((shdrs + i)->sh_entsize));
#line 4075
    internal->sh_entsize = (bfd_size_type )tmp___13;
#line 4062
    i ++;
#line 4062
    internal ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4078
  free((void *)shdrs);
  }
#line 4080
  return (1);
}
}
#line 4083 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_64bit_section_headers(FILE *file , unsigned int num ) 
{ 
  Elf64_External_Shdr *shdrs ;
  Elf_Internal_Shdr *internal ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;

  {
  {
#line 4090
  tmp___0 = gettext("section headers");
#line 4090
  tmp___1 = get_data((void *)0, file, (long )elf_header.e_shoff, (size_t )elf_header.e_shentsize,
                     (size_t )num, (char const   *)tmp___0);
#line 4090
  shdrs = (Elf64_External_Shdr *)tmp___1;
  }
#line 4093
  if (! shdrs) {
#line 4094
    return (0);
  }
  {
#line 4096
  tmp___2 = cmalloc((size_t )num, sizeof(Elf_Internal_Shdr ));
#line 4096
  section_headers = (Elf_Internal_Shdr *)tmp___2;
  }
#line 4099
  if ((unsigned long )section_headers == (unsigned long )((void *)0)) {
    {
#line 4101
    tmp___3 = gettext("Out of memory\n");
#line 4101
    error((char const   *)tmp___3);
    }
#line 4102
    return (0);
  }
#line 4105
  i = 0U;
#line 4105
  internal = section_headers;
  {
#line 4105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4105
    if (! (i < num)) {
#line 4105
      goto while_break;
    }
    {
#line 4109
    tmp___4 = (*byte_get)((shdrs + i)->sh_name, (int )sizeof((shdrs + i)->sh_name));
#line 4109
    internal->sh_name = (unsigned int )tmp___4;
#line 4110
    tmp___5 = (*byte_get)((shdrs + i)->sh_type, (int )sizeof((shdrs + i)->sh_type));
#line 4110
    internal->sh_type = (unsigned int )tmp___5;
#line 4111
    tmp___6 = (*byte_get)((shdrs + i)->sh_flags, (int )sizeof((shdrs + i)->sh_flags));
#line 4111
    internal->sh_flags = (bfd_vma )tmp___6;
#line 4112
    tmp___7 = (*byte_get)((shdrs + i)->sh_addr, (int )sizeof((shdrs + i)->sh_addr));
#line 4112
    internal->sh_addr = (bfd_vma )tmp___7;
#line 4113
    tmp___8 = (*byte_get)((shdrs + i)->sh_size, (int )sizeof((shdrs + i)->sh_size));
#line 4113
    internal->sh_size = (bfd_size_type )tmp___8;
#line 4114
    tmp___9 = (*byte_get)((shdrs + i)->sh_entsize, (int )sizeof((shdrs + i)->sh_entsize));
#line 4114
    internal->sh_entsize = (bfd_size_type )tmp___9;
#line 4115
    tmp___10 = (*byte_get)((shdrs + i)->sh_link, (int )sizeof((shdrs + i)->sh_link));
#line 4115
    internal->sh_link = (unsigned int )tmp___10;
#line 4116
    tmp___11 = (*byte_get)((shdrs + i)->sh_info, (int )sizeof((shdrs + i)->sh_info));
#line 4116
    internal->sh_info = (unsigned int )tmp___11;
#line 4117
    tmp___12 = (*byte_get)((shdrs + i)->sh_offset, (int )sizeof((shdrs + i)->sh_offset));
#line 4117
    internal->sh_offset = (file_ptr )tmp___12;
#line 4118
    tmp___13 = (*byte_get)((shdrs + i)->sh_addralign, (int )sizeof((shdrs + i)->sh_addralign));
#line 4118
    internal->sh_addralign = (bfd_vma )tmp___13;
#line 4105
    i ++;
#line 4105
    internal ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4121
  free((void *)shdrs);
  }
#line 4123
  return (1);
}
}
#line 4126 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Sym *get_32bit_elf_symbols(FILE *file , Elf_Internal_Shdr *section ,
                                               unsigned long *num_syms_return ) 
{ 
  unsigned long number ;
  Elf32_External_Sym *esyms ;
  Elf_External_Sym_Shndx *shndx ;
  Elf_Internal_Sym *isyms ;
  Elf_Internal_Sym *psym ;
  unsigned int j ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;

  {
#line 4131
  number = 0UL;
#line 4132
  esyms = (Elf32_External_Sym *)((void *)0);
#line 4133
  shndx = (Elf_External_Sym_Shndx *)((void *)0);
#line 4134
  isyms = (Elf_Internal_Sym *)((void *)0);
#line 4139
  if (section->sh_entsize == 0UL) {
    {
#line 4141
    tmp___0 = gettext("sh_entsize is zero\n");
#line 4141
    error((char const   *)tmp___0);
    }
#line 4142
    goto exit_point;
  }
#line 4145
  number = section->sh_size / section->sh_entsize;
#line 4147
  if (number * sizeof(Elf32_External_Sym ) > section->sh_size + 1UL) {
    {
#line 4149
    tmp___1 = gettext("Invalid sh_entsize\n");
#line 4149
    error((char const   *)tmp___1);
    }
#line 4150
    goto exit_point;
  }
  {
#line 4153
  tmp___2 = gettext("symbols");
#line 4153
  tmp___3 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                     (char const   *)tmp___2);
#line 4153
  esyms = (Elf32_External_Sym *)tmp___3;
  }
#line 4155
  if ((unsigned long )esyms == (unsigned long )((void *)0)) {
#line 4156
    goto exit_point;
  }
#line 4158
  shndx = (Elf_External_Sym_Shndx *)((void *)0);
#line 4159
  if ((unsigned long )symtab_shndx_hdr != (unsigned long )((void *)0)) {
#line 4159
    if ((unsigned long )symtab_shndx_hdr->sh_link == (unsigned long )(section - section_headers)) {
      {
#line 4163
      tmp___4 = gettext("symbol table section indicies");
#line 4163
      tmp___5 = get_data((void *)0, file, symtab_shndx_hdr->sh_offset, (size_t )1,
                         symtab_shndx_hdr->sh_size, (char const   *)tmp___4);
#line 4163
      shndx = (Elf_External_Sym_Shndx *)tmp___5;
      }
#line 4167
      if ((unsigned long )shndx == (unsigned long )((void *)0)) {
#line 4168
        goto exit_point;
      }
    }
  }
  {
#line 4171
  tmp___6 = cmalloc(number, sizeof(Elf_Internal_Sym ));
#line 4171
  isyms = (Elf_Internal_Sym *)tmp___6;
  }
#line 4173
  if ((unsigned long )isyms == (unsigned long )((void *)0)) {
    {
#line 4175
    tmp___7 = gettext("Out of memory\n");
#line 4175
    error((char const   *)tmp___7);
    }
#line 4176
    goto exit_point;
  }
#line 4179
  j = 0U;
#line 4179
  psym = isyms;
  {
#line 4179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4179
    if (! ((unsigned long )j < number)) {
#line 4179
      goto while_break;
    }
    {
#line 4181
    tmp___8 = (*byte_get)((esyms + j)->st_name, (int )sizeof((esyms + j)->st_name));
#line 4181
    psym->st_name = (unsigned long )tmp___8;
#line 4182
    tmp___9 = (*byte_get)((esyms + j)->st_value, (int )sizeof((esyms + j)->st_value));
#line 4182
    psym->st_value = (bfd_vma )tmp___9;
#line 4183
    tmp___10 = (*byte_get)((esyms + j)->st_size, (int )sizeof((esyms + j)->st_size));
#line 4183
    psym->st_size = (bfd_vma )tmp___10;
#line 4184
    tmp___11 = (*byte_get)((esyms + j)->st_shndx, (int )sizeof((esyms + j)->st_shndx));
#line 4184
    psym->st_shndx = (unsigned int )tmp___11;
    }
#line 4185
    if (psym->st_shndx == 65535U) {
#line 4185
      if ((unsigned long )shndx != (unsigned long )((void *)0)) {
        {
#line 4186
        tmp___12 = (*byte_get)((unsigned char *)(shndx + j), (int )sizeof(*(shndx + j)));
#line 4186
        psym->st_shndx = (unsigned int )tmp___12;
        }
      } else {
#line 4185
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4188
    if (psym->st_shndx >= 65280U) {
#line 4189
      psym->st_shndx += 4294901760U;
    }
    {
#line 4190
    tmp___13 = (*byte_get)((esyms + j)->st_info, (int )sizeof((esyms + j)->st_info));
#line 4190
    psym->st_info = (unsigned char )tmp___13;
#line 4191
    tmp___14 = (*byte_get)((esyms + j)->st_other, (int )sizeof((esyms + j)->st_other));
#line 4191
    psym->st_other = (unsigned char )tmp___14;
#line 4179
    j ++;
#line 4179
    psym ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit_point: 
#line 4195
  if ((unsigned long )shndx != (unsigned long )((void *)0)) {
    {
#line 4196
    free((void *)shndx);
    }
  }
#line 4197
  if ((unsigned long )esyms != (unsigned long )((void *)0)) {
    {
#line 4198
    free((void *)esyms);
    }
  }
#line 4200
  if ((unsigned long )num_syms_return != (unsigned long )((void *)0)) {
#line 4201
    if ((unsigned long )isyms == (unsigned long )((void *)0)) {
#line 4201
      *num_syms_return = 0UL;
    } else {
#line 4201
      *num_syms_return = number;
    }
  }
#line 4203
  return (isyms);
}
}
#line 4206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Sym *get_64bit_elf_symbols(FILE *file , Elf_Internal_Shdr *section ,
                                               unsigned long *num_syms_return ) 
{ 
  unsigned long number ;
  Elf64_External_Sym *esyms ;
  Elf_External_Sym_Shndx *shndx ;
  Elf_Internal_Sym *isyms ;
  Elf_Internal_Sym *psym ;
  unsigned int j ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;

  {
#line 4211
  number = 0UL;
#line 4212
  esyms = (Elf64_External_Sym *)((void *)0);
#line 4213
  shndx = (Elf_External_Sym_Shndx *)((void *)0);
#line 4214
  isyms = (Elf_Internal_Sym *)((void *)0);
#line 4219
  if (section->sh_entsize == 0UL) {
    {
#line 4221
    tmp___0 = gettext("sh_entsize is zero\n");
#line 4221
    error((char const   *)tmp___0);
    }
#line 4222
    goto exit_point;
  }
#line 4225
  number = section->sh_size / section->sh_entsize;
#line 4227
  if (number * sizeof(Elf64_External_Sym ) > section->sh_size + 1UL) {
    {
#line 4229
    tmp___1 = gettext("Invalid sh_entsize\n");
#line 4229
    error((char const   *)tmp___1);
    }
#line 4230
    goto exit_point;
  }
  {
#line 4233
  tmp___2 = gettext("symbols");
#line 4233
  tmp___3 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                     (char const   *)tmp___2);
#line 4233
  esyms = (Elf64_External_Sym *)tmp___3;
  }
#line 4235
  if (! esyms) {
#line 4236
    goto exit_point;
  }
#line 4238
  if ((unsigned long )symtab_shndx_hdr != (unsigned long )((void *)0)) {
#line 4238
    if ((unsigned long )symtab_shndx_hdr->sh_link == (unsigned long )(section - section_headers)) {
      {
#line 4242
      tmp___4 = gettext("symbol table section indicies");
#line 4242
      tmp___5 = get_data((void *)0, file, symtab_shndx_hdr->sh_offset, (size_t )1,
                         symtab_shndx_hdr->sh_size, (char const   *)tmp___4);
#line 4242
      shndx = (Elf_External_Sym_Shndx *)tmp___5;
      }
#line 4246
      if ((unsigned long )shndx == (unsigned long )((void *)0)) {
#line 4247
        goto exit_point;
      }
    }
  }
  {
#line 4250
  tmp___6 = cmalloc(number, sizeof(Elf_Internal_Sym ));
#line 4250
  isyms = (Elf_Internal_Sym *)tmp___6;
  }
#line 4252
  if ((unsigned long )isyms == (unsigned long )((void *)0)) {
    {
#line 4254
    tmp___7 = gettext("Out of memory\n");
#line 4254
    error((char const   *)tmp___7);
    }
#line 4255
    goto exit_point;
  }
#line 4258
  j = 0U;
#line 4258
  psym = isyms;
  {
#line 4258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4258
    if (! ((unsigned long )j < number)) {
#line 4258
      goto while_break;
    }
    {
#line 4260
    tmp___8 = (*byte_get)((esyms + j)->st_name, (int )sizeof((esyms + j)->st_name));
#line 4260
    psym->st_name = (unsigned long )tmp___8;
#line 4261
    tmp___9 = (*byte_get)((esyms + j)->st_info, (int )sizeof((esyms + j)->st_info));
#line 4261
    psym->st_info = (unsigned char )tmp___9;
#line 4262
    tmp___10 = (*byte_get)((esyms + j)->st_other, (int )sizeof((esyms + j)->st_other));
#line 4262
    psym->st_other = (unsigned char )tmp___10;
#line 4263
    tmp___11 = (*byte_get)((esyms + j)->st_shndx, (int )sizeof((esyms + j)->st_shndx));
#line 4263
    psym->st_shndx = (unsigned int )tmp___11;
    }
#line 4265
    if (psym->st_shndx == 65535U) {
#line 4265
      if ((unsigned long )shndx != (unsigned long )((void *)0)) {
        {
#line 4266
        tmp___12 = (*byte_get)((unsigned char *)(shndx + j), (int )sizeof(*(shndx + j)));
#line 4266
        psym->st_shndx = (unsigned int )tmp___12;
        }
      } else {
#line 4265
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4268
    if (psym->st_shndx >= 65280U) {
#line 4269
      psym->st_shndx += 4294901760U;
    }
    {
#line 4271
    tmp___13 = (*byte_get)((esyms + j)->st_value, (int )sizeof((esyms + j)->st_value));
#line 4271
    psym->st_value = (bfd_vma )tmp___13;
#line 4272
    tmp___14 = (*byte_get)((esyms + j)->st_size, (int )sizeof((esyms + j)->st_size));
#line 4272
    psym->st_size = (bfd_vma )tmp___14;
#line 4258
    j ++;
#line 4258
    psym ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  exit_point: 
#line 4276
  if ((unsigned long )shndx != (unsigned long )((void *)0)) {
    {
#line 4277
    free((void *)shndx);
    }
  }
#line 4278
  if ((unsigned long )esyms != (unsigned long )((void *)0)) {
    {
#line 4279
    free((void *)esyms);
    }
  }
#line 4281
  if ((unsigned long )num_syms_return != (unsigned long )((void *)0)) {
#line 4282
    if ((unsigned long )isyms == (unsigned long )((void *)0)) {
#line 4282
      *num_syms_return = 0UL;
    } else {
#line 4282
      *num_syms_return = number;
    }
  }
#line 4284
  return (isyms);
}
}
#line 4290 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___8[1024]  ;
#line 4298
static char const   *get_elf_section_flags(bfd_vma sh_flags ) ;
#line 4298 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct __anonstruct_flags_713894858  const  flags[20]  = 
#line 4298
  {      {"WRITE", (int )(sizeof("WRITE") - 1UL)}, 
        {"ALLOC", (int )(sizeof("ALLOC") - 1UL)}, 
        {"EXEC", (int )(sizeof("EXEC") - 1UL)}, 
        {"MERGE", (int )(sizeof("MERGE") - 1UL)}, 
        {"STRINGS", (int )(sizeof("STRINGS") - 1UL)}, 
        {"INFO LINK", (int )(sizeof("INFO LINK") - 1UL)}, 
        {"LINK ORDER", (int )(sizeof("LINK ORDER") - 1UL)}, 
        {"OS NONCONF", (int )(sizeof("OS NONCONF") - 1UL)}, 
        {"GROUP", (int )(sizeof("GROUP") - 1UL)}, 
        {"TLS", (int )(sizeof("TLS") - 1UL)}, 
        {"SHORT", (int )(sizeof("SHORT") - 1UL)}, 
        {"NORECOV", (int )(sizeof("NORECOV") - 1UL)}, 
        {"VMS_GLOBAL", (int )(sizeof("VMS_GLOBAL") - 1UL)}, 
        {"VMS_OVERLAID", (int )(sizeof("VMS_OVERLAID") - 1UL)}, 
        {"VMS_SHARED", (int )(sizeof("VMS_SHARED") - 1UL)}, 
        {"VMS_VECTOR", (int )(sizeof("VMS_VECTOR") - 1UL)}, 
        {"VMS_ALLOC_64BIT", (int )(sizeof("VMS_ALLOC_64BIT") - 1UL)}, 
        {"VMS_PROTECTED", (int )(sizeof("VMS_PROTECTED") - 1UL)}, 
        {"EXCLUDE", (int )(sizeof("EXCLUDE") - 1UL)}, 
        {"ORDERED", (int )(sizeof("ORDERED") - 1UL)}};
#line 4287 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_elf_section_flags(bfd_vma sh_flags ) 
{ 
  char *p ;
  int field_size ;
  int tmp___0 ;
  int sindex ;
  int size ;
  bfd_vma os_flags ;
  bfd_vma proc_flags ;
  bfd_vma unknown_flags ;
  bfd_vma flag ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 4291
  p = buff___8;
#line 4292
  if (is_32bit_elf) {
#line 4292
    tmp___0 = 8;
  } else {
#line 4292
    tmp___0 = 16;
  }
#line 4292
  field_size = tmp___0;
#line 4294
  size = (int )(sizeof(buff___8) - (unsigned long )((field_size + 4) + 1));
#line 4295
  os_flags = (bfd_vma )0;
#line 4296
  proc_flags = (bfd_vma )0;
#line 4297
  unknown_flags = (bfd_vma )0;
#line 4331
  if (do_section_details) {
    {
#line 4333
    sprintf((char */* __restrict  */)(buff___8), (char const   */* __restrict  */)"[%*.*lx]: ",
            field_size, field_size, sh_flags);
#line 4335
    p += field_size + 4;
    }
  }
  {
#line 4338
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4338
    if (! sh_flags) {
#line 4338
      goto while_break;
    }
#line 4342
    flag = sh_flags & - sh_flags;
#line 4343
    sh_flags &= ~ flag;
#line 4345
    if (do_section_details) {
      {
#line 4349
      if (flag == 1UL) {
#line 4349
        goto case_1;
      }
#line 4350
      if (flag == (bfd_vma )(1 << 1)) {
#line 4350
        goto case_exp;
      }
#line 4351
      if (flag == (bfd_vma )(1 << 2)) {
#line 4351
        goto case_exp___0;
      }
#line 4352
      if (flag == (bfd_vma )(1 << 4)) {
#line 4352
        goto case_exp___1;
      }
#line 4353
      if (flag == (bfd_vma )(1 << 5)) {
#line 4353
        goto case_exp___2;
      }
#line 4354
      if (flag == (bfd_vma )(1 << 6)) {
#line 4354
        goto case_exp___3;
      }
#line 4355
      if (flag == (bfd_vma )(1 << 7)) {
#line 4355
        goto case_exp___4;
      }
#line 4356
      if (flag == (bfd_vma )(1 << 8)) {
#line 4356
        goto case_exp___5;
      }
#line 4357
      if (flag == (bfd_vma )(1 << 9)) {
#line 4357
        goto case_exp___6;
      }
#line 4358
      if (flag == (bfd_vma )(1 << 10)) {
#line 4358
        goto case_exp___7;
      }
#line 4359
      if (flag == 2147483648UL) {
#line 4359
        goto case_2147483648;
      }
#line 4361
      goto switch_default;
      case_1: /* CIL Label */ 
#line 4349
      sindex = 0;
#line 4349
      goto switch_break;
      case_exp: /* CIL Label */ 
#line 4350
      sindex = 1;
#line 4350
      goto switch_break;
      case_exp___0: /* CIL Label */ 
#line 4351
      sindex = 2;
#line 4351
      goto switch_break;
      case_exp___1: /* CIL Label */ 
#line 4352
      sindex = 3;
#line 4352
      goto switch_break;
      case_exp___2: /* CIL Label */ 
#line 4353
      sindex = 4;
#line 4353
      goto switch_break;
      case_exp___3: /* CIL Label */ 
#line 4354
      sindex = 5;
#line 4354
      goto switch_break;
      case_exp___4: /* CIL Label */ 
#line 4355
      sindex = 6;
#line 4355
      goto switch_break;
      case_exp___5: /* CIL Label */ 
#line 4356
      sindex = 7;
#line 4356
      goto switch_break;
      case_exp___6: /* CIL Label */ 
#line 4357
      sindex = 8;
#line 4357
      goto switch_break;
      case_exp___7: /* CIL Label */ 
#line 4358
      sindex = 9;
#line 4358
      goto switch_break;
      case_2147483648: /* CIL Label */ 
#line 4359
      sindex = 18;
#line 4359
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 4362
      sindex = -1;
      {
#line 4365
      if ((int )elf_header.e_machine == 50) {
#line 4365
        goto case_50;
      }
#line 4393
      if ((int )elf_header.e_machine == 2) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 43) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 18) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 11) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 181) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 180) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 62) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 6) {
#line 4393
        goto case_2;
      }
#line 4393
      if ((int )elf_header.e_machine == 3) {
#line 4393
        goto case_2;
      }
#line 4397
      goto switch_default___1;
      case_50: /* CIL Label */ 
#line 4366
      if (flag == 268435456UL) {
#line 4367
        sindex = 10;
      } else
#line 4368
      if (flag == 536870912UL) {
#line 4369
        sindex = 11;
      } else
#line 4371
      if ((int )elf_header.e_ident[7] == 13) {
        {
#line 4374
        if (flag == 4294967296UL) {
#line 4374
          goto case_4294967296;
        }
#line 4375
        if (flag == 8589934592UL) {
#line 4375
          goto case_8589934592;
        }
#line 4376
        if (flag == 17179869184UL) {
#line 4376
          goto case_17179869184;
        }
#line 4377
        if (flag == 34359738368UL) {
#line 4377
          goto case_34359738368;
        }
#line 4378
        if (flag == 68719476736UL) {
#line 4378
          goto case_68719476736;
        }
#line 4379
        if (flag == 137438953472UL) {
#line 4379
          goto case_137438953472;
        }
#line 4380
        goto switch_default___0;
        case_4294967296: /* CIL Label */ 
#line 4374
        sindex = 12;
#line 4374
        goto switch_break___1;
        case_8589934592: /* CIL Label */ 
#line 4375
        sindex = 13;
#line 4375
        goto switch_break___1;
        case_17179869184: /* CIL Label */ 
#line 4376
        sindex = 14;
#line 4376
        goto switch_break___1;
        case_34359738368: /* CIL Label */ 
#line 4377
        sindex = 15;
#line 4377
        goto switch_break___1;
        case_68719476736: /* CIL Label */ 
#line 4378
        sindex = 16;
#line 4378
        goto switch_break___1;
        case_137438953472: /* CIL Label */ 
#line 4379
        sindex = 17;
#line 4379
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 4380
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 4383
      goto switch_break___0;
      case_2: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_18: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_181: /* CIL Label */ 
      case_180: /* CIL Label */ 
      case_62: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 4394
      if (flag == 1073741824UL) {
#line 4395
        sindex = 19;
      }
#line 4396
      goto switch_break___0;
      switch_default___1: /* CIL Label */ 
#line 4398
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
#line 4402
      if (sindex != -1) {
#line 4404
        if ((unsigned long )p != (unsigned long )((buff___8 + field_size) + 4)) {
#line 4406
          if (size < 12) {
            {
#line 4407
            abort();
            }
          }
#line 4408
          size -= 2;
#line 4409
          tmp___1 = p;
#line 4409
          p ++;
#line 4409
          *tmp___1 = (char )',';
#line 4410
          tmp___2 = p;
#line 4410
          p ++;
#line 4410
          *tmp___2 = (char )' ';
        }
        {
#line 4413
        size -= (int )flags[sindex].len;
#line 4414
        p = stpcpy((char */* __restrict  */)p, (char const   */* __restrict  */)flags[sindex].str);
        }
      } else
#line 4416
      if (flag & 267386880UL) {
#line 4417
        os_flags |= flag;
      } else
#line 4418
      if (flag & 4026531840UL) {
#line 4419
        proc_flags |= flag;
      } else {
#line 4421
        unknown_flags |= flag;
      }
    } else {
      {
#line 4427
      if (flag == 1UL) {
#line 4427
        goto case_1___0;
      }
#line 4428
      if (flag == (bfd_vma )(1 << 1)) {
#line 4428
        goto case_exp___8;
      }
#line 4429
      if (flag == (bfd_vma )(1 << 2)) {
#line 4429
        goto case_exp___9;
      }
#line 4430
      if (flag == (bfd_vma )(1 << 4)) {
#line 4430
        goto case_exp___10;
      }
#line 4431
      if (flag == (bfd_vma )(1 << 5)) {
#line 4431
        goto case_exp___11;
      }
#line 4432
      if (flag == (bfd_vma )(1 << 6)) {
#line 4432
        goto case_exp___12;
      }
#line 4433
      if (flag == (bfd_vma )(1 << 7)) {
#line 4433
        goto case_exp___13;
      }
#line 4434
      if (flag == (bfd_vma )(1 << 8)) {
#line 4434
        goto case_exp___14;
      }
#line 4435
      if (flag == (bfd_vma )(1 << 9)) {
#line 4435
        goto case_exp___15;
      }
#line 4436
      if (flag == (bfd_vma )(1 << 10)) {
#line 4436
        goto case_exp___16;
      }
#line 4437
      if (flag == 2147483648UL) {
#line 4437
        goto case_2147483648___0;
      }
#line 4439
      goto switch_default___2;
      case_1___0: /* CIL Label */ 
#line 4427
      *p = (char )'W';
#line 4427
      goto switch_break___2;
      case_exp___8: /* CIL Label */ 
#line 4428
      *p = (char )'A';
#line 4428
      goto switch_break___2;
      case_exp___9: /* CIL Label */ 
#line 4429
      *p = (char )'X';
#line 4429
      goto switch_break___2;
      case_exp___10: /* CIL Label */ 
#line 4430
      *p = (char )'M';
#line 4430
      goto switch_break___2;
      case_exp___11: /* CIL Label */ 
#line 4431
      *p = (char )'S';
#line 4431
      goto switch_break___2;
      case_exp___12: /* CIL Label */ 
#line 4432
      *p = (char )'I';
#line 4432
      goto switch_break___2;
      case_exp___13: /* CIL Label */ 
#line 4433
      *p = (char )'L';
#line 4433
      goto switch_break___2;
      case_exp___14: /* CIL Label */ 
#line 4434
      *p = (char )'O';
#line 4434
      goto switch_break___2;
      case_exp___15: /* CIL Label */ 
#line 4435
      *p = (char )'G';
#line 4435
      goto switch_break___2;
      case_exp___16: /* CIL Label */ 
#line 4436
      *p = (char )'T';
#line 4436
      goto switch_break___2;
      case_2147483648___0: /* CIL Label */ 
#line 4437
      *p = (char )'E';
#line 4437
      goto switch_break___2;
      switch_default___2: /* CIL Label */ 
#line 4440
      if ((int )elf_header.e_machine == 62) {
#line 4440
        goto _L___0;
      } else
#line 4440
      if ((int )elf_header.e_machine == 180) {
#line 4440
        goto _L___0;
      } else
#line 4440
      if ((int )elf_header.e_machine == 181) {
        _L___0: /* CIL Label */ 
#line 4440
        if (flag == 268435456UL) {
#line 4444
          *p = (char )'l';
        } else {
#line 4440
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 4445
      if (flag & 267386880UL) {
#line 4447
        *p = (char )'o';
#line 4448
        sh_flags &= 0xfffffffff00fffffUL;
      } else
#line 4450
      if (flag & 4026531840UL) {
#line 4452
        *p = (char )'p';
#line 4453
        sh_flags &= 268435455UL;
      } else {
#line 4456
        *p = (char )'x';
      }
#line 4457
      goto switch_break___2;
      switch_break___2: /* CIL Label */ ;
      }
#line 4459
      p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 4463
  if (do_section_details) {
#line 4465
    if (os_flags) {
#line 4467
      size -= 5 + field_size;
#line 4468
      if ((unsigned long )p != (unsigned long )((buff___8 + field_size) + 4)) {
#line 4470
        if (size < 3) {
          {
#line 4471
          abort();
          }
        }
#line 4472
        size -= 2;
#line 4473
        tmp___3 = p;
#line 4473
        p ++;
#line 4473
        *tmp___3 = (char )',';
#line 4474
        tmp___4 = p;
#line 4474
        p ++;
#line 4474
        *tmp___4 = (char )' ';
      }
      {
#line 4476
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"OS (%*.*lx)",
              field_size, field_size, os_flags);
#line 4478
      p += 5 + field_size;
      }
    }
#line 4480
    if (proc_flags) {
#line 4482
      size -= 7 + field_size;
#line 4483
      if ((unsigned long )p != (unsigned long )((buff___8 + field_size) + 4)) {
#line 4485
        if (size < 3) {
          {
#line 4486
          abort();
          }
        }
#line 4487
        size -= 2;
#line 4488
        tmp___5 = p;
#line 4488
        p ++;
#line 4488
        *tmp___5 = (char )',';
#line 4489
        tmp___6 = p;
#line 4489
        p ++;
#line 4489
        *tmp___6 = (char )' ';
      }
      {
#line 4491
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"PROC (%*.*lx)",
              field_size, field_size, proc_flags);
#line 4493
      p += 7 + field_size;
      }
    }
#line 4495
    if (unknown_flags) {
#line 4497
      size -= 10 + field_size;
#line 4498
      if ((unsigned long )p != (unsigned long )((buff___8 + field_size) + 4)) {
#line 4500
        if (size < 3) {
          {
#line 4501
          abort();
          }
        }
#line 4502
        size -= 2;
#line 4503
        tmp___7 = p;
#line 4503
        p ++;
#line 4503
        *tmp___7 = (char )',';
#line 4504
        tmp___8 = p;
#line 4504
        p ++;
#line 4504
        *tmp___8 = (char )' ';
      }
      {
#line 4506
      tmp___9 = gettext("UNKNOWN (%*.*lx)");
#line 4506
      sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)tmp___9,
              field_size, field_size, unknown_flags);
#line 4508
      p += 10 + field_size;
      }
    }
  }
#line 4512
  *p = (char )'\000';
#line 4513
  return ((char const   *)(buff___8));
}
}
#line 4516 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_section_headers(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  Elf_Internal_Shdr *tmp___7 ;
  char *name___0 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t expected_entsize ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  Elf_Internal_Sym *tmp___17 ;
  Elf_Internal_Sym *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  void *tmp___21 ;
  char *tmp___22 ;
  size_t expected_entsize___0 ;
  unsigned long tmp___23 ;
  char *tmp___24 ;
  size_t expected_entsize___1 ;
  int tmp___25 ;
  char *tmp___26 ;
  size_t expected_entsize___2 ;
  unsigned long tmp___27 ;
  char *tmp___28 ;
  size_t expected_entsize___3 ;
  unsigned long tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char const   *tmp___80 ;
  char const   *tmp___81 ;
  char const   *link_too_big ;
  char const   *tmp___82 ;
  char *tmp___83 ;
  char const   *tmp___84 ;
  char const   *tmp___85 ;
  char const   *tmp___86 ;
  char const   *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;

  {
#line 4522
  section_headers = (Elf_Internal_Shdr *)((void *)0);
#line 4524
  if (elf_header.e_shnum == 0U) {
#line 4527
    if (elf_header.e_shoff != 0UL) {
      {
#line 4528
      tmp___0 = gettext("possibly corrupt ELF file header - it has a non-zero section header offset, but no section headers\n");
#line 4528
      warn((char const   *)tmp___0);
      }
    } else
#line 4530
    if (do_sections) {
      {
#line 4531
      tmp___1 = gettext("\nThere are no sections in this file.\n");
#line 4531
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 4533
    return (1);
  }
#line 4536
  if (do_sections) {
#line 4536
    if (! do_header) {
      {
#line 4537
      tmp___2 = gettext("There are %d section headers, starting at offset 0x%lx:\n");
#line 4537
      printf((char const   */* __restrict  */)tmp___2, elf_header.e_shnum, elf_header.e_shoff);
      }
    }
  }
#line 4540
  if (is_32bit_elf) {
    {
#line 4542
    tmp___3 = get_32bit_section_headers(file, elf_header.e_shnum);
    }
#line 4542
    if (! tmp___3) {
#line 4543
      return (0);
    }
  } else {
    {
#line 4545
    tmp___4 = get_64bit_section_headers(file, elf_header.e_shnum);
    }
#line 4545
    if (! tmp___4) {
#line 4546
      return (0);
    }
  }
#line 4549
  if (elf_header.e_shstrndx != 0U) {
#line 4549
    if (elf_header.e_shstrndx < elf_header.e_shnum) {
#line 4552
      section = section_headers + elf_header.e_shstrndx;
#line 4554
      if (section->sh_size != 0UL) {
        {
#line 4556
        tmp___5 = gettext("string table");
#line 4556
        tmp___6 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                           (char const   *)tmp___5);
#line 4556
        string_table = (char *)tmp___6;
        }
#line 4560
        if ((unsigned long )string_table != (unsigned long )((void *)0)) {
#line 4560
          string_table_length = section->sh_size;
        } else {
#line 4560
          string_table_length = 0UL;
        }
      }
    }
  }
#line 4566
  dynamic_symbols = (Elf_Internal_Sym *)((void *)0);
#line 4567
  dynamic_strings = (char *)((void *)0);
#line 4568
  dynamic_syminfo = (Elf_Internal_Syminfo *)((void *)0);
#line 4569
  symtab_shndx_hdr = (Elf_Internal_Shdr *)((void *)0);
#line 4571
  if (is_32bit_elf) {
#line 4571
    eh_addr_size = 4;
  } else {
#line 4571
    eh_addr_size = 8;
  }
  {
#line 4575
  if ((int )elf_header.e_machine == 10) {
#line 4575
    goto case_10;
  }
#line 4575
  if ((int )elf_header.e_machine == 8) {
#line 4575
    goto case_10;
  }
#line 4591
  if ((int )elf_header.e_machine == 47) {
#line 4591
    goto case_47;
  }
#line 4591
  if ((int )elf_header.e_machine == 46) {
#line 4591
    goto case_47;
  }
#line 4609
  if ((int )elf_header.e_machine == 120) {
#line 4609
    goto case_120;
  }
#line 4609
  if ((int )elf_header.e_machine == 65200) {
#line 4609
    goto case_120;
  }
#line 4572
  goto switch_break;
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 4585
  if ((elf_header.e_flags & 61440UL) == 16384UL) {
    {
#line 4585
    tmp___7 = find_section(".gcc_compiled_long32");
    }
#line 4585
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 4587
      eh_addr_size = 8;
    }
  }
#line 4588
  goto switch_break;
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  {
#line 4597
  if ((elf_header.e_flags & 16711680UL) == 8781824UL) {
#line 4597
    goto case_8781824;
  }
#line 4597
  if ((elf_header.e_flags & 16711680UL) == 8650752UL) {
#line 4597
    goto case_8781824;
  }
#line 4597
  if ((elf_header.e_flags & 16711680UL) == 8585216UL) {
#line 4597
    goto case_8781824;
  }
#line 4597
  if ((elf_header.e_flags & 16711680UL) == 8388608UL) {
#line 4597
    goto case_8781824;
  }
#line 4602
  if ((elf_header.e_flags & 16711680UL) == 8716288UL) {
#line 4602
    goto case_8716288;
  }
#line 4602
  if ((elf_header.e_flags & 16711680UL) == 8519680UL) {
#line 4602
    goto case_8716288;
  }
#line 4602
  if ((elf_header.e_flags & 16711680UL) == 8454144UL) {
#line 4602
    goto case_8716288;
  }
#line 4592
  goto switch_break___0;
  case_8781824: /* CIL Label */ 
  case_8650752: /* CIL Label */ 
  case_8585216: /* CIL Label */ 
  case_8388608: /* CIL Label */ 
#line 4598
  eh_addr_size = 2;
#line 4599
  goto switch_break___0;
  case_8716288: /* CIL Label */ 
  case_8519680: /* CIL Label */ 
  case_8454144: /* CIL Label */ 
#line 4603
  eh_addr_size = 4;
#line 4604
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 4606
  goto switch_break;
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
  {
#line 4612
  if ((elf_header.e_flags & 127UL) == 117UL) {
#line 4612
    goto case_117;
  }
#line 4610
  goto switch_break___1;
  case_117: /* CIL Label */ 
#line 4613
  eh_addr_size = 2;
#line 4614
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 4616
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4635
  i = 0U;
#line 4635
  section = section_headers;
  {
#line 4635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4635
    if (! (i < elf_header.e_shnum)) {
#line 4635
      goto while_break;
    }
#line 4639
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 4639
      tmp___8 = gettext("<none>");
#line 4639
      tmp___13 = tmp___8;
      }
    } else {
#line 4639
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 4639
        tmp___9 = gettext("<no-name>");
#line 4639
        tmp___12 = tmp___9;
        }
      } else {
#line 4639
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 4639
          tmp___10 = gettext("<corrupt>");
#line 4639
          tmp___11 = tmp___10;
          }
        } else {
#line 4639
          tmp___11 = string_table + section->sh_name;
        }
#line 4639
        tmp___12 = tmp___11;
      }
#line 4639
      tmp___13 = tmp___12;
    }
#line 4639
    name___0 = tmp___13;
#line 4641
    if (section->sh_type == 11U) {
#line 4643
      if ((unsigned long )dynamic_symbols != (unsigned long )((void *)0)) {
        {
#line 4645
        tmp___14 = gettext("File contains multiple dynamic symbol tables\n");
#line 4645
        error((char const   *)tmp___14);
        }
#line 4646
        goto __Cont;
      }
      {
#line 4649
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 4649
        if (is_32bit_elf) {
#line 4649
          tmp___15 = sizeof(Elf32_External_Sym );
        } else {
#line 4649
          tmp___15 = sizeof(Elf64_External_Sym );
        }
#line 4649
        expected_entsize = tmp___15;
#line 4649
        if (section->sh_entsize != expected_entsize) {
          {
#line 4649
          tmp___16 = gettext("Section %d has invalid sh_entsize %lx (expected %lx)\n");
#line 4649
          error((char const   *)tmp___16, i, section->sh_entsize, expected_entsize);
          }
        }
#line 4649
        section->sh_entsize = expected_entsize;
#line 4649
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 4650
      if (is_32bit_elf) {
        {
#line 4650
        tmp___17 = get_32bit_elf_symbols(file, section, & num_dynamic_syms);
#line 4650
        dynamic_symbols = tmp___17;
        }
      } else {
        {
#line 4650
        tmp___18 = get_64bit_elf_symbols(file, section, & num_dynamic_syms);
#line 4650
        dynamic_symbols = tmp___18;
        }
      }
    } else
#line 4652
    if (section->sh_type == 3U) {
      {
#line 4652
      tmp___53 = strcmp((char const   *)name___0, ".dynstr");
      }
#line 4652
      if (tmp___53 == 0) {
#line 4655
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
          {
#line 4657
          tmp___19 = gettext("File contains multiple dynamic string tables\n");
#line 4657
          error((char const   *)tmp___19);
          }
#line 4658
          goto __Cont;
        }
        {
#line 4661
        tmp___20 = gettext("dynamic strings");
#line 4661
        tmp___21 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                            (char const   *)tmp___20);
#line 4661
        dynamic_strings = (char *)tmp___21;
        }
#line 4664
        if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 4664
          dynamic_strings_length = 0UL;
        } else {
#line 4664
          dynamic_strings_length = section->sh_size;
        }
      } else {
#line 4652
        goto _L___21;
      }
    } else
    _L___21: /* CIL Label */ 
#line 4666
    if (section->sh_type == 18U) {
#line 4668
      if ((unsigned long )symtab_shndx_hdr != (unsigned long )((void *)0)) {
        {
#line 4670
        tmp___22 = gettext("File contains multiple symtab shndx tables\n");
#line 4670
        error((char const   *)tmp___22);
        }
#line 4671
        goto __Cont;
      }
#line 4673
      symtab_shndx_hdr = section;
    } else
#line 4675
    if (section->sh_type == 2U) {
      {
#line 4676
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 4676
        if (is_32bit_elf) {
#line 4676
          tmp___23 = sizeof(Elf32_External_Sym );
        } else {
#line 4676
          tmp___23 = sizeof(Elf64_External_Sym );
        }
#line 4676
        expected_entsize___0 = tmp___23;
#line 4676
        if (section->sh_entsize != expected_entsize___0) {
          {
#line 4676
          tmp___24 = gettext("Section %d has invalid sh_entsize %lx (expected %lx)\n");
#line 4676
          error((char const   *)tmp___24, i, section->sh_entsize, expected_entsize___0);
          }
        }
#line 4676
        section->sh_entsize = expected_entsize___0;
#line 4676
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    } else
#line 4677
    if (section->sh_type == 17U) {
      {
#line 4678
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 4678
        if (is_32bit_elf) {
#line 4678
          tmp___25 = 4;
        } else {
#line 4678
          tmp___25 = 4;
        }
#line 4678
        expected_entsize___1 = (size_t )tmp___25;
#line 4678
        if (section->sh_entsize != expected_entsize___1) {
          {
#line 4678
          tmp___26 = gettext("Section %d has invalid sh_entsize %lx (expected %lx)\n");
#line 4678
          error((char const   *)tmp___26, i, section->sh_entsize, expected_entsize___1);
          }
        }
#line 4678
        section->sh_entsize = expected_entsize___1;
#line 4678
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else
#line 4679
    if (section->sh_type == 9U) {
      {
#line 4680
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 4680
        if (is_32bit_elf) {
#line 4680
          tmp___27 = sizeof(Elf32_External_Rel );
        } else {
#line 4680
          tmp___27 = sizeof(Elf64_External_Rel );
        }
#line 4680
        expected_entsize___2 = tmp___27;
#line 4680
        if (section->sh_entsize != expected_entsize___2) {
          {
#line 4680
          tmp___28 = gettext("Section %d has invalid sh_entsize %lx (expected %lx)\n");
#line 4680
          error((char const   *)tmp___28, i, section->sh_entsize, expected_entsize___2);
          }
        }
#line 4680
        section->sh_entsize = expected_entsize___2;
#line 4680
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else
#line 4681
    if (section->sh_type == 4U) {
      {
#line 4682
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4682
        if (is_32bit_elf) {
#line 4682
          tmp___29 = sizeof(Elf32_External_Rela );
        } else {
#line 4682
          tmp___29 = sizeof(Elf64_External_Rela );
        }
#line 4682
        expected_entsize___3 = tmp___29;
#line 4682
        if (section->sh_entsize != expected_entsize___3) {
          {
#line 4682
          tmp___30 = gettext("Section %d has invalid sh_entsize %lx (expected %lx)\n");
#line 4682
          error((char const   *)tmp___30, i, section->sh_entsize, expected_entsize___3);
          }
        }
#line 4682
        section->sh_entsize = expected_entsize___3;
#line 4682
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    } else
#line 4683
    if (do_debugging) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_info) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_abbrevs) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_lines) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_pubnames) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_pubtypes) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_aranges) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_frames) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_macinfo) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_str) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_loc) {
#line 4683
      goto _L___20;
    } else
#line 4683
    if (do_debug_ranges) {
      _L___20: /* CIL Label */ 
      {
#line 4683
      tmp___51 = strncmp((char const   *)name___0, ".debug_", sizeof(".debug_") - 1UL);
      }
#line 4683
      if (tmp___51 == 0) {
#line 4683
        goto _L___19;
      } else {
        {
#line 4683
        tmp___52 = strncmp((char const   *)name___0, ".zdebug_", sizeof(".zdebug_") - 1UL);
        }
#line 4683
        if (tmp___52 == 0) {
          _L___19: /* CIL Label */ 
#line 4690
          if ((int )*(name___0 + 1) == 122) {
#line 4691
            name___0 += sizeof(".zdebug_") - 1UL;
          } else {
#line 4693
            name___0 += sizeof(".debug_") - 1UL;
          }
#line 4695
          if (do_debugging) {
            {
#line 4710
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          } else
#line 4695
          if (do_debug_info) {
            {
#line 4695
            tmp___31 = strncmp((char const   *)name___0, "info", sizeof("info") - 1UL);
            }
#line 4695
            if (tmp___31 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___10;
            }
          } else
          _L___10: /* CIL Label */ 
#line 4695
          if (do_debug_info) {
            {
#line 4695
            tmp___32 = strncmp((char const   *)name___0, "types", sizeof("types") - 1UL);
            }
#line 4695
            if (tmp___32 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___9;
            }
          } else
          _L___9: /* CIL Label */ 
#line 4695
          if (do_debug_abbrevs) {
            {
#line 4695
            tmp___33 = strncmp((char const   *)name___0, "abbrev", sizeof("abbrev") - 1UL);
            }
#line 4695
            if (tmp___33 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___8;
            }
          } else
          _L___8: /* CIL Label */ 
#line 4695
          if (do_debug_lines) {
            {
#line 4695
            tmp___34 = strncmp((char const   *)name___0, "line", sizeof("line") - 1UL);
            }
#line 4695
            if (tmp___34 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___7;
            }
          } else
          _L___7: /* CIL Label */ 
#line 4695
          if (do_debug_pubnames) {
            {
#line 4695
            tmp___35 = strncmp((char const   *)name___0, "pubnames", sizeof("pubnames") - 1UL);
            }
#line 4695
            if (tmp___35 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___6;
            }
          } else
          _L___6: /* CIL Label */ 
#line 4695
          if (do_debug_pubtypes) {
            {
#line 4695
            tmp___36 = strncmp((char const   *)name___0, "pubtypes", sizeof("pubtypes") - 1UL);
            }
#line 4695
            if (tmp___36 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___5;
            }
          } else
          _L___5: /* CIL Label */ 
#line 4695
          if (do_debug_aranges) {
            {
#line 4695
            tmp___37 = strncmp((char const   *)name___0, "aranges", sizeof("aranges") - 1UL);
            }
#line 4695
            if (tmp___37 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___4;
            }
          } else
          _L___4: /* CIL Label */ 
#line 4695
          if (do_debug_ranges) {
            {
#line 4695
            tmp___38 = strncmp((char const   *)name___0, "ranges", sizeof("ranges") - 1UL);
            }
#line 4695
            if (tmp___38 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___3;
            }
          } else
          _L___3: /* CIL Label */ 
#line 4695
          if (do_debug_frames) {
            {
#line 4695
            tmp___39 = strncmp((char const   *)name___0, "frame", sizeof("frame") - 1UL);
            }
#line 4695
            if (tmp___39 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 4695
          if (do_debug_macinfo) {
            {
#line 4695
            tmp___40 = strncmp((char const   *)name___0, "macinfo", sizeof("macinfo") - 1UL);
            }
#line 4695
            if (tmp___40 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 4695
          if (do_debug_macinfo) {
            {
#line 4695
            tmp___41 = strncmp((char const   *)name___0, "macro", sizeof("macro") - 1UL);
            }
#line 4695
            if (tmp___41 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 4695
          if (do_debug_str) {
            {
#line 4695
            tmp___42 = strncmp((char const   *)name___0, "str", sizeof("str") - 1UL);
            }
#line 4695
            if (tmp___42 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            } else {
#line 4695
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 4695
          if (do_debug_loc) {
            {
#line 4695
            tmp___43 = strncmp((char const   *)name___0, "loc", sizeof("loc") - 1UL);
            }
#line 4695
            if (tmp___43 == 0) {
              {
#line 4710
              request_dump_bynumber(i, (dump_type )(1 << 2));
              }
            }
          }
        } else {
#line 4683
          goto _L___18;
        }
      }
    } else
    _L___18: /* CIL Label */ 
#line 4713
    if (do_debugging) {
#line 4713
      goto _L___17;
    } else
#line 4713
    if (do_debug_info) {
      _L___17: /* CIL Label */ 
      {
#line 4713
      tmp___50 = strncmp((char const   *)name___0, ".gnu.linkonce.wi.", sizeof(".gnu.linkonce.wi.") - 1UL);
      }
#line 4713
      if (tmp___50 == 0) {
        {
#line 4715
        request_dump_bynumber(i, (dump_type )(1 << 2));
        }
      } else {
#line 4713
        goto _L___16;
      }
    } else
    _L___16: /* CIL Label */ 
#line 4716
    if (do_debug_frames) {
      {
#line 4716
      tmp___49 = strcmp((char const   *)name___0, ".eh_frame");
      }
#line 4716
      if (tmp___49 == 0) {
        {
#line 4717
        request_dump_bynumber(i, (dump_type )(1 << 2));
        }
      } else {
#line 4716
        goto _L___15;
      }
    } else
    _L___15: /* CIL Label */ 
#line 4718
    if (do_gdb_index) {
      {
#line 4718
      tmp___48 = strcmp((char const   *)name___0, ".gdb_index");
      }
#line 4718
      if (tmp___48 == 0) {
        {
#line 4719
        request_dump_bynumber(i, (dump_type )(1 << 2));
        }
      } else {
#line 4718
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 4721
    if (do_debugging) {
#line 4721
      goto _L___13;
    } else
#line 4721
    if (do_trace_info) {
#line 4721
      goto _L___13;
    } else
#line 4721
    if (do_trace_abbrevs) {
#line 4721
      goto _L___13;
    } else
#line 4721
    if (do_trace_aranges) {
      _L___13: /* CIL Label */ 
      {
#line 4721
      tmp___47 = strncmp((char const   *)name___0, ".trace_", sizeof(".trace_") - 1UL);
      }
#line 4721
      if (tmp___47 == 0) {
#line 4725
        name___0 += sizeof(".trace_") - 1UL;
#line 4727
        if (do_debugging) {
          {
#line 4732
          request_dump_bynumber(i, (dump_type )(1 << 2));
          }
        } else
#line 4727
        if (do_trace_info) {
          {
#line 4727
          tmp___44 = strcmp((char const   *)name___0, "info");
          }
#line 4727
          if (tmp___44 == 0) {
            {
#line 4732
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          } else {
#line 4727
            goto _L___12;
          }
        } else
        _L___12: /* CIL Label */ 
#line 4727
        if (do_trace_abbrevs) {
          {
#line 4727
          tmp___45 = strcmp((char const   *)name___0, "abbrev");
          }
#line 4727
          if (tmp___45 == 0) {
            {
#line 4732
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          } else {
#line 4727
            goto _L___11;
          }
        } else
        _L___11: /* CIL Label */ 
#line 4727
        if (do_trace_aranges) {
          {
#line 4727
          tmp___46 = strcmp((char const   *)name___0, "aranges");
          }
#line 4727
          if (tmp___46 == 0) {
            {
#line 4732
            request_dump_bynumber(i, (dump_type )(1 << 2));
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 4635
    i ++;
#line 4635
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4737
  if (! do_sections) {
#line 4738
    return (1);
  }
#line 4740
  if (elf_header.e_shnum > 1U) {
    {
#line 4741
    tmp___54 = gettext("\nSection Headers:\n");
#line 4741
    printf((char const   */* __restrict  */)tmp___54);
    }
  } else {
    {
#line 4743
    tmp___55 = gettext("\nSection Header:\n");
#line 4743
    printf((char const   */* __restrict  */)tmp___55);
    }
  }
#line 4745
  if (is_32bit_elf) {
#line 4747
    if (do_section_details) {
      {
#line 4749
      tmp___56 = gettext("  [Nr] Name\n");
#line 4749
      printf((char const   */* __restrict  */)tmp___56);
#line 4750
      tmp___57 = gettext("       Type            Addr     Off    Size   ES   Lk Inf Al\n");
#line 4750
      printf((char const   */* __restrict  */)tmp___57);
      }
    } else {
      {
#line 4753
      tmp___58 = gettext("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n");
#line 4753
      printf((char const   */* __restrict  */)tmp___58);
      }
    }
  } else
#line 4756
  if (do_wide) {
#line 4758
    if (do_section_details) {
      {
#line 4760
      tmp___59 = gettext("  [Nr] Name\n");
#line 4760
      printf((char const   */* __restrict  */)tmp___59);
#line 4761
      tmp___60 = gettext("       Type            Address          Off    Size   ES   Lk Inf Al\n");
#line 4761
      printf((char const   */* __restrict  */)tmp___60);
      }
    } else {
      {
#line 4764
      tmp___61 = gettext("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n");
#line 4764
      printf((char const   */* __restrict  */)tmp___61);
      }
    }
  } else
#line 4769
  if (do_section_details) {
    {
#line 4771
    tmp___62 = gettext("  [Nr] Name\n");
#line 4771
    printf((char const   */* __restrict  */)tmp___62);
#line 4772
    tmp___63 = gettext("       Type              Address          Offset            Link\n");
#line 4772
    printf((char const   */* __restrict  */)tmp___63);
#line 4773
    tmp___64 = gettext("       Size              EntSize          Info              Align\n");
#line 4773
    printf((char const   */* __restrict  */)tmp___64);
    }
  } else {
    {
#line 4777
    tmp___65 = gettext("  [Nr] Name              Type             Address           Offset\n");
#line 4777
    printf((char const   */* __restrict  */)tmp___65);
#line 4778
    tmp___66 = gettext("       Size              EntSize          Flags  Link  Info  Align\n");
#line 4778
    printf((char const   */* __restrict  */)tmp___66);
    }
  }
#line 4782
  if (do_section_details) {
    {
#line 4783
    tmp___67 = gettext("       Flags\n");
#line 4783
    printf((char const   */* __restrict  */)tmp___67);
    }
  }
#line 4785
  i = 0U;
#line 4785
  section = section_headers;
  {
#line 4785
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 4785
    if (! (i < elf_header.e_shnum)) {
#line 4785
      goto while_break___5;
    }
    {
#line 4789
    printf((char const   */* __restrict  */)"  [%2u] ", i);
    }
#line 4790
    if (do_section_details) {
#line 4792
      if ((unsigned long )section == (unsigned long )((void *)0)) {
        {
#line 4792
        tmp___68 = gettext("<none>");
#line 4792
        tmp___73 = tmp___68;
        }
      } else {
#line 4792
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 4792
          tmp___69 = gettext("<no-name>");
#line 4792
          tmp___72 = tmp___69;
          }
        } else {
#line 4792
          if ((unsigned long )section->sh_name >= string_table_length) {
            {
#line 4792
            tmp___70 = gettext("<corrupt>");
#line 4792
            tmp___71 = tmp___70;
            }
          } else {
#line 4792
            tmp___71 = string_table + section->sh_name;
          }
#line 4792
          tmp___72 = tmp___71;
        }
#line 4792
        tmp___73 = tmp___72;
      }
      {
#line 4792
      print_symbol(2147483647, (char const   *)tmp___73);
#line 4793
      printf((char const   */* __restrict  */)"\n      ");
      }
    } else {
#line 4797
      if ((unsigned long )section == (unsigned long )((void *)0)) {
        {
#line 4797
        tmp___74 = gettext("<none>");
#line 4797
        tmp___79 = tmp___74;
        }
      } else {
#line 4797
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 4797
          tmp___75 = gettext("<no-name>");
#line 4797
          tmp___78 = tmp___75;
          }
        } else {
#line 4797
          if ((unsigned long )section->sh_name >= string_table_length) {
            {
#line 4797
            tmp___76 = gettext("<corrupt>");
#line 4797
            tmp___77 = tmp___76;
            }
          } else {
#line 4797
            tmp___77 = string_table + section->sh_name;
          }
#line 4797
          tmp___78 = tmp___77;
        }
#line 4797
        tmp___79 = tmp___78;
      }
      {
#line 4797
      print_symbol(-17, (char const   *)tmp___79);
      }
    }
    {
#line 4800
    tmp___80 = get_section_type_name(section->sh_type);
    }
#line 4800
    if (do_wide) {
#line 4800
      tmp___81 = " %-15s ";
    } else {
#line 4800
      tmp___81 = " %-15.15s ";
    }
    {
#line 4800
    printf((char const   */* __restrict  */)tmp___81, tmp___80);
    }
#line 4803
    if (is_32bit_elf) {
      {
#line 4805
      link_too_big = (char const   *)((void *)0);
#line 4807
      print_vma(section->sh_addr, (print_mode )6);
#line 4809
      printf((char const   */* __restrict  */)" %6.6lx %6.6lx %2.2lx", (unsigned long )section->sh_offset,
             section->sh_size, section->sh_entsize);
      }
#line 4814
      if (do_section_details) {
        {
#line 4815
        fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 4817
        tmp___82 = get_elf_section_flags(section->sh_flags);
#line 4817
        printf((char const   */* __restrict  */)" %3s ", tmp___82);
        }
      }
#line 4819
      if (section->sh_link >= elf_header.e_shnum) {
#line 4821
        link_too_big = "";
        {
#line 4834
        if ((int )elf_header.e_machine == 2) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 43) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 18) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 11) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 181) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 180) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 62) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 6) {
#line 4834
          goto case_2;
        }
#line 4834
        if ((int )elf_header.e_machine == 3) {
#line 4834
          goto case_2;
        }
#line 4840
        goto switch_default;
        case_2: /* CIL Label */ 
        case_43: /* CIL Label */ 
        case_18: /* CIL Label */ 
        case_11: /* CIL Label */ 
        case_181: /* CIL Label */ 
        case_180: /* CIL Label */ 
        case_62: /* CIL Label */ 
        case_6: /* CIL Label */ 
        case_3: /* CIL Label */ 
#line 4835
        if (section->sh_link == 65280U) {
#line 4836
          link_too_big = "BEFORE";
        } else
#line 4837
        if (section->sh_link == 65281U) {
#line 4838
          link_too_big = "AFTER";
        }
#line 4839
        goto switch_break___2;
        switch_default: /* CIL Label */ 
#line 4841
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
      }
#line 4845
      if (do_section_details) {
#line 4847
        if ((unsigned long )link_too_big != (unsigned long )((void *)0)) {
#line 4847
          if (*link_too_big) {
            {
#line 4848
            printf((char const   */* __restrict  */)"<%s> ", link_too_big);
            }
          } else {
            {
#line 4850
            printf((char const   */* __restrict  */)"%2u ", section->sh_link);
            }
          }
        } else {
          {
#line 4850
          printf((char const   */* __restrict  */)"%2u ", section->sh_link);
          }
        }
        {
#line 4851
        printf((char const   */* __restrict  */)"%3u %2lu\n", section->sh_info, section->sh_addralign);
        }
      } else {
        {
#line 4855
        printf((char const   */* __restrict  */)"%2u %3u %2lu\n", section->sh_link,
               section->sh_info, section->sh_addralign);
        }
      }
#line 4860
      if (link_too_big) {
#line 4860
        if (! *link_too_big) {
          {
#line 4861
          tmp___83 = gettext("section %u: sh_link value of %u is larger than the number of sections\n");
#line 4861
          warn((char const   *)tmp___83, i, section->sh_link);
          }
        }
      }
    } else
#line 4864
    if (do_wide) {
      {
#line 4866
      print_vma(section->sh_addr, (print_mode )6);
      }
#line 4868
      if (section->sh_offset == section->sh_offset) {
        {
#line 4869
        printf((char const   */* __restrict  */)" %6.6lx", (unsigned long )section->sh_offset);
        }
      } else {
        {
#line 4872
        putchar(' ');
#line 4873
        print_vma((bfd_vma )section->sh_offset, (print_mode )6);
        }
      }
#line 4876
      if (section->sh_size == section->sh_size) {
        {
#line 4877
        printf((char const   */* __restrict  */)" %6.6lx", section->sh_size);
        }
      } else {
        {
#line 4880
        putchar(' ');
#line 4881
        print_vma(section->sh_size, (print_mode )6);
        }
      }
#line 4884
      if (section->sh_entsize == section->sh_entsize) {
        {
#line 4885
        printf((char const   */* __restrict  */)" %2.2lx", section->sh_entsize);
        }
      } else {
        {
#line 4888
        putchar(' ');
#line 4889
        print_vma(section->sh_entsize, (print_mode )6);
        }
      }
#line 4892
      if (do_section_details) {
        {
#line 4893
        fputs((char const   */* __restrict  */)"  ", (FILE */* __restrict  */)stdout);
        }
      } else {
        {
#line 4895
        tmp___84 = get_elf_section_flags(section->sh_flags);
#line 4895
        printf((char const   */* __restrict  */)" %3s ", tmp___84);
        }
      }
      {
#line 4897
      printf((char const   */* __restrict  */)"%2u %3u ", section->sh_link, section->sh_info);
      }
#line 4899
      if (section->sh_addralign == section->sh_addralign) {
        {
#line 4900
        printf((char const   */* __restrict  */)"%2lu\n", section->sh_addralign);
        }
      } else {
        {
#line 4903
        print_vma(section->sh_addralign, (print_mode )1);
#line 4904
        putchar('\n');
        }
      }
    } else
#line 4907
    if (do_section_details) {
      {
#line 4909
      tmp___85 = get_section_type_name(section->sh_type);
#line 4909
      printf((char const   */* __restrict  */)"       %-15.15s  ", tmp___85);
#line 4911
      print_vma(section->sh_addr, (print_mode )6);
      }
#line 4912
      if (section->sh_offset == section->sh_offset) {
        {
#line 4913
        printf((char const   */* __restrict  */)"  %16.16lx", (unsigned long )section->sh_offset);
        }
      } else {
        {
#line 4916
        printf((char const   */* __restrict  */)"  ");
#line 4917
        print_vma((bfd_vma )section->sh_offset, (print_mode )6);
        }
      }
      {
#line 4919
      printf((char const   */* __restrict  */)"  %u\n       ", section->sh_link);
#line 4920
      print_vma(section->sh_size, (print_mode )6);
#line 4921
      putchar(' ');
#line 4922
      print_vma(section->sh_entsize, (print_mode )6);
#line 4924
      printf((char const   */* __restrict  */)"  %-16u  %lu\n", section->sh_info,
             section->sh_addralign);
      }
    } else {
      {
#line 4930
      putchar(' ');
#line 4931
      print_vma(section->sh_addr, (print_mode )6);
      }
#line 4932
      if (section->sh_offset == section->sh_offset) {
        {
#line 4933
        printf((char const   */* __restrict  */)"  %8.8lx", (unsigned long )section->sh_offset);
        }
      } else {
        {
#line 4936
        printf((char const   */* __restrict  */)"  ");
#line 4937
        print_vma((bfd_vma )section->sh_offset, (print_mode )6);
        }
      }
      {
#line 4939
      printf((char const   */* __restrict  */)"\n       ");
#line 4940
      print_vma(section->sh_size, (print_mode )6);
#line 4941
      printf((char const   */* __restrict  */)"  ");
#line 4942
      print_vma(section->sh_entsize, (print_mode )6);
#line 4944
      tmp___86 = get_elf_section_flags(section->sh_flags);
#line 4944
      printf((char const   */* __restrict  */)" %3s ", tmp___86);
#line 4946
      printf((char const   */* __restrict  */)"     %2u   %3u     %lu\n", section->sh_link,
             section->sh_info, section->sh_addralign);
      }
    }
#line 4952
    if (do_section_details) {
      {
#line 4953
      tmp___87 = get_elf_section_flags(section->sh_flags);
#line 4953
      printf((char const   */* __restrict  */)"       %s\n", tmp___87);
      }
    }
#line 4785
    i ++;
#line 4785
    section ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 4956
  if (! do_section_details) {
#line 4958
    if ((int )elf_header.e_machine == 62) {
      {
#line 4961
      tmp___88 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 4961
      printf((char const   */* __restrict  */)tmp___88);
      }
    } else
#line 4958
    if ((int )elf_header.e_machine == 180) {
      {
#line 4961
      tmp___88 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 4961
      printf((char const   */* __restrict  */)tmp___88);
      }
    } else
#line 4958
    if ((int )elf_header.e_machine == 181) {
      {
#line 4961
      tmp___88 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 4961
      printf((char const   */* __restrict  */)tmp___88);
      }
    } else {
      {
#line 4966
      tmp___89 = gettext("Key to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)\n");
#line 4966
      printf((char const   */* __restrict  */)tmp___89);
      }
    }
  }
#line 4972
  return (1);
}
}
#line 4978 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___9[32]  ;
#line 4975 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_group_flags(unsigned int flags___1 ) 
{ 
  char *tmp___0 ;

  {
  {
#line 4981
  if (flags___1 == 0U) {
#line 4981
    goto case_0;
  }
#line 4984
  if (flags___1 == 1U) {
#line 4984
    goto case_1;
  }
#line 4987
  goto switch_default;
  case_0: /* CIL Label */ 
#line 4982
  return ("");
  case_1: /* CIL Label */ 
#line 4985
  return ("COMDAT ");
  switch_default: /* CIL Label */ 
  {
#line 4988
  tmp___0 = gettext("[<unknown>: 0x%x] ");
#line 4988
  snprintf((char */* __restrict  */)(buff___9), sizeof(buff___9), (char const   */* __restrict  */)tmp___0,
           flags___1);
  }
#line 4989
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 4991
  return ((char const   *)(buff___9));
}
}
#line 5201
static int process_section_groups(FILE *file ) ;
#line 5201 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int warned___0  =    0;
#line 4994 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_section_groups(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  struct group *group ;
  Elf_Internal_Shdr *symtab_sec ;
  Elf_Internal_Shdr *strtab_sec ;
  Elf_Internal_Sym *symtab ;
  unsigned long num_syms ;
  char *strtab ;
  size_t strtab_size ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *name___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *group_name ;
  unsigned char *start ;
  unsigned char *indices ;
  unsigned int entry ;
  unsigned int j ;
  unsigned int size ;
  Elf_Internal_Shdr *sec ;
  Elf_Internal_Sym *sym ;
  char *tmp___13 ;
  Elf_Internal_Sym *tmp___14 ;
  Elf_Internal_Sym *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  void *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  void *tmp___28 ;
  elf_vma tmp___29 ;
  char const   *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  struct group_list *g ;
  elf_vma tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  void *tmp___43 ;

  {
#line 5008
  if (! do_unwind) {
#line 5008
    if (! do_section_groups) {
#line 5009
      return (1);
    }
  }
#line 5011
  if (elf_header.e_shnum == 0U) {
#line 5013
    if (do_section_groups) {
      {
#line 5014
      tmp___0 = gettext("\nThere are no sections to group in this file.\n");
#line 5014
      printf((char const   */* __restrict  */)tmp___0);
      }
    }
#line 5016
    return (1);
  }
#line 5019
  if ((unsigned long )section_headers == (unsigned long )((void *)0)) {
    {
#line 5021
    tmp___1 = gettext("Section headers are not available!\n");
#line 5021
    error((char const   *)tmp___1);
    }
#line 5023
    return (0);
  }
  {
#line 5026
  tmp___2 = calloc((size_t )elf_header.e_shnum, sizeof(struct group *));
#line 5026
  section_headers_groups = (struct group **)tmp___2;
  }
#line 5029
  if ((unsigned long )section_headers_groups == (unsigned long )((void *)0)) {
    {
#line 5031
    tmp___3 = gettext("Out of memory\n");
#line 5031
    error((char const   *)tmp___3);
    }
#line 5032
    return (0);
  }
#line 5036
  group_count = (size_t )0;
#line 5037
  i = 0U;
#line 5037
  section = section_headers;
  {
#line 5037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5037
    if (! (i < elf_header.e_shnum)) {
#line 5037
      goto while_break;
    }
#line 5040
    if (section->sh_type == 17U) {
#line 5041
      group_count ++;
    }
#line 5037
    i ++;
#line 5037
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5043
  if (group_count == 0UL) {
#line 5045
    if (do_section_groups) {
      {
#line 5046
      tmp___4 = gettext("\nThere are no section groups in this file.\n");
#line 5046
      printf((char const   */* __restrict  */)tmp___4);
      }
    }
#line 5048
    return (1);
  }
  {
#line 5051
  tmp___5 = calloc(group_count, sizeof(struct group ));
#line 5051
  section_groups = (struct group *)tmp___5;
  }
#line 5053
  if ((unsigned long )section_groups == (unsigned long )((void *)0)) {
    {
#line 5055
    tmp___6 = gettext("Out of memory\n");
#line 5055
    error((char const   *)tmp___6);
    }
#line 5056
    return (0);
  }
#line 5059
  symtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5060
  strtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5061
  symtab = (Elf_Internal_Sym *)((void *)0);
#line 5062
  num_syms = 0UL;
#line 5063
  strtab = (char *)((void *)0);
#line 5064
  strtab_size = (size_t )0;
#line 5065
  i = 0U;
#line 5065
  section = section_headers;
#line 5065
  group = section_groups;
  {
#line 5065
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5065
    if (! (i < elf_header.e_shnum)) {
#line 5065
      goto while_break___0;
    }
#line 5069
    if (section->sh_type == 17U) {
#line 5071
      if ((unsigned long )section == (unsigned long )((void *)0)) {
        {
#line 5071
        tmp___7 = gettext("<none>");
#line 5071
        tmp___12 = tmp___7;
        }
      } else {
#line 5071
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5071
          tmp___8 = gettext("<no-name>");
#line 5071
          tmp___11 = tmp___8;
          }
        } else {
#line 5071
          if ((unsigned long )section->sh_name >= string_table_length) {
            {
#line 5071
            tmp___9 = gettext("<corrupt>");
#line 5071
            tmp___10 = tmp___9;
            }
          } else {
#line 5071
            tmp___10 = string_table + section->sh_name;
          }
#line 5071
          tmp___11 = tmp___10;
        }
#line 5071
        tmp___12 = tmp___11;
      }
#line 5071
      name___0 = tmp___12;
#line 5080
      if (section->sh_link >= elf_header.e_shnum) {
        {
#line 5084
        tmp___13 = gettext("Bad sh_link in group section `%s\'\n");
#line 5084
        error((char const   *)tmp___13, name___0);
        }
#line 5085
        goto __Cont;
      } else {
#line 5080
        sec = section_headers + section->sh_link;
#line 5080
        if (sec->sh_type != 2U) {
          {
#line 5084
          tmp___13 = gettext("Bad sh_link in group section `%s\'\n");
#line 5084
          error((char const   *)tmp___13, name___0);
          }
#line 5085
          goto __Cont;
        }
      }
#line 5088
      if ((unsigned long )symtab_sec != (unsigned long )sec) {
#line 5090
        symtab_sec = sec;
#line 5091
        if (symtab) {
          {
#line 5092
          free((void *)symtab);
          }
        }
#line 5093
        if (is_32bit_elf) {
          {
#line 5093
          tmp___14 = get_32bit_elf_symbols(file, symtab_sec, & num_syms);
#line 5093
          symtab = tmp___14;
          }
        } else {
          {
#line 5093
          tmp___15 = get_64bit_elf_symbols(file, symtab_sec, & num_syms);
#line 5093
          symtab = tmp___15;
          }
        }
      }
#line 5096
      if ((unsigned long )symtab == (unsigned long )((void *)0)) {
        {
#line 5098
        tmp___16 = gettext("Corrupt header in group section `%s\'\n");
#line 5098
        error((char const   *)tmp___16, name___0);
        }
#line 5099
        goto __Cont;
      }
#line 5102
      if ((unsigned long )section->sh_info >= num_syms) {
        {
#line 5104
        tmp___17 = gettext("Bad sh_info in group section `%s\'\n");
#line 5104
        error((char const   *)tmp___17, name___0);
        }
#line 5105
        goto __Cont;
      }
#line 5108
      sym = symtab + section->sh_info;
#line 5110
      if (((int )sym->st_info & 15) == 3) {
#line 5112
        if (sym->st_shndx == 0U) {
          {
#line 5115
          tmp___18 = gettext("Bad sh_info in group section `%s\'\n");
#line 5115
          error((char const   *)tmp___18, name___0);
          }
#line 5116
          goto __Cont;
        } else
#line 5112
        if (sym->st_shndx >= elf_header.e_shnum) {
          {
#line 5115
          tmp___18 = gettext("Bad sh_info in group section `%s\'\n");
#line 5115
          error((char const   *)tmp___18, name___0);
          }
#line 5116
          goto __Cont;
        }
#line 5119
        if ((unsigned long )(section_headers + sym->st_shndx) == (unsigned long )((void *)0)) {
          {
#line 5119
          tmp___19 = gettext("<none>");
#line 5119
          group_name = tmp___19;
          }
        } else {
#line 5119
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5119
            tmp___20 = gettext("<no-name>");
#line 5119
            tmp___23 = tmp___20;
            }
          } else {
#line 5119
            if ((unsigned long )(section_headers + sym->st_shndx)->sh_name >= string_table_length) {
              {
#line 5119
              tmp___21 = gettext("<corrupt>");
#line 5119
              tmp___22 = tmp___21;
              }
            } else {
#line 5119
              tmp___22 = string_table + (section_headers + sym->st_shndx)->sh_name;
            }
#line 5119
            tmp___23 = tmp___22;
          }
#line 5119
          group_name = tmp___23;
        }
#line 5120
        strtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5121
        if (strtab) {
          {
#line 5122
          free((void *)strtab);
          }
        }
#line 5123
        strtab = (char *)((void *)0);
#line 5124
        strtab_size = (size_t )0;
      } else {
#line 5129
        if (symtab_sec->sh_link >= elf_header.e_shnum) {
#line 5131
          strtab_sec = (Elf_Internal_Shdr *)((void *)0);
#line 5132
          if (strtab) {
            {
#line 5133
            free((void *)strtab);
            }
          }
#line 5134
          strtab = (char *)((void *)0);
#line 5135
          strtab_size = (size_t )0;
        } else {
#line 5137
          sec = section_headers + symtab_sec->sh_link;
#line 5137
          if ((unsigned long )strtab_sec != (unsigned long )sec) {
#line 5140
            strtab_sec = sec;
#line 5141
            if (strtab) {
              {
#line 5142
              free((void *)strtab);
              }
            }
            {
#line 5143
            tmp___24 = gettext("string table");
#line 5143
            tmp___25 = get_data((void *)0, file, strtab_sec->sh_offset, (size_t )1,
                                strtab_sec->sh_size, (char const   *)tmp___24);
#line 5143
            strtab = (char *)tmp___25;
            }
#line 5146
            if ((unsigned long )strtab != (unsigned long )((void *)0)) {
#line 5146
              strtab_size = strtab_sec->sh_size;
            } else {
#line 5146
              strtab_size = (size_t )0;
            }
          }
        }
#line 5148
        if (sym->st_name < strtab_size) {
#line 5148
          group_name = strtab + sym->st_name;
        } else {
          {
#line 5148
          tmp___26 = gettext("<corrupt>");
#line 5148
          group_name = tmp___26;
          }
        }
      }
      {
#line 5152
      tmp___27 = gettext("section data");
#line 5152
      tmp___28 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                          (char const   *)tmp___27);
#line 5152
      start = (unsigned char *)tmp___28;
      }
#line 5155
      if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 5156
        goto __Cont;
      }
      {
#line 5158
      indices = start;
#line 5159
      size = (unsigned int )(section->sh_size / section->sh_entsize - 1UL);
#line 5160
      tmp___29 = (*byte_get)(indices, 4);
#line 5160
      entry = (unsigned int )tmp___29;
#line 5161
      indices += 4;
      }
#line 5163
      if (do_section_groups) {
        {
#line 5165
        tmp___30 = get_group_flags(entry);
#line 5165
        tmp___31 = gettext("\n%sgroup section [%5u] `%s\' [%s] contains %u sections:\n");
#line 5165
        printf((char const   */* __restrict  */)tmp___31, tmp___30, i, name___0, group_name,
               size);
#line 5168
        tmp___32 = gettext("   [Index]    Name\n");
#line 5168
        printf((char const   */* __restrict  */)tmp___32);
        }
      }
#line 5171
      group->group_index = i;
#line 5173
      j = 0U;
      {
#line 5173
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 5173
        if (! (j < size)) {
#line 5173
          goto while_break___1;
        }
        {
#line 5177
        tmp___33 = (*byte_get)(indices, 4);
#line 5177
        entry = (unsigned int )tmp___33;
#line 5178
        indices += 4;
        }
#line 5180
        if (entry >= elf_header.e_shnum) {
          {
#line 5182
          tmp___34 = gettext("section [%5u] in group section [%5u] > maximum section [%5u]\n");
#line 5182
          error((char const   *)tmp___34, entry, i, elf_header.e_shnum - 1U);
          }
#line 5184
          goto __Cont___0;
        }
#line 5187
        if ((unsigned long )*(section_headers_groups + entry) != (unsigned long )((void *)0)) {
#line 5189
          if (entry) {
            {
#line 5191
            tmp___35 = gettext("section [%5u] in group section [%5u] already in group section [%5u]\n");
#line 5191
            error((char const   *)tmp___35, entry, i, (*(section_headers_groups + entry))->group_index);
            }
#line 5194
            goto __Cont___0;
          } else
#line 5202
          if (! warned___0) {
            {
#line 5204
            tmp___36 = gettext("section 0 in group section [%5u]\n");
#line 5204
            error((char const   *)tmp___36, (*(section_headers_groups + entry))->group_index);
#line 5206
            warned___0 ++;
            }
          }
        }
#line 5211
        *(section_headers_groups + entry) = group;
#line 5213
        if (do_section_groups) {
#line 5215
          sec = section_headers + entry;
#line 5216
          if ((unsigned long )sec == (unsigned long )((void *)0)) {
            {
#line 5216
            tmp___37 = gettext("<none>");
#line 5216
            tmp___42 = tmp___37;
            }
          } else {
#line 5216
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5216
              tmp___38 = gettext("<no-name>");
#line 5216
              tmp___41 = tmp___38;
              }
            } else {
#line 5216
              if ((unsigned long )sec->sh_name >= string_table_length) {
                {
#line 5216
                tmp___39 = gettext("<corrupt>");
#line 5216
                tmp___40 = tmp___39;
                }
              } else {
#line 5216
                tmp___40 = string_table + sec->sh_name;
              }
#line 5216
              tmp___41 = tmp___40;
            }
#line 5216
            tmp___42 = tmp___41;
          }
          {
#line 5216
          printf((char const   */* __restrict  */)"   [%5u]   %s\n", entry, tmp___42);
          }
        }
        {
#line 5219
        tmp___43 = xmalloc(sizeof(struct group_list ));
#line 5219
        g = (struct group_list *)tmp___43;
#line 5220
        g->section_index = entry;
#line 5221
        g->next = group->root;
#line 5222
        group->root = g;
        }
        __Cont___0: /* CIL Label */ 
#line 5173
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 5225
      if (start) {
        {
#line 5226
        free((void *)start);
        }
      }
#line 5228
      group ++;
    }
    __Cont: /* CIL Label */ 
#line 5065
    i ++;
#line 5065
    section ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5232
  if (symtab) {
    {
#line 5233
    free((void *)symtab);
    }
  }
#line 5234
  if (strtab) {
    {
#line 5235
    free((void *)strtab);
    }
  }
#line 5236
  return (1);
}
}
#line 5261 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_ia64_vms_dynamic_fixups(FILE *file , struct ia64_vms_dynfixup *fixup ,
                                         char const   *strtab , unsigned int strtab_sz ) 
{ 
  Elf64_External_VMS_IMAGE_FIXUP *imfs ;
  long i ;
  char const   *lib_name ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int type ;
  char const   *rtype ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;

  {
  {
#line 5269
  tmp___0 = gettext("dynamic section image fixups");
#line 5269
  tmp___1 = get_data((void *)0, file, (long )(dynamic_addr + fixup->fixup_rela_off),
                     (size_t )1, fixup->fixup_rela_cnt * sizeof(*imfs), (char const   *)tmp___0);
#line 5269
  imfs = (Elf64_External_VMS_IMAGE_FIXUP *)tmp___1;
  }
#line 5272
  if (! imfs) {
#line 5273
    return;
  }
#line 5275
  if (fixup->needed < (bfd_vma )strtab_sz) {
#line 5276
    lib_name = strtab + fixup->needed;
  } else {
    {
#line 5279
    warn("corrupt library name index of 0x%lx found in dynamic entry", fixup->needed);
#line 5281
    lib_name = "???";
    }
  }
  {
#line 5283
  tmp___2 = gettext("\nImage fixups for needed library #%d: %s - ident: %lx\n");
#line 5283
  printf((char const   */* __restrict  */)tmp___2, (int )fixup->fixup_needed, lib_name,
         (long )fixup->needed_ident);
#line 5285
  tmp___3 = gettext("Seg Offset           Type                             SymVec DataType\n");
#line 5285
  printf((char const   */* __restrict  */)tmp___3);
#line 5288
  i = 0L;
  }
  {
#line 5288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5288
    if (! (i < (long )fixup->fixup_rela_cnt)) {
#line 5288
      goto while_break;
    }
    {
#line 5293
    tmp___4 = (*byte_get)((imfs + i)->fixup_seg, (int )sizeof((imfs + i)->fixup_seg));
#line 5293
    printf((char const   */* __restrict  */)"%3u ", (unsigned int )tmp___4);
#line 5294
    tmp___5 = (*byte_get)((imfs + i)->fixup_offset, (int )sizeof((imfs + i)->fixup_offset));
#line 5294
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            (bfd_vma )tmp___5);
#line 5295
    tmp___6 = (*byte_get)((imfs + i)->type, (int )sizeof((imfs + i)->type));
#line 5295
    type = (unsigned int )tmp___6;
#line 5296
    rtype = elf_ia64_reloc_type((unsigned long )type);
    }
#line 5297
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
      {
#line 5298
      printf((char const   */* __restrict  */)" 0x%08x                       ", type);
      }
    } else {
      {
#line 5300
      printf((char const   */* __restrict  */)" %-32s ", rtype);
      }
    }
    {
#line 5301
    tmp___7 = (*byte_get)((imfs + i)->symvec_index, (int )sizeof((imfs + i)->symvec_index));
#line 5301
    printf((char const   */* __restrict  */)"%6u ", (unsigned int )tmp___7);
#line 5302
    tmp___8 = (*byte_get)((imfs + i)->data_type, (int )sizeof((imfs + i)->data_type));
#line 5302
    printf((char const   */* __restrict  */)"0x%08x\n", (unsigned int )tmp___8);
#line 5288
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5305
  free((void *)imfs);
  }
#line 5306
  return;
}
}
#line 5310 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_ia64_vms_dynamic_relocs(FILE *file , struct ia64_vms_dynimgrela *imgrela ) 
{ 
  Elf64_External_VMS_IMAGE_RELA *imrs ;
  long i ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int type ;
  char const   *rtype ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;

  {
  {
#line 5316
  tmp___0 = gettext("dynamic section image relocations");
#line 5316
  tmp___1 = get_data((void *)0, file, (long )(dynamic_addr + imgrela->img_rela_off),
                     (size_t )1, imgrela->img_rela_cnt * sizeof(*imrs), (char const   *)tmp___0);
#line 5316
  imrs = (Elf64_External_VMS_IMAGE_RELA *)tmp___1;
  }
#line 5319
  if (! imrs) {
#line 5320
    return;
  }
  {
#line 5322
  tmp___2 = gettext("\nImage relocs\n");
#line 5322
  printf((char const   */* __restrict  */)tmp___2);
#line 5323
  tmp___3 = gettext("Seg Offset   Type                            Addend            Seg Sym Off\n");
#line 5323
  printf((char const   */* __restrict  */)tmp___3);
#line 5326
  i = 0L;
  }
  {
#line 5326
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5326
    if (! (i < (long )imgrela->img_rela_cnt)) {
#line 5326
      goto while_break;
    }
    {
#line 5331
    tmp___4 = (*byte_get)((imrs + i)->rela_seg, (int )sizeof((imrs + i)->rela_seg));
#line 5331
    printf((char const   */* __restrict  */)"%3u ", (unsigned int )tmp___4);
#line 5332
    tmp___5 = (*byte_get)((imrs + i)->rela_offset, (int )sizeof((imrs + i)->rela_offset));
#line 5332
    printf((char const   */* __restrict  */)"%08lx ", (bfd_vma )tmp___5);
#line 5334
    tmp___6 = (*byte_get)((imrs + i)->type, (int )sizeof((imrs + i)->type));
#line 5334
    type = (unsigned int )tmp___6;
#line 5335
    rtype = elf_ia64_reloc_type((unsigned long )type);
    }
#line 5336
    if ((unsigned long )rtype == (unsigned long )((void *)0)) {
      {
#line 5337
      printf((char const   */* __restrict  */)"0x%08x                      ", type);
      }
    } else {
      {
#line 5339
      printf((char const   */* __restrict  */)"%-31s ", rtype);
      }
    }
    {
#line 5340
    tmp___7 = (*byte_get)((imrs + i)->addend, (int )sizeof((imrs + i)->addend));
#line 5340
    print_vma((bfd_vma )tmp___7, (print_mode )5);
#line 5341
    tmp___8 = (*byte_get)((imrs + i)->sym_seg, (int )sizeof((imrs + i)->sym_seg));
#line 5341
    printf((char const   */* __restrict  */)"%3u ", (unsigned int )tmp___8);
#line 5342
    tmp___9 = (*byte_get)((imrs + i)->sym_offset, (int )sizeof((imrs + i)->sym_offset));
#line 5342
    printf((char const   */* __restrict  */)"%08lx\n", (bfd_vma )tmp___9);
#line 5326
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5346
  free((void *)imrs);
  }
#line 5347
  return;
}
}
#line 5351 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_ia64_vms_dynamic_relocs(FILE *file ) 
{ 
  struct ia64_vms_dynfixup fixup ;
  struct ia64_vms_dynimgrela imgrela ;
  Elf_Internal_Dyn *entry ;
  int res___0 ;
  bfd_vma strtab_off ;
  bfd_vma strtab_sz ;
  char *strtab ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 5357
  res___0 = 0;
#line 5358
  strtab_off = (bfd_vma )0;
#line 5359
  strtab_sz = (bfd_vma )0;
#line 5360
  strtab = (char *)((void *)0);
#line 5362
  memset((void *)(& fixup), 0, sizeof(fixup));
#line 5363
  memset((void *)(& imgrela), 0, sizeof(imgrela));
#line 5366
  entry = dynamic_section;
  }
  {
#line 5366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5366
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 5366
      goto while_break;
    }
    {
#line 5372
    if (entry->d_tag == 1610612801UL) {
#line 5372
      goto case_1610612801;
    }
#line 5375
    if (entry->d_tag == 10UL) {
#line 5375
      goto case_10;
    }
#line 5382
    if (entry->d_tag == 1610612765UL) {
#line 5382
      goto case_1610612765;
    }
#line 5385
    if (entry->d_tag == 1UL) {
#line 5385
      goto case_1;
    }
#line 5388
    if (entry->d_tag == 1610612773UL) {
#line 5388
      goto case_1610612773;
    }
#line 5391
    if (entry->d_tag == 1610612771UL) {
#line 5391
      goto case_1610612771;
    }
#line 5394
    if (entry->d_tag == 1610612809UL) {
#line 5394
      goto case_1610612809;
    }
#line 5400
    if (entry->d_tag == 1610612767UL) {
#line 5400
      goto case_1610612767;
    }
#line 5403
    if (entry->d_tag == 1610612805UL) {
#line 5403
      goto case_1610612805;
    }
#line 5409
    goto switch_default;
    case_1610612801: /* CIL Label */ 
#line 5373
    strtab_off = entry->d_un.d_val;
#line 5374
    goto switch_break;
    case_10: /* CIL Label */ 
#line 5376
    strtab_sz = entry->d_un.d_val;
#line 5377
    if ((unsigned long )strtab == (unsigned long )((void *)0)) {
      {
#line 5378
      tmp___0 = gettext("dynamic string section");
#line 5378
      tmp___1 = get_data((void *)0, file, (long )(dynamic_addr + strtab_off), (size_t )1,
                         strtab_sz, (char const   *)tmp___0);
#line 5378
      strtab = (char *)tmp___1;
      }
    }
#line 5380
    goto switch_break;
    case_1610612765: /* CIL Label */ 
#line 5383
    fixup.needed_ident = entry->d_un.d_val;
#line 5384
    goto switch_break;
    case_1: /* CIL Label */ 
#line 5386
    fixup.needed = entry->d_un.d_val;
#line 5387
    goto switch_break;
    case_1610612773: /* CIL Label */ 
#line 5389
    fixup.fixup_needed = entry->d_un.d_val;
#line 5390
    goto switch_break;
    case_1610612771: /* CIL Label */ 
#line 5392
    fixup.fixup_rela_cnt = entry->d_un.d_val;
#line 5393
    goto switch_break;
    case_1610612809: /* CIL Label */ 
    {
#line 5395
    fixup.fixup_rela_off = entry->d_un.d_val;
#line 5396
    res___0 ++;
#line 5397
    dump_ia64_vms_dynamic_fixups(file, & fixup, (char const   *)strtab, (unsigned int )strtab_sz);
    }
#line 5398
    goto switch_break;
    case_1610612767: /* CIL Label */ 
#line 5401
    imgrela.img_rela_cnt = entry->d_un.d_val;
#line 5402
    goto switch_break;
    case_1610612805: /* CIL Label */ 
    {
#line 5404
    imgrela.img_rela_off = entry->d_un.d_val;
#line 5405
    res___0 ++;
#line 5406
    dump_ia64_vms_dynamic_relocs(file, & imgrela);
    }
#line 5407
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 5410
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 5366
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5414
  if ((unsigned long )strtab != (unsigned long )((void *)0)) {
    {
#line 5415
    free((void *)strtab);
    }
  }
#line 5417
  return (res___0);
}
}
#line 5420 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct __anonstruct_dynamic_relocations_602783530 dynamic_relocations[3]  = {      {"REL",
      17, 18, 0}, 
        {"RELA", 7, 8, 1}, 
        {"PLT", 23, 2, -1}};
#line 5435 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_relocs(FILE *file ) 
{ 
  unsigned long rel_size ;
  unsigned long rel_offset ;
  int is_rela ;
  char const   *name___0 ;
  int has_dynamic_reloc ;
  unsigned int i ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  Elf_Internal_Shdr *section ;
  unsigned long i___0 ;
  int found ;
  Elf_Internal_Shdr *strsec ;
  int is_rela___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  Elf_Internal_Shdr *symsec ;
  Elf_Internal_Sym *symtab ;
  unsigned long nsyms ;
  unsigned long strtablen ;
  char *strtab ;
  Elf_Internal_Sym *tmp___13 ;
  Elf_Internal_Sym *tmp___14 ;
  char *tmp___15 ;
  void *tmp___16 ;
  char *tmp___17 ;

  {
#line 5442
  if (! do_reloc) {
#line 5443
    return (1);
  }
#line 5445
  if (do_using_dynamic) {
#line 5452
    has_dynamic_reloc = 0;
#line 5454
    i = 0U;
    {
#line 5454
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5454
      if (! ((unsigned long )i < sizeof(dynamic_relocations) / sizeof(dynamic_relocations[0]))) {
#line 5454
        goto while_break;
      }
#line 5456
      is_rela = dynamic_relocations[i].rela;
#line 5457
      name___0 = dynamic_relocations[i].name;
#line 5458
      rel_size = dynamic_info[dynamic_relocations[i].size];
#line 5459
      rel_offset = dynamic_info[dynamic_relocations[i].reloc];
#line 5461
      has_dynamic_reloc = (int )((unsigned long )has_dynamic_reloc | rel_size);
#line 5463
      if (is_rela == -1) {
#line 5465
        if (dynamic_relocations[i].reloc == 23) {
          {
#line 5468
          if (dynamic_info[20] == 17UL) {
#line 5468
            goto case_17;
          }
#line 5471
          if (dynamic_info[20] == 7UL) {
#line 5471
            goto case_7;
          }
#line 5466
          goto switch_break;
          case_17: /* CIL Label */ 
#line 5469
          is_rela = 0;
#line 5470
          goto switch_break;
          case_7: /* CIL Label */ 
#line 5472
          is_rela = 1;
#line 5473
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
#line 5477
      if (rel_size) {
        {
#line 5479
        tmp___0 = gettext("\n\'%s\' relocation section at offset 0x%lx contains %ld bytes:\n");
#line 5479
        printf((char const   */* __restrict  */)tmp___0, name___0, rel_offset, rel_size);
#line 5483
        tmp___1 = offset_from_vma(file, rel_offset, rel_size);
#line 5483
        dump_relocations(file, (unsigned long )tmp___1, rel_size, dynamic_symbols,
                         num_dynamic_syms, dynamic_strings, dynamic_strings_length,
                         is_rela);
        }
      }
#line 5454
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 5491
    tmp___3 = is_ia64_vms();
    }
#line 5491
    if (tmp___3) {
      {
#line 5492
      tmp___2 = process_ia64_vms_dynamic_relocs(file);
#line 5492
      has_dynamic_reloc |= tmp___2;
      }
    }
#line 5494
    if (! has_dynamic_reloc) {
      {
#line 5495
      tmp___4 = gettext("\nThere are no dynamic relocations in this file.\n");
#line 5495
      printf((char const   */* __restrict  */)tmp___4);
      }
    }
  } else {
#line 5501
    found = 0;
#line 5503
    i___0 = 0UL;
#line 5503
    section = section_headers;
    {
#line 5503
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5503
      if (! (i___0 < (unsigned long )elf_header.e_shnum)) {
#line 5503
        goto while_break___0;
      }
#line 5507
      if (section->sh_type != 4U) {
#line 5507
        if (section->sh_type != 9U) {
#line 5509
          goto __Cont;
        }
      }
#line 5511
      rel_offset = (unsigned long )section->sh_offset;
#line 5512
      rel_size = section->sh_size;
#line 5514
      if (rel_size) {
        {
#line 5519
        tmp___5 = gettext("\nRelocation section ");
#line 5519
        printf((char const   */* __restrict  */)tmp___5);
        }
#line 5521
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5522
          printf((char const   */* __restrict  */)"%d", section->sh_name);
          }
        } else {
#line 5524
          if ((unsigned long )section == (unsigned long )((void *)0)) {
            {
#line 5524
            tmp___6 = gettext("<none>");
#line 5524
            tmp___11 = tmp___6;
            }
          } else {
#line 5524
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5524
              tmp___7 = gettext("<no-name>");
#line 5524
              tmp___10 = tmp___7;
              }
            } else {
#line 5524
              if ((unsigned long )section->sh_name >= string_table_length) {
                {
#line 5524
                tmp___8 = gettext("<corrupt>");
#line 5524
                tmp___9 = tmp___8;
                }
              } else {
#line 5524
                tmp___9 = string_table + section->sh_name;
              }
#line 5524
              tmp___10 = tmp___9;
            }
#line 5524
            tmp___11 = tmp___10;
          }
          {
#line 5524
          printf((char const   */* __restrict  */)"\'%s\'", tmp___11);
          }
        }
        {
#line 5526
        tmp___12 = gettext(" at offset 0x%lx contains %lu entries:\n");
#line 5526
        printf((char const   */* __restrict  */)tmp___12, rel_offset, rel_size / section->sh_entsize);
#line 5529
        is_rela___0 = section->sh_type == 4U;
        }
#line 5531
        if (section->sh_link != 0U) {
#line 5531
          if (section->sh_link < elf_header.e_shnum) {
#line 5537
            strtablen = 0UL;
#line 5538
            strtab = (char *)((void *)0);
#line 5540
            symsec = section_headers + section->sh_link;
#line 5541
            if (symsec->sh_type != 2U) {
#line 5541
              if (symsec->sh_type != 11U) {
#line 5543
                goto __Cont;
              }
            }
#line 5545
            if (is_32bit_elf) {
              {
#line 5545
              tmp___13 = get_32bit_elf_symbols(file, symsec, & nsyms);
#line 5545
              symtab = tmp___13;
              }
            } else {
              {
#line 5545
              tmp___14 = get_64bit_elf_symbols(file, symsec, & nsyms);
#line 5545
              symtab = tmp___14;
              }
            }
#line 5547
            if ((unsigned long )symtab == (unsigned long )((void *)0)) {
#line 5548
              goto __Cont;
            }
#line 5550
            if (symsec->sh_link != 0U) {
#line 5550
              if (symsec->sh_link < elf_header.e_shnum) {
                {
#line 5553
                strsec = section_headers + symsec->sh_link;
#line 5555
                tmp___15 = gettext("string table");
#line 5555
                tmp___16 = get_data((void *)0, file, strsec->sh_offset, (size_t )1,
                                    strsec->sh_size, (char const   *)tmp___15);
#line 5555
                strtab = (char *)tmp___16;
                }
#line 5558
                if ((unsigned long )strtab == (unsigned long )((void *)0)) {
#line 5558
                  strtablen = 0UL;
                } else {
#line 5558
                  strtablen = strsec->sh_size;
                }
              }
            }
            {
#line 5561
            dump_relocations(file, rel_offset, rel_size, symtab, nsyms, strtab, strtablen,
                             is_rela___0);
            }
#line 5563
            if (strtab) {
              {
#line 5564
              free((void *)strtab);
              }
            }
            {
#line 5565
            free((void *)symtab);
            }
          } else {
            {
#line 5568
            dump_relocations(file, rel_offset, rel_size, (Elf_Internal_Sym *)((void *)0),
                             0UL, (char *)((void *)0), 0UL, is_rela___0);
            }
          }
        } else {
          {
#line 5568
          dump_relocations(file, rel_offset, rel_size, (Elf_Internal_Sym *)((void *)0),
                           0UL, (char *)((void *)0), 0UL, is_rela___0);
          }
        }
#line 5571
        found = 1;
      }
      __Cont: /* CIL Label */ 
#line 5503
      i___0 ++;
#line 5503
      section ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 5575
    if (! found) {
      {
#line 5576
      tmp___17 = gettext("\nThere are no relocations in this file.\n");
#line 5576
      printf((char const   */* __restrict  */)tmp___17);
      }
    }
  }
#line 5579
  return (1);
}
}
#line 5623 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void find_symbol_for_address(Elf_Internal_Sym *symtab , unsigned long nsyms ,
                                    char const   *strtab , unsigned long strtab_size ,
                                    struct absaddr addr , char const   **symname ,
                                    bfd_vma *offset ) 
{ 
  bfd_vma dist ;
  Elf_Internal_Sym *sym ;
  Elf_Internal_Sym *best ;
  unsigned long i ;
  bfd_vma value ;
  char *tmp___0 ;

  {
#line 5632
  dist = (bfd_vma )1048576;
#line 5634
  best = (Elf_Internal_Sym *)((void *)0);
  {
#line 5637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5637
    if ((int )elf_header.e_machine == 40) {
#line 5637
      addr.offset &= 0xfffffffffffffffeUL;
    }
#line 5637
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 5639
  i = 0UL;
#line 5639
  sym = symtab;
  {
#line 5639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5639
    if (! (i < nsyms)) {
#line 5639
      goto while_break___0;
    }
#line 5641
    value = sym->st_value;
    {
#line 5643
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5643
      if ((int )elf_header.e_machine == 40) {
#line 5643
        value &= 0xfffffffffffffffeUL;
      }
#line 5643
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5645
    if (((int )sym->st_info & 15) == 2) {
#line 5645
      if (sym->st_name != 0UL) {
#line 5645
        if ((int )addr.section == 0) {
#line 5645
          goto _L;
        } else
#line 5645
        if ((unsigned int )addr.section == sym->st_shndx) {
          _L: /* CIL Label */ 
#line 5645
          if (addr.offset >= value) {
#line 5645
            if (addr.offset - value < dist) {
#line 5651
              best = sym;
#line 5652
              dist = addr.offset - value;
#line 5653
              if (! dist) {
#line 5654
                goto while_break___0;
              }
            }
          }
        }
      }
    }
#line 5639
    i ++;
#line 5639
    sym ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5658
  if (best) {
#line 5660
    if (best->st_name >= strtab_size) {
      {
#line 5660
      tmp___0 = gettext("<corrupt>");
#line 5660
      *symname = (char const   *)tmp___0;
      }
    } else {
#line 5660
      *symname = strtab + best->st_name;
    }
#line 5662
    *offset = dist;
#line 5663
    return;
  }
#line 5666
  *symname = (char const   *)((void *)0);
#line 5667
  *offset = addr.offset;
#line 5668
  return;
}
}
#line 5670 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_ia64_unwind(struct ia64_unw_aux_info *aux ) 
{ 
  struct ia64_unw_table_entry *tp ;
  int in_body ;
  bfd_vma stamp ;
  bfd_vma offset ;
  unsigned char const   *dp ;
  unsigned char const   *head ;
  char const   *procname ;
  bfd_vma tmp___0 ;
  elf_vma tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;

  {
#line 5676
  tp = aux->table;
  {
#line 5676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5676
    if (! ((unsigned long )tp < (unsigned long )(aux->table + aux->table_len))) {
#line 5676
      goto while_break;
    }
    {
#line 5684
    find_symbol_for_address(aux->symtab, aux->nsyms, (char const   *)aux->strtab,
                            aux->strtab_size, tp->start, & procname, & offset);
#line 5687
    fputs((char const   */* __restrict  */)"\n<", (FILE */* __restrict  */)stdout);
    }
#line 5689
    if (procname) {
      {
#line 5691
      fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
      }
#line 5693
      if (offset) {
        {
#line 5694
        printf((char const   */* __restrict  */)"+%lx", offset);
        }
      }
    }
    {
#line 5697
    fputs((char const   */* __restrict  */)">: [", (FILE */* __restrict  */)stdout);
#line 5698
    print_vma(tp->start.offset, (print_mode )4);
#line 5699
    fputc('-', stdout);
#line 5700
    print_vma(tp->end.offset, (print_mode )4);
#line 5701
    printf((char const   */* __restrict  */)"], info at +0x%lx\n", tp->info.offset - aux->seg_base);
    }
#line 5704
    if (tp->info.section) {
#line 5704
      tmp___0 = (section_headers + tp->info.section)->sh_addr + tp->info.offset;
    } else {
#line 5704
      tmp___0 = tp->info.offset;
    }
    {
#line 5704
    head = (unsigned char const   *)(aux->info + (tmp___0 - aux->info_addr));
#line 5705
    tmp___1 = (*byte_get)((unsigned char *)head, (int )sizeof(stamp));
#line 5705
    stamp = (bfd_vma )tmp___1;
    }
#line 5707
    if ((unsigned long long )stamp & 8589934592ULL) {
#line 5707
      tmp___2 = " uhandler";
    } else {
#line 5707
      tmp___2 = "";
    }
#line 5707
    if ((unsigned long long )stamp & 4294967296ULL) {
#line 5707
      tmp___3 = " ehandler";
    } else {
#line 5707
      tmp___3 = "";
    }
    {
#line 5707
    printf((char const   */* __restrict  */)"  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
           (unsigned int )(stamp >> 48), (unsigned long )(((unsigned long long )stamp & 281470681743360ULL) >> 32),
           tmp___3, tmp___2, (unsigned long )((unsigned long long )eh_addr_size * ((unsigned long long )stamp & 4294967295ULL)));
    }
#line 5714
    if (stamp >> 48 != 1UL) {
      {
#line 5716
      tmp___4 = gettext("\tUnknown version.\n");
#line 5716
      printf((char const   */* __restrict  */)tmp___4);
      }
#line 5717
      goto __Cont;
    }
#line 5720
    in_body = 0;
#line 5721
    dp = head + 8;
    {
#line 5721
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 5721
      if (! ((unsigned long )dp < (unsigned long )((head + 8) + (unsigned long long )eh_addr_size * ((unsigned long long )stamp & 4294967295ULL)))) {
#line 5721
        goto while_break___0;
      }
      {
#line 5722
      dp = unw_decode(dp, in_body, (void *)(& in_body));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 5676
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5724
  return;
}
}
#line 5726 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int slurp_ia64_unwind_table(FILE *file , struct ia64_unw_aux_info *aux , Elf_Internal_Shdr *sec ) 
{ 
  unsigned long size ;
  unsigned long nrelas ;
  unsigned long i ;
  Elf_Internal_Phdr *seg ;
  struct ia64_unw_table_entry *tep ;
  Elf_Internal_Shdr *relsec ;
  Elf_Internal_Rela *rela ;
  Elf_Internal_Rela *rp ;
  unsigned char *table ;
  unsigned char *tp ;
  Elf_Internal_Sym *sym ;
  char const   *relname ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  bfd_vma tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;

  {
#line 5745
  if (elf_header.e_phnum) {
    {
#line 5747
    tmp___0 = get_program_headers(file);
    }
#line 5747
    if (! tmp___0) {
#line 5748
      return (0);
    }
#line 5750
    seg = program_headers;
    {
#line 5750
    while (1) {
      while_continue: /* CIL Label */ ;
#line 5750
      if (! ((unsigned long )seg < (unsigned long )(program_headers + elf_header.e_phnum))) {
#line 5750
        goto while_break;
      }
#line 5754
      if (seg->p_type != 1UL) {
#line 5755
        goto __Cont;
      }
#line 5757
      if (sec->sh_addr >= seg->p_vaddr) {
#line 5757
        if (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz) {
#line 5760
          aux->seg_base = seg->p_vaddr;
#line 5761
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 5750
      seg ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 5767
  size = sec->sh_size;
#line 5768
  tmp___1 = gettext("unwind table");
#line 5768
  tmp___2 = get_data((void *)0, file, sec->sh_offset, (size_t )1, size, (char const   *)tmp___1);
#line 5768
  table = (unsigned char *)tmp___2;
  }
#line 5770
  if (! table) {
#line 5771
    return (0);
  }
  {
#line 5773
  tmp___3 = xcmalloc(size / (unsigned long )(3 * eh_addr_size), sizeof(*(aux->table + 0)));
#line 5773
  aux->table = (struct ia64_unw_table_entry *)tmp___3;
#line 5775
  tep = aux->table;
#line 5776
  tp = table;
  }
  {
#line 5776
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5776
    if (! ((unsigned long )tp < (unsigned long )(table + size))) {
#line 5776
      goto while_break___0;
    }
    {
#line 5778
    tep->start.section = (unsigned short)0;
#line 5779
    tep->end.section = (unsigned short)0;
#line 5780
    tep->info.section = (unsigned short)0;
#line 5781
    tmp___4 = (*byte_get)(tp, eh_addr_size);
#line 5781
    tep->start.offset = (bfd_vma )tmp___4;
#line 5781
    tp += eh_addr_size;
#line 5782
    tmp___5 = (*byte_get)(tp, eh_addr_size);
#line 5782
    tep->end.offset = (bfd_vma )tmp___5;
#line 5782
    tp += eh_addr_size;
#line 5783
    tmp___6 = (*byte_get)(tp, eh_addr_size);
#line 5783
    tep->info.offset = (bfd_vma )tmp___6;
#line 5783
    tp += eh_addr_size;
#line 5784
    tep->start.offset += aux->seg_base;
#line 5785
    tep->end.offset += aux->seg_base;
#line 5786
    tep->info.offset += aux->seg_base;
#line 5776
    tep ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 5788
  free((void *)table);
#line 5791
  relsec = section_headers;
  }
  {
#line 5791
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 5791
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 5791
      goto while_break___1;
    }
#line 5795
    if (relsec->sh_type != 4U) {
#line 5798
      goto __Cont___0;
    } else
#line 5795
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 5798
      goto __Cont___0;
    } else
#line 5795
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )sec) {
#line 5798
      goto __Cont___0;
    }
    {
#line 5800
    tmp___7 = slurp_rela_relocs(file, (unsigned long )relsec->sh_offset, relsec->sh_size,
                                & rela, & nrelas);
    }
#line 5800
    if (! tmp___7) {
#line 5802
      return (0);
    }
#line 5804
    rp = rela;
    {
#line 5804
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 5804
      if (! ((unsigned long )rp < (unsigned long )(rela + nrelas))) {
#line 5804
        goto while_break___2;
      }
      {
#line 5806
      tmp___8 = get_reloc_type(rp->r_info);
#line 5806
      relname = elf_ia64_reloc_type((unsigned long )tmp___8);
#line 5807
      tmp___9 = get_reloc_symindex(rp->r_info);
#line 5807
      sym = aux->symtab + tmp___9;
#line 5809
      tmp___11 = strncmp(relname, "R_IA64_SEGREL", sizeof("R_IA64_SEGREL") - 1UL);
      }
#line 5809
      if (! (tmp___11 == 0)) {
        {
#line 5811
        tmp___10 = gettext("Skipping unexpected relocation type %s\n");
#line 5811
        warn((char const   *)tmp___10, relname);
        }
#line 5812
        goto __Cont___1;
      }
#line 5815
      i = rp->r_offset / (bfd_vma )(3 * eh_addr_size);
      {
#line 5819
      if ((rp->r_offset / (bfd_vma )eh_addr_size) % 3UL == 0UL) {
#line 5819
        goto case_0;
      }
#line 5823
      if ((rp->r_offset / (bfd_vma )eh_addr_size) % 3UL == 1UL) {
#line 5823
        goto case_1;
      }
#line 5827
      if ((rp->r_offset / (bfd_vma )eh_addr_size) % 3UL == 2UL) {
#line 5827
        goto case_2;
      }
#line 5831
      goto switch_default;
      case_0: /* CIL Label */ 
#line 5820
      (aux->table + i)->start.section = (unsigned short )sym->st_shndx;
#line 5821
      (aux->table + i)->start.offset = rp->r_addend + sym->st_value;
#line 5822
      goto switch_break;
      case_1: /* CIL Label */ 
#line 5824
      (aux->table + i)->end.section = (unsigned short )sym->st_shndx;
#line 5825
      (aux->table + i)->end.offset = rp->r_addend + sym->st_value;
#line 5826
      goto switch_break;
      case_2: /* CIL Label */ 
#line 5828
      (aux->table + i)->info.section = (unsigned short )sym->st_shndx;
#line 5829
      (aux->table + i)->info.offset = rp->r_addend + sym->st_value;
#line 5830
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 5832
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___1: /* CIL Label */ 
#line 5804
      rp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 5836
    free((void *)rela);
    }
    __Cont___0: /* CIL Label */ 
#line 5791
    relsec ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 5839
  aux->table_len = size / (unsigned long )(3 * eh_addr_size);
#line 5840
  return (1);
}
}
#line 5843 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void ia64_process_unwind(FILE *file ) 
{ 
  Elf_Internal_Shdr *sec ;
  Elf_Internal_Shdr *unwsec ;
  Elf_Internal_Shdr *strsec ;
  unsigned long i ;
  unsigned long unwcount ;
  unsigned long unwstart ;
  struct ia64_unw_aux_info aux ;
  Elf_Internal_Sym *tmp___0 ;
  Elf_Internal_Sym *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *suffix ;
  size_t len ;
  size_t len2 ;
  struct group_list *g ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  void *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  unsigned long tmp___85 ;

  {
  {
#line 5847
  unwsec = (Elf_Internal_Shdr *)((void *)0);
#line 5849
  unwcount = 0UL;
#line 5849
  unwstart = 0UL;
#line 5852
  memset((void *)(& aux), 0, sizeof(aux));
#line 5854
  i = 0UL;
#line 5854
  sec = section_headers;
  }
  {
#line 5854
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5854
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 5854
      goto while_break;
    }
#line 5856
    if (sec->sh_type == 2U) {
#line 5856
      if (sec->sh_link < elf_header.e_shnum) {
#line 5859
        if (is_32bit_elf) {
          {
#line 5859
          tmp___0 = get_32bit_elf_symbols(file, sec, & aux.nsyms);
#line 5859
          aux.symtab = tmp___0;
          }
        } else {
          {
#line 5859
          tmp___1 = get_64bit_elf_symbols(file, sec, & aux.nsyms);
#line 5859
          aux.symtab = tmp___1;
          }
        }
#line 5861
        strsec = section_headers + sec->sh_link;
#line 5862
        if (! ((unsigned long )aux.strtab == (unsigned long )((void *)0))) {
          {
#line 5862
          __assert_fail("aux.strtab == NULL", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                        5862U, "ia64_process_unwind");
          }
        }
        {
#line 5863
        tmp___2 = gettext("string table");
#line 5863
        tmp___3 = get_data((void *)0, file, strsec->sh_offset, (size_t )1, strsec->sh_size,
                           (char const   *)tmp___2);
#line 5863
        aux.strtab = (char *)tmp___3;
        }
#line 5866
        if ((unsigned long )aux.strtab != (unsigned long )((void *)0)) {
#line 5866
          aux.strtab_size = strsec->sh_size;
        } else {
#line 5866
          aux.strtab_size = 0UL;
        }
      } else {
#line 5856
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 5868
    if (sec->sh_type == 1879048193U) {
#line 5869
      unwcount ++;
    }
#line 5854
    i ++;
#line 5854
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5872
  if (! unwcount) {
    {
#line 5873
    tmp___4 = gettext("\nThere are no unwind sections in this file.\n");
#line 5873
    printf((char const   */* __restrict  */)tmp___4);
    }
  }
  {
#line 5875
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5875
    tmp___85 = unwcount;
#line 5875
    unwcount --;
#line 5875
    if (! (tmp___85 > 0UL)) {
#line 5875
      goto while_break___0;
    }
#line 5880
    i = unwstart;
#line 5880
    sec = section_headers + unwstart;
    {
#line 5880
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 5880
      if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 5880
        goto while_break___1;
      }
#line 5882
      if (sec->sh_type == 1879048193U) {
#line 5884
        unwsec = sec;
#line 5885
        goto while_break___1;
      }
#line 5880
      i ++;
#line 5880
      sec ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 5888
    unwstart = i + 1UL;
#line 5889
    len = sizeof(".gnu.linkonce.ia64unw.") - 1UL;
#line 5891
    if ((unwsec->sh_flags & (unsigned long )(1 << 9)) != 0UL) {
#line 5894
      g = (*(section_headers_groups + i))->root;
      {
#line 5896
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 5896
        if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 5896
          goto while_break___2;
        }
#line 5898
        sec = section_headers + g->section_index;
#line 5900
        if ((unsigned long )sec == (unsigned long )((void *)0)) {
          {
#line 5900
          tmp___5 = gettext("<none>");
#line 5900
          tmp___10 = tmp___5;
          }
        } else {
#line 5900
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5900
            tmp___6 = gettext("<no-name>");
#line 5900
            tmp___9 = tmp___6;
            }
          } else {
#line 5900
            if ((unsigned long )sec->sh_name >= string_table_length) {
              {
#line 5900
              tmp___7 = gettext("<corrupt>");
#line 5900
              tmp___8 = tmp___7;
              }
            } else {
#line 5900
              tmp___8 = string_table + sec->sh_name;
            }
#line 5900
            tmp___9 = tmp___8;
          }
#line 5900
          tmp___10 = tmp___9;
        }
        {
#line 5900
        tmp___11 = strcmp((char const   *)tmp___10, ".IA_64.unwind_info");
        }
#line 5900
        if (tmp___11 == 0) {
#line 5901
          goto while_break___2;
        }
#line 5896
        g = g->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 5904
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 5905
        i = (unsigned long )elf_header.e_shnum;
      }
    } else {
#line 5907
      if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
        {
#line 5907
        tmp___59 = gettext("<none>");
#line 5907
        tmp___64 = tmp___59;
        }
      } else {
#line 5907
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 5907
          tmp___60 = gettext("<no-name>");
#line 5907
          tmp___63 = tmp___60;
          }
        } else {
#line 5907
          if ((unsigned long )unwsec->sh_name >= string_table_length) {
            {
#line 5907
            tmp___61 = gettext("<corrupt>");
#line 5907
            tmp___62 = tmp___61;
            }
          } else {
#line 5907
            tmp___62 = string_table + unwsec->sh_name;
          }
#line 5907
          tmp___63 = tmp___62;
        }
#line 5907
        tmp___64 = tmp___63;
      }
      {
#line 5907
      tmp___65 = strncmp((char const   *)tmp___64, ".gnu.linkonce.ia64unw.", len);
      }
#line 5907
      if (tmp___65 == 0) {
#line 5910
        len2 = sizeof(".gnu.linkonce.ia64unwi.") - 1UL;
#line 5911
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 5911
          tmp___12 = gettext("<none>");
#line 5911
          tmp___17 = tmp___12;
          }
        } else {
#line 5911
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5911
            tmp___13 = gettext("<no-name>");
#line 5911
            tmp___16 = tmp___13;
            }
          } else {
#line 5911
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 5911
              tmp___14 = gettext("<corrupt>");
#line 5911
              tmp___15 = tmp___14;
              }
            } else {
#line 5911
              tmp___15 = string_table + unwsec->sh_name;
            }
#line 5911
            tmp___16 = tmp___15;
          }
#line 5911
          tmp___17 = tmp___16;
        }
#line 5911
        suffix = tmp___17 + len;
#line 5912
        i = 0UL;
#line 5912
        sec = section_headers;
        {
#line 5912
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 5912
          if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 5912
            goto while_break___3;
          }
#line 5914
          if ((unsigned long )sec == (unsigned long )((void *)0)) {
            {
#line 5914
            tmp___18 = gettext("<none>");
#line 5914
            tmp___23 = tmp___18;
            }
          } else {
#line 5914
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5914
              tmp___19 = gettext("<no-name>");
#line 5914
              tmp___22 = tmp___19;
              }
            } else {
#line 5914
              if ((unsigned long )sec->sh_name >= string_table_length) {
                {
#line 5914
                tmp___20 = gettext("<corrupt>");
#line 5914
                tmp___21 = tmp___20;
                }
              } else {
#line 5914
                tmp___21 = string_table + sec->sh_name;
              }
#line 5914
              tmp___22 = tmp___21;
            }
#line 5914
            tmp___23 = tmp___22;
          }
          {
#line 5914
          tmp___24 = strncmp((char const   *)tmp___23, ".gnu.linkonce.ia64unwi.",
                             len2);
          }
#line 5914
          if (tmp___24 == 0) {
#line 5914
            if ((unsigned long )sec == (unsigned long )((void *)0)) {
              {
#line 5914
              tmp___25 = gettext("<none>");
#line 5914
              tmp___30 = tmp___25;
              }
            } else {
#line 5914
              if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                {
#line 5914
                tmp___26 = gettext("<no-name>");
#line 5914
                tmp___29 = tmp___26;
                }
              } else {
#line 5914
                if ((unsigned long )sec->sh_name >= string_table_length) {
                  {
#line 5914
                  tmp___27 = gettext("<corrupt>");
#line 5914
                  tmp___28 = tmp___27;
                  }
                } else {
#line 5914
                  tmp___28 = string_table + sec->sh_name;
                }
#line 5914
                tmp___29 = tmp___28;
              }
#line 5914
              tmp___30 = tmp___29;
            }
            {
#line 5914
            tmp___31 = strcmp((char const   *)(tmp___30 + len2), (char const   *)suffix);
            }
#line 5914
            if (tmp___31 == 0) {
#line 5916
              goto while_break___3;
            }
          }
#line 5912
          i ++;
#line 5912
          sec ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 5922
        len = sizeof(".IA_64.unwind") - 1UL;
#line 5923
        len2 = sizeof(".IA_64.unwind_info") - 1UL;
#line 5924
        suffix = (char *)"";
#line 5925
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 5925
          tmp___38 = gettext("<none>");
#line 5925
          tmp___43 = tmp___38;
          }
        } else {
#line 5925
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5925
            tmp___39 = gettext("<no-name>");
#line 5925
            tmp___42 = tmp___39;
            }
          } else {
#line 5925
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 5925
              tmp___40 = gettext("<corrupt>");
#line 5925
              tmp___41 = tmp___40;
              }
            } else {
#line 5925
              tmp___41 = string_table + unwsec->sh_name;
            }
#line 5925
            tmp___42 = tmp___41;
          }
#line 5925
          tmp___43 = tmp___42;
        }
        {
#line 5925
        tmp___44 = strncmp((char const   *)tmp___43, ".IA_64.unwind", len);
        }
#line 5925
        if (tmp___44 == 0) {
#line 5926
          if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
            {
#line 5926
            tmp___32 = gettext("<none>");
#line 5926
            tmp___37 = tmp___32;
            }
          } else {
#line 5926
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5926
              tmp___33 = gettext("<no-name>");
#line 5926
              tmp___36 = tmp___33;
              }
            } else {
#line 5926
              if ((unsigned long )unwsec->sh_name >= string_table_length) {
                {
#line 5926
                tmp___34 = gettext("<corrupt>");
#line 5926
                tmp___35 = tmp___34;
                }
              } else {
#line 5926
                tmp___35 = string_table + unwsec->sh_name;
              }
#line 5926
              tmp___36 = tmp___35;
            }
#line 5926
            tmp___37 = tmp___36;
          }
#line 5926
          suffix = tmp___37 + len;
        }
#line 5927
        i = 0UL;
#line 5927
        sec = section_headers;
        {
#line 5927
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 5927
          if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 5927
            goto while_break___4;
          }
#line 5929
          if ((unsigned long )sec == (unsigned long )((void *)0)) {
            {
#line 5929
            tmp___45 = gettext("<none>");
#line 5929
            tmp___50 = tmp___45;
            }
          } else {
#line 5929
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 5929
              tmp___46 = gettext("<no-name>");
#line 5929
              tmp___49 = tmp___46;
              }
            } else {
#line 5929
              if ((unsigned long )sec->sh_name >= string_table_length) {
                {
#line 5929
                tmp___47 = gettext("<corrupt>");
#line 5929
                tmp___48 = tmp___47;
                }
              } else {
#line 5929
                tmp___48 = string_table + sec->sh_name;
              }
#line 5929
              tmp___49 = tmp___48;
            }
#line 5929
            tmp___50 = tmp___49;
          }
          {
#line 5929
          tmp___51 = strncmp((char const   *)tmp___50, ".IA_64.unwind_info", len2);
          }
#line 5929
          if (tmp___51 == 0) {
#line 5929
            if ((unsigned long )sec == (unsigned long )((void *)0)) {
              {
#line 5929
              tmp___52 = gettext("<none>");
#line 5929
              tmp___57 = tmp___52;
              }
            } else {
#line 5929
              if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                {
#line 5929
                tmp___53 = gettext("<no-name>");
#line 5929
                tmp___56 = tmp___53;
                }
              } else {
#line 5929
                if ((unsigned long )sec->sh_name >= string_table_length) {
                  {
#line 5929
                  tmp___54 = gettext("<corrupt>");
#line 5929
                  tmp___55 = tmp___54;
                  }
                } else {
#line 5929
                  tmp___55 = string_table + sec->sh_name;
                }
#line 5929
                tmp___56 = tmp___55;
              }
#line 5929
              tmp___57 = tmp___56;
            }
            {
#line 5929
            tmp___58 = strcmp((char const   *)(tmp___57 + len2), (char const   *)suffix);
            }
#line 5929
            if (tmp___58 == 0) {
#line 5931
              goto while_break___4;
            }
          }
#line 5927
          i ++;
#line 5927
          sec ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
#line 5934
    if (i == (unsigned long )elf_header.e_shnum) {
      {
#line 5936
      tmp___66 = gettext("\nCould not find unwind info section for ");
#line 5936
      printf((char const   */* __restrict  */)tmp___66);
      }
#line 5938
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 5939
        printf((char const   */* __restrict  */)"%d", unwsec->sh_name);
        }
      } else {
#line 5941
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 5941
          tmp___67 = gettext("<none>");
#line 5941
          tmp___72 = tmp___67;
          }
        } else {
#line 5941
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5941
            tmp___68 = gettext("<no-name>");
#line 5941
            tmp___71 = tmp___68;
            }
          } else {
#line 5941
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 5941
              tmp___69 = gettext("<corrupt>");
#line 5941
              tmp___70 = tmp___69;
              }
            } else {
#line 5941
              tmp___70 = string_table + unwsec->sh_name;
            }
#line 5941
            tmp___71 = tmp___70;
          }
#line 5941
          tmp___72 = tmp___71;
        }
        {
#line 5941
        tmp___73 = gettext("\'%s\'");
#line 5941
        printf((char const   */* __restrict  */)tmp___73, tmp___72);
        }
      }
    } else {
      {
#line 5945
      aux.info_addr = sec->sh_addr;
#line 5946
      tmp___74 = gettext("unwind info");
#line 5946
      tmp___75 = get_data((void *)0, file, sec->sh_offset, (size_t )1, sec->sh_size,
                          (char const   *)tmp___74);
#line 5946
      aux.info = (unsigned char *)tmp___75;
      }
#line 5949
      if ((unsigned long )aux.info == (unsigned long )((void *)0)) {
#line 5949
        aux.info_size = 0UL;
      } else {
#line 5949
        aux.info_size = sec->sh_size;
      }
      {
#line 5951
      tmp___76 = gettext("\nUnwind section ");
#line 5951
      printf((char const   */* __restrict  */)tmp___76);
      }
#line 5953
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 5954
        printf((char const   */* __restrict  */)"%d", unwsec->sh_name);
        }
      } else {
#line 5956
        if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
          {
#line 5956
          tmp___77 = gettext("<none>");
#line 5956
          tmp___82 = tmp___77;
          }
        } else {
#line 5956
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 5956
            tmp___78 = gettext("<no-name>");
#line 5956
            tmp___81 = tmp___78;
            }
          } else {
#line 5956
            if ((unsigned long )unwsec->sh_name >= string_table_length) {
              {
#line 5956
              tmp___79 = gettext("<corrupt>");
#line 5956
              tmp___80 = tmp___79;
              }
            } else {
#line 5956
              tmp___80 = string_table + unwsec->sh_name;
            }
#line 5956
            tmp___81 = tmp___80;
          }
#line 5956
          tmp___82 = tmp___81;
        }
        {
#line 5956
        tmp___83 = gettext("\'%s\'");
#line 5956
        printf((char const   */* __restrict  */)tmp___83, tmp___82);
        }
      }
      {
#line 5958
      tmp___84 = gettext(" at offset 0x%lx contains %lu entries:\n");
#line 5958
      printf((char const   */* __restrict  */)tmp___84, (unsigned long )unwsec->sh_offset,
             unwsec->sh_size / (bfd_size_type )(3 * eh_addr_size));
#line 5962
      slurp_ia64_unwind_table(file, & aux, unwsec);
      }
#line 5964
      if (aux.table_len > 0UL) {
        {
#line 5965
        dump_ia64_unwind(& aux);
        }
      }
#line 5967
      if (aux.table) {
        {
#line 5968
        free((void *)((char *)aux.table));
        }
      }
#line 5969
      if (aux.info) {
        {
#line 5970
        free((void *)((char *)aux.info));
        }
      }
#line 5971
      aux.table = (struct ia64_unw_table_entry *)((void *)0);
#line 5972
      aux.info = (unsigned char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5976
  if (aux.symtab) {
    {
#line 5977
    free((void *)aux.symtab);
    }
  }
#line 5978
  if (aux.strtab) {
    {
#line 5979
    free((void *)aux.strtab);
    }
  }
#line 5980
  return;
}
}
#line 6030 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_hppa_unwind(struct hppa_unw_aux_info *aux ) 
{ 
  struct hppa_unw_table_entry *tp ;
  bfd_vma offset ;
  char const   *procname ;

  {
#line 6035
  tp = aux->table;
  {
#line 6035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6035
    if (! ((unsigned long )tp < (unsigned long )(aux->table + aux->table_len))) {
#line 6035
      goto while_break;
    }
    {
#line 6040
    find_symbol_for_address(aux->symtab, aux->nsyms, (char const   *)aux->strtab,
                            aux->strtab_size, tp->start, & procname, & offset);
#line 6044
    fputs((char const   */* __restrict  */)"\n<", (FILE */* __restrict  */)stdout);
    }
#line 6046
    if (procname) {
      {
#line 6048
      fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
      }
#line 6050
      if (offset) {
        {
#line 6051
        printf((char const   */* __restrict  */)"+%lx", offset);
        }
      }
    }
    {
#line 6054
    fputs((char const   */* __restrict  */)">: [", (FILE */* __restrict  */)stdout);
#line 6055
    print_vma(tp->start.offset, (print_mode )4);
#line 6056
    fputc('-', stdout);
#line 6057
    print_vma(tp->end.offset, (print_mode )4);
#line 6058
    printf((char const   */* __restrict  */)"]\n\t");
    }
#line 6062
    if (tp->Cannot_unwind) {
      {
#line 6062
      printf((char const   */* __restrict  */)"Cannot_unwind ");
      }
    }
#line 6063
    if (tp->Millicode) {
      {
#line 6063
      printf((char const   */* __restrict  */)"Millicode ");
      }
    }
#line 6064
    if (tp->Millicode_save_sr0) {
      {
#line 6064
      printf((char const   */* __restrict  */)"Millicode_save_sr0 ");
      }
    }
#line 6066
    if (tp->Entry_SR) {
      {
#line 6066
      printf((char const   */* __restrict  */)"Entry_SR ");
      }
    }
#line 6067
    if (tp->Entry_FR) {
      {
#line 6067
      printf((char const   */* __restrict  */)"Entry_FR=%d ", tp->Entry_FR);
      }
    }
#line 6068
    if (tp->Entry_GR) {
      {
#line 6068
      printf((char const   */* __restrict  */)"Entry_GR=%d ", tp->Entry_GR);
      }
    }
#line 6069
    if (tp->Args_stored) {
      {
#line 6069
      printf((char const   */* __restrict  */)"Args_stored ");
      }
    }
#line 6070
    if (tp->Variable_Frame) {
      {
#line 6070
      printf((char const   */* __restrict  */)"Variable_Frame ");
      }
    }
#line 6071
    if (tp->Separate_Package_Body) {
      {
#line 6071
      printf((char const   */* __restrict  */)"Separate_Package_Body ");
      }
    }
#line 6072
    if (tp->Frame_Extension_Millicode) {
      {
#line 6072
      printf((char const   */* __restrict  */)"Frame_Extension_Millicode ");
      }
    }
#line 6073
    if (tp->Stack_Overflow_Check) {
      {
#line 6073
      printf((char const   */* __restrict  */)"Stack_Overflow_Check ");
      }
    }
#line 6074
    if (tp->Two_Instruction_SP_Increment) {
      {
#line 6074
      printf((char const   */* __restrict  */)"Two_Instruction_SP_Increment ");
      }
    }
#line 6075
    if (tp->Ada_Region) {
      {
#line 6075
      printf((char const   */* __restrict  */)"Ada_Region ");
      }
    }
#line 6076
    if (tp->cxx_info) {
      {
#line 6076
      printf((char const   */* __restrict  */)"cxx_info ");
      }
    }
#line 6077
    if (tp->cxx_try_catch) {
      {
#line 6077
      printf((char const   */* __restrict  */)"cxx_try_catch ");
      }
    }
#line 6078
    if (tp->sched_entry_seq) {
      {
#line 6078
      printf((char const   */* __restrict  */)"sched_entry_seq ");
      }
    }
#line 6079
    if (tp->Save_SP) {
      {
#line 6079
      printf((char const   */* __restrict  */)"Save_SP ");
      }
    }
#line 6080
    if (tp->Save_RP) {
      {
#line 6080
      printf((char const   */* __restrict  */)"Save_RP ");
      }
    }
#line 6081
    if (tp->Save_MRP_in_frame) {
      {
#line 6081
      printf((char const   */* __restrict  */)"Save_MRP_in_frame ");
      }
    }
#line 6082
    if (tp->extn_ptr_defined) {
      {
#line 6082
      printf((char const   */* __restrict  */)"extn_ptr_defined ");
      }
    }
#line 6083
    if (tp->Cleanup_defined) {
      {
#line 6083
      printf((char const   */* __restrict  */)"Cleanup_defined ");
      }
    }
#line 6084
    if (tp->MPE_XL_interrupt_marker) {
      {
#line 6084
      printf((char const   */* __restrict  */)"MPE_XL_interrupt_marker ");
      }
    }
#line 6085
    if (tp->HP_UX_interrupt_marker) {
      {
#line 6085
      printf((char const   */* __restrict  */)"HP_UX_interrupt_marker ");
      }
    }
#line 6086
    if (tp->Large_frame) {
      {
#line 6086
      printf((char const   */* __restrict  */)"Large_frame ");
      }
    }
#line 6087
    if (tp->Pseudo_SP_Set) {
      {
#line 6087
      printf((char const   */* __restrict  */)"Pseudo_SP_Set ");
      }
    }
#line 6088
    if (tp->Total_frame_size) {
      {
#line 6088
      printf((char const   */* __restrict  */)"Total_frame_size=%d ", tp->Total_frame_size);
      }
    }
#line 6035
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6093
  printf((char const   */* __restrict  */)"\n");
  }
#line 6094
  return;
}
}
#line 6096 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int slurp_hppa_unwind_table(FILE *file , struct hppa_unw_aux_info *aux , Elf_Internal_Shdr *sec ) 
{ 
  unsigned long size ;
  unsigned long unw_ent_size ;
  unsigned long nentries ;
  unsigned long nrelas ;
  unsigned long i ;
  Elf_Internal_Phdr *seg ;
  struct hppa_unw_table_entry *tep ;
  Elf_Internal_Shdr *relsec ;
  Elf_Internal_Rela *rela ;
  Elf_Internal_Rela *rp ;
  unsigned char *table ;
  unsigned char *tp ;
  Elf_Internal_Sym *sym ;
  char const   *relname ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  struct hppa_unw_table_entry *tmp___3 ;
  void *tmp___4 ;
  unsigned int tmp1 ;
  unsigned int tmp2 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  int tmp___9 ;
  unsigned int tmp___10 ;
  bfd_vma tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;

  {
#line 6115
  if (elf_header.e_phnum) {
    {
#line 6117
    tmp___0 = get_program_headers(file);
    }
#line 6117
    if (! tmp___0) {
#line 6118
      return (0);
    }
#line 6120
    seg = program_headers;
    {
#line 6120
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6120
      if (! ((unsigned long )seg < (unsigned long )(program_headers + elf_header.e_phnum))) {
#line 6120
        goto while_break;
      }
#line 6124
      if (seg->p_type != 1UL) {
#line 6125
        goto __Cont;
      }
#line 6127
      if (sec->sh_addr >= seg->p_vaddr) {
#line 6127
        if (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz) {
#line 6130
          aux->seg_base = seg->p_vaddr;
#line 6131
          goto while_break;
        }
      }
      __Cont: /* CIL Label */ 
#line 6120
      seg ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 6138
  size = sec->sh_size;
#line 6139
  tmp___1 = gettext("unwind table");
#line 6139
  tmp___2 = get_data((void *)0, file, sec->sh_offset, (size_t )1, size, (char const   *)tmp___1);
#line 6139
  table = (unsigned char *)tmp___2;
  }
#line 6141
  if (! table) {
#line 6142
    return (0);
  }
  {
#line 6144
  unw_ent_size = 16UL;
#line 6145
  nentries = size / unw_ent_size;
#line 6146
  size = unw_ent_size * nentries;
#line 6148
  tmp___4 = xcmalloc(nentries, sizeof(*(aux->table + 0)));
#line 6148
  tmp___3 = (struct hppa_unw_table_entry *)tmp___4;
#line 6148
  aux->table = tmp___3;
#line 6148
  tep = tmp___3;
#line 6151
  tp = table;
  }
  {
#line 6151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6151
    if (! ((unsigned long )tp < (unsigned long )(table + size))) {
#line 6151
      goto while_break___0;
    }
    {
#line 6155
    tep->start.section = (unsigned short)0;
#line 6156
    tep->end.section = (unsigned short)0;
#line 6158
    tmp___5 = (*byte_get)(tp + 0, 4);
#line 6158
    tep->start.offset = (bfd_vma )tmp___5;
#line 6159
    tmp___6 = (*byte_get)(tp + 4, 4);
#line 6159
    tep->end.offset = (bfd_vma )tmp___6;
#line 6160
    tmp___7 = (*byte_get)(tp + 8, 4);
#line 6160
    tmp1 = (unsigned int )tmp___7;
#line 6161
    tmp___8 = (*byte_get)(tp + 12, 4);
#line 6161
    tmp2 = (unsigned int )tmp___8;
#line 6163
    tep->start.offset += aux->seg_base;
#line 6164
    tep->end.offset += aux->seg_base;
#line 6166
    tep->Cannot_unwind = (tmp1 >> 31) & 1U;
#line 6167
    tep->Millicode = (tmp1 >> 30) & 1U;
#line 6168
    tep->Millicode_save_sr0 = (tmp1 >> 29) & 1U;
#line 6169
    tep->Region_description = (tmp1 >> 27) & 3U;
#line 6170
    tep->reserved1 = (tmp1 >> 26) & 1U;
#line 6171
    tep->Entry_SR = (tmp1 >> 25) & 1U;
#line 6172
    tep->Entry_FR = (tmp1 >> 21) & 15U;
#line 6173
    tep->Entry_GR = (tmp1 >> 16) & 31U;
#line 6174
    tep->Args_stored = (tmp1 >> 15) & 1U;
#line 6175
    tep->Variable_Frame = (tmp1 >> 14) & 1U;
#line 6176
    tep->Separate_Package_Body = (tmp1 >> 13) & 1U;
#line 6177
    tep->Frame_Extension_Millicode = (tmp1 >> 12) & 1U;
#line 6178
    tep->Stack_Overflow_Check = (tmp1 >> 11) & 1U;
#line 6179
    tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 1U;
#line 6180
    tep->Ada_Region = (tmp1 >> 9) & 1U;
#line 6181
    tep->cxx_info = (tmp1 >> 8) & 1U;
#line 6182
    tep->cxx_try_catch = (tmp1 >> 7) & 1U;
#line 6183
    tep->sched_entry_seq = (tmp1 >> 6) & 1U;
#line 6184
    tep->reserved2 = (tmp1 >> 5) & 1U;
#line 6185
    tep->Save_SP = (tmp1 >> 4) & 1U;
#line 6186
    tep->Save_RP = (tmp1 >> 3) & 1U;
#line 6187
    tep->Save_MRP_in_frame = (tmp1 >> 2) & 1U;
#line 6188
    tep->extn_ptr_defined = (tmp1 >> 1) & 1U;
#line 6189
    tep->Cleanup_defined = tmp1 & 1U;
#line 6191
    tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 1U;
#line 6192
    tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 1U;
#line 6193
    tep->Large_frame = (tmp2 >> 29) & 1U;
#line 6194
    tep->Pseudo_SP_Set = (tmp2 >> 28) & 1U;
#line 6195
    tep->reserved4 = (tmp2 >> 27) & 1U;
#line 6196
    tep->Total_frame_size = tmp2 & 134217727U;
#line 6151
    tp += unw_ent_size;
#line 6151
    tep ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6198
  free((void *)table);
#line 6201
  relsec = section_headers;
  }
  {
#line 6201
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 6201
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 6201
      goto while_break___1;
    }
#line 6205
    if (relsec->sh_type != 4U) {
#line 6208
      goto __Cont___0;
    } else
#line 6205
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 6208
      goto __Cont___0;
    } else
#line 6205
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )sec) {
#line 6208
      goto __Cont___0;
    }
    {
#line 6210
    tmp___9 = slurp_rela_relocs(file, (unsigned long )relsec->sh_offset, relsec->sh_size,
                                & rela, & nrelas);
    }
#line 6210
    if (! tmp___9) {
#line 6212
      return (0);
    }
#line 6214
    rp = rela;
    {
#line 6214
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6214
      if (! ((unsigned long )rp < (unsigned long )(rela + nrelas))) {
#line 6214
        goto while_break___2;
      }
      {
#line 6216
      tmp___10 = get_reloc_type(rp->r_info);
#line 6216
      relname = elf_hppa_reloc_type((unsigned long )tmp___10);
#line 6217
      tmp___11 = get_reloc_symindex(rp->r_info);
#line 6217
      sym = aux->symtab + tmp___11;
#line 6220
      tmp___13 = strncmp(relname, "R_PARISC_SEGREL", sizeof("R_PARISC_SEGREL") - 1UL);
      }
#line 6220
      if (! (tmp___13 == 0)) {
        {
#line 6222
        tmp___12 = gettext("Skipping unexpected relocation type %s\n");
#line 6222
        warn((char const   *)tmp___12, relname);
        }
#line 6223
        goto __Cont___1;
      }
#line 6226
      i = rp->r_offset / unw_ent_size;
      {
#line 6230
      if ((rp->r_offset % unw_ent_size) / (unsigned long )eh_addr_size == 0UL) {
#line 6230
        goto case_0;
      }
#line 6234
      if ((rp->r_offset % unw_ent_size) / (unsigned long )eh_addr_size == 1UL) {
#line 6234
        goto case_1;
      }
#line 6238
      goto switch_default;
      case_0: /* CIL Label */ 
#line 6231
      (aux->table + i)->start.section = (unsigned short )sym->st_shndx;
#line 6232
      (aux->table + i)->start.offset = sym->st_value + rp->r_addend;
#line 6233
      goto switch_break;
      case_1: /* CIL Label */ 
#line 6235
      (aux->table + i)->end.section = (unsigned short )sym->st_shndx;
#line 6236
      (aux->table + i)->end.offset = sym->st_value + rp->r_addend;
#line 6237
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 6239
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
      __Cont___1: /* CIL Label */ 
#line 6214
      rp ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 6243
    free((void *)rela);
    }
    __Cont___0: /* CIL Label */ 
#line 6201
    relsec ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 6246
  aux->table_len = nentries;
#line 6248
  return (1);
}
}
#line 6251 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void hppa_process_unwind(FILE *file ) 
{ 
  struct hppa_unw_aux_info aux ;
  Elf_Internal_Shdr *unwsec ;
  Elf_Internal_Shdr *strsec ;
  Elf_Internal_Shdr *sec ;
  unsigned long i ;
  Elf_Internal_Sym *tmp___0 ;
  Elf_Internal_Sym *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;

  {
#line 6255
  unwsec = (Elf_Internal_Shdr *)((void *)0);
#line 6260
  if ((unsigned long )string_table == (unsigned long )((void *)0)) {
#line 6261
    return;
  }
  {
#line 6263
  memset((void *)(& aux), 0, sizeof(aux));
#line 6265
  i = 0UL;
#line 6265
  sec = section_headers;
  }
  {
#line 6265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6265
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6265
      goto while_break;
    }
#line 6267
    if (sec->sh_type == 2U) {
#line 6267
      if (sec->sh_link < elf_header.e_shnum) {
#line 6270
        if (is_32bit_elf) {
          {
#line 6270
          tmp___0 = get_32bit_elf_symbols(file, sec, & aux.nsyms);
#line 6270
          aux.symtab = tmp___0;
          }
        } else {
          {
#line 6270
          tmp___1 = get_64bit_elf_symbols(file, sec, & aux.nsyms);
#line 6270
          aux.symtab = tmp___1;
          }
        }
#line 6272
        strsec = section_headers + sec->sh_link;
#line 6273
        if (! ((unsigned long )aux.strtab == (unsigned long )((void *)0))) {
          {
#line 6273
          __assert_fail("aux.strtab == NULL", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                        6273U, "hppa_process_unwind");
          }
        }
        {
#line 6274
        tmp___2 = gettext("string table");
#line 6274
        tmp___3 = get_data((void *)0, file, strsec->sh_offset, (size_t )1, strsec->sh_size,
                           (char const   *)tmp___2);
#line 6274
        aux.strtab = (char *)tmp___3;
        }
#line 6277
        if ((unsigned long )aux.strtab != (unsigned long )((void *)0)) {
#line 6277
          aux.strtab_size = strsec->sh_size;
        } else {
#line 6277
          aux.strtab_size = 0UL;
        }
      } else {
#line 6267
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 6279
      if ((unsigned long )sec == (unsigned long )((void *)0)) {
        {
#line 6279
        tmp___4 = gettext("<none>");
#line 6279
        tmp___9 = tmp___4;
        }
      } else {
#line 6279
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 6279
          tmp___5 = gettext("<no-name>");
#line 6279
          tmp___8 = tmp___5;
          }
        } else {
#line 6279
          if ((unsigned long )sec->sh_name >= string_table_length) {
            {
#line 6279
            tmp___6 = gettext("<corrupt>");
#line 6279
            tmp___7 = tmp___6;
            }
          } else {
#line 6279
            tmp___7 = string_table + sec->sh_name;
          }
#line 6279
          tmp___8 = tmp___7;
        }
#line 6279
        tmp___9 = tmp___8;
      }
      {
#line 6279
      tmp___10 = strcmp((char const   *)tmp___9, ".PARISC.unwind");
      }
#line 6279
      if (tmp___10 == 0) {
#line 6280
        unwsec = sec;
      }
    }
#line 6265
    i ++;
#line 6265
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 6283
  if (! unwsec) {
    {
#line 6284
    tmp___11 = gettext("\nThere are no unwind sections in this file.\n");
#line 6284
    printf((char const   */* __restrict  */)tmp___11);
    }
  }
#line 6286
  i = 0UL;
#line 6286
  sec = section_headers;
  {
#line 6286
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6286
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 6286
      goto while_break___0;
    }
#line 6288
    if ((unsigned long )sec == (unsigned long )((void *)0)) {
      {
#line 6288
      tmp___21 = gettext("<none>");
#line 6288
      tmp___26 = tmp___21;
      }
    } else {
#line 6288
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 6288
        tmp___22 = gettext("<no-name>");
#line 6288
        tmp___25 = tmp___22;
        }
      } else {
#line 6288
        if ((unsigned long )sec->sh_name >= string_table_length) {
          {
#line 6288
          tmp___23 = gettext("<corrupt>");
#line 6288
          tmp___24 = tmp___23;
          }
        } else {
#line 6288
          tmp___24 = string_table + sec->sh_name;
        }
#line 6288
        tmp___25 = tmp___24;
      }
#line 6288
      tmp___26 = tmp___25;
    }
    {
#line 6288
    tmp___27 = strcmp((char const   *)tmp___26, ".PARISC.unwind");
    }
#line 6288
    if (tmp___27 == 0) {
      {
#line 6290
      tmp___12 = gettext("\nUnwind section ");
#line 6290
      printf((char const   */* __restrict  */)tmp___12);
      }
#line 6291
      if ((unsigned long )sec == (unsigned long )((void *)0)) {
        {
#line 6291
        tmp___13 = gettext("<none>");
#line 6291
        tmp___18 = tmp___13;
        }
      } else {
#line 6291
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 6291
          tmp___14 = gettext("<no-name>");
#line 6291
          tmp___17 = tmp___14;
          }
        } else {
#line 6291
          if ((unsigned long )sec->sh_name >= string_table_length) {
            {
#line 6291
            tmp___15 = gettext("<corrupt>");
#line 6291
            tmp___16 = tmp___15;
            }
          } else {
#line 6291
            tmp___16 = string_table + sec->sh_name;
          }
#line 6291
          tmp___17 = tmp___16;
        }
#line 6291
        tmp___18 = tmp___17;
      }
      {
#line 6291
      tmp___19 = gettext("\'%s\'");
#line 6291
      printf((char const   */* __restrict  */)tmp___19, tmp___18);
#line 6293
      tmp___20 = gettext(" at offset 0x%lx contains %lu entries:\n");
#line 6293
      printf((char const   */* __restrict  */)tmp___20, (unsigned long )sec->sh_offset,
             sec->sh_size / (bfd_size_type )(2 * eh_addr_size + 8));
#line 6297
      slurp_hppa_unwind_table(file, & aux, sec);
      }
#line 6298
      if (aux.table_len > 0UL) {
        {
#line 6299
        dump_hppa_unwind(& aux);
        }
      }
#line 6301
      if (aux.table) {
        {
#line 6302
        free((void *)((char *)aux.table));
        }
      }
#line 6303
      aux.table = (struct hppa_unw_table_entry *)((void *)0);
    }
#line 6286
    i ++;
#line 6286
    sec ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6307
  if (aux.symtab) {
    {
#line 6308
    free((void *)aux.symtab);
    }
  }
#line 6309
  if (aux.strtab) {
    {
#line 6310
    free((void *)aux.strtab);
    }
  }
#line 6311
  return;
}
}
#line 6332 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_print_vma_and_name(struct arm_unw_aux_info *aux , bfd_vma fn ,
                                            struct absaddr addr ) 
{ 
  char const   *procname ;
  bfd_vma sym_offset ;

  {
#line 6339
  if ((int )addr.section == 0) {
#line 6340
    addr.offset = fn;
  }
  {
#line 6342
  find_symbol_for_address(aux->symtab, aux->nsyms, (char const   *)aux->strtab, aux->strtab_size,
                          addr, & procname, & sym_offset);
#line 6346
  print_vma(fn, (print_mode )4);
  }
#line 6348
  if (procname) {
    {
#line 6350
    fputs((char const   */* __restrict  */)" <", (FILE */* __restrict  */)stdout);
#line 6351
    fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
    }
#line 6353
    if (sym_offset) {
      {
#line 6354
      printf((char const   */* __restrict  */)"+0x%lx", sym_offset);
      }
    }
    {
#line 6355
    fputc('>', stdout);
    }
  }
#line 6358
  return (procname);
}
}
#line 6361 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void arm_free_section(struct arm_section *arm_sec ) 
{ 


  {
#line 6364
  if ((unsigned long )arm_sec->data != (unsigned long )((void *)0)) {
    {
#line 6365
    free((void *)arm_sec->data);
    }
  }
#line 6367
  if ((unsigned long )arm_sec->rela != (unsigned long )((void *)0)) {
    {
#line 6368
    free((void *)arm_sec->rela);
    }
  }
#line 6369
  return;
}
}
#line 6382 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean get_unwind_section_word(struct arm_unw_aux_info *aux , struct arm_section *arm_sec ,
                                           Elf_Internal_Shdr *sec , bfd_vma word_offset ,
                                           unsigned int *wordp , struct absaddr *addr ,
                                           bfd_vma *sym_name ) 
{ 
  Elf_Internal_Rela *rp ;
  Elf_Internal_Sym *sym ;
  char const   *relname ;
  unsigned int word ;
  bfd_boolean wrapped ;
  Elf_Internal_Shdr *relsec ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  elf_vma tmp___5 ;
  bfd_vma prelval ;
  bfd_vma offset ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;

  {
#line 6397
  addr->section = (unsigned short)0;
#line 6398
  addr->offset = (bfd_vma )0;
#line 6400
  if ((unsigned long )sym_name != (unsigned long )((void *)0)) {
#line 6401
    *sym_name = (bfd_vma )-1;
  }
#line 6404
  if ((unsigned long )sec != (unsigned long )arm_sec->sec) {
    {
#line 6408
    arm_free_section(arm_sec);
#line 6410
    arm_sec->sec = sec;
#line 6411
    tmp___0 = gettext("unwind data");
#line 6411
    tmp___1 = get_data((void *)0, aux->file, sec->sh_offset, (size_t )1, sec->sh_size,
                       (char const   *)tmp___0);
#line 6411
    arm_sec->data = (unsigned char *)tmp___1;
#line 6413
    arm_sec->rela = (Elf_Internal_Rela *)((void *)0);
#line 6414
    arm_sec->nrelas = 0UL;
#line 6416
    relsec = section_headers;
    }
    {
#line 6416
    while (1) {
      while_continue: /* CIL Label */ ;
#line 6416
      if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 6416
        goto while_break;
      }
#line 6420
      if (relsec->sh_info >= elf_header.e_shnum) {
#line 6422
        goto __Cont;
      } else
#line 6420
      if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )sec) {
#line 6422
        goto __Cont;
      }
#line 6424
      arm_sec->rel_type = relsec->sh_type;
#line 6425
      if (relsec->sh_type == 9U) {
        {
#line 6427
        tmp___2 = slurp_rel_relocs(aux->file, (unsigned long )relsec->sh_offset, relsec->sh_size,
                                   & arm_sec->rela, & arm_sec->nrelas);
        }
#line 6427
        if (! tmp___2) {
#line 6430
          return (0);
        }
#line 6431
        goto while_break;
      } else
#line 6433
      if (relsec->sh_type == 4U) {
        {
#line 6435
        tmp___3 = slurp_rela_relocs(aux->file, (unsigned long )relsec->sh_offset,
                                    relsec->sh_size, & arm_sec->rela, & arm_sec->nrelas);
        }
#line 6435
        if (! tmp___3) {
#line 6438
          return (0);
        }
#line 6439
        goto while_break;
      } else {
        {
#line 6442
        tmp___4 = gettext("unexpected relocation type (%d) for section %d");
#line 6442
        warn((char const   *)tmp___4, relsec->sh_type, relsec->sh_info);
        }
      }
      __Cont: /* CIL Label */ 
#line 6416
      relsec ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 6446
    arm_sec->next_rela = arm_sec->rela;
  }
#line 6450
  if ((unsigned long )arm_sec->data == (unsigned long )((void *)0)) {
#line 6451
    return (0);
  }
  {
#line 6454
  tmp___5 = (*byte_get)(arm_sec->data + word_offset, 4);
#line 6454
  word = (unsigned int )tmp___5;
#line 6457
  wrapped = 0;
#line 6458
  rp = arm_sec->next_rela;
  }
  {
#line 6458
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6458
    if (! ((unsigned long )rp != (unsigned long )(arm_sec->rela + arm_sec->nrelas))) {
#line 6458
      goto while_break___0;
    }
#line 6462
    if (rp->r_offset > word_offset) {
#line 6462
      if (! wrapped) {
#line 6464
        rp = arm_sec->rela;
#line 6465
        wrapped = 1;
      }
    }
#line 6467
    if (rp->r_offset > word_offset) {
#line 6468
      goto while_break___0;
    }
#line 6470
    if (rp->r_offset & 3UL) {
      {
#line 6472
      tmp___6 = gettext("Skipping unexpected relocation at offset 0x%lx\n");
#line 6472
      warn((char const   *)tmp___6, rp->r_offset);
      }
#line 6474
      goto __Cont___0;
    }
#line 6477
    if (rp->r_offset < word_offset) {
#line 6478
      goto __Cont___0;
    }
#line 6480
    sym = aux->symtab + (rp->r_info >> 8);
#line 6482
    if (arm_sec->rel_type == 9U) {
#line 6484
      offset = (bfd_vma )(word & 2147483647U);
#line 6485
      if (offset & 1073741824UL) {
#line 6486
        offset |= 0xffffffff80000000UL;
      }
    } else
#line 6488
    if (arm_sec->rel_type == 4U) {
#line 6489
      offset = rp->r_addend;
    } else {
      {
#line 6491
      abort();
      }
    }
#line 6493
    offset += sym->st_value;
#line 6494
    prelval = offset - ((arm_sec->sec)->sh_addr + rp->r_offset);
#line 6497
    if ((int )elf_header.e_machine == 40) {
      {
#line 6499
      relname = elf_arm_reloc_type(rp->r_info & 255UL);
#line 6501
      tmp___7 = strcmp(relname, "R_ARM_NONE");
      }
#line 6501
      if (tmp___7 == 0) {
#line 6502
        goto __Cont___0;
      }
      {
#line 6504
      tmp___9 = strcmp(relname, "R_ARM_PREL31");
      }
#line 6504
      if (! (tmp___9 == 0)) {
        {
#line 6506
        tmp___8 = gettext("Skipping unexpected relocation type %s\n");
#line 6506
        warn((char const   *)tmp___8, relname);
        }
#line 6507
        goto __Cont___0;
      }
    } else
#line 6510
    if ((int )elf_header.e_machine == 140) {
      {
#line 6512
      relname = elf_tic6x_reloc_type(rp->r_info & 255UL);
#line 6514
      tmp___10 = strcmp(relname, "R_C6000_NONE");
      }
#line 6514
      if (tmp___10 == 0) {
#line 6515
        goto __Cont___0;
      }
      {
#line 6517
      tmp___12 = strcmp(relname, "R_C6000_PREL31");
      }
#line 6517
      if (! (tmp___12 == 0)) {
        {
#line 6519
        tmp___11 = gettext("Skipping unexpected relocation type %s\n");
#line 6519
        warn((char const   *)tmp___11, relname);
        }
#line 6520
        goto __Cont___0;
      }
#line 6523
      prelval >>= 1;
    } else {
      {
#line 6527
      abort();
      }
    }
#line 6529
    word = (unsigned int )(((unsigned long )word & 0xffffffff80000000UL) | (prelval & 2147483647UL));
#line 6530
    addr->section = (unsigned short )sym->st_shndx;
#line 6531
    addr->offset = offset;
#line 6532
    if (sym_name) {
#line 6533
      *sym_name = sym->st_name;
    }
#line 6534
    goto while_break___0;
    __Cont___0: /* CIL Label */ 
#line 6458
    rp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 6537
  *wordp = word;
#line 6538
  arm_sec->next_rela = rp;
#line 6540
  return (1);
}
}
#line 6543 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *tic6x_unwind_regnames[16]  = 
#line 6543
  {      "A15",      "B15",      "B14",      "B13", 
        "B12",      "B11",      "B10",      "B3", 
        "A14",      "A13",      "A12",      "A11", 
        "A10",      "[invalid reg 13]",      "[invalid reg 14]",      "[invalid reg 15]"};
#line 6550 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void decode_tic6x_unwind_regmask(unsigned int mask ) 
{ 
  int i ;

  {
#line 6555
  i = 12;
  {
#line 6555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6555
    if (! mask) {
#line 6555
      goto while_break;
    }
#line 6557
    if (mask & 1U) {
      {
#line 6559
      fputs((char const   */* __restrict  */)tic6x_unwind_regnames[i], (FILE */* __restrict  */)stdout);
      }
#line 6560
      if (mask > 1U) {
        {
#line 6561
        fputs((char const   */* __restrict  */)", ", (FILE */* __restrict  */)stdout);
        }
      }
    }
#line 6555
    mask >>= 1;
#line 6555
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 6564
  return;
}
}
#line 6592 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void decode_arm_unwind_bytecode(struct arm_unw_aux_info *aux , unsigned int word ,
                                       unsigned int remaining , unsigned int more_words ,
                                       bfd_vma data_offset , Elf_Internal_Shdr *data_sec ,
                                       struct arm_section *data_arm_sec ) 
{ 
  struct absaddr addr ;
  unsigned int op ;
  unsigned int op2 ;
  bfd_boolean tmp___0 ;
  int offset ;
  int offset___0 ;
  bfd_boolean tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int mask ;
  int first ;
  int i ;
  char *tmp___4 ;
  int end ;
  int first___0 ;
  int i___0 ;
  char *tmp___5 ;
  bfd_boolean tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  unsigned int mask___0 ;
  int first___1 ;
  int i___1 ;
  unsigned char buf___4[9] ;
  unsigned int i___2 ;
  unsigned int len ;
  unsigned long offset___1 ;
  bfd_boolean tmp___9 ;
  char *tmp___10 ;
  unsigned int first___2 ;
  unsigned int last ;
  bfd_boolean tmp___12 ;
  char *tmp___13 ;
  unsigned int count ;
  unsigned int count___0 ;
  unsigned int first___3 ;
  unsigned int last___0 ;
  bfd_boolean tmp___14 ;
  char *tmp___15 ;
  bfd_boolean tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  unsigned int mask___1 ;
  int first___4 ;
  int i___3 ;
  char *tmp___19 ;

  {
  {
#line 6602
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6606
    if (remaining == 0U) {
#line 6606
      if (more_words) {
        {
#line 6606
        data_offset += 4UL;
#line 6606
        tmp___0 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                          & word, & addr, (bfd_vma *)((void *)0));
        }
#line 6606
        if (! tmp___0) {
#line 6606
          return;
        }
#line 6606
        remaining = 4U;
#line 6606
        more_words --;
      }
    }
#line 6607
    if (remaining == 0U) {
#line 6608
      goto while_break;
    }
    {
#line 6609
    remaining --;
#line 6610
    op = word >> 24;
#line 6611
    word <<= 8;
#line 6613
    printf((char const   */* __restrict  */)"  0x%02x ", op);
    }
#line 6615
    if ((op & 192U) == 0U) {
      {
#line 6617
      offset = (int )(((op & 63U) << 2) + 4U);
#line 6619
      printf((char const   */* __restrict  */)"     vsp = vsp + %d", offset);
      }
    } else
#line 6621
    if ((op & 192U) == 64U) {
      {
#line 6623
      offset___0 = (int )(((op & 63U) << 2) + 4U);
#line 6625
      printf((char const   */* __restrict  */)"     vsp = vsp - %d", offset___0);
      }
    } else
#line 6627
    if ((op & 240U) == 128U) {
#line 6629
      if (remaining == 0U) {
#line 6629
        if (more_words) {
          {
#line 6629
          data_offset += 4UL;
#line 6629
          tmp___1 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                            & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6629
          if (! tmp___1) {
#line 6629
            return;
          }
#line 6629
          remaining = 4U;
#line 6629
          more_words --;
        }
      }
#line 6629
      if (remaining) {
#line 6629
        remaining --;
#line 6629
        op2 = word >> 24;
#line 6629
        word <<= 8;
      } else {
        {
#line 6629
        tmp___2 = gettext("[Truncated opcode]\n");
#line 6629
        printf((char const   */* __restrict  */)tmp___2);
        }
#line 6629
        return;
      }
      {
#line 6629
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6630
      if (op == 128U) {
#line 6630
        if (op2 == 0U) {
          {
#line 6631
          tmp___3 = gettext("Refuse to unwind");
#line 6631
          printf((char const   */* __restrict  */)tmp___3);
          }
        } else {
#line 6630
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 6634
        mask = ((op & 15U) << 8) | op2;
#line 6635
        first = 1;
#line 6638
        printf((char const   */* __restrict  */)"pop {");
#line 6639
        i = 0;
        }
        {
#line 6639
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 6639
          if (! (i < 12)) {
#line 6639
            goto while_break___0;
          }
#line 6640
          if (mask & (unsigned int )(1 << i)) {
#line 6642
            if (first) {
#line 6643
              first = 0;
            } else {
              {
#line 6645
              printf((char const   */* __restrict  */)", ");
              }
            }
            {
#line 6646
            printf((char const   */* __restrict  */)"r%d", 4 + i);
            }
          }
#line 6639
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 6648
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else
#line 6651
    if ((op & 240U) == 144U) {
#line 6653
      if (op == 157U) {
        {
#line 6654
        tmp___4 = gettext("     [Reserved]");
#line 6654
        printf((char const   */* __restrict  */)tmp___4);
        }
      } else
#line 6653
      if (op == 159U) {
        {
#line 6654
        tmp___4 = gettext("     [Reserved]");
#line 6654
        printf((char const   */* __restrict  */)tmp___4);
        }
      } else {
        {
#line 6656
        printf((char const   */* __restrict  */)"     vsp = r%d", op & 15U);
        }
      }
    } else
#line 6658
    if ((op & 240U) == 160U) {
      {
#line 6660
      end = (int )(4U + (op & 7U));
#line 6661
      first___0 = 1;
#line 6664
      printf((char const   */* __restrict  */)"     pop {");
#line 6665
      i___0 = 4;
      }
      {
#line 6665
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6665
        if (! (i___0 <= end)) {
#line 6665
          goto while_break___1;
        }
#line 6667
        if (first___0) {
#line 6668
          first___0 = 0;
        } else {
          {
#line 6670
          printf((char const   */* __restrict  */)", ");
          }
        }
        {
#line 6671
        printf((char const   */* __restrict  */)"r%d", i___0);
#line 6665
        i___0 ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 6673
      if (op & 8U) {
#line 6675
        if (! first___0) {
          {
#line 6676
          printf((char const   */* __restrict  */)", ");
          }
        }
        {
#line 6677
        printf((char const   */* __restrict  */)"r14");
        }
      }
      {
#line 6679
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6681
    if (op == 176U) {
      {
#line 6682
      tmp___5 = gettext("     finish");
#line 6682
      printf((char const   */* __restrict  */)tmp___5);
      }
    } else
#line 6683
    if (op == 177U) {
#line 6685
      if (remaining == 0U) {
#line 6685
        if (more_words) {
          {
#line 6685
          data_offset += 4UL;
#line 6685
          tmp___6 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                            & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6685
          if (! tmp___6) {
#line 6685
            return;
          }
#line 6685
          remaining = 4U;
#line 6685
          more_words --;
        }
      }
#line 6685
      if (remaining) {
#line 6685
        remaining --;
#line 6685
        op2 = word >> 24;
#line 6685
        word <<= 8;
      } else {
        {
#line 6685
        tmp___7 = gettext("[Truncated opcode]\n");
#line 6685
        printf((char const   */* __restrict  */)tmp___7);
        }
#line 6685
        return;
      }
      {
#line 6685
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6686
      if (op2 == 0U) {
        {
#line 6687
        tmp___8 = gettext("[Spare]");
#line 6687
        printf((char const   */* __restrict  */)tmp___8);
        }
      } else
#line 6686
      if ((op2 & 240U) != 0U) {
        {
#line 6687
        tmp___8 = gettext("[Spare]");
#line 6687
        printf((char const   */* __restrict  */)tmp___8);
        }
      } else {
        {
#line 6690
        mask___0 = op2 & 15U;
#line 6691
        first___1 = 1;
#line 6694
        printf((char const   */* __restrict  */)"pop {");
#line 6695
        i___1 = 0;
        }
        {
#line 6695
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 6695
          if (! (i___1 < 12)) {
#line 6695
            goto while_break___2;
          }
#line 6696
          if (mask___0 & (unsigned int )(1 << i___1)) {
#line 6698
            if (first___1) {
#line 6699
              first___1 = 0;
            } else {
              {
#line 6701
              printf((char const   */* __restrict  */)", ");
              }
            }
            {
#line 6702
            printf((char const   */* __restrict  */)"r%d", i___1);
            }
          }
#line 6695
          i___1 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 6704
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else
#line 6707
    if (op == 178U) {
#line 6713
      i___2 = 0U;
      {
#line 6713
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6713
        if (! ((unsigned long )i___2 < sizeof(buf___4))) {
#line 6713
          goto while_break___3;
        }
#line 6715
        if (remaining == 0U) {
#line 6715
          if (more_words) {
            {
#line 6715
            data_offset += 4UL;
#line 6715
            tmp___9 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                              & word, & addr, (bfd_vma *)((void *)0));
            }
#line 6715
            if (! tmp___9) {
#line 6715
              return;
            }
#line 6715
            remaining = 4U;
#line 6715
            more_words --;
          }
        }
#line 6715
        if (remaining) {
#line 6715
          remaining --;
#line 6715
          buf___4[i___2] = (unsigned char )(word >> 24);
#line 6715
          word <<= 8;
        } else {
          {
#line 6715
          tmp___10 = gettext("[Truncated opcode]\n");
#line 6715
          printf((char const   */* __restrict  */)tmp___10);
          }
#line 6715
          return;
        }
        {
#line 6715
        printf((char const   */* __restrict  */)"0x%02x ", (int )buf___4[i___2]);
        }
#line 6716
        if (((int )buf___4[i___2] & 128) == 0) {
#line 6717
          goto while_break___3;
        }
#line 6713
        i___2 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6719
      if (! ((unsigned long )i___2 < sizeof(buf___4))) {
        {
#line 6719
        __assert_fail("i < sizeof (buf)", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                      6719U, "decode_arm_unwind_bytecode");
        }
      }
      {
#line 6720
      offset___1 = read_uleb128(buf___4, & len);
      }
#line 6721
      if (! (len == i___2 + 1U)) {
        {
#line 6721
        __assert_fail("len == i + 1", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                      6721U, "decode_arm_unwind_bytecode");
        }
      }
      {
#line 6722
      offset___1 = offset___1 * 4UL + 516UL;
#line 6723
      printf((char const   */* __restrict  */)"vsp = vsp + %ld", offset___1);
      }
    } else
#line 6725
    if (op == 179U) {
#line 6725
      goto _L___2;
    } else
#line 6725
    if (op == 200U) {
#line 6725
      goto _L___2;
    } else
#line 6725
    if (op == 201U) {
      _L___2: /* CIL Label */ 
#line 6729
      if (remaining == 0U) {
#line 6729
        if (more_words) {
          {
#line 6729
          data_offset += 4UL;
#line 6729
          tmp___12 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                             & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6729
          if (! tmp___12) {
#line 6729
            return;
          }
#line 6729
          remaining = 4U;
#line 6729
          more_words --;
        }
      }
#line 6729
      if (remaining) {
#line 6729
        remaining --;
#line 6729
        op2 = word >> 24;
#line 6729
        word <<= 8;
      } else {
        {
#line 6729
        tmp___13 = gettext("[Truncated opcode]\n");
#line 6729
        printf((char const   */* __restrict  */)tmp___13);
        }
#line 6729
        return;
      }
      {
#line 6729
      printf((char const   */* __restrict  */)"0x%02x ", op2);
#line 6730
      first___2 = op2 >> 4;
#line 6731
      last = op2 & 15U;
      }
#line 6732
      if (op == 200U) {
#line 6733
        first___2 += 16U;
      }
      {
#line 6734
      printf((char const   */* __restrict  */)"pop {D%d", first___2);
      }
#line 6735
      if (last) {
        {
#line 6736
        printf((char const   */* __restrict  */)"-D%d", first___2 + last);
        }
      }
      {
#line 6737
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6739
    if ((op & 248U) == 184U) {
#line 6739
      goto _L___1;
    } else
#line 6739
    if ((op & 248U) == 208U) {
      _L___1: /* CIL Label */ 
      {
#line 6741
      count = op & 7U;
#line 6743
      printf((char const   */* __restrict  */)"pop {D8");
      }
#line 6744
      if (count) {
        {
#line 6745
        printf((char const   */* __restrict  */)"-D%d", 8U + count);
        }
      }
      {
#line 6746
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6748
    if (op >= 192U) {
#line 6748
      if (op <= 197U) {
        {
#line 6750
        count___0 = op & 7U;
#line 6752
        printf((char const   */* __restrict  */)"     pop {wR10");
        }
#line 6753
        if (count___0) {
          {
#line 6754
          printf((char const   */* __restrict  */)"-wR%d", 10U + count___0);
          }
        }
        {
#line 6755
        printf((char const   */* __restrict  */)"}");
        }
      } else {
#line 6748
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 6757
    if (op == 198U) {
#line 6761
      if (remaining == 0U) {
#line 6761
        if (more_words) {
          {
#line 6761
          data_offset += 4UL;
#line 6761
          tmp___14 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                             & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6761
          if (! tmp___14) {
#line 6761
            return;
          }
#line 6761
          remaining = 4U;
#line 6761
          more_words --;
        }
      }
#line 6761
      if (remaining) {
#line 6761
        remaining --;
#line 6761
        op2 = word >> 24;
#line 6761
        word <<= 8;
      } else {
        {
#line 6761
        tmp___15 = gettext("[Truncated opcode]\n");
#line 6761
        printf((char const   */* __restrict  */)tmp___15);
        }
#line 6761
        return;
      }
      {
#line 6761
      printf((char const   */* __restrict  */)"0x%02x ", op2);
#line 6762
      first___3 = op2 >> 4;
#line 6763
      last___0 = op2 & 15U;
#line 6764
      printf((char const   */* __restrict  */)"pop {wR%d", first___3);
      }
#line 6765
      if (last___0) {
        {
#line 6766
        printf((char const   */* __restrict  */)"-wR%d", first___3 + last___0);
        }
      }
      {
#line 6767
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6769
    if (op == 199U) {
#line 6771
      if (remaining == 0U) {
#line 6771
        if (more_words) {
          {
#line 6771
          data_offset += 4UL;
#line 6771
          tmp___16 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                             & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6771
          if (! tmp___16) {
#line 6771
            return;
          }
#line 6771
          remaining = 4U;
#line 6771
          more_words --;
        }
      }
#line 6771
      if (remaining) {
#line 6771
        remaining --;
#line 6771
        op2 = word >> 24;
#line 6771
        word <<= 8;
      } else {
        {
#line 6771
        tmp___17 = gettext("[Truncated opcode]\n");
#line 6771
        printf((char const   */* __restrict  */)tmp___17);
        }
#line 6771
        return;
      }
      {
#line 6771
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6772
      if (op2 == 0U) {
        {
#line 6773
        tmp___18 = gettext("[Spare]");
#line 6773
        printf((char const   */* __restrict  */)tmp___18);
        }
      } else
#line 6772
      if ((op2 & 240U) != 0U) {
        {
#line 6773
        tmp___18 = gettext("[Spare]");
#line 6773
        printf((char const   */* __restrict  */)tmp___18);
        }
      } else {
        {
#line 6776
        mask___1 = op2 & 15U;
#line 6777
        first___4 = 1;
#line 6780
        printf((char const   */* __restrict  */)"pop {");
#line 6781
        i___3 = 0;
        }
        {
#line 6781
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 6781
          if (! (i___3 < 4)) {
#line 6781
            goto while_break___4;
          }
#line 6782
          if (mask___1 & (unsigned int )(1 << i___3)) {
#line 6784
            if (first___4) {
#line 6785
              first___4 = 0;
            } else {
              {
#line 6787
              printf((char const   */* __restrict  */)", ");
              }
            }
            {
#line 6788
            printf((char const   */* __restrict  */)"wCGR%d", i___3);
            }
          }
#line 6781
          i___3 ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 6790
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else {
      {
#line 6794
      tmp___19 = gettext("     [unsupported opcode]");
#line 6794
      printf((char const   */* __restrict  */)tmp___19);
      }
    }
    {
#line 6795
    printf((char const   */* __restrict  */)"\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6797
  return;
}
}
#line 6799 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void decode_tic6x_unwind_bytecode(struct arm_unw_aux_info *aux , unsigned int word ,
                                         unsigned int remaining , unsigned int more_words ,
                                         bfd_vma data_offset , Elf_Internal_Shdr *data_sec ,
                                         struct arm_section *data_arm_sec ) 
{ 
  struct absaddr addr ;
  unsigned int op ;
  unsigned int op2 ;
  bfd_boolean tmp___0 ;
  int offset ;
  bfd_boolean tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned int mask ;
  unsigned int reg___0 ;
  unsigned int nregs ;
  unsigned int i ;
  char const   *name___0 ;
  struct __anonstruct_regpos_1006031692 regpos[16] ;
  bfd_boolean tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned char buf___4[9] ;
  unsigned int i___0 ;
  unsigned int len ;
  unsigned long offset___0 ;
  bfd_boolean tmp___8 ;
  char *tmp___9 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 6809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6813
    if (remaining == 0U) {
#line 6813
      if (more_words) {
        {
#line 6813
        data_offset += 4UL;
#line 6813
        tmp___0 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                          & word, & addr, (bfd_vma *)((void *)0));
        }
#line 6813
        if (! tmp___0) {
#line 6813
          return;
        }
#line 6813
        remaining = 4U;
#line 6813
        more_words --;
      }
    }
#line 6814
    if (remaining == 0U) {
#line 6815
      goto while_break;
    }
    {
#line 6816
    remaining --;
#line 6817
    op = word >> 24;
#line 6818
    word <<= 8;
#line 6820
    printf((char const   */* __restrict  */)"  0x%02x ", op);
    }
#line 6822
    if ((op & 192U) == 0U) {
      {
#line 6824
      offset = (int )(((op & 63U) << 3) + 8U);
#line 6825
      printf((char const   */* __restrict  */)"     sp = sp + %d", offset);
      }
    } else
#line 6827
    if ((op & 192U) == 128U) {
#line 6829
      if (remaining == 0U) {
#line 6829
        if (more_words) {
          {
#line 6829
          data_offset += 4UL;
#line 6829
          tmp___1 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                            & word, & addr, (bfd_vma *)((void *)0));
          }
#line 6829
          if (! tmp___1) {
#line 6829
            return;
          }
#line 6829
          remaining = 4U;
#line 6829
          more_words --;
        }
      }
#line 6829
      if (remaining) {
#line 6829
        remaining --;
#line 6829
        op2 = word >> 24;
#line 6829
        word <<= 8;
      } else {
        {
#line 6829
        tmp___2 = gettext("[Truncated opcode]\n");
#line 6829
        printf((char const   */* __restrict  */)tmp___2);
        }
#line 6829
        return;
      }
      {
#line 6829
      printf((char const   */* __restrict  */)"0x%02x ", op2);
      }
#line 6830
      if (op == 128U) {
#line 6830
        if (op2 == 0U) {
          {
#line 6831
          tmp___3 = gettext("Refuse to unwind");
#line 6831
          printf((char const   */* __restrict  */)tmp___3);
          }
        } else {
#line 6830
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 6834
        mask = ((op & 31U) << 8) | op2;
#line 6835
        if (op & 32U) {
          {
#line 6836
          printf((char const   */* __restrict  */)"pop compact {");
          }
        } else {
          {
#line 6838
          printf((char const   */* __restrict  */)"pop {");
          }
        }
        {
#line 6840
        decode_tic6x_unwind_regmask(mask);
#line 6841
        printf((char const   */* __restrict  */)"}");
        }
      }
    } else
#line 6844
    if ((op & 240U) == 192U) {
#line 6858
      nregs = 0U;
#line 6859
      i = 0U;
      {
#line 6859
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 6859
        if (! (nregs < (op & 15U))) {
#line 6859
          goto while_break___0;
        }
#line 6861
        if (remaining == 0U) {
#line 6861
          if (more_words) {
            {
#line 6861
            data_offset += 4UL;
#line 6861
            tmp___4 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                              & word, & addr, (bfd_vma *)((void *)0));
            }
#line 6861
            if (! tmp___4) {
#line 6861
              return;
            }
#line 6861
            remaining = 4U;
#line 6861
            more_words --;
          }
        }
#line 6861
        if (remaining) {
#line 6861
          remaining --;
#line 6861
          op2 = word >> 24;
#line 6861
          word <<= 8;
        } else {
          {
#line 6861
          tmp___5 = gettext("[Truncated opcode]\n");
#line 6861
          printf((char const   */* __restrict  */)tmp___5);
          }
#line 6861
          return;
        }
        {
#line 6861
        printf((char const   */* __restrict  */)"0x%02x ", op2);
#line 6862
        reg___0 = op2 >> 4;
        }
#line 6863
        if (reg___0 != 15U) {
#line 6865
          regpos[nregs].offset = i * 2U;
#line 6866
          regpos[nregs].reg = reg___0;
#line 6867
          nregs ++;
        }
#line 6870
        reg___0 = op2 & 15U;
#line 6871
        if (reg___0 != 15U) {
#line 6873
          regpos[nregs].offset = i * 2U + 1U;
#line 6874
          regpos[nregs].reg = reg___0;
#line 6875
          nregs ++;
        }
#line 6859
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 6879
      tmp___6 = gettext("pop frame {");
#line 6879
      printf((char const   */* __restrict  */)tmp___6);
#line 6880
      reg___0 = nregs - 1U;
#line 6881
      i *= 2U;
      }
      {
#line 6881
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6881
        if (! (i > 0U)) {
#line 6881
          goto while_break___1;
        }
#line 6883
        if (regpos[reg___0].offset == i - 1U) {
#line 6885
          name___0 = tic6x_unwind_regnames[regpos[reg___0].reg];
#line 6886
          if (reg___0 > 0U) {
#line 6887
            reg___0 --;
          }
        } else {
          {
#line 6890
          tmp___7 = gettext("[pad]");
#line 6890
          name___0 = (char const   *)tmp___7;
          }
        }
        {
#line 6892
        fputs((char const   */* __restrict  */)name___0, (FILE */* __restrict  */)stdout);
        }
#line 6893
        if (i > 1U) {
          {
#line 6894
          printf((char const   */* __restrict  */)", ");
          }
        }
#line 6881
        i --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 6897
      printf((char const   */* __restrict  */)"}");
      }
    } else
#line 6899
    if (op == 208U) {
      {
#line 6900
      printf((char const   */* __restrict  */)"     MOV FP, SP");
      }
    } else
#line 6901
    if (op == 209U) {
      {
#line 6902
      printf((char const   */* __restrict  */)"     __c6xabi_pop_rts");
      }
    } else
#line 6903
    if (op == 210U) {
#line 6909
      i___0 = 0U;
      {
#line 6909
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 6909
        if (! ((unsigned long )i___0 < sizeof(buf___4))) {
#line 6909
          goto while_break___2;
        }
#line 6911
        if (remaining == 0U) {
#line 6911
          if (more_words) {
            {
#line 6911
            data_offset += 4UL;
#line 6911
            tmp___8 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                              & word, & addr, (bfd_vma *)((void *)0));
            }
#line 6911
            if (! tmp___8) {
#line 6911
              return;
            }
#line 6911
            remaining = 4U;
#line 6911
            more_words --;
          }
        }
#line 6911
        if (remaining) {
#line 6911
          remaining --;
#line 6911
          buf___4[i___0] = (unsigned char )(word >> 24);
#line 6911
          word <<= 8;
        } else {
          {
#line 6911
          tmp___9 = gettext("[Truncated opcode]\n");
#line 6911
          printf((char const   */* __restrict  */)tmp___9);
          }
#line 6911
          return;
        }
        {
#line 6911
        printf((char const   */* __restrict  */)"0x%02x ", (int )buf___4[i___0]);
        }
#line 6912
        if (((int )buf___4[i___0] & 128) == 0) {
#line 6913
          goto while_break___2;
        }
#line 6909
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 6915
      if (! ((unsigned long )i___0 < sizeof(buf___4))) {
        {
#line 6915
        __assert_fail("i < sizeof (buf)", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                      6915U, "decode_tic6x_unwind_bytecode");
        }
      }
      {
#line 6916
      offset___0 = read_uleb128(buf___4, & len);
      }
#line 6917
      if (! (len == i___0 + 1U)) {
        {
#line 6917
        __assert_fail("len == i + 1", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                      6917U, "decode_tic6x_unwind_bytecode");
        }
      }
      {
#line 6918
      offset___0 = offset___0 * 8UL + 1032UL;
#line 6919
      tmp___11 = gettext("sp = sp + %ld");
#line 6919
      printf((char const   */* __restrict  */)tmp___11, offset___0);
      }
    } else
#line 6921
    if ((op & 240U) == 224U) {
#line 6923
      if ((op & 15U) == 7U) {
        {
#line 6924
        printf((char const   */* __restrict  */)"     RETURN");
        }
      } else {
        {
#line 6926
        printf((char const   */* __restrict  */)"     MV %s, B3", tic6x_unwind_regnames[op & 15U]);
        }
      }
    } else {
      {
#line 6930
      tmp___12 = gettext("     [unsupported opcode]");
#line 6930
      printf((char const   */* __restrict  */)tmp___12);
      }
    }
    {
#line 6932
    putchar('\n');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6934
  return;
}
}
#line 6936 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma arm_expand_prel31(bfd_vma word , bfd_vma where ) 
{ 
  bfd_vma offset ;

  {
#line 6941
  offset = word & 2147483647UL;
#line 6942
  if (offset & 1073741824UL) {
#line 6943
    offset |= 0xffffffff80000000UL;
  }
#line 6945
  if ((int )elf_header.e_machine == 140) {
#line 6946
    offset <<= 1;
  }
#line 6948
  return (offset + where);
}
}
#line 6951 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void decode_arm_unwind(struct arm_unw_aux_info *aux , unsigned int word , unsigned int remaining ,
                              bfd_vma data_offset , Elf_Internal_Shdr *data_sec ,
                              struct arm_section *data_arm_sec ) 
{ 
  int per_index ;
  unsigned int more_words ;
  struct absaddr addr ;
  bfd_vma sym_name ;
  bfd_boolean tmp___0 ;
  bfd_vma fn ;
  char const   *procname ;
  char *tmp___1 ;
  bfd_boolean tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 6960
  more_words = 0U;
#line 6962
  sym_name = (bfd_vma )-1;
#line 6964
  if (remaining == 0U) {
    {
#line 6971
    tmp___0 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset, & word,
                                      & addr, & sym_name);
    }
#line 6971
    if (! tmp___0) {
#line 6973
      return;
    }
#line 6975
    remaining = 4U;
  }
#line 6978
  if ((word & 2147483648U) == 0U) {
    {
#line 6984
    fn = arm_expand_prel31((bfd_vma )word, data_sec->sh_addr + data_offset);
#line 6985
    tmp___1 = gettext("  Personality routine: ");
#line 6985
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 6986
    if (fn == 0UL) {
#line 6986
      if ((int )addr.section == 0) {
#line 6986
        if (addr.offset == 0UL) {
#line 6986
          if (sym_name != 0xffffffffffffffffUL) {
#line 6986
            if (sym_name < aux->strtab_size) {
              {
#line 6990
              procname = (char const   *)(aux->strtab + sym_name);
#line 6991
              print_vma(fn, (print_mode )4);
              }
#line 6992
              if (procname) {
                {
#line 6994
                fputs((char const   */* __restrict  */)" <", (FILE */* __restrict  */)stdout);
#line 6995
                fputs((char const   */* __restrict  */)procname, (FILE */* __restrict  */)stdout);
#line 6996
                fputc('>', stdout);
                }
              }
            } else {
              {
#line 7000
              procname = arm_print_vma_and_name(aux, fn, addr);
              }
            }
          } else {
            {
#line 7000
            procname = arm_print_vma_and_name(aux, fn, addr);
            }
          }
        } else {
          {
#line 7000
          procname = arm_print_vma_and_name(aux, fn, addr);
          }
        }
      } else {
        {
#line 7000
        procname = arm_print_vma_and_name(aux, fn, addr);
        }
      }
    } else {
      {
#line 7000
      procname = arm_print_vma_and_name(aux, fn, addr);
      }
    }
    {
#line 7001
    fputc('\n', stdout);
    }
#line 7006
    if ((unsigned long )procname != (unsigned long )((void *)0)) {
      {
#line 7006
      tmp___4 = strncmp(procname, "__gcc_personality_v0", sizeof("__gcc_personality_v0") - 1UL);
      }
#line 7006
      if (tmp___4 == 0) {
#line 7006
        goto _L;
      } else {
        {
#line 7006
        tmp___5 = strncmp(procname, "__gxx_personality_v0", sizeof("__gxx_personality_v0") - 1UL);
        }
#line 7006
        if (tmp___5 == 0) {
#line 7006
          goto _L;
        } else {
          {
#line 7006
          tmp___6 = strncmp(procname, "__gcj_personality_v0", sizeof("__gcj_personality_v0") - 1UL);
          }
#line 7006
          if (tmp___6 == 0) {
#line 7006
            goto _L;
          } else {
            {
#line 7006
            tmp___7 = strncmp(procname, "__gnu_objc_personality_v0", sizeof("__gnu_objc_personality_v0") - 1UL);
            }
#line 7006
            if (tmp___7 == 0) {
              _L: /* CIL Label */ 
#line 7012
              remaining = 0U;
#line 7013
              more_words = 1U;
#line 7014
              if (remaining == 0U) {
#line 7014
                if (more_words) {
                  {
#line 7014
                  data_offset += 4UL;
#line 7014
                  tmp___2 = get_unwind_section_word(aux, data_arm_sec, data_sec, data_offset,
                                                    & word, & addr, (bfd_vma *)((void *)0));
                  }
#line 7014
                  if (! tmp___2) {
#line 7014
                    return;
                  }
#line 7014
                  remaining = 4U;
#line 7014
                  more_words --;
                }
              }
#line 7015
              if (! remaining) {
                {
#line 7017
                tmp___3 = gettext("  [Truncated data]\n");
#line 7017
                printf((char const   */* __restrict  */)tmp___3);
                }
#line 7018
                return;
              }
#line 7020
              more_words = word >> 24;
#line 7021
              word <<= 8;
#line 7022
              remaining --;
#line 7023
              per_index = -1;
            } else {
#line 7026
              return;
            }
          }
        }
      }
    } else {
#line 7026
      return;
    }
  } else {
#line 7038
    if ((int )elf_header.e_machine == 40) {
#line 7038
      if (word & 1879048192U) {
        {
#line 7040
        tmp___8 = gettext("Corrupt ARM compact model table entry: %x \n");
#line 7040
        warn((char const   *)tmp___8, word);
        }
      }
    }
    {
#line 7042
    per_index = (int )((word >> 24) & 127U);
#line 7043
    tmp___9 = gettext("  Compact model index: %d\n");
#line 7043
    printf((char const   */* __restrict  */)tmp___9, per_index);
    }
#line 7044
    if (per_index == 0) {
#line 7046
      more_words = 0U;
#line 7047
      word <<= 8;
#line 7048
      remaining --;
    } else
#line 7050
    if (per_index < 3) {
#line 7052
      more_words = (word >> 16) & 255U;
#line 7053
      word <<= 16;
#line 7054
      remaining -= 2U;
    }
  }
  {
#line 7060
  if ((int )elf_header.e_machine == 40) {
#line 7060
    goto case_40;
  }
#line 7073
  if ((int )elf_header.e_machine == 140) {
#line 7073
    goto case_140;
  }
#line 7097
  goto switch_default;
  case_40: /* CIL Label */ 
#line 7061
  if (per_index < 3) {
    {
#line 7063
    decode_arm_unwind_bytecode(aux, word, remaining, more_words, data_offset, data_sec,
                               data_arm_sec);
    }
  } else {
    {
#line 7068
    tmp___10 = gettext("Unknown ARM compact model index encountered\n");
#line 7068
    warn((char const   *)tmp___10);
#line 7069
    tmp___11 = gettext("  [reserved]\n");
#line 7069
    printf((char const   */* __restrict  */)tmp___11);
    }
  }
#line 7071
  goto switch_break;
  case_140: /* CIL Label */ 
#line 7074
  if (per_index < 3) {
    {
#line 7076
    decode_tic6x_unwind_bytecode(aux, word, remaining, more_words, data_offset, data_sec,
                                 data_arm_sec);
    }
  } else
#line 7079
  if (per_index < 5) {
#line 7081
    if (((word >> 17) & 127U) == 127U) {
      {
#line 7082
      tmp___12 = gettext("  Restore stack from frame pointer\n");
#line 7082
      printf((char const   */* __restrict  */)tmp___12);
      }
    } else {
      {
#line 7084
      tmp___13 = gettext("  Stack increment %d\n");
#line 7084
      printf((char const   */* __restrict  */)tmp___13, (word >> 14) & 508U);
      }
    }
    {
#line 7085
    tmp___14 = gettext("  Registers restored: ");
#line 7085
    printf((char const   */* __restrict  */)tmp___14);
    }
#line 7086
    if (per_index == 4) {
      {
#line 7087
      printf((char const   */* __restrict  */)" (compact) ");
      }
    }
    {
#line 7088
    decode_tic6x_unwind_regmask((word >> 4) & 8191U);
#line 7089
    putchar('\n');
#line 7090
    tmp___15 = gettext("  Return register: %s\n");
#line 7090
    printf((char const   */* __restrict  */)tmp___15, tic6x_unwind_regnames[word & 15U]);
    }
  } else {
    {
#line 7094
    tmp___16 = gettext("  [reserved (%d)]\n");
#line 7094
    printf((char const   */* __restrict  */)tmp___16, per_index);
    }
  }
#line 7095
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7098
  tmp___17 = gettext("Unsupported architecture type %d encountered when decoding unwind table");
#line 7098
  error((char const   *)tmp___17, (int )elf_header.e_machine);
  }
  switch_break: /* CIL Label */ ;
  }
#line 7103
  return;
}
}
#line 7105 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_arm_unwind(struct arm_unw_aux_info *aux , Elf_Internal_Shdr *exidx_sec ) 
{ 
  struct arm_section exidx_arm_sec ;
  struct arm_section extab_arm_sec ;
  unsigned int i ;
  unsigned int exidx_len ;
  unsigned int exidx_fn ;
  unsigned int exidx_entry ;
  struct absaddr fn_addr ;
  struct absaddr entry_addr ;
  bfd_vma fn ;
  bfd_boolean tmp___0 ;
  bfd_boolean tmp___1 ;
  char *tmp___2 ;
  bfd_vma table ;
  bfd_vma table_offset ;
  Elf_Internal_Shdr *table_sec ;
  char *tmp___3 ;

  {
  {
#line 7111
  memset((void *)(& exidx_arm_sec), 0, sizeof(exidx_arm_sec));
#line 7112
  memset((void *)(& extab_arm_sec), 0, sizeof(extab_arm_sec));
#line 7113
  exidx_len = (unsigned int )(exidx_sec->sh_size / 8UL);
#line 7115
  i = 0U;
  }
  {
#line 7115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7115
    if (! (i < exidx_len)) {
#line 7115
      goto while_break;
    }
    {
#line 7121
    fputc('\n', stdout);
#line 7123
    tmp___0 = get_unwind_section_word(aux, & exidx_arm_sec, exidx_sec, (bfd_vma )(8U * i),
                                      & exidx_fn, & fn_addr, (bfd_vma *)((void *)0));
    }
#line 7123
    if (tmp___0) {
      {
#line 7123
      tmp___1 = get_unwind_section_word(aux, & exidx_arm_sec, exidx_sec, (bfd_vma )(8U * i + 4U),
                                        & exidx_entry, & entry_addr, (bfd_vma *)((void *)0));
      }
#line 7123
      if (! tmp___1) {
        {
#line 7128
        arm_free_section(& exidx_arm_sec);
#line 7129
        arm_free_section(& extab_arm_sec);
        }
#line 7130
        return;
      }
    } else {
      {
#line 7128
      arm_free_section(& exidx_arm_sec);
#line 7129
      arm_free_section(& extab_arm_sec);
      }
#line 7130
      return;
    }
#line 7136
    if (exidx_fn & 2147483648U) {
      {
#line 7137
      tmp___2 = gettext("corrupt index table entry: %x\n");
#line 7137
      warn((char const   *)tmp___2, exidx_fn);
      }
    }
    {
#line 7139
    fn = arm_expand_prel31((bfd_vma )exidx_fn, exidx_sec->sh_addr + (bfd_vma )(8U * i));
#line 7141
    arm_print_vma_and_name(aux, fn, fn_addr);
#line 7142
    fputs((char const   */* __restrict  */)": ", (FILE */* __restrict  */)stdout);
    }
#line 7144
    if (exidx_entry == 1U) {
      {
#line 7146
      print_vma((bfd_vma )exidx_entry, (print_mode )4);
#line 7147
      fputs((char const   */* __restrict  */)" [cantunwind]\n", (FILE */* __restrict  */)stdout);
      }
    } else
#line 7149
    if (exidx_entry & 2147483648U) {
      {
#line 7151
      print_vma((bfd_vma )exidx_entry, (print_mode )4);
#line 7152
      fputc('\n', stdout);
#line 7153
      decode_arm_unwind(aux, exidx_entry, 4U, (bfd_vma )0, (Elf_Internal_Shdr *)((void *)0),
                        (struct arm_section *)((void *)0));
      }
    } else {
      {
#line 7157
      table_offset = (bfd_vma )0;
#line 7160
      fputs((char const   */* __restrict  */)"@", (FILE */* __restrict  */)stdout);
#line 7161
      table = arm_expand_prel31((bfd_vma )exidx_entry, (exidx_sec->sh_addr + (bfd_vma )(8U * i)) + 4UL);
#line 7162
      print_vma(table, (print_mode )4);
#line 7163
      printf((char const   */* __restrict  */)"\n");
      }
#line 7166
      if ((int )entry_addr.section != 0) {
#line 7166
        if ((unsigned int )entry_addr.section < elf_header.e_shnum) {
#line 7169
          table_sec = section_headers + (int )entry_addr.section;
#line 7170
          table_offset = entry_addr.offset;
        } else {
#line 7166
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 7174
        table_sec = find_section_by_address(table);
        }
#line 7175
        if ((unsigned long )table_sec != (unsigned long )((void *)0)) {
#line 7176
          table_offset = table - table_sec->sh_addr;
        }
      }
#line 7178
      if ((unsigned long )table_sec == (unsigned long )((void *)0)) {
        {
#line 7180
        tmp___3 = gettext("Could not locate .ARM.extab section containing 0x%lx.\n");
#line 7180
        warn((char const   *)tmp___3, table);
        }
#line 7182
        goto __Cont;
      }
      {
#line 7184
      decode_arm_unwind(aux, 0U, 0U, table_offset, table_sec, & extab_arm_sec);
      }
    }
    __Cont: /* CIL Label */ 
#line 7115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7189
  printf((char const   */* __restrict  */)"\n");
#line 7191
  arm_free_section(& exidx_arm_sec);
#line 7192
  arm_free_section(& extab_arm_sec);
  }
#line 7193
  return;
}
}
#line 7197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void arm_process_unwind(FILE *file ) 
{ 
  struct arm_unw_aux_info aux ;
  Elf_Internal_Shdr *unwsec ;
  Elf_Internal_Shdr *strsec ;
  Elf_Internal_Shdr *sec ;
  unsigned long i ;
  unsigned int sec_type ;
  char *tmp___0 ;
  Elf_Internal_Sym *tmp___1 ;
  Elf_Internal_Sym *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 7201
  unwsec = (Elf_Internal_Shdr *)((void *)0);
  {
#line 7209
  if ((int )elf_header.e_machine == 40) {
#line 7209
    goto case_40;
  }
#line 7213
  if ((int )elf_header.e_machine == 140) {
#line 7213
    goto case_140;
  }
#line 7217
  goto switch_default;
  case_40: /* CIL Label */ 
#line 7210
  sec_type = 1879048193U;
#line 7211
  goto switch_break;
  case_140: /* CIL Label */ 
#line 7214
  sec_type = 1879048193U;
#line 7215
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7218
  tmp___0 = gettext("Unsupported architecture type %d encountered when processing unwind table");
#line 7218
  error((char const   *)tmp___0, (int )elf_header.e_machine);
  }
#line 7220
  return;
  switch_break: /* CIL Label */ ;
  }
#line 7223
  if ((unsigned long )string_table == (unsigned long )((void *)0)) {
#line 7224
    return;
  }
  {
#line 7226
  memset((void *)(& aux), 0, sizeof(aux));
#line 7227
  aux.file = file;
#line 7229
  i = 0UL;
#line 7229
  sec = section_headers;
  }
  {
#line 7229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7229
    if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 7229
      goto while_break;
    }
#line 7231
    if (sec->sh_type == 2U) {
#line 7231
      if (sec->sh_link < elf_header.e_shnum) {
#line 7233
        if (is_32bit_elf) {
          {
#line 7233
          tmp___1 = get_32bit_elf_symbols(file, sec, & aux.nsyms);
#line 7233
          aux.symtab = tmp___1;
          }
        } else {
          {
#line 7233
          tmp___2 = get_64bit_elf_symbols(file, sec, & aux.nsyms);
#line 7233
          aux.symtab = tmp___2;
          }
        }
#line 7235
        strsec = section_headers + sec->sh_link;
#line 7236
        if (! ((unsigned long )aux.strtab == (unsigned long )((void *)0))) {
          {
#line 7236
          __assert_fail("aux.strtab == NULL", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                        7236U, "arm_process_unwind");
          }
        }
        {
#line 7237
        tmp___3 = gettext("string table");
#line 7237
        tmp___4 = get_data((void *)0, file, strsec->sh_offset, (size_t )1, strsec->sh_size,
                           (char const   *)tmp___3);
#line 7237
        aux.strtab = (char *)tmp___4;
        }
#line 7239
        if ((unsigned long )aux.strtab != (unsigned long )((void *)0)) {
#line 7239
          aux.strtab_size = strsec->sh_size;
        } else {
#line 7239
          aux.strtab_size = 0UL;
        }
      } else {
#line 7231
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 7241
    if (sec->sh_type == sec_type) {
#line 7242
      unwsec = sec;
    }
#line 7229
    i ++;
#line 7229
    sec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7245
  if ((unsigned long )unwsec == (unsigned long )((void *)0)) {
    {
#line 7246
    tmp___5 = gettext("\nThere are no unwind sections in this file.\n");
#line 7246
    printf((char const   */* __restrict  */)tmp___5);
    }
  } else {
#line 7248
    i = 0UL;
#line 7248
    sec = section_headers;
    {
#line 7248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7248
      if (! (i < (unsigned long )elf_header.e_shnum)) {
#line 7248
        goto while_break___0;
      }
#line 7250
      if (sec->sh_type == sec_type) {
#line 7252
        if ((unsigned long )sec == (unsigned long )((void *)0)) {
          {
#line 7252
          tmp___6 = gettext("<none>");
#line 7252
          tmp___11 = tmp___6;
          }
        } else {
#line 7252
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 7252
            tmp___7 = gettext("<no-name>");
#line 7252
            tmp___10 = tmp___7;
            }
          } else {
#line 7252
            if ((unsigned long )sec->sh_name >= string_table_length) {
              {
#line 7252
              tmp___8 = gettext("<corrupt>");
#line 7252
              tmp___9 = tmp___8;
              }
            } else {
#line 7252
              tmp___9 = string_table + sec->sh_name;
            }
#line 7252
            tmp___10 = tmp___9;
          }
#line 7252
          tmp___11 = tmp___10;
        }
        {
#line 7252
        tmp___12 = gettext("\nUnwind table index \'%s\' at offset 0x%lx contains %lu entries:\n");
#line 7252
        printf((char const   */* __restrict  */)tmp___12, tmp___11, (unsigned long )sec->sh_offset,
               sec->sh_size / (bfd_size_type )(2 * eh_addr_size));
#line 7257
        dump_arm_unwind(& aux, sec);
        }
      }
#line 7248
      i ++;
#line 7248
      sec ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 7261
  if (aux.symtab) {
    {
#line 7262
    free((void *)aux.symtab);
    }
  }
#line 7263
  if (aux.strtab) {
    {
#line 7264
    free((void *)aux.strtab);
    }
  }
#line 7265
  return;
}
}
#line 7267 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void process_unwind(FILE *file ) 
{ 
  struct unwind_handler handlers[5] ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 7270
  handlers[0].machtype = 40;
#line 7270
  handlers[0].handler = & arm_process_unwind;
#line 7270
  handlers[1].machtype = 50;
#line 7270
  handlers[1].handler = & ia64_process_unwind;
#line 7270
  handlers[2].machtype = 15;
#line 7270
  handlers[2].handler = & hppa_process_unwind;
#line 7270
  handlers[3].machtype = 140;
#line 7270
  handlers[3].handler = & arm_process_unwind;
#line 7270
  handlers[4].machtype = 0;
#line 7270
  handlers[4].handler = (void (*)(FILE * ))0;
#line 7284
  if (! do_unwind) {
#line 7285
    return;
  }
#line 7287
  i = 0;
  {
#line 7287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7287
    if (! ((unsigned long )handlers[i].handler != (unsigned long )((void *)0))) {
#line 7287
      goto while_break;
    }
#line 7288
    if ((int )elf_header.e_machine == handlers[i].machtype) {
      {
#line 7289
      (*(handlers[i].handler))(file);
      }
#line 7289
      return;
    }
#line 7287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7291
  tmp___0 = get_machine_name((unsigned int )elf_header.e_machine);
#line 7291
  tmp___1 = gettext("\nThe decoding of unwind sections for machine type %s is not currently supported.\n");
#line 7291
  printf((char const   */* __restrict  */)tmp___1, tmp___0);
  }
#line 7293
  return;
}
}
#line 7305
static void dynamic_section_mips_val(Elf_Internal_Dyn *entry ) ;
#line 7305 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *opts[15]  = 
#line 7305
  {      "QUICKSTART",      "NOTPOT",      "NO_LIBRARY_REPLACEMENT",      "NO_MOVE", 
        "SGI_ONLY",      "GUARANTEE_INIT",      "DELTA_C_PLUS_PLUS",      "GUARANTEE_START_INIT", 
        "PIXIE",      "DEFAULT_DELAY_LOAD",      "REQUICKSTART",      "REQUICKSTARTED", 
        "CORD",      "NO_UNRES_UNDEF",      "RLD_ORDER_SAFE"};
#line 7295 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dynamic_section_mips_val(Elf_Internal_Dyn *entry ) 
{ 
  char *tmp___0 ;
  unsigned int cnt ;
  int first ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char timebuf[20] ;
  struct tm *tmp___4 ;
  time_t atime ;
  char *tmp___5 ;

  {
  {
#line 7300
  if (entry->d_tag == 1879048197UL) {
#line 7300
    goto case_1879048197;
  }
#line 7325
  if (entry->d_tag == 1879048196UL) {
#line 7325
    goto case_1879048196;
  }
#line 7332
  if (entry->d_tag == 1879048194UL) {
#line 7332
    goto case_1879048194;
  }
#line 7358
  if (entry->d_tag == 1879048239UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048225UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048222UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048220UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048218UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048216UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048212UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048210UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048209UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048208UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048203UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048202UL) {
#line 7358
    goto case_1879048239;
  }
#line 7358
  if (entry->d_tag == 1879048193UL) {
#line 7358
    goto case_1879048239;
  }
#line 7362
  goto switch_default;
  case_1879048197: /* CIL Label */ 
#line 7301
  if (entry->d_un.d_val == 0UL) {
    {
#line 7302
    tmp___0 = gettext("NONE");
#line 7302
    printf((char const   */* __restrict  */)tmp___0);
    }
  } else {
#line 7314
    first = 1;
#line 7316
    cnt = 0U;
    {
#line 7316
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7316
      if (! ((unsigned long )cnt < sizeof(opts) / sizeof(opts[0]))) {
#line 7316
        goto while_break;
      }
#line 7317
      if (entry->d_un.d_val & (unsigned long )(1 << cnt)) {
#line 7319
        if (first) {
#line 7319
          tmp___1 = "";
        } else {
#line 7319
          tmp___1 = " ";
        }
        {
#line 7319
        printf((char const   */* __restrict  */)"%s%s", tmp___1, opts[cnt]);
#line 7320
        first = 0;
        }
      }
#line 7316
      cnt ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 7323
  goto switch_break;
  case_1879048196: /* CIL Label */ 
#line 7326
  if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 7326
    if (entry->d_un.d_val < dynamic_strings_length) {
      {
#line 7327
      tmp___2 = gettext("Interface Version: %s");
#line 7327
      printf((char const   */* __restrict  */)tmp___2, dynamic_strings + entry->d_un.d_val);
      }
    } else {
      {
#line 7329
      tmp___3 = gettext("<corrupt: %ld>");
#line 7329
      printf((char const   */* __restrict  */)tmp___3, entry->d_un.d_ptr);
      }
    }
  } else {
    {
#line 7329
    tmp___3 = gettext("<corrupt: %ld>");
#line 7329
    printf((char const   */* __restrict  */)tmp___3, entry->d_un.d_ptr);
    }
  }
#line 7330
  goto switch_break;
  case_1879048194: /* CIL Label */ 
  {
#line 7337
  atime = (time_t )entry->d_un.d_val;
#line 7338
  tmp___4 = gmtime((time_t const   *)(& atime));
#line 7339
  snprintf((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u",
           tmp___4->tm_year + 1900, tmp___4->tm_mon + 1, tmp___4->tm_mday, tmp___4->tm_hour,
           tmp___4->tm_min, tmp___4->tm_sec);
#line 7342
  tmp___5 = gettext("Time Stamp: %s");
#line 7342
  printf((char const   */* __restrict  */)tmp___5, timebuf);
  }
#line 7344
  goto switch_break;
  case_1879048239: /* CIL Label */ 
  case_1879048225: /* CIL Label */ 
  case_1879048222: /* CIL Label */ 
  case_1879048220: /* CIL Label */ 
  case_1879048218: /* CIL Label */ 
  case_1879048216: /* CIL Label */ 
  case_1879048212: /* CIL Label */ 
  case_1879048210: /* CIL Label */ 
  case_1879048209: /* CIL Label */ 
  case_1879048208: /* CIL Label */ 
  case_1879048203: /* CIL Label */ 
  case_1879048202: /* CIL Label */ 
  case_1879048193: /* CIL Label */ 
  {
#line 7359
  print_vma(entry->d_un.d_ptr, (print_mode )1);
  }
#line 7360
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7363
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 7365
  putchar('\n');
  }
#line 7366
  return;
}
}
#line 7375
static void dynamic_section_parisc_val(Elf_Internal_Dyn *entry ) ;
#line 7375 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct __anonstruct_flags_85572036 flags___0[17]  = 
#line 7375
  {      {1L, "HP_DEBUG_PRIVATE"}, 
        {2L, "HP_DEBUG_CALLBACK"}, 
        {4L, "HP_DEBUG_CALLBACK_BOR"}, 
        {8L, "HP_NO_ENVVAR"}, 
        {16L, "HP_BIND_NOW"}, 
        {32L, "HP_BIND_NONFATAL"}, 
        {64L, "HP_BIND_VERBOSE"}, 
        {128L, "HP_BIND_RESTRICTED"}, 
        {256L, "HP_BIND_SYMBOLIC"}, 
        {512L, "HP_RPATH_FIRST"}, 
        {1024L, "HP_BIND_DEPTH_FIRST"}, 
        {2048L, "HP_GST"}, 
        {4096L, "HP_SHLIB_FIXED"}, 
        {8192L, "HP_MERGE_SHLIB_SEG"}, 
        {16384L, "HP_NODELETE"}, 
        {32768L, "HP_GROUP"}, 
        {65536L, "HP_PROTECT_LINKAGE_TABLE"}};
#line 7368 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dynamic_section_parisc_val(Elf_Internal_Dyn *entry ) 
{ 
  int first ;
  size_t cnt ;
  bfd_vma val ;

  {
  {
#line 7373
  if (entry->d_tag == 1610612737UL) {
#line 7373
    goto case_1610612737;
  }
#line 7423
  goto switch_default;
  case_1610612737: /* CIL Label */ 
#line 7400
  first = 1;
#line 7402
  val = entry->d_un.d_val;
#line 7404
  cnt = (size_t )0;
  {
#line 7404
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7404
    if (! (cnt < sizeof(flags___0) / sizeof(flags___0[0]))) {
#line 7404
      goto while_break;
    }
#line 7405
    if (val & (unsigned long )flags___0[cnt].bit) {
#line 7407
      if (! first) {
        {
#line 7408
        putchar(' ');
        }
      }
      {
#line 7409
      fputs((char const   */* __restrict  */)flags___0[cnt].str, (FILE */* __restrict  */)stdout);
#line 7410
      first = 0;
#line 7411
      val ^= (unsigned long )flags___0[cnt].bit;
      }
    }
#line 7404
    cnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 7414
  if (val != 0UL) {
#line 7414
    goto _L;
  } else
#line 7414
  if (first) {
    _L: /* CIL Label */ 
#line 7416
    if (! first) {
      {
#line 7417
      putchar(' ');
      }
    }
    {
#line 7418
    print_vma(val, (print_mode )0);
    }
  }
#line 7421
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7424
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
#line 7425
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 7427
  putchar('\n');
  }
#line 7428
  return;
}
}
#line 7439 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void print_vms_time(bfd_int64_t vmstime ) 
{ 
  struct tm *tm ;
  time_t unxtime ;

  {
  {
#line 7445
  unxtime = (time_t )(((long long )vmstime - 35067168000000000LL) / 10000000LL);
#line 7446
  tm = gmtime((time_t const   *)(& unxtime));
#line 7447
  printf((char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u", tm->tm_year + 1900,
         tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
  }
#line 7450
  return;
}
}
#line 7453 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dynamic_section_ia64_val(Elf_Internal_Dyn *entry ) 
{ 


  {
  {
#line 7458
  if (entry->d_tag == 1879048192UL) {
#line 7458
    goto case_1879048192;
  }
#line 7465
  if (entry->d_tag == 1610612789UL) {
#line 7465
    goto case_1610612789;
  }
#line 7471
  if (entry->d_tag == 1610612757UL) {
#line 7471
    goto case_1610612757;
  }
#line 7505
  goto switch_default;
  case_1879048192: /* CIL Label */ 
  {
#line 7460
  print_vma(entry->d_un.d_ptr, (print_mode )4);
#line 7461
  printf((char const   */* __restrict  */)" -- ");
#line 7462
  print_vma(entry->d_un.d_ptr + 24UL, (print_mode )4);
  }
#line 7463
  goto switch_break;
  case_1610612789: /* CIL Label */ 
  {
#line 7467
  print_vms_time((bfd_int64_t )entry->d_un.d_val);
  }
#line 7469
  goto switch_break;
  case_1610612757: /* CIL Label */ 
  {
#line 7472
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
#line 7473
  if (entry->d_un.d_val & 1UL) {
    {
#line 7474
    printf((char const   */* __restrict  */)" CALL_DEBUG");
    }
  }
#line 7475
  if (entry->d_un.d_val & 2UL) {
    {
#line 7476
    printf((char const   */* __restrict  */)" NOP0BUFS");
    }
  }
#line 7477
  if (entry->d_un.d_val & 4UL) {
    {
#line 7478
    printf((char const   */* __restrict  */)" P0IMAGE");
    }
  }
#line 7479
  if (entry->d_un.d_val & 8UL) {
    {
#line 7480
    printf((char const   */* __restrict  */)" MKTHREADS");
    }
  }
#line 7481
  if (entry->d_un.d_val & 16UL) {
    {
#line 7482
    printf((char const   */* __restrict  */)" UPCALLS");
    }
  }
#line 7483
  if (entry->d_un.d_val & 32UL) {
    {
#line 7484
    printf((char const   */* __restrict  */)" IMGSTA");
    }
  }
#line 7485
  if (entry->d_un.d_val & 64UL) {
    {
#line 7486
    printf((char const   */* __restrict  */)" INITIALIZE");
    }
  }
#line 7487
  if (entry->d_un.d_val & 128UL) {
    {
#line 7488
    printf((char const   */* __restrict  */)" MAIN");
    }
  }
#line 7489
  if (entry->d_un.d_val & 512UL) {
    {
#line 7490
    printf((char const   */* __restrict  */)" EXE_INIT");
    }
  }
#line 7491
  if (entry->d_un.d_val & 1024UL) {
    {
#line 7492
    printf((char const   */* __restrict  */)" TBK_IN_IMG");
    }
  }
#line 7493
  if (entry->d_un.d_val & 2048UL) {
    {
#line 7494
    printf((char const   */* __restrict  */)" DBG_IN_IMG");
    }
  }
#line 7495
  if (entry->d_un.d_val & 4096UL) {
    {
#line 7496
    printf((char const   */* __restrict  */)" TBK_IN_DSF");
    }
  }
#line 7497
  if (entry->d_un.d_val & 8192UL) {
    {
#line 7498
    printf((char const   */* __restrict  */)" DBG_IN_DSF");
    }
  }
#line 7499
  if (entry->d_un.d_val & 16384UL) {
    {
#line 7500
    printf((char const   */* __restrict  */)" SIGNATURES");
    }
  }
#line 7501
  if (entry->d_un.d_val & 32768UL) {
    {
#line 7502
    printf((char const   */* __restrict  */)" REL_SEG_OFF");
    }
  }
#line 7503
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 7506
  print_vma(entry->d_un.d_ptr, (print_mode )4);
  }
#line 7507
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 7509
  putchar('\n');
  }
#line 7510
  return;
}
}
#line 7512 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_32bit_dynamic_section(FILE *file ) 
{ 
  Elf32_External_Dyn *edyn ;
  Elf32_External_Dyn *ext ;
  Elf_Internal_Dyn *entry ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;

  {
  {
#line 7519
  tmp___0 = gettext("dynamic section");
#line 7519
  tmp___1 = get_data((void *)0, file, (long )dynamic_addr, (size_t )1, dynamic_size,
                     (char const   *)tmp___0);
#line 7519
  edyn = (Elf32_External_Dyn *)tmp___1;
  }
#line 7521
  if (! edyn) {
#line 7522
    return (0);
  }
#line 7527
  ext = edyn;
#line 7527
  dynamic_nent = 0U;
  {
#line 7527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7527
    if (! ((unsigned long )((char *)ext) < (unsigned long )((char *)edyn + dynamic_size))) {
#line 7527
      goto while_break;
    }
    {
#line 7531
    dynamic_nent ++;
#line 7532
    tmp___2 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
    }
#line 7532
    if (tmp___2 == 0ULL) {
#line 7533
      goto while_break;
    }
#line 7527
    ext ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7536
  tmp___3 = cmalloc((size_t )dynamic_nent, sizeof(*entry));
#line 7536
  dynamic_section = (Elf_Internal_Dyn *)tmp___3;
  }
#line 7538
  if ((unsigned long )dynamic_section == (unsigned long )((void *)0)) {
    {
#line 7540
    tmp___4 = gettext("Out of memory\n");
#line 7540
    error((char const   *)tmp___4);
#line 7541
    free((void *)edyn);
    }
#line 7542
    return (0);
  }
#line 7545
  ext = edyn;
#line 7545
  entry = dynamic_section;
  {
#line 7545
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7545
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7545
      goto while_break___0;
    }
    {
#line 7549
    tmp___5 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
#line 7549
    entry->d_tag = (bfd_vma )tmp___5;
#line 7550
    tmp___6 = (*byte_get)(ext->d_un.d_val, (int )sizeof(ext->d_un.d_val));
#line 7550
    entry->d_un.d_val = (bfd_vma )tmp___6;
#line 7545
    ext ++;
#line 7545
    entry ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7553
  free((void *)edyn);
  }
#line 7555
  return (1);
}
}
#line 7558 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_64bit_dynamic_section(FILE *file ) 
{ 
  Elf64_External_Dyn *edyn ;
  Elf64_External_Dyn *ext ;
  Elf_Internal_Dyn *entry ;
  char *tmp___0 ;
  void *tmp___1 ;
  elf_vma tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;

  {
  {
#line 7565
  tmp___0 = gettext("dynamic section");
#line 7565
  tmp___1 = get_data((void *)0, file, (long )dynamic_addr, (size_t )1, dynamic_size,
                     (char const   *)tmp___0);
#line 7565
  edyn = (Elf64_External_Dyn *)tmp___1;
  }
#line 7567
  if (! edyn) {
#line 7568
    return (0);
  }
#line 7573
  ext = edyn;
#line 7573
  dynamic_nent = 0U;
  {
#line 7573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7573
    if (! ((unsigned long )((char *)ext) < (unsigned long )((char *)edyn + dynamic_size))) {
#line 7573
      goto while_break;
    }
    {
#line 7577
    dynamic_nent ++;
#line 7578
    tmp___2 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
    }
#line 7578
    if (tmp___2 == 0ULL) {
#line 7579
      goto while_break;
    }
#line 7573
    ext ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7582
  tmp___3 = cmalloc((size_t )dynamic_nent, sizeof(*entry));
#line 7582
  dynamic_section = (Elf_Internal_Dyn *)tmp___3;
  }
#line 7584
  if ((unsigned long )dynamic_section == (unsigned long )((void *)0)) {
    {
#line 7586
    tmp___4 = gettext("Out of memory\n");
#line 7586
    error((char const   *)tmp___4);
#line 7587
    free((void *)edyn);
    }
#line 7588
    return (0);
  }
#line 7591
  ext = edyn;
#line 7591
  entry = dynamic_section;
  {
#line 7591
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 7591
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7591
      goto while_break___0;
    }
    {
#line 7595
    tmp___5 = (*byte_get)(ext->d_tag, (int )sizeof(ext->d_tag));
#line 7595
    entry->d_tag = (bfd_vma )tmp___5;
#line 7596
    tmp___6 = (*byte_get)(ext->d_un.d_val, (int )sizeof(ext->d_un.d_val));
#line 7596
    entry->d_un.d_val = (bfd_vma )tmp___6;
#line 7591
    ext ++;
#line 7591
    entry ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 7599
  free((void *)edyn);
  }
#line 7601
  return (1);
}
}
#line 7604 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void print_dynamic_flags(bfd_vma flags___1 ) 
{ 
  int first ;
  bfd_vma flag ;
  char *tmp___0 ;

  {
#line 7607
  first = 1;
  {
#line 7609
  while (1) {
    while_continue: /* CIL Label */ ;
#line 7609
    if (! flags___1) {
#line 7609
      goto while_break;
    }
#line 7613
    flag = flags___1 & - flags___1;
#line 7614
    flags___1 &= ~ flag;
#line 7616
    if (first) {
#line 7617
      first = 0;
    } else {
      {
#line 7619
      _IO_putc(' ', stdout);
      }
    }
    {
#line 7623
    if (flag == 1UL) {
#line 7623
      goto case_1;
    }
#line 7624
    if (flag == (bfd_vma )(1 << 1)) {
#line 7624
      goto case_exp;
    }
#line 7625
    if (flag == (bfd_vma )(1 << 2)) {
#line 7625
      goto case_exp___0;
    }
#line 7626
    if (flag == (bfd_vma )(1 << 3)) {
#line 7626
      goto case_exp___1;
    }
#line 7627
    if (flag == (bfd_vma )(1 << 4)) {
#line 7627
      goto case_exp___2;
    }
#line 7628
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 7623
    fputs((char const   */* __restrict  */)"ORIGIN", (FILE */* __restrict  */)stdout);
    }
#line 7623
    goto switch_break;
    case_exp: /* CIL Label */ 
    {
#line 7624
    fputs((char const   */* __restrict  */)"SYMBOLIC", (FILE */* __restrict  */)stdout);
    }
#line 7624
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    {
#line 7625
    fputs((char const   */* __restrict  */)"TEXTREL", (FILE */* __restrict  */)stdout);
    }
#line 7625
    goto switch_break;
    case_exp___1: /* CIL Label */ 
    {
#line 7626
    fputs((char const   */* __restrict  */)"BIND_NOW", (FILE */* __restrict  */)stdout);
    }
#line 7626
    goto switch_break;
    case_exp___2: /* CIL Label */ 
    {
#line 7627
    fputs((char const   */* __restrict  */)"STATIC_TLS", (FILE */* __restrict  */)stdout);
    }
#line 7627
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 7628
    tmp___0 = gettext("unknown");
#line 7628
    fputs((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stdout);
    }
#line 7628
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 7631
  puts("");
  }
#line 7632
  return;
}
}
#line 7636 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_dynamic_section(FILE *file ) 
{ 
  Elf_Internal_Dyn *entry ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  Elf_Internal_Shdr section ;
  char *tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  Elf_Internal_Sym *tmp___6 ;
  Elf_Internal_Sym *tmp___7 ;
  char *tmp___8 ;
  unsigned long offset ;
  long str_tab_len ;
  long tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  void *tmp___15 ;
  unsigned long syminsz ;
  long tmp___16 ;
  Elf_External_Syminfo *extsyminfo ;
  Elf_External_Syminfo *extsym ;
  Elf_Internal_Syminfo *syminfo ;
  char *tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char const   *dtype ;
  int tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned long val ;
  char *tmp___34 ;
  char *tmp___35 ;
  unsigned long val___0 ;
  char *tmp___36 ;
  char *tmp___37 ;
  unsigned long val___1 ;
  char const   *tmp___38 ;
  char *name___0 ;
  char *tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *name___1 ;
  char *tmp___46 ;
  struct tm *tmp___47 ;
  time_t atime ;

  {
#line 7641
  if (dynamic_size == 0UL) {
#line 7643
    if (do_dynamic) {
      {
#line 7644
      tmp___0 = gettext("\nThere is no dynamic section in this file.\n");
#line 7644
      printf((char const   */* __restrict  */)tmp___0);
      }
    }
#line 7646
    return (1);
  }
#line 7649
  if (is_32bit_elf) {
    {
#line 7651
    tmp___1 = get_32bit_dynamic_section(file);
    }
#line 7651
    if (! tmp___1) {
#line 7652
      return (0);
    }
  } else {
    {
#line 7654
    tmp___2 = get_64bit_dynamic_section(file);
    }
#line 7654
    if (! tmp___2) {
#line 7655
      return (0);
    }
  }
#line 7658
  if ((unsigned long )dynamic_symbols == (unsigned long )((void *)0)) {
#line 7660
    entry = dynamic_section;
    {
#line 7660
    while (1) {
      while_continue: /* CIL Label */ ;
#line 7660
      if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7660
        goto while_break;
      }
#line 7666
      if (entry->d_tag != 6UL) {
#line 7667
        goto __Cont;
      }
      {
#line 7669
      dynamic_info[6] = entry->d_un.d_val;
#line 7675
      section.sh_offset = offset_from_vma(file, entry->d_un.d_val, (bfd_size_type )0);
      }
#line 7677
      if (archive_file_offset != 0L) {
#line 7678
        section.sh_size = archive_file_size - (unsigned long )section.sh_offset;
      } else {
        {
#line 7681
        tmp___4 = fseek(file, 0L, 2);
        }
#line 7681
        if (tmp___4) {
          {
#line 7682
          tmp___3 = gettext("Unable to seek to end of file!\n");
#line 7682
          error((char const   *)tmp___3);
          }
        }
        {
#line 7684
        tmp___5 = ftell(file);
#line 7684
        section.sh_size = (bfd_size_type )(tmp___5 - section.sh_offset);
        }
      }
#line 7687
      if (is_32bit_elf) {
#line 7688
        section.sh_entsize = sizeof(Elf32_External_Sym );
      } else {
#line 7690
        section.sh_entsize = sizeof(Elf64_External_Sym );
      }
#line 7692
      if (is_32bit_elf) {
        {
#line 7692
        tmp___6 = get_32bit_elf_symbols(file, & section, & num_dynamic_syms);
#line 7692
        dynamic_symbols = tmp___6;
        }
      } else {
        {
#line 7692
        tmp___7 = get_64bit_elf_symbols(file, & section, & num_dynamic_syms);
#line 7692
        dynamic_symbols = tmp___7;
        }
      }
#line 7693
      if (num_dynamic_syms < 1UL) {
        {
#line 7695
        tmp___8 = gettext("Unable to determine the number of symbols to load\n");
#line 7695
        error((char const   *)tmp___8);
        }
#line 7696
        goto __Cont;
      }
      __Cont: /* CIL Label */ 
#line 7660
      entry ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 7702
  if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 7704
    entry = dynamic_section;
    {
#line 7704
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 7704
      if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7704
        goto while_break___0;
      }
#line 7711
      if (entry->d_tag != 5UL) {
#line 7712
        goto __Cont___0;
      }
      {
#line 7714
      dynamic_info[5] = entry->d_un.d_val;
#line 7721
      tmp___9 = offset_from_vma(file, entry->d_un.d_val, (bfd_size_type )0);
#line 7721
      offset = (unsigned long )tmp___9;
      }
#line 7723
      if (archive_file_offset != 0L) {
#line 7724
        str_tab_len = (long )(archive_file_size - offset);
      } else {
        {
#line 7727
        tmp___11 = fseek(file, 0L, 2);
        }
#line 7727
        if (tmp___11) {
          {
#line 7728
          tmp___10 = gettext("Unable to seek to end of file\n");
#line 7728
          error((char const   *)tmp___10);
          }
        }
        {
#line 7729
        tmp___12 = ftell(file);
#line 7729
        str_tab_len = (long )((unsigned long )tmp___12 - offset);
        }
      }
#line 7732
      if (str_tab_len < 1L) {
        {
#line 7734
        tmp___13 = gettext("Unable to determine the length of the dynamic string table\n");
#line 7734
        error((char const   *)tmp___13);
        }
#line 7736
        goto __Cont___0;
      }
      {
#line 7739
      tmp___14 = gettext("dynamic string table");
#line 7739
      tmp___15 = get_data((void *)0, file, (long )offset, (size_t )1, (size_t )str_tab_len,
                          (char const   *)tmp___14);
#line 7739
      dynamic_strings = (char *)tmp___15;
      }
#line 7742
      if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 7742
        dynamic_strings_length = 0UL;
      } else {
#line 7742
        dynamic_strings_length = (unsigned long )str_tab_len;
      }
#line 7743
      goto while_break___0;
      __Cont___0: /* CIL Label */ 
#line 7704
      entry ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 7748
  if ((unsigned long )dynamic_syminfo == (unsigned long )((void *)0)) {
#line 7750
    syminsz = 0UL;
#line 7752
    entry = dynamic_section;
    {
#line 7752
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 7752
      if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7752
        goto while_break___1;
      }
#line 7756
      if (entry->d_tag == 1879047679UL) {
#line 7760
        if (! (sizeof(Elf_External_Syminfo ) == entry->d_un.d_val)) {
          {
#line 7760
          __assert_fail("sizeof (Elf_External_Syminfo) == entry->d_un.d_val", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                        7760U, "process_dynamic_section");
          }
        }
      } else
#line 7762
      if (entry->d_tag == 1879047678UL) {
#line 7763
        syminsz = entry->d_un.d_val;
      } else
#line 7764
      if (entry->d_tag == 1879047935UL) {
        {
#line 7765
        tmp___16 = offset_from_vma(file, entry->d_un.d_val, syminsz);
#line 7765
        dynamic_syminfo_offset = (unsigned long )tmp___16;
        }
      }
#line 7752
      entry ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 7769
    if (dynamic_syminfo_offset != 0UL) {
#line 7769
      if (syminsz != 0UL) {
        {
#line 7776
        tmp___17 = gettext("symbol information");
#line 7776
        tmp___18 = get_data((void *)0, file, (long )dynamic_syminfo_offset, (size_t )1,
                            syminsz, (char const   *)tmp___17);
#line 7776
        extsyminfo = (Elf_External_Syminfo *)tmp___18;
        }
#line 7779
        if (! extsyminfo) {
#line 7780
          return (0);
        }
        {
#line 7782
        tmp___19 = malloc(syminsz);
#line 7782
        dynamic_syminfo = (Elf_Internal_Syminfo *)tmp___19;
        }
#line 7783
        if ((unsigned long )dynamic_syminfo == (unsigned long )((void *)0)) {
          {
#line 7785
          tmp___20 = gettext("Out of memory\n");
#line 7785
          error((char const   *)tmp___20);
          }
#line 7786
          return (0);
        }
#line 7789
        dynamic_syminfo_nent = (unsigned int )(syminsz / sizeof(Elf_External_Syminfo ));
#line 7790
        syminfo = dynamic_syminfo;
#line 7790
        extsym = extsyminfo;
        {
#line 7790
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 7790
          if (! ((unsigned long )syminfo < (unsigned long )(dynamic_syminfo + dynamic_syminfo_nent))) {
#line 7790
            goto while_break___2;
          }
          {
#line 7794
          tmp___21 = (*byte_get)(extsym->si_boundto, (int )sizeof(extsym->si_boundto));
#line 7794
          syminfo->si_boundto = (unsigned short )tmp___21;
#line 7795
          tmp___22 = (*byte_get)(extsym->si_flags, (int )sizeof(extsym->si_flags));
#line 7795
          syminfo->si_flags = (unsigned short )tmp___22;
#line 7790
          syminfo ++;
#line 7790
          extsym ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 7798
        free((void *)extsyminfo);
        }
      }
    }
  }
#line 7802
  if (do_dynamic) {
#line 7802
    if (dynamic_addr) {
      {
#line 7803
      tmp___23 = gettext("\nDynamic section at offset 0x%lx contains %u entries:\n");
#line 7803
      printf((char const   */* __restrict  */)tmp___23, dynamic_addr, dynamic_nent);
      }
    }
  }
#line 7805
  if (do_dynamic) {
    {
#line 7806
    tmp___24 = gettext("  Tag        Type                         Name/Value\n");
#line 7806
    printf((char const   */* __restrict  */)tmp___24);
    }
  }
#line 7808
  entry = dynamic_section;
  {
#line 7808
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 7808
    if (! ((unsigned long )entry < (unsigned long )(dynamic_section + dynamic_nent))) {
#line 7808
      goto while_break___3;
    }
#line 7812
    if (do_dynamic) {
      {
#line 7816
      putchar(' ');
#line 7817
      print_vma(entry->d_tag, (print_mode )5);
#line 7818
      dtype = get_dynamic_type(entry->d_tag);
      }
#line 7819
      if (is_32bit_elf) {
#line 7819
        tmp___25 = 27;
      } else {
#line 7819
        tmp___25 = 19;
      }
      {
#line 7819
      tmp___26 = strlen(dtype);
#line 7819
      printf((char const   */* __restrict  */)" (%s)%*s", dtype, tmp___25 - (int )tmp___26,
             " ");
      }
    }
    {
#line 7827
    if (entry->d_tag == 30UL) {
#line 7827
      goto case_30;
    }
#line 7836
    if (entry->d_tag == 1879047932UL) {
#line 7836
      goto case_1879047932;
    }
#line 7836
    if (entry->d_tag == 1879047931UL) {
#line 7836
      goto case_1879047932;
    }
#line 7836
    if (entry->d_tag == 1879047930UL) {
#line 7836
      goto case_1879047932;
    }
#line 7836
    if (entry->d_tag == 2147483647UL) {
#line 7836
      goto case_1879047932;
    }
#line 7836
    if (entry->d_tag == 2147483645UL) {
#line 7836
      goto case_1879047932;
    }
#line 7873
    if (entry->d_tag == 1879047676UL) {
#line 7873
      goto case_1879047676;
    }
#line 7901
    if (entry->d_tag == 1879047677UL) {
#line 7901
      goto case_1879047677;
    }
#line 7929
    if (entry->d_tag == 1879048187UL) {
#line 7929
      goto case_1879048187;
    }
#line 8016
    if (entry->d_tag == 20UL) {
#line 8016
      goto case_20;
    }
#line 8038
    if (entry->d_tag == 29UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 23UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 22UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 21UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 17UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 16UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 15UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 14UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 13UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 12UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 7UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 6UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 5UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 4UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 3UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 1UL) {
#line 8038
      goto case_29;
    }
#line 8038
    if (entry->d_tag == 0UL) {
#line 8038
      goto case_29;
    }
#line 8091
    if (entry->d_tag == 19UL) {
#line 8091
      goto case_19;
    }
#line 8091
    if (entry->d_tag == 11UL) {
#line 8091
      goto case_19;
    }
#line 8091
    if (entry->d_tag == 9UL) {
#line 8091
      goto case_19;
    }
#line 8091
    if (entry->d_tag == 18UL) {
#line 8091
      goto case_19;
    }
#line 8091
    if (entry->d_tag == 10UL) {
#line 8091
      goto case_19;
    }
#line 8091
    if (entry->d_tag == 8UL) {
#line 8091
      goto case_19;
    }
#line 8091
    if (entry->d_tag == 2UL) {
#line 8091
      goto case_19;
    }
#line 8099
    if (entry->d_tag == 1879047671UL) {
#line 8099
      goto case_1879047671;
    }
#line 8099
    if (entry->d_tag == 1879047670UL) {
#line 8099
      goto case_1879047671;
    }
#line 8099
    if (entry->d_tag == 28UL) {
#line 8099
      goto case_1879047671;
    }
#line 8099
    if (entry->d_tag == 27UL) {
#line 8099
      goto case_1879047671;
    }
#line 8099
    if (entry->d_tag == 1879047675UL) {
#line 8099
      goto case_1879047671;
    }
#line 8099
    if (entry->d_tag == 1879047674UL) {
#line 8099
      goto case_1879047671;
    }
#line 8099
    if (entry->d_tag == 1879047673UL) {
#line 8099
      goto case_1879047671;
    }
#line 8110
    if (entry->d_tag == 1879048186UL) {
#line 8110
      goto case_1879048186;
    }
#line 8110
    if (entry->d_tag == 1879048185UL) {
#line 8110
      goto case_1879048186;
    }
#line 8110
    if (entry->d_tag == 1879048191UL) {
#line 8110
      goto case_1879048186;
    }
#line 8110
    if (entry->d_tag == 1879048189UL) {
#line 8110
      goto case_1879048186;
    }
#line 8123
    if (entry->d_tag == 26UL) {
#line 8123
      goto case_26;
    }
#line 8123
    if (entry->d_tag == 25UL) {
#line 8123
      goto case_26;
    }
#line 8123
    if (entry->d_tag == 2147483646UL) {
#line 8123
      goto case_26;
    }
#line 8123
    if (entry->d_tag == 1879047935UL) {
#line 8123
      goto case_26;
    }
#line 8123
    if (entry->d_tag == 1879047679UL) {
#line 8123
      goto case_26;
    }
#line 8123
    if (entry->d_tag == 1879047678UL) {
#line 8123
      goto case_26;
    }
#line 8143
    if (entry->d_tag == 24UL) {
#line 8143
      goto case_24;
    }
#line 8149
    if (entry->d_tag == 1879047669UL) {
#line 8149
      goto case_1879047669;
    }
#line 8163
    if (entry->d_tag == 1879047925UL) {
#line 8163
      goto case_1879047925;
    }
#line 8172
    goto switch_default___0;
    case_30: /* CIL Label */ 
#line 7828
    if (do_dynamic) {
      {
#line 7829
      print_dynamic_flags(entry->d_un.d_val);
      }
    }
#line 7830
    goto switch_break;
    case_1879047932: /* CIL Label */ 
    case_1879047931: /* CIL Label */ 
    case_1879047930: /* CIL Label */ 
    case_2147483647: /* CIL Label */ 
    case_2147483645: /* CIL Label */ 
#line 7837
    if (do_dynamic) {
      {
#line 7841
      if (entry->d_tag == 2147483645UL) {
#line 7841
        goto case_2147483645___0;
      }
#line 7845
      if (entry->d_tag == 2147483647UL) {
#line 7845
        goto case_2147483647___0;
      }
#line 7849
      if (entry->d_tag == 1879047930UL) {
#line 7849
        goto case_1879047930___0;
      }
#line 7853
      if (entry->d_tag == 1879047931UL) {
#line 7853
        goto case_1879047931___0;
      }
#line 7857
      if (entry->d_tag == 1879047932UL) {
#line 7857
        goto case_1879047932___0;
      }
#line 7839
      goto switch_break___0;
      case_2147483645___0: /* CIL Label */ 
      {
#line 7842
      tmp___27 = gettext("Auxiliary library");
#line 7842
      printf((char const   */* __restrict  */)tmp___27);
      }
#line 7843
      goto switch_break___0;
      case_2147483647___0: /* CIL Label */ 
      {
#line 7846
      tmp___28 = gettext("Filter library");
#line 7846
      printf((char const   */* __restrict  */)tmp___28);
      }
#line 7847
      goto switch_break___0;
      case_1879047930___0: /* CIL Label */ 
      {
#line 7850
      tmp___29 = gettext("Configuration file");
#line 7850
      printf((char const   */* __restrict  */)tmp___29);
      }
#line 7851
      goto switch_break___0;
      case_1879047931___0: /* CIL Label */ 
      {
#line 7854
      tmp___30 = gettext("Dependency audit library");
#line 7854
      printf((char const   */* __restrict  */)tmp___30);
      }
#line 7855
      goto switch_break___0;
      case_1879047932___0: /* CIL Label */ 
      {
#line 7858
      tmp___31 = gettext("Audit library");
#line 7858
      printf((char const   */* __restrict  */)tmp___31);
      }
#line 7859
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 7862
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 7862
        if (entry->d_un.d_val < dynamic_strings_length) {
          {
#line 7863
          printf((char const   */* __restrict  */)": [%s]\n", dynamic_strings + entry->d_un.d_val);
          }
        } else {
          {
#line 7866
          printf((char const   */* __restrict  */)": ");
#line 7867
          print_vma(entry->d_un.d_val, (print_mode )4);
#line 7868
          putchar('\n');
          }
        }
      } else {
        {
#line 7866
        printf((char const   */* __restrict  */)": ");
#line 7867
        print_vma(entry->d_un.d_val, (print_mode )4);
#line 7868
        putchar('\n');
        }
      }
    }
#line 7871
    goto switch_break;
    case_1879047676: /* CIL Label */ 
#line 7874
    if (do_dynamic) {
      {
#line 7876
      tmp___32 = gettext("Flags:");
#line 7876
      printf((char const   */* __restrict  */)tmp___32);
      }
#line 7878
      if (entry->d_un.d_val == 0UL) {
        {
#line 7879
        tmp___33 = gettext(" None\n");
#line 7879
        printf((char const   */* __restrict  */)tmp___33);
        }
      } else {
#line 7882
        val = entry->d_un.d_val;
#line 7884
        if (val & 1UL) {
          {
#line 7886
          printf((char const   */* __restrict  */)" PARINIT");
#line 7887
          val ^= 1UL;
          }
        }
#line 7889
        if (val & 2UL) {
          {
#line 7891
          printf((char const   */* __restrict  */)" CONFEXP");
#line 7892
          val ^= 2UL;
          }
        }
#line 7894
        if (val != 0UL) {
          {
#line 7895
          printf((char const   */* __restrict  */)" %lx", val);
          }
        }
        {
#line 7896
        puts("");
        }
      }
    }
#line 7899
    goto switch_break;
    case_1879047677: /* CIL Label */ 
#line 7902
    if (do_dynamic) {
      {
#line 7904
      tmp___34 = gettext("Flags:");
#line 7904
      printf((char const   */* __restrict  */)tmp___34);
      }
#line 7906
      if (entry->d_un.d_val == 0UL) {
        {
#line 7907
        tmp___35 = gettext(" None\n");
#line 7907
        printf((char const   */* __restrict  */)tmp___35);
        }
      } else {
#line 7910
        val___0 = entry->d_un.d_val;
#line 7912
        if (val___0 & 1UL) {
          {
#line 7914
          printf((char const   */* __restrict  */)" LAZYLOAD");
#line 7915
          val___0 ^= 1UL;
          }
        }
#line 7917
        if (val___0 & 2UL) {
          {
#line 7919
          printf((char const   */* __restrict  */)" GROUPPERM");
#line 7920
          val___0 ^= 2UL;
          }
        }
#line 7922
        if (val___0 != 0UL) {
          {
#line 7923
          printf((char const   */* __restrict  */)" %lx", val___0);
          }
        }
        {
#line 7924
        puts("");
        }
      }
    }
#line 7927
    goto switch_break;
    case_1879048187: /* CIL Label */ 
#line 7930
    if (do_dynamic) {
      {
#line 7932
      tmp___36 = gettext("Flags:");
#line 7932
      printf((char const   */* __restrict  */)tmp___36);
      }
#line 7933
      if (entry->d_un.d_val == 0UL) {
        {
#line 7934
        tmp___37 = gettext(" None\n");
#line 7934
        printf((char const   */* __restrict  */)tmp___37);
        }
      } else {
#line 7937
        val___1 = entry->d_un.d_val;
#line 7939
        if (val___1 & 1UL) {
          {
#line 7941
          printf((char const   */* __restrict  */)" NOW");
#line 7942
          val___1 ^= 1UL;
          }
        }
#line 7944
        if (val___1 & 2UL) {
          {
#line 7946
          printf((char const   */* __restrict  */)" GLOBAL");
#line 7947
          val___1 ^= 2UL;
          }
        }
#line 7949
        if (val___1 & 4UL) {
          {
#line 7951
          printf((char const   */* __restrict  */)" GROUP");
#line 7952
          val___1 ^= 4UL;
          }
        }
#line 7954
        if (val___1 & 8UL) {
          {
#line 7956
          printf((char const   */* __restrict  */)" NODELETE");
#line 7957
          val___1 ^= 8UL;
          }
        }
#line 7959
        if (val___1 & 16UL) {
          {
#line 7961
          printf((char const   */* __restrict  */)" LOADFLTR");
#line 7962
          val___1 ^= 16UL;
          }
        }
#line 7964
        if (val___1 & 32UL) {
          {
#line 7966
          printf((char const   */* __restrict  */)" INITFIRST");
#line 7967
          val___1 ^= 32UL;
          }
        }
#line 7969
        if (val___1 & 64UL) {
          {
#line 7971
          printf((char const   */* __restrict  */)" NOOPEN");
#line 7972
          val___1 ^= 64UL;
          }
        }
#line 7974
        if (val___1 & 128UL) {
          {
#line 7976
          printf((char const   */* __restrict  */)" ORIGIN");
#line 7977
          val___1 ^= 128UL;
          }
        }
#line 7979
        if (val___1 & 256UL) {
          {
#line 7981
          printf((char const   */* __restrict  */)" DIRECT");
#line 7982
          val___1 ^= 256UL;
          }
        }
#line 7984
        if (val___1 & 512UL) {
          {
#line 7986
          printf((char const   */* __restrict  */)" TRANS");
#line 7987
          val___1 ^= 512UL;
          }
        }
#line 7989
        if (val___1 & 1024UL) {
          {
#line 7991
          printf((char const   */* __restrict  */)" INTERPOSE");
#line 7992
          val___1 ^= 1024UL;
          }
        }
#line 7994
        if (val___1 & 2048UL) {
          {
#line 7996
          printf((char const   */* __restrict  */)" NODEFLIB");
#line 7997
          val___1 ^= 2048UL;
          }
        }
#line 7999
        if (val___1 & 4096UL) {
          {
#line 8001
          printf((char const   */* __restrict  */)" NODUMP");
#line 8002
          val___1 ^= 4096UL;
          }
        }
#line 8004
        if (val___1 & 8192UL) {
          {
#line 8006
          printf((char const   */* __restrict  */)" CONLFAT");
#line 8007
          val___1 ^= 8192UL;
          }
        }
#line 8009
        if (val___1 != 0UL) {
          {
#line 8010
          printf((char const   */* __restrict  */)" %lx", val___1);
          }
        }
        {
#line 8011
        puts("");
        }
      }
    }
#line 8014
    goto switch_break;
    case_20: /* CIL Label */ 
#line 8017
    dynamic_info[entry->d_tag] = entry->d_un.d_val;
#line 8018
    if (do_dynamic) {
      {
#line 8019
      tmp___38 = get_dynamic_type(entry->d_un.d_val);
#line 8019
      puts(tmp___38);
      }
    }
#line 8020
    goto switch_break;
    case_29: /* CIL Label */ 
    case_23: /* CIL Label */ 
    case_22: /* CIL Label */ 
    case_21: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_12: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 8039
    dynamic_info[entry->d_tag] = entry->d_un.d_val;
#line 8041
    if (do_dynamic) {
#line 8045
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8045
        if (entry->d_un.d_val < dynamic_strings_length) {
#line 8046
          name___0 = dynamic_strings + entry->d_un.d_val;
        } else {
#line 8048
          name___0 = (char *)((void *)0);
        }
      } else {
#line 8048
        name___0 = (char *)((void *)0);
      }
#line 8050
      if (name___0) {
        {
#line 8054
        if (entry->d_tag == 1UL) {
#line 8054
          goto case_1___0;
        }
#line 8061
        if (entry->d_tag == 14UL) {
#line 8061
          goto case_14___0;
        }
#line 8065
        if (entry->d_tag == 15UL) {
#line 8065
          goto case_15___0;
        }
#line 8069
        if (entry->d_tag == 29UL) {
#line 8069
          goto case_29___0;
        }
#line 8073
        goto switch_default;
        case_1___0: /* CIL Label */ 
        {
#line 8055
        tmp___39 = gettext("Shared library: [%s]");
#line 8055
        printf((char const   */* __restrict  */)tmp___39, name___0);
#line 8057
        tmp___41 = strcmp((char const   *)name___0, (char const   *)(program_interpreter));
        }
#line 8057
        if (tmp___41 == 0) {
          {
#line 8058
          tmp___40 = gettext(" program interpreter");
#line 8058
          printf((char const   */* __restrict  */)tmp___40);
          }
        }
#line 8059
        goto switch_break___1;
        case_14___0: /* CIL Label */ 
        {
#line 8062
        tmp___42 = gettext("Library soname: [%s]");
#line 8062
        printf((char const   */* __restrict  */)tmp___42, name___0);
        }
#line 8063
        goto switch_break___1;
        case_15___0: /* CIL Label */ 
        {
#line 8066
        tmp___43 = gettext("Library rpath: [%s]");
#line 8066
        printf((char const   */* __restrict  */)tmp___43, name___0);
        }
#line 8067
        goto switch_break___1;
        case_29___0: /* CIL Label */ 
        {
#line 8070
        tmp___44 = gettext("Library runpath: [%s]");
#line 8070
        printf((char const   */* __restrict  */)tmp___44, name___0);
        }
#line 8071
        goto switch_break___1;
        switch_default: /* CIL Label */ 
        {
#line 8074
        print_vma(entry->d_un.d_val, (print_mode )4);
        }
#line 8075
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      } else {
        {
#line 8079
        print_vma(entry->d_un.d_val, (print_mode )4);
        }
      }
      {
#line 8081
      putchar('\n');
      }
    }
#line 8083
    goto switch_break;
    case_19: /* CIL Label */ 
    case_11: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_18: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_8: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 8092
    dynamic_info[entry->d_tag] = entry->d_un.d_val;
    case_1879047671: /* CIL Label */ 
    case_1879047670: /* CIL Label */ 
    case_28: /* CIL Label */ 
    case_27: /* CIL Label */ 
    case_1879047675: /* CIL Label */ 
    case_1879047674: /* CIL Label */ 
    case_1879047673: /* CIL Label */ 
#line 8100
    if (do_dynamic) {
      {
#line 8102
      print_vma(entry->d_un.d_val, (print_mode )3);
#line 8103
      tmp___45 = gettext(" (bytes)\n");
#line 8103
      printf((char const   */* __restrict  */)tmp___45);
      }
    }
#line 8105
    goto switch_break;
    case_1879048186: /* CIL Label */ 
    case_1879048185: /* CIL Label */ 
    case_1879048191: /* CIL Label */ 
    case_1879048189: /* CIL Label */ 
#line 8111
    if (do_dynamic) {
      {
#line 8113
      print_vma(entry->d_un.d_val, (print_mode )3);
#line 8114
      putchar('\n');
      }
    }
#line 8116
    goto switch_break;
    case_26: /* CIL Label */ 
    case_25: /* CIL Label */ 
    case_2147483646: /* CIL Label */ 
    case_1879047935: /* CIL Label */ 
    case_1879047679: /* CIL Label */ 
    case_1879047678: /* CIL Label */ 
#line 8124
    if (do_dynamic) {
#line 8126
      if (entry->d_tag == 2147483646UL) {
#line 8126
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8126
          if (entry->d_un.d_val < dynamic_strings_length) {
#line 8129
            name___1 = dynamic_strings + entry->d_un.d_val;
#line 8131
            if (*name___1) {
              {
#line 8133
              tmp___46 = gettext("Not needed object: [%s]\n");
#line 8133
              printf((char const   */* __restrict  */)tmp___46, name___1);
              }
#line 8134
              goto switch_break;
            }
          }
        }
      }
      {
#line 8138
      print_vma(entry->d_un.d_val, (print_mode )4);
#line 8139
      putchar('\n');
      }
    }
#line 8141
    goto switch_break;
    case_24: /* CIL Label */ 
#line 8145
    if (do_dynamic) {
      {
#line 8146
      putchar('\n');
      }
    }
#line 8147
    goto switch_break;
    case_1879047669: /* CIL Label */ 
#line 8150
    if (do_dynamic) {
      {
#line 8153
      atime = (time_t )entry->d_un.d_val;
#line 8155
      tmp___47 = gmtime((time_t const   *)(& atime));
#line 8156
      printf((char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u\n", tmp___47->tm_year + 1900,
             tmp___47->tm_mon + 1, tmp___47->tm_mday, tmp___47->tm_hour, tmp___47->tm_min,
             tmp___47->tm_sec);
      }
    }
#line 8161
    goto switch_break;
    case_1879047925: /* CIL Label */ 
#line 8164
    dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
#line 8165
    if (do_dynamic) {
      {
#line 8167
      print_vma(entry->d_un.d_val, (print_mode )4);
#line 8168
      putchar('\n');
      }
    }
#line 8170
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 8173
    if (entry->d_tag >= 1879048176UL) {
#line 8173
      if (entry->d_tag <= 1879048191UL) {
#line 8174
        version_info[1879048191UL - entry->d_tag] = entry->d_un.d_val;
      }
    }
#line 8177
    if (do_dynamic) {
      {
#line 8182
      if ((int )elf_header.e_machine == 10) {
#line 8182
        goto case_10___0;
      }
#line 8182
      if ((int )elf_header.e_machine == 8) {
#line 8182
        goto case_10___0;
      }
#line 8185
      if ((int )elf_header.e_machine == 15) {
#line 8185
        goto case_15___1;
      }
#line 8188
      if ((int )elf_header.e_machine == 50) {
#line 8188
        goto case_50;
      }
#line 8191
      goto switch_default___1;
      case_10___0: /* CIL Label */ 
      case_8___0: /* CIL Label */ 
      {
#line 8183
      dynamic_section_mips_val(entry);
      }
#line 8184
      goto switch_break___2;
      case_15___1: /* CIL Label */ 
      {
#line 8186
      dynamic_section_parisc_val(entry);
      }
#line 8187
      goto switch_break___2;
      case_50: /* CIL Label */ 
      {
#line 8189
      dynamic_section_ia64_val(entry);
      }
#line 8190
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 8192
      print_vma(entry->d_un.d_val, (print_mode )4);
#line 8193
      putchar('\n');
      }
      switch_break___2: /* CIL Label */ ;
      }
    }
#line 8196
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 7808
    entry ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 8200
  return (1);
}
}
#line 8206 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___10[32]  ;
#line 8203 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *get_ver_flags(unsigned int flags___1 ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 8208
  buff___10[0] = (char)0;
#line 8210
  if (flags___1 == 0U) {
    {
#line 8211
    tmp___0 = gettext("none");
    }
#line 8211
    return (tmp___0);
  }
#line 8213
  if (flags___1 & 1U) {
    {
#line 8214
    strcat((char */* __restrict  */)(buff___10), (char const   */* __restrict  */)"BASE ");
    }
  }
#line 8216
  if (flags___1 & 2U) {
#line 8218
    if (flags___1 & 1U) {
      {
#line 8219
      strcat((char */* __restrict  */)(buff___10), (char const   */* __restrict  */)"| ");
      }
    }
    {
#line 8221
    strcat((char */* __restrict  */)(buff___10), (char const   */* __restrict  */)"WEAK ");
    }
  }
#line 8224
  if (flags___1 & 4U) {
#line 8226
    if (flags___1 & 3U) {
      {
#line 8227
      strcat((char */* __restrict  */)(buff___10), (char const   */* __restrict  */)"| ");
      }
    }
    {
#line 8229
    strcat((char */* __restrict  */)(buff___10), (char const   */* __restrict  */)"INFO ");
    }
  }
#line 8232
  if (flags___1 & 4294967288U) {
    {
#line 8233
    tmp___1 = gettext("| <unknown>");
#line 8233
    strcat((char */* __restrict  */)(buff___10), (char const   */* __restrict  */)tmp___1);
    }
  }
#line 8235
  return (buff___10);
}
}
#line 8240 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_version_sections(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  int found ;
  Elf_External_Verdef *edefs ;
  unsigned int idx___0 ;
  unsigned int cnt ;
  char *endbuf ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  void *tmp___18 ;
  char *vstart ;
  Elf_External_Verdef *edef ;
  Elf_Internal_Verdef ent ;
  Elf_External_Verdaux *eaux ;
  Elf_Internal_Verdaux aux ;
  int j ;
  int isum ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  elf_vma tmp___23 ;
  elf_vma tmp___24 ;
  elf_vma tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  elf_vma tmp___29 ;
  elf_vma tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  elf_vma tmp___33 ;
  elf_vma tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  Elf_External_Verneed *eneed ;
  unsigned int idx___1 ;
  unsigned int cnt___0 ;
  char *endbuf___0 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  void *tmp___57 ;
  Elf_External_Verneed *entry ;
  Elf_Internal_Verneed ent___0 ;
  int j___0 ;
  int isum___0 ;
  char *vstart___0 ;
  elf_vma tmp___58 ;
  elf_vma tmp___59 ;
  elf_vma tmp___60 ;
  elf_vma tmp___61 ;
  elf_vma tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  Elf_External_Vernaux *eaux___0 ;
  Elf_Internal_Vernaux aux___0 ;
  elf_vma tmp___67 ;
  elf_vma tmp___68 ;
  elf_vma tmp___69 ;
  elf_vma tmp___70 ;
  elf_vma tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  Elf_Internal_Shdr *link_section ;
  int total ;
  int cnt___1 ;
  unsigned char *edata ;
  unsigned short *data ;
  char *strtab ;
  Elf_Internal_Sym *symbols ;
  Elf_Internal_Shdr *string_sec ;
  unsigned long num_syms ;
  long off ;
  Elf_Internal_Sym *tmp___78 ;
  Elf_Internal_Sym *tmp___79 ;
  char *tmp___80 ;
  void *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  char *tmp___84 ;
  char *tmp___85 ;
  char *tmp___86 ;
  char *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  void *tmp___98 ;
  void *tmp___99 ;
  elf_vma tmp___100 ;
  int tmp___101 ;
  int j___1 ;
  int nn ;
  int check_def ;
  int check_need ;
  char *name___0 ;
  char *tmp___102 ;
  char *tmp___103 ;
  int tmp___104 ;
  char *tmp___105 ;
  Elf_Internal_Verneed ivn ;
  unsigned long offset ;
  long tmp___106 ;
  Elf_Internal_Vernaux ivna ;
  Elf_External_Verneed evn ;
  Elf_External_Vernaux evna ;
  unsigned long a_off ;
  char *tmp___107 ;
  void *tmp___108 ;
  elf_vma tmp___109 ;
  elf_vma tmp___110 ;
  elf_vma tmp___111 ;
  elf_vma tmp___112 ;
  char *tmp___113 ;
  void *tmp___114 ;
  elf_vma tmp___115 ;
  size_t tmp___116 ;
  int tmp___117 ;
  Elf_Internal_Verdef ivd ;
  Elf_External_Verdef evd ;
  unsigned long offset___0 ;
  long tmp___118 ;
  elf_vma tmp___119 ;
  elf_vma tmp___120 ;
  char *tmp___121 ;
  void *tmp___122 ;
  Elf_External_Verdaux evda ;
  Elf_Internal_Verdaux ivda ;
  elf_vma tmp___123 ;
  char *tmp___124 ;
  void *tmp___125 ;
  elf_vma tmp___126 ;
  size_t tmp___127 ;
  int tmp___128 ;
  char *tmp___129 ;

  {
#line 8245
  found = 0;
#line 8247
  if (! do_version) {
#line 8248
    return (1);
  }
#line 8250
  i = 0U;
#line 8250
  section = section_headers;
  {
#line 8250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 8250
    if (! (i < elf_header.e_shnum)) {
#line 8250
      goto while_break;
    }
    {
#line 8256
    if (section->sh_type == 1879048189U) {
#line 8256
      goto case_1879048189;
    }
#line 8375
    if (section->sh_type == 1879048190U) {
#line 8375
      goto case_1879048190;
    }
#line 8489
    if (section->sh_type == 1879048191U) {
#line 8489
      goto case_1879048191;
    }
#line 8736
    goto switch_default___0;
    case_1879048189: /* CIL Label */ 
#line 8263
    found = 1;
#line 8265
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 8265
      tmp___0 = gettext("<none>");
#line 8265
      tmp___5 = tmp___0;
      }
    } else {
#line 8265
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8265
        tmp___1 = gettext("<no-name>");
#line 8265
        tmp___4 = tmp___1;
        }
      } else {
#line 8265
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 8265
          tmp___2 = gettext("<corrupt>");
#line 8265
          tmp___3 = tmp___2;
          }
        } else {
#line 8265
          tmp___3 = string_table + section->sh_name;
        }
#line 8265
        tmp___4 = tmp___3;
      }
#line 8265
      tmp___5 = tmp___4;
    }
    {
#line 8265
    tmp___6 = gettext("\nVersion definition section \'%s\' contains %u entries:\n");
#line 8265
    printf((char const   */* __restrict  */)tmp___6, tmp___5, section->sh_info);
#line 8269
    tmp___7 = gettext("  Addr: 0x");
#line 8269
    printf((char const   */* __restrict  */)tmp___7);
#line 8270
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            section->sh_addr);
    }
#line 8271
    if (section->sh_link < elf_header.e_shnum) {
#line 8271
      if ((unsigned long )(section_headers + section->sh_link) == (unsigned long )((void *)0)) {
        {
#line 8271
        tmp___8 = gettext("<none>");
#line 8271
        tmp___13 = tmp___8;
        }
      } else {
#line 8271
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 8271
          tmp___9 = gettext("<no-name>");
#line 8271
          tmp___12 = tmp___9;
          }
        } else {
#line 8271
          if ((unsigned long )(section_headers + section->sh_link)->sh_name >= string_table_length) {
            {
#line 8271
            tmp___10 = gettext("<corrupt>");
#line 8271
            tmp___11 = tmp___10;
            }
          } else {
#line 8271
            tmp___11 = string_table + (section_headers + section->sh_link)->sh_name;
          }
#line 8271
          tmp___12 = tmp___11;
        }
#line 8271
        tmp___13 = tmp___12;
      }
#line 8271
      tmp___15 = tmp___13;
    } else {
      {
#line 8271
      tmp___14 = gettext("<corrupt>");
#line 8271
      tmp___15 = tmp___14;
      }
    }
    {
#line 8271
    tmp___16 = gettext("  Offset: %#08lx  Link: %u (%s)\n");
#line 8271
    printf((char const   */* __restrict  */)tmp___16, (unsigned long )section->sh_offset,
           section->sh_link, tmp___15);
#line 8277
    tmp___17 = gettext("version definition section");
#line 8277
    tmp___18 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                        (char const   *)tmp___17);
#line 8277
    edefs = (Elf_External_Verdef *)tmp___18;
    }
#line 8280
    if (! edefs) {
#line 8281
      goto switch_break;
    }
#line 8282
    endbuf = (char *)edefs + section->sh_size;
#line 8284
    cnt = 0U;
#line 8284
    idx___0 = cnt;
    {
#line 8284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 8284
      if (! (cnt < section->sh_info)) {
#line 8284
        goto while_break___0;
      }
#line 8295
      if ((unsigned long )((unsigned char *)edefs + idx___0) < (unsigned long )((unsigned char *)edefs)) {
#line 8296
        goto while_break___0;
      }
#line 8298
      vstart = (char *)edefs + idx___0;
#line 8299
      if ((unsigned long )(vstart + sizeof(*edef)) > (unsigned long )endbuf) {
#line 8300
        goto while_break___0;
      }
      {
#line 8302
      edef = (Elf_External_Verdef *)vstart;
#line 8304
      tmp___19 = (*byte_get)(edef->vd_version, (int )sizeof(edef->vd_version));
#line 8304
      ent.vd_version = (unsigned short )tmp___19;
#line 8305
      tmp___20 = (*byte_get)(edef->vd_flags, (int )sizeof(edef->vd_flags));
#line 8305
      ent.vd_flags = (unsigned short )tmp___20;
#line 8306
      tmp___21 = (*byte_get)(edef->vd_ndx, (int )sizeof(edef->vd_ndx));
#line 8306
      ent.vd_ndx = (unsigned short )tmp___21;
#line 8307
      tmp___22 = (*byte_get)(edef->vd_cnt, (int )sizeof(edef->vd_cnt));
#line 8307
      ent.vd_cnt = (unsigned short )tmp___22;
#line 8308
      tmp___23 = (*byte_get)(edef->vd_hash, (int )sizeof(edef->vd_hash));
#line 8308
      ent.vd_hash = (unsigned long )tmp___23;
#line 8309
      tmp___24 = (*byte_get)(edef->vd_aux, (int )sizeof(edef->vd_aux));
#line 8309
      ent.vd_aux = (unsigned long )tmp___24;
#line 8310
      tmp___25 = (*byte_get)(edef->vd_next, (int )sizeof(edef->vd_next));
#line 8310
      ent.vd_next = (unsigned long )tmp___25;
#line 8312
      tmp___26 = get_ver_flags((unsigned int )ent.vd_flags);
#line 8312
      tmp___27 = gettext("  %#06x: Rev: %d  Flags: %s");
#line 8312
      printf((char const   */* __restrict  */)tmp___27, idx___0, (int )ent.vd_version,
             tmp___26);
#line 8315
      tmp___28 = gettext("  Index: %d  Cnt: %d  ");
#line 8315
      printf((char const   */* __restrict  */)tmp___28, (int )ent.vd_ndx, (int )ent.vd_cnt);
      }
#line 8319
      if ((unsigned long )((unsigned char *)(vstart + ent.vd_aux)) < (unsigned long )((unsigned char *)vstart)) {
#line 8321
        goto while_break___0;
      } else
#line 8319
      if ((unsigned long )((unsigned char *)(vstart + ent.vd_aux)) > (unsigned long )((unsigned char *)endbuf)) {
#line 8321
        goto while_break___0;
      }
      {
#line 8323
      vstart += ent.vd_aux;
#line 8325
      eaux = (Elf_External_Verdaux *)vstart;
#line 8327
      tmp___29 = (*byte_get)(eaux->vda_name, (int )sizeof(eaux->vda_name));
#line 8327
      aux.vda_name = (unsigned long )tmp___29;
#line 8328
      tmp___30 = (*byte_get)(eaux->vda_next, (int )sizeof(eaux->vda_next));
#line 8328
      aux.vda_next = (unsigned long )tmp___30;
      }
#line 8330
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8330
        if (aux.vda_name < dynamic_strings_length) {
          {
#line 8331
          tmp___31 = gettext("Name: %s\n");
#line 8331
          printf((char const   */* __restrict  */)tmp___31, dynamic_strings + aux.vda_name);
          }
        } else {
          {
#line 8333
          tmp___32 = gettext("Name index: %ld\n");
#line 8333
          printf((char const   */* __restrict  */)tmp___32, aux.vda_name);
          }
        }
      } else {
        {
#line 8333
        tmp___32 = gettext("Name index: %ld\n");
#line 8333
        printf((char const   */* __restrict  */)tmp___32, aux.vda_name);
        }
      }
#line 8335
      isum = (int )((unsigned long )idx___0 + ent.vd_aux);
#line 8337
      j = 1;
      {
#line 8337
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 8337
        if (! (j < (int )ent.vd_cnt)) {
#line 8337
          goto while_break___1;
        }
#line 8340
        if ((unsigned long )((unsigned char *)(vstart + aux.vda_next)) < (unsigned long )((unsigned char *)vstart)) {
#line 8342
          goto while_break___1;
        } else
#line 8340
        if ((unsigned long )((unsigned char *)(vstart + aux.vda_next)) > (unsigned long )((unsigned char *)endbuf)) {
#line 8342
          goto while_break___1;
        }
#line 8344
        isum = (int )((unsigned long )isum + aux.vda_next);
#line 8345
        vstart += aux.vda_next;
#line 8347
        eaux = (Elf_External_Verdaux *)vstart;
#line 8348
        if ((unsigned long )(vstart + sizeof(*eaux)) > (unsigned long )endbuf) {
#line 8349
          goto while_break___1;
        }
        {
#line 8351
        tmp___33 = (*byte_get)(eaux->vda_name, (int )sizeof(eaux->vda_name));
#line 8351
        aux.vda_name = (unsigned long )tmp___33;
#line 8352
        tmp___34 = (*byte_get)(eaux->vda_next, (int )sizeof(eaux->vda_next));
#line 8352
        aux.vda_next = (unsigned long )tmp___34;
        }
#line 8354
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8354
          if (aux.vda_name < dynamic_strings_length) {
            {
#line 8355
            tmp___35 = gettext("  %#06x: Parent %d: %s\n");
#line 8355
            printf((char const   */* __restrict  */)tmp___35, isum, j, dynamic_strings + aux.vda_name);
            }
          } else {
            {
#line 8358
            tmp___36 = gettext("  %#06x: Parent %d, name index: %ld\n");
#line 8358
            printf((char const   */* __restrict  */)tmp___36, isum, j, aux.vda_name);
            }
          }
        } else {
          {
#line 8358
          tmp___36 = gettext("  %#06x: Parent %d, name index: %ld\n");
#line 8358
          printf((char const   */* __restrict  */)tmp___36, isum, j, aux.vda_name);
          }
        }
#line 8337
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 8362
      if (j < (int )ent.vd_cnt) {
        {
#line 8363
        tmp___37 = gettext("  Version def aux past end of section\n");
#line 8363
        printf((char const   */* __restrict  */)tmp___37);
        }
      }
#line 8365
      idx___0 = (unsigned int )((unsigned long )idx___0 + ent.vd_next);
#line 8284
      cnt ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 8368
    if (cnt < section->sh_info) {
      {
#line 8369
      tmp___38 = gettext("  Version definition past end of section\n");
#line 8369
      printf((char const   */* __restrict  */)tmp___38);
      }
    }
    {
#line 8371
    free((void *)edefs);
    }
#line 8373
    goto switch_break;
    case_1879048190: /* CIL Label */ 
#line 8382
    found = 1;
#line 8384
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 8384
      tmp___39 = gettext("<none>");
#line 8384
      tmp___44 = tmp___39;
      }
    } else {
#line 8384
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8384
        tmp___40 = gettext("<no-name>");
#line 8384
        tmp___43 = tmp___40;
        }
      } else {
#line 8384
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 8384
          tmp___41 = gettext("<corrupt>");
#line 8384
          tmp___42 = tmp___41;
          }
        } else {
#line 8384
          tmp___42 = string_table + section->sh_name;
        }
#line 8384
        tmp___43 = tmp___42;
      }
#line 8384
      tmp___44 = tmp___43;
    }
    {
#line 8384
    tmp___45 = gettext("\nVersion needs section \'%s\' contains %u entries:\n");
#line 8384
    printf((char const   */* __restrict  */)tmp___45, tmp___44, section->sh_info);
#line 8387
    tmp___46 = gettext(" Addr: 0x");
#line 8387
    printf((char const   */* __restrict  */)tmp___46);
#line 8388
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            section->sh_addr);
    }
#line 8389
    if (section->sh_link < elf_header.e_shnum) {
#line 8389
      if ((unsigned long )(section_headers + section->sh_link) == (unsigned long )((void *)0)) {
        {
#line 8389
        tmp___47 = gettext("<none>");
#line 8389
        tmp___52 = tmp___47;
        }
      } else {
#line 8389
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 8389
          tmp___48 = gettext("<no-name>");
#line 8389
          tmp___51 = tmp___48;
          }
        } else {
#line 8389
          if ((unsigned long )(section_headers + section->sh_link)->sh_name >= string_table_length) {
            {
#line 8389
            tmp___49 = gettext("<corrupt>");
#line 8389
            tmp___50 = tmp___49;
            }
          } else {
#line 8389
            tmp___50 = string_table + (section_headers + section->sh_link)->sh_name;
          }
#line 8389
          tmp___51 = tmp___50;
        }
#line 8389
        tmp___52 = tmp___51;
      }
#line 8389
      tmp___54 = tmp___52;
    } else {
      {
#line 8389
      tmp___53 = gettext("<corrupt>");
#line 8389
      tmp___54 = tmp___53;
      }
    }
    {
#line 8389
    tmp___55 = gettext("  Offset: %#08lx  Link: %u (%s)\n");
#line 8389
    printf((char const   */* __restrict  */)tmp___55, (unsigned long )section->sh_offset,
           section->sh_link, tmp___54);
#line 8395
    tmp___56 = gettext("Version Needs section");
#line 8395
    tmp___57 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                        (char const   *)tmp___56);
#line 8395
    eneed = (Elf_External_Verneed *)tmp___57;
    }
#line 8399
    if (! eneed) {
#line 8400
      goto switch_break;
    }
#line 8401
    endbuf___0 = (char *)eneed + section->sh_size;
#line 8403
    cnt___0 = 0U;
#line 8403
    idx___1 = cnt___0;
    {
#line 8403
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 8403
      if (! (cnt___0 < section->sh_info)) {
#line 8403
        goto while_break___2;
      }
#line 8411
      if ((unsigned long )((unsigned char *)eneed + idx___1) < (unsigned long )((unsigned char *)eneed)) {
#line 8412
        goto while_break___2;
      }
#line 8414
      vstart___0 = (char *)eneed + idx___1;
#line 8415
      if ((unsigned long )(vstart___0 + sizeof(*entry)) > (unsigned long )endbuf___0) {
#line 8416
        goto while_break___2;
      }
      {
#line 8418
      entry = (Elf_External_Verneed *)vstart___0;
#line 8420
      tmp___58 = (*byte_get)(entry->vn_version, (int )sizeof(entry->vn_version));
#line 8420
      ent___0.vn_version = (unsigned short )tmp___58;
#line 8421
      tmp___59 = (*byte_get)(entry->vn_cnt, (int )sizeof(entry->vn_cnt));
#line 8421
      ent___0.vn_cnt = (unsigned short )tmp___59;
#line 8422
      tmp___60 = (*byte_get)(entry->vn_file, (int )sizeof(entry->vn_file));
#line 8422
      ent___0.vn_file = (unsigned long )tmp___60;
#line 8423
      tmp___61 = (*byte_get)(entry->vn_aux, (int )sizeof(entry->vn_aux));
#line 8423
      ent___0.vn_aux = (unsigned long )tmp___61;
#line 8424
      tmp___62 = (*byte_get)(entry->vn_next, (int )sizeof(entry->vn_next));
#line 8424
      ent___0.vn_next = (unsigned long )tmp___62;
#line 8426
      tmp___63 = gettext("  %#06x: Version: %d");
#line 8426
      printf((char const   */* __restrict  */)tmp___63, idx___1, (int )ent___0.vn_version);
      }
#line 8428
      if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8428
        if (ent___0.vn_file < dynamic_strings_length) {
          {
#line 8429
          tmp___64 = gettext("  File: %s");
#line 8429
          printf((char const   */* __restrict  */)tmp___64, dynamic_strings + ent___0.vn_file);
          }
        } else {
          {
#line 8431
          tmp___65 = gettext("  File: %lx");
#line 8431
          printf((char const   */* __restrict  */)tmp___65, ent___0.vn_file);
          }
        }
      } else {
        {
#line 8431
        tmp___65 = gettext("  File: %lx");
#line 8431
        printf((char const   */* __restrict  */)tmp___65, ent___0.vn_file);
        }
      }
      {
#line 8433
      tmp___66 = gettext("  Cnt: %d\n");
#line 8433
      printf((char const   */* __restrict  */)tmp___66, (int )ent___0.vn_cnt);
      }
#line 8436
      if ((unsigned long )((unsigned char *)(vstart___0 + ent___0.vn_aux)) < (unsigned long )((unsigned char *)vstart___0)) {
#line 8438
        goto while_break___2;
      } else
#line 8436
      if ((unsigned long )((unsigned char *)(vstart___0 + ent___0.vn_aux)) > (unsigned long )((unsigned char *)endbuf___0)) {
#line 8438
        goto while_break___2;
      }
#line 8440
      vstart___0 += ent___0.vn_aux;
#line 8442
      j___0 = 0;
#line 8442
      isum___0 = (int )((unsigned long )idx___1 + ent___0.vn_aux);
      {
#line 8442
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 8442
        if (! (j___0 < (int )ent___0.vn_cnt)) {
#line 8442
          goto while_break___3;
        }
#line 8447
        if ((unsigned long )(vstart___0 + sizeof(*eaux___0)) > (unsigned long )endbuf___0) {
#line 8448
          goto while_break___3;
        }
        {
#line 8449
        eaux___0 = (Elf_External_Vernaux *)vstart___0;
#line 8451
        tmp___67 = (*byte_get)(eaux___0->vna_hash, (int )sizeof(eaux___0->vna_hash));
#line 8451
        aux___0.vna_hash = (unsigned long )tmp___67;
#line 8452
        tmp___68 = (*byte_get)(eaux___0->vna_flags, (int )sizeof(eaux___0->vna_flags));
#line 8452
        aux___0.vna_flags = (unsigned short )tmp___68;
#line 8453
        tmp___69 = (*byte_get)(eaux___0->vna_other, (int )sizeof(eaux___0->vna_other));
#line 8453
        aux___0.vna_other = (unsigned short )tmp___69;
#line 8454
        tmp___70 = (*byte_get)(eaux___0->vna_name, (int )sizeof(eaux___0->vna_name));
#line 8454
        aux___0.vna_name = (unsigned long )tmp___70;
#line 8455
        tmp___71 = (*byte_get)(eaux___0->vna_next, (int )sizeof(eaux___0->vna_next));
#line 8455
        aux___0.vna_next = (unsigned long )tmp___71;
        }
#line 8457
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 8457
          if (aux___0.vna_name < dynamic_strings_length) {
            {
#line 8458
            tmp___72 = gettext("  %#06x:   Name: %s");
#line 8458
            printf((char const   */* __restrict  */)tmp___72, isum___0, dynamic_strings + aux___0.vna_name);
            }
          } else {
            {
#line 8461
            tmp___73 = gettext("  %#06x:   Name index: %lx");
#line 8461
            printf((char const   */* __restrict  */)tmp___73, isum___0, aux___0.vna_name);
            }
          }
        } else {
          {
#line 8461
          tmp___73 = gettext("  %#06x:   Name index: %lx");
#line 8461
          printf((char const   */* __restrict  */)tmp___73, isum___0, aux___0.vna_name);
          }
        }
        {
#line 8464
        tmp___74 = get_ver_flags((unsigned int )aux___0.vna_flags);
#line 8464
        tmp___75 = gettext("  Flags: %s  Version: %d\n");
#line 8464
        printf((char const   */* __restrict  */)tmp___75, tmp___74, (int )aux___0.vna_other);
        }
#line 8468
        if ((unsigned long )((unsigned char *)(vstart___0 + aux___0.vna_next)) < (unsigned long )((unsigned char *)vstart___0)) {
#line 8470
          goto while_break___3;
        } else
#line 8468
        if ((unsigned long )((unsigned char *)(vstart___0 + aux___0.vna_next)) > (unsigned long )((unsigned char *)endbuf___0)) {
#line 8470
          goto while_break___3;
        }
#line 8472
        isum___0 = (int )((unsigned long )isum___0 + aux___0.vna_next);
#line 8473
        vstart___0 += aux___0.vna_next;
#line 8442
        j___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 8476
      if (j___0 < (int )ent___0.vn_cnt) {
        {
#line 8477
        tmp___76 = gettext("Missing Version Needs auxillary information\n");
#line 8477
        warn((char const   *)tmp___76);
        }
      }
#line 8479
      idx___1 = (unsigned int )((unsigned long )idx___1 + ent___0.vn_next);
#line 8403
      cnt___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 8482
    if (cnt___0 < section->sh_info) {
      {
#line 8483
      tmp___77 = gettext("Missing Version Needs information\n");
#line 8483
      warn((char const   *)tmp___77);
      }
    }
    {
#line 8485
    free((void *)eneed);
    }
#line 8487
    goto switch_break;
    case_1879048191: /* CIL Label */ 
#line 8502
    if (section->sh_link >= elf_header.e_shnum) {
#line 8503
      goto switch_break;
    }
#line 8505
    link_section = section_headers + section->sh_link;
#line 8506
    total = (int )(section->sh_size / sizeof(Elf_External_Versym ));
#line 8508
    if (link_section->sh_link >= elf_header.e_shnum) {
#line 8509
      goto switch_break;
    }
#line 8511
    found = 1;
#line 8513
    if (is_32bit_elf) {
      {
#line 8513
      tmp___78 = get_32bit_elf_symbols(file, link_section, & num_syms);
#line 8513
      symbols = tmp___78;
      }
    } else {
      {
#line 8513
      tmp___79 = get_64bit_elf_symbols(file, link_section, & num_syms);
#line 8513
      symbols = tmp___79;
      }
    }
#line 8514
    if ((unsigned long )symbols == (unsigned long )((void *)0)) {
#line 8515
      goto switch_break;
    }
    {
#line 8517
    string_sec = section_headers + link_section->sh_link;
#line 8519
    tmp___80 = gettext("version string table");
#line 8519
    tmp___81 = get_data((void *)0, file, string_sec->sh_offset, (size_t )1, string_sec->sh_size,
                        (char const   *)tmp___80);
#line 8519
    strtab = (char *)tmp___81;
    }
#line 8522
    if (! strtab) {
      {
#line 8524
      free((void *)symbols);
      }
#line 8525
      goto switch_break;
    }
#line 8528
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 8528
      tmp___82 = gettext("<none>");
#line 8528
      tmp___87 = tmp___82;
      }
    } else {
#line 8528
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8528
        tmp___83 = gettext("<no-name>");
#line 8528
        tmp___86 = tmp___83;
        }
      } else {
#line 8528
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 8528
          tmp___84 = gettext("<corrupt>");
#line 8528
          tmp___85 = tmp___84;
          }
        } else {
#line 8528
          tmp___85 = string_table + section->sh_name;
        }
#line 8528
        tmp___86 = tmp___85;
      }
#line 8528
      tmp___87 = tmp___86;
    }
    {
#line 8528
    tmp___88 = gettext("\nVersion symbols section \'%s\' contains %d entries:\n");
#line 8528
    printf((char const   */* __restrict  */)tmp___88, tmp___87, total);
#line 8531
    tmp___89 = gettext(" Addr: ");
#line 8531
    printf((char const   */* __restrict  */)tmp___89);
#line 8532
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
            section->sh_addr);
    }
#line 8533
    if ((unsigned long )link_section == (unsigned long )((void *)0)) {
      {
#line 8533
      tmp___90 = gettext("<none>");
#line 8533
      tmp___95 = tmp___90;
      }
    } else {
#line 8533
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 8533
        tmp___91 = gettext("<no-name>");
#line 8533
        tmp___94 = tmp___91;
        }
      } else {
#line 8533
        if ((unsigned long )link_section->sh_name >= string_table_length) {
          {
#line 8533
          tmp___92 = gettext("<corrupt>");
#line 8533
          tmp___93 = tmp___92;
          }
        } else {
#line 8533
          tmp___93 = string_table + link_section->sh_name;
        }
#line 8533
        tmp___94 = tmp___93;
      }
#line 8533
      tmp___95 = tmp___94;
    }
    {
#line 8533
    tmp___96 = gettext("  Offset: %#08lx  Link: %u (%s)\n");
#line 8533
    printf((char const   */* __restrict  */)tmp___96, (unsigned long )section->sh_offset,
           section->sh_link, tmp___95);
#line 8537
    off = offset_from_vma(file, version_info[15], (unsigned long )total * sizeof(short ));
#line 8540
    tmp___97 = gettext("version symbol data");
#line 8540
    tmp___98 = get_data((void *)0, file, off, (size_t )total, sizeof(short ), (char const   *)tmp___97);
#line 8540
    edata = (unsigned char *)tmp___98;
    }
#line 8543
    if (! edata) {
      {
#line 8545
      free((void *)strtab);
#line 8546
      free((void *)symbols);
      }
#line 8547
      goto switch_break;
    }
    {
#line 8550
    tmp___99 = cmalloc((size_t )total, sizeof(short ));
#line 8550
    data = (unsigned short *)tmp___99;
#line 8552
    cnt___1 = total;
    }
    {
#line 8552
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 8552
      tmp___101 = cnt___1;
#line 8552
      cnt___1 --;
#line 8552
      if (! tmp___101) {
#line 8552
        goto while_break___4;
      }
      {
#line 8553
      tmp___100 = (*byte_get)(edata + (unsigned long )cnt___1 * sizeof(short ), (int )sizeof(short ));
#line 8553
      *(data + cnt___1) = (unsigned short )tmp___100;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 8556
    free((void *)edata);
#line 8558
    cnt___1 = 0;
    }
    {
#line 8558
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 8558
      if (! (cnt___1 < total)) {
#line 8558
        goto while_break___5;
      }
      {
#line 8564
      printf((char const   */* __restrict  */)"  %03x:", cnt___1);
#line 8566
      j___1 = 0;
      }
      {
#line 8566
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 8566
        if (j___1 < 4) {
#line 8566
          if (! (cnt___1 + j___1 < total)) {
#line 8566
            goto while_break___6;
          }
        } else {
#line 8566
          goto while_break___6;
        }
        {
#line 8569
        if ((int )*(data + (cnt___1 + j___1)) == 0) {
#line 8569
          goto case_0;
        }
#line 8573
        if ((int )*(data + (cnt___1 + j___1)) == 1) {
#line 8573
          goto case_1;
        }
#line 8577
        goto switch_default;
        case_0: /* CIL Label */ 
        {
#line 8570
        tmp___102 = gettext("   0 (*local*)    ");
#line 8570
        fputs((char const   */* __restrict  */)tmp___102, (FILE */* __restrict  */)stdout);
        }
#line 8571
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 8574
        tmp___103 = gettext("   1 (*global*)   ");
#line 8574
        fputs((char const   */* __restrict  */)tmp___103, (FILE */* __restrict  */)stdout);
        }
#line 8575
        goto switch_break___0;
        switch_default: /* CIL Label */ 
#line 8578
        if ((int )*(data + (cnt___1 + j___1)) & 32768) {
#line 8578
          tmp___104 = 'h';
        } else {
#line 8578
          tmp___104 = ' ';
        }
        {
#line 8578
        nn = printf((char const   */* __restrict  */)"%4x%c", (int )*(data + (cnt___1 + j___1)) & 32767,
                    tmp___104);
        }
#line 8583
        if ((unsigned long )(cnt___1 + j___1) >= num_syms) {
          {
#line 8585
          tmp___105 = gettext("invalid index into symbol array\n");
#line 8585
          warn((char const   *)tmp___105);
          }
#line 8586
          goto switch_break___0;
        }
#line 8589
        check_def = 1;
#line 8590
        check_need = 1;
#line 8591
        if ((symbols + (cnt___1 + j___1))->st_shndx >= elf_header.e_shnum) {
#line 8591
          goto _L;
        } else
#line 8591
        if ((section_headers + (symbols + (cnt___1 + j___1))->st_shndx)->sh_type != 8U) {
          _L: /* CIL Label */ 
#line 8595
          if ((symbols + (cnt___1 + j___1))->st_shndx == 0U) {
#line 8596
            check_def = 0;
          } else {
#line 8598
            check_need = 0;
          }
        }
#line 8601
        if (check_need) {
#line 8601
          if (version_info[1]) {
            {
#line 8607
            tmp___106 = offset_from_vma(file, version_info[1], sizeof(Elf_External_Verneed ));
#line 8607
            offset = (unsigned long )tmp___106;
            }
            {
#line 8611
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 8618
              tmp___107 = gettext("version need");
#line 8618
              tmp___108 = get_data((void *)(& evn), file, (long )offset, sizeof(evn),
                                   (size_t )1, (char const   *)tmp___107);
              }
#line 8618
              if ((unsigned long )tmp___108 == (unsigned long )((void *)0)) {
#line 8620
                goto while_break___7;
              }
              {
#line 8622
              tmp___109 = (*byte_get)(evn.vn_aux, (int )sizeof(evn.vn_aux));
#line 8622
              ivn.vn_aux = (unsigned long )tmp___109;
#line 8623
              tmp___110 = (*byte_get)(evn.vn_next, (int )sizeof(evn.vn_next));
#line 8623
              ivn.vn_next = (unsigned long )tmp___110;
#line 8625
              a_off = offset + ivn.vn_aux;
              }
              {
#line 8627
              while (1) {
                while_continue___8: /* CIL Label */ ;
                {
#line 8629
                tmp___113 = gettext("version need aux (2)");
#line 8629
                tmp___114 = get_data((void *)(& evna), file, (long )a_off, sizeof(evna),
                                     (size_t )1, (char const   *)tmp___113);
                }
#line 8629
                if ((unsigned long )tmp___114 == (unsigned long )((void *)0)) {
#line 8632
                  ivna.vna_next = 0UL;
#line 8633
                  ivna.vna_other = (unsigned short)0;
                } else {
                  {
#line 8637
                  tmp___111 = (*byte_get)(evna.vna_next, (int )sizeof(evna.vna_next));
#line 8637
                  ivna.vna_next = (unsigned long )tmp___111;
#line 8638
                  tmp___112 = (*byte_get)(evna.vna_other, (int )sizeof(evna.vna_other));
#line 8638
                  ivna.vna_other = (unsigned short )tmp___112;
                  }
                }
#line 8641
                a_off += ivna.vna_next;
#line 8627
                if ((int )ivna.vna_other != (int )*(data + (cnt___1 + j___1))) {
#line 8627
                  if (! (ivna.vna_next != 0UL)) {
#line 8627
                    goto while_break___8;
                  }
                } else {
#line 8627
                  goto while_break___8;
                }
              }
              while_break___8: /* CIL Label */ ;
              }
#line 8646
              if ((int )ivna.vna_other == (int )*(data + (cnt___1 + j___1))) {
                {
#line 8648
                tmp___115 = (*byte_get)(evna.vna_name, (int )sizeof(evna.vna_name));
#line 8648
                ivna.vna_name = (unsigned long )tmp___115;
                }
#line 8650
                if (ivna.vna_name >= string_sec->sh_size) {
                  {
#line 8651
                  name___0 = gettext("*invalid*");
                  }
                } else {
#line 8653
                  name___0 = strtab + ivna.vna_name;
                }
                {
#line 8654
                tmp___116 = strlen((char const   *)name___0);
#line 8654
                tmp___117 = printf((char const   */* __restrict  */)"(%s%-*s", name___0,
                                   12 - (int )tmp___116, ")");
#line 8654
                nn += tmp___117;
#line 8658
                check_def = 0;
                }
#line 8659
                goto while_break___7;
              }
#line 8662
              offset += ivn.vn_next;
#line 8611
              if (! ivn.vn_next) {
#line 8611
                goto while_break___7;
              }
            }
            while_break___7: /* CIL Label */ ;
            }
          }
        }
#line 8667
        if (check_def) {
#line 8667
          if ((int )*(data + (cnt___1 + j___1)) != 32769) {
#line 8667
            if (version_info[3]) {
              {
#line 8674
              tmp___118 = offset_from_vma(file, version_info[3], sizeof(evd));
#line 8674
              offset___0 = (unsigned long )tmp___118;
              }
              {
#line 8678
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 8680
                tmp___121 = gettext("version def");
#line 8680
                tmp___122 = get_data((void *)(& evd), file, (long )offset___0, sizeof(evd),
                                     (size_t )1, (char const   *)tmp___121);
                }
#line 8680
                if ((unsigned long )tmp___122 == (unsigned long )((void *)0)) {
#line 8683
                  ivd.vd_next = 0UL;
#line 8684
                  ivd.vd_ndx = (unsigned short)0;
                } else {
                  {
#line 8688
                  tmp___119 = (*byte_get)(evd.vd_next, (int )sizeof(evd.vd_next));
#line 8688
                  ivd.vd_next = (unsigned long )tmp___119;
#line 8689
                  tmp___120 = (*byte_get)(evd.vd_ndx, (int )sizeof(evd.vd_ndx));
#line 8689
                  ivd.vd_ndx = (unsigned short )tmp___120;
                  }
                }
#line 8692
                offset___0 += ivd.vd_next;
#line 8678
                if ((int )ivd.vd_ndx != ((int )*(data + (cnt___1 + j___1)) & 32767)) {
#line 8678
                  if (! (ivd.vd_next != 0UL)) {
#line 8678
                    goto while_break___9;
                  }
                } else {
#line 8678
                  goto while_break___9;
                }
              }
              while_break___9: /* CIL Label */ ;
              }
#line 8697
              if ((int )ivd.vd_ndx == ((int )*(data + (cnt___1 + j___1)) & 32767)) {
                {
#line 8702
                tmp___123 = (*byte_get)(evd.vd_aux, (int )sizeof(evd.vd_aux));
#line 8702
                ivd.vd_aux = (unsigned long )tmp___123;
#line 8704
                tmp___124 = gettext("version def aux");
#line 8704
                tmp___125 = get_data((void *)(& evda), file, (long )((offset___0 - ivd.vd_next) + ivd.vd_aux),
                                     sizeof(evda), (size_t )1, (char const   *)tmp___124);
                }
#line 8704
                if ((unsigned long )tmp___125 == (unsigned long )((void *)0)) {
#line 8708
                  goto switch_break___0;
                }
                {
#line 8710
                tmp___126 = (*byte_get)(evda.vda_name, (int )sizeof(evda.vda_name));
#line 8710
                ivda.vda_name = (unsigned long )tmp___126;
                }
#line 8712
                if (ivda.vda_name >= string_sec->sh_size) {
                  {
#line 8713
                  name___0 = gettext("*invalid*");
                  }
                } else {
#line 8715
                  name___0 = strtab + ivda.vda_name;
                }
                {
#line 8716
                tmp___127 = strlen((char const   *)name___0);
#line 8716
                tmp___128 = printf((char const   */* __restrict  */)"(%s%-*s", name___0,
                                   12 - (int )tmp___127, ")");
#line 8716
                nn += tmp___128;
                }
              }
            }
          }
        }
#line 8723
        if (nn < 18) {
          {
#line 8724
          printf((char const   */* __restrict  */)"%*c", 18 - nn, ' ');
          }
        }
        switch_break___0: /* CIL Label */ ;
        }
#line 8566
        j___1 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 8727
      putchar('\n');
#line 8558
      cnt___1 += 4;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 8730
    free((void *)data);
#line 8731
    free((void *)strtab);
#line 8732
    free((void *)symbols);
    }
#line 8734
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 8737
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 8250
    i ++;
#line 8250
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 8741
  if (! found) {
    {
#line 8742
    tmp___129 = gettext("\nNo version information found in this file.\n");
#line 8742
    printf((char const   */* __restrict  */)tmp___129);
    }
  }
#line 8744
  return (1);
}
}
#line 8750 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___11[32]  ;
#line 8747 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_symbol_binding(unsigned int binding ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 8754
  if (binding == 0U) {
#line 8754
    goto case_0;
  }
#line 8755
  if (binding == 1U) {
#line 8755
    goto case_1;
  }
#line 8756
  if (binding == 2U) {
#line 8756
    goto case_2;
  }
#line 8757
  goto switch_default;
  case_0: /* CIL Label */ 
#line 8754
  return ("LOCAL");
  case_1: /* CIL Label */ 
#line 8755
  return ("GLOBAL");
  case_2: /* CIL Label */ 
#line 8756
  return ("WEAK");
  switch_default: /* CIL Label */ 
#line 8758
  if (binding >= 13U) {
#line 8758
    if (binding <= 15U) {
      {
#line 8759
      tmp___0 = gettext("<processor specific>: %d");
#line 8759
      snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___0,
               binding);
      }
    } else {
#line 8758
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 8761
  if (binding >= 10U) {
#line 8761
    if (binding <= 12U) {
#line 8763
      if (binding == 10U) {
#line 8763
        if ((int )elf_header.e_ident[7] == 3) {
#line 8767
          return ("UNIQUE");
        } else
#line 8763
        if ((int )elf_header.e_ident[7] == 0) {
#line 8767
          return ("UNIQUE");
        }
      }
      {
#line 8768
      tmp___1 = gettext("<OS specific>: %d");
#line 8768
      snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___1,
               binding);
      }
    } else {
      {
#line 8771
      tmp___2 = gettext("<unknown>: %d");
#line 8771
      snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___2,
               binding);
      }
    }
  } else {
    {
#line 8771
    tmp___2 = gettext("<unknown>: %d");
#line 8771
    snprintf((char */* __restrict  */)(buff___11), sizeof(buff___11), (char const   */* __restrict  */)tmp___2,
             binding);
    }
  }
#line 8772
  return ((char const   *)(buff___11));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 8779 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___12[32]  ;
#line 8776 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_symbol_type(unsigned int type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 8783
  if (type == 0U) {
#line 8783
    goto case_0;
  }
#line 8784
  if (type == 1U) {
#line 8784
    goto case_1;
  }
#line 8785
  if (type == 2U) {
#line 8785
    goto case_2;
  }
#line 8786
  if (type == 3U) {
#line 8786
    goto case_3;
  }
#line 8787
  if (type == 4U) {
#line 8787
    goto case_4;
  }
#line 8788
  if (type == 5U) {
#line 8788
    goto case_5;
  }
#line 8789
  if (type == 6U) {
#line 8789
    goto case_6;
  }
#line 8790
  if (type == 8U) {
#line 8790
    goto case_8;
  }
#line 8791
  if (type == 9U) {
#line 8791
    goto case_9;
  }
#line 8792
  goto switch_default;
  case_0: /* CIL Label */ 
#line 8783
  return ("NOTYPE");
  case_1: /* CIL Label */ 
#line 8784
  return ("OBJECT");
  case_2: /* CIL Label */ 
#line 8785
  return ("FUNC");
  case_3: /* CIL Label */ 
#line 8786
  return ("SECTION");
  case_4: /* CIL Label */ 
#line 8787
  return ("FILE");
  case_5: /* CIL Label */ 
#line 8788
  return ("COMMON");
  case_6: /* CIL Label */ 
#line 8789
  return ("TLS");
  case_8: /* CIL Label */ 
#line 8790
  return ("RELC");
  case_9: /* CIL Label */ 
#line 8791
  return ("SRELC");
  switch_default: /* CIL Label */ 
#line 8793
  if (type >= 13U) {
#line 8793
    if (type <= 15U) {
#line 8795
      if ((int )elf_header.e_machine == 40) {
#line 8795
        if (type == 13U) {
#line 8796
          return ("THUMB_FUNC");
        }
      }
#line 8798
      if ((int )elf_header.e_machine == 43) {
#line 8798
        if (type == 13U) {
#line 8799
          return ("REGISTER");
        }
      }
#line 8801
      if ((int )elf_header.e_machine == 15) {
#line 8801
        if (type == 13U) {
#line 8802
          return ("PARISC_MILLI");
        }
      }
      {
#line 8804
      tmp___0 = gettext("<processor specific>: %d");
#line 8804
      snprintf((char */* __restrict  */)(buff___12), sizeof(buff___12), (char const   */* __restrict  */)tmp___0,
               type);
      }
    } else {
#line 8793
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 8806
  if (type >= 10U) {
#line 8806
    if (type <= 12U) {
#line 8808
      if ((int )elf_header.e_machine == 15) {
#line 8810
        if (type == 11U) {
#line 8811
          return ("HP_OPAQUE");
        }
#line 8812
        if (type == 12U) {
#line 8813
          return ("HP_STUB");
        }
      }
#line 8816
      if (type == 10U) {
#line 8816
        if ((int )elf_header.e_ident[7] == 3) {
#line 8821
          return ("IFUNC");
        } else
#line 8816
        if ((int )elf_header.e_ident[7] == 9) {
#line 8821
          return ("IFUNC");
        } else
#line 8816
        if ((int )elf_header.e_ident[7] == 0) {
#line 8821
          return ("IFUNC");
        }
      }
      {
#line 8823
      tmp___1 = gettext("<OS specific>: %d");
#line 8823
      snprintf((char */* __restrict  */)(buff___12), sizeof(buff___12), (char const   */* __restrict  */)tmp___1,
               type);
      }
    } else {
      {
#line 8826
      tmp___2 = gettext("<unknown>: %d");
#line 8826
      snprintf((char */* __restrict  */)(buff___12), sizeof(buff___12), (char const   */* __restrict  */)tmp___2,
               type);
      }
    }
  } else {
    {
#line 8826
    tmp___2 = gettext("<unknown>: %d");
#line 8826
    snprintf((char */* __restrict  */)(buff___12), sizeof(buff___12), (char const   */* __restrict  */)tmp___2,
             type);
    }
  }
#line 8827
  return ((char const   *)(buff___12));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 8831 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_symbol_visibility(unsigned int visibility ) 
{ 


  {
  {
#line 8836
  if (visibility == 0U) {
#line 8836
    goto case_0;
  }
#line 8837
  if (visibility == 1U) {
#line 8837
    goto case_1;
  }
#line 8838
  if (visibility == 2U) {
#line 8838
    goto case_2;
  }
#line 8839
  if (visibility == 3U) {
#line 8839
    goto case_3;
  }
#line 8840
  goto switch_default;
  case_0: /* CIL Label */ 
#line 8836
  return ("DEFAULT");
  case_1: /* CIL Label */ 
#line 8837
  return ("INTERNAL");
  case_2: /* CIL Label */ 
#line 8838
  return ("HIDDEN");
  case_3: /* CIL Label */ 
#line 8839
  return ("PROTECTED");
  switch_default: /* CIL Label */ 
  {
#line 8840
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 8844 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_mips_symbol_other(unsigned int other ) 
{ 


  {
  {
#line 8849
  if (other == (unsigned int )(1 << 2)) {
#line 8849
    goto case_exp;
  }
#line 8851
  if (other == 8U) {
#line 8851
    goto case_8;
  }
#line 8853
  if (other == 32U) {
#line 8853
    goto case_32;
  }
#line 8855
  if (other == (unsigned int )(2 << 6)) {
#line 8855
    goto case_exp___0;
  }
#line 8857
  if (other == (unsigned int )((2 << 6) | 32)) {
#line 8857
    goto case_exp___1;
  }
#line 8859
  if (other == 240U) {
#line 8859
    goto case_240;
  }
#line 8861
  goto switch_default;
  case_exp: /* CIL Label */ 
#line 8850
  return ("OPTIONAL");
  case_8: /* CIL Label */ 
#line 8852
  return ("MIPS PLT");
  case_32: /* CIL Label */ 
#line 8854
  return ("MIPS PIC");
  case_exp___0: /* CIL Label */ 
#line 8856
  return ("MICROMIPS");
  case_exp___1: /* CIL Label */ 
#line 8858
  return ("MICROMIPS, MIPS PIC");
  case_240: /* CIL Label */ 
#line 8860
  return ("MIPS16");
  switch_default: /* CIL Label */ 
#line 8862
  return ((char const   *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 8871 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char res[32]  ;
#line 8866 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ia64_symbol_other(unsigned int other ) 
{ 
  int tmp___0 ;

  {
  {
#line 8869
  tmp___0 = is_ia64_vms();
  }
#line 8869
  if (tmp___0) {
#line 8873
    res[0] = (char)0;
    {
#line 8879
    if ((int )elf_header.e_type == 2) {
#line 8879
      goto case_2;
    }
#line 8879
    if ((int )elf_header.e_type == 3) {
#line 8879
      goto case_2;
    }
#line 8898
    goto switch_default___0;
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    {
#line 8882
    if ((other & 48U) >> 4 == 0U) {
#line 8882
      goto case_0;
    }
#line 8885
    if ((other & 48U) >> 4 == 1U) {
#line 8885
      goto case_1;
    }
#line 8888
    if ((other & 48U) >> 4 == 2U) {
#line 8888
      goto case_2___0;
    }
#line 8891
    if ((other & 48U) >> 4 == 3U) {
#line 8891
      goto case_3___0;
    }
#line 8894
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 8883
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" CA");
    }
#line 8884
    goto switch_break___0;
    case_1: /* CIL Label */ 
    {
#line 8886
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" VEC");
    }
#line 8887
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 8889
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" FD");
    }
#line 8890
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 8892
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" RSV");
    }
#line 8893
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 8895
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 8897
    goto switch_break;
    switch_default___0: /* CIL Label */ 
#line 8899
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 8903
    if ((other & 192U) >> 6 == 0U) {
#line 8903
      goto case_0___0;
    }
#line 8906
    if ((other & 192U) >> 6 == 1U) {
#line 8906
      goto case_1___0;
    }
#line 8909
    if ((other & 192U) >> 6 == 2U) {
#line 8909
      goto case_2___1;
    }
#line 8912
    if ((other & 192U) >> 6 == 3U) {
#line 8912
      goto case_3___1;
    }
#line 8915
    goto switch_default___1;
    case_0___0: /* CIL Label */ 
    {
#line 8904
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" IGN");
    }
#line 8905
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
    {
#line 8907
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" RSV");
    }
#line 8908
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 8910
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" STD");
    }
#line 8911
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    {
#line 8913
    strcat((char */* __restrict  */)(res), (char const   */* __restrict  */)" LNK");
    }
#line 8914
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 8916
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 8919
    if ((int )res[0] != 0) {
#line 8920
      return ((char const   *)(res + 1));
    } else {
#line 8922
      return ((char const   *)(res));
    }
  }
#line 8924
  return ((char const   *)((void *)0));
}
}
#line 8931 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___13[32]  ;
#line 8927 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_symbol_other(unsigned int other ) 
{ 
  char const   *result ;
  char *tmp___0 ;

  {
#line 8930
  result = (char const   *)((void *)0);
#line 8933
  if (other == 0U) {
#line 8934
    return ("");
  }
  {
#line 8938
  if ((int )elf_header.e_machine == 8) {
#line 8938
    goto case_8;
  }
#line 8941
  if ((int )elf_header.e_machine == 50) {
#line 8941
    goto case_50;
  }
#line 8944
  goto switch_default;
  case_8: /* CIL Label */ 
  {
#line 8939
  result = get_mips_symbol_other(other);
  }
#line 8940
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 8942
  result = get_ia64_symbol_other(other);
  }
#line 8943
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 8945
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 8948
  if (result) {
#line 8949
    return (result);
  }
  {
#line 8951
  tmp___0 = gettext("<other>: %x");
#line 8951
  snprintf((char */* __restrict  */)(buff___13), sizeof(buff___13), (char const   */* __restrict  */)tmp___0,
           other);
  }
#line 8952
  return ((char const   *)(buff___13));
}
}
#line 8958 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___14[32]  ;
#line 8955 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_symbol_index_type(unsigned int type ) 
{ 


  {
  {
#line 8962
  if (type == 0U) {
#line 8962
    goto case_0;
  }
#line 8963
  if (type == 4294967281U) {
#line 8963
    goto case_4294967281;
  }
#line 8964
  if (type == 4294967282U) {
#line 8964
    goto case_4294967282;
  }
#line 8965
  goto switch_default;
  case_0: /* CIL Label */ 
#line 8962
  return ("UND");
  case_4294967281: /* CIL Label */ 
#line 8963
  return ("ABS");
  case_4294967282: /* CIL Label */ 
#line 8964
  return ("COM");
  switch_default: /* CIL Label */ 
#line 8966
  if (type == 4294967040U) {
#line 8966
    if ((int )elf_header.e_machine == 50) {
#line 8966
      if ((int )elf_header.e_ident[7] == 1) {
#line 8969
        return ("ANSI_COM");
      } else {
#line 8966
        goto _L___7;
      }
    } else {
#line 8966
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 8970
  if ((int )elf_header.e_machine == 62) {
#line 8970
    goto _L___5;
  } else
#line 8970
  if ((int )elf_header.e_machine == 180) {
#line 8970
    goto _L___5;
  } else
#line 8970
  if ((int )elf_header.e_machine == 181) {
    _L___5: /* CIL Label */ 
#line 8970
    if (type == 4294967042U) {
#line 8974
      return ("LARGE_COM");
    } else {
#line 8970
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 8975
  if (type == 4294967043U) {
#line 8975
    if ((int )elf_header.e_machine == 8) {
#line 8979
      return ("SCOM");
    } else {
#line 8975
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 8975
  if (type == 4294967040U) {
#line 8975
    if ((int )elf_header.e_machine == 140) {
#line 8979
      return ("SCOM");
    } else {
#line 8975
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 8980
  if (type == 4294967044U) {
#line 8980
    if ((int )elf_header.e_machine == 8) {
#line 8982
      return ("SUND");
    } else {
#line 8980
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 8983
  if (type >= 4294967040U) {
#line 8983
    if (type <= 4294967071U) {
      {
#line 8984
      sprintf((char */* __restrict  */)(buff___14), (char const   */* __restrict  */)"PRC[0x%04x]",
              type & 65535U);
      }
    } else {
#line 8983
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 8985
  if (type >= 4294967072U) {
#line 8985
    if (type <= 4294967103U) {
      {
#line 8986
      sprintf((char */* __restrict  */)(buff___14), (char const   */* __restrict  */)"OS [0x%04x]",
              type & 65535U);
      }
    } else {
#line 8985
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 8987
  if (type >= 4294967040U) {
    {
#line 8988
    sprintf((char */* __restrict  */)(buff___14), (char const   */* __restrict  */)"RSV[0x%04x]",
            type & 65535U);
    }
  } else
#line 8989
  if (type >= elf_header.e_shnum) {
    {
#line 8990
    sprintf((char */* __restrict  */)(buff___14), (char const   */* __restrict  */)"bad section index[%3d]",
            type);
    }
  } else {
    {
#line 8992
    sprintf((char */* __restrict  */)(buff___14), (char const   */* __restrict  */)"%3d",
            type);
    }
  }
#line 8993
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 8996
  return ((char const   *)(buff___14));
}
}
#line 8999 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma *get_dynamic_data(FILE *file , unsigned int number , unsigned int ent_size ) 
{ 
  unsigned char *e_data ;
  bfd_vma *i_data ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  elf_vma tmp___6 ;
  unsigned int tmp___7 ;

  {
  {
#line 9005
  tmp___0 = cmalloc((size_t )number, (size_t )ent_size);
#line 9005
  e_data = (unsigned char *)tmp___0;
  }
#line 9007
  if ((unsigned long )e_data == (unsigned long )((void *)0)) {
    {
#line 9009
    tmp___1 = gettext("Out of memory\n");
#line 9009
    error((char const   *)tmp___1);
    }
#line 9010
    return ((bfd_vma *)((void *)0));
  }
  {
#line 9013
  tmp___3 = fread((void */* __restrict  */)e_data, (size_t )ent_size, (size_t )number,
                  (FILE */* __restrict  */)file);
  }
#line 9013
  if (tmp___3 != (size_t )number) {
    {
#line 9015
    tmp___2 = gettext("Unable to read in dynamic data\n");
#line 9015
    error((char const   *)tmp___2);
    }
#line 9016
    return ((bfd_vma *)((void *)0));
  }
  {
#line 9019
  tmp___4 = cmalloc((size_t )number, sizeof(*i_data));
#line 9019
  i_data = (bfd_vma *)tmp___4;
  }
#line 9021
  if ((unsigned long )i_data == (unsigned long )((void *)0)) {
    {
#line 9023
    tmp___5 = gettext("Out of memory\n");
#line 9023
    error((char const   *)tmp___5);
#line 9024
    free((void *)e_data);
    }
#line 9025
    return ((bfd_vma *)((void *)0));
  }
  {
#line 9028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9028
    tmp___7 = number;
#line 9028
    number --;
#line 9028
    if (! tmp___7) {
#line 9028
      goto while_break;
    }
    {
#line 9029
    tmp___6 = (*byte_get)(e_data + number * ent_size, (int )ent_size);
#line 9029
    *(i_data + number) = (bfd_vma )tmp___6;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 9031
  free((void *)e_data);
  }
#line 9033
  return (i_data);
}
}
#line 9036 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void print_dynamic_symbol(bfd_vma si , unsigned long hn ) 
{ 
  Elf_Internal_Sym *psym ;
  int n ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 9042
  psym = dynamic_symbols + si;
#line 9044
  n = print_vma(si, (print_mode )2);
  }
#line 9045
  if (n < 5) {
    {
#line 9046
    fputs((char const   */* __restrict  */)("     " + n), (FILE */* __restrict  */)stdout);
    }
  }
  {
#line 9047
  printf((char const   */* __restrict  */)" %3lu: ", hn);
#line 9048
  print_vma(psym->st_value, (print_mode )6);
#line 9049
  putchar(' ');
#line 9050
  print_vma(psym->st_size, (print_mode )2);
#line 9052
  tmp___0 = get_symbol_type((unsigned int )((int )psym->st_info & 15));
#line 9052
  printf((char const   */* __restrict  */)" %-7s", tmp___0);
#line 9053
  tmp___1 = get_symbol_binding((unsigned int )psym->st_info >> 4);
#line 9053
  printf((char const   */* __restrict  */)" %-6s", tmp___1);
#line 9054
  tmp___2 = get_symbol_visibility((unsigned int )((int )psym->st_other & 3));
#line 9054
  printf((char const   */* __restrict  */)" %-7s", tmp___2);
  }
#line 9059
  if ((int )psym->st_other ^ ((int )psym->st_other & 3)) {
    {
#line 9060
    tmp___3 = get_symbol_other((unsigned int )((int )psym->st_other ^ ((int )psym->st_other & 3)));
#line 9060
    printf((char const   */* __restrict  */)" [%s] ", tmp___3);
    }
  }
  {
#line 9061
  tmp___4 = get_symbol_index_type(psym->st_shndx);
#line 9061
  printf((char const   */* __restrict  */)" %3.3s ", tmp___4);
  }
#line 9062
  if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 9062
    if (psym->st_name < dynamic_strings_length) {
      {
#line 9063
      print_symbol(25, (char const   *)(dynamic_strings + psym->st_name));
      }
    } else {
      {
#line 9065
      tmp___5 = gettext(" <corrupt: %14ld>");
#line 9065
      printf((char const   */* __restrict  */)tmp___5, psym->st_name);
      }
    }
  } else {
    {
#line 9065
    tmp___5 = gettext(" <corrupt: %14ld>");
#line 9065
    printf((char const   */* __restrict  */)tmp___5, psym->st_name);
    }
  }
  {
#line 9066
  putchar('\n');
  }
#line 9067
  return;
}
}
#line 9070 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_symbol_table(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  bfd_vma nbuckets ;
  bfd_vma nchains ;
  bfd_vma *buckets ;
  bfd_vma *chains ;
  bfd_vma ngnubuckets ;
  bfd_vma *gnubuckets ;
  bfd_vma *gnuchains ;
  bfd_vma gnusymidx ;
  unsigned char nb[8] ;
  unsigned char nc[8] ;
  int hash_ent_size ;
  char *tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  unsigned char nb___0[16] ;
  bfd_vma i ;
  bfd_vma maxchain ;
  bfd_vma bitmaskwords ;
  bfd_vma buckets_vma ;
  char *tmp___9 ;
  long tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  elf_vma tmp___14 ;
  elf_vma tmp___15 ;
  elf_vma tmp___16 ;
  char *tmp___17 ;
  long tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  elf_vma tmp___25 ;
  char *tmp___26 ;
  long tmp___27 ;
  int tmp___28 ;
  unsigned long hn ;
  bfd_vma si ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  bfd_vma si___0 ;
  bfd_vma off ;
  bfd_vma tmp___35 ;
  unsigned int i___0 ;
  unsigned int si___1 ;
  char *strtab ;
  unsigned long strtab_size ;
  Elf_Internal_Sym *symtab ;
  Elf_Internal_Sym *psym ;
  unsigned long num_syms ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  Elf_Internal_Sym *tmp___52 ;
  Elf_Internal_Sym *tmp___53 ;
  Elf_Internal_Shdr *string_sec ;
  char *tmp___54 ;
  void *tmp___55 ;
  char const   *tmp___56 ;
  char const   *tmp___57 ;
  char const   *tmp___58 ;
  char const   *tmp___59 ;
  char const   *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  unsigned char data[2] ;
  unsigned short vers_data ;
  unsigned long offset ;
  int is_nobits ;
  int check_def ;
  long tmp___63 ;
  char *tmp___64 ;
  void *tmp___65 ;
  elf_vma tmp___66 ;
  int tmp___67 ;
  Elf_External_Verneed evn ;
  Elf_Internal_Verneed ivn ;
  Elf_Internal_Vernaux ivna ;
  long tmp___68 ;
  unsigned long vna_off ;
  char *tmp___69 ;
  void *tmp___70 ;
  elf_vma tmp___71 ;
  elf_vma tmp___72 ;
  Elf_External_Vernaux evna ;
  elf_vma tmp___73 ;
  elf_vma tmp___74 ;
  elf_vma tmp___75 ;
  char *tmp___76 ;
  void *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  Elf_Internal_Verdef ivd ;
  Elf_Internal_Verdaux ivda ;
  Elf_External_Verdaux evda ;
  unsigned long off___0 ;
  long tmp___81 ;
  Elf_External_Verdef evd ;
  elf_vma tmp___82 ;
  elf_vma tmp___83 ;
  elf_vma tmp___84 ;
  char *tmp___85 ;
  void *tmp___86 ;
  char *tmp___87 ;
  void *tmp___88 ;
  elf_vma tmp___89 ;
  char *tmp___90 ;
  char *tmp___91 ;
  char const   *tmp___92 ;
  char *tmp___93 ;
  unsigned long *lengths ;
  unsigned long *counts ;
  unsigned long hn___0 ;
  bfd_vma si___2 ;
  unsigned long maxlength ;
  unsigned long nzero_counts ;
  unsigned long nsyms ;
  char *tmp___94 ;
  char *tmp___95 ;
  void *tmp___96 ;
  char *tmp___97 ;
  void *tmp___98 ;
  char *tmp___99 ;
  unsigned long i___1 ;
  unsigned long *lengths___0 ;
  unsigned long *counts___0 ;
  unsigned long hn___1 ;
  unsigned long maxlength___0 ;
  unsigned long nzero_counts___0 ;
  unsigned long nsyms___0 ;
  void *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  bfd_vma off___1 ;
  bfd_vma length ;
  void *tmp___104 ;
  char *tmp___105 ;
  unsigned long j ;

  {
#line 9074
  nbuckets = (bfd_vma )0;
#line 9075
  nchains = (bfd_vma )0;
#line 9076
  buckets = (bfd_vma *)((void *)0);
#line 9077
  chains = (bfd_vma *)((void *)0);
#line 9078
  ngnubuckets = (bfd_vma )0;
#line 9079
  gnubuckets = (bfd_vma *)((void *)0);
#line 9080
  gnuchains = (bfd_vma *)((void *)0);
#line 9081
  gnusymidx = (bfd_vma )0;
#line 9083
  if (! do_syms) {
#line 9083
    if (! do_dyn_syms) {
#line 9083
      if (! do_histogram) {
#line 9084
        return (1);
      }
    }
  }
#line 9086
  if (dynamic_info[4]) {
#line 9086
    if (do_histogram) {
#line 9086
      goto _L___1;
    } else
#line 9086
    if (do_using_dynamic) {
#line 9086
      if (! do_dyn_syms) {
#line 9086
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
          _L___1: /* CIL Label */ 
#line 9094
          hash_ent_size = 4;
#line 9096
          if ((int )elf_header.e_machine == 36902) {
#line 9096
            goto _L;
          } else
#line 9096
          if ((int )elf_header.e_machine == 22) {
#line 9096
            goto _L;
          } else
#line 9096
          if ((int )elf_header.e_machine == 41872) {
            _L: /* CIL Label */ 
#line 9096
            if ((int )elf_header.e_ident[4] == 2) {
#line 9100
              hash_ent_size = 8;
            }
          }
          {
#line 9102
          tmp___1 = offset_from_vma(file, dynamic_info[4], sizeof(nb) + sizeof(nc));
#line 9102
          tmp___2 = fseek(file, archive_file_offset + tmp___1, 0);
          }
#line 9102
          if (tmp___2) {
            {
#line 9108
            tmp___0 = gettext("Unable to seek to start of dynamic information\n");
#line 9108
            error((char const   *)tmp___0);
            }
#line 9109
            goto no_hash;
          }
          {
#line 9112
          tmp___4 = fread((void */* __restrict  */)(nb), (size_t )hash_ent_size, (size_t )1,
                          (FILE */* __restrict  */)file);
          }
#line 9112
          if (tmp___4 != 1UL) {
            {
#line 9114
            tmp___3 = gettext("Failed to read in number of buckets\n");
#line 9114
            error((char const   *)tmp___3);
            }
#line 9115
            goto no_hash;
          }
          {
#line 9118
          tmp___6 = fread((void */* __restrict  */)(nc), (size_t )hash_ent_size, (size_t )1,
                          (FILE */* __restrict  */)file);
          }
#line 9118
          if (tmp___6 != 1UL) {
            {
#line 9120
            tmp___5 = gettext("Failed to read in number of chains\n");
#line 9120
            error((char const   *)tmp___5);
            }
#line 9121
            goto no_hash;
          }
          {
#line 9124
          tmp___7 = (*byte_get)(nb, hash_ent_size);
#line 9124
          nbuckets = (bfd_vma )tmp___7;
#line 9125
          tmp___8 = (*byte_get)(nc, hash_ent_size);
#line 9125
          nchains = (bfd_vma )tmp___8;
#line 9127
          buckets = get_dynamic_data(file, (unsigned int )nbuckets, (unsigned int )hash_ent_size);
#line 9128
          chains = get_dynamic_data(file, (unsigned int )nchains, (unsigned int )hash_ent_size);
          }
          no_hash: 
#line 9131
          if ((unsigned long )buckets == (unsigned long )((void *)0)) {
#line 9131
            goto _L___0;
          } else
#line 9131
          if ((unsigned long )chains == (unsigned long )((void *)0)) {
            _L___0: /* CIL Label */ 
#line 9133
            if (do_using_dynamic) {
#line 9134
              return (0);
            }
            {
#line 9135
            free((void *)buckets);
#line 9136
            free((void *)chains);
#line 9137
            buckets = (bfd_vma *)((void *)0);
#line 9138
            chains = (bfd_vma *)((void *)0);
#line 9139
            nbuckets = (bfd_vma )0;
#line 9140
            nchains = (bfd_vma )0;
            }
          }
        }
      }
    }
  }
#line 9144
  if (dynamic_info_DT_GNU_HASH) {
#line 9144
    if (do_histogram) {
#line 9144
      goto _L___2;
    } else
#line 9144
    if (do_using_dynamic) {
#line 9144
      if (! do_dyn_syms) {
#line 9144
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
          _L___2: /* CIL Label */ 
          {
#line 9151
          maxchain = (bfd_vma )4294967295U;
#line 9154
          tmp___10 = offset_from_vma(file, dynamic_info_DT_GNU_HASH, sizeof(nb___0));
#line 9154
          tmp___11 = fseek(file, archive_file_offset + tmp___10, 0);
          }
#line 9154
          if (tmp___11) {
            {
#line 9160
            tmp___9 = gettext("Unable to seek to start of dynamic information\n");
#line 9160
            error((char const   *)tmp___9);
            }
#line 9161
            goto no_gnu_hash;
          }
          {
#line 9164
          tmp___13 = fread((void */* __restrict  */)(nb___0), (size_t )16, (size_t )1,
                           (FILE */* __restrict  */)file);
          }
#line 9164
          if (tmp___13 != 1UL) {
            {
#line 9166
            tmp___12 = gettext("Failed to read in number of buckets\n");
#line 9166
            error((char const   *)tmp___12);
            }
#line 9167
            goto no_gnu_hash;
          }
          {
#line 9170
          tmp___14 = (*byte_get)(nb___0, 4);
#line 9170
          ngnubuckets = (bfd_vma )tmp___14;
#line 9171
          tmp___15 = (*byte_get)(nb___0 + 4, 4);
#line 9171
          gnusymidx = (bfd_vma )tmp___15;
#line 9172
          tmp___16 = (*byte_get)(nb___0 + 8, 4);
#line 9172
          bitmaskwords = (bfd_vma )tmp___16;
#line 9173
          buckets_vma = dynamic_info_DT_GNU_HASH + 16UL;
          }
#line 9174
          if (is_32bit_elf) {
#line 9175
            buckets_vma += bitmaskwords * 4UL;
          } else {
#line 9177
            buckets_vma += bitmaskwords * 8UL;
          }
          {
#line 9179
          tmp___18 = offset_from_vma(file, buckets_vma, (bfd_size_type )4);
#line 9179
          tmp___19 = fseek(file, archive_file_offset + tmp___18, 0);
          }
#line 9179
          if (tmp___19) {
            {
#line 9184
            tmp___17 = gettext("Unable to seek to start of dynamic information\n");
#line 9184
            error((char const   *)tmp___17);
            }
#line 9185
            goto no_gnu_hash;
          }
          {
#line 9188
          gnubuckets = get_dynamic_data(file, (unsigned int )ngnubuckets, 4U);
          }
#line 9190
          if ((unsigned long )gnubuckets == (unsigned long )((void *)0)) {
#line 9191
            goto no_gnu_hash;
          }
#line 9193
          i = (bfd_vma )0;
          {
#line 9193
          while (1) {
            while_continue: /* CIL Label */ ;
#line 9193
            if (! (i < ngnubuckets)) {
#line 9193
              goto while_break;
            }
#line 9194
            if (*(gnubuckets + i) != 0UL) {
#line 9196
              if (*(gnubuckets + i) < gnusymidx) {
#line 9197
                return (0);
              }
#line 9199
              if (maxchain == 4294967295UL) {
#line 9200
                maxchain = *(gnubuckets + i);
              } else
#line 9199
              if (*(gnubuckets + i) > maxchain) {
#line 9200
                maxchain = *(gnubuckets + i);
              }
            }
#line 9193
            i ++;
          }
          while_break: /* CIL Label */ ;
          }
#line 9203
          if (maxchain == 4294967295UL) {
#line 9204
            goto no_gnu_hash;
          }
          {
#line 9206
          maxchain -= gnusymidx;
#line 9208
          tmp___21 = offset_from_vma(file, buckets_vma + 4UL * (ngnubuckets + maxchain),
                                     (bfd_size_type )4);
#line 9208
          tmp___22 = fseek(file, archive_file_offset + tmp___21, 0);
          }
#line 9208
          if (tmp___22) {
            {
#line 9214
            tmp___20 = gettext("Unable to seek to start of dynamic information\n");
#line 9214
            error((char const   *)tmp___20);
            }
#line 9215
            goto no_gnu_hash;
          }
          {
#line 9218
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 9220
            tmp___24 = fread((void */* __restrict  */)(nb___0), (size_t )4, (size_t )1,
                             (FILE */* __restrict  */)file);
            }
#line 9220
            if (tmp___24 != 1UL) {
              {
#line 9222
              tmp___23 = gettext("Failed to determine last chain length\n");
#line 9222
              error((char const   *)tmp___23);
              }
#line 9223
              goto no_gnu_hash;
            }
#line 9226
            if (maxchain + 1UL == 0UL) {
#line 9227
              goto no_gnu_hash;
            }
            {
#line 9229
            maxchain ++;
#line 9218
            tmp___25 = (*byte_get)(nb___0, 4);
            }
#line 9218
            if (! ((tmp___25 & 1ULL) == 0ULL)) {
#line 9218
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 9233
          tmp___27 = offset_from_vma(file, buckets_vma + 4UL * ngnubuckets, (bfd_size_type )4);
#line 9233
          tmp___28 = fseek(file, archive_file_offset + tmp___27, 0);
          }
#line 9233
          if (tmp___28) {
            {
#line 9238
            tmp___26 = gettext("Unable to seek to start of dynamic information\n");
#line 9238
            error((char const   *)tmp___26);
            }
#line 9239
            goto no_gnu_hash;
          }
          {
#line 9242
          gnuchains = get_dynamic_data(file, (unsigned int )maxchain, 4U);
          }
          no_gnu_hash: 
#line 9245
          if ((unsigned long )gnuchains == (unsigned long )((void *)0)) {
            {
#line 9247
            free((void *)gnubuckets);
#line 9248
            gnubuckets = (bfd_vma *)((void *)0);
#line 9249
            ngnubuckets = (bfd_vma )0;
            }
#line 9250
            if (do_using_dynamic) {
#line 9251
              return (0);
            }
          }
        }
      }
    }
  }
#line 9255
  if (dynamic_info[4]) {
#line 9255
    goto _L___11;
  } else
#line 9255
  if (dynamic_info_DT_GNU_HASH) {
    _L___11: /* CIL Label */ 
#line 9255
    if (do_syms) {
#line 9255
      if (do_using_dynamic) {
#line 9255
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 9262
          if (dynamic_info[4]) {
            {
#line 9266
            tmp___29 = gettext("\nSymbol table for image:\n");
#line 9266
            printf((char const   */* __restrict  */)tmp___29);
            }
#line 9267
            if (is_32bit_elf) {
              {
#line 9268
              tmp___30 = gettext("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n");
#line 9268
              printf((char const   */* __restrict  */)tmp___30);
              }
            } else {
              {
#line 9270
              tmp___31 = gettext("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n");
#line 9270
              printf((char const   */* __restrict  */)tmp___31);
              }
            }
#line 9272
            hn = 0UL;
            {
#line 9272
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 9272
              if (! (hn < nbuckets)) {
#line 9272
                goto while_break___1;
              }
#line 9274
              if (! *(buckets + hn)) {
#line 9275
                goto __Cont;
              }
#line 9277
              si = *(buckets + hn);
              {
#line 9277
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 9277
                if (si < nchains) {
#line 9277
                  if (! (si > 0UL)) {
#line 9277
                    goto while_break___2;
                  }
                } else {
#line 9277
                  goto while_break___2;
                }
                {
#line 9278
                print_dynamic_symbol(si, hn);
#line 9277
                si = *(chains + si);
                }
              }
              while_break___2: /* CIL Label */ ;
              }
              __Cont: /* CIL Label */ 
#line 9272
              hn ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 9282
          if (dynamic_info_DT_GNU_HASH) {
            {
#line 9284
            tmp___32 = gettext("\nSymbol table of `.gnu.hash\' for image:\n");
#line 9284
            printf((char const   */* __restrict  */)tmp___32);
            }
#line 9285
            if (is_32bit_elf) {
              {
#line 9286
              tmp___33 = gettext("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n");
#line 9286
              printf((char const   */* __restrict  */)tmp___33);
              }
            } else {
              {
#line 9288
              tmp___34 = gettext("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n");
#line 9288
              printf((char const   */* __restrict  */)tmp___34);
              }
            }
#line 9290
            hn = 0UL;
            {
#line 9290
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 9290
              if (! (hn < ngnubuckets)) {
#line 9290
                goto while_break___3;
              }
#line 9291
              if (*(gnubuckets + hn) != 0UL) {
#line 9293
                si___0 = *(gnubuckets + hn);
#line 9294
                off = si___0 - gnusymidx;
                {
#line 9296
                while (1) {
                  while_continue___4: /* CIL Label */ ;
                  {
#line 9298
                  print_dynamic_symbol(si___0, hn);
#line 9299
                  si___0 ++;
#line 9296
                  tmp___35 = off;
#line 9296
                  off ++;
                  }
#line 9296
                  if (! ((*(gnuchains + tmp___35) & 1UL) == 0UL)) {
#line 9296
                    goto while_break___4;
                  }
                }
                while_break___4: /* CIL Label */ ;
                }
              }
#line 9290
              hn ++;
            }
            while_break___3: /* CIL Label */ ;
            }
          }
        } else {
#line 9255
          goto _L___10;
        }
      } else {
#line 9255
        goto _L___10;
      }
    } else {
#line 9255
      goto _L___10;
    }
  } else
  _L___10: /* CIL Label */ 
#line 9305
  if (do_dyn_syms) {
#line 9305
    goto _L___6;
  } else
#line 9305
  if (do_syms) {
#line 9305
    if (! do_using_dynamic) {
      _L___6: /* CIL Label */ 
#line 9309
      i___0 = 0U;
#line 9309
      section = section_headers;
      {
#line 9309
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 9309
        if (! (i___0 < elf_header.e_shnum)) {
#line 9309
          goto while_break___5;
        }
#line 9314
        strtab = (char *)((void *)0);
#line 9315
        strtab_size = 0UL;
#line 9320
        if (section->sh_type != 2U) {
#line 9320
          if (section->sh_type != 11U) {
#line 9324
            goto __Cont___0;
          } else {
#line 9320
            goto _L___3;
          }
        } else
        _L___3: /* CIL Label */ 
#line 9320
        if (! do_syms) {
#line 9320
          if (section->sh_type == 2U) {
#line 9324
            goto __Cont___0;
          }
        }
#line 9326
        if (section->sh_entsize == 0UL) {
#line 9328
          if ((unsigned long )section == (unsigned long )((void *)0)) {
            {
#line 9328
            tmp___36 = gettext("<none>");
#line 9328
            tmp___41 = tmp___36;
            }
          } else {
#line 9328
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 9328
              tmp___37 = gettext("<no-name>");
#line 9328
              tmp___40 = tmp___37;
              }
            } else {
#line 9328
              if ((unsigned long )section->sh_name >= string_table_length) {
                {
#line 9328
                tmp___38 = gettext("<corrupt>");
#line 9328
                tmp___39 = tmp___38;
                }
              } else {
#line 9328
                tmp___39 = string_table + section->sh_name;
              }
#line 9328
              tmp___40 = tmp___39;
            }
#line 9328
            tmp___41 = tmp___40;
          }
          {
#line 9328
          tmp___42 = gettext("\nSymbol table \'%s\' has a sh_entsize of zero!\n");
#line 9328
          printf((char const   */* __restrict  */)tmp___42, tmp___41);
          }
#line 9330
          goto __Cont___0;
        }
#line 9333
        if ((unsigned long )section == (unsigned long )((void *)0)) {
          {
#line 9333
          tmp___43 = gettext("<none>");
#line 9333
          tmp___48 = tmp___43;
          }
        } else {
#line 9333
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 9333
            tmp___44 = gettext("<no-name>");
#line 9333
            tmp___47 = tmp___44;
            }
          } else {
#line 9333
            if ((unsigned long )section->sh_name >= string_table_length) {
              {
#line 9333
              tmp___45 = gettext("<corrupt>");
#line 9333
              tmp___46 = tmp___45;
              }
            } else {
#line 9333
              tmp___46 = string_table + section->sh_name;
            }
#line 9333
            tmp___47 = tmp___46;
          }
#line 9333
          tmp___48 = tmp___47;
        }
        {
#line 9333
        tmp___49 = gettext("\nSymbol table \'%s\' contains %lu entries:\n");
#line 9333
        printf((char const   */* __restrict  */)tmp___49, tmp___48, section->sh_size / section->sh_entsize);
        }
#line 9337
        if (is_32bit_elf) {
          {
#line 9338
          tmp___50 = gettext("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n");
#line 9338
          printf((char const   */* __restrict  */)tmp___50);
          }
        } else {
          {
#line 9340
          tmp___51 = gettext("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n");
#line 9340
          printf((char const   */* __restrict  */)tmp___51);
          }
        }
#line 9342
        if (is_32bit_elf) {
          {
#line 9342
          tmp___52 = get_32bit_elf_symbols(file, section, & num_syms);
#line 9342
          symtab = tmp___52;
          }
        } else {
          {
#line 9342
          tmp___53 = get_64bit_elf_symbols(file, section, & num_syms);
#line 9342
          symtab = tmp___53;
          }
        }
#line 9343
        if ((unsigned long )symtab == (unsigned long )((void *)0)) {
#line 9344
          goto __Cont___0;
        }
#line 9346
        if (section->sh_link == elf_header.e_shstrndx) {
#line 9348
          strtab = string_table;
#line 9349
          strtab_size = string_table_length;
        } else
#line 9351
        if (section->sh_link < elf_header.e_shnum) {
          {
#line 9355
          string_sec = section_headers + section->sh_link;
#line 9357
          tmp___54 = gettext("string table");
#line 9357
          tmp___55 = get_data((void *)0, file, string_sec->sh_offset, (size_t )1,
                              string_sec->sh_size, (char const   *)tmp___54);
#line 9357
          strtab = (char *)tmp___55;
          }
#line 9360
          if ((unsigned long )strtab != (unsigned long )((void *)0)) {
#line 9360
            strtab_size = string_sec->sh_size;
          } else {
#line 9360
            strtab_size = 0UL;
          }
        }
#line 9363
        si___1 = 0U;
#line 9363
        psym = symtab;
        {
#line 9363
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 9363
          if (! ((unsigned long )si___1 < num_syms)) {
#line 9363
            goto while_break___6;
          }
          {
#line 9365
          printf((char const   */* __restrict  */)"%6d: ", si___1);
#line 9366
          print_vma(psym->st_value, (print_mode )6);
#line 9367
          putchar(' ');
#line 9368
          print_vma(psym->st_size, (print_mode )2);
#line 9369
          tmp___56 = get_symbol_type((unsigned int )((int )psym->st_info & 15));
#line 9369
          printf((char const   */* __restrict  */)" %-7s", tmp___56);
#line 9370
          tmp___57 = get_symbol_binding((unsigned int )psym->st_info >> 4);
#line 9370
          printf((char const   */* __restrict  */)" %-6s", tmp___57);
#line 9371
          tmp___58 = get_symbol_visibility((unsigned int )((int )psym->st_other & 3));
#line 9371
          printf((char const   */* __restrict  */)" %-7s", tmp___58);
          }
#line 9375
          if ((int )psym->st_other ^ ((int )psym->st_other & 3)) {
            {
#line 9376
            tmp___59 = get_symbol_other((unsigned int )((int )psym->st_other ^ ((int )psym->st_other & 3)));
#line 9376
            printf((char const   */* __restrict  */)" [%s] ", tmp___59);
            }
          }
          {
#line 9377
          tmp___60 = get_symbol_index_type(psym->st_shndx);
#line 9377
          printf((char const   */* __restrict  */)" %4s ", tmp___60);
          }
#line 9378
          if (psym->st_name < strtab_size) {
#line 9378
            tmp___62 = strtab + psym->st_name;
          } else {
            {
#line 9378
            tmp___61 = gettext("<corrupt>");
#line 9378
            tmp___62 = tmp___61;
            }
          }
          {
#line 9378
          print_symbol(25, (char const   *)tmp___62);
          }
#line 9381
          if (section->sh_type == 11U) {
#line 9381
            if (version_info[15] != 0UL) {
              {
#line 9390
              tmp___63 = offset_from_vma(file, version_info[15], sizeof(data) + (unsigned long )si___1 * sizeof(vers_data));
#line 9390
              offset = (unsigned long )tmp___63;
#line 9394
              tmp___64 = gettext("version data");
#line 9394
              tmp___65 = get_data((void *)(& data), file, (long )(offset + (unsigned long )si___1 * sizeof(vers_data)),
                                  sizeof(data), (size_t )1, (char const   *)tmp___64);
              }
#line 9394
              if ((unsigned long )tmp___65 == (unsigned long )((void *)0)) {
#line 9396
                goto while_break___6;
              }
              {
#line 9398
              tmp___66 = (*byte_get)(data, 2);
#line 9398
              vers_data = (unsigned short )tmp___66;
              }
#line 9400
              if (psym->st_shndx < elf_header.e_shnum) {
#line 9400
                if ((section_headers + psym->st_shndx)->sh_type == 8U) {
#line 9400
                  tmp___67 = 1;
                } else {
#line 9400
                  tmp___67 = 0;
                }
              } else {
#line 9400
                tmp___67 = 0;
              }
#line 9400
              is_nobits = tmp___67;
#line 9404
              check_def = psym->st_shndx != 0U;
#line 9406
              if ((int )vers_data & 32768) {
#line 9406
                goto _L___5;
              } else
#line 9406
              if ((int )vers_data > 1) {
                _L___5: /* CIL Label */ 
#line 9408
                if (version_info[1]) {
#line 9408
                  if (is_nobits) {
#line 9408
                    goto _L___4;
                  } else
#line 9408
                  if (! check_def) {
                    _L___4: /* CIL Label */ 
                    {
#line 9416
                    tmp___68 = offset_from_vma(file, version_info[1], sizeof(evn));
#line 9416
                    offset = (unsigned long )tmp___68;
                    }
                    {
#line 9420
                    while (1) {
                      while_continue___7: /* CIL Label */ ;
                      {
#line 9424
                      tmp___69 = gettext("version need");
#line 9424
                      tmp___70 = get_data((void *)(& evn), file, (long )offset, sizeof(evn),
                                          (size_t )1, (char const   *)tmp___69);
                      }
#line 9424
                      if ((unsigned long )tmp___70 == (unsigned long )((void *)0)) {
#line 9427
                        ivna.vna_next = 0UL;
#line 9428
                        ivna.vna_other = (unsigned short)0;
#line 9429
                        ivna.vna_name = 0UL;
#line 9430
                        goto while_break___7;
                      }
                      {
#line 9433
                      tmp___71 = (*byte_get)(evn.vn_aux, (int )sizeof(evn.vn_aux));
#line 9433
                      ivn.vn_aux = (unsigned long )tmp___71;
#line 9434
                      tmp___72 = (*byte_get)(evn.vn_next, (int )sizeof(evn.vn_next));
#line 9434
                      ivn.vn_next = (unsigned long )tmp___72;
#line 9436
                      vna_off = offset + ivn.vn_aux;
                      }
                      {
#line 9438
                      while (1) {
                        while_continue___8: /* CIL Label */ ;
                        {
#line 9442
                        tmp___76 = gettext("version need aux (3)");
#line 9442
                        tmp___77 = get_data((void *)(& evna), file, (long )vna_off,
                                            sizeof(evna), (size_t )1, (char const   *)tmp___76);
                        }
#line 9442
                        if ((unsigned long )tmp___77 == (unsigned long )((void *)0)) {
#line 9446
                          ivna.vna_next = 0UL;
#line 9447
                          ivna.vna_other = (unsigned short)0;
#line 9448
                          ivna.vna_name = 0UL;
                        } else {
                          {
#line 9452
                          tmp___73 = (*byte_get)(evna.vna_other, (int )sizeof(evna.vna_other));
#line 9452
                          ivna.vna_other = (unsigned short )tmp___73;
#line 9453
                          tmp___74 = (*byte_get)(evna.vna_next, (int )sizeof(evna.vna_next));
#line 9453
                          ivna.vna_next = (unsigned long )tmp___74;
#line 9454
                          tmp___75 = (*byte_get)(evna.vna_name, (int )sizeof(evna.vna_name));
#line 9454
                          ivna.vna_name = (unsigned long )tmp___75;
                          }
                        }
#line 9457
                        vna_off += ivna.vna_next;
#line 9438
                        if ((int )ivna.vna_other != (int )vers_data) {
#line 9438
                          if (! (ivna.vna_next != 0UL)) {
#line 9438
                            goto while_break___8;
                          }
                        } else {
#line 9438
                          goto while_break___8;
                        }
                      }
                      while_break___8: /* CIL Label */ ;
                      }
#line 9462
                      if ((int )ivna.vna_other == (int )vers_data) {
#line 9463
                        goto while_break___7;
                      }
#line 9465
                      offset += ivn.vn_next;
#line 9420
                      if (! (ivn.vn_next != 0UL)) {
#line 9420
                        goto while_break___7;
                      }
                    }
                    while_break___7: /* CIL Label */ ;
                    }
#line 9469
                    if ((int )ivna.vna_other == (int )vers_data) {
#line 9471
                      if (ivna.vna_name < strtab_size) {
#line 9471
                        tmp___79 = strtab + ivna.vna_name;
                      } else {
                        {
#line 9471
                        tmp___78 = gettext("<corrupt>");
#line 9471
                        tmp___79 = tmp___78;
                        }
                      }
                      {
#line 9471
                      printf((char const   */* __restrict  */)"@%s (%d)", tmp___79,
                             (int )ivna.vna_other);
#line 9475
                      check_def = 0;
                      }
                    } else
#line 9477
                    if (! is_nobits) {
                      {
#line 9478
                      tmp___80 = gettext("bad dynamic symbol\n");
#line 9478
                      error((char const   *)tmp___80);
                      }
                    } else {
#line 9480
                      check_def = 1;
                    }
                  }
                }
#line 9483
                if (check_def) {
#line 9485
                  if ((int )vers_data != 32769) {
#line 9485
                    if (version_info[3]) {
                      {
#line 9493
                      tmp___81 = offset_from_vma(file, version_info[3], sizeof(Elf_External_Verdef ));
#line 9493
                      off___0 = (unsigned long )tmp___81;
                      }
                      {
#line 9498
                      while (1) {
                        while_continue___9: /* CIL Label */ ;
                        {
#line 9502
                        tmp___85 = gettext("version def");
#line 9502
                        tmp___86 = get_data((void *)(& evd), file, (long )off___0,
                                            sizeof(evd), (size_t )1, (char const   *)tmp___85);
                        }
#line 9502
                        if ((unsigned long )tmp___86 == (unsigned long )((void *)0)) {
#line 9505
                          ivd.vd_ndx = (unsigned short)0;
#line 9506
                          ivd.vd_aux = 0UL;
#line 9507
                          ivd.vd_next = 0UL;
                        } else {
                          {
#line 9511
                          tmp___82 = (*byte_get)(evd.vd_ndx, (int )sizeof(evd.vd_ndx));
#line 9511
                          ivd.vd_ndx = (unsigned short )tmp___82;
#line 9512
                          tmp___83 = (*byte_get)(evd.vd_aux, (int )sizeof(evd.vd_aux));
#line 9512
                          ivd.vd_aux = (unsigned long )tmp___83;
#line 9513
                          tmp___84 = (*byte_get)(evd.vd_next, (int )sizeof(evd.vd_next));
#line 9513
                          ivd.vd_next = (unsigned long )tmp___84;
                          }
                        }
#line 9516
                        off___0 += ivd.vd_next;
#line 9498
                        if ((int )ivd.vd_ndx != ((int )vers_data & 32767)) {
#line 9498
                          if (! (ivd.vd_next != 0UL)) {
#line 9498
                            goto while_break___9;
                          }
                        } else {
#line 9498
                          goto while_break___9;
                        }
                      }
                      while_break___9: /* CIL Label */ ;
                      }
                      {
#line 9521
                      off___0 -= ivd.vd_next;
#line 9522
                      off___0 += ivd.vd_aux;
#line 9524
                      tmp___87 = gettext("version def aux");
#line 9524
                      tmp___88 = get_data((void *)(& evda), file, (long )off___0,
                                          sizeof(evda), (size_t )1, (char const   *)tmp___87);
                      }
#line 9524
                      if ((unsigned long )tmp___88 == (unsigned long )((void *)0)) {
#line 9526
                        goto while_break___6;
                      }
                      {
#line 9528
                      tmp___89 = (*byte_get)(evda.vda_name, (int )sizeof(evda.vda_name));
#line 9528
                      ivda.vda_name = (unsigned long )tmp___89;
                      }
#line 9530
                      if (psym->st_name != ivda.vda_name) {
#line 9531
                        if (ivda.vda_name < strtab_size) {
#line 9531
                          tmp___91 = strtab + ivda.vda_name;
                        } else {
                          {
#line 9531
                          tmp___90 = gettext("<corrupt>");
#line 9531
                          tmp___91 = tmp___90;
                          }
                        }
#line 9531
                        if ((int )vers_data & 32768) {
#line 9531
                          tmp___92 = "@%s";
                        } else {
#line 9531
                          tmp___92 = "@@%s";
                        }
                        {
#line 9531
                        printf((char const   */* __restrict  */)tmp___92, tmp___91);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          {
#line 9540
          putchar('\n');
#line 9363
          si___1 ++;
#line 9363
          psym ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 9543
        free((void *)symtab);
        }
#line 9544
        if ((unsigned long )strtab != (unsigned long )string_table) {
          {
#line 9545
          free((void *)strtab);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 9309
        i___0 ++;
#line 9309
        section ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 9305
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 9548
  if (do_syms) {
    {
#line 9549
    tmp___93 = gettext("\nDynamic symbol information is not available for displaying symbols.\n");
#line 9549
    printf((char const   */* __restrict  */)tmp___93);
    }
  }
#line 9552
  if (do_histogram) {
#line 9552
    if ((unsigned long )buckets != (unsigned long )((void *)0)) {
      {
#line 9558
      maxlength = 0UL;
#line 9559
      nzero_counts = 0UL;
#line 9560
      nsyms = 0UL;
#line 9562
      tmp___94 = gettext("\nHistogram for bucket list length (total of %lu buckets):\n");
#line 9562
      printf((char const   */* __restrict  */)tmp___94, nbuckets);
#line 9564
      tmp___95 = gettext(" Length  Number     %% of total  Coverage\n");
#line 9564
      printf((char const   */* __restrict  */)tmp___95);
#line 9566
      tmp___96 = calloc(nbuckets, sizeof(*lengths));
#line 9566
      lengths = (unsigned long *)tmp___96;
      }
#line 9567
      if ((unsigned long )lengths == (unsigned long )((void *)0)) {
        {
#line 9569
        tmp___97 = gettext("Out of memory\n");
#line 9569
        error((char const   *)tmp___97);
        }
#line 9570
        return (0);
      }
#line 9572
      hn___0 = 0UL;
      {
#line 9572
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 9572
        if (! (hn___0 < nbuckets)) {
#line 9572
          goto while_break___10;
        }
#line 9574
        si___2 = *(buckets + hn___0);
        {
#line 9574
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 9574
          if (si___2 > 0UL) {
#line 9574
            if (! (si___2 < nchains)) {
#line 9574
              goto while_break___11;
            }
          } else {
#line 9574
            goto while_break___11;
          }
#line 9576
          nsyms ++;
#line 9577
          (*(lengths + hn___0)) ++;
#line 9577
          if (maxlength < *(lengths + hn___0)) {
#line 9578
            maxlength ++;
          }
#line 9574
          si___2 = *(chains + si___2);
        }
        while_break___11: /* CIL Label */ ;
        }
#line 9572
        hn___0 ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 9582
      tmp___98 = calloc(maxlength + 1UL, sizeof(*counts));
#line 9582
      counts = (unsigned long *)tmp___98;
      }
#line 9583
      if ((unsigned long )counts == (unsigned long )((void *)0)) {
        {
#line 9585
        tmp___99 = gettext("Out of memory\n");
#line 9585
        error((char const   *)tmp___99);
        }
#line 9586
        return (0);
      }
#line 9589
      hn___0 = 0UL;
      {
#line 9589
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 9589
        if (! (hn___0 < nbuckets)) {
#line 9589
          goto while_break___12;
        }
#line 9590
        (*(counts + *(lengths + hn___0))) ++;
#line 9589
        hn___0 ++;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 9592
      if (nbuckets > 0UL) {
        {
#line 9595
        printf((char const   */* __restrict  */)"      0  %-10lu (%5.1f%%)\n", *(counts + 0),
               ((double )*(counts + 0) * 100.0) / (double )nbuckets);
#line 9597
        i___1 = 1UL;
        }
        {
#line 9597
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 9597
          if (! (i___1 <= maxlength)) {
#line 9597
            goto while_break___13;
          }
          {
#line 9599
          nzero_counts += *(counts + i___1) * i___1;
#line 9600
          printf((char const   */* __restrict  */)"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
                 i___1, *(counts + i___1), ((double )*(counts + i___1) * 100.0) / (double )nbuckets,
                 ((double )nzero_counts * 100.0) / (double )nsyms);
#line 9597
          i___1 ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      {
#line 9606
      free((void *)counts);
#line 9607
      free((void *)lengths);
      }
    }
  }
#line 9610
  if ((unsigned long )buckets != (unsigned long )((void *)0)) {
    {
#line 9612
    free((void *)buckets);
#line 9613
    free((void *)chains);
    }
  }
#line 9616
  if (do_histogram) {
#line 9616
    if ((unsigned long )gnubuckets != (unsigned long )((void *)0)) {
      {
#line 9621
      maxlength___0 = 0UL;
#line 9622
      nzero_counts___0 = 0UL;
#line 9623
      nsyms___0 = 0UL;
#line 9625
      tmp___100 = calloc(ngnubuckets, sizeof(*lengths___0));
#line 9625
      lengths___0 = (unsigned long *)tmp___100;
      }
#line 9626
      if ((unsigned long )lengths___0 == (unsigned long )((void *)0)) {
        {
#line 9628
        tmp___101 = gettext("Out of memory\n");
#line 9628
        error((char const   *)tmp___101);
        }
#line 9629
        return (0);
      }
      {
#line 9632
      tmp___102 = gettext("\nHistogram for `.gnu.hash\' bucket list length (total of %lu buckets):\n");
#line 9632
      printf((char const   */* __restrict  */)tmp___102, ngnubuckets);
#line 9634
      tmp___103 = gettext(" Length  Number     %% of total  Coverage\n");
#line 9634
      printf((char const   */* __restrict  */)tmp___103);
#line 9636
      hn___1 = 0UL;
      }
      {
#line 9636
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 9636
        if (! (hn___1 < ngnubuckets)) {
#line 9636
          goto while_break___14;
        }
#line 9637
        if (*(gnubuckets + hn___1) != 0UL) {
#line 9639
          length = (bfd_vma )1;
#line 9641
          off___1 = *(gnubuckets + hn___1) - gnusymidx;
          {
#line 9641
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 9641
            if (! ((*(gnuchains + off___1) & 1UL) == 0UL)) {
#line 9641
              goto while_break___15;
            }
#line 9643
            length ++;
#line 9641
            off___1 ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 9644
          *(lengths___0 + hn___1) = length;
#line 9645
          if (length > maxlength___0) {
#line 9646
            maxlength___0 = length;
          }
#line 9647
          nsyms___0 += length;
        }
#line 9636
        hn___1 ++;
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 9650
      tmp___104 = calloc(maxlength___0 + 1UL, sizeof(*counts___0));
#line 9650
      counts___0 = (unsigned long *)tmp___104;
      }
#line 9651
      if ((unsigned long )counts___0 == (unsigned long )((void *)0)) {
        {
#line 9653
        tmp___105 = gettext("Out of memory\n");
#line 9653
        error((char const   *)tmp___105);
        }
#line 9654
        return (0);
      }
#line 9657
      hn___1 = 0UL;
      {
#line 9657
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 9657
        if (! (hn___1 < ngnubuckets)) {
#line 9657
          goto while_break___16;
        }
#line 9658
        (*(counts___0 + *(lengths___0 + hn___1))) ++;
#line 9657
        hn___1 ++;
      }
      while_break___16: /* CIL Label */ ;
      }
#line 9660
      if (ngnubuckets > 0UL) {
        {
#line 9663
        printf((char const   */* __restrict  */)"      0  %-10lu (%5.1f%%)\n", *(counts___0 + 0),
               ((double )*(counts___0 + 0) * 100.0) / (double )ngnubuckets);
#line 9665
        j = 1UL;
        }
        {
#line 9665
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 9665
          if (! (j <= maxlength___0)) {
#line 9665
            goto while_break___17;
          }
          {
#line 9667
          nzero_counts___0 += *(counts___0 + j) * j;
#line 9668
          printf((char const   */* __restrict  */)"%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
                 j, *(counts___0 + j), ((double )*(counts___0 + j) * 100.0) / (double )ngnubuckets,
                 ((double )nzero_counts___0 * 100.0) / (double )nsyms___0);
#line 9665
          j ++;
          }
        }
        while_break___17: /* CIL Label */ ;
        }
      }
      {
#line 9674
      free((void *)counts___0);
#line 9675
      free((void *)lengths___0);
#line 9676
      free((void *)gnubuckets);
#line 9677
      free((void *)gnuchains);
      }
    }
  }
#line 9680
  return (1);
}
}
#line 9683 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_syminfo(FILE *file  __attribute__((__unused__)) ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short flags___1 ;
  char *tmp___2 ;

  {
#line 9688
  if ((unsigned long )dynamic_syminfo == (unsigned long )((void *)0)) {
#line 9691
    return (1);
  } else
#line 9688
  if (! do_dynamic) {
#line 9691
    return (1);
  }
#line 9694
  if ((unsigned long )dynamic_symbols == (unsigned long )((void *)0)) {
#line 9695
    return (0);
  } else
#line 9694
  if ((unsigned long )dynamic_strings == (unsigned long )((void *)0)) {
#line 9695
    return (0);
  }
#line 9697
  if (dynamic_addr) {
    {
#line 9698
    tmp___0 = gettext("\nDynamic info segment at offset 0x%lx contains %d entries:\n");
#line 9698
    printf((char const   */* __restrict  */)tmp___0, dynamic_syminfo_offset, dynamic_syminfo_nent);
    }
  }
  {
#line 9701
  tmp___1 = gettext(" Num: Name                           BoundTo     Flags\n");
#line 9701
  printf((char const   */* __restrict  */)tmp___1);
#line 9702
  i = 0U;
  }
  {
#line 9702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 9702
    if (! (i < dynamic_syminfo_nent)) {
#line 9702
      goto while_break;
    }
    {
#line 9704
    flags___1 = (dynamic_syminfo + i)->si_flags;
#line 9706
    printf((char const   */* __restrict  */)"%4d: ", i);
    }
#line 9707
    if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 9707
      if ((dynamic_symbols + i)->st_name < dynamic_strings_length) {
        {
#line 9708
        print_symbol(30, (char const   *)(dynamic_strings + (dynamic_symbols + i)->st_name));
        }
      } else {
        {
#line 9710
        tmp___2 = gettext("<corrupt: %19ld>");
#line 9710
        printf((char const   */* __restrict  */)tmp___2, (dynamic_symbols + i)->st_name);
        }
      }
    } else {
      {
#line 9710
      tmp___2 = gettext("<corrupt: %19ld>");
#line 9710
      printf((char const   */* __restrict  */)tmp___2, (dynamic_symbols + i)->st_name);
      }
    }
    {
#line 9711
    putchar(' ');
    }
    {
#line 9715
    if ((int )(dynamic_syminfo + i)->si_boundto == 65535) {
#line 9715
      goto case_65535;
    }
#line 9718
    if ((int )(dynamic_syminfo + i)->si_boundto == 65534) {
#line 9718
      goto case_65534;
    }
#line 9721
    goto switch_default;
    case_65535: /* CIL Label */ 
    {
#line 9716
    fputs((char const   */* __restrict  */)"SELF       ", (FILE */* __restrict  */)stdout);
    }
#line 9717
    goto switch_break;
    case_65534: /* CIL Label */ 
    {
#line 9719
    fputs((char const   */* __restrict  */)"PARENT     ", (FILE */* __restrict  */)stdout);
    }
#line 9720
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 9722
    if ((int )(dynamic_syminfo + i)->si_boundto > 0) {
#line 9722
      if ((unsigned int )(dynamic_syminfo + i)->si_boundto < dynamic_nent) {
#line 9722
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 9722
          if ((dynamic_section + (dynamic_syminfo + i)->si_boundto)->d_un.d_val < dynamic_strings_length) {
            {
#line 9726
            print_symbol(10, (char const   *)(dynamic_strings + (dynamic_section + (dynamic_syminfo + i)->si_boundto)->d_un.d_val));
#line 9727
            putchar(' ');
            }
          } else {
            {
#line 9730
            printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
            }
          }
        } else {
          {
#line 9730
          printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
          }
        }
      } else {
        {
#line 9730
        printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
        }
      }
    } else {
      {
#line 9730
      printf((char const   */* __restrict  */)"%-10d ", (int )(dynamic_syminfo + i)->si_boundto);
      }
    }
#line 9731
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 9734
    if ((int )flags___1 & 1) {
      {
#line 9735
      printf((char const   */* __restrict  */)" DIRECT");
      }
    }
#line 9736
    if ((int )flags___1 & 2) {
      {
#line 9737
      printf((char const   */* __restrict  */)" PASSTHRU");
      }
    }
#line 9738
    if ((int )flags___1 & 4) {
      {
#line 9739
      printf((char const   */* __restrict  */)" COPY");
      }
    }
#line 9740
    if ((int )flags___1 & 8) {
      {
#line 9741
      printf((char const   */* __restrict  */)" LAZYLOAD");
      }
    }
    {
#line 9743
    puts("");
#line 9702
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 9746
  return (1);
}
}
#line 9765
static bfd_boolean target_specific_reloc_handling(Elf_Internal_Rela *reloc , unsigned char *start ,
                                                  Elf_Internal_Sym *symtab ) ;
#line 9765 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static Elf_Internal_Sym *saved_sym  =    (Elf_Internal_Sym *)((void *)0);
#line 9753 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean target_specific_reloc_handling(Elf_Internal_Rela *reloc , unsigned char *start ,
                                                  Elf_Internal_Sym *symtab ) 
{ 
  unsigned int reloc_type ;
  unsigned int tmp___0 ;
  bfd_vma tmp___1 ;
  bfd_vma value ;
  bfd_vma tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 9758
  tmp___0 = get_reloc_type(reloc->r_info);
#line 9758
  reloc_type = tmp___0;
  }
  {
#line 9763
  if ((int )elf_header.e_machine == 48879) {
#line 9763
    goto case_48879;
  }
#line 9763
  if ((int )elf_header.e_machine == 89) {
#line 9763
    goto case_48879;
  }
#line 9760
  goto switch_break;
  case_48879: /* CIL Label */ 
  case_89: /* CIL Label */ 
  {
#line 9769
  if (reloc_type == 34U) {
#line 9769
    goto case_34;
  }
#line 9771
  if (reloc_type == 33U) {
#line 9771
    goto case_33;
  }
#line 9775
  if (reloc_type == 2U) {
#line 9775
    goto case_2;
  }
#line 9775
  if (reloc_type == 1U) {
#line 9775
    goto case_2;
  }
#line 9790
  goto switch_default;
  case_34: /* CIL Label */ 
#line 9770
  return (1);
  case_33: /* CIL Label */ 
  {
#line 9772
  tmp___1 = get_reloc_symindex(reloc->r_info);
#line 9772
  saved_sym = symtab + tmp___1;
  }
#line 9773
  return (1);
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 9776
  if ((unsigned long )saved_sym != (unsigned long )((void *)0)) {
    {
#line 9780
    tmp___2 = get_reloc_symindex(reloc->r_info);
#line 9780
    value = reloc->r_addend + ((symtab + tmp___2)->st_value - saved_sym->st_value);
    }
#line 9784
    if (reloc_type == 1U) {
#line 9784
      tmp___3 = 4;
    } else {
#line 9784
      tmp___3 = 2;
    }
    {
#line 9784
    (*byte_put)(start + reloc->r_offset, (elf_vma )value, tmp___3);
#line 9786
    saved_sym = (Elf_Internal_Sym *)((void *)0);
    }
#line 9787
    return (1);
  }
#line 9789
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 9791
  if ((unsigned long )saved_sym != (unsigned long )((void *)0)) {
    {
#line 9792
    tmp___4 = gettext("Unhandled MN10300 reloc type found after SYM_DIFF reloc");
#line 9792
    error((char const   *)tmp___4);
    }
  }
#line 9793
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 9795
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 9799
  return (0);
}
}
#line 9813 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_32bit_abs_reloc(unsigned int reloc_type ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 9819
  if ((int )elf_header.e_machine == 6) {
#line 9819
    goto case_6;
  }
#line 9819
  if ((int )elf_header.e_machine == 3) {
#line 9819
    goto case_6;
  }
#line 9821
  if ((int )elf_header.e_machine == 4) {
#line 9821
    goto case_4;
  }
#line 9823
  if ((int )elf_header.e_machine == 7) {
#line 9823
    goto case_7;
  }
#line 9825
  if ((int )elf_header.e_machine == 19) {
#line 9825
    goto case_19;
  }
#line 9827
  if ((int )elf_header.e_machine == 183) {
#line 9827
    goto case_183;
  }
#line 9829
  if ((int )elf_header.e_machine == 36902) {
#line 9829
    goto case_36902;
  }
#line 9831
  if ((int )elf_header.e_machine == 45) {
#line 9831
    goto case_45;
  }
#line 9833
  if ((int )elf_header.e_machine == 40) {
#line 9833
    goto case_40;
  }
#line 9836
  if ((int )elf_header.e_machine == 83) {
#line 9836
    goto case_83;
  }
#line 9836
  if ((int )elf_header.e_machine == 4183) {
#line 9836
    goto case_83;
  }
#line 9838
  if ((int )elf_header.e_machine == 4643) {
#line 9838
    goto case_4643;
  }
#line 9840
  if ((int )elf_header.e_machine == 106) {
#line 9840
    goto case_106;
  }
#line 9842
  if ((int )elf_header.e_machine == 76) {
#line 9842
    goto case_76;
  }
#line 9844
  if ((int )elf_header.e_machine == 177) {
#line 9844
    goto case_177;
  }
#line 9846
  if ((int )elf_header.e_machine == 114) {
#line 9846
    goto case_114;
  }
#line 9848
  if ((int )elf_header.e_machine == 21569) {
#line 9848
    goto case_21569;
  }
#line 9851
  if ((int )elf_header.e_machine == 85) {
#line 9851
    goto case_85;
  }
#line 9851
  if ((int )elf_header.e_machine == 30288) {
#line 9851
    goto case_85;
  }
#line 9854
  if ((int )elf_header.e_machine == 86) {
#line 9854
    goto case_86;
  }
#line 9854
  if ((int )elf_header.e_machine == 30326) {
#line 9854
    goto case_86;
  }
#line 9856
  if ((int )elf_header.e_machine == 23205) {
#line 9856
    goto case_23205;
  }
#line 9859
  if ((int )elf_header.e_machine == 84) {
#line 9859
    goto case_84;
  }
#line 9859
  if ((int )elf_header.e_machine == 13104) {
#line 9859
    goto case_84;
  }
#line 9863
  if ((int )elf_header.e_machine == 47) {
#line 9863
    goto case_47;
  }
#line 9863
  if ((int )elf_header.e_machine == 46) {
#line 9863
    goto case_47;
  }
#line 9863
  if ((int )elf_header.e_machine == 48) {
#line 9863
    goto case_47;
  }
#line 9865
  if ((int )elf_header.e_machine == 50) {
#line 9865
    goto case_50;
  }
#line 9868
  if ((int )elf_header.e_machine == 101) {
#line 9868
    goto case_101;
  }
#line 9868
  if ((int )elf_header.e_machine == 33303) {
#line 9868
    goto case_101;
  }
#line 9870
  if ((int )elf_header.e_machine == 65210) {
#line 9870
    goto case_65210;
  }
#line 9872
  if ((int )elf_header.e_machine == 138) {
#line 9872
    goto case_138;
  }
#line 9875
  if ((int )elf_header.e_machine == 120) {
#line 9875
    goto case_120;
  }
#line 9875
  if ((int )elf_header.e_machine == 65200) {
#line 9875
    goto case_120;
  }
#line 9877
  if ((int )elf_header.e_machine == 88) {
#line 9877
    goto case_88;
  }
#line 9879
  if ((int )elf_header.e_machine == 39) {
#line 9879
    goto case_39;
  }
#line 9881
  if ((int )elf_header.e_machine == 61453) {
#line 9881
    goto case_61453;
  }
#line 9883
  if ((int )elf_header.e_machine == 189) {
#line 9883
    goto case_189;
  }
#line 9885
  if ((int )elf_header.e_machine == 8) {
#line 9885
    goto case_8;
  }
#line 9887
  if ((int )elf_header.e_machine == 80) {
#line 9887
    goto case_80;
  }
#line 9890
  if ((int )elf_header.e_machine == 90) {
#line 9890
    goto case_90;
  }
#line 9890
  if ((int )elf_header.e_machine == 57005) {
#line 9890
    goto case_90;
  }
#line 9893
  if ((int )elf_header.e_machine == 89) {
#line 9893
    goto case_89;
  }
#line 9893
  if ((int )elf_header.e_machine == 48879) {
#line 9893
    goto case_89;
  }
#line 9895
  if ((int )elf_header.e_machine == 65261) {
#line 9895
    goto case_65261;
  }
#line 9898
  if ((int )elf_header.e_machine == 105) {
#line 9898
    goto case_105;
  }
#line 9898
  if ((int )elf_header.e_machine == 4185) {
#line 9898
    goto case_105;
  }
#line 9900
  if ((int )elf_header.e_machine == 9520) {
#line 9900
    goto case_9520;
  }
#line 9903
  if ((int )elf_header.e_machine == 65211) {
#line 9903
    goto case_65211;
  }
#line 9903
  if ((int )elf_header.e_machine == 113) {
#line 9903
    goto case_65211;
  }
#line 9906
  if ((int )elf_header.e_machine == 33906) {
#line 9906
    goto case_33906;
  }
#line 9906
  if ((int )elf_header.e_machine == 92) {
#line 9906
    goto case_33906;
  }
#line 9908
  if ((int )elf_header.e_machine == 15) {
#line 9908
    goto case_15;
  }
#line 9912
  if ((int )elf_header.e_machine == 99) {
#line 9912
    goto case_99;
  }
#line 9912
  if ((int )elf_header.e_machine == 91) {
#line 9912
    goto case_99;
  }
#line 9914
  if ((int )elf_header.e_machine == 21) {
#line 9914
    goto case_21;
  }
#line 9916
  if ((int )elf_header.e_machine == 20) {
#line 9916
    goto case_20;
  }
#line 9918
  if ((int )elf_header.e_machine == 197) {
#line 9918
    goto case_197;
  }
#line 9920
  if ((int )elf_header.e_machine == 173) {
#line 9920
    goto case_173;
  }
#line 9922
  if ((int )elf_header.e_machine == 9) {
#line 9922
    goto case_9;
  }
#line 9925
  if ((int )elf_header.e_machine == 22) {
#line 9925
    goto case_22;
  }
#line 9925
  if ((int )elf_header.e_machine == 41872) {
#line 9925
    goto case_22;
  }
#line 9927
  if ((int )elf_header.e_machine == 135) {
#line 9927
    goto case_135;
  }
#line 9929
  if ((int )elf_header.e_machine == 42) {
#line 9929
    goto case_42;
  }
#line 9933
  if ((int )elf_header.e_machine == 2) {
#line 9933
    goto case_2;
  }
#line 9933
  if ((int )elf_header.e_machine == 43) {
#line 9933
    goto case_2;
  }
#line 9933
  if ((int )elf_header.e_machine == 18) {
#line 9933
    goto case_2;
  }
#line 9936
  if ((int )elf_header.e_machine == 23) {
#line 9936
    goto case_23;
  }
#line 9938
  if ((int )elf_header.e_machine == 140) {
#line 9938
    goto case_140;
  }
#line 9940
  if ((int )elf_header.e_machine == 191) {
#line 9940
    goto case_191;
  }
#line 9942
  if ((int )elf_header.e_machine == 188) {
#line 9942
    goto case_188;
  }
#line 9945
  if ((int )elf_header.e_machine == 87) {
#line 9945
    goto case_87;
  }
#line 9945
  if ((int )elf_header.e_machine == 36992) {
#line 9945
    goto case_87;
  }
#line 9947
  if ((int )elf_header.e_machine == 75) {
#line 9947
    goto case_75;
  }
#line 9951
  if ((int )elf_header.e_machine == 181) {
#line 9951
    goto case_181;
  }
#line 9951
  if ((int )elf_header.e_machine == 180) {
#line 9951
    goto case_181;
  }
#line 9951
  if ((int )elf_header.e_machine == 62) {
#line 9951
    goto case_181;
  }
#line 9954
  if ((int )elf_header.e_machine == 116) {
#line 9954
    goto case_116;
  }
#line 9954
  if ((int )elf_header.e_machine == 18056) {
#line 9954
    goto case_116;
  }
#line 9956
  if ((int )elf_header.e_machine == 115) {
#line 9956
    goto case_115;
  }
#line 9958
  if ((int )elf_header.e_machine == 44357) {
#line 9958
    goto case_44357;
  }
#line 9961
  if ((int )elf_header.e_machine == 94) {
#line 9961
    goto case_94;
  }
#line 9961
  if ((int )elf_header.e_machine == 43975) {
#line 9961
    goto case_94;
  }
#line 9963
  goto switch_default;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 9820
  return (reloc_type == 1U);
  case_4: /* CIL Label */ 
#line 9822
  return (reloc_type == 1U);
  case_7: /* CIL Label */ 
#line 9824
  return (reloc_type == 1U);
  case_19: /* CIL Label */ 
#line 9826
  return (reloc_type == 2U);
  case_183: /* CIL Label */ 
#line 9828
  return (reloc_type == 258U);
  case_36902: /* CIL Label */ 
#line 9830
  return (reloc_type == 1U);
  case_45: /* CIL Label */ 
#line 9832
  return (reloc_type == 1U);
  case_40: /* CIL Label */ 
#line 9834
  return (reloc_type == 2U);
  case_83: /* CIL Label */ 
  case_4183: /* CIL Label */ 
#line 9837
  return (reloc_type == 1U);
  case_4643: /* CIL Label */ 
#line 9839
  return (reloc_type == 3U);
  case_106: /* CIL Label */ 
#line 9841
  return (reloc_type == 18U);
  case_76: /* CIL Label */ 
#line 9843
  return (reloc_type == 3U);
  case_177: /* CIL Label */ 
#line 9845
  return (reloc_type == 3U);
  case_114: /* CIL Label */ 
#line 9847
  return (reloc_type == 15U);
  case_21569: /* CIL Label */ 
#line 9849
  return (reloc_type == 1U);
  case_85: /* CIL Label */ 
  case_30288: /* CIL Label */ 
#line 9852
  return (reloc_type == 6U);
  case_86: /* CIL Label */ 
  case_30326: /* CIL Label */ 
#line 9855
  return (reloc_type == 12U);
  case_23205: /* CIL Label */ 
#line 9857
  return (reloc_type == 3U);
  case_84: /* CIL Label */ 
  case_13104: /* CIL Label */ 
#line 9860
  return (reloc_type == 3U);
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 9864
  return (reloc_type == 1U);
  case_50: /* CIL Label */ 
#line 9866
  return (reloc_type == 101U);
  case_101: /* CIL Label */ 
  case_33303: /* CIL Label */ 
#line 9869
  return (reloc_type == 2U);
  case_65210: /* CIL Label */ 
#line 9871
  return (reloc_type == 2U);
  case_138: /* CIL Label */ 
#line 9873
  return (reloc_type == 3U);
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
#line 9876
  return (reloc_type == 3U);
  case_88: /* CIL Label */ 
#line 9878
  return (reloc_type == 34U);
  case_39: /* CIL Label */ 
#line 9880
  return (reloc_type == 1U);
  case_61453: /* CIL Label */ 
#line 9882
  return (reloc_type == 4U);
  case_189: /* CIL Label */ 
#line 9884
  return (reloc_type == 1U);
  case_8: /* CIL Label */ 
#line 9886
  return (reloc_type == 2U);
  case_80: /* CIL Label */ 
#line 9888
  return (reloc_type == 4U);
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 9891
  return (reloc_type == 1U);
  case_89: /* CIL Label */ 
  case_48879: /* CIL Label */ 
#line 9894
  return (reloc_type == 1U);
  case_65261: /* CIL Label */ 
#line 9896
  return (reloc_type == 1U);
  case_105: /* CIL Label */ 
  case_4185: /* CIL Label */ 
#line 9899
  return (reloc_type == 1U);
  case_9520: /* CIL Label */ 
#line 9901
  return (reloc_type == 2U);
  case_65211: /* CIL Label */ 
  case_113: /* CIL Label */ 
#line 9904
  return (reloc_type == 1U);
  case_33906: /* CIL Label */ 
  case_92: /* CIL Label */ 
#line 9907
  return (reloc_type == 1U);
  case_15: /* CIL Label */ 
#line 9909
  if (reloc_type == 1U) {
#line 9909
    tmp___0 = 1;
  } else
#line 9909
  if (reloc_type == 41U) {
#line 9909
    tmp___0 = 1;
  } else {
#line 9909
    tmp___0 = 0;
  }
#line 9909
  return (tmp___0);
  case_99: /* CIL Label */ 
  case_91: /* CIL Label */ 
#line 9913
  return (reloc_type == 1U);
  case_21: /* CIL Label */ 
#line 9915
  return (reloc_type == 1U);
  case_20: /* CIL Label */ 
#line 9917
  return (reloc_type == 1U);
  case_197: /* CIL Label */ 
#line 9919
  return (reloc_type == 1U);
  case_173: /* CIL Label */ 
#line 9921
  return (reloc_type == 1U);
  case_9: /* CIL Label */ 
#line 9923
  return (reloc_type == 1U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 9926
  return (reloc_type == 4U);
  case_135: /* CIL Label */ 
#line 9928
  return (reloc_type == 8U);
  case_42: /* CIL Label */ 
#line 9930
  return (reloc_type == 1U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 9934
  if (reloc_type == 3U) {
#line 9934
    tmp___1 = 1;
  } else
#line 9934
  if (reloc_type == 23U) {
#line 9934
    tmp___1 = 1;
  } else {
#line 9934
    tmp___1 = 0;
  }
#line 9934
  return (tmp___1);
  case_23: /* CIL Label */ 
#line 9937
  return (reloc_type == 6U);
  case_140: /* CIL Label */ 
#line 9939
  return (reloc_type == 1U);
  case_191: /* CIL Label */ 
#line 9941
  return (reloc_type == 2U);
  case_188: /* CIL Label */ 
#line 9943
  return (reloc_type == 1U);
  case_87: /* CIL Label */ 
  case_36992: /* CIL Label */ 
#line 9946
  return (reloc_type == 6U);
  case_75: /* CIL Label */ 
#line 9948
  return (reloc_type == 1U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 9952
  return (reloc_type == 10U);
  case_116: /* CIL Label */ 
  case_18056: /* CIL Label */ 
#line 9955
  return (reloc_type == 3U);
  case_115: /* CIL Label */ 
#line 9957
  return (reloc_type == 4U);
  case_44357: /* CIL Label */ 
#line 9959
  return (reloc_type == 1U);
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 9962
  return (reloc_type == 1U);
  switch_default: /* CIL Label */ 
  {
#line 9964
  tmp___2 = gettext("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n");
#line 9964
  error((char const   *)tmp___2, (int )elf_header.e_machine);
#line 9966
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 9973 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_32bit_pcrel_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 9979
  if ((int )elf_header.e_machine == 6) {
#line 9979
    goto case_6;
  }
#line 9979
  if ((int )elf_header.e_machine == 3) {
#line 9979
    goto case_6;
  }
#line 9981
  if ((int )elf_header.e_machine == 4) {
#line 9981
    goto case_4;
  }
#line 9983
  if ((int )elf_header.e_machine == 183) {
#line 9983
    goto case_183;
  }
#line 9985
  if ((int )elf_header.e_machine == 4643) {
#line 9985
    goto case_4643;
  }
#line 9987
  if ((int )elf_header.e_machine == 36902) {
#line 9987
    goto case_36902;
  }
#line 9989
  if ((int )elf_header.e_machine == 40) {
#line 9989
    goto case_40;
  }
#line 9991
  if ((int )elf_header.e_machine == 189) {
#line 9991
    goto case_189;
  }
#line 9993
  if ((int )elf_header.e_machine == 15) {
#line 9993
    goto case_15;
  }
#line 9995
  if ((int )elf_header.e_machine == 20) {
#line 9995
    goto case_20;
  }
#line 9997
  if ((int )elf_header.e_machine == 21) {
#line 9997
    goto case_21;
  }
#line 10000
  if ((int )elf_header.e_machine == 22) {
#line 10000
    goto case_22;
  }
#line 10000
  if ((int )elf_header.e_machine == 41872) {
#line 10000
    goto case_22;
  }
#line 10002
  if ((int )elf_header.e_machine == 42) {
#line 10002
    goto case_42;
  }
#line 10006
  if ((int )elf_header.e_machine == 2) {
#line 10006
    goto case_2;
  }
#line 10006
  if ((int )elf_header.e_machine == 43) {
#line 10006
    goto case_2;
  }
#line 10006
  if ((int )elf_header.e_machine == 18) {
#line 10006
    goto case_2;
  }
#line 10008
  if ((int )elf_header.e_machine == 23) {
#line 10008
    goto case_23;
  }
#line 10010
  if ((int )elf_header.e_machine == 191) {
#line 10010
    goto case_191;
  }
#line 10012
  if ((int )elf_header.e_machine == 188) {
#line 10012
    goto case_188;
  }
#line 10016
  if ((int )elf_header.e_machine == 181) {
#line 10016
    goto case_181;
  }
#line 10016
  if ((int )elf_header.e_machine == 180) {
#line 10016
    goto case_181;
  }
#line 10016
  if ((int )elf_header.e_machine == 62) {
#line 10016
    goto case_181;
  }
#line 10019
  if ((int )elf_header.e_machine == 94) {
#line 10019
    goto case_94;
  }
#line 10019
  if ((int )elf_header.e_machine == 43975) {
#line 10019
    goto case_94;
  }
#line 10021
  goto switch_default;
  case_6: /* CIL Label */ 
  case_3: /* CIL Label */ 
#line 9980
  return (reloc_type == 2U);
  case_4: /* CIL Label */ 
#line 9982
  return (reloc_type == 4U);
  case_183: /* CIL Label */ 
#line 9984
  return (reloc_type == 261U);
  case_4643: /* CIL Label */ 
#line 9986
  return (reloc_type == 6U);
  case_36902: /* CIL Label */ 
#line 9988
  return (reloc_type == 10U);
  case_40: /* CIL Label */ 
#line 9990
  return (reloc_type == 3U);
  case_189: /* CIL Label */ 
#line 9992
  return (reloc_type == 2U);
  case_15: /* CIL Label */ 
#line 9994
  return (reloc_type == 9U);
  case_20: /* CIL Label */ 
#line 9996
  return (reloc_type == 26U);
  case_21: /* CIL Label */ 
#line 9998
  return (reloc_type == 26U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10001
  return (reloc_type == 5U);
  case_42: /* CIL Label */ 
#line 10003
  return (reloc_type == 2U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10007
  return (reloc_type == 6U);
  case_23: /* CIL Label */ 
#line 10009
  return (reloc_type == 13U);
  case_191: /* CIL Label */ 
#line 10011
  return (reloc_type == 6U);
  case_188: /* CIL Label */ 
#line 10013
  return (reloc_type == 4U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10017
  return (reloc_type == 2U);
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 10020
  return (reloc_type == 14U);
  switch_default: /* CIL Label */ 
#line 10027
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10034 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_64bit_abs_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10039
  if ((int )elf_header.e_machine == 183) {
#line 10039
    goto case_183;
  }
#line 10041
  if ((int )elf_header.e_machine == 36902) {
#line 10041
    goto case_36902;
  }
#line 10043
  if ((int )elf_header.e_machine == 50) {
#line 10043
    goto case_50;
  }
#line 10045
  if ((int )elf_header.e_machine == 15) {
#line 10045
    goto case_15;
  }
#line 10047
  if ((int )elf_header.e_machine == 21) {
#line 10047
    goto case_21;
  }
#line 10051
  if ((int )elf_header.e_machine == 2) {
#line 10051
    goto case_2;
  }
#line 10051
  if ((int )elf_header.e_machine == 43) {
#line 10051
    goto case_2;
  }
#line 10051
  if ((int )elf_header.e_machine == 18) {
#line 10051
    goto case_2;
  }
#line 10055
  if ((int )elf_header.e_machine == 181) {
#line 10055
    goto case_181;
  }
#line 10055
  if ((int )elf_header.e_machine == 180) {
#line 10055
    goto case_181;
  }
#line 10055
  if ((int )elf_header.e_machine == 62) {
#line 10055
    goto case_181;
  }
#line 10058
  if ((int )elf_header.e_machine == 22) {
#line 10058
    goto case_22;
  }
#line 10058
  if ((int )elf_header.e_machine == 41872) {
#line 10058
    goto case_22;
  }
#line 10060
  if ((int )elf_header.e_machine == 191) {
#line 10060
    goto case_191;
  }
#line 10062
  if ((int )elf_header.e_machine == 8) {
#line 10062
    goto case_8;
  }
#line 10064
  goto switch_default;
  case_183: /* CIL Label */ 
#line 10040
  return (reloc_type == 257U);
  case_36902: /* CIL Label */ 
#line 10042
  return (reloc_type == 2U);
  case_50: /* CIL Label */ 
#line 10044
  return (reloc_type == 39U);
  case_15: /* CIL Label */ 
#line 10046
  return (reloc_type == 80U);
  case_21: /* CIL Label */ 
#line 10048
  return (reloc_type == 38U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10052
  return (reloc_type == 54U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10056
  return (reloc_type == 1U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10059
  return (reloc_type == 22U);
  case_191: /* CIL Label */ 
#line 10061
  return (reloc_type == 1U);
  case_8: /* CIL Label */ 
#line 10063
  return (reloc_type == 18U);
  switch_default: /* CIL Label */ 
#line 10065
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10072 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_64bit_pcrel_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10077
  if ((int )elf_header.e_machine == 183) {
#line 10077
    goto case_183;
  }
#line 10079
  if ((int )elf_header.e_machine == 36902) {
#line 10079
    goto case_36902;
  }
#line 10081
  if ((int )elf_header.e_machine == 50) {
#line 10081
    goto case_50;
  }
#line 10083
  if ((int )elf_header.e_machine == 15) {
#line 10083
    goto case_15;
  }
#line 10085
  if ((int )elf_header.e_machine == 21) {
#line 10085
    goto case_21;
  }
#line 10089
  if ((int )elf_header.e_machine == 2) {
#line 10089
    goto case_2;
  }
#line 10089
  if ((int )elf_header.e_machine == 43) {
#line 10089
    goto case_2;
  }
#line 10089
  if ((int )elf_header.e_machine == 18) {
#line 10089
    goto case_2;
  }
#line 10093
  if ((int )elf_header.e_machine == 181) {
#line 10093
    goto case_181;
  }
#line 10093
  if ((int )elf_header.e_machine == 180) {
#line 10093
    goto case_181;
  }
#line 10093
  if ((int )elf_header.e_machine == 62) {
#line 10093
    goto case_181;
  }
#line 10096
  if ((int )elf_header.e_machine == 22) {
#line 10096
    goto case_22;
  }
#line 10096
  if ((int )elf_header.e_machine == 41872) {
#line 10096
    goto case_22;
  }
#line 10098
  if ((int )elf_header.e_machine == 191) {
#line 10098
    goto case_191;
  }
#line 10100
  goto switch_default;
  case_183: /* CIL Label */ 
#line 10078
  return (reloc_type == 260U);
  case_36902: /* CIL Label */ 
#line 10080
  return (reloc_type == 11U);
  case_50: /* CIL Label */ 
#line 10082
  return (reloc_type == 79U);
  case_15: /* CIL Label */ 
#line 10084
  return (reloc_type == 72U);
  case_21: /* CIL Label */ 
#line 10086
  return (reloc_type == 44U);
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
#line 10090
  return (reloc_type == 46U);
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
#line 10094
  return (reloc_type == 24U);
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
#line 10097
  return (reloc_type == 23U);
  case_191: /* CIL Label */ 
#line 10099
  return (reloc_type == 5U);
  switch_default: /* CIL Label */ 
#line 10101
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10108 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_24bit_abs_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10114
  if ((int )elf_header.e_machine == 90) {
#line 10114
    goto case_90;
  }
#line 10114
  if ((int )elf_header.e_machine == 57005) {
#line 10114
    goto case_90;
  }
#line 10116
  goto switch_default;
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 10115
  return (reloc_type == 4U);
  switch_default: /* CIL Label */ 
#line 10117
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10124 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_16bit_abs_reloc(unsigned int reloc_type ) 
{ 


  {
  {
#line 10130
  if ((int )elf_header.e_machine == 83) {
#line 10130
    goto case_83;
  }
#line 10130
  if ((int )elf_header.e_machine == 4183) {
#line 10130
    goto case_83;
  }
#line 10132
  if ((int )elf_header.e_machine == 4643) {
#line 10132
    goto case_4643;
  }
#line 10135
  if ((int )elf_header.e_machine == 85) {
#line 10135
    goto case_85;
  }
#line 10135
  if ((int )elf_header.e_machine == 30288) {
#line 10135
    goto case_85;
  }
#line 10139
  if ((int )elf_header.e_machine == 47) {
#line 10139
    goto case_47;
  }
#line 10139
  if ((int )elf_header.e_machine == 46) {
#line 10139
    goto case_47;
  }
#line 10139
  if ((int )elf_header.e_machine == 48) {
#line 10139
    goto case_47;
  }
#line 10142
  if ((int )elf_header.e_machine == 101) {
#line 10142
    goto case_101;
  }
#line 10142
  if ((int )elf_header.e_machine == 33303) {
#line 10142
    goto case_101;
  }
#line 10145
  if ((int )elf_header.e_machine == 120) {
#line 10145
    goto case_120;
  }
#line 10145
  if ((int )elf_header.e_machine == 65200) {
#line 10145
    goto case_120;
  }
#line 10148
  if ((int )elf_header.e_machine == 105) {
#line 10148
    goto case_105;
  }
#line 10148
  if ((int )elf_header.e_machine == 4185) {
#line 10148
    goto case_105;
  }
#line 10151
  if ((int )elf_header.e_machine == 65211) {
#line 10151
    goto case_65211;
  }
#line 10151
  if ((int )elf_header.e_machine == 113) {
#line 10151
    goto case_65211;
  }
#line 10153
  if ((int )elf_header.e_machine == 140) {
#line 10153
    goto case_140;
  }
#line 10156
  if ((int )elf_header.e_machine == 116) {
#line 10156
    goto case_116;
  }
#line 10156
  if ((int )elf_header.e_machine == 18056) {
#line 10156
    goto case_116;
  }
#line 10159
  if ((int )elf_header.e_machine == 90) {
#line 10159
    goto case_90;
  }
#line 10159
  if ((int )elf_header.e_machine == 57005) {
#line 10159
    goto case_90;
  }
#line 10162
  if ((int )elf_header.e_machine == 89) {
#line 10162
    goto case_89;
  }
#line 10162
  if ((int )elf_header.e_machine == 48879) {
#line 10162
    goto case_89;
  }
#line 10164
  if ((int )elf_header.e_machine == 115) {
#line 10164
    goto case_115;
  }
#line 10166
  goto switch_default;
  case_83: /* CIL Label */ 
  case_4183: /* CIL Label */ 
#line 10131
  return (reloc_type == 4U);
  case_4643: /* CIL Label */ 
#line 10133
  return (reloc_type == 5U);
  case_85: /* CIL Label */ 
  case_30288: /* CIL Label */ 
#line 10136
  return (reloc_type == 3U);
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 10140
  return (reloc_type == 17U);
  case_101: /* CIL Label */ 
  case_33303: /* CIL Label */ 
#line 10143
  return (reloc_type == 1U);
  case_120: /* CIL Label */ 
  case_65200: /* CIL Label */ 
#line 10146
  return (reloc_type == 1U);
  case_105: /* CIL Label */ 
  case_4185: /* CIL Label */ 
#line 10149
  return (reloc_type == 5U);
  case_65211: /* CIL Label */ 
  case_113: /* CIL Label */ 
#line 10152
  return (reloc_type == 9U);
  case_140: /* CIL Label */ 
#line 10154
  return (reloc_type == 2U);
  case_116: /* CIL Label */ 
  case_18056: /* CIL Label */ 
#line 10157
  return (reloc_type == 2U);
  case_90: /* CIL Label */ 
  case_57005: /* CIL Label */ 
#line 10160
  return (reloc_type == 2U);
  case_89: /* CIL Label */ 
  case_48879: /* CIL Label */ 
#line 10163
  return (reloc_type == 2U);
  case_115: /* CIL Label */ 
#line 10165
  return (reloc_type == 3U);
  switch_default: /* CIL Label */ 
#line 10167
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 10174 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_boolean is_none_reloc(unsigned int reloc_type ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 10206
  if ((int )elf_header.e_machine == 116) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 18056) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 188) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 191) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 140) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 88) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 65261) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 89) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 181) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 180) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 62) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 76) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 22) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 41872) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 42) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 50) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 40) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 21) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 20) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 4643) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 36902) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 15) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 8) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 2) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 43) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 18) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 3) {
#line 10206
    goto case_116;
  }
#line 10206
  if ((int )elf_header.e_machine == 4) {
#line 10206
    goto case_116;
  }
#line 10208
  if ((int )elf_header.e_machine == 183) {
#line 10208
    goto case_183;
  }
#line 10211
  if ((int )elf_header.e_machine == 94) {
#line 10211
    goto case_94;
  }
#line 10211
  if ((int )elf_header.e_machine == 43975) {
#line 10211
    goto case_94;
  }
#line 10177
  goto switch_break;
  case_116: /* CIL Label */ 
  case_18056: /* CIL Label */ 
  case_188: /* CIL Label */ 
  case_191: /* CIL Label */ 
  case_140: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_65261: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_181: /* CIL Label */ 
  case_180: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_41872: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_4643: /* CIL Label */ 
  case_36902: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 10207
  return (reloc_type == 0U);
  case_183: /* CIL Label */ 
#line 10209
  if (reloc_type == 0U) {
#line 10209
    tmp___0 = 1;
  } else
#line 10209
  if (reloc_type == 256U) {
#line 10209
    tmp___0 = 1;
  } else {
#line 10209
    tmp___0 = 0;
  }
#line 10209
  return (tmp___0);
  case_94: /* CIL Label */ 
  case_43975: /* CIL Label */ 
#line 10212
  if (reloc_type == 0U) {
#line 10212
    tmp___1 = 1;
  } else
#line 10212
  if (reloc_type == 17U) {
#line 10212
    tmp___1 = 1;
  } else
#line 10212
  if (reloc_type == 18U) {
#line 10212
    tmp___1 = 1;
  } else
#line 10212
  if (reloc_type == 19U) {
#line 10212
    tmp___1 = 1;
  } else {
#line 10212
    tmp___1 = 0;
  }
#line 10212
  return (tmp___1);
  switch_break: /* CIL Label */ ;
  }
#line 10217
  return (0);
}
}
#line 10225 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void apply_relocations(void *file , Elf_Internal_Shdr *section , unsigned char *start ) 
{ 
  Elf_Internal_Shdr *relsec ;
  unsigned char *end ;
  bfd_boolean is_rela ;
  unsigned long num_relocs ;
  Elf_Internal_Rela *relocs ;
  Elf_Internal_Rela *rp ;
  Elf_Internal_Shdr *symsec ;
  Elf_Internal_Sym *symtab ;
  unsigned long num_syms ;
  Elf_Internal_Sym *sym ;
  int tmp___0 ;
  int tmp___1 ;
  Elf_Internal_Sym *tmp___2 ;
  Elf_Internal_Sym *tmp___3 ;
  bfd_vma addend ;
  unsigned int reloc_type ;
  unsigned int reloc_size ;
  unsigned char *rloc ;
  unsigned long sym_index ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  bfd_boolean tmp___11 ;
  bfd_boolean tmp___12 ;
  bfd_boolean tmp___13 ;
  bfd_boolean tmp___14 ;
  bfd_boolean tmp___15 ;
  bfd_boolean tmp___16 ;
  bfd_boolean tmp___17 ;
  bfd_boolean tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  bfd_vma tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  elf_vma tmp___42 ;
  bfd_boolean tmp___43 ;
  bfd_boolean tmp___44 ;

  {
#line 10231
  end = start + section->sh_size;
#line 10233
  if ((int )elf_header.e_type != 1) {
#line 10234
    return;
  }
#line 10237
  relsec = section_headers;
  {
#line 10237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10237
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 10237
      goto while_break;
    }
#line 10250
    if (relsec->sh_type != 4U) {
#line 10250
      if (relsec->sh_type != 9U) {
#line 10255
        goto __Cont;
      } else {
#line 10250
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 10250
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 10255
      goto __Cont;
    } else
#line 10250
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )section) {
#line 10255
      goto __Cont;
    } else
#line 10250
    if (relsec->sh_size == 0UL) {
#line 10255
      goto __Cont;
    } else
#line 10250
    if (relsec->sh_link >= elf_header.e_shnum) {
#line 10255
      goto __Cont;
    }
#line 10257
    is_rela = relsec->sh_type == 4U;
#line 10259
    if (is_rela) {
      {
#line 10261
      tmp___0 = slurp_rela_relocs((FILE *)file, (unsigned long )relsec->sh_offset,
                                  relsec->sh_size, & relocs, & num_relocs);
      }
#line 10261
      if (! tmp___0) {
#line 10263
        return;
      }
    } else {
      {
#line 10267
      tmp___1 = slurp_rel_relocs((FILE *)file, (unsigned long )relsec->sh_offset,
                                 relsec->sh_size, & relocs, & num_relocs);
      }
#line 10267
      if (! tmp___1) {
#line 10269
        return;
      }
    }
#line 10273
    if ((int )elf_header.e_machine == 42) {
#line 10274
      is_rela = 0;
    }
#line 10276
    symsec = section_headers + relsec->sh_link;
#line 10277
    if (is_32bit_elf) {
      {
#line 10277
      tmp___2 = get_32bit_elf_symbols((FILE *)file, symsec, & num_syms);
#line 10277
      symtab = tmp___2;
      }
    } else {
      {
#line 10277
      tmp___3 = get_64bit_elf_symbols((FILE *)file, symsec, & num_syms);
#line 10277
      symtab = tmp___3;
      }
    }
#line 10279
    rp = relocs;
    {
#line 10279
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10279
      if (! ((unsigned long )rp < (unsigned long )(relocs + num_relocs))) {
#line 10279
        goto while_break___0;
      }
      {
#line 10287
      reloc_type = get_reloc_type(rp->r_info);
#line 10289
      tmp___18 = target_specific_reloc_handling(rp, start, symtab);
      }
#line 10289
      if (tmp___18) {
#line 10290
        goto __Cont___0;
      } else {
        {
#line 10291
        tmp___17 = is_none_reloc(reloc_type);
        }
#line 10291
        if (tmp___17) {
#line 10292
          goto __Cont___0;
        } else {
          {
#line 10293
          tmp___15 = is_32bit_abs_reloc(reloc_type);
          }
#line 10293
          if (tmp___15) {
#line 10295
            reloc_size = 4U;
          } else {
            {
#line 10293
            tmp___16 = is_32bit_pcrel_reloc(reloc_type);
            }
#line 10293
            if (tmp___16) {
#line 10295
              reloc_size = 4U;
            } else {
              {
#line 10296
              tmp___13 = is_64bit_abs_reloc(reloc_type);
              }
#line 10296
              if (tmp___13) {
#line 10298
                reloc_size = 8U;
              } else {
                {
#line 10296
                tmp___14 = is_64bit_pcrel_reloc(reloc_type);
                }
#line 10296
                if (tmp___14) {
#line 10298
                  reloc_size = 8U;
                } else {
                  {
#line 10299
                  tmp___12 = is_24bit_abs_reloc(reloc_type);
                  }
#line 10299
                  if (tmp___12) {
#line 10300
                    reloc_size = 3U;
                  } else {
                    {
#line 10301
                    tmp___11 = is_16bit_abs_reloc(reloc_type);
                    }
#line 10301
                    if (tmp___11) {
#line 10302
                      reloc_size = 2U;
                    } else {
#line 10305
                      if ((unsigned long )section == (unsigned long )((void *)0)) {
                        {
#line 10305
                        tmp___4 = gettext("<none>");
#line 10305
                        tmp___9 = tmp___4;
                        }
                      } else {
#line 10305
                        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
                          {
#line 10305
                          tmp___5 = gettext("<no-name>");
#line 10305
                          tmp___8 = tmp___5;
                          }
                        } else {
#line 10305
                          if ((unsigned long )section->sh_name >= string_table_length) {
                            {
#line 10305
                            tmp___6 = gettext("<corrupt>");
#line 10305
                            tmp___7 = tmp___6;
                            }
                          } else {
#line 10305
                            tmp___7 = string_table + section->sh_name;
                          }
#line 10305
                          tmp___8 = tmp___7;
                        }
#line 10305
                        tmp___9 = tmp___8;
                      }
                      {
#line 10305
                      tmp___10 = gettext("unable to apply unsupported reloc type %d to section %s\n");
#line 10305
                      warn((char const   *)tmp___10, reloc_type, tmp___9);
                      }
#line 10307
                      goto __Cont___0;
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 10310
      rloc = start + rp->r_offset;
#line 10311
      if ((unsigned long )(rloc + reloc_size) > (unsigned long )end) {
#line 10313
        if ((unsigned long )section == (unsigned long )((void *)0)) {
          {
#line 10313
          tmp___19 = gettext("<none>");
#line 10313
          tmp___24 = tmp___19;
          }
        } else {
#line 10313
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 10313
            tmp___20 = gettext("<no-name>");
#line 10313
            tmp___23 = tmp___20;
            }
          } else {
#line 10313
            if ((unsigned long )section->sh_name >= string_table_length) {
              {
#line 10313
              tmp___21 = gettext("<corrupt>");
#line 10313
              tmp___22 = tmp___21;
              }
            } else {
#line 10313
              tmp___22 = string_table + section->sh_name;
            }
#line 10313
            tmp___23 = tmp___22;
          }
#line 10313
          tmp___24 = tmp___23;
        }
        {
#line 10313
        tmp___25 = gettext("skipping invalid relocation offset 0x%lx in section %s\n");
#line 10313
        warn((char const   *)tmp___25, rp->r_offset, tmp___24);
        }
#line 10316
        goto __Cont___0;
      }
      {
#line 10319
      tmp___26 = get_reloc_symindex(rp->r_info);
#line 10319
      sym_index = tmp___26;
      }
#line 10320
      if (sym_index >= num_syms) {
#line 10322
        if ((unsigned long )section == (unsigned long )((void *)0)) {
          {
#line 10322
          tmp___27 = gettext("<none>");
#line 10322
          tmp___32 = tmp___27;
          }
        } else {
#line 10322
          if ((unsigned long )string_table == (unsigned long )((void *)0)) {
            {
#line 10322
            tmp___28 = gettext("<no-name>");
#line 10322
            tmp___31 = tmp___28;
            }
          } else {
#line 10322
            if ((unsigned long )section->sh_name >= string_table_length) {
              {
#line 10322
              tmp___29 = gettext("<corrupt>");
#line 10322
              tmp___30 = tmp___29;
              }
            } else {
#line 10322
              tmp___30 = string_table + section->sh_name;
            }
#line 10322
            tmp___31 = tmp___30;
          }
#line 10322
          tmp___32 = tmp___31;
        }
        {
#line 10322
        tmp___33 = gettext("skipping invalid relocation symbol index 0x%lx in section %s\n");
#line 10322
        warn((char const   *)tmp___33, sym_index, tmp___32);
        }
#line 10324
        goto __Cont___0;
      }
#line 10326
      sym = symtab + sym_index;
#line 10341
      if ((unsigned long )sym != (unsigned long )symtab) {
#line 10341
        if (((int )sym->st_info & 15) > 3) {
#line 10344
          if ((unsigned long )relsec == (unsigned long )((void *)0)) {
            {
#line 10344
            tmp___34 = gettext("<none>");
#line 10344
            tmp___39 = tmp___34;
            }
          } else {
#line 10344
            if ((unsigned long )string_table == (unsigned long )((void *)0)) {
              {
#line 10344
              tmp___35 = gettext("<no-name>");
#line 10344
              tmp___38 = tmp___35;
              }
            } else {
#line 10344
              if ((unsigned long )relsec->sh_name >= string_table_length) {
                {
#line 10344
                tmp___36 = gettext("<corrupt>");
#line 10344
                tmp___37 = tmp___36;
                }
              } else {
#line 10344
                tmp___37 = string_table + relsec->sh_name;
              }
#line 10344
              tmp___38 = tmp___37;
            }
#line 10344
            tmp___39 = tmp___38;
          }
          {
#line 10344
          tmp___40 = get_symbol_type((unsigned int )((int )sym->st_info & 15));
#line 10344
          tmp___41 = gettext("skipping unexpected symbol type %s in %ld\'th relocation in section %s\n");
#line 10344
          warn((char const   *)tmp___41, tmp___40, rp - relocs, tmp___39);
          }
#line 10348
          goto __Cont___0;
        }
      }
#line 10351
      addend = (bfd_vma )0;
#line 10352
      if (is_rela) {
#line 10353
        addend += rp->r_addend;
      }
#line 10356
      if (! is_rela) {
        {
#line 10365
        tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10365
        addend = (bfd_vma )((elf_vma )addend + tmp___42);
        }
      } else
#line 10356
      if ((int )elf_header.e_machine == 94) {
#line 10356
        if (reloc_type == 1U) {
          {
#line 10365
          tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10365
          addend = (bfd_vma )((elf_vma )addend + tmp___42);
          }
        } else {
#line 10356
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 10356
      if ((int )elf_header.e_machine == 91) {
#line 10356
        goto _L___2;
      } else
#line 10356
      if ((int )elf_header.e_machine == 99) {
        _L___2: /* CIL Label */ 
#line 10356
        if (reloc_type == 1U) {
          {
#line 10365
          tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10365
          addend = (bfd_vma )((elf_vma )addend + tmp___42);
          }
        } else {
#line 10356
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 10356
      if ((int )elf_header.e_machine == 86) {
#line 10356
        goto _L___0;
      } else
#line 10356
      if ((int )elf_header.e_machine == 30326) {
        _L___0: /* CIL Label */ 
#line 10356
        if (reloc_type == 12U) {
          {
#line 10365
          tmp___42 = (*byte_get)(rloc, (int )reloc_size);
#line 10365
          addend = (bfd_vma )((elf_vma )addend + tmp___42);
          }
        }
      }
      {
#line 10367
      tmp___43 = is_32bit_pcrel_reloc(reloc_type);
      }
#line 10367
      if (tmp___43) {
#line 10367
        goto _L___4;
      } else {
        {
#line 10367
        tmp___44 = is_64bit_pcrel_reloc(reloc_type);
        }
#line 10367
        if (tmp___44) {
          _L___4: /* CIL Label */ 
#line 10371
          if ((int )elf_header.e_machine == 15) {
#line 10372
            addend -= 8UL;
          }
          {
#line 10373
          (*byte_put)(rloc, (elf_vma )((addend + sym->st_value) - rp->r_offset), (int )reloc_size);
          }
        } else {
          {
#line 10377
          (*byte_put)(rloc, (elf_vma )(addend + sym->st_value), (int )reloc_size);
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 10279
      rp ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 10380
    free((void *)symtab);
#line 10381
    free((void *)relocs);
    }
#line 10382
    goto while_break;
    __Cont: /* CIL Label */ 
#line 10237
    relsec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10384
  return;
}
}
#line 10402 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char *get_section_contents(Elf_Internal_Shdr *section , FILE *file ) 
{ 
  bfd_size_type num_bytes ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;

  {
#line 10407
  num_bytes = section->sh_size;
#line 10409
  if (num_bytes == 0UL) {
#line 10409
    goto _L;
  } else
#line 10409
  if (section->sh_type == 8U) {
    _L: /* CIL Label */ 
#line 10411
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 10411
      tmp___0 = gettext("<none>");
#line 10411
      tmp___5 = tmp___0;
      }
    } else {
#line 10411
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 10411
        tmp___1 = gettext("<no-name>");
#line 10411
        tmp___4 = tmp___1;
        }
      } else {
#line 10411
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 10411
          tmp___2 = gettext("<corrupt>");
#line 10411
          tmp___3 = tmp___2;
          }
        } else {
#line 10411
          tmp___3 = string_table + section->sh_name;
        }
#line 10411
        tmp___4 = tmp___3;
      }
#line 10411
      tmp___5 = tmp___4;
    }
    {
#line 10411
    tmp___6 = gettext("\nSection \'%s\' has no data to dump.\n");
#line 10411
    printf((char const   */* __restrict  */)tmp___6, tmp___5);
    }
#line 10413
    return ((char *)((void *)0));
  }
  {
#line 10416
  tmp___7 = gettext("section contents");
#line 10416
  tmp___8 = get_data((void *)0, file, section->sh_offset, (size_t )1, num_bytes, (char const   *)tmp___7);
  }
#line 10416
  return ((char *)tmp___8);
}
}
#line 10421 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_section_as_strings(Elf_Internal_Shdr *section , FILE *file ) 
{ 
  Elf_Internal_Shdr *relsec ;
  bfd_size_type num_bytes ;
  char *data ;
  char *end ;
  char *start ;
  char *name___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  bfd_boolean some_strings_shown ;
  char *tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  char *tmp___9 ;

  {
#line 10429
  if ((unsigned long )section == (unsigned long )((void *)0)) {
    {
#line 10429
    tmp___0 = gettext("<none>");
#line 10429
    tmp___5 = tmp___0;
    }
  } else {
#line 10429
    if ((unsigned long )string_table == (unsigned long )((void *)0)) {
      {
#line 10429
      tmp___1 = gettext("<no-name>");
#line 10429
      tmp___4 = tmp___1;
      }
    } else {
#line 10429
      if ((unsigned long )section->sh_name >= string_table_length) {
        {
#line 10429
        tmp___2 = gettext("<corrupt>");
#line 10429
        tmp___3 = tmp___2;
        }
      } else {
#line 10429
        tmp___3 = string_table + section->sh_name;
      }
#line 10429
      tmp___4 = tmp___3;
    }
#line 10429
    tmp___5 = tmp___4;
  }
  {
#line 10429
  name___0 = tmp___5;
#line 10432
  start = get_section_contents(section, file);
  }
#line 10433
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 10434
    return;
  }
  {
#line 10436
  tmp___6 = gettext("\nString dump of section \'%s\':\n");
#line 10436
  printf((char const   */* __restrict  */)tmp___6, name___0);
#line 10443
  relsec = section_headers;
  }
  {
#line 10443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10443
    if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 10443
      goto while_break;
    }
#line 10447
    if (relsec->sh_type != 4U) {
#line 10447
      if (relsec->sh_type != 9U) {
#line 10452
        goto __Cont;
      } else {
#line 10447
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 10447
    if (relsec->sh_info >= elf_header.e_shnum) {
#line 10452
      goto __Cont;
    } else
#line 10447
    if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )section) {
#line 10452
      goto __Cont;
    } else
#line 10447
    if (relsec->sh_size == 0UL) {
#line 10452
      goto __Cont;
    } else
#line 10447
    if (relsec->sh_link >= elf_header.e_shnum) {
#line 10452
      goto __Cont;
    }
    {
#line 10454
    tmp___7 = gettext("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n");
#line 10454
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 10455
    goto while_break;
    __Cont: /* CIL Label */ 
#line 10443
    relsec ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10458
  num_bytes = section->sh_size;
#line 10459
  data = start;
#line 10460
  end = start + num_bytes;
#line 10461
  some_strings_shown = 0;
  {
#line 10463
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 10463
    if (! ((unsigned long )data < (unsigned long )end)) {
#line 10463
      goto while_break___0;
    }
    {
#line 10465
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 10465
      if (! (! ((int const   )_sch_istable[(int )*data & 255] & 16))) {
#line 10465
        goto while_break___1;
      }
#line 10466
      data ++;
#line 10466
      if ((unsigned long )data >= (unsigned long )end) {
#line 10467
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 10469
    if ((unsigned long )data < (unsigned long )end) {
      {
#line 10474
      printf((char const   */* __restrict  */)"  [%6tx]  ", data - start);
#line 10475
      printf((char const   */* __restrict  */)"%s\n", data);
#line 10479
      tmp___8 = strlen((char const   *)data);
#line 10479
      data += tmp___8;
#line 10480
      some_strings_shown = 1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 10484
  if (! some_strings_shown) {
    {
#line 10485
    tmp___9 = gettext("  No strings found in this section.");
#line 10485
    printf((char const   */* __restrict  */)tmp___9);
    }
  }
  {
#line 10487
  free((void *)start);
#line 10489
  putchar('\n');
  }
#line 10490
  return;
}
}
#line 10492 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void dump_section_as_bytes(Elf_Internal_Shdr *section , FILE *file , bfd_boolean relocate ) 
{ 
  Elf_Internal_Shdr *relsec ;
  bfd_size_type bytes ;
  bfd_vma addr ;
  unsigned char *data ;
  unsigned char *start ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int j ;
  int k ;
  int lbytes ;

  {
  {
#line 10503
  tmp___0 = get_section_contents(section, file);
#line 10503
  start = (unsigned char *)tmp___0;
  }
#line 10504
  if ((unsigned long )start == (unsigned long )((void *)0)) {
#line 10505
    return;
  }
#line 10507
  if ((unsigned long )section == (unsigned long )((void *)0)) {
    {
#line 10507
    tmp___1 = gettext("<none>");
#line 10507
    tmp___6 = tmp___1;
    }
  } else {
#line 10507
    if ((unsigned long )string_table == (unsigned long )((void *)0)) {
      {
#line 10507
      tmp___2 = gettext("<no-name>");
#line 10507
      tmp___5 = tmp___2;
      }
    } else {
#line 10507
      if ((unsigned long )section->sh_name >= string_table_length) {
        {
#line 10507
        tmp___3 = gettext("<corrupt>");
#line 10507
        tmp___4 = tmp___3;
        }
      } else {
#line 10507
        tmp___4 = string_table + section->sh_name;
      }
#line 10507
      tmp___5 = tmp___4;
    }
#line 10507
    tmp___6 = tmp___5;
  }
  {
#line 10507
  tmp___7 = gettext("\nHex dump of section \'%s\':\n");
#line 10507
  printf((char const   */* __restrict  */)tmp___7, tmp___6);
  }
#line 10509
  if (relocate) {
    {
#line 10511
    apply_relocations((void *)file, section, start);
    }
  } else {
#line 10520
    relsec = section_headers;
    {
#line 10520
    while (1) {
      while_continue: /* CIL Label */ ;
#line 10520
      if (! ((unsigned long )relsec < (unsigned long )(section_headers + elf_header.e_shnum))) {
#line 10520
        goto while_break;
      }
#line 10524
      if (relsec->sh_type != 4U) {
#line 10524
        if (relsec->sh_type != 9U) {
#line 10529
          goto __Cont;
        } else {
#line 10524
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 10524
      if (relsec->sh_info >= elf_header.e_shnum) {
#line 10529
        goto __Cont;
      } else
#line 10524
      if ((unsigned long )(section_headers + relsec->sh_info) != (unsigned long )section) {
#line 10529
        goto __Cont;
      } else
#line 10524
      if (relsec->sh_size == 0UL) {
#line 10529
        goto __Cont;
      } else
#line 10524
      if (relsec->sh_link >= elf_header.e_shnum) {
#line 10529
        goto __Cont;
      }
      {
#line 10531
      tmp___8 = gettext(" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n");
#line 10531
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 10532
      goto while_break;
      __Cont: /* CIL Label */ 
#line 10520
      relsec ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 10536
  addr = section->sh_addr;
#line 10537
  bytes = section->sh_size;
#line 10538
  data = start;
  {
#line 10540
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 10540
    if (! bytes) {
#line 10540
      goto while_break___0;
    }
#line 10546
    if (bytes > 16UL) {
#line 10546
      lbytes = 16;
    } else {
#line 10546
      lbytes = (int )bytes;
    }
    {
#line 10548
    printf((char const   */* __restrict  */)"  0x%8.8lx ", addr);
#line 10550
    j = 0;
    }
    {
#line 10550
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 10550
      if (! (j < 16)) {
#line 10550
        goto while_break___1;
      }
#line 10552
      if (j < lbytes) {
        {
#line 10553
        printf((char const   */* __restrict  */)"%2.2x", (int )*(data + j));
        }
      } else {
        {
#line 10555
        printf((char const   */* __restrict  */)"  ");
        }
      }
#line 10557
      if ((j & 3) == 3) {
        {
#line 10558
        printf((char const   */* __restrict  */)" ");
        }
      }
#line 10550
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 10561
    j = 0;
    {
#line 10561
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 10561
      if (! (j < lbytes)) {
#line 10561
        goto while_break___2;
      }
#line 10563
      k = (int )*(data + j);
#line 10564
      if (k >= 32) {
#line 10564
        if (k < 127) {
          {
#line 10565
          printf((char const   */* __restrict  */)"%c", k);
          }
        } else {
          {
#line 10567
          printf((char const   */* __restrict  */)".");
          }
        }
      } else {
        {
#line 10567
        printf((char const   */* __restrict  */)".");
        }
      }
#line 10561
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 10570
    putchar('\n');
#line 10572
    data += lbytes;
#line 10573
    addr += (bfd_vma )lbytes;
#line 10574
    bytes -= (bfd_size_type )lbytes;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 10577
  free((void *)start);
#line 10579
  putchar('\n');
  }
#line 10580
  return;
}
}
#line 10584 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int uncompress_section_contents(unsigned char **buffer___2  __attribute__((__unused__)) ,
                                       dwarf_size_type *size  __attribute__((__unused__)) ) 
{ 
  dwarf_size_type compressed_size ;
  unsigned char *compressed_buffer ;
  dwarf_size_type uncompressed_size ;
  unsigned char *uncompressed_buffer ;
  z_stream strm ;
  int rc ;
  dwarf_size_type header_size ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 10591
  compressed_size = *size;
#line 10592
  compressed_buffer = *buffer___2;
#line 10597
  header_size = (dwarf_size_type )12;
#line 10601
  if (compressed_size < header_size) {
#line 10603
    return (0);
  } else {
    {
#line 10601
    tmp___0 = strcmp((char const   *)((char *)compressed_buffer), "ZLIB");
    }
#line 10601
    if (! (tmp___0 == 0)) {
#line 10603
      return (0);
    }
  }
  {
#line 10605
  uncompressed_size = (dwarf_size_type )*(compressed_buffer + 4);
#line 10605
  uncompressed_size <<= 8;
#line 10606
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 5);
#line 10606
  uncompressed_size <<= 8;
#line 10607
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 6);
#line 10607
  uncompressed_size <<= 8;
#line 10608
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 7);
#line 10608
  uncompressed_size <<= 8;
#line 10609
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 8);
#line 10609
  uncompressed_size <<= 8;
#line 10610
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 9);
#line 10610
  uncompressed_size <<= 8;
#line 10611
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 10);
#line 10611
  uncompressed_size <<= 8;
#line 10612
  uncompressed_size += (dwarf_size_type )*(compressed_buffer + 11);
#line 10616
  strm.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))((void *)0);
#line 10617
  strm.zfree = (void (*)(voidpf opaque , voidpf address ))((void *)0);
#line 10618
  strm.opaque = (void *)0;
#line 10619
  strm.avail_in = (uInt )(compressed_size - header_size);
#line 10620
  strm.next_in = compressed_buffer + header_size;
#line 10621
  strm.avail_out = (uInt )uncompressed_size;
#line 10622
  tmp___1 = xmalloc((size_t )uncompressed_size);
#line 10622
  uncompressed_buffer = (unsigned char *)tmp___1;
#line 10624
  rc = inflateInit_(& strm, "1.2.11", (int )sizeof(z_stream ));
  }
  {
#line 10625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10625
    if (! (strm.avail_in > 0U)) {
#line 10625
      goto while_break;
    }
#line 10627
    if (rc != 0) {
#line 10628
      goto fail;
    }
    {
#line 10629
    strm.next_out = uncompressed_buffer + (uncompressed_size - (dwarf_size_type )strm.avail_out);
#line 10631
    rc = inflate(& strm, 4);
    }
#line 10632
    if (rc != 1) {
#line 10633
      goto fail;
    }
    {
#line 10634
    rc = inflateReset(& strm);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10636
  rc = inflateEnd(& strm);
  }
#line 10637
  if (rc != 0) {
#line 10639
    goto fail;
  } else
#line 10637
  if (strm.avail_out != 0U) {
#line 10639
    goto fail;
  }
  {
#line 10641
  free((void *)compressed_buffer);
#line 10642
  *buffer___2 = uncompressed_buffer;
#line 10643
  *size = uncompressed_size;
  }
#line 10644
  return (1);
  fail: 
  {
#line 10647
  free((void *)uncompressed_buffer);
#line 10649
  *buffer___2 = (unsigned char *)((void *)0);
  }
#line 10650
  return (0);
}
}
#line 10654 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int load_specific_debug_section(enum dwarf_section_display_enum debug , Elf_Internal_Shdr *sec ,
                                       void *file ) 
{ 
  struct dwarf_section *section ;
  char buf___4[64] ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 10658
  section = & debug_displays[debug].section;
#line 10662
  if ((unsigned long )section->start != (unsigned long )((void *)0)) {
#line 10663
    return (1);
  }
  {
#line 10665
  tmp___0 = gettext("%s section data");
#line 10665
  snprintf((char */* __restrict  */)(buf___4), sizeof(buf___4), (char const   */* __restrict  */)tmp___0,
           section->name);
#line 10666
  section->address = (dwarf_vma )sec->sh_addr;
#line 10667
  tmp___1 = get_data((void *)0, (FILE *)file, sec->sh_offset, (size_t )1, sec->sh_size,
                     (char const   *)(buf___4));
#line 10667
  section->start = (unsigned char *)tmp___1;
  }
#line 10670
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 10671
    section->size = (dwarf_size_type )0;
  } else {
    {
#line 10674
    section->size = (dwarf_size_type )sec->sh_size;
#line 10675
    tmp___2 = uncompress_section_contents(& section->start, & section->size);
    }
#line 10675
    if (tmp___2) {
#line 10676
      sec->sh_size = (bfd_size_type )section->size;
    }
  }
#line 10679
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 10680
    return (0);
  }
#line 10682
  if (debug_displays[debug].relocate) {
    {
#line 10683
    apply_relocations((void *)((FILE *)file), sec, section->start);
    }
  }
#line 10685
  return (1);
}
}
#line 10688 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
int load_debug_section(enum dwarf_section_display_enum debug , void *file ) 
{ 
  struct dwarf_section *section ;
  Elf_Internal_Shdr *sec ;
  int tmp___0 ;

  {
  {
#line 10691
  section = & debug_displays[debug].section;
#line 10695
  sec = find_section(section->uncompressed_name);
  }
#line 10696
  if ((unsigned long )sec != (unsigned long )((void *)0)) {
#line 10697
    section->name = section->uncompressed_name;
  } else {
    {
#line 10700
    sec = find_section(section->compressed_name);
    }
#line 10701
    if ((unsigned long )sec != (unsigned long )((void *)0)) {
#line 10702
      section->name = section->compressed_name;
    }
  }
#line 10704
  if ((unsigned long )sec == (unsigned long )((void *)0)) {
#line 10705
    return (0);
  }
  {
#line 10707
  tmp___0 = load_specific_debug_section(debug, sec, (void *)((FILE *)file));
  }
#line 10707
  return (tmp___0);
}
}
#line 10710 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
void free_debug_section(enum dwarf_section_display_enum debug ) 
{ 
  struct dwarf_section *section ;

  {
#line 10713
  section = & debug_displays[debug].section;
#line 10715
  if ((unsigned long )section->start == (unsigned long )((void *)0)) {
#line 10716
    return;
  }
  {
#line 10718
  free((void *)((char *)section->start));
#line 10719
  section->start = (unsigned char *)((void *)0);
#line 10720
  section->address = (dwarf_vma )0;
#line 10721
  section->size = (dwarf_size_type )0;
  }
#line 10722
  return;
}
}
#line 10724 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int display_debug_section(Elf_Internal_Shdr *section , FILE *file ) 
{ 
  char *name___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  bfd_size_type length ;
  int result ;
  int i ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  struct dwarf_section *sec ;
  int secondary ;
  Elf_Internal_Shdr *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;

  {
#line 10727
  if ((unsigned long )section == (unsigned long )((void *)0)) {
    {
#line 10727
    tmp___0 = gettext("<none>");
#line 10727
    tmp___5 = tmp___0;
    }
  } else {
#line 10727
    if ((unsigned long )string_table == (unsigned long )((void *)0)) {
      {
#line 10727
      tmp___1 = gettext("<no-name>");
#line 10727
      tmp___4 = tmp___1;
      }
    } else {
#line 10727
      if ((unsigned long )section->sh_name >= string_table_length) {
        {
#line 10727
        tmp___2 = gettext("<corrupt>");
#line 10727
        tmp___3 = tmp___2;
        }
      } else {
#line 10727
        tmp___3 = string_table + section->sh_name;
      }
#line 10727
      tmp___4 = tmp___3;
    }
#line 10727
    tmp___5 = tmp___4;
  }
#line 10727
  name___0 = tmp___5;
#line 10729
  result = 1;
#line 10732
  length = section->sh_size;
#line 10733
  if (length == 0UL) {
    {
#line 10735
    tmp___6 = gettext("\nSection \'%s\' has no debugging data.\n");
#line 10735
    printf((char const   */* __restrict  */)tmp___6, name___0);
    }
#line 10736
    return (0);
  }
#line 10738
  if (section->sh_type == 8U) {
    {
#line 10744
    tmp___7 = gettext("section \'%s\' has the NOBITS type - its contents are unreliable.\n");
#line 10744
    printf((char const   */* __restrict  */)tmp___7, name___0);
    }
#line 10745
    return (0);
  }
  {
#line 10748
  tmp___8 = strncmp((char const   *)name___0, ".gnu.linkonce.wi.", sizeof(".gnu.linkonce.wi.") - 1UL);
  }
#line 10748
  if (tmp___8 == 0) {
#line 10749
    name___0 = (char *)".debug_info";
  }
#line 10752
  i = 0;
  {
#line 10752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10752
    if (! (i < 32)) {
#line 10752
      goto while_break;
    }
    {
#line 10753
    tmp___13 = strcmp(debug_displays[i].section.uncompressed_name, (char const   *)name___0);
    }
#line 10753
    if (tmp___13 == 0) {
#line 10753
      goto _L;
    } else {
      {
#line 10753
      tmp___14 = strcmp(debug_displays[i].section.compressed_name, (char const   *)name___0);
      }
#line 10753
      if (tmp___14 == 0) {
        _L: /* CIL Label */ 
        {
#line 10756
        sec = & debug_displays[i].section;
#line 10757
        tmp___9 = find_section((char const   *)name___0);
#line 10757
        secondary = (unsigned long )section != (unsigned long )tmp___9;
        }
#line 10759
        if (secondary) {
          {
#line 10760
          free_debug_section((enum dwarf_section_display_enum )i);
          }
        }
        {
#line 10762
        tmp___10 = strcmp(sec->uncompressed_name, (char const   *)name___0);
        }
#line 10762
        if (tmp___10 == 0) {
#line 10763
          sec->name = sec->uncompressed_name;
        } else {
#line 10765
          sec->name = sec->compressed_name;
        }
        {
#line 10766
        tmp___12 = load_specific_debug_section((enum dwarf_section_display_enum )i,
                                               section, (void *)file);
        }
#line 10766
        if (tmp___12) {
          {
#line 10769
          tmp___11 = (*(debug_displays[i].display))(sec, (void *)file);
#line 10769
          result &= tmp___11;
          }
#line 10771
          if (secondary) {
            {
#line 10772
            free_debug_section((enum dwarf_section_display_enum )i);
            }
          } else
#line 10771
          if (i != 3) {
#line 10771
            if (i != 0) {
              {
#line 10772
              free_debug_section((enum dwarf_section_display_enum )i);
              }
            }
          }
        }
#line 10775
        goto while_break;
      }
    }
#line 10752
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 10778
  if (i == 32) {
    {
#line 10780
    tmp___15 = gettext("Unrecognized debug section: %s\n");
#line 10780
    printf((char const   */* __restrict  */)tmp___15, name___0);
#line 10781
    result = 0;
    }
  }
#line 10784
  return (result);
}
}
#line 10790 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void initialise_dumps_byname(void) 
{ 
  struct dump_list_entry *cur ;
  unsigned int i ;
  int any ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 10795
  cur = dump_sects_byname;
  {
#line 10795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10795
    if (! cur) {
#line 10795
      goto while_break;
    }
#line 10800
    i = 0U;
#line 10800
    any = 0;
    {
#line 10800
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 10800
      if (! (i < elf_header.e_shnum)) {
#line 10800
        goto while_break___0;
      }
#line 10801
      if ((unsigned long )(section_headers + i) == (unsigned long )((void *)0)) {
        {
#line 10801
        tmp___0 = gettext("<none>");
#line 10801
        tmp___5 = tmp___0;
        }
      } else {
#line 10801
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 10801
          tmp___1 = gettext("<no-name>");
#line 10801
          tmp___4 = tmp___1;
          }
        } else {
#line 10801
          if ((unsigned long )(section_headers + i)->sh_name >= string_table_length) {
            {
#line 10801
            tmp___2 = gettext("<corrupt>");
#line 10801
            tmp___3 = tmp___2;
            }
          } else {
#line 10801
            tmp___3 = string_table + (section_headers + i)->sh_name;
          }
#line 10801
          tmp___4 = tmp___3;
        }
#line 10801
        tmp___5 = tmp___4;
      }
      {
#line 10801
      tmp___6 = strcmp((char const   *)tmp___5, (char const   *)cur->name);
      }
#line 10801
      if (tmp___6 == 0) {
        {
#line 10803
        request_dump_bynumber(i, cur->type);
#line 10804
        any = 1;
        }
      }
#line 10800
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 10807
    if (! any) {
      {
#line 10808
      tmp___7 = gettext("Section \'%s\' was not dumped because it does not exist!\n");
#line 10808
      warn((char const   *)tmp___7, cur->name);
      }
    }
#line 10795
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 10811
  return;
}
}
#line 10813 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void process_section_contents(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned int i ;
  char *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 10819
  if (! do_dump) {
#line 10820
    return;
  }
  {
#line 10822
  initialise_dumps_byname();
#line 10824
  i = 0U;
#line 10824
  section = section_headers;
  }
  {
#line 10824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 10824
    if (i < elf_header.e_shnum) {
#line 10824
      if (! (i < num_dump_sects)) {
#line 10824
        goto while_break;
      }
    } else {
#line 10824
      goto while_break;
    }
#line 10832
    if ((int )*(dump_sects + i) & 1) {
      {
#line 10833
      dump_section_as_bytes(section, file, 0);
      }
    }
#line 10835
    if ((int )*(dump_sects + i) & (1 << 4)) {
      {
#line 10836
      dump_section_as_bytes(section, file, 1);
      }
    }
#line 10838
    if ((int )*(dump_sects + i) & (1 << 3)) {
      {
#line 10839
      dump_section_as_strings(section, file);
      }
    }
#line 10841
    if ((int )*(dump_sects + i) & (1 << 2)) {
      {
#line 10842
      display_debug_section(section, file);
      }
    }
#line 10824
    i ++;
#line 10824
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 10847
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 10847
    tmp___1 = i;
#line 10847
    i ++;
#line 10847
    if (! (tmp___1 < num_dump_sects)) {
#line 10847
      goto while_break___0;
    }
#line 10848
    if (*(dump_sects + i)) {
      {
#line 10849
      tmp___0 = gettext("Section %d was not dumped because it does not exist!\n");
#line 10849
      warn((char const   *)tmp___0, i);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 10850
  return;
}
}
#line 10852 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void process_mips_fpe_exception(int mask ) 
{ 
  int first ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 10855
  if (mask) {
#line 10857
    first = 1;
#line 10858
    if (mask & 1) {
      {
#line 10859
      fputs((char const   */* __restrict  */)"INEX", (FILE */* __restrict  */)stdout);
#line 10859
      first = 0;
      }
    }
#line 10860
    if (mask & 2) {
#line 10861
      if (first) {
#line 10861
        tmp___0 = "";
      } else {
#line 10861
        tmp___0 = "|";
      }
      {
#line 10861
      printf((char const   */* __restrict  */)"%sUFLO", tmp___0);
#line 10861
      first = 0;
      }
    }
#line 10862
    if (mask & 4) {
#line 10863
      if (first) {
#line 10863
        tmp___1 = "";
      } else {
#line 10863
        tmp___1 = "|";
      }
      {
#line 10863
      printf((char const   */* __restrict  */)"%sOFLO", tmp___1);
#line 10863
      first = 0;
      }
    }
#line 10864
    if (mask & 8) {
#line 10865
      if (first) {
#line 10865
        tmp___2 = "";
      } else {
#line 10865
        tmp___2 = "|";
      }
      {
#line 10865
      printf((char const   */* __restrict  */)"%sDIV0", tmp___2);
#line 10865
      first = 0;
      }
    }
#line 10866
    if (mask & 16) {
#line 10867
      if (first) {
#line 10867
        tmp___3 = "";
      } else {
#line 10867
        tmp___3 = "|";
      }
      {
#line 10867
      printf((char const   */* __restrict  */)"%sINVAL", tmp___3);
      }
    }
  } else {
    {
#line 10870
    fputs((char const   */* __restrict  */)"0", (FILE */* __restrict  */)stdout);
    }
  }
#line 10871
  return;
}
}
#line 10883 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_CPU_arch[15]  = 
#line 10883
  {      "Pre-v4",      "v4",      "v4T",      "v5T", 
        "v5TE",      "v5TEJ",      "v6",      "v6KZ", 
        "v6T2",      "v6K",      "v7",      "v6-M", 
        "v6S-M",      "v7E-M",      "v8"};
#line 10886 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ARM_ISA_use[2]  = {      "No",      "Yes"};
#line 10887 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_THUMB_ISA_use[3]  = {      "No",      "Thumb-1",      "Thumb-2"};
#line 10889 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_FP_arch[8]  = 
#line 10889
  {      "No",      "VFPv1",      "VFPv2",      "VFPv3", 
        "VFPv3-D16",      "VFPv4",      "VFPv4-D16",      "FP for ARMv8"};
#line 10892 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_WMMX_arch[3]  = {      "No",      "WMMXv1",      "WMMXv2"};
#line 10893 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_Advanced_SIMD_arch[4]  = {      "No",      "NEONv1",      "NEONv1 with Fused-MAC",      "NEON for ARMv8"};
#line 10895 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_PCS_config[8]  = 
#line 10895
  {      "None",      "Bare platform",      "Linux application",      "Linux DSO", 
        "PalmOS 2004",      "PalmOS (reserved)",      "SymbianOS 2004",      "SymbianOS (reserved)"};
#line 10898 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_R9_use[4]  = {      "V6",      "SB",      "TLS",      "Unused"};
#line 10900 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_RW_data[4]  = {      "Absolute",      "PC-relative",      "SB-relative",      "None"};
#line 10902 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_RO_data[3]  = {      "Absolute",      "PC-relative",      "None"};
#line 10904 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_GOT_use[3]  = {      "None",      "direct",      "GOT-indirect"};
#line 10906 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_PCS_wchar_t[5]  = {      "None",      "??? 1",      "2",      "??? 3", 
        "4"};
#line 10908 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_rounding[2]  = {      "Unused",      "Needed"};
#line 10909 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_denormal[3]  = {      "Unused",      "Needed",      "Sign only"};
#line 10911 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_exceptions[2]  = {      "Unused",      "Needed"};
#line 10912 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_user_exceptions[2]  = {      "Unused",      "Needed"};
#line 10913 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_number_model[4]  = {      "Unused",      "Finite",      "RTABI",      "IEEE 754"};
#line 10915 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_enum_size[4]  = {      "Unused",      "small",      "int",      "forced to int"};
#line 10917 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_HardFP_use[4]  = {      "As Tag_FP_arch",      "SP only",      "DP only",      "SP and DP"};
#line 10919 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_VFP_args[3]  = {      "AAPCS",      "VFP registers",      "custom"};
#line 10921 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_WMMX_args[3]  = {      "AAPCS",      "WMMX registers",      "custom"};
#line 10923 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_optimization_goals[7]  = {      "None",      "Prefer Speed",      "Aggressive Speed",      "Prefer Size", 
        "Aggressive Size",      "Prefer Debug",      "Aggressive Debug"};
#line 10926 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_optimization_goals[7]  = {      "None",      "Prefer Speed",      "Aggressive Speed",      "Prefer Size", 
        "Aggressive Size",      "Prefer Accuracy",      "Aggressive Accuracy"};
#line 10929 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_CPU_unaligned_access[2]  = {      "None",      "v6"};
#line 10930 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_FP_HP_extension[2]  = {      "Not Allowed",      "Allowed"};
#line 10932 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_ABI_FP_16bit_format[3]  = {      "None",      "IEEE 754",      "Alternative Format"};
#line 10934 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_MPextension_use[2]  = {      "Not Allowed",      "Allowed"};
#line 10936 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_DIV_use[3]  = {      "Allowed in Thumb-ISA, v7-R or v7-M",      "Not allowed",      "Allowed in v7-A with integer division extension"};
#line 10939 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_T2EE_use[2]  = {      "Not Allowed",      "Allowed"};
#line 10940 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_Virtualization_use[4]  = {      "Not Allowed",      "TrustZone",      "Virtualization Extensions",      "TrustZone and Virtualization Extensions"};
#line 10943 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *arm_attr_tag_MPextension_use_legacy[2]  = {      "Not Allowed",      "Allowed"};
#line 10948 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static arm_attr_public_tag arm_attr_public_tags[40]  = 
#line 10948
  {      {4, "CPU_raw_name", 1, (char const   **)((void *)0)}, 
        {5, "CPU_name", 1, (char const   **)((void *)0)}, 
        {6, "CPU_arch", (int )(128UL | sizeof(arm_attr_tag_CPU_arch) / sizeof(arm_attr_tag_CPU_arch[0])),
      arm_attr_tag_CPU_arch}, 
        {7, "CPU_arch_profile", 0, (char const   **)((void *)0)}, 
        {8, "ARM_ISA_use", (int )(128UL | sizeof(arm_attr_tag_ARM_ISA_use) / sizeof(arm_attr_tag_ARM_ISA_use[0])),
      arm_attr_tag_ARM_ISA_use}, 
        {9, "THUMB_ISA_use", (int )(128UL | sizeof(arm_attr_tag_THUMB_ISA_use) / sizeof(arm_attr_tag_THUMB_ISA_use[0])),
      arm_attr_tag_THUMB_ISA_use}, 
        {10, "FP_arch", (int )(128UL | sizeof(arm_attr_tag_FP_arch) / sizeof(arm_attr_tag_FP_arch[0])),
      arm_attr_tag_FP_arch}, 
        {11, "WMMX_arch", (int )(128UL | sizeof(arm_attr_tag_WMMX_arch) / sizeof(arm_attr_tag_WMMX_arch[0])),
      arm_attr_tag_WMMX_arch}, 
        {12, "Advanced_SIMD_arch", (int )(128UL | sizeof(arm_attr_tag_Advanced_SIMD_arch) / sizeof(arm_attr_tag_Advanced_SIMD_arch[0])),
      arm_attr_tag_Advanced_SIMD_arch}, 
        {13, "PCS_config", (int )(128UL | sizeof(arm_attr_tag_PCS_config) / sizeof(arm_attr_tag_PCS_config[0])),
      arm_attr_tag_PCS_config}, 
        {14, "ABI_PCS_R9_use", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_R9_use) / sizeof(arm_attr_tag_ABI_PCS_R9_use[0])),
      arm_attr_tag_ABI_PCS_R9_use}, 
        {15, "ABI_PCS_RW_data", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_RW_data) / sizeof(arm_attr_tag_ABI_PCS_RW_data[0])),
      arm_attr_tag_ABI_PCS_RW_data}, 
        {16, "ABI_PCS_RO_data", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_RO_data) / sizeof(arm_attr_tag_ABI_PCS_RO_data[0])),
      arm_attr_tag_ABI_PCS_RO_data}, 
        {17, "ABI_PCS_GOT_use", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_GOT_use) / sizeof(arm_attr_tag_ABI_PCS_GOT_use[0])),
      arm_attr_tag_ABI_PCS_GOT_use}, 
        {18, "ABI_PCS_wchar_t", (int )(128UL | sizeof(arm_attr_tag_ABI_PCS_wchar_t) / sizeof(arm_attr_tag_ABI_PCS_wchar_t[0])),
      arm_attr_tag_ABI_PCS_wchar_t}, 
        {19, "ABI_FP_rounding", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_rounding) / sizeof(arm_attr_tag_ABI_FP_rounding[0])),
      arm_attr_tag_ABI_FP_rounding}, 
        {20, "ABI_FP_denormal", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_denormal) / sizeof(arm_attr_tag_ABI_FP_denormal[0])),
      arm_attr_tag_ABI_FP_denormal}, 
        {21, "ABI_FP_exceptions", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_exceptions) / sizeof(arm_attr_tag_ABI_FP_exceptions[0])),
      arm_attr_tag_ABI_FP_exceptions}, 
        {22, "ABI_FP_user_exceptions", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_user_exceptions) / sizeof(arm_attr_tag_ABI_FP_user_exceptions[0])),
      arm_attr_tag_ABI_FP_user_exceptions}, 
        {23, "ABI_FP_number_model", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_number_model) / sizeof(arm_attr_tag_ABI_FP_number_model[0])),
      arm_attr_tag_ABI_FP_number_model}, 
        {24, "ABI_align_needed", 0, (char const   **)((void *)0)}, 
        {25, "ABI_align_preserved", 0, (char const   **)((void *)0)}, 
        {26, "ABI_enum_size", (int )(128UL | sizeof(arm_attr_tag_ABI_enum_size) / sizeof(arm_attr_tag_ABI_enum_size[0])),
      arm_attr_tag_ABI_enum_size}, 
        {27, "ABI_HardFP_use", (int )(128UL | sizeof(arm_attr_tag_ABI_HardFP_use) / sizeof(arm_attr_tag_ABI_HardFP_use[0])),
      arm_attr_tag_ABI_HardFP_use}, 
        {28, "ABI_VFP_args", (int )(128UL | sizeof(arm_attr_tag_ABI_VFP_args) / sizeof(arm_attr_tag_ABI_VFP_args[0])),
      arm_attr_tag_ABI_VFP_args}, 
        {29, "ABI_WMMX_args", (int )(128UL | sizeof(arm_attr_tag_ABI_WMMX_args) / sizeof(arm_attr_tag_ABI_WMMX_args[0])),
      arm_attr_tag_ABI_WMMX_args}, 
        {30, "ABI_optimization_goals", (int )(128UL | sizeof(arm_attr_tag_ABI_optimization_goals) / sizeof(arm_attr_tag_ABI_optimization_goals[0])),
      arm_attr_tag_ABI_optimization_goals}, 
        {31, "ABI_FP_optimization_goals", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_optimization_goals) / sizeof(arm_attr_tag_ABI_FP_optimization_goals[0])),
      arm_attr_tag_ABI_FP_optimization_goals}, 
        {32, "compatibility", 0, (char const   **)((void *)0)}, 
        {34, "CPU_unaligned_access", (int )(128UL | sizeof(arm_attr_tag_CPU_unaligned_access) / sizeof(arm_attr_tag_CPU_unaligned_access[0])),
      arm_attr_tag_CPU_unaligned_access}, 
        {36, "FP_HP_extension", (int )(128UL | sizeof(arm_attr_tag_FP_HP_extension) / sizeof(arm_attr_tag_FP_HP_extension[0])),
      arm_attr_tag_FP_HP_extension}, 
        {38, "ABI_FP_16bit_format", (int )(128UL | sizeof(arm_attr_tag_ABI_FP_16bit_format) / sizeof(arm_attr_tag_ABI_FP_16bit_format[0])),
      arm_attr_tag_ABI_FP_16bit_format}, 
        {42, "MPextension_use", (int )(128UL | sizeof(arm_attr_tag_MPextension_use) / sizeof(arm_attr_tag_MPextension_use[0])),
      arm_attr_tag_MPextension_use}, 
        {44, "DIV_use", (int )(128UL | sizeof(arm_attr_tag_DIV_use) / sizeof(arm_attr_tag_DIV_use[0])),
      arm_attr_tag_DIV_use}, 
        {64, "nodefaults", 0, (char const   **)((void *)0)}, 
        {65, "also_compatible_with", 0, (char const   **)((void *)0)}, 
        {66, "T2EE_use", (int )(128UL | sizeof(arm_attr_tag_T2EE_use) / sizeof(arm_attr_tag_T2EE_use[0])),
      arm_attr_tag_T2EE_use}, 
        {67, "conformance", 1, (char const   **)((void *)0)}, 
        {68, "Virtualization_use", (int )(128UL | sizeof(arm_attr_tag_Virtualization_use) / sizeof(arm_attr_tag_Virtualization_use[0])),
      arm_attr_tag_Virtualization_use}, 
        {70, "MPextension_use_legacy", (int )(128UL | sizeof(arm_attr_tag_MPextension_use_legacy) / sizeof(arm_attr_tag_MPextension_use_legacy[0])),
      arm_attr_tag_MPextension_use_legacy}};
#line 10993 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned char *display_arm_attribute(unsigned char *p ) 
{ 
  int tag ;
  unsigned int len ;
  int val ;
  arm_attr_public_tag *attr ;
  unsigned int i ;
  int type ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned long tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  unsigned long tmp___17 ;
  char *tmp___18 ;
  size_t tmp___19 ;
  char *tmp___20 ;
  unsigned long tmp___21 ;
  unsigned long tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned long tmp___24 ;
  size_t tmp___25 ;
  unsigned long tmp___26 ;

  {
  {
#line 11003
  tmp___0 = read_uleb128(p, & len);
#line 11003
  tag = (int )tmp___0;
#line 11004
  p += len;
#line 11005
  attr = (arm_attr_public_tag *)((void *)0);
#line 11006
  i = 0U;
  }
  {
#line 11006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11006
    if (! ((unsigned long )i < sizeof(arm_attr_public_tags) / sizeof(arm_attr_public_tags[0]))) {
#line 11006
      goto while_break;
    }
#line 11008
    if (arm_attr_public_tags[i].tag == tag) {
#line 11010
      attr = & arm_attr_public_tags[i];
#line 11011
      goto while_break;
    }
#line 11006
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11015
  if (attr) {
    {
#line 11017
    printf((char const   */* __restrict  */)"  Tag_%s: ", attr->name);
    }
    {
#line 11020
    if (attr->type == 0) {
#line 11020
      goto case_0;
    }
#line 11110
    if (attr->type == 2) {
#line 11110
      goto case_2___1;
    }
#line 11110
    if (attr->type == 1) {
#line 11110
      goto case_2___1;
    }
#line 11114
    goto switch_default___3;
    case_0: /* CIL Label */ 
    {
#line 11023
    if (tag == 7) {
#line 11023
      goto case_7;
    }
#line 11037
    if (tag == 24) {
#line 11037
      goto case_24;
    }
#line 11056
    if (tag == 25) {
#line 11056
      goto case_25;
    }
#line 11075
    if (tag == 32) {
#line 11075
      goto case_32;
    }
#line 11082
    if (tag == 64) {
#line 11082
      goto case_64;
    }
#line 11087
    if (tag == 65) {
#line 11087
      goto case_65___0;
    }
#line 11104
    goto switch_default___2;
    case_7: /* CIL Label */ 
    {
#line 11024
    tmp___1 = read_uleb128(p, & len);
#line 11024
    val = (int )tmp___1;
#line 11025
    p += len;
    }
    {
#line 11028
    if (val == 0) {
#line 11028
      goto case_0___0;
    }
#line 11029
    if (val == 65) {
#line 11029
      goto case_65;
    }
#line 11030
    if (val == 82) {
#line 11030
      goto case_82;
    }
#line 11031
    if (val == 77) {
#line 11031
      goto case_77;
    }
#line 11032
    if (val == 83) {
#line 11032
      goto case_83;
    }
#line 11033
    goto switch_default;
    case_0___0: /* CIL Label */ 
    {
#line 11028
    tmp___2 = gettext("None\n");
#line 11028
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 11028
    goto switch_break___1;
    case_65: /* CIL Label */ 
    {
#line 11029
    tmp___3 = gettext("Application\n");
#line 11029
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 11029
    goto switch_break___1;
    case_82: /* CIL Label */ 
    {
#line 11030
    tmp___4 = gettext("Realtime\n");
#line 11030
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 11030
    goto switch_break___1;
    case_77: /* CIL Label */ 
    {
#line 11031
    tmp___5 = gettext("Microcontroller\n");
#line 11031
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 11031
    goto switch_break___1;
    case_83: /* CIL Label */ 
    {
#line 11032
    tmp___6 = gettext("Application or Realtime\n");
#line 11032
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 11032
    goto switch_break___1;
    switch_default: /* CIL Label */ 
    {
#line 11033
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11033
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 11035
    goto switch_break___0;
    case_24: /* CIL Label */ 
    {
#line 11038
    tmp___7 = read_uleb128(p, & len);
#line 11038
    val = (int )tmp___7;
#line 11039
    p += len;
    }
    {
#line 11042
    if (val == 0) {
#line 11042
      goto case_0___1;
    }
#line 11043
    if (val == 1) {
#line 11043
      goto case_1;
    }
#line 11044
    if (val == 2) {
#line 11044
      goto case_2;
    }
#line 11045
    if (val == 3) {
#line 11045
      goto case_3;
    }
#line 11046
    goto switch_default___0;
    case_0___1: /* CIL Label */ 
    {
#line 11042
    tmp___8 = gettext("None\n");
#line 11042
    printf((char const   */* __restrict  */)tmp___8);
    }
#line 11042
    goto switch_break___2;
    case_1: /* CIL Label */ 
    {
#line 11043
    tmp___9 = gettext("8-byte\n");
#line 11043
    printf((char const   */* __restrict  */)tmp___9);
    }
#line 11043
    goto switch_break___2;
    case_2: /* CIL Label */ 
    {
#line 11044
    tmp___10 = gettext("4-byte\n");
#line 11044
    printf((char const   */* __restrict  */)tmp___10);
    }
#line 11044
    goto switch_break___2;
    case_3: /* CIL Label */ 
    {
#line 11045
    printf((char const   */* __restrict  */)"??? 3\n");
    }
#line 11045
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 11047
    if (val <= 12) {
      {
#line 11048
      tmp___11 = gettext("8-byte and up to %d-byte extended\n");
#line 11048
      printf((char const   */* __restrict  */)tmp___11, 1 << val);
      }
    } else {
      {
#line 11051
      printf((char const   */* __restrict  */)"??? (%d)\n", val);
      }
    }
#line 11052
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 11054
    goto switch_break___0;
    case_25: /* CIL Label */ 
    {
#line 11057
    tmp___12 = read_uleb128(p, & len);
#line 11057
    val = (int )tmp___12;
#line 11058
    p += len;
    }
    {
#line 11061
    if (val == 0) {
#line 11061
      goto case_0___2;
    }
#line 11062
    if (val == 1) {
#line 11062
      goto case_1___0;
    }
#line 11063
    if (val == 2) {
#line 11063
      goto case_2___0;
    }
#line 11064
    if (val == 3) {
#line 11064
      goto case_3___0;
    }
#line 11065
    goto switch_default___1;
    case_0___2: /* CIL Label */ 
    {
#line 11061
    tmp___13 = gettext("None\n");
#line 11061
    printf((char const   */* __restrict  */)tmp___13);
    }
#line 11061
    goto switch_break___3;
    case_1___0: /* CIL Label */ 
    {
#line 11062
    tmp___14 = gettext("8-byte, except leaf SP\n");
#line 11062
    printf((char const   */* __restrict  */)tmp___14);
    }
#line 11062
    goto switch_break___3;
    case_2___0: /* CIL Label */ 
    {
#line 11063
    tmp___15 = gettext("8-byte\n");
#line 11063
    printf((char const   */* __restrict  */)tmp___15);
    }
#line 11063
    goto switch_break___3;
    case_3___0: /* CIL Label */ 
    {
#line 11064
    printf((char const   */* __restrict  */)"??? 3\n");
    }
#line 11064
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
#line 11066
    if (val <= 12) {
      {
#line 11067
      tmp___16 = gettext("8-byte and up to %d-byte extended\n");
#line 11067
      printf((char const   */* __restrict  */)tmp___16, 1 << val);
      }
    } else {
      {
#line 11070
      printf((char const   */* __restrict  */)"??? (%d)\n", val);
      }
    }
#line 11071
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 11073
    goto switch_break___0;
    case_32: /* CIL Label */ 
    {
#line 11076
    tmp___17 = read_uleb128(p, & len);
#line 11076
    val = (int )tmp___17;
#line 11077
    p += len;
#line 11078
    tmp___18 = gettext("flag = %d, vendor = %s\n");
#line 11078
    printf((char const   */* __restrict  */)tmp___18, val, p);
#line 11079
    tmp___19 = strlen((char const   *)((char *)p));
#line 11079
    p += tmp___19 + 1UL;
    }
#line 11080
    goto switch_break___0;
    case_64: /* CIL Label */ 
    {
#line 11083
    p ++;
#line 11084
    tmp___20 = gettext("True\n");
#line 11084
    printf((char const   */* __restrict  */)tmp___20);
    }
#line 11085
    goto switch_break___0;
    case_65___0: /* CIL Label */ 
    {
#line 11088
    tmp___21 = read_uleb128(p, & len);
#line 11088
    val = (int )tmp___21;
#line 11089
    p += len;
    }
#line 11090
    if (val == 6) {
      {
#line 11092
      tmp___22 = read_uleb128(p, & len);
#line 11092
      val = (int )tmp___22;
#line 11093
      p += len;
      }
#line 11094
      if ((unsigned long )((unsigned int )val) >= sizeof(arm_attr_tag_CPU_arch) / sizeof(arm_attr_tag_CPU_arch[0])) {
        {
#line 11095
        printf((char const   */* __restrict  */)"??? (%d)\n", val);
        }
      } else {
        {
#line 11097
        printf((char const   */* __restrict  */)"%s\n", arm_attr_tag_CPU_arch[val]);
        }
      }
    } else {
      {
#line 11100
      printf((char const   */* __restrict  */)"???\n");
      }
    }
    {
#line 11101
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 11101
      tmp___23 = p;
#line 11101
      p ++;
#line 11101
      if (! ((int )*tmp___23 != 0)) {
#line 11101
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 11102
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
    {
#line 11105
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 11107
    return (p);
    case_2___1: /* CIL Label */ 
    case_1___1: /* CIL Label */ 
#line 11111
    type = attr->type;
#line 11112
    goto switch_break;
    switch_default___3: /* CIL Label */ 
#line 11115
    if (! (attr->type & 128)) {
      {
#line 11115
      __assert_fail("attr->type & 0x80", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                    11115U, "display_arm_attribute");
      }
    }
    {
#line 11116
    tmp___24 = read_uleb128(p, & len);
#line 11116
    val = (int )tmp___24;
#line 11117
    p += len;
#line 11118
    type = attr->type & 127;
    }
#line 11119
    if (val >= type) {
      {
#line 11120
      printf((char const   */* __restrict  */)"??? (%d)\n", val);
      }
    } else {
      {
#line 11122
      printf((char const   */* __restrict  */)"%s\n", *(attr->table + val));
      }
    }
#line 11123
    return (p);
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 11128
    if (tag & 1) {
#line 11129
      type = 1;
    } else {
#line 11131
      type = 2;
    }
    {
#line 11132
    printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
    }
  }
#line 11135
  if (type == 1) {
    {
#line 11137
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11138
    tmp___25 = strlen((char const   *)((char *)p));
#line 11138
    p += tmp___25 + 1UL;
    }
  } else {
    {
#line 11142
    tmp___26 = read_uleb128(p, & len);
#line 11142
    val = (int )tmp___26;
#line 11143
    p += len;
#line 11144
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 11147
  return (p);
}
}
#line 11150 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned char *display_gnu_attribute(unsigned char *p , unsigned char *(*display_proc_gnu_attribute)(unsigned char * ,
                                                                                                            int  ) ) 
{ 
  int tag ;
  unsigned int len ;
  int val ;
  int type ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  unsigned char *tmp___4 ;
  size_t tmp___5 ;
  unsigned long tmp___6 ;

  {
  {
#line 11159
  tmp___0 = read_uleb128(p, & len);
#line 11159
  tag = (int )tmp___0;
#line 11160
  p += len;
  }
#line 11164
  if (tag == 32) {
    {
#line 11166
    tmp___1 = read_uleb128(p, & len);
#line 11166
    val = (int )tmp___1;
#line 11167
    p += len;
#line 11168
    tmp___2 = gettext("flag = %d, vendor = %s\n");
#line 11168
    printf((char const   */* __restrict  */)tmp___2, val, p);
#line 11169
    tmp___3 = strlen((char const   *)((char *)p));
#line 11169
    p += tmp___3 + 1UL;
    }
#line 11170
    return (p);
  }
#line 11173
  if ((tag & 2) == 0) {
#line 11173
    if (display_proc_gnu_attribute) {
      {
#line 11174
      tmp___4 = (*display_proc_gnu_attribute)(p, tag);
      }
#line 11174
      return (tmp___4);
    }
  }
#line 11176
  if (tag & 1) {
#line 11177
    type = 1;
  } else {
#line 11179
    type = 2;
  }
  {
#line 11180
  printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
  }
#line 11182
  if (type == 1) {
    {
#line 11184
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11185
    tmp___5 = strlen((char const   *)((char *)p));
#line 11185
    p += tmp___5 + 1UL;
    }
  } else {
    {
#line 11189
    tmp___6 = read_uleb128(p, & len);
#line 11189
    val = (int )tmp___6;
#line 11190
    p += len;
#line 11191
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 11194
  return (p);
}
}
#line 11197 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned char *display_power_gnu_attribute(unsigned char *p , int tag ) 
{ 
  int type ;
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  unsigned long tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  unsigned long tmp___12 ;

  {
#line 11204
  if (tag == 4) {
    {
#line 11206
    tmp___0 = read_uleb128(p, & len);
#line 11206
    val = (int )tmp___0;
#line 11207
    p += len;
#line 11208
    printf((char const   */* __restrict  */)"  Tag_GNU_Power_ABI_FP: ");
    }
    {
#line 11212
    if (val == 0) {
#line 11212
      goto case_0;
    }
#line 11215
    if (val == 1) {
#line 11215
      goto case_1;
    }
#line 11218
    if (val == 2) {
#line 11218
      goto case_2;
    }
#line 11221
    if (val == 3) {
#line 11221
      goto case_3;
    }
#line 11224
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 11213
    tmp___1 = gettext("Hard or soft float\n");
#line 11213
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 11214
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 11216
    tmp___2 = gettext("Hard float\n");
#line 11216
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 11217
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 11219
    tmp___3 = gettext("Soft float\n");
#line 11219
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 11220
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 11222
    tmp___4 = gettext("Single-precision hard float\n");
#line 11222
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 11223
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 11225
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11226
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 11228
    return (p);
  }
#line 11231
  if (tag == 8) {
    {
#line 11233
    tmp___5 = read_uleb128(p, & len);
#line 11233
    val = (int )tmp___5;
#line 11234
    p += len;
#line 11235
    printf((char const   */* __restrict  */)"  Tag_GNU_Power_ABI_Vector: ");
    }
    {
#line 11238
    if (val == 0) {
#line 11238
      goto case_0___0;
    }
#line 11241
    if (val == 1) {
#line 11241
      goto case_1___0;
    }
#line 11244
    if (val == 2) {
#line 11244
      goto case_2___0;
    }
#line 11247
    if (val == 3) {
#line 11247
      goto case_3___0;
    }
#line 11250
    goto switch_default___0;
    case_0___0: /* CIL Label */ 
    {
#line 11239
    tmp___6 = gettext("Any\n");
#line 11239
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 11240
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
    {
#line 11242
    tmp___7 = gettext("Generic\n");
#line 11242
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 11243
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 11245
    printf((char const   */* __restrict  */)"AltiVec\n");
    }
#line 11246
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 11248
    printf((char const   */* __restrict  */)"SPE\n");
    }
#line 11249
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 11251
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11252
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 11254
    return (p);
  }
#line 11257
  if (tag == 12) {
    {
#line 11259
    tmp___8 = read_uleb128(p, & len);
#line 11259
    val = (int )tmp___8;
#line 11260
    p += len;
#line 11261
    printf((char const   */* __restrict  */)"  Tag_GNU_Power_ABI_Struct_Return: ");
    }
    {
#line 11264
    if (val == 0) {
#line 11264
      goto case_0___1;
    }
#line 11267
    if (val == 1) {
#line 11267
      goto case_1___1;
    }
#line 11270
    if (val == 2) {
#line 11270
      goto case_2___1;
    }
#line 11273
    goto switch_default___1;
    case_0___1: /* CIL Label */ 
    {
#line 11265
    tmp___9 = gettext("Any\n");
#line 11265
    printf((char const   */* __restrict  */)tmp___9);
    }
#line 11266
    goto switch_break___1;
    case_1___1: /* CIL Label */ 
    {
#line 11268
    printf((char const   */* __restrict  */)"r3/r4\n");
    }
#line 11269
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 11271
    tmp___10 = gettext("Memory\n");
#line 11271
    printf((char const   */* __restrict  */)tmp___10);
    }
#line 11272
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
    {
#line 11274
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11275
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 11277
    return (p);
  }
#line 11280
  if (tag & 1) {
#line 11281
    type = 1;
  } else {
#line 11283
    type = 2;
  }
  {
#line 11284
  printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
  }
#line 11286
  if (type == 1) {
    {
#line 11288
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11289
    tmp___11 = strlen((char const   *)((char *)p));
#line 11289
    p += tmp___11 + 1UL;
    }
  } else {
    {
#line 11293
    tmp___12 = read_uleb128(p, & len);
#line 11293
    val = (int )tmp___12;
#line 11294
    p += len;
#line 11295
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 11298
  return (p);
}
}
#line 11301 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static void display_sparc_hwcaps(int mask ) 
{ 
  int first ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;

  {
#line 11304
  if (mask) {
#line 11306
    first = 1;
#line 11307
    if (mask & 1) {
      {
#line 11308
      fputs((char const   */* __restrict  */)"mul32", (FILE */* __restrict  */)stdout);
#line 11308
      first = 0;
      }
    }
#line 11309
    if (mask & 2) {
#line 11310
      if (first) {
#line 11310
        tmp___0 = "";
      } else {
#line 11310
        tmp___0 = "|";
      }
      {
#line 11310
      printf((char const   */* __restrict  */)"%sdiv32", tmp___0);
#line 11310
      first = 0;
      }
    }
#line 11311
    if (mask & 4) {
#line 11312
      if (first) {
#line 11312
        tmp___1 = "";
      } else {
#line 11312
        tmp___1 = "|";
      }
      {
#line 11312
      printf((char const   */* __restrict  */)"%sfsmuld", tmp___1);
#line 11312
      first = 0;
      }
    }
#line 11313
    if (mask & 8) {
#line 11314
      if (first) {
#line 11314
        tmp___2 = "";
      } else {
#line 11314
        tmp___2 = "|";
      }
      {
#line 11314
      printf((char const   */* __restrict  */)"%sv8plus", tmp___2);
#line 11314
      first = 0;
      }
    }
#line 11315
    if (mask & 16) {
#line 11316
      if (first) {
#line 11316
        tmp___3 = "";
      } else {
#line 11316
        tmp___3 = "|";
      }
      {
#line 11316
      printf((char const   */* __restrict  */)"%spopc", tmp___3);
#line 11316
      first = 0;
      }
    }
#line 11317
    if (mask & 32) {
#line 11318
      if (first) {
#line 11318
        tmp___4 = "";
      } else {
#line 11318
        tmp___4 = "|";
      }
      {
#line 11318
      printf((char const   */* __restrict  */)"%svis", tmp___4);
#line 11318
      first = 0;
      }
    }
#line 11319
    if (mask & 64) {
#line 11320
      if (first) {
#line 11320
        tmp___5 = "";
      } else {
#line 11320
        tmp___5 = "|";
      }
      {
#line 11320
      printf((char const   */* __restrict  */)"%svis2", tmp___5);
#line 11320
      first = 0;
      }
    }
#line 11321
    if (mask & 128) {
#line 11322
      if (first) {
#line 11322
        tmp___6 = "";
      } else {
#line 11322
        tmp___6 = "|";
      }
      {
#line 11322
      printf((char const   */* __restrict  */)"%sASIBlkInit", tmp___6);
#line 11322
      first = 0;
      }
    }
#line 11323
    if (mask & 256) {
#line 11324
      if (first) {
#line 11324
        tmp___7 = "";
      } else {
#line 11324
        tmp___7 = "|";
      }
      {
#line 11324
      printf((char const   */* __restrict  */)"%sfmaf", tmp___7);
#line 11324
      first = 0;
      }
    }
#line 11325
    if (mask & 1024) {
#line 11326
      if (first) {
#line 11326
        tmp___8 = "";
      } else {
#line 11326
        tmp___8 = "|";
      }
      {
#line 11326
      printf((char const   */* __restrict  */)"%svis3", tmp___8);
#line 11326
      first = 0;
      }
    }
#line 11327
    if (mask & 2048) {
#line 11328
      if (first) {
#line 11328
        tmp___9 = "";
      } else {
#line 11328
        tmp___9 = "|";
      }
      {
#line 11328
      printf((char const   */* __restrict  */)"%shpc", tmp___9);
#line 11328
      first = 0;
      }
    }
#line 11329
    if (mask & 4096) {
#line 11330
      if (first) {
#line 11330
        tmp___10 = "";
      } else {
#line 11330
        tmp___10 = "|";
      }
      {
#line 11330
      printf((char const   */* __restrict  */)"%srandom", tmp___10);
#line 11330
      first = 0;
      }
    }
#line 11331
    if (mask & 8192) {
#line 11332
      if (first) {
#line 11332
        tmp___11 = "";
      } else {
#line 11332
        tmp___11 = "|";
      }
      {
#line 11332
      printf((char const   */* __restrict  */)"%strans", tmp___11);
#line 11332
      first = 0;
      }
    }
#line 11333
    if (mask & 16384) {
#line 11334
      if (first) {
#line 11334
        tmp___12 = "";
      } else {
#line 11334
        tmp___12 = "|";
      }
      {
#line 11334
      printf((char const   */* __restrict  */)"%sfjfmau", tmp___12);
#line 11334
      first = 0;
      }
    }
#line 11335
    if (mask & 32768) {
#line 11336
      if (first) {
#line 11336
        tmp___13 = "";
      } else {
#line 11336
        tmp___13 = "|";
      }
      {
#line 11336
      printf((char const   */* __restrict  */)"%sima", tmp___13);
#line 11336
      first = 0;
      }
    }
#line 11337
    if (mask & 65536) {
#line 11338
      if (first) {
#line 11338
        tmp___14 = "";
      } else {
#line 11338
        tmp___14 = "|";
      }
      {
#line 11338
      printf((char const   */* __restrict  */)"%scspare", tmp___14);
#line 11338
      first = 0;
      }
    }
  } else {
    {
#line 11341
    fputc('0', stdout);
    }
  }
  {
#line 11342
  fputc('\n', stdout);
  }
#line 11343
  return;
}
}
#line 11345 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned char *display_sparc_gnu_attribute(unsigned char *p , int tag ) 
{ 
  int type ;
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  size_t tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 11352
  if (tag == 4) {
    {
#line 11354
    tmp___0 = read_uleb128(p, & len);
#line 11354
    val = (int )tmp___0;
#line 11355
    p += len;
#line 11356
    printf((char const   */* __restrict  */)"  Tag_GNU_Sparc_HWCAPS: ");
#line 11358
    display_sparc_hwcaps(val);
    }
#line 11359
    return (p);
  }
#line 11362
  if (tag & 1) {
#line 11363
    type = 1;
  } else {
#line 11365
    type = 2;
  }
  {
#line 11366
  printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
  }
#line 11368
  if (type == 1) {
    {
#line 11370
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11371
    tmp___1 = strlen((char const   *)((char *)p));
#line 11371
    p += tmp___1 + 1UL;
    }
  } else {
    {
#line 11375
    tmp___2 = read_uleb128(p, & len);
#line 11375
    val = (int )tmp___2;
#line 11376
    p += len;
#line 11377
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 11380
  return (p);
}
}
#line 11383 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned char *display_mips_gnu_attribute(unsigned char *p , int tag ) 
{ 
  int type ;
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  unsigned long tmp___7 ;

  {
#line 11390
  if (tag == 4) {
    {
#line 11392
    tmp___0 = read_uleb128(p, & len);
#line 11392
    val = (int )tmp___0;
#line 11393
    p += len;
#line 11394
    printf((char const   */* __restrict  */)"  Tag_GNU_MIPS_ABI_FP: ");
    }
    {
#line 11398
    if (val == 0) {
#line 11398
      goto case_0;
    }
#line 11401
    if (val == 1) {
#line 11401
      goto case_1;
    }
#line 11404
    if (val == 2) {
#line 11404
      goto case_2;
    }
#line 11407
    if (val == 3) {
#line 11407
      goto case_3;
    }
#line 11410
    if (val == 4) {
#line 11410
      goto case_4;
    }
#line 11413
    goto switch_default;
    case_0: /* CIL Label */ 
    {
#line 11399
    tmp___1 = gettext("Hard or soft float\n");
#line 11399
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 11400
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 11402
    tmp___2 = gettext("Hard float (double precision)\n");
#line 11402
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 11403
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 11405
    tmp___3 = gettext("Hard float (single precision)\n");
#line 11405
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 11406
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 11408
    tmp___4 = gettext("Soft float\n");
#line 11408
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 11409
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 11411
    tmp___5 = gettext("Hard float (MIPS32r2 64-bit FPU)\n");
#line 11411
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 11412
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 11414
    printf((char const   */* __restrict  */)"??? (%d)\n", val);
    }
#line 11415
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 11417
    return (p);
  }
#line 11420
  if (tag & 1) {
#line 11421
    type = 1;
  } else {
#line 11423
    type = 2;
  }
  {
#line 11424
  printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
  }
#line 11426
  if (type == 1) {
    {
#line 11428
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11429
    tmp___6 = strlen((char const   *)((char *)p));
#line 11429
    p += tmp___6 + 1UL;
    }
  } else {
    {
#line 11433
    tmp___7 = read_uleb128(p, & len);
#line 11433
    val = (int )tmp___7;
#line 11434
    p += len;
#line 11435
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 11438
  return (p);
}
}
#line 11441 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static unsigned char *display_tic6x_attribute(unsigned char *p ) 
{ 
  int tag ;
  unsigned int len ;
  int val ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned long tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  unsigned long tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  unsigned long tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  unsigned long tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  unsigned long tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  unsigned long tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned long tmp___31 ;
  char *tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  unsigned long tmp___36 ;

  {
  {
#line 11448
  tmp___0 = read_uleb128(p, & len);
#line 11448
  tag = (int )tmp___0;
#line 11449
  p += len;
  }
  {
#line 11453
  if (tag == 4) {
#line 11453
    goto case_4;
  }
#line 11487
  if (tag == 6) {
#line 11487
    goto case_6___0;
  }
#line 11508
  if (tag == 8) {
#line 11508
    goto case_8___0;
  }
#line 11526
  if (tag == 10) {
#line 11526
    goto case_10;
  }
#line 11544
  if (tag == 12) {
#line 11544
    goto case_12;
  }
#line 11562
  if (tag == 14) {
#line 11562
    goto case_14;
  }
#line 11583
  if (tag == 16) {
#line 11583
    goto case_16;
  }
#line 11601
  if (tag == 18) {
#line 11601
    goto case_18;
  }
#line 11622
  if (tag == 20) {
#line 11622
    goto case_20;
  }
#line 11643
  if (tag == 32) {
#line 11643
    goto case_32;
  }
#line 11651
  if (tag == 67) {
#line 11651
    goto case_67;
  }
#line 11451
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 11454
  tmp___1 = read_uleb128(p, & len);
#line 11454
  val = (int )tmp___1;
#line 11455
  p += len;
#line 11456
  printf((char const   */* __restrict  */)"  Tag_ISA: ");
  }
  {
#line 11460
  if (val == 0) {
#line 11460
    goto case_0;
  }
#line 11463
  if (val == 1) {
#line 11463
    goto case_1;
  }
#line 11466
  if (val == 3) {
#line 11466
    goto case_3;
  }
#line 11469
  if (val == 4) {
#line 11469
    goto case_4___0;
  }
#line 11472
  if (val == 6) {
#line 11472
    goto case_6;
  }
#line 11475
  if (val == 7) {
#line 11475
    goto case_7;
  }
#line 11478
  if (val == 8) {
#line 11478
    goto case_8;
  }
#line 11481
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 11461
  tmp___2 = gettext("None\n");
#line 11461
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 11462
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 11464
  printf((char const   */* __restrict  */)"C62x\n");
  }
#line 11465
  goto switch_break___0;
  case_3: /* CIL Label */ 
  {
#line 11467
  printf((char const   */* __restrict  */)"C67x\n");
  }
#line 11468
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
  {
#line 11470
  printf((char const   */* __restrict  */)"C67x+\n");
  }
#line 11471
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 11473
  printf((char const   */* __restrict  */)"C64x\n");
  }
#line 11474
  goto switch_break___0;
  case_7: /* CIL Label */ 
  {
#line 11476
  printf((char const   */* __restrict  */)"C64x+\n");
  }
#line 11477
  goto switch_break___0;
  case_8: /* CIL Label */ 
  {
#line 11479
  printf((char const   */* __restrict  */)"C674x\n");
  }
#line 11480
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 11482
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11483
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 11485
  return (p);
  case_6___0: /* CIL Label */ 
  {
#line 11488
  tmp___3 = read_uleb128(p, & len);
#line 11488
  val = (int )tmp___3;
#line 11489
  p += len;
#line 11490
  printf((char const   */* __restrict  */)"  Tag_ABI_wchar_t: ");
  }
  {
#line 11493
  if (val == 0) {
#line 11493
    goto case_0___0;
  }
#line 11496
  if (val == 1) {
#line 11496
    goto case_1___0;
  }
#line 11499
  if (val == 2) {
#line 11499
    goto case_2;
  }
#line 11502
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
  {
#line 11494
  tmp___4 = gettext("Not used\n");
#line 11494
  printf((char const   */* __restrict  */)tmp___4);
  }
#line 11495
  goto switch_break___1;
  case_1___0: /* CIL Label */ 
  {
#line 11497
  tmp___5 = gettext("2 bytes\n");
#line 11497
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 11498
  goto switch_break___1;
  case_2: /* CIL Label */ 
  {
#line 11500
  tmp___6 = gettext("4 bytes\n");
#line 11500
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 11501
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 11503
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11504
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 11506
  return (p);
  case_8___0: /* CIL Label */ 
  {
#line 11509
  tmp___7 = read_uleb128(p, & len);
#line 11509
  val = (int )tmp___7;
#line 11510
  p += len;
#line 11511
  printf((char const   */* __restrict  */)"  Tag_ABI_stack_align_needed: ");
  }
  {
#line 11514
  if (val == 0) {
#line 11514
    goto case_0___1;
  }
#line 11517
  if (val == 1) {
#line 11517
    goto case_1___1;
  }
#line 11520
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
  {
#line 11515
  tmp___8 = gettext("8-byte\n");
#line 11515
  printf((char const   */* __restrict  */)tmp___8);
  }
#line 11516
  goto switch_break___2;
  case_1___1: /* CIL Label */ 
  {
#line 11518
  tmp___9 = gettext("16-byte\n");
#line 11518
  printf((char const   */* __restrict  */)tmp___9);
  }
#line 11519
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 11521
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11522
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 11524
  return (p);
  case_10: /* CIL Label */ 
  {
#line 11527
  tmp___10 = read_uleb128(p, & len);
#line 11527
  val = (int )tmp___10;
#line 11528
  p += len;
#line 11529
  printf((char const   */* __restrict  */)"  Tag_ABI_stack_align_preserved: ");
  }
  {
#line 11532
  if (val == 0) {
#line 11532
    goto case_0___2;
  }
#line 11535
  if (val == 1) {
#line 11535
    goto case_1___2;
  }
#line 11538
  goto switch_default___2;
  case_0___2: /* CIL Label */ 
  {
#line 11533
  tmp___11 = gettext("8-byte\n");
#line 11533
  printf((char const   */* __restrict  */)tmp___11);
  }
#line 11534
  goto switch_break___3;
  case_1___2: /* CIL Label */ 
  {
#line 11536
  tmp___12 = gettext("16-byte\n");
#line 11536
  printf((char const   */* __restrict  */)tmp___12);
  }
#line 11537
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 11539
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11540
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 11542
  return (p);
  case_12: /* CIL Label */ 
  {
#line 11545
  tmp___13 = read_uleb128(p, & len);
#line 11545
  val = (int )tmp___13;
#line 11546
  p += len;
#line 11547
  printf((char const   */* __restrict  */)"  Tag_ABI_DSBT: ");
  }
  {
#line 11550
  if (val == 0) {
#line 11550
    goto case_0___3;
  }
#line 11553
  if (val == 1) {
#line 11553
    goto case_1___3;
  }
#line 11556
  goto switch_default___3;
  case_0___3: /* CIL Label */ 
  {
#line 11551
  tmp___14 = gettext("DSBT addressing not used\n");
#line 11551
  printf((char const   */* __restrict  */)tmp___14);
  }
#line 11552
  goto switch_break___4;
  case_1___3: /* CIL Label */ 
  {
#line 11554
  tmp___15 = gettext("DSBT addressing used\n");
#line 11554
  printf((char const   */* __restrict  */)tmp___15);
  }
#line 11555
  goto switch_break___4;
  switch_default___3: /* CIL Label */ 
  {
#line 11557
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11558
  goto switch_break___4;
  switch_break___4: /* CIL Label */ ;
  }
#line 11560
  return (p);
  case_14: /* CIL Label */ 
  {
#line 11563
  tmp___16 = read_uleb128(p, & len);
#line 11563
  val = (int )tmp___16;
#line 11564
  p += len;
#line 11565
  printf((char const   */* __restrict  */)"  Tag_ABI_PID: ");
  }
  {
#line 11568
  if (val == 0) {
#line 11568
    goto case_0___4;
  }
#line 11571
  if (val == 1) {
#line 11571
    goto case_1___4;
  }
#line 11574
  if (val == 2) {
#line 11574
    goto case_2___0;
  }
#line 11577
  goto switch_default___4;
  case_0___4: /* CIL Label */ 
  {
#line 11569
  tmp___17 = gettext("Data addressing position-dependent\n");
#line 11569
  printf((char const   */* __restrict  */)tmp___17);
  }
#line 11570
  goto switch_break___5;
  case_1___4: /* CIL Label */ 
  {
#line 11572
  tmp___18 = gettext("Data addressing position-independent, GOT near DP\n");
#line 11572
  printf((char const   */* __restrict  */)tmp___18);
  }
#line 11573
  goto switch_break___5;
  case_2___0: /* CIL Label */ 
  {
#line 11575
  tmp___19 = gettext("Data addressing position-independent, GOT far from DP\n");
#line 11575
  printf((char const   */* __restrict  */)tmp___19);
  }
#line 11576
  goto switch_break___5;
  switch_default___4: /* CIL Label */ 
  {
#line 11578
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11579
  goto switch_break___5;
  switch_break___5: /* CIL Label */ ;
  }
#line 11581
  return (p);
  case_16: /* CIL Label */ 
  {
#line 11584
  tmp___20 = read_uleb128(p, & len);
#line 11584
  val = (int )tmp___20;
#line 11585
  p += len;
#line 11586
  printf((char const   */* __restrict  */)"  Tag_ABI_PIC: ");
  }
  {
#line 11589
  if (val == 0) {
#line 11589
    goto case_0___5;
  }
#line 11592
  if (val == 1) {
#line 11592
    goto case_1___5;
  }
#line 11595
  goto switch_default___5;
  case_0___5: /* CIL Label */ 
  {
#line 11590
  tmp___21 = gettext("Code addressing position-dependent\n");
#line 11590
  printf((char const   */* __restrict  */)tmp___21);
  }
#line 11591
  goto switch_break___6;
  case_1___5: /* CIL Label */ 
  {
#line 11593
  tmp___22 = gettext("Code addressing position-independent\n");
#line 11593
  printf((char const   */* __restrict  */)tmp___22);
  }
#line 11594
  goto switch_break___6;
  switch_default___5: /* CIL Label */ 
  {
#line 11596
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11597
  goto switch_break___6;
  switch_break___6: /* CIL Label */ ;
  }
#line 11599
  return (p);
  case_18: /* CIL Label */ 
  {
#line 11602
  tmp___23 = read_uleb128(p, & len);
#line 11602
  val = (int )tmp___23;
#line 11603
  p += len;
#line 11604
  printf((char const   */* __restrict  */)"  Tag_ABI_array_object_alignment: ");
  }
  {
#line 11607
  if (val == 0) {
#line 11607
    goto case_0___6;
  }
#line 11610
  if (val == 1) {
#line 11610
    goto case_1___6;
  }
#line 11613
  if (val == 2) {
#line 11613
    goto case_2___1;
  }
#line 11616
  goto switch_default___6;
  case_0___6: /* CIL Label */ 
  {
#line 11608
  tmp___24 = gettext("8-byte\n");
#line 11608
  printf((char const   */* __restrict  */)tmp___24);
  }
#line 11609
  goto switch_break___7;
  case_1___6: /* CIL Label */ 
  {
#line 11611
  tmp___25 = gettext("4-byte\n");
#line 11611
  printf((char const   */* __restrict  */)tmp___25);
  }
#line 11612
  goto switch_break___7;
  case_2___1: /* CIL Label */ 
  {
#line 11614
  tmp___26 = gettext("16-byte\n");
#line 11614
  printf((char const   */* __restrict  */)tmp___26);
  }
#line 11615
  goto switch_break___7;
  switch_default___6: /* CIL Label */ 
  {
#line 11617
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11618
  goto switch_break___7;
  switch_break___7: /* CIL Label */ ;
  }
#line 11620
  return (p);
  case_20: /* CIL Label */ 
  {
#line 11623
  tmp___27 = read_uleb128(p, & len);
#line 11623
  val = (int )tmp___27;
#line 11624
  p += len;
#line 11625
  printf((char const   */* __restrict  */)"  Tag_ABI_array_object_align_expected: ");
  }
  {
#line 11628
  if (val == 0) {
#line 11628
    goto case_0___7;
  }
#line 11631
  if (val == 1) {
#line 11631
    goto case_1___7;
  }
#line 11634
  if (val == 2) {
#line 11634
    goto case_2___2;
  }
#line 11637
  goto switch_default___7;
  case_0___7: /* CIL Label */ 
  {
#line 11629
  tmp___28 = gettext("8-byte\n");
#line 11629
  printf((char const   */* __restrict  */)tmp___28);
  }
#line 11630
  goto switch_break___8;
  case_1___7: /* CIL Label */ 
  {
#line 11632
  tmp___29 = gettext("4-byte\n");
#line 11632
  printf((char const   */* __restrict  */)tmp___29);
  }
#line 11633
  goto switch_break___8;
  case_2___2: /* CIL Label */ 
  {
#line 11635
  tmp___30 = gettext("16-byte\n");
#line 11635
  printf((char const   */* __restrict  */)tmp___30);
  }
#line 11636
  goto switch_break___8;
  switch_default___7: /* CIL Label */ 
  {
#line 11638
  printf((char const   */* __restrict  */)"??? (%d)\n", val);
  }
#line 11639
  goto switch_break___8;
  switch_break___8: /* CIL Label */ ;
  }
#line 11641
  return (p);
  case_32: /* CIL Label */ 
  {
#line 11644
  tmp___31 = read_uleb128(p, & len);
#line 11644
  val = (int )tmp___31;
#line 11645
  p += len;
#line 11646
  printf((char const   */* __restrict  */)"  Tag_ABI_compatibility: ");
#line 11647
  tmp___32 = gettext("flag = %d, vendor = %s\n");
#line 11647
  printf((char const   */* __restrict  */)tmp___32, val, p);
#line 11648
  tmp___33 = strlen((char const   *)((char *)p));
#line 11648
  p += tmp___33 + 1UL;
  }
#line 11649
  return (p);
  case_67: /* CIL Label */ 
  {
#line 11652
  printf((char const   */* __restrict  */)"  Tag_ABI_conformance: ");
#line 11653
  printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11654
  tmp___34 = strlen((char const   *)((char *)p));
#line 11654
  p += tmp___34 + 1UL;
  }
#line 11655
  return (p);
  switch_break: /* CIL Label */ ;
  }
  {
#line 11658
  printf((char const   */* __restrict  */)"  Tag_unknown_%d: ", tag);
  }
#line 11660
  if (tag & 1) {
    {
#line 11662
    printf((char const   */* __restrict  */)"\"%s\"\n", p);
#line 11663
    tmp___35 = strlen((char const   *)((char *)p));
#line 11663
    p += tmp___35 + 1UL;
    }
  } else {
    {
#line 11667
    tmp___36 = read_uleb128(p, & len);
#line 11667
    val = (int )tmp___36;
#line 11668
    p += len;
#line 11669
    printf((char const   */* __restrict  */)"%d (0x%x)\n", val, val);
    }
  }
#line 11672
  return (p);
}
}
#line 11675 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_attributes(FILE *file , char const   *public_name , unsigned int proc_type ,
                              unsigned char *(*display_pub_attribute)(unsigned char * ) ,
                              unsigned char *(*display_proc_gnu_attribute)(unsigned char * ,
                                                                           int  ) ) 
{ 
  Elf_Internal_Shdr *sect ;
  unsigned char *contents ;
  unsigned char *p ;
  unsigned char *end ;
  bfd_vma section_len ;
  bfd_vma len ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  int namelen ;
  bfd_boolean public_section ;
  bfd_boolean gnu_section ;
  elf_vma tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  int tag ;
  unsigned char *tmp___8 ;
  int val ;
  bfd_vma size ;
  elf_vma tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  unsigned int j ;
  unsigned long tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 11691
  i = 0U;
#line 11691
  sect = section_headers;
  {
#line 11691
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11691
    if (! (i < elf_header.e_shnum)) {
#line 11691
      goto while_break;
    }
#line 11695
    if (sect->sh_type != proc_type) {
#line 11695
      if (sect->sh_type != 1879048181U) {
#line 11696
        goto __Cont;
      }
    }
    {
#line 11698
    tmp___0 = gettext("attributes");
#line 11698
    tmp___1 = get_data((void *)0, file, sect->sh_offset, (size_t )1, sect->sh_size,
                       (char const   *)tmp___0);
#line 11698
    contents = (unsigned char *)tmp___1;
    }
#line 11700
    if ((unsigned long )contents == (unsigned long )((void *)0)) {
#line 11701
      goto __Cont;
    }
#line 11703
    p = contents;
#line 11704
    if ((int )*p == 65) {
#line 11706
      len = sect->sh_size - 1UL;
#line 11707
      p ++;
      {
#line 11709
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 11709
        if (! (len > 0UL)) {
#line 11709
          goto while_break___0;
        }
        {
#line 11715
        tmp___2 = (*byte_get)(p, 4);
#line 11715
        section_len = (bfd_vma )tmp___2;
#line 11716
        p += 4;
        }
#line 11718
        if (section_len > len) {
          {
#line 11720
          tmp___3 = gettext("ERROR: Bad section length (%d > %d)\n");
#line 11720
          printf((char const   */* __restrict  */)tmp___3, (int )section_len, (int )len);
#line 11722
          section_len = len;
          }
        }
        {
#line 11725
        len -= section_len;
#line 11726
        tmp___4 = gettext("Attribute Section: %s\n");
#line 11726
        printf((char const   */* __restrict  */)tmp___4, p);
        }
#line 11728
        if (public_name) {
          {
#line 11728
          tmp___5 = strcmp((char const   *)((char *)p), public_name);
          }
#line 11728
          if (tmp___5 == 0) {
#line 11729
            public_section = 1;
          } else {
#line 11731
            public_section = 0;
          }
        } else {
#line 11731
          public_section = 0;
        }
        {
#line 11733
        tmp___6 = strcmp((char const   *)((char *)p), "gnu");
        }
#line 11733
        if (tmp___6 == 0) {
#line 11734
          gnu_section = 1;
        } else {
#line 11736
          gnu_section = 0;
        }
        {
#line 11738
        tmp___7 = strlen((char const   *)((char *)p));
#line 11738
        namelen = (int )(tmp___7 + 1UL);
#line 11739
        p += namelen;
#line 11740
        section_len -= (bfd_vma )(namelen + 4);
        }
        {
#line 11742
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 11742
          if (! (section_len > 0UL)) {
#line 11742
            goto while_break___1;
          }
          {
#line 11744
          tmp___8 = p;
#line 11744
          p ++;
#line 11744
          tag = (int )*tmp___8;
#line 11748
          tmp___9 = (*byte_get)(p, 4);
#line 11748
          size = (bfd_vma )tmp___9;
          }
#line 11749
          if (size > section_len) {
            {
#line 11751
            tmp___10 = gettext("ERROR: Bad subsection length (%d > %d)\n");
#line 11751
            printf((char const   */* __restrict  */)tmp___10, (int )size, (int )section_len);
#line 11753
            size = section_len;
            }
          }
#line 11756
          section_len -= size;
#line 11757
          end = (p + size) - 1;
#line 11758
          p += 4;
          {
#line 11762
          if (tag == 1) {
#line 11762
            goto case_1;
          }
#line 11765
          if (tag == 2) {
#line 11765
            goto case_2;
          }
#line 11768
          if (tag == 3) {
#line 11768
            goto case_3;
          }
#line 11783
          goto switch_default;
          case_1: /* CIL Label */ 
          {
#line 11763
          tmp___11 = gettext("File Attributes\n");
#line 11763
          printf((char const   */* __restrict  */)tmp___11);
          }
#line 11764
          goto switch_break;
          case_2: /* CIL Label */ 
          {
#line 11766
          tmp___12 = gettext("Section Attributes:");
#line 11766
          printf((char const   */* __restrict  */)tmp___12);
          }
#line 11767
          goto do_numlist;
          case_3: /* CIL Label */ 
          {
#line 11769
          tmp___13 = gettext("Symbol Attributes:");
#line 11769
          printf((char const   */* __restrict  */)tmp___13);
          }
          do_numlist: 
          {
#line 11771
          while (1) {
            while_continue___2: /* CIL Label */ ;
            {
#line 11775
            tmp___14 = read_uleb128(p, & j);
#line 11775
            val = (int )tmp___14;
#line 11776
            p += j;
            }
#line 11777
            if (val == 0) {
#line 11778
              goto while_break___2;
            }
            {
#line 11779
            printf((char const   */* __restrict  */)" %d", val);
            }
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 11781
          printf((char const   */* __restrict  */)"\n");
          }
#line 11782
          goto switch_break;
          switch_default: /* CIL Label */ 
          {
#line 11784
          tmp___15 = gettext("Unknown tag: %d\n");
#line 11784
          printf((char const   */* __restrict  */)tmp___15, tag);
#line 11785
          public_section = 0;
          }
#line 11786
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 11789
          if (public_section) {
            {
#line 11791
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 11791
              if (! ((unsigned long )p < (unsigned long )end)) {
#line 11791
                goto while_break___3;
              }
              {
#line 11792
              p = (*display_pub_attribute)(p);
              }
            }
            while_break___3: /* CIL Label */ ;
            }
          } else
#line 11794
          if (gnu_section) {
            {
#line 11796
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 11796
              if (! ((unsigned long )p < (unsigned long )end)) {
#line 11796
                goto while_break___4;
              }
              {
#line 11797
              p = display_gnu_attribute(p, display_proc_gnu_attribute);
              }
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
            {
#line 11803
            tmp___16 = gettext("  Unknown section contexts\n");
#line 11803
            printf((char const   */* __restrict  */)tmp___16);
#line 11804
            p = end;
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 11810
      tmp___17 = gettext("Unknown format \'%c\'\n");
#line 11810
      printf((char const   */* __restrict  */)tmp___17, (int )*p);
      }
    }
    {
#line 11812
    free((void *)contents);
    }
    __Cont: /* CIL Label */ 
#line 11691
    i ++;
#line 11691
    sect ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11814
  return (1);
}
}
#line 11817 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_arm_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 11820
  tmp___0 = process_attributes(file, "aeabi", 1879048195U, & display_arm_attribute,
                               (unsigned char *(*)(unsigned char * , int  ))((void *)0));
  }
#line 11820
  return (tmp___0);
}
}
#line 11824 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_power_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 11827
  tmp___0 = process_attributes(file, (char const   *)((void *)0), 1879048181U, (unsigned char *(*)(unsigned char * ))((void *)0),
                               & display_power_gnu_attribute);
  }
#line 11827
  return (tmp___0);
}
}
#line 11831 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_sparc_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 11834
  tmp___0 = process_attributes(file, (char const   *)((void *)0), 1879048181U, (unsigned char *(*)(unsigned char * ))((void *)0),
                               & display_sparc_gnu_attribute);
  }
#line 11834
  return (tmp___0);
}
}
#line 11838 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_tic6x_specific(FILE *file ) 
{ 
  int tmp___0 ;

  {
  {
#line 11841
  tmp___0 = process_attributes(file, "c6xabi", 1879048195U, & display_tic6x_attribute,
                               (unsigned char *(*)(unsigned char * , int  ))((void *)0));
  }
#line 11841
  return (tmp___0);
}
}
#line 11849 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma print_mips_got_entry(unsigned char *data , bfd_vma pltgot , bfd_vma addr ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;
  bfd_vma entry ;
  int tmp___2 ;
  elf_vma tmp___3 ;
  int tmp___4 ;

  {
  {
#line 11852
  printf((char const   */* __restrict  */)"  ");
#line 11853
  print_vma(addr, (print_mode )6);
#line 11854
  printf((char const   */* __restrict  */)" ");
  }
#line 11855
  if (addr < pltgot + 65520UL) {
    {
#line 11856
    printf((char const   */* __restrict  */)"%6d(gp)", (int )((addr - pltgot) - 32752UL));
    }
  } else {
    {
#line 11858
    printf((char const   */* __restrict  */)"%10s", "");
    }
  }
  {
#line 11859
  printf((char const   */* __restrict  */)" ");
  }
#line 11860
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 11861
    tmp___0 = gettext("<unknown>");
    }
#line 11861
    if (is_32bit_elf) {
#line 11861
      tmp___1 = 8;
    } else {
#line 11861
      tmp___1 = 16;
    }
    {
#line 11861
    printf((char const   */* __restrict  */)"%*s", tmp___1, tmp___0);
    }
  } else {
#line 11866
    if (is_32bit_elf) {
#line 11866
      tmp___2 = 4;
    } else {
#line 11866
      tmp___2 = 8;
    }
    {
#line 11866
    tmp___3 = (*byte_get)((data + addr) - pltgot, tmp___2);
#line 11866
    entry = (bfd_vma )tmp___3;
#line 11867
    print_vma(entry, (print_mode )6);
    }
  }
#line 11869
  if (is_32bit_elf) {
#line 11869
    tmp___4 = 4;
  } else {
#line 11869
    tmp___4 = 8;
  }
#line 11869
  return (addr + (bfd_vma )tmp___4);
}
}
#line 11876 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static bfd_vma print_mips_pltgot_entry(unsigned char *data , bfd_vma pltgot , bfd_vma addr ) 
{ 
  char *tmp___0 ;
  int tmp___1 ;
  bfd_vma entry ;
  int tmp___2 ;
  elf_vma tmp___3 ;
  int tmp___4 ;

  {
  {
#line 11879
  printf((char const   */* __restrict  */)"  ");
#line 11880
  print_vma(addr, (print_mode )6);
#line 11881
  printf((char const   */* __restrict  */)" ");
  }
#line 11882
  if ((unsigned long )data == (unsigned long )((void *)0)) {
    {
#line 11883
    tmp___0 = gettext("<unknown>");
    }
#line 11883
    if (is_32bit_elf) {
#line 11883
      tmp___1 = 8;
    } else {
#line 11883
      tmp___1 = 16;
    }
    {
#line 11883
    printf((char const   */* __restrict  */)"%*s", tmp___1, tmp___0);
    }
  } else {
#line 11888
    if (is_32bit_elf) {
#line 11888
      tmp___2 = 4;
    } else {
#line 11888
      tmp___2 = 8;
    }
    {
#line 11888
    tmp___3 = (*byte_get)((data + addr) - pltgot, tmp___2);
#line 11888
    entry = (bfd_vma )tmp___3;
#line 11889
    print_vma(entry, (print_mode )6);
    }
  }
#line 11891
  if (is_32bit_elf) {
#line 11891
    tmp___4 = 4;
  } else {
#line 11891
    tmp___4 = 8;
  }
#line 11891
  return (addr + (bfd_vma )tmp___4);
}
}
#line 12017
static int process_mips_specific(FILE *file ) ;
#line 12017 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static struct __anonstruct_l_flags_vals_1006031693  const  l_flags_vals[6]  = {      {" EXACT_MATCH", 1}, 
        {" IGNORE_INT_VER", 2}, 
        {" REQUIRE_MINOR", 4}, 
        {" EXPORTS", 8}, 
        {" DELAY_LOAD", 16}, 
        {" DELTA", 32}};
#line 11894 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_mips_specific(FILE *file ) 
{ 
  Elf_Internal_Dyn *entry ;
  size_t liblist_offset ;
  size_t liblistno ;
  size_t conflictsno ;
  size_t options_offset ;
  size_t conflicts_offset ;
  size_t pltrelsz ;
  size_t pltrel ;
  bfd_vma pltgot ;
  bfd_vma mips_pltgot ;
  bfd_vma jmprel ;
  bfd_vma local_gotno ;
  bfd_vma gotsym ;
  bfd_vma symtabno ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Elf32_External_Lib *elib ;
  size_t cnt ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  Elf32_Lib liblist ;
  time_t atime ;
  char timebuf[20] ;
  struct tm *tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int flags___1 ;
  size_t fcnt ;
  Elf_External_Options *eopt ;
  Elf_Internal_Shdr *sect ;
  Elf_Internal_Options *iopt ;
  Elf_Internal_Options *option ;
  size_t offset ;
  int cnt___0 ;
  char *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  Elf_External_Options *eoption ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  size_t len ;
  Elf32_External_RegInfo *ereg ;
  Elf32_RegInfo reginfo ;
  elf_vma tmp___30 ;
  elf_vma tmp___31 ;
  elf_vma tmp___32 ;
  elf_vma tmp___33 ;
  elf_vma tmp___34 ;
  elf_vma tmp___35 ;
  Elf64_External_RegInfo *ereg___0 ;
  Elf64_Internal_RegInfo reginfo___0 ;
  elf_vma tmp___36 ;
  elf_vma tmp___37 ;
  elf_vma tmp___38 ;
  elf_vma tmp___39 ;
  elf_vma tmp___40 ;
  elf_vma tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  int tmp___44 ;
  Elf32_Conflict *iconf ;
  size_t cnt___1 ;
  char *tmp___45 ;
  void *tmp___46 ;
  char *tmp___47 ;
  Elf32_External_Conflict *econf32 ;
  char *tmp___48 ;
  void *tmp___49 ;
  elf_vma tmp___50 ;
  Elf64_External_Conflict *econf64 ;
  char *tmp___51 ;
  void *tmp___52 ;
  elf_vma tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  Elf_Internal_Sym *psym ;
  char *tmp___56 ;
  bfd_vma ent ;
  bfd_vma local_end ;
  bfd_vma global_end ;
  size_t i ;
  size_t offset___0 ;
  unsigned char *data ;
  int addr_size ;
  long tmp___57 ;
  char *tmp___58 ;
  void *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  elf_vma tmp___69 ;
  char *tmp___70 ;
  char *tmp___71 ;
  char *tmp___72 ;
  char *tmp___73 ;
  int sym_width ;
  char *tmp___74 ;
  char *tmp___75 ;
  char *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  int tmp___82 ;
  Elf_Internal_Sym *psym___0 ;
  char const   *tmp___83 ;
  char const   *tmp___84 ;
  char *tmp___85 ;
  bfd_vma ent___0 ;
  bfd_vma end ;
  size_t offset___1 ;
  size_t rel_offset ;
  unsigned long count ;
  unsigned long i___0 ;
  unsigned char *data___0 ;
  int addr_size___0 ;
  int sym_width___0 ;
  Elf_Internal_Rela *rels ;
  long tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  long tmp___89 ;
  char *tmp___90 ;
  void *tmp___91 ;
  char *tmp___92 ;
  char *tmp___93 ;
  char *tmp___94 ;
  char *tmp___95 ;
  char *tmp___96 ;
  char *tmp___97 ;
  char *tmp___98 ;
  char *tmp___99 ;
  char *tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  int tmp___105 ;
  Elf_Internal_Sym *psym___1 ;
  bfd_vma tmp___106 ;
  char const   *tmp___107 ;
  char const   *tmp___108 ;
  char *tmp___109 ;

  {
  {
#line 11898
  liblist_offset = (size_t )0;
#line 11899
  liblistno = (size_t )0;
#line 11900
  conflictsno = (size_t )0;
#line 11901
  options_offset = (size_t )0;
#line 11902
  conflicts_offset = (size_t )0;
#line 11903
  pltrelsz = (size_t )0;
#line 11904
  pltrel = (size_t )0;
#line 11905
  pltgot = (bfd_vma )0;
#line 11906
  mips_pltgot = (bfd_vma )0;
#line 11907
  jmprel = (bfd_vma )0;
#line 11908
  local_gotno = (bfd_vma )0;
#line 11909
  gotsym = (bfd_vma )0;
#line 11910
  symtabno = (bfd_vma )0;
#line 11912
  process_attributes(file, (char const   *)((void *)0), 1879048181U, (unsigned char *(*)(unsigned char * ))((void *)0),
                     & display_mips_gnu_attribute);
  }
#line 11916
  if ((unsigned long )dynamic_section == (unsigned long )((void *)0)) {
#line 11918
    return (0);
  }
#line 11920
  entry = dynamic_section;
  {
#line 11920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 11920
    if (! (entry->d_tag != 0UL)) {
#line 11920
      goto while_break;
    }
    {
#line 11923
    if (entry->d_tag == 1879048201UL) {
#line 11923
      goto case_1879048201;
    }
#line 11928
    if (entry->d_tag == 1879048208UL) {
#line 11928
      goto case_1879048208;
    }
#line 11931
    if (entry->d_tag == 1879048233UL) {
#line 11931
      goto case_1879048233;
    }
#line 11934
    if (entry->d_tag == 1879048200UL) {
#line 11934
      goto case_1879048200;
    }
#line 11939
    if (entry->d_tag == 1879048203UL) {
#line 11939
      goto case_1879048203;
    }
#line 11942
    if (entry->d_tag == 3UL) {
#line 11942
      goto case_3;
    }
#line 11945
    if (entry->d_tag == 1879048202UL) {
#line 11945
      goto case_1879048202;
    }
#line 11948
    if (entry->d_tag == 1879048211UL) {
#line 11948
      goto case_1879048211;
    }
#line 11951
    if (entry->d_tag == 1879048209UL) {
#line 11951
      goto case_1879048209;
    }
#line 11954
    if (entry->d_tag == 1879048242UL) {
#line 11954
      goto case_1879048242;
    }
#line 11957
    if (entry->d_tag == 20UL) {
#line 11957
      goto case_20;
    }
#line 11960
    if (entry->d_tag == 2UL) {
#line 11960
      goto case_2;
    }
#line 11963
    if (entry->d_tag == 23UL) {
#line 11963
      goto case_23;
    }
#line 11966
    goto switch_default;
    case_1879048201: /* CIL Label */ 
    {
#line 11924
    tmp___0 = offset_from_vma(file, entry->d_un.d_val, liblistno * sizeof(Elf32_External_Lib ));
#line 11924
    liblist_offset = (size_t )tmp___0;
    }
#line 11927
    goto switch_break;
    case_1879048208: /* CIL Label */ 
#line 11929
    liblistno = entry->d_un.d_val;
#line 11930
    goto switch_break;
    case_1879048233: /* CIL Label */ 
    {
#line 11932
    tmp___1 = offset_from_vma(file, entry->d_un.d_val, (bfd_size_type )0);
#line 11932
    options_offset = (size_t )tmp___1;
    }
#line 11933
    goto switch_break;
    case_1879048200: /* CIL Label */ 
    {
#line 11935
    tmp___2 = offset_from_vma(file, entry->d_un.d_val, conflictsno * sizeof(Elf32_External_Conflict ));
#line 11935
    conflicts_offset = (size_t )tmp___2;
    }
#line 11938
    goto switch_break;
    case_1879048203: /* CIL Label */ 
#line 11940
    conflictsno = entry->d_un.d_val;
#line 11941
    goto switch_break;
    case_3: /* CIL Label */ 
#line 11943
    pltgot = entry->d_un.d_ptr;
#line 11944
    goto switch_break;
    case_1879048202: /* CIL Label */ 
#line 11946
    local_gotno = entry->d_un.d_val;
#line 11947
    goto switch_break;
    case_1879048211: /* CIL Label */ 
#line 11949
    gotsym = entry->d_un.d_val;
#line 11950
    goto switch_break;
    case_1879048209: /* CIL Label */ 
#line 11952
    symtabno = entry->d_un.d_val;
#line 11953
    goto switch_break;
    case_1879048242: /* CIL Label */ 
#line 11955
    mips_pltgot = entry->d_un.d_ptr;
#line 11956
    goto switch_break;
    case_20: /* CIL Label */ 
#line 11958
    pltrel = entry->d_un.d_val;
#line 11959
    goto switch_break;
    case_2: /* CIL Label */ 
#line 11961
    pltrelsz = entry->d_un.d_val;
#line 11962
    goto switch_break;
    case_23: /* CIL Label */ 
#line 11964
    jmprel = entry->d_un.d_ptr;
#line 11965
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 11967
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 11920
    entry ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 11970
  if (liblist_offset != 0UL) {
#line 11970
    if (liblistno != 0UL) {
#line 11970
      if (do_dynamic) {
        {
#line 11975
        tmp___3 = gettext("liblist section data");
#line 11975
        tmp___4 = get_data((void *)0, file, (long )liblist_offset, liblistno, sizeof(Elf32_External_Lib ),
                           (char const   *)tmp___3);
#line 11975
        elib = (Elf32_External_Lib *)tmp___4;
        }
#line 11979
        if (elib) {
          {
#line 11981
          tmp___5 = gettext("\nSection \'.liblist\' contains %lu entries:\n");
#line 11981
          printf((char const   */* __restrict  */)tmp___5, liblistno);
#line 11983
          tmp___6 = gettext("     Library              Time Stamp          Checksum   Version Flags\n");
#line 11983
          fputs((char const   */* __restrict  */)tmp___6, (FILE */* __restrict  */)stdout);
#line 11986
          cnt = (size_t )0;
          }
          {
#line 11986
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 11986
            if (! (cnt < liblistno)) {
#line 11986
              goto while_break___0;
            }
            {
#line 11993
            tmp___8 = (*byte_get)((elib + cnt)->l_name, (int )sizeof((elib + cnt)->l_name));
#line 11993
            liblist.l_name = (unsigned long )tmp___8;
#line 11994
            tmp___9 = (*byte_get)((elib + cnt)->l_time_stamp, (int )sizeof((elib + cnt)->l_time_stamp));
#line 11994
            atime = (time_t )tmp___9;
#line 11995
            tmp___10 = (*byte_get)((elib + cnt)->l_checksum, (int )sizeof((elib + cnt)->l_checksum));
#line 11995
            liblist.l_checksum = (unsigned long )tmp___10;
#line 11996
            tmp___11 = (*byte_get)((elib + cnt)->l_version, (int )sizeof((elib + cnt)->l_version));
#line 11996
            liblist.l_version = (unsigned long )tmp___11;
#line 11997
            tmp___12 = (*byte_get)((elib + cnt)->l_flags, (int )sizeof((elib + cnt)->l_flags));
#line 11997
            liblist.l_flags = (unsigned long )tmp___12;
#line 11999
            tmp___7 = gmtime((time_t const   *)(& atime));
#line 12000
            snprintf((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u",
                     tmp___7->tm_year + 1900, tmp___7->tm_mon + 1, tmp___7->tm_mday,
                     tmp___7->tm_hour, tmp___7->tm_min, tmp___7->tm_sec);
#line 12005
            printf((char const   */* __restrict  */)"%3lu: ", cnt);
            }
#line 12006
            if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12006
              if (liblist.l_name < dynamic_strings_length) {
                {
#line 12007
                print_symbol(20, (char const   *)(dynamic_strings + liblist.l_name));
                }
              } else {
                {
#line 12009
                tmp___13 = gettext("<corrupt: %9ld>");
#line 12009
                printf((char const   */* __restrict  */)tmp___13, liblist.l_name);
                }
              }
            } else {
              {
#line 12009
              tmp___13 = gettext("<corrupt: %9ld>");
#line 12009
              printf((char const   */* __restrict  */)tmp___13, liblist.l_name);
              }
            }
            {
#line 12010
            printf((char const   */* __restrict  */)" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
                   liblist.l_version);
            }
#line 12013
            if (liblist.l_flags == 0UL) {
              {
#line 12014
              tmp___14 = gettext(" NONE");
#line 12014
              puts((char const   *)tmp___14);
              }
            } else {
#line 12031
              flags___1 = (int )liblist.l_flags;
#line 12034
              fcnt = (size_t )0;
              {
#line 12034
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 12034
                if (! (fcnt < sizeof(l_flags_vals) / sizeof(l_flags_vals[0]))) {
#line 12034
                  goto while_break___1;
                }
#line 12035
                if ((flags___1 & (int )l_flags_vals[fcnt].bit) != 0) {
                  {
#line 12037
                  fputs((char const   */* __restrict  */)l_flags_vals[fcnt].name,
                        (FILE */* __restrict  */)stdout);
#line 12038
                  flags___1 ^= (int )l_flags_vals[fcnt].bit;
                  }
                }
#line 12034
                fcnt ++;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 12040
              if (flags___1 != 0) {
                {
#line 12041
                printf((char const   */* __restrict  */)" %#x", (unsigned int )flags___1);
                }
              }
              {
#line 12043
              puts("");
              }
            }
#line 11986
            cnt ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 12047
          free((void *)elib);
          }
        }
      }
    }
  }
#line 12051
  if (options_offset != 0UL) {
#line 12054
    sect = section_headers;
    {
#line 12061
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 12061
      if (! (sect->sh_type != 1879048205U)) {
#line 12061
        goto while_break___2;
      }
#line 12062
      sect ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 12064
    tmp___15 = gettext("options");
#line 12064
    tmp___16 = get_data((void *)0, file, (long )options_offset, (size_t )1, sect->sh_size,
                        (char const   *)tmp___15);
#line 12064
    eopt = (Elf_External_Options *)tmp___16;
    }
#line 12066
    if (eopt) {
      {
#line 12068
      tmp___17 = cmalloc(sect->sh_size / sizeof(eopt), sizeof(*iopt));
#line 12068
      iopt = (Elf_Internal_Options *)tmp___17;
      }
#line 12070
      if ((unsigned long )iopt == (unsigned long )((void *)0)) {
        {
#line 12072
        tmp___18 = gettext("Out of memory\n");
#line 12072
        error((char const   *)tmp___18);
        }
#line 12073
        return (0);
      }
#line 12076
      cnt___0 = 0;
#line 12076
      offset = (size_t )cnt___0;
#line 12077
      option = iopt;
      {
#line 12079
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 12079
        if (! (offset < sect->sh_size)) {
#line 12079
          goto while_break___3;
        }
        {
#line 12083
        eoption = (Elf_External_Options *)((char *)eopt + offset);
#line 12085
        tmp___19 = (*byte_get)(eoption->kind, (int )sizeof(eoption->kind));
#line 12085
        option->kind = (unsigned char )tmp___19;
#line 12086
        tmp___20 = (*byte_get)(eoption->size, (int )sizeof(eoption->size));
#line 12086
        option->size = (unsigned char )tmp___20;
#line 12087
        tmp___21 = (*byte_get)(eoption->section, (int )sizeof(eoption->section));
#line 12087
        option->section = (unsigned short )tmp___21;
#line 12088
        tmp___22 = (*byte_get)(eoption->info, (int )sizeof(eoption->info));
#line 12088
        option->info = (unsigned long )tmp___22;
#line 12090
        offset += (size_t )option->size;
#line 12092
        option ++;
#line 12093
        cnt___0 ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 12096
      if ((unsigned long )sect == (unsigned long )((void *)0)) {
        {
#line 12096
        tmp___23 = gettext("<none>");
#line 12096
        tmp___28 = tmp___23;
        }
      } else {
#line 12096
        if ((unsigned long )string_table == (unsigned long )((void *)0)) {
          {
#line 12096
          tmp___24 = gettext("<no-name>");
#line 12096
          tmp___27 = tmp___24;
          }
        } else {
#line 12096
          if ((unsigned long )sect->sh_name >= string_table_length) {
            {
#line 12096
            tmp___25 = gettext("<corrupt>");
#line 12096
            tmp___26 = tmp___25;
            }
          } else {
#line 12096
            tmp___26 = string_table + sect->sh_name;
          }
#line 12096
          tmp___27 = tmp___26;
        }
#line 12096
        tmp___28 = tmp___27;
      }
      {
#line 12096
      tmp___29 = gettext("\nSection \'%s\' contains %d entries:\n");
#line 12096
      printf((char const   */* __restrict  */)tmp___29, tmp___28, cnt___0);
#line 12099
      option = iopt;
      }
      {
#line 12101
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 12101
        tmp___44 = cnt___0;
#line 12101
        cnt___0 --;
#line 12101
        if (! (tmp___44 > 0)) {
#line 12101
          goto while_break___4;
        }
        {
#line 12107
        if ((int )option->kind == 0) {
#line 12107
          goto case_0;
        }
#line 12111
        if ((int )option->kind == 1) {
#line 12111
          goto case_1;
        }
#line 12159
        if ((int )option->kind == 2) {
#line 12159
          goto case_2___0;
        }
#line 12175
        if ((int )option->kind == 3) {
#line 12175
          goto case_3___0;
        }
#line 12184
        if ((int )option->kind == 4) {
#line 12184
          goto case_4;
        }
#line 12195
        if ((int )option->kind == 5) {
#line 12195
          goto case_5;
        }
#line 12199
        if ((int )option->kind == 6) {
#line 12199
          goto case_6;
        }
#line 12203
        if ((int )option->kind == 7) {
#line 12203
          goto case_7;
        }
#line 12210
        if ((int )option->kind == 8) {
#line 12210
          goto case_8;
        }
#line 12217
        if ((int )option->kind == 9) {
#line 12217
          goto case_9;
        }
#line 12222
        if ((int )option->kind == 10) {
#line 12222
          goto case_10;
        }
#line 12227
        goto switch_default___0;
        case_0: /* CIL Label */ 
        {
#line 12109
        printf((char const   */* __restrict  */)" NULL       %d %lx", (int )option->section,
               option->info);
        }
#line 12110
        goto switch_break___0;
        case_1: /* CIL Label */ 
        {
#line 12112
        printf((char const   */* __restrict  */)" REGINFO    ");
        }
#line 12113
        if ((int )elf_header.e_machine == 8) {
          {
#line 12119
          ereg = (Elf32_External_RegInfo *)(option + 1);
#line 12120
          tmp___30 = (*byte_get)(ereg->ri_gprmask, (int )sizeof(ereg->ri_gprmask));
#line 12120
          reginfo.ri_gprmask = (unsigned long )tmp___30;
#line 12121
          tmp___31 = (*byte_get)(ereg->ri_cprmask[0], (int )sizeof(ereg->ri_cprmask[0]));
#line 12121
          reginfo.ri_cprmask[0] = (unsigned long )tmp___31;
#line 12122
          tmp___32 = (*byte_get)(ereg->ri_cprmask[1], (int )sizeof(ereg->ri_cprmask[1]));
#line 12122
          reginfo.ri_cprmask[1] = (unsigned long )tmp___32;
#line 12123
          tmp___33 = (*byte_get)(ereg->ri_cprmask[2], (int )sizeof(ereg->ri_cprmask[2]));
#line 12123
          reginfo.ri_cprmask[2] = (unsigned long )tmp___33;
#line 12124
          tmp___34 = (*byte_get)(ereg->ri_cprmask[3], (int )sizeof(ereg->ri_cprmask[3]));
#line 12124
          reginfo.ri_cprmask[3] = (unsigned long )tmp___34;
#line 12125
          tmp___35 = (*byte_get)(ereg->ri_gp_value, (int )sizeof(ereg->ri_gp_value));
#line 12125
          reginfo.ri_gp_value = (long )tmp___35;
#line 12127
          printf((char const   */* __restrict  */)"GPR %08lx  GP 0x%lx\n", reginfo.ri_gprmask,
                 (unsigned long )reginfo.ri_gp_value);
#line 12130
          printf((char const   */* __restrict  */)"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
                 reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2],
                 reginfo.ri_cprmask[3]);
          }
        } else {
          {
#line 12140
          ereg___0 = (Elf64_External_RegInfo *)(option + 1);
#line 12141
          tmp___36 = (*byte_get)(ereg___0->ri_gprmask, (int )sizeof(ereg___0->ri_gprmask));
#line 12141
          reginfo___0.ri_gprmask = (unsigned long )tmp___36;
#line 12142
          tmp___37 = (*byte_get)(ereg___0->ri_cprmask[0], (int )sizeof(ereg___0->ri_cprmask[0]));
#line 12142
          reginfo___0.ri_cprmask[0] = (unsigned long )tmp___37;
#line 12143
          tmp___38 = (*byte_get)(ereg___0->ri_cprmask[1], (int )sizeof(ereg___0->ri_cprmask[1]));
#line 12143
          reginfo___0.ri_cprmask[1] = (unsigned long )tmp___38;
#line 12144
          tmp___39 = (*byte_get)(ereg___0->ri_cprmask[2], (int )sizeof(ereg___0->ri_cprmask[2]));
#line 12144
          reginfo___0.ri_cprmask[2] = (unsigned long )tmp___39;
#line 12145
          tmp___40 = (*byte_get)(ereg___0->ri_cprmask[3], (int )sizeof(ereg___0->ri_cprmask[3]));
#line 12145
          reginfo___0.ri_cprmask[3] = (unsigned long )tmp___40;
#line 12146
          tmp___41 = (*byte_get)(ereg___0->ri_gp_value, (int )sizeof(ereg___0->ri_gp_value));
#line 12146
          reginfo___0.ri_gp_value = (bfd_vma )tmp___41;
#line 12148
          printf((char const   */* __restrict  */)"GPR %08lx  GP 0x", reginfo___0.ri_gprmask);
#line 12150
          fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%016lx",
                  reginfo___0.ri_gp_value);
#line 12151
          printf((char const   */* __restrict  */)"\n");
#line 12153
          printf((char const   */* __restrict  */)"            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
                 reginfo___0.ri_cprmask[0], reginfo___0.ri_cprmask[1], reginfo___0.ri_cprmask[2],
                 reginfo___0.ri_cprmask[3]);
          }
        }
#line 12157
        option ++;
#line 12158
        goto while_continue___4;
        case_2___0: /* CIL Label */ 
        {
#line 12160
        fputs((char const   */* __restrict  */)" EXCEPTIONS fpe_min(", (FILE */* __restrict  */)stdout);
#line 12161
        process_mips_fpe_exception((int )(option->info & 31UL));
#line 12162
        fputs((char const   */* __restrict  */)") fpe_max(", (FILE */* __restrict  */)stdout);
#line 12163
        process_mips_fpe_exception((int )((option->info & 7936UL) >> 8));
#line 12164
        fputs((char const   */* __restrict  */)")", (FILE */* __restrict  */)stdout);
        }
#line 12166
        if (option->info & 65536UL) {
          {
#line 12167
          fputs((char const   */* __restrict  */)" PAGE0", (FILE */* __restrict  */)stdout);
          }
        }
#line 12168
        if (option->info & 131072UL) {
          {
#line 12169
          fputs((char const   */* __restrict  */)" SMM", (FILE */* __restrict  */)stdout);
          }
        }
#line 12170
        if (option->info & 262144UL) {
          {
#line 12171
          fputs((char const   */* __restrict  */)" FPDBUG", (FILE */* __restrict  */)stdout);
          }
        }
#line 12172
        if (option->info & 524288UL) {
          {
#line 12173
          fputs((char const   */* __restrict  */)" DISMISS", (FILE */* __restrict  */)stdout);
          }
        }
#line 12174
        goto switch_break___0;
        case_3___0: /* CIL Label */ 
        {
#line 12176
        fputs((char const   */* __restrict  */)" PAD       ", (FILE */* __restrict  */)stdout);
        }
#line 12177
        if (option->info & 1UL) {
          {
#line 12178
          fputs((char const   */* __restrict  */)" PREFIX", (FILE */* __restrict  */)stdout);
          }
        }
#line 12179
        if (option->info & 2UL) {
          {
#line 12180
          fputs((char const   */* __restrict  */)" POSTFIX", (FILE */* __restrict  */)stdout);
          }
        }
#line 12181
        if (option->info & 4UL) {
          {
#line 12182
          fputs((char const   */* __restrict  */)" SYMBOL", (FILE */* __restrict  */)stdout);
          }
        }
#line 12183
        goto switch_break___0;
        case_4: /* CIL Label */ 
        {
#line 12185
        fputs((char const   */* __restrict  */)" HWPATCH   ", (FILE */* __restrict  */)stdout);
        }
#line 12186
        if (option->info & 1UL) {
          {
#line 12187
          fputs((char const   */* __restrict  */)" R4KEOP", (FILE */* __restrict  */)stdout);
          }
        }
#line 12188
        if (option->info & 2UL) {
          {
#line 12189
          fputs((char const   */* __restrict  */)" R8KPFETCH", (FILE */* __restrict  */)stdout);
          }
        }
#line 12190
        if (option->info & 4UL) {
          {
#line 12191
          fputs((char const   */* __restrict  */)" R5KEOP", (FILE */* __restrict  */)stdout);
          }
        }
#line 12192
        if (option->info & 8UL) {
          {
#line 12193
          fputs((char const   */* __restrict  */)" R5KCVTL", (FILE */* __restrict  */)stdout);
          }
        }
#line 12194
        goto switch_break___0;
        case_5: /* CIL Label */ 
        {
#line 12196
        fputs((char const   */* __restrict  */)" FILL       ", (FILE */* __restrict  */)stdout);
        }
#line 12198
        goto switch_break___0;
        case_6: /* CIL Label */ 
        {
#line 12200
        fputs((char const   */* __restrict  */)" TAGS       ", (FILE */* __restrict  */)stdout);
        }
#line 12202
        goto switch_break___0;
        case_7: /* CIL Label */ 
        {
#line 12204
        fputs((char const   */* __restrict  */)" HWAND     ", (FILE */* __restrict  */)stdout);
        }
#line 12205
        if (option->info & 1UL) {
          {
#line 12206
          fputs((char const   */* __restrict  */)" R4KEOP_CHECKED", (FILE */* __restrict  */)stdout);
          }
        }
#line 12207
        if (option->info & 2UL) {
          {
#line 12208
          fputs((char const   */* __restrict  */)" R4KEOP_CLEAN", (FILE */* __restrict  */)stdout);
          }
        }
#line 12209
        goto switch_break___0;
        case_8: /* CIL Label */ 
        {
#line 12211
        fputs((char const   */* __restrict  */)" HWOR      ", (FILE */* __restrict  */)stdout);
        }
#line 12212
        if (option->info & 1UL) {
          {
#line 12213
          fputs((char const   */* __restrict  */)" R4KEOP_CHECKED", (FILE */* __restrict  */)stdout);
          }
        }
#line 12214
        if (option->info & 2UL) {
          {
#line 12215
          fputs((char const   */* __restrict  */)" R4KEOP_CLEAN", (FILE */* __restrict  */)stdout);
          }
        }
#line 12216
        goto switch_break___0;
        case_9: /* CIL Label */ 
        {
#line 12218
        printf((char const   */* __restrict  */)" GP_GROUP  %#06lx  self-contained %#06lx",
               option->info & 65535UL, (option->info & 4294901760UL) >> 16);
        }
#line 12221
        goto switch_break___0;
        case_10: /* CIL Label */ 
        {
#line 12223
        printf((char const   */* __restrict  */)" IDENT     %#06lx  self-contained %#06lx",
               option->info & 65535UL, (option->info & 4294901760UL) >> 16);
        }
#line 12226
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
        {
#line 12229
        printf((char const   */* __restrict  */)" %3d ???     %d %lx", (int )option->kind,
               (int )option->section, option->info);
        }
#line 12231
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 12234
        len = sizeof(*eopt);
        {
#line 12235
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 12235
          if (! (len < (size_t )option->size)) {
#line 12235
            goto while_break___5;
          }
#line 12236
          if ((int )*((char *)option + len) >= 32) {
#line 12236
            if ((int )*((char *)option + len) < 127) {
              {
#line 12238
              tmp___42 = len;
#line 12238
              len ++;
#line 12238
              printf((char const   */* __restrict  */)"%c", (int )*((char *)option + tmp___42));
              }
            } else {
              {
#line 12240
              tmp___43 = len;
#line 12240
              len ++;
#line 12240
              printf((char const   */* __restrict  */)"\\%03o", (int )*((char *)option + tmp___43));
              }
            }
          } else {
            {
#line 12240
            tmp___43 = len;
#line 12240
            len ++;
#line 12240
            printf((char const   */* __restrict  */)"\\%03o", (int )*((char *)option + tmp___43));
            }
          }
        }
        while_break___5: /* CIL Label */ ;
        }
        {
#line 12242
        fputs((char const   */* __restrict  */)"\n", (FILE */* __restrict  */)stdout);
#line 12243
        option ++;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 12246
      free((void *)eopt);
      }
    }
  }
#line 12250
  if (conflicts_offset != 0UL) {
#line 12250
    if (conflictsno != 0UL) {
#line 12255
      if ((unsigned long )dynamic_symbols == (unsigned long )((void *)0)) {
        {
#line 12257
        tmp___45 = gettext("conflict list found without a dynamic symbol table\n");
#line 12257
        error((char const   *)tmp___45);
        }
#line 12258
        return (0);
      }
      {
#line 12261
      tmp___46 = cmalloc(conflictsno, sizeof(*iconf));
#line 12261
      iconf = (Elf32_Conflict *)tmp___46;
      }
#line 12262
      if ((unsigned long )iconf == (unsigned long )((void *)0)) {
        {
#line 12264
        tmp___47 = gettext("Out of memory\n");
#line 12264
        error((char const   *)tmp___47);
        }
#line 12265
        return (0);
      }
#line 12268
      if (is_32bit_elf) {
        {
#line 12272
        tmp___48 = gettext("conflict");
#line 12272
        tmp___49 = get_data((void *)0, file, (long )conflicts_offset, conflictsno,
                            sizeof(*econf32), (char const   *)tmp___48);
#line 12272
        econf32 = (Elf32_External_Conflict *)tmp___49;
        }
#line 12275
        if (! econf32) {
#line 12276
          return (0);
        }
#line 12278
        cnt___1 = (size_t )0;
        {
#line 12278
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 12278
          if (! (cnt___1 < conflictsno)) {
#line 12278
            goto while_break___6;
          }
          {
#line 12279
          tmp___50 = (*byte_get)(*(econf32 + cnt___1), (int )sizeof(*(econf32 + cnt___1)));
#line 12279
          *(iconf + cnt___1) = (Elf32_Conflict )tmp___50;
#line 12278
          cnt___1 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 12281
        free((void *)econf32);
        }
      } else {
        {
#line 12287
        tmp___51 = gettext("conflict");
#line 12287
        tmp___52 = get_data((void *)0, file, (long )conflicts_offset, conflictsno,
                            sizeof(*econf64), (char const   *)tmp___51);
#line 12287
        econf64 = (Elf64_External_Conflict *)tmp___52;
        }
#line 12290
        if (! econf64) {
#line 12291
          return (0);
        }
#line 12293
        cnt___1 = (size_t )0;
        {
#line 12293
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 12293
          if (! (cnt___1 < conflictsno)) {
#line 12293
            goto while_break___7;
          }
          {
#line 12294
          tmp___53 = (*byte_get)(*(econf64 + cnt___1), (int )sizeof(*(econf64 + cnt___1)));
#line 12294
          *(iconf + cnt___1) = (Elf32_Conflict )tmp___53;
#line 12293
          cnt___1 ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        {
#line 12296
        free((void *)econf64);
        }
      }
      {
#line 12299
      tmp___54 = gettext("\nSection \'.conflict\' contains %lu entries:\n");
#line 12299
      printf((char const   */* __restrict  */)tmp___54, conflictsno);
#line 12301
      tmp___55 = gettext("  Num:    Index       Value  Name");
#line 12301
      puts((char const   *)tmp___55);
#line 12303
      cnt___1 = (size_t )0;
      }
      {
#line 12303
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 12303
        if (! (cnt___1 < conflictsno)) {
#line 12303
          goto while_break___8;
        }
        {
#line 12305
        psym = dynamic_symbols + *(iconf + cnt___1);
#line 12307
        printf((char const   */* __restrict  */)"%5lu: %8lu  ", cnt___1, *(iconf + cnt___1));
#line 12308
        print_vma(psym->st_value, (print_mode )5);
#line 12309
        putchar(' ');
        }
#line 12310
        if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12310
          if (psym->st_name < dynamic_strings_length) {
            {
#line 12311
            print_symbol(25, (char const   *)(dynamic_strings + psym->st_name));
            }
          } else {
            {
#line 12313
            tmp___56 = gettext("<corrupt: %14ld>");
#line 12313
            printf((char const   */* __restrict  */)tmp___56, psym->st_name);
            }
          }
        } else {
          {
#line 12313
          tmp___56 = gettext("<corrupt: %14ld>");
#line 12313
          printf((char const   */* __restrict  */)tmp___56, psym->st_name);
          }
        }
        {
#line 12314
        putchar('\n');
#line 12303
        cnt___1 ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 12317
      free((void *)iconf);
      }
    }
  }
#line 12320
  if (pltgot != 0UL) {
#line 12320
    if (local_gotno != 0UL) {
#line 12327
      ent = pltgot;
#line 12328
      if (is_32bit_elf) {
#line 12328
        addr_size = 4;
      } else {
#line 12328
        addr_size = 8;
      }
      {
#line 12329
      local_end = pltgot + local_gotno * (bfd_vma )addr_size;
#line 12330
      global_end = local_end + (symtabno - gotsym) * (bfd_vma )addr_size;
#line 12332
      tmp___57 = offset_from_vma(file, pltgot, global_end - pltgot);
#line 12332
      offset___0 = (size_t )tmp___57;
#line 12333
      tmp___58 = gettext("Global Offset Table data");
#line 12333
      tmp___59 = get_data((void *)0, file, (long )offset___0, global_end - pltgot,
                          (size_t )1, (char const   *)tmp___58);
#line 12333
      data = (unsigned char *)tmp___59;
      }
#line 12336
      if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 12337
        return (0);
      }
      {
#line 12339
      tmp___60 = gettext("\nPrimary GOT:\n");
#line 12339
      printf((char const   */* __restrict  */)tmp___60);
#line 12340
      tmp___61 = gettext(" Canonical gp value: ");
#line 12340
      printf((char const   */* __restrict  */)tmp___61);
#line 12341
      print_vma(pltgot + 32752UL, (print_mode )6);
#line 12342
      printf((char const   */* __restrict  */)"\n\n");
#line 12344
      tmp___62 = gettext(" Reserved entries:\n");
#line 12344
      printf((char const   */* __restrict  */)tmp___62);
#line 12345
      tmp___63 = gettext("Initial");
#line 12345
      tmp___64 = gettext("Access");
#line 12345
      tmp___65 = gettext("Address");
#line 12345
      tmp___66 = gettext("  %*s %10s %*s Purpose\n");
#line 12345
      printf((char const   */* __restrict  */)tmp___66, addr_size * 2, tmp___65, tmp___64,
             addr_size * 2, tmp___63);
#line 12348
      ent = print_mips_got_entry(data, pltgot, ent);
#line 12349
      tmp___67 = gettext(" Lazy resolver\n");
#line 12349
      printf((char const   */* __restrict  */)tmp___67);
      }
#line 12350
      if (data) {
        {
#line 12350
        tmp___69 = (*byte_get)((data + ent) - pltgot, addr_size);
        }
#line 12350
        if (tmp___69 >> (addr_size * 8 - 1) != 0ULL) {
          {
#line 12354
          ent = print_mips_got_entry(data, pltgot, ent);
#line 12355
          tmp___68 = gettext(" Module pointer (GNU extension)\n");
#line 12355
          printf((char const   */* __restrict  */)tmp___68);
          }
        }
      }
      {
#line 12357
      printf((char const   */* __restrict  */)"\n");
      }
#line 12359
      if (ent < local_end) {
        {
#line 12361
        tmp___70 = gettext(" Local entries:\n");
#line 12361
        printf((char const   */* __restrict  */)tmp___70);
#line 12362
        tmp___71 = gettext("Initial");
#line 12362
        tmp___72 = gettext("Access");
#line 12362
        tmp___73 = gettext("Address");
#line 12362
        printf((char const   */* __restrict  */)"  %*s %10s %*s\n", addr_size * 2,
               tmp___73, tmp___72, addr_size * 2, tmp___71);
        }
        {
#line 12365
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 12365
          if (! (ent < local_end)) {
#line 12365
            goto while_break___9;
          }
          {
#line 12367
          ent = print_mips_got_entry(data, pltgot, ent);
#line 12368
          printf((char const   */* __restrict  */)"\n");
          }
        }
        while_break___9: /* CIL Label */ ;
        }
        {
#line 12370
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 12373
      if (gotsym < symtabno) {
        {
#line 12377
        tmp___74 = gettext(" Global entries:\n");
#line 12377
        printf((char const   */* __restrict  */)tmp___74);
#line 12378
        tmp___75 = gettext("Name");
#line 12378
        tmp___76 = gettext("Ndx");
#line 12378
        tmp___77 = gettext("Type");
#line 12378
        tmp___78 = gettext("Sym.Val.");
#line 12378
        tmp___79 = gettext("Initial");
#line 12378
        tmp___80 = gettext("Access");
#line 12378
        tmp___81 = gettext("Address");
#line 12378
        printf((char const   */* __restrict  */)"  %*s %10s %*s %*s %-7s %3s %s\n",
               addr_size * 2, tmp___81, tmp___80, addr_size * 2, tmp___79, addr_size * 2,
               tmp___78, tmp___77, tmp___76, tmp___75);
        }
#line 12387
        if (is_32bit_elf) {
#line 12387
          tmp___82 = 80;
        } else {
#line 12387
          tmp___82 = 160;
        }
#line 12387
        sym_width = ((tmp___82 - 28) - addr_size * 6) - 1;
#line 12388
        i = gotsym;
        {
#line 12388
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 12388
          if (! (i < symtabno)) {
#line 12388
            goto while_break___10;
          }
          {
#line 12392
          psym___0 = dynamic_symbols + i;
#line 12393
          ent = print_mips_got_entry(data, pltgot, ent);
#line 12394
          printf((char const   */* __restrict  */)" ");
#line 12395
          print_vma(psym___0->st_value, (print_mode )6);
#line 12396
          tmp___83 = get_symbol_index_type(psym___0->st_shndx);
#line 12396
          tmp___84 = get_symbol_type((unsigned int )((int )psym___0->st_info & 15));
#line 12396
          printf((char const   */* __restrict  */)" %-7s %3s ", tmp___84, tmp___83);
          }
#line 12399
          if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12399
            if (psym___0->st_name < dynamic_strings_length) {
              {
#line 12400
              print_symbol(sym_width, (char const   *)(dynamic_strings + psym___0->st_name));
              }
            } else {
              {
#line 12402
              tmp___85 = gettext("<corrupt: %14ld>");
#line 12402
              printf((char const   */* __restrict  */)tmp___85, psym___0->st_name);
              }
            }
          } else {
            {
#line 12402
            tmp___85 = gettext("<corrupt: %14ld>");
#line 12402
            printf((char const   */* __restrict  */)tmp___85, psym___0->st_name);
            }
          }
          {
#line 12403
          printf((char const   */* __restrict  */)"\n");
#line 12388
          i ++;
          }
        }
        while_break___10: /* CIL Label */ ;
        }
        {
#line 12405
        printf((char const   */* __restrict  */)"\n");
        }
      }
#line 12408
      if (data) {
        {
#line 12409
        free((void *)data);
        }
      }
    }
  }
#line 12412
  if (mips_pltgot != 0UL) {
#line 12412
    if (jmprel != 0UL) {
#line 12412
      if (pltrel != 0UL) {
#line 12412
        if (pltrelsz != 0UL) {
          {
#line 12421
          tmp___86 = offset_from_vma(file, jmprel, pltrelsz);
#line 12421
          rel_offset = (size_t )tmp___86;
          }
#line 12422
          if (pltrel == 7UL) {
            {
#line 12424
            tmp___87 = slurp_rela_relocs(file, rel_offset, pltrelsz, & rels, & count);
            }
#line 12424
            if (! tmp___87) {
#line 12425
              return (0);
            }
          } else {
            {
#line 12429
            tmp___88 = slurp_rel_relocs(file, rel_offset, pltrelsz, & rels, & count);
            }
#line 12429
            if (! tmp___88) {
#line 12430
              return (0);
            }
          }
#line 12433
          ent___0 = mips_pltgot;
#line 12434
          if (is_32bit_elf) {
#line 12434
            addr_size___0 = 4;
          } else {
#line 12434
            addr_size___0 = 8;
          }
          {
#line 12435
          end = mips_pltgot + (2UL + count) * (unsigned long )addr_size___0;
#line 12437
          tmp___89 = offset_from_vma(file, mips_pltgot, end - mips_pltgot);
#line 12437
          offset___1 = (size_t )tmp___89;
#line 12438
          tmp___90 = gettext("Procedure Linkage Table data");
#line 12438
          tmp___91 = get_data((void *)0, file, (long )offset___1, end - mips_pltgot,
                              (size_t )1, (char const   *)tmp___90);
#line 12438
          data___0 = (unsigned char *)tmp___91;
          }
#line 12440
          if ((unsigned long )data___0 == (unsigned long )((void *)0)) {
#line 12441
            return (0);
          }
          {
#line 12443
          printf((char const   */* __restrict  */)"\nPLT GOT:\n\n");
#line 12444
          tmp___92 = gettext(" Reserved entries:\n");
#line 12444
          printf((char const   */* __restrict  */)tmp___92);
#line 12445
          tmp___93 = gettext("Initial");
#line 12445
          tmp___94 = gettext("Address");
#line 12445
          tmp___95 = gettext("  %*s %*s Purpose\n");
#line 12445
          printf((char const   */* __restrict  */)tmp___95, addr_size___0 * 2, tmp___94,
                 addr_size___0 * 2, tmp___93);
#line 12447
          ent___0 = print_mips_pltgot_entry(data___0, mips_pltgot, ent___0);
#line 12448
          tmp___96 = gettext(" PLT lazy resolver\n");
#line 12448
          printf((char const   */* __restrict  */)tmp___96);
#line 12449
          ent___0 = print_mips_pltgot_entry(data___0, mips_pltgot, ent___0);
#line 12450
          tmp___97 = gettext(" Module pointer\n");
#line 12450
          printf((char const   */* __restrict  */)tmp___97);
#line 12451
          printf((char const   */* __restrict  */)"\n");
#line 12453
          tmp___98 = gettext(" Entries:\n");
#line 12453
          printf((char const   */* __restrict  */)tmp___98);
#line 12454
          tmp___99 = gettext("Name");
#line 12454
          tmp___100 = gettext("Ndx");
#line 12454
          tmp___101 = gettext("Type");
#line 12454
          tmp___102 = gettext("Sym.Val.");
#line 12454
          tmp___103 = gettext("Initial");
#line 12454
          tmp___104 = gettext("Address");
#line 12454
          printf((char const   */* __restrict  */)"  %*s %*s %*s %-7s %3s %s\n", addr_size___0 * 2,
                 tmp___104, addr_size___0 * 2, tmp___103, addr_size___0 * 2, tmp___102,
                 tmp___101, tmp___100, tmp___99);
          }
#line 12458
          if (is_32bit_elf) {
#line 12458
            tmp___105 = 80;
          } else {
#line 12458
            tmp___105 = 160;
          }
#line 12458
          sym_width___0 = ((tmp___105 - 17) - addr_size___0 * 6) - 1;
#line 12459
          i___0 = 0UL;
          {
#line 12459
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 12459
            if (! (i___0 < count)) {
#line 12459
              goto while_break___11;
            }
            {
#line 12463
            tmp___106 = get_reloc_symindex((rels + i___0)->r_info);
#line 12463
            psym___1 = dynamic_symbols + tmp___106;
#line 12464
            ent___0 = print_mips_pltgot_entry(data___0, mips_pltgot, ent___0);
#line 12465
            printf((char const   */* __restrict  */)" ");
#line 12466
            print_vma(psym___1->st_value, (print_mode )6);
#line 12467
            tmp___107 = get_symbol_index_type(psym___1->st_shndx);
#line 12467
            tmp___108 = get_symbol_type((unsigned int )((int )psym___1->st_info & 15));
#line 12467
            printf((char const   */* __restrict  */)" %-7s %3s ", tmp___108, tmp___107);
            }
#line 12470
            if ((unsigned long )dynamic_strings != (unsigned long )((void *)0)) {
#line 12470
              if (psym___1->st_name < dynamic_strings_length) {
                {
#line 12471
                print_symbol(sym_width___0, (char const   *)(dynamic_strings + psym___1->st_name));
                }
              } else {
                {
#line 12473
                tmp___109 = gettext("<corrupt: %14ld>");
#line 12473
                printf((char const   */* __restrict  */)tmp___109, psym___1->st_name);
                }
              }
            } else {
              {
#line 12473
              tmp___109 = gettext("<corrupt: %14ld>");
#line 12473
              printf((char const   */* __restrict  */)tmp___109, psym___1->st_name);
              }
            }
            {
#line 12474
            printf((char const   */* __restrict  */)"\n");
#line 12459
            i___0 ++;
            }
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 12476
          printf((char const   */* __restrict  */)"\n");
          }
#line 12478
          if (data___0) {
            {
#line 12479
            free((void *)data___0);
            }
          }
          {
#line 12480
          free((void *)rels);
          }
        }
      }
    }
  }
#line 12483
  return (1);
}
}
#line 12486 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_gnu_liblist(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  Elf_Internal_Shdr *string_sec ;
  Elf32_External_Lib *elib ;
  char *strtab ;
  size_t strtab_size ;
  size_t cnt ;
  unsigned int i ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  Elf32_Lib liblist ;
  time_t atime ;
  char timebuf[20] ;
  struct tm *tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  elf_vma tmp___15 ;
  elf_vma tmp___16 ;
  elf_vma tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
#line 12497
  if (! do_arch) {
#line 12498
    return (0);
  }
#line 12500
  i = 0U;
#line 12500
  section = section_headers;
  {
#line 12500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12500
    if (! (i < elf_header.e_shnum)) {
#line 12500
      goto while_break;
    }
    {
#line 12506
    if (section->sh_type == 1879048183U) {
#line 12506
      goto case_1879048183;
    }
#line 12504
    goto switch_break;
    case_1879048183: /* CIL Label */ 
#line 12507
    if (section->sh_link >= elf_header.e_shnum) {
#line 12508
      goto switch_break;
    }
    {
#line 12510
    tmp___0 = gettext("liblist section data");
#line 12510
    tmp___1 = get_data((void *)0, file, section->sh_offset, (size_t )1, section->sh_size,
                       (char const   *)tmp___0);
#line 12510
    elib = (Elf32_External_Lib *)tmp___1;
    }
#line 12514
    if ((unsigned long )elib == (unsigned long )((void *)0)) {
#line 12515
      goto switch_break;
    }
    {
#line 12516
    string_sec = section_headers + section->sh_link;
#line 12518
    tmp___2 = gettext("liblist string table");
#line 12518
    tmp___3 = get_data((void *)0, file, string_sec->sh_offset, (size_t )1, string_sec->sh_size,
                       (char const   *)tmp___2);
#line 12518
    strtab = (char *)tmp___3;
    }
#line 12521
    if ((unsigned long )strtab == (unsigned long )((void *)0)) {
      {
#line 12524
      free((void *)elib);
#line 12525
      free((void *)strtab);
      }
#line 12526
      goto switch_break;
    } else
#line 12521
    if (section->sh_entsize != sizeof(Elf32_External_Lib )) {
      {
#line 12524
      free((void *)elib);
#line 12525
      free((void *)strtab);
      }
#line 12526
      goto switch_break;
    }
#line 12528
    strtab_size = string_sec->sh_size;
#line 12530
    if ((unsigned long )section == (unsigned long )((void *)0)) {
      {
#line 12530
      tmp___4 = gettext("<none>");
#line 12530
      tmp___9 = tmp___4;
      }
    } else {
#line 12530
      if ((unsigned long )string_table == (unsigned long )((void *)0)) {
        {
#line 12530
        tmp___5 = gettext("<no-name>");
#line 12530
        tmp___8 = tmp___5;
        }
      } else {
#line 12530
        if ((unsigned long )section->sh_name >= string_table_length) {
          {
#line 12530
          tmp___6 = gettext("<corrupt>");
#line 12530
          tmp___7 = tmp___6;
          }
        } else {
#line 12530
          tmp___7 = string_table + section->sh_name;
        }
#line 12530
        tmp___8 = tmp___7;
      }
#line 12530
      tmp___9 = tmp___8;
    }
    {
#line 12530
    tmp___10 = gettext("\nLibrary list section \'%s\' contains %lu entries:\n");
#line 12530
    printf((char const   */* __restrict  */)tmp___10, tmp___9, section->sh_size / sizeof(Elf32_External_Lib ));
#line 12534
    tmp___11 = gettext("     Library              Time Stamp          Checksum   Version Flags");
#line 12534
    puts((char const   *)tmp___11);
#line 12536
    cnt = (size_t )0;
    }
    {
#line 12536
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 12536
      if (! (cnt < section->sh_size / sizeof(Elf32_External_Lib ))) {
#line 12536
        goto while_break___0;
      }
      {
#line 12544
      tmp___13 = (*byte_get)((elib + cnt)->l_name, (int )sizeof((elib + cnt)->l_name));
#line 12544
      liblist.l_name = (unsigned long )tmp___13;
#line 12545
      tmp___14 = (*byte_get)((elib + cnt)->l_time_stamp, (int )sizeof((elib + cnt)->l_time_stamp));
#line 12545
      atime = (time_t )tmp___14;
#line 12546
      tmp___15 = (*byte_get)((elib + cnt)->l_checksum, (int )sizeof((elib + cnt)->l_checksum));
#line 12546
      liblist.l_checksum = (unsigned long )tmp___15;
#line 12547
      tmp___16 = (*byte_get)((elib + cnt)->l_version, (int )sizeof((elib + cnt)->l_version));
#line 12547
      liblist.l_version = (unsigned long )tmp___16;
#line 12548
      tmp___17 = (*byte_get)((elib + cnt)->l_flags, (int )sizeof((elib + cnt)->l_flags));
#line 12548
      liblist.l_flags = (unsigned long )tmp___17;
#line 12550
      tmp___12 = gmtime((time_t const   *)(& atime));
#line 12551
      snprintf((char */* __restrict  */)(timebuf), sizeof(timebuf), (char const   */* __restrict  */)"%04u-%02u-%02uT%02u:%02u:%02u",
               tmp___12->tm_year + 1900, tmp___12->tm_mon + 1, tmp___12->tm_mday,
               tmp___12->tm_hour, tmp___12->tm_min, tmp___12->tm_sec);
#line 12556
      printf((char const   */* __restrict  */)"%3lu: ", cnt);
      }
#line 12557
      if (do_wide) {
#line 12558
        if (liblist.l_name < strtab_size) {
#line 12558
          tmp___19 = strtab + liblist.l_name;
        } else {
          {
#line 12558
          tmp___18 = gettext("<corrupt>");
#line 12558
          tmp___19 = tmp___18;
          }
        }
        {
#line 12558
        printf((char const   */* __restrict  */)"%-20s", tmp___19);
        }
      } else {
#line 12561
        if (liblist.l_name < strtab_size) {
#line 12561
          tmp___21 = strtab + liblist.l_name;
        } else {
          {
#line 12561
          tmp___20 = gettext("<corrupt>");
#line 12561
          tmp___21 = tmp___20;
          }
        }
        {
#line 12561
        printf((char const   */* __restrict  */)"%-20.20s", tmp___21);
        }
      }
      {
#line 12563
      printf((char const   */* __restrict  */)" %s %#010lx %-7ld %-7ld\n", timebuf,
             liblist.l_checksum, liblist.l_version, liblist.l_flags);
#line 12536
      cnt ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 12567
    free((void *)elib);
#line 12568
    free((void *)strtab);
    }
    switch_break: /* CIL Label */ ;
    }
#line 12500
    i ++;
#line 12500
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 12572
  return (1);
}
}
#line 12578 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___15[64]  ;
#line 12575 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;

  {
#line 12580
  if ((int )elf_header.e_type == 4) {
    {
#line 12583
    if (e_type == 6U) {
#line 12583
      goto case_6;
    }
#line 12585
    if (e_type == 1U) {
#line 12585
      goto case_1;
    }
#line 12587
    if (e_type == 2U) {
#line 12587
      goto case_2;
    }
#line 12589
    if (e_type == 3U) {
#line 12589
      goto case_3;
    }
#line 12591
    if (e_type == 4U) {
#line 12591
      goto case_4;
    }
#line 12593
    if (e_type == 1189489535U) {
#line 12593
      goto case_1189489535;
    }
#line 12595
    if (e_type == 256U) {
#line 12595
      goto case_256;
    }
#line 12597
    if (e_type == 258U) {
#line 12597
      goto case_258;
    }
#line 12599
    if (e_type == 514U) {
#line 12599
      goto case_514;
    }
#line 12601
    if (e_type == 768U) {
#line 12601
      goto case_768;
    }
#line 12603
    if (e_type == 769U) {
#line 12603
      goto case_769;
    }
#line 12605
    if (e_type == 770U) {
#line 12605
      goto case_770;
    }
#line 12607
    if (e_type == 771U) {
#line 12607
      goto case_771;
    }
#line 12609
    if (e_type == 772U) {
#line 12609
      goto case_772;
    }
#line 12611
    if (e_type == 773U) {
#line 12611
      goto case_773;
    }
#line 12613
    if (e_type == 1024U) {
#line 12613
      goto case_1024;
    }
#line 12615
    if (e_type == 10U) {
#line 12615
      goto case_10;
    }
#line 12617
    if (e_type == 12U) {
#line 12617
      goto case_12;
    }
#line 12619
    if (e_type == 13U) {
#line 12619
      goto case_13;
    }
#line 12621
    if (e_type == 16U) {
#line 12621
      goto case_16;
    }
#line 12623
    if (e_type == 17U) {
#line 12623
      goto case_17;
    }
#line 12625
    if (e_type == 18U) {
#line 12625
      goto case_18;
    }
#line 12627
    goto switch_default;
    case_6: /* CIL Label */ 
    {
#line 12584
    tmp___0 = gettext("NT_AUXV (auxiliary vector)");
    }
#line 12584
    return ((char const   *)tmp___0);
    case_1: /* CIL Label */ 
    {
#line 12586
    tmp___1 = gettext("NT_PRSTATUS (prstatus structure)");
    }
#line 12586
    return ((char const   *)tmp___1);
    case_2: /* CIL Label */ 
    {
#line 12588
    tmp___2 = gettext("NT_FPREGSET (floating point registers)");
    }
#line 12588
    return ((char const   *)tmp___2);
    case_3: /* CIL Label */ 
    {
#line 12590
    tmp___3 = gettext("NT_PRPSINFO (prpsinfo structure)");
    }
#line 12590
    return ((char const   *)tmp___3);
    case_4: /* CIL Label */ 
    {
#line 12592
    tmp___4 = gettext("NT_TASKSTRUCT (task structure)");
    }
#line 12592
    return ((char const   *)tmp___4);
    case_1189489535: /* CIL Label */ 
    {
#line 12594
    tmp___5 = gettext("NT_PRXFPREG (user_xfpregs structure)");
    }
#line 12594
    return ((char const   *)tmp___5);
    case_256: /* CIL Label */ 
    {
#line 12596
    tmp___6 = gettext("NT_PPC_VMX (ppc Altivec registers)");
    }
#line 12596
    return ((char const   *)tmp___6);
    case_258: /* CIL Label */ 
    {
#line 12598
    tmp___7 = gettext("NT_PPC_VSX (ppc VSX registers)");
    }
#line 12598
    return ((char const   *)tmp___7);
    case_514: /* CIL Label */ 
    {
#line 12600
    tmp___8 = gettext("NT_X86_XSTATE (x86 XSAVE extended state)");
    }
#line 12600
    return ((char const   *)tmp___8);
    case_768: /* CIL Label */ 
    {
#line 12602
    tmp___9 = gettext("NT_S390_HIGH_GPRS (s390 upper register halves)");
    }
#line 12602
    return ((char const   *)tmp___9);
    case_769: /* CIL Label */ 
    {
#line 12604
    tmp___10 = gettext("NT_S390_TIMER (s390 timer register)");
    }
#line 12604
    return ((char const   *)tmp___10);
    case_770: /* CIL Label */ 
    {
#line 12606
    tmp___11 = gettext("NT_S390_TODCMP (s390 TOD comparator register)");
    }
#line 12606
    return ((char const   *)tmp___11);
    case_771: /* CIL Label */ 
    {
#line 12608
    tmp___12 = gettext("NT_S390_TODPREG (s390 TOD programmable register)");
    }
#line 12608
    return ((char const   *)tmp___12);
    case_772: /* CIL Label */ 
    {
#line 12610
    tmp___13 = gettext("NT_S390_CTRS (s390 control registers)");
    }
#line 12610
    return ((char const   *)tmp___13);
    case_773: /* CIL Label */ 
    {
#line 12612
    tmp___14 = gettext("NT_S390_PREFIX (s390 prefix register)");
    }
#line 12612
    return ((char const   *)tmp___14);
    case_1024: /* CIL Label */ 
    {
#line 12614
    tmp___15 = gettext("NT_ARM_VFP (arm VFP registers)");
    }
#line 12614
    return ((char const   *)tmp___15);
    case_10: /* CIL Label */ 
    {
#line 12616
    tmp___16 = gettext("NT_PSTATUS (pstatus structure)");
    }
#line 12616
    return ((char const   *)tmp___16);
    case_12: /* CIL Label */ 
    {
#line 12618
    tmp___17 = gettext("NT_FPREGS (floating point registers)");
    }
#line 12618
    return ((char const   *)tmp___17);
    case_13: /* CIL Label */ 
    {
#line 12620
    tmp___18 = gettext("NT_PSINFO (psinfo structure)");
    }
#line 12620
    return ((char const   *)tmp___18);
    case_16: /* CIL Label */ 
    {
#line 12622
    tmp___19 = gettext("NT_LWPSTATUS (lwpstatus_t structure)");
    }
#line 12622
    return ((char const   *)tmp___19);
    case_17: /* CIL Label */ 
    {
#line 12624
    tmp___20 = gettext("NT_LWPSINFO (lwpsinfo_t structure)");
    }
#line 12624
    return ((char const   *)tmp___20);
    case_18: /* CIL Label */ 
    {
#line 12626
    tmp___21 = gettext("NT_WIN32PSTATUS (win32_pstatus structure)");
    }
#line 12626
    return ((char const   *)tmp___21);
    switch_default: /* CIL Label */ 
#line 12628
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 12633
    if (e_type == 1U) {
#line 12633
      goto case_1___0;
    }
#line 12635
    if (e_type == 2U) {
#line 12635
      goto case_2___0;
    }
#line 12637
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 12634
    tmp___22 = gettext("NT_VERSION (version)");
    }
#line 12634
    return ((char const   *)tmp___22);
    case_2___0: /* CIL Label */ 
    {
#line 12636
    tmp___23 = gettext("NT_ARCH (architecture)");
    }
#line 12636
    return ((char const   *)tmp___23);
    switch_default___0: /* CIL Label */ 
#line 12638
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 12641
  tmp___24 = gettext("Unknown note type: (0x%08x)");
#line 12641
  snprintf((char */* __restrict  */)(buff___15), sizeof(buff___15), (char const   */* __restrict  */)tmp___24,
           e_type);
  }
#line 12642
  return ((char const   *)(buff___15));
}
}
#line 12648 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___16[64]  ;
#line 12645 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_gnu_elf_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 12652
  if (e_type == 1U) {
#line 12652
    goto case_1;
  }
#line 12654
  if (e_type == 2U) {
#line 12654
    goto case_2;
  }
#line 12656
  if (e_type == 3U) {
#line 12656
    goto case_3;
  }
#line 12658
  if (e_type == 4U) {
#line 12658
    goto case_4;
  }
#line 12660
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 12653
  tmp___0 = gettext("NT_GNU_ABI_TAG (ABI version tag)");
  }
#line 12653
  return ((char const   *)tmp___0);
  case_2: /* CIL Label */ 
  {
#line 12655
  tmp___1 = gettext("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
  }
#line 12655
  return ((char const   *)tmp___1);
  case_3: /* CIL Label */ 
  {
#line 12657
  tmp___2 = gettext("NT_GNU_BUILD_ID (unique build ID bitstring)");
  }
#line 12657
  return ((char const   *)tmp___2);
  case_4: /* CIL Label */ 
  {
#line 12659
  tmp___3 = gettext("NT_GNU_GOLD_VERSION (gold version)");
  }
#line 12659
  return ((char const   *)tmp___3);
  switch_default: /* CIL Label */ 
#line 12661
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 12664
  tmp___4 = gettext("Unknown note type: (0x%08x)");
#line 12664
  snprintf((char */* __restrict  */)(buff___16), sizeof(buff___16), (char const   */* __restrict  */)tmp___4,
           e_type);
  }
#line 12665
  return ((char const   *)(buff___16));
}
}
#line 12668 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int print_gnu_note(Elf_Internal_Note *pnote ) 
{ 
  unsigned long i ;
  char *tmp___0 ;
  unsigned long os ;
  unsigned long major ;
  unsigned long minor ;
  unsigned long subminor ;
  char const   *osname ;
  elf_vma tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 12673
  if (pnote->type == 3UL) {
#line 12673
    goto case_3;
  }
#line 12684
  if (pnote->type == 1UL) {
#line 12684
    goto case_1;
  }
#line 12671
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 12677
  tmp___0 = gettext("    Build ID: ");
#line 12677
  printf((char const   */* __restrict  */)tmp___0);
#line 12678
  i = 0UL;
  }
  {
#line 12678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 12678
    if (! (i < pnote->descsz)) {
#line 12678
      goto while_break;
    }
    {
#line 12679
    printf((char const   */* __restrict  */)"%02x", (int )*(pnote->descdata + i) & 255);
#line 12678
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 12680
  printf((char const   */* __restrict  */)"\n");
  }
#line 12682
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 12689
  tmp___1 = (*byte_get)((unsigned char *)pnote->descdata, 4);
#line 12689
  os = (unsigned long )tmp___1;
#line 12690
  tmp___2 = (*byte_get)((unsigned char *)pnote->descdata + 4, 4);
#line 12690
  major = (unsigned long )tmp___2;
#line 12691
  tmp___3 = (*byte_get)((unsigned char *)pnote->descdata + 8, 4);
#line 12691
  minor = (unsigned long )tmp___3;
#line 12692
  tmp___4 = (*byte_get)((unsigned char *)pnote->descdata + 12, 4);
#line 12692
  subminor = (unsigned long )tmp___4;
  }
  {
#line 12696
  if (os == 0UL) {
#line 12696
    goto case_0;
  }
#line 12699
  if (os == 1UL) {
#line 12699
    goto case_1___0;
  }
#line 12702
  if (os == 2UL) {
#line 12702
    goto case_2;
  }
#line 12705
  if (os == 3UL) {
#line 12705
    goto case_3___0;
  }
#line 12708
  if (os == 4UL) {
#line 12708
    goto case_4;
  }
#line 12711
  goto switch_default;
  case_0: /* CIL Label */ 
#line 12697
  osname = "Linux";
#line 12698
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 12700
  osname = "Hurd";
#line 12701
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 12703
  osname = "Solaris";
#line 12704
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 12706
  osname = "FreeBSD";
#line 12707
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 12709
  osname = "NetBSD";
#line 12710
  goto switch_break___0;
  switch_default: /* CIL Label */ 
#line 12712
  osname = "Unknown";
#line 12713
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 12716
  tmp___5 = gettext("    OS: %s, ABI: %ld.%ld.%ld\n");
#line 12716
  printf((char const   */* __restrict  */)tmp___5, osname, major, minor, subminor);
  }
#line 12719
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 12722
  return (1);
}
}
#line 12728 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___17[64]  ;
#line 12725 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_netbsd_elfcore_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 12730
  if (e_type == 1U) {
    {
#line 12733
    tmp___0 = gettext("NetBSD procinfo structure");
    }
#line 12733
    return ((char const   *)tmp___0);
  }
#line 12741
  if (e_type < 32U) {
    {
#line 12743
    tmp___1 = gettext("Unknown note type: (0x%08x)");
#line 12743
    snprintf((char */* __restrict  */)(buff___17), sizeof(buff___17), (char const   */* __restrict  */)tmp___1,
             e_type);
    }
#line 12744
    return ((char const   *)(buff___17));
  }
  {
#line 12756
  if ((int )elf_header.e_machine == 43) {
#line 12756
    goto case_43;
  }
#line 12756
  if ((int )elf_header.e_machine == 18) {
#line 12756
    goto case_43;
  }
#line 12756
  if ((int )elf_header.e_machine == 2) {
#line 12756
    goto case_43;
  }
#line 12756
  if ((int )elf_header.e_machine == 36902) {
#line 12756
    goto case_43;
  }
#line 12756
  if ((int )elf_header.e_machine == 41) {
#line 12756
    goto case_43;
  }
#line 12770
  goto switch_default___0;
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_36902: /* CIL Label */ 
  case_41: /* CIL Label */ 
  {
#line 12759
  if (e_type == 32U) {
#line 12759
    goto case_32;
  }
#line 12761
  if (e_type == 34U) {
#line 12761
    goto case_34;
  }
#line 12763
  goto switch_default;
  case_32: /* CIL Label */ 
  {
#line 12760
  tmp___2 = gettext("PT_GETREGS (reg structure)");
  }
#line 12760
  return ((char const   *)tmp___2);
  case_34: /* CIL Label */ 
  {
#line 12762
  tmp___3 = gettext("PT_GETFPREGS (fpreg structure)");
  }
#line 12762
  return ((char const   *)tmp___3);
  switch_default: /* CIL Label */ 
#line 12764
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 12766
  goto switch_break;
  switch_default___0: /* CIL Label */ 
  {
#line 12773
  if (e_type == 33U) {
#line 12773
    goto case_33;
  }
#line 12775
  if (e_type == 35U) {
#line 12775
    goto case_35;
  }
#line 12777
  goto switch_default___1;
  case_33: /* CIL Label */ 
  {
#line 12774
  tmp___4 = gettext("PT_GETREGS (reg structure)");
  }
#line 12774
  return ((char const   *)tmp___4);
  case_35: /* CIL Label */ 
  {
#line 12776
  tmp___5 = gettext("PT_GETFPREGS (fpreg structure)");
  }
#line 12776
  return ((char const   *)tmp___5);
  switch_default___1: /* CIL Label */ 
#line 12778
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 12782
  snprintf((char */* __restrict  */)(buff___17), sizeof(buff___17), (char const   */* __restrict  */)"PT_FIRSTMACH+%d",
           e_type - 32U);
  }
#line 12784
  return ((char const   *)(buff___17));
}
}
#line 12790 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___18[64]  ;
#line 12787 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_stapsdt_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 12794
  if (e_type == 3U) {
#line 12794
    goto case_3;
  }
#line 12797
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 12795
  tmp___0 = gettext("NT_STAPSDT (SystemTap probe descriptors)");
  }
#line 12795
  return ((char const   *)tmp___0);
  switch_default: /* CIL Label */ 
#line 12798
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 12801
  tmp___1 = gettext("Unknown note type: (0x%08x)");
#line 12801
  snprintf((char */* __restrict  */)(buff___18), sizeof(buff___18), (char const   */* __restrict  */)tmp___1,
           e_type);
  }
#line 12802
  return ((char const   *)(buff___18));
}
}
#line 12805 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int print_stapsdt_note(Elf_Internal_Note *pnote ) 
{ 
  int addr_size ;
  int tmp___0 ;
  char *data ;
  char *data_end ;
  bfd_vma pc ;
  bfd_vma base_addr ;
  bfd_vma semaphore ;
  char *provider ;
  char *probe ;
  char *arg_fmt ;
  elf_vma tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 12808
  if (is_32bit_elf) {
#line 12808
    tmp___0 = 4;
  } else {
#line 12808
    tmp___0 = 8;
  }
  {
#line 12808
  addr_size = tmp___0;
#line 12809
  data = pnote->descdata;
#line 12810
  data_end = pnote->descdata + pnote->descsz;
#line 12814
  tmp___1 = (*byte_get)((unsigned char *)data, addr_size);
#line 12814
  pc = (bfd_vma )tmp___1;
#line 12815
  data += addr_size;
#line 12816
  tmp___2 = (*byte_get)((unsigned char *)data, addr_size);
#line 12816
  base_addr = (bfd_vma )tmp___2;
#line 12817
  data += addr_size;
#line 12818
  tmp___3 = (*byte_get)((unsigned char *)data, addr_size);
#line 12818
  semaphore = (bfd_vma )tmp___3;
#line 12819
  data += addr_size;
#line 12821
  provider = data;
#line 12822
  tmp___4 = strlen((char const   *)data);
#line 12822
  data += tmp___4 + 1UL;
#line 12823
  probe = data;
#line 12824
  tmp___5 = strlen((char const   *)data);
#line 12824
  data += tmp___5 + 1UL;
#line 12825
  arg_fmt = data;
#line 12826
  tmp___6 = strlen((char const   *)data);
#line 12826
  data += tmp___6 + 1UL;
#line 12828
  tmp___7 = gettext("    Provider: %s\n");
#line 12828
  printf((char const   */* __restrict  */)tmp___7, provider);
#line 12829
  tmp___8 = gettext("    Name: %s\n");
#line 12829
  printf((char const   */* __restrict  */)tmp___8, probe);
#line 12830
  tmp___9 = gettext("    Location: ");
#line 12830
  printf((char const   */* __restrict  */)tmp___9);
#line 12831
  print_vma(pc, (print_mode )5);
#line 12832
  tmp___10 = gettext(", Base: ");
#line 12832
  printf((char const   */* __restrict  */)tmp___10);
#line 12833
  print_vma(base_addr, (print_mode )5);
#line 12834
  tmp___11 = gettext(", Semaphore: ");
#line 12834
  printf((char const   */* __restrict  */)tmp___11);
#line 12835
  print_vma(semaphore, (print_mode )5);
#line 12836
  printf((char const   */* __restrict  */)"\n");
#line 12837
  tmp___12 = gettext("    Arguments: %s\n");
#line 12837
  printf((char const   */* __restrict  */)tmp___12, arg_fmt);
  }
#line 12839
  return ((unsigned long )data == (unsigned long )data_end);
}
}
#line 12845 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char buff___19[64]  ;
#line 12842 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static char const   *get_ia64_vms_note_type(unsigned int e_type ) 
{ 
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 12849
  if (e_type == 1U) {
#line 12849
    goto case_1;
  }
#line 12851
  if (e_type == 2U) {
#line 12851
    goto case_2;
  }
#line 12853
  if (e_type == 3U) {
#line 12853
    goto case_3;
  }
#line 12855
  if (e_type == 4U) {
#line 12855
    goto case_4;
  }
#line 12857
  if (e_type == 5U) {
#line 12857
    goto case_5;
  }
#line 12859
  if (e_type == 6U) {
#line 12859
    goto case_6;
  }
#line 12861
  if (e_type == 101U) {
#line 12861
    goto case_101;
  }
#line 12863
  if (e_type == 102U) {
#line 12863
    goto case_102;
  }
#line 12865
  if (e_type == 103U) {
#line 12865
    goto case_103;
  }
#line 12867
  if (e_type == 104U) {
#line 12867
    goto case_104;
  }
#line 12869
  if (e_type == 105U) {
#line 12869
    goto case_105;
  }
#line 12871
  if (e_type == 106U) {
#line 12871
    goto case_106;
  }
#line 12873
  if (e_type == 107U) {
#line 12873
    goto case_107;
  }
#line 12875
  if (e_type == 108U) {
#line 12875
    goto case_108;
  }
#line 12877
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 12850
  tmp___0 = gettext("NT_VMS_MHD (module header)");
  }
#line 12850
  return ((char const   *)tmp___0);
  case_2: /* CIL Label */ 
  {
#line 12852
  tmp___1 = gettext("NT_VMS_LNM (language name)");
  }
#line 12852
  return ((char const   *)tmp___1);
  case_3: /* CIL Label */ 
  {
#line 12854
  tmp___2 = gettext("NT_VMS_SRC (source files)");
  }
#line 12854
  return ((char const   *)tmp___2);
  case_4: /* CIL Label */ 
#line 12856
  return ("NT_VMS_TITLE");
  case_5: /* CIL Label */ 
  {
#line 12858
  tmp___3 = gettext("NT_VMS_EIDC (consistency check)");
  }
#line 12858
  return ((char const   *)tmp___3);
  case_6: /* CIL Label */ 
  {
#line 12860
  tmp___4 = gettext("NT_VMS_FPMODE (FP mode)");
  }
#line 12860
  return ((char const   *)tmp___4);
  case_101: /* CIL Label */ 
#line 12862
  return ("NT_VMS_LINKTIME");
  case_102: /* CIL Label */ 
  {
#line 12864
  tmp___5 = gettext("NT_VMS_IMGNAM (image name)");
  }
#line 12864
  return ((char const   *)tmp___5);
  case_103: /* CIL Label */ 
  {
#line 12866
  tmp___6 = gettext("NT_VMS_IMGID (image id)");
  }
#line 12866
  return ((char const   *)tmp___6);
  case_104: /* CIL Label */ 
  {
#line 12868
  tmp___7 = gettext("NT_VMS_LINKID (link id)");
  }
#line 12868
  return ((char const   *)tmp___7);
  case_105: /* CIL Label */ 
  {
#line 12870
  tmp___8 = gettext("NT_VMS_IMGBID (build id)");
  }
#line 12870
  return ((char const   *)tmp___8);
  case_106: /* CIL Label */ 
  {
#line 12872
  tmp___9 = gettext("NT_VMS_GSTNAM (sym table name)");
  }
#line 12872
  return ((char const   *)tmp___9);
  case_107: /* CIL Label */ 
#line 12874
  return ("NT_VMS_ORIG_DYN");
  case_108: /* CIL Label */ 
#line 12876
  return ("NT_VMS_PATCHTIME");
  switch_default: /* CIL Label */ 
  {
#line 12878
  tmp___10 = gettext("Unknown note type: (0x%08x)");
#line 12878
  snprintf((char */* __restrict  */)(buff___19), sizeof(buff___19), (char const   */* __restrict  */)tmp___10,
           e_type);
  }
#line 12879
  return ((char const   *)(buff___19));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 12883 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int print_ia64_vms_note(Elf_Internal_Note *pnote ) 
{ 
  size_t l ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  elf_vma tmp___8 ;
  char *tmp___9 ;
  elf_vma tmp___10 ;
  char *tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  elf_vma tmp___17 ;
  char *tmp___18 ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
  {
#line 12888
  if (pnote->type == 1UL) {
#line 12888
    goto case_1;
  }
#line 12900
  if (pnote->type == 2UL) {
#line 12900
    goto case_2;
  }
#line 12904
  if (pnote->type == 6UL) {
#line 12904
    goto case_6;
  }
#line 12909
  if (pnote->type == 101UL) {
#line 12909
    goto case_101;
  }
#line 12915
  if (pnote->type == 108UL) {
#line 12915
    goto case_108;
  }
#line 12921
  if (pnote->type == 107UL) {
#line 12921
    goto case_107;
  }
#line 12936
  if (pnote->type == 102UL) {
#line 12936
    goto case_102;
  }
#line 12939
  if (pnote->type == 106UL) {
#line 12939
    goto case_106;
  }
#line 12942
  if (pnote->type == 103UL) {
#line 12942
    goto case_103;
  }
#line 12945
  if (pnote->type == 104UL) {
#line 12945
    goto case_104;
  }
#line 12948
  goto switch_default;
  case_1: /* CIL Label */ 
#line 12889
  if (pnote->descsz > 36UL) {
    {
#line 12891
    tmp___0 = strlen((char const   *)(pnote->descdata + 34));
#line 12891
    l = tmp___0;
#line 12892
    tmp___1 = gettext("    Creation date  : %.17s\n");
#line 12892
    printf((char const   */* __restrict  */)tmp___1, pnote->descdata);
#line 12893
    tmp___2 = gettext("    Last patch date: %.17s\n");
#line 12893
    printf((char const   */* __restrict  */)tmp___2, pnote->descdata + 17);
#line 12894
    tmp___3 = gettext("    Module name    : %s\n");
#line 12894
    printf((char const   */* __restrict  */)tmp___3, pnote->descdata + 34);
#line 12895
    tmp___4 = gettext("    Module version : %s\n");
#line 12895
    printf((char const   */* __restrict  */)tmp___4, ((pnote->descdata + 34) + l) + 1);
    }
  } else {
    {
#line 12898
    tmp___5 = gettext("    Invalid size\n");
#line 12898
    printf((char const   */* __restrict  */)tmp___5);
    }
  }
#line 12899
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 12901
  tmp___6 = gettext("   Language: %s\n");
#line 12901
  printf((char const   */* __restrict  */)tmp___6, pnote->descdata);
  }
#line 12902
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 12905
  tmp___7 = gettext("   Floating Point mode: ");
#line 12905
  printf((char const   */* __restrict  */)tmp___7);
#line 12906
  tmp___8 = (*byte_get)((unsigned char *)pnote->descdata, 8);
#line 12906
  printf((char const   */* __restrict  */)"0x%016lx\n", (bfd_vma )tmp___8);
  }
#line 12908
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 12910
  tmp___9 = gettext("   Link time: ");
#line 12910
  printf((char const   */* __restrict  */)tmp___9);
#line 12911
  tmp___10 = (*byte_get)((unsigned char *)pnote->descdata, 8);
#line 12911
  print_vms_time((bfd_int64_t )tmp___10);
#line 12913
  printf((char const   */* __restrict  */)"\n");
  }
#line 12914
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 12916
  tmp___11 = gettext("   Patch time: ");
#line 12916
  printf((char const   */* __restrict  */)tmp___11);
#line 12917
  tmp___12 = (*byte_get)((unsigned char *)pnote->descdata, 8);
#line 12917
  print_vms_time((bfd_int64_t )tmp___12);
#line 12919
  printf((char const   */* __restrict  */)"\n");
  }
#line 12920
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 12922
  tmp___13 = (*byte_get)((unsigned char *)pnote->descdata + 4, 4);
#line 12922
  tmp___14 = (*byte_get)((unsigned char *)pnote->descdata, 4);
#line 12922
  tmp___15 = gettext("   Major id: %u,  minor id: %u\n");
#line 12922
  printf((char const   */* __restrict  */)tmp___15, (unsigned int )tmp___14, (unsigned int )tmp___13);
#line 12925
  tmp___16 = gettext("   Last modified  : ");
#line 12925
  printf((char const   */* __restrict  */)tmp___16);
#line 12926
  tmp___17 = (*byte_get)((unsigned char *)pnote->descdata + 8, 8);
#line 12926
  print_vms_time((bfd_int64_t )tmp___17);
#line 12928
  tmp___18 = gettext("\n   Link flags  : ");
#line 12928
  printf((char const   */* __restrict  */)tmp___18);
#line 12929
  tmp___19 = (*byte_get)((unsigned char *)pnote->descdata + 16, 8);
#line 12929
  printf((char const   */* __restrict  */)"0x%016lx\n", (bfd_vma )tmp___19);
#line 12931
  tmp___20 = (*byte_get)((unsigned char *)pnote->descdata + 24, 4);
#line 12931
  tmp___21 = gettext("   Header flags: 0x%08x\n");
#line 12931
  printf((char const   */* __restrict  */)tmp___21, (unsigned int )tmp___20);
#line 12933
  tmp___22 = gettext("   Image id    : %s\n");
#line 12933
  printf((char const   */* __restrict  */)tmp___22, pnote->descdata + 32);
  }
#line 12934
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 12937
  tmp___23 = gettext("    Image name: %s\n");
#line 12937
  printf((char const   */* __restrict  */)tmp___23, pnote->descdata);
  }
#line 12938
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 12940
  tmp___24 = gettext("    Global symbol table name: %s\n");
#line 12940
  printf((char const   */* __restrict  */)tmp___24, pnote->descdata);
  }
#line 12941
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 12943
  tmp___25 = gettext("    Image id: %s\n");
#line 12943
  printf((char const   */* __restrict  */)tmp___25, pnote->descdata);
  }
#line 12944
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 12946
  tmp___26 = gettext("    Linker id: %s\n");
#line 12946
  printf((char const   */* __restrict  */)tmp___26, pnote->descdata);
  }
#line 12947
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 12949
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 12951
  return (1);
}
}
#line 12959 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_note(Elf_Internal_Note *pnote ) 
{ 
  char const   *name___0 ;
  char const   *tmp___0 ;
  char const   *nt ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 12962
  if (pnote->namesz) {
#line 12962
    tmp___0 = (char const   *)pnote->namedata;
  } else {
#line 12962
    tmp___0 = "(NONE)";
  }
#line 12962
  name___0 = tmp___0;
#line 12965
  if (pnote->namesz == 0UL) {
    {
#line 12968
    nt = get_note_type((unsigned int )pnote->type);
    }
  } else {
    {
#line 12970
    tmp___5 = strncmp((char const   *)pnote->namedata, "GNU", sizeof("GNU") - 1UL);
    }
#line 12970
    if (tmp___5 == 0) {
      {
#line 12972
      nt = get_gnu_elf_note_type((unsigned int )pnote->type);
      }
    } else {
      {
#line 12974
      tmp___4 = strncmp((char const   *)pnote->namedata, "NetBSD-CORE", sizeof("NetBSD-CORE") - 1UL);
      }
#line 12974
      if (tmp___4 == 0) {
        {
#line 12976
        nt = get_netbsd_elfcore_note_type((unsigned int )pnote->type);
        }
      } else {
        {
#line 12978
        tmp___3 = strncmp((char const   *)pnote->namedata, "SPU/", (size_t )4);
        }
#line 12978
        if (tmp___3 == 0) {
#line 12981
          nt = (char const   *)(pnote->namedata + 4);
#line 12982
          name___0 = "SPU";
        } else {
          {
#line 12985
          tmp___2 = strncmp((char const   *)pnote->namedata, "IPF/VMS", sizeof("IPF/VMS") - 1UL);
          }
#line 12985
          if (tmp___2 == 0) {
            {
#line 12987
            nt = get_ia64_vms_note_type((unsigned int )pnote->type);
            }
          } else {
            {
#line 12989
            tmp___1 = strncmp((char const   *)pnote->namedata, "stapsdt", sizeof("stapsdt") - 1UL);
            }
#line 12989
            if (tmp___1 == 0) {
              {
#line 12990
              nt = get_stapsdt_note_type((unsigned int )pnote->type);
              }
            } else {
              {
#line 12995
              nt = get_note_type((unsigned int )pnote->type);
              }
            }
          }
        }
      }
    }
  }
  {
#line 12997
  printf((char const   */* __restrict  */)"  %-20s 0x%08lx\t%s\n", name___0, pnote->descsz,
         nt);
#line 12999
  tmp___11 = strncmp((char const   *)pnote->namedata, "IPF/VMS", sizeof("IPF/VMS") - 1UL);
  }
#line 12999
  if (tmp___11 == 0) {
    {
#line 13000
    tmp___6 = print_ia64_vms_note(pnote);
    }
#line 13000
    return (tmp___6);
  } else {
    {
#line 13001
    tmp___10 = strncmp((char const   *)pnote->namedata, "GNU", sizeof("GNU") - 1UL);
    }
#line 13001
    if (tmp___10 == 0) {
      {
#line 13002
      tmp___7 = print_gnu_note(pnote);
      }
#line 13002
      return (tmp___7);
    } else {
      {
#line 13003
      tmp___9 = strncmp((char const   *)pnote->namedata, "stapsdt", sizeof("stapsdt") - 1UL);
      }
#line 13003
      if (tmp___9 == 0) {
        {
#line 13004
        tmp___8 = print_stapsdt_note(pnote);
        }
#line 13004
        return (tmp___8);
      } else {
#line 13006
        return (1);
      }
    }
  }
}
}
#line 13010 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_corefile_note_segment(FILE *file , bfd_vma offset , bfd_vma length ) 
{ 
  Elf_External_Note *pnotes ;
  Elf_External_Note *external ;
  int res___0 ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  Elf_External_Note *next ;
  Elf_Internal_Note inote ;
  char *temp ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  Elf64_External_VMS_Note *vms_external ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 13015
  res___0 = 1;
#line 13017
  if (length <= 0UL) {
#line 13018
    return (0);
  }
  {
#line 13020
  tmp___0 = gettext("notes");
#line 13020
  tmp___1 = get_data((void *)0, file, (long )offset, (size_t )1, length, (char const   *)tmp___0);
#line 13020
  pnotes = (Elf_External_Note *)tmp___1;
  }
#line 13022
  if ((unsigned long )pnotes == (unsigned long )((void *)0)) {
#line 13023
    return (0);
  }
  {
#line 13025
  external = pnotes;
#line 13027
  tmp___2 = gettext("\nNotes at offset 0x%08lx with length 0x%08lx:\n");
#line 13027
  printf((char const   */* __restrict  */)tmp___2, offset, length);
#line 13029
  tmp___3 = gettext("Data size");
#line 13029
  tmp___4 = gettext("Owner");
#line 13029
  tmp___5 = gettext("  %-20s %10s\tDescription\n");
#line 13029
  printf((char const   */* __restrict  */)tmp___5, tmp___4, tmp___3);
  }
  {
#line 13031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13031
    if (! ((unsigned long )external < (unsigned long )((Elf_External_Note *)((char *)pnotes + length)))) {
#line 13031
      goto while_break;
    }
    {
#line 13035
    temp = (char *)((void *)0);
#line 13037
    tmp___12 = is_ia64_vms();
    }
#line 13037
    if (tmp___12) {
      {
#line 13052
      vms_external = (Elf64_External_VMS_Note *)external;
#line 13053
      tmp___9 = (*byte_get)(vms_external->type, (int )sizeof(vms_external->type));
#line 13053
      inote.type = (unsigned long )tmp___9;
#line 13054
      tmp___10 = (*byte_get)(vms_external->namesz, (int )sizeof(vms_external->namesz));
#line 13054
      inote.namesz = (unsigned long )tmp___10;
#line 13055
      inote.namedata = vms_external->name;
#line 13056
      tmp___11 = (*byte_get)(vms_external->descsz, (int )sizeof(vms_external->descsz));
#line 13056
      inote.descsz = (unsigned long )tmp___11;
#line 13057
      inote.descdata = inote.namedata + (((inote.namesz + (1UL << 3)) - 1UL) & (0xffffffffffffffffUL << 3));
#line 13058
      inote.descpos = offset + (bfd_vma )(inote.descdata - (char *)pnotes);
#line 13060
      next = (Elf_External_Note *)(inote.descdata + (((inote.descsz + (1UL << 3)) - 1UL) & (0xffffffffffffffffUL << 3)));
      }
    } else {
      {
#line 13039
      tmp___6 = (*byte_get)(external->type, (int )sizeof(external->type));
#line 13039
      inote.type = (unsigned long )tmp___6;
#line 13040
      tmp___7 = (*byte_get)(external->namesz, (int )sizeof(external->namesz));
#line 13040
      inote.namesz = (unsigned long )tmp___7;
#line 13041
      inote.namedata = external->name;
#line 13042
      tmp___8 = (*byte_get)(external->descsz, (int )sizeof(external->descsz));
#line 13042
      inote.descsz = (unsigned long )tmp___8;
#line 13043
      inote.descdata = inote.namedata + (((inote.namesz + (1UL << 2)) - 1UL) & (0xffffffffffffffffUL << 2));
#line 13044
      inote.descpos = offset + (bfd_vma )(inote.descdata - (char *)pnotes);
#line 13046
      next = (Elf_External_Note *)(inote.descdata + (((inote.descsz + (1UL << 2)) - 1UL) & (0xffffffffffffffffUL << 2)));
      }
    }
#line 13064
    if ((unsigned long )((char *)next) > (unsigned long )((char *)pnotes + length)) {
      {
#line 13067
      tmp___13 = gettext("corrupt note found at offset %lx into core notes\n");
#line 13067
      warn((char const   *)tmp___13, (unsigned long )((char *)external - (char *)pnotes));
#line 13069
      tmp___14 = gettext(" type: %lx, namesize: %08lx, descsize: %08lx\n");
#line 13069
      warn((char const   *)tmp___14, inote.type, inote.namesz, inote.descsz);
      }
#line 13071
      goto while_break;
    } else
#line 13064
    if ((unsigned long )((char *)next) < (unsigned long )((char *)pnotes)) {
      {
#line 13067
      tmp___13 = gettext("corrupt note found at offset %lx into core notes\n");
#line 13067
      warn((char const   *)tmp___13, (unsigned long )((char *)external - (char *)pnotes));
#line 13069
      tmp___14 = gettext(" type: %lx, namesize: %08lx, descsize: %08lx\n");
#line 13069
      warn((char const   *)tmp___14, inote.type, inote.namesz, inote.descsz);
      }
#line 13071
      goto while_break;
    }
#line 13074
    external = next;
#line 13077
    if ((unsigned long )(inote.namedata + inote.namesz) > (unsigned long )((char *)pnotes + length)) {
      {
#line 13080
      tmp___15 = gettext("corrupt note found at offset %lx into core notes\n");
#line 13080
      warn((char const   *)tmp___15, (unsigned long )((char *)external - (char *)pnotes));
#line 13082
      tmp___16 = gettext(" type: %lx, namesize: %08lx, descsize: %08lx\n");
#line 13082
      warn((char const   *)tmp___16, inote.type, inote.namesz, inote.descsz);
      }
#line 13084
      goto while_break;
    } else
#line 13077
    if ((unsigned long )(inote.namedata + inote.namesz) < (unsigned long )inote.namedata) {
      {
#line 13080
      tmp___15 = gettext("corrupt note found at offset %lx into core notes\n");
#line 13080
      warn((char const   *)tmp___15, (unsigned long )((char *)external - (char *)pnotes));
#line 13082
      tmp___16 = gettext(" type: %lx, namesize: %08lx, descsize: %08lx\n");
#line 13082
      warn((char const   *)tmp___16, inote.type, inote.namesz, inote.descsz);
      }
#line 13084
      goto while_break;
    }
#line 13091
    if ((int )*(inote.namedata + (inote.namesz - 1UL)) != 0) {
      {
#line 13093
      tmp___17 = malloc(inote.namesz + 1UL);
#line 13093
      temp = (char *)tmp___17;
      }
#line 13095
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        {
#line 13097
        tmp___18 = gettext("Out of memory\n");
#line 13097
        error((char const   *)tmp___18);
#line 13098
        res___0 = 0;
        }
#line 13099
        goto while_break;
      }
      {
#line 13102
      strncpy((char */* __restrict  */)temp, (char const   */* __restrict  */)inote.namedata,
              inote.namesz);
#line 13103
      *(temp + inote.namesz) = (char)0;
#line 13106
      inote.namedata = temp;
      }
    }
    {
#line 13109
    tmp___19 = process_note(& inote);
#line 13109
    res___0 &= tmp___19;
    }
#line 13111
    if ((unsigned long )temp != (unsigned long )((void *)0)) {
      {
#line 13113
      free((void *)temp);
#line 13114
      temp = (char *)((void *)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 13118
  free((void *)pnotes);
  }
#line 13120
  return (res___0);
}
}
#line 13123 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_corefile_note_segments(FILE *file ) 
{ 
  Elf_Internal_Phdr *segment ;
  unsigned int i ;
  int res___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 13128
  res___0 = 1;
#line 13130
  tmp___0 = get_program_headers(file);
  }
#line 13130
  if (! tmp___0) {
#line 13131
    return (0);
  }
#line 13133
  i = 0U;
#line 13133
  segment = program_headers;
  {
#line 13133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13133
    if (! (i < elf_header.e_phnum)) {
#line 13133
      goto while_break;
    }
#line 13137
    if (segment->p_type == 4UL) {
      {
#line 13138
      tmp___1 = process_corefile_note_segment(file, segment->p_offset, segment->p_filesz);
#line 13138
      res___0 &= tmp___1;
      }
    }
#line 13133
    i ++;
#line 13133
    segment ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13143
  return (res___0);
}
}
#line 13146 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_note_sections(FILE *file ) 
{ 
  Elf_Internal_Shdr *section ;
  unsigned long i ;
  int res___0 ;
  int tmp___0 ;

  {
#line 13151
  res___0 = 1;
#line 13153
  i = 0UL;
#line 13153
  section = section_headers;
  {
#line 13153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13153
    if (i < (unsigned long )elf_header.e_shnum) {
#line 13153
      if (! ((unsigned long )section != (unsigned long )((void *)0))) {
#line 13153
        goto while_break;
      }
    } else {
#line 13153
      goto while_break;
    }
#line 13156
    if (section->sh_type == 7U) {
      {
#line 13157
      tmp___0 = process_corefile_note_segment(file, (bfd_vma )section->sh_offset,
                                              section->sh_size);
#line 13157
      res___0 &= tmp___0;
      }
    }
#line 13153
    i ++;
#line 13153
    section ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 13161
  return (res___0);
}
}
#line 13164 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_notes(FILE *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 13168
  if (! do_notes) {
#line 13169
    return (1);
  }
#line 13171
  if ((int )elf_header.e_type != 4) {
    {
#line 13172
    tmp___0 = process_note_sections(file);
    }
#line 13172
    return (tmp___0);
  }
#line 13175
  if (elf_header.e_phnum > 0U) {
    {
#line 13176
    tmp___1 = process_corefile_note_segments(file);
    }
#line 13176
    return (tmp___1);
  }
  {
#line 13178
  tmp___2 = gettext("No note segments present in the core file.\n");
#line 13178
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 13179
  return (1);
}
}
#line 13182 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_arch_specific(FILE *file ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 13185
  if (! do_arch) {
#line 13186
    return (1);
  }
  {
#line 13190
  if ((int )elf_header.e_machine == 40) {
#line 13190
    goto case_40;
  }
#line 13193
  if ((int )elf_header.e_machine == 10) {
#line 13193
    goto case_10;
  }
#line 13193
  if ((int )elf_header.e_machine == 8) {
#line 13193
    goto case_10;
  }
#line 13196
  if ((int )elf_header.e_machine == 20) {
#line 13196
    goto case_20;
  }
#line 13201
  if ((int )elf_header.e_machine == 43) {
#line 13201
    goto case_43;
  }
#line 13201
  if ((int )elf_header.e_machine == 18) {
#line 13201
    goto case_43;
  }
#line 13201
  if ((int )elf_header.e_machine == 2) {
#line 13201
    goto case_43;
  }
#line 13204
  if ((int )elf_header.e_machine == 140) {
#line 13204
    goto case_140;
  }
#line 13207
  goto switch_default;
  case_40: /* CIL Label */ 
  {
#line 13191
  tmp___0 = process_arm_specific(file);
  }
#line 13191
  return (tmp___0);
  case_10: /* CIL Label */ 
  case_8: /* CIL Label */ 
  {
#line 13194
  tmp___1 = process_mips_specific(file);
  }
#line 13194
  return (tmp___1);
#line 13195
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 13197
  tmp___2 = process_power_specific(file);
  }
#line 13197
  return (tmp___2);
#line 13198
  goto switch_break;
  case_43: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 13202
  tmp___3 = process_sparc_specific(file);
  }
#line 13202
  return (tmp___3);
#line 13203
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 13205
  tmp___4 = process_tic6x_specific(file);
  }
#line 13205
  return (tmp___4);
#line 13206
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 13208
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 13210
  return (1);
}
}
#line 13213 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int get_file_header(FILE *file ) 
{ 
  size_t tmp___0 ;
  Elf32_External_Ehdr ehdr32 ;
  size_t tmp___1 ;
  elf_vma tmp___2 ;
  elf_vma tmp___3 ;
  elf_vma tmp___4 ;
  elf_vma tmp___5 ;
  elf_vma tmp___6 ;
  elf_vma tmp___7 ;
  elf_vma tmp___8 ;
  elf_vma tmp___9 ;
  elf_vma tmp___10 ;
  elf_vma tmp___11 ;
  elf_vma tmp___12 ;
  elf_vma tmp___13 ;
  elf_vma tmp___14 ;
  Elf64_External_Ehdr ehdr64 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  elf_vma tmp___17 ;
  elf_vma tmp___18 ;
  elf_vma tmp___19 ;
  elf_vma tmp___20 ;
  elf_vma tmp___21 ;
  elf_vma tmp___22 ;
  elf_vma tmp___23 ;
  elf_vma tmp___24 ;
  elf_vma tmp___25 ;
  elf_vma tmp___26 ;
  elf_vma tmp___27 ;
  elf_vma tmp___28 ;
  elf_vma tmp___29 ;

  {
  {
#line 13217
  tmp___0 = fread((void */* __restrict  */)(elf_header.e_ident), (size_t )16, (size_t )1,
                  (FILE */* __restrict  */)file);
  }
#line 13217
  if (tmp___0 != 1UL) {
#line 13218
    return (0);
  }
  {
#line 13229
  if ((int )elf_header.e_ident[5] == 2) {
#line 13229
    goto case_2;
  }
#line 13223
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 13226
  byte_get = & byte_get_little_endian;
#line 13227
  byte_put = & byte_put_little_endian;
#line 13228
  goto switch_break;
  case_2: /* CIL Label */ 
#line 13230
  byte_get = & byte_get_big_endian;
#line 13231
  byte_put = & byte_put_big_endian;
#line 13232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 13236
  is_32bit_elf = (int )elf_header.e_ident[4] != 2;
#line 13239
  if (is_32bit_elf) {
    {
#line 13243
    tmp___1 = fread((void */* __restrict  */)(ehdr32.e_type), sizeof(ehdr32) - 16UL,
                    (size_t )1, (FILE */* __restrict  */)file);
    }
#line 13243
    if (tmp___1 != 1UL) {
#line 13244
      return (0);
    }
    {
#line 13246
    tmp___2 = (*byte_get)(ehdr32.e_type, (int )sizeof(ehdr32.e_type));
#line 13246
    elf_header.e_type = (unsigned short )tmp___2;
#line 13247
    tmp___3 = (*byte_get)(ehdr32.e_machine, (int )sizeof(ehdr32.e_machine));
#line 13247
    elf_header.e_machine = (unsigned short )tmp___3;
#line 13248
    tmp___4 = (*byte_get)(ehdr32.e_version, (int )sizeof(ehdr32.e_version));
#line 13248
    elf_header.e_version = (unsigned long )tmp___4;
#line 13249
    tmp___5 = (*byte_get)(ehdr32.e_entry, (int )sizeof(ehdr32.e_entry));
#line 13249
    elf_header.e_entry = (bfd_vma )tmp___5;
#line 13250
    tmp___6 = (*byte_get)(ehdr32.e_phoff, (int )sizeof(ehdr32.e_phoff));
#line 13250
    elf_header.e_phoff = (bfd_size_type )tmp___6;
#line 13251
    tmp___7 = (*byte_get)(ehdr32.e_shoff, (int )sizeof(ehdr32.e_shoff));
#line 13251
    elf_header.e_shoff = (bfd_size_type )tmp___7;
#line 13252
    tmp___8 = (*byte_get)(ehdr32.e_flags, (int )sizeof(ehdr32.e_flags));
#line 13252
    elf_header.e_flags = (unsigned long )tmp___8;
#line 13253
    tmp___9 = (*byte_get)(ehdr32.e_ehsize, (int )sizeof(ehdr32.e_ehsize));
#line 13253
    elf_header.e_ehsize = (unsigned int )tmp___9;
#line 13254
    tmp___10 = (*byte_get)(ehdr32.e_phentsize, (int )sizeof(ehdr32.e_phentsize));
#line 13254
    elf_header.e_phentsize = (unsigned int )tmp___10;
#line 13255
    tmp___11 = (*byte_get)(ehdr32.e_phnum, (int )sizeof(ehdr32.e_phnum));
#line 13255
    elf_header.e_phnum = (unsigned int )tmp___11;
#line 13256
    tmp___12 = (*byte_get)(ehdr32.e_shentsize, (int )sizeof(ehdr32.e_shentsize));
#line 13256
    elf_header.e_shentsize = (unsigned int )tmp___12;
#line 13257
    tmp___13 = (*byte_get)(ehdr32.e_shnum, (int )sizeof(ehdr32.e_shnum));
#line 13257
    elf_header.e_shnum = (unsigned int )tmp___13;
#line 13258
    tmp___14 = (*byte_get)(ehdr32.e_shstrndx, (int )sizeof(ehdr32.e_shstrndx));
#line 13258
    elf_header.e_shstrndx = (unsigned int )tmp___14;
    }
  } else {
#line 13268
    if (sizeof(bfd_vma ) < 8UL) {
      {
#line 13270
      tmp___15 = gettext("This instance of readelf has been built without support for a\n64 bit data type and so it cannot read 64 bit ELF files.\n");
#line 13270
      error((char const   *)tmp___15);
      }
#line 13272
      return (0);
    }
    {
#line 13275
    tmp___16 = fread((void */* __restrict  */)(ehdr64.e_type), sizeof(ehdr64) - 16UL,
                     (size_t )1, (FILE */* __restrict  */)file);
    }
#line 13275
    if (tmp___16 != 1UL) {
#line 13276
      return (0);
    }
    {
#line 13278
    tmp___17 = (*byte_get)(ehdr64.e_type, (int )sizeof(ehdr64.e_type));
#line 13278
    elf_header.e_type = (unsigned short )tmp___17;
#line 13279
    tmp___18 = (*byte_get)(ehdr64.e_machine, (int )sizeof(ehdr64.e_machine));
#line 13279
    elf_header.e_machine = (unsigned short )tmp___18;
#line 13280
    tmp___19 = (*byte_get)(ehdr64.e_version, (int )sizeof(ehdr64.e_version));
#line 13280
    elf_header.e_version = (unsigned long )tmp___19;
#line 13281
    tmp___20 = (*byte_get)(ehdr64.e_entry, (int )sizeof(ehdr64.e_entry));
#line 13281
    elf_header.e_entry = (bfd_vma )tmp___20;
#line 13282
    tmp___21 = (*byte_get)(ehdr64.e_phoff, (int )sizeof(ehdr64.e_phoff));
#line 13282
    elf_header.e_phoff = (bfd_size_type )tmp___21;
#line 13283
    tmp___22 = (*byte_get)(ehdr64.e_shoff, (int )sizeof(ehdr64.e_shoff));
#line 13283
    elf_header.e_shoff = (bfd_size_type )tmp___22;
#line 13284
    tmp___23 = (*byte_get)(ehdr64.e_flags, (int )sizeof(ehdr64.e_flags));
#line 13284
    elf_header.e_flags = (unsigned long )tmp___23;
#line 13285
    tmp___24 = (*byte_get)(ehdr64.e_ehsize, (int )sizeof(ehdr64.e_ehsize));
#line 13285
    elf_header.e_ehsize = (unsigned int )tmp___24;
#line 13286
    tmp___25 = (*byte_get)(ehdr64.e_phentsize, (int )sizeof(ehdr64.e_phentsize));
#line 13286
    elf_header.e_phentsize = (unsigned int )tmp___25;
#line 13287
    tmp___26 = (*byte_get)(ehdr64.e_phnum, (int )sizeof(ehdr64.e_phnum));
#line 13287
    elf_header.e_phnum = (unsigned int )tmp___26;
#line 13288
    tmp___27 = (*byte_get)(ehdr64.e_shentsize, (int )sizeof(ehdr64.e_shentsize));
#line 13288
    elf_header.e_shentsize = (unsigned int )tmp___27;
#line 13289
    tmp___28 = (*byte_get)(ehdr64.e_shnum, (int )sizeof(ehdr64.e_shnum));
#line 13289
    elf_header.e_shnum = (unsigned int )tmp___28;
#line 13290
    tmp___29 = (*byte_get)(ehdr64.e_shstrndx, (int )sizeof(ehdr64.e_shstrndx));
#line 13290
    elf_header.e_shstrndx = (unsigned int )tmp___29;
    }
  }
#line 13293
  if (elf_header.e_shoff) {
#line 13297
    if (is_32bit_elf) {
      {
#line 13298
      get_32bit_section_headers(file, 1U);
      }
    } else {
      {
#line 13300
      get_64bit_section_headers(file, 1U);
      }
    }
  }
#line 13303
  return (1);
}
}
#line 13310 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_object(char *file_name , FILE *file ) 
{ 
  unsigned int i ;
  char *tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct group_list *g ;
  struct group_list *next ;

  {
  {
#line 13315
  tmp___1 = get_file_header(file);
  }
#line 13315
  if (! tmp___1) {
    {
#line 13317
    tmp___0 = gettext("%s: Failed to read file header\n");
#line 13317
    error((char const   *)tmp___0, file_name);
    }
#line 13318
    return (1);
  }
#line 13322
  i = (unsigned int )(sizeof(version_info) / sizeof(version_info[0]));
  {
#line 13322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13322
    tmp___2 = i;
#line 13322
    i --;
#line 13322
    if (! tmp___2) {
#line 13322
      goto while_break;
    }
#line 13323
    version_info[i] = (bfd_vma )0;
  }
  while_break: /* CIL Label */ ;
  }
#line 13325
  i = (unsigned int )(sizeof(dynamic_info) / sizeof(dynamic_info[0]));
  {
#line 13325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 13325
    tmp___3 = i;
#line 13325
    i --;
#line 13325
    if (! tmp___3) {
#line 13325
      goto while_break___0;
    }
#line 13326
    dynamic_info[i] = (bfd_vma )0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 13327
  dynamic_info_DT_GNU_HASH = (bfd_vma )0;
#line 13330
  if (show_name) {
    {
#line 13331
    tmp___4 = gettext("\nFile: %s\n");
#line 13331
    printf((char const   */* __restrict  */)tmp___4, file_name);
    }
  }
#line 13337
  if (num_dump_sects > num_cmdline_dump_sects) {
    {
#line 13338
    memset((void *)dump_sects, 0, (unsigned long )num_dump_sects * sizeof(*dump_sects));
    }
  }
#line 13340
  if (num_cmdline_dump_sects > 0U) {
#line 13342
    if (num_dump_sects == 0U) {
      {
#line 13344
      request_dump_bynumber(num_cmdline_dump_sects, (dump_type )0);
      }
    }
#line 13346
    if (! (num_dump_sects >= num_cmdline_dump_sects)) {
      {
#line 13346
      __assert_fail("num_dump_sects >= num_cmdline_dump_sects", "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c",
                    13346U, "process_object");
      }
    }
    {
#line 13347
    memcpy((void */* __restrict  */)dump_sects, (void const   */* __restrict  */)cmdline_dump_sects,
           (unsigned long )num_cmdline_dump_sects * sizeof(*dump_sects));
    }
  }
  {
#line 13351
  tmp___5 = process_file_header();
  }
#line 13351
  if (! tmp___5) {
#line 13352
    return (1);
  }
  {
#line 13354
  tmp___6 = process_section_headers(file);
  }
#line 13354
  if (! tmp___6) {
#line 13358
    do_arch = 0;
#line 13358
    do_dump = do_arch;
#line 13358
    do_version = do_dump;
#line 13358
    do_unwind = do_version;
#line 13360
    if (! do_using_dynamic) {
#line 13361
      do_reloc = 0;
#line 13361
      do_dyn_syms = do_reloc;
#line 13361
      do_syms = do_dyn_syms;
    }
  }
  {
#line 13364
  tmp___7 = process_section_groups(file);
  }
#line 13364
  if (! tmp___7) {
#line 13367
    do_unwind = 0;
  }
  {
#line 13370
  tmp___8 = process_program_headers(file);
  }
#line 13370
  if (tmp___8) {
    {
#line 13371
    process_dynamic_section(file);
    }
  }
  {
#line 13373
  process_relocs(file);
#line 13375
  process_unwind(file);
#line 13377
  process_symbol_table(file);
#line 13379
  process_syminfo(file);
#line 13381
  process_version_sections(file);
#line 13383
  process_section_contents(file);
#line 13385
  process_notes(file);
#line 13387
  process_gnu_liblist(file);
#line 13389
  process_arch_specific(file);
  }
#line 13391
  if (program_headers) {
    {
#line 13393
    free((void *)program_headers);
#line 13394
    program_headers = (Elf_Internal_Phdr *)((void *)0);
    }
  }
#line 13397
  if (section_headers) {
    {
#line 13399
    free((void *)section_headers);
#line 13400
    section_headers = (Elf_Internal_Shdr *)((void *)0);
    }
  }
#line 13403
  if (string_table) {
    {
#line 13405
    free((void *)string_table);
#line 13406
    string_table = (char *)((void *)0);
#line 13407
    string_table_length = 0UL;
    }
  }
#line 13410
  if (dynamic_strings) {
    {
#line 13412
    free((void *)dynamic_strings);
#line 13413
    dynamic_strings = (char *)((void *)0);
#line 13414
    dynamic_strings_length = 0UL;
    }
  }
#line 13417
  if (dynamic_symbols) {
    {
#line 13419
    free((void *)dynamic_symbols);
#line 13420
    dynamic_symbols = (Elf_Internal_Sym *)((void *)0);
#line 13421
    num_dynamic_syms = 0UL;
    }
  }
#line 13424
  if (dynamic_syminfo) {
    {
#line 13426
    free((void *)dynamic_syminfo);
#line 13427
    dynamic_syminfo = (Elf_Internal_Syminfo *)((void *)0);
    }
  }
#line 13430
  if (dynamic_section) {
    {
#line 13432
    free((void *)dynamic_section);
#line 13433
    dynamic_section = (Elf_Internal_Dyn *)((void *)0);
    }
  }
#line 13436
  if (section_headers_groups) {
    {
#line 13438
    free((void *)section_headers_groups);
#line 13439
    section_headers_groups = (struct group **)((void *)0);
    }
  }
#line 13442
  if (section_groups) {
#line 13447
    i = 0U;
    {
#line 13447
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 13447
      if (! ((size_t )i < group_count)) {
#line 13447
        goto while_break___1;
      }
#line 13449
      g = (section_groups + i)->root;
      {
#line 13449
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 13449
        if (! ((unsigned long )g != (unsigned long )((void *)0))) {
#line 13449
          goto while_break___2;
        }
        {
#line 13451
        next = g->next;
#line 13452
        free((void *)g);
#line 13449
        g = next;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 13447
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 13456
    free((void *)section_groups);
#line 13457
    section_groups = (struct group *)((void *)0);
    }
  }
  {
#line 13460
  free_debug_memory();
  }
#line 13462
  return (0);
}
}
#line 13468 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_archive(char *file_name , FILE *file , bfd_boolean is_thin_archive ) 
{ 
  struct archive_info arch ;
  struct archive_info nested_arch ;
  size_t got ;
  int ret ;
  int tmp___0 ;
  char *tmp___1 ;
  unsigned int i ;
  unsigned int l ;
  unsigned long current_pos ;
  char *tmp___2 ;
  long tmp___3 ;
  char *member_name ;
  char *qualified_name ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *name___0 ;
  size_t namelen ;
  char *qualified_name___0 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  FILE *member_file ;
  char *member_file_name ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;

  {
  {
#line 13476
  show_name = 1;
#line 13479
  arch.file_name = (char *)((void *)0);
#line 13480
  arch.file = (FILE *)((void *)0);
#line 13481
  arch.index_array = (elf_vma *)((void *)0);
#line 13482
  arch.sym_table = (char *)((void *)0);
#line 13483
  arch.longnames = (char *)((void *)0);
#line 13488
  nested_arch.file_name = (char *)((void *)0);
#line 13489
  nested_arch.file = (FILE *)((void *)0);
#line 13490
  nested_arch.index_array = (elf_vma *)((void *)0);
#line 13491
  nested_arch.sym_table = (char *)((void *)0);
#line 13492
  nested_arch.longnames = (char *)((void *)0);
#line 13494
  tmp___0 = setup_archive(& arch, (char const   *)file_name, file, is_thin_archive,
                          do_archive_index);
  }
#line 13494
  if (tmp___0 != 0) {
#line 13496
    ret = 1;
#line 13497
    goto out;
  }
#line 13500
  if (do_archive_index) {
#line 13502
    if ((unsigned long )arch.sym_table == (unsigned long )((void *)0)) {
      {
#line 13503
      tmp___1 = gettext("%s: unable to dump the index as none was found\n");
#line 13503
      error((char const   *)tmp___1, file_name);
      }
    } else {
      {
#line 13509
      tmp___2 = gettext("Index of archive %s: (%ld entries, 0x%lx bytes in the symbol table)\n");
#line 13509
      printf((char const   */* __restrict  */)tmp___2, file_name, (long )arch.index_num,
             arch.sym_size);
#line 13511
      tmp___3 = ftell(file);
#line 13511
      current_pos = (unsigned long )tmp___3;
#line 13513
      l = 0U;
#line 13513
      i = l;
      }
      {
#line 13513
      while (1) {
        while_continue: /* CIL Label */ ;
#line 13513
        if (! ((elf_vma )i < arch.index_num)) {
#line 13513
          goto while_break;
        }
#line 13515
        if (i == 0U) {
#line 13515
          goto _L;
        } else
#line 13515
        if (i > 0U) {
#line 13515
          if (*(arch.index_array + i) != *(arch.index_array + (i - 1U))) {
            _L: /* CIL Label */ 
            {
#line 13519
            member_name = get_archive_member_name_at(& arch, (unsigned long )*(arch.index_array + i),
                                                     & nested_arch);
            }
#line 13521
            if ((unsigned long )member_name != (unsigned long )((void *)0)) {
              {
#line 13523
              tmp___4 = make_qualified_name(& arch, & nested_arch, (char const   *)member_name);
#line 13523
              qualified_name = tmp___4;
              }
#line 13525
              if ((unsigned long )qualified_name != (unsigned long )((void *)0)) {
                {
#line 13527
                tmp___5 = gettext("Contents of binary %s at offset ");
#line 13527
                printf((char const   */* __restrict  */)tmp___5, qualified_name);
#line 13528
                print_vma((bfd_vma )*(arch.index_array + i), (print_mode )4);
#line 13529
                putchar('\n');
#line 13530
                free((void *)qualified_name);
                }
              }
            }
          }
        }
#line 13535
        if ((unsigned long )l >= arch.sym_size) {
          {
#line 13537
          tmp___6 = gettext("%s: end of the symbol table reached before the end of the index\n");
#line 13537
          error((char const   *)tmp___6, file_name);
          }
#line 13539
          goto while_break;
        }
        {
#line 13541
        printf((char const   */* __restrict  */)"\t%s\n", arch.sym_table + l);
#line 13542
        tmp___7 = strlen((char const   *)(arch.sym_table + l));
#line 13542
        l = (unsigned int )((size_t )l + (tmp___7 + 1UL));
#line 13513
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 13545
      if (arch.uses_64bit_indicies) {
#line 13546
        l = (l + 7U) & 4294967288U;
      } else {
#line 13548
        l += l & 1U;
      }
#line 13550
      if ((unsigned long )l < arch.sym_size) {
        {
#line 13551
        tmp___8 = gettext("%s: %ld bytes remain in the symbol table, but without corresponding entries in the index table\n");
#line 13551
        error((char const   *)tmp___8, file_name, arch.sym_size - (unsigned long )l);
        }
      }
      {
#line 13554
      tmp___10 = fseek(file, (long )current_pos, 0);
      }
#line 13554
      if (tmp___10 != 0) {
        {
#line 13556
        tmp___9 = gettext("%s: failed to seek back to start of object files in the archive\n");
#line 13556
        error((char const   *)tmp___9, file_name);
#line 13557
        ret = 1;
        }
#line 13558
        goto out;
      }
    }
#line 13562
    if (! do_dynamic) {
#line 13562
      if (! do_syms) {
#line 13562
        if (! do_reloc) {
#line 13562
          if (! do_unwind) {
#line 13562
            if (! do_sections) {
#line 13562
              if (! do_segments) {
#line 13562
                if (! do_header) {
#line 13562
                  if (! do_dump) {
#line 13562
                    if (! do_version) {
#line 13562
                      if (! do_histogram) {
#line 13562
                        if (! do_debugging) {
#line 13562
                          if (! do_arch) {
#line 13562
                            if (! do_notes) {
#line 13562
                              if (! do_section_groups) {
#line 13562
                                if (! do_dyn_syms) {
#line 13567
                                  ret = 0;
#line 13568
                                  goto out;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 13572
  ret = 0;
  {
#line 13574
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 13581
    tmp___12 = fseek(file, (long )arch.next_arhdr_offset, 0);
    }
#line 13581
    if (tmp___12 != 0) {
      {
#line 13583
      tmp___11 = gettext("%s: failed to seek to next archive header\n");
#line 13583
      error((char const   *)tmp___11, file_name);
      }
#line 13584
      return (1);
    }
    {
#line 13586
    got = fread((void */* __restrict  */)(& arch.arhdr), (size_t )1, sizeof(arch.arhdr),
                (FILE */* __restrict  */)file);
    }
#line 13587
    if (got != sizeof(arch.arhdr)) {
#line 13589
      if (got == 0UL) {
#line 13590
        goto while_break___0;
      }
      {
#line 13591
      tmp___13 = gettext("%s: failed to read archive header\n");
#line 13591
      error((char const   *)tmp___13, file_name);
#line 13592
      ret = 1;
      }
#line 13593
      goto while_break___0;
    }
    {
#line 13595
    tmp___15 = memcmp((void const   *)(arch.arhdr.ar_fmag), (void const   *)"`\n",
                      (size_t )2);
    }
#line 13595
    if (tmp___15 != 0) {
      {
#line 13597
      tmp___14 = gettext("%s: did not find a valid archive header\n");
#line 13597
      error((char const   *)tmp___14, arch.file_name);
#line 13598
      ret = 1;
      }
#line 13599
      goto while_break___0;
    }
    {
#line 13602
    arch.next_arhdr_offset += sizeof(arch.arhdr);
#line 13604
    archive_file_size = strtoul((char const   */* __restrict  */)(arch.arhdr.ar_size),
                                (char **/* __restrict  */)((void *)0), 10);
    }
#line 13605
    if (archive_file_size & 1UL) {
#line 13606
      archive_file_size ++;
    }
    {
#line 13608
    name___0 = get_archive_member_name(& arch, & nested_arch);
    }
#line 13609
    if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
      {
#line 13611
      tmp___16 = gettext("%s: bad archive file name\n");
#line 13611
      error((char const   *)tmp___16, file_name);
#line 13612
      ret = 1;
      }
#line 13613
      goto while_break___0;
    }
    {
#line 13615
    namelen = strlen((char const   *)name___0);
#line 13617
    qualified_name___0 = make_qualified_name(& arch, & nested_arch, (char const   *)name___0);
    }
#line 13618
    if ((unsigned long )qualified_name___0 == (unsigned long )((void *)0)) {
      {
#line 13620
      tmp___17 = gettext("%s: bad archive file name\n");
#line 13620
      error((char const   *)tmp___17, file_name);
#line 13621
      ret = 1;
      }
#line 13622
      goto while_break___0;
    }
#line 13625
    if (is_thin_archive) {
#line 13625
      if (arch.nested_member_origin == 0UL) {
        {
#line 13629
        tmp___18 = adjust_relative_path((char const   *)file_name, (char const   *)name___0,
                                        (int )namelen);
#line 13629
        member_file_name = tmp___18;
        }
#line 13630
        if ((unsigned long )member_file_name == (unsigned long )((void *)0)) {
#line 13632
          ret = 1;
#line 13633
          goto while_break___0;
        }
        {
#line 13636
        member_file = fopen((char const   */* __restrict  */)member_file_name, (char const   */* __restrict  */)"rb");
        }
#line 13637
        if ((unsigned long )member_file == (unsigned long )((void *)0)) {
          {
#line 13639
          tmp___19 = gettext("Input file \'%s\' is not readable.\n");
#line 13639
          error((char const   *)tmp___19, member_file_name);
#line 13640
          free((void *)member_file_name);
#line 13641
          ret = 1;
          }
#line 13642
          goto while_break___0;
        }
        {
#line 13645
        archive_file_offset = (long )arch.nested_member_origin;
#line 13647
        tmp___20 = process_object(qualified_name___0, member_file);
#line 13647
        ret |= tmp___20;
#line 13649
        fclose(member_file);
#line 13650
        free((void *)member_file_name);
        }
      } else {
#line 13625
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 13652
    if (is_thin_archive) {
      {
#line 13655
      archive_file_offset = (long )(arch.nested_member_origin + sizeof(arch.arhdr));
#line 13659
      tmp___22 = fseek(nested_arch.file, archive_file_offset, 0);
      }
#line 13659
      if (tmp___22 != 0) {
        {
#line 13661
        tmp___21 = gettext("%s: failed to seek to archive member.\n");
#line 13661
        error((char const   *)tmp___21, nested_arch.file_name);
#line 13662
        ret = 1;
        }
#line 13663
        goto while_break___0;
      }
      {
#line 13666
      tmp___23 = process_object(qualified_name___0, nested_arch.file);
#line 13666
      ret |= tmp___23;
      }
    } else {
      {
#line 13670
      archive_file_offset = (long )arch.next_arhdr_offset;
#line 13671
      arch.next_arhdr_offset += archive_file_size;
#line 13673
      tmp___24 = process_object(qualified_name___0, file);
#line 13673
      ret |= tmp___24;
      }
    }
#line 13676
    if ((unsigned long )dump_sects != (unsigned long )((void *)0)) {
      {
#line 13678
      free((void *)dump_sects);
#line 13679
      dump_sects = (dump_type *)((void *)0);
#line 13680
      num_dump_sects = 0U;
      }
    }
    {
#line 13683
    free((void *)qualified_name___0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  out: 
#line 13687
  if ((unsigned long )nested_arch.file != (unsigned long )((void *)0)) {
    {
#line 13688
    fclose(nested_arch.file);
    }
  }
  {
#line 13689
  release_archive(& nested_arch);
#line 13690
  release_archive(& arch);
  }
#line 13692
  return (ret);
}
}
#line 13695 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
static int process_file(char *file_name ) 
{ 
  FILE *file ;
  struct stat statbuf ;
  char armag[8] ;
  int ret ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 13703
  tmp___5 = stat((char const   */* __restrict  */)file_name, (struct stat */* __restrict  */)(& statbuf));
  }
#line 13703
  if (tmp___5 < 0) {
    {
#line 13705
    tmp___4 = __errno_location();
    }
#line 13705
    if (*tmp___4 == 2) {
      {
#line 13706
      tmp___0 = gettext("\'%s\': No such file\n");
#line 13706
      error((char const   *)tmp___0, file_name);
      }
    } else {
      {
#line 13708
      tmp___1 = __errno_location();
#line 13708
      tmp___2 = strerror(*tmp___1);
#line 13708
      tmp___3 = gettext("Could not locate \'%s\'.  System error message: %s\n");
#line 13708
      error((char const   *)tmp___3, file_name, tmp___2);
      }
    }
#line 13710
    return (1);
  }
#line 13713
  if (! ((statbuf.st_mode & 61440U) == 32768U)) {
    {
#line 13715
    tmp___6 = gettext("\'%s\' is not an ordinary file\n");
#line 13715
    error((char const   *)tmp___6, file_name);
    }
#line 13716
    return (1);
  }
  {
#line 13719
  file = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"rb");
  }
#line 13720
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 13722
    tmp___7 = gettext("Input file \'%s\' is not readable.\n");
#line 13722
    error((char const   *)tmp___7, file_name);
    }
#line 13723
    return (1);
  }
  {
#line 13726
  tmp___9 = fread((void */* __restrict  */)(armag), (size_t )8, (size_t )1, (FILE */* __restrict  */)file);
  }
#line 13726
  if (tmp___9 != 1UL) {
    {
#line 13728
    tmp___8 = gettext("%s: Failed to read file\'s magic number\n");
#line 13728
    error((char const   *)tmp___8, file_name);
#line 13729
    fclose(file);
    }
#line 13730
    return (1);
  }
  {
#line 13733
  tmp___12 = memcmp((void const   *)(armag), (void const   *)"!<arch>\n", (size_t )8);
  }
#line 13733
  if (tmp___12 == 0) {
    {
#line 13734
    ret = process_archive(file_name, file, 0);
    }
  } else {
    {
#line 13735
    tmp___11 = memcmp((void const   *)(armag), (void const   *)"!<thin>\n", (size_t )8);
    }
#line 13735
    if (tmp___11 == 0) {
      {
#line 13736
      ret = process_archive(file_name, file, 1);
      }
    } else {
#line 13739
      if (do_archive_index) {
        {
#line 13740
        tmp___10 = gettext("File %s is not an archive so its index cannot be displayed.\n");
#line 13740
        error((char const   *)tmp___10, file_name);
        }
      }
      {
#line 13743
      rewind(file);
#line 13744
      archive_file_offset = 0L;
#line 13744
      archive_file_size = (unsigned long )archive_file_offset;
#line 13745
      ret = process_object(file_name, file);
      }
    }
  }
  {
#line 13748
  fclose(file);
  }
#line 13750
  return (ret);
}
}
#line 13772 "/home/khheo/project/benchmark/binutils-gdb-binutils-2_23_2/binutils/readelf.c"
int main(int argc , char **argv ) 
{ 
  int err ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 13778
  setlocale(5, "");
#line 13781
  setlocale(0, "");
#line 13783
  bindtextdomain("binutils", "/usr/local/share/locale");
#line 13784
  textdomain("binutils");
#line 13786
  expandargv(& argc, & argv);
#line 13788
  parse_args(argc, argv);
  }
#line 13790
  if (num_dump_sects > 0U) {
    {
#line 13793
    tmp___0 = malloc((unsigned long )num_dump_sects * sizeof(*dump_sects));
#line 13793
    cmdline_dump_sects = (dump_type *)tmp___0;
    }
#line 13795
    if ((unsigned long )cmdline_dump_sects == (unsigned long )((void *)0)) {
      {
#line 13796
      tmp___1 = gettext("Out of memory allocating dump request table.\n");
#line 13796
      error((char const   *)tmp___1);
      }
    } else {
      {
#line 13799
      memcpy((void */* __restrict  */)cmdline_dump_sects, (void const   */* __restrict  */)dump_sects,
             (unsigned long )num_dump_sects * sizeof(*dump_sects));
#line 13801
      num_cmdline_dump_sects = num_dump_sects;
      }
    }
  }
#line 13805
  if (optind < argc - 1) {
#line 13806
    show_name = 1;
  }
#line 13808
  err = 0;
  {
#line 13809
  while (1) {
    while_continue: /* CIL Label */ ;
#line 13809
    if (! (optind < argc)) {
#line 13809
      goto while_break;
    }
    {
#line 13810
    tmp___2 = optind;
#line 13810
    optind ++;
#line 13810
    tmp___3 = process_file(*(argv + tmp___2));
#line 13810
    err |= tmp___3;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 13812
  if ((unsigned long )dump_sects != (unsigned long )((void *)0)) {
    {
#line 13813
    free((void *)dump_sects);
    }
  }
#line 13814
  if ((unsigned long )cmdline_dump_sects != (unsigned long )((void *)0)) {
    {
#line 13815
    free((void *)cmdline_dump_sects);
    }
  }
#line 13817
  return (err);
}
}
