/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 256 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.h"
struct permission_context {
   mode_t mode ;
};
#line 67 "./lib/selinux/selinux.h"
typedef unsigned short security_class_t;
#line 68 "./lib/selinux/selinux.h"
typedef char *security_context_t;
#line 37 "./lib/selinux/context.h"
typedef int context_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 32 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    shell_escape_quoting_style = 3,
    shell_escape_always_quoting_style = 4,
    c_quoting_style = 5,
    c_maybe_quoting_style = 6,
    escape_quoting_style = 7,
    locale_quoting_style = 8,
    clocale_quoting_style = 9,
    custom_quoting_style = 10
} ;
#line 270
struct quoting_options ;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_116524687 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_116524687 __mbstate_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 57 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 826 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 167 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[] ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.h"
union __anonunion_temp_355861816 {
   size_t i ;
   void *p ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.h"
union __anonunion_chunkfun_5259977 {
   void *(*plain)(size_t  ) ;
   void *(*extra)(void * , size_t  ) ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.h"
union __anonunion_freefun_5259978 {
   void (*plain)(void * ) ;
   void (*extra)(void * , void * ) ;
};
#line 174 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.h"
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_355861816 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_5259977 chunkfun ;
   union __anonunion_freefun_5259978 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 52 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.c"
struct preliminary_header {
   void *next ;
   int magic ;
};
#line 56 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.c"
struct __anonstruct_magic_951761807 {
   char room[(((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(int )] ;
   int word ;
};
#line 56 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.c"
union header {
   void *next ;
   struct __anonstruct_magic_951761807 magic ;
};
#line 26 "./lib/localeinfo.h"
struct localeinfo {
   _Bool multibyte ;
   _Bool using_utf8 ;
   signed char sbclen[256] ;
   wint_t sbctowc[256] ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 73 "./lib/regex.h"
typedef unsigned long reg_syntax_t;
#line 35 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.h"
struct dfamust {
   _Bool exact ;
   _Bool begline ;
   _Bool endline ;
   char *must ;
};
#line 44
struct dfa ;
#line 74 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef unsigned long charclass_word;
#line 106 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef charclass_word charclass[4];
#line 185 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef ptrdiff_t token;
#line 190 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef ptrdiff_t state_num;
#line 285 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct __anonstruct_position_1023785459 {
   size_t index ;
   unsigned int constraint ;
};
#line 285 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef struct __anonstruct_position_1023785459 position;
#line 292 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct __anonstruct_position_set_349475030 {
   position *elems ;
   ptrdiff_t nelem ;
   ptrdiff_t alloc ;
};
#line 292 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef struct __anonstruct_position_set_349475030 position_set;
#line 300 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct __anonstruct_leaf_set_73278319 {
   size_t *elems ;
   size_t nelem ;
};
#line 300 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef struct __anonstruct_leaf_set_73278319 leaf_set;
#line 309 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct __anonstruct_dfa_state_810101419 {
   size_t hash ;
   position_set elems ;
   unsigned char context ;
   unsigned short constraint ;
   token first_end ;
   position_set mbps ;
   state_num mb_trindex ;
};
#line 309 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef struct __anonstruct_dfa_state_810101419 dfa_state;
#line 330 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct mb_char_classes {
   ptrdiff_t cset ;
   _Bool invert ;
   wchar_t *chars ;
   ptrdiff_t nchars ;
};
#line 338 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct regex_syntax {
   reg_syntax_t syntax_bits ;
   _Bool syntax_bits_set ;
   _Bool case_fold ;
   _Bool anchor ;
   unsigned char eolbyte ;
   int sbit[256] ;
   _Bool never_trail[256] ;
   charclass letters ;
   charclass newline ;
};
#line 372 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct lexer_state {
   char const   *ptr ;
   size_t left ;
   token lasttok ;
   size_t parens ;
   int minrep ;
   int maxrep ;
   wint_t wctok ;
   int cur_mb_len ;
   _Bool laststart ;
};
#line 394 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct parser_state {
   token tok ;
   size_t depth ;
};
#line 405 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct dfa {
   struct regex_syntax syntax ;
   charclass *charclasses ;
   ptrdiff_t cindex ;
   ptrdiff_t calloc ;
   size_t canychar ;
   struct lexer_state lex ;
   struct parser_state parse ;
   token *tokens ;
   size_t tindex ;
   size_t talloc ;
   size_t depth ;
   size_t nleaves ;
   size_t nregexps ;
   _Bool fast ;
   token utf8_anychar_classes[5] ;
   mbstate_t mbs ;
   int *multibyte_prop ;
   struct mb_char_classes *mbcsets ;
   ptrdiff_t nmbcsets ;
   ptrdiff_t mbcsets_alloc ;
   struct dfa *superset ;
   dfa_state *states ;
   state_num sindex ;
   ptrdiff_t salloc ;
   position_set *follows ;
   _Bool searchflag ;
   state_num tralloc ;
   int trcount ;
   int min_trcount ;
   state_num **trans ;
   state_num **fails ;
   int *success ;
   state_num *newlines ;
   state_num initstate_notbol ;
   position_set mb_follows ;
   state_num **mb_trans ;
   state_num mb_trcount ;
   char *(*dfaexec)(struct dfa * , char const   * , char * , _Bool  , size_t * , _Bool * ) ;
   _Bool simple_locale ;
   struct localeinfo localeinfo ;
};
#line 939 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef int predicate(int  );
#line 945 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct dfa_ctype {
   char const   *name ;
   predicate *func ;
   _Bool single_byte_only ;
};
#line 1229 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct lexptr {
   char const   *ptr ;
   size_t left ;
};
#line 2385 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct __anonstruct_stkalloc_360611398 {
   _Bool nullable ;
   size_t nfirstpos ;
   size_t nlastpos ;
};
#line 3769
struct must ;
#line 3769 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
typedef struct must must;
#line 3771 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct must {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
   _Bool begline ;
   _Bool endline ;
   must *prev ;
};
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 71 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 51 "/home/khheo/project/benchmark/sed-4.3/sed/utils.h"
struct buffer ;
#line 40 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
struct open_file {
   FILE *fp ;
   char *name ;
   struct open_file *link ;
   unsigned int temp : 1 ;
};
#line 444 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
struct buffer {
   size_t allocated ;
   size_t length ;
   char *b ;
};
#line 32 "./basicdefs.h"
typedef unsigned long countT;
#line 57 "./lib/regex.h"
typedef unsigned long __re_long_size_t;
#line 414
struct re_dfa_t ;
#line 414 "./lib/regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 479 "./lib/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 29 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct sed_cmd ;
#line 29 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct vector {
   struct sed_cmd *v ;
   size_t v_allocated ;
   size_t v_length ;
};
#line 39 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct output {
   char *name ;
   _Bool missing_newline ;
   FILE *fp ;
   struct output *link ;
};
#line 46 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct text_buf {
   char *text ;
   size_t text_length ;
};
#line 51 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct regex {
   regex_t pattern ;
   int flags ;
   size_t sz ;
   struct dfa *dfa ;
   _Bool begline ;
   _Bool endline ;
   char re[1] ;
};
#line 61
enum replacement_types {
    REPL_ASIS = 0,
    REPL_UPPERCASE = 1,
    REPL_LOWERCASE = 2,
    REPL_UPPERCASE_FIRST = 4,
    REPL_LOWERCASE_FIRST = 8,
    REPL_MODIFIERS = 12,
    REPL_UPPERCASE_UPPERCASE = 5,
    REPL_UPPERCASE_LOWERCASE = 6,
    REPL_LOWERCASE_UPPERCASE = 9,
    REPL_LOWERCASE_LOWERCASE = 10
} ;
#line 82
enum posixicity_types {
    POSIXLY_EXTENDED = 0,
    POSIXLY_CORRECT = 1,
    POSIXLY_BASIC = 2
} ;
#line 88
enum addr_state {
    RANGE_INACTIVE = 0,
    RANGE_ACTIVE = 1,
    RANGE_CLOSED = 2
} ;
#line 94
enum addr_types {
    ADDR_IS_NULL = 0,
    ADDR_IS_REGEX = 1,
    ADDR_IS_NUM = 2,
    ADDR_IS_NUM_MOD = 3,
    ADDR_IS_STEP = 4,
    ADDR_IS_STEP_MOD = 5,
    ADDR_IS_LAST = 6
} ;
#line 104 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct addr {
   enum addr_types addr_type ;
   countT addr_number ;
   countT addr_step ;
   struct regex *addr_regex ;
};
#line 112 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct replacement {
   char *prefix ;
   size_t prefix_length ;
   int subst_id ;
   enum replacement_types repl_type ;
   struct replacement *next ;
};
#line 120 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct subst {
   struct regex *regx ;
   struct replacement *replacement ;
   countT numb ;
   struct output *outf ;
   unsigned int global : 1 ;
   unsigned int print : 2 ;
   unsigned int eval : 1 ;
   unsigned int max_id : 4 ;
};
#line 144 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
union __anonunion_x_936425645 {
   struct text_buf cmd_txt ;
   int int_arg ;
   countT jump_index ;
   char *fname ;
   struct subst *cmd_subst ;
   struct output *outf ;
   FILE *fp ;
   unsigned char *translate ;
   char **translatemb ;
};
#line 144 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct sed_cmd {
   struct addr *a1 ;
   struct addr *a2 ;
   enum addr_state range_state ;
   char addr_bang ;
   char cmd ;
   union __anonunion_x_936425645 x ;
};
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 56 "./lib/regex.h"
typedef unsigned int __re_size_t;
#line 491 "./lib/regex.h"
typedef int regoff_t;
#line 498 "./lib/regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 76 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
enum text_types {
    TEXT_BUFFER = 0,
    TEXT_REPLACEMENT = 1,
    TEXT_REGEX = 2
} ;
#line 56 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
struct line {
   char *text ;
   char *active ;
   size_t length ;
   size_t alloc ;
   _Bool chomped ;
   mbstate_t mbstate ;
};
#line 69 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
struct append_queue {
   char const   *fname ;
   char *text ;
   size_t textlen ;
   struct append_queue *next ;
   _Bool free ;
};
#line 78 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
struct input {
   char **file_list ;
   countT bad_count ;
   countT line_number ;
   _Bool reset_at_next_file ;
   _Bool (*read_fn)(struct input * ) ;
   char *out_file_name ;
   char const   *in_file_name ;
   struct stat st ;
   FILE *fp ;
   _Bool no_buffering ;
};
#line 38 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
struct prog_info {
   unsigned char const   *base ;
   unsigned char const   *cur ;
   unsigned char const   *end ;
   FILE *file ;
};
#line 55 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
struct error_info {
   char const   *name ;
   countT line ;
   countT string_expr_count ;
};
#line 68 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
struct sed_label {
   countT v_index ;
   char *name ;
   struct error_info err_info ;
   struct sed_label *next ;
};
#line 75 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
struct special_files {
   struct output outf ;
   FILE **pfp ;
};
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 57
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 59
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 61
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 63
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 65
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 67
void *x2realloc(void *p , size_t *pn ) ;
#line 68
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 70
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 102
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 104 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 107
  if (9223372036854775807UL / s < n) {
    {
#line 108
    xalloc_die();
    }
  }
  {
#line 109
  tmp = xmalloc(n * s);
  }
#line 109
  return (tmp);
}
}
#line 115
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 117 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  void *tmp ;

  {
#line 120
  if (9223372036854775807UL / s < n) {
    {
#line 121
    xalloc_die();
    }
  }
  {
#line 122
  tmp = xrealloc(p, n * s);
  }
#line 122
  return (tmp);
}
}
#line 179 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 182
  n = *pn;
#line 184
  if (! p) {
#line 186
    if (! n) {
#line 194
      n = 128UL / s;
#line 195
      n += (size_t )(! n);
    }
  } else {
#line 204
    if (6148914691236517204UL / s <= n) {
      {
#line 206
      xalloc_die();
      }
    }
#line 207
    n += n / 2UL + 1UL;
  }
  {
#line 210
  *pn = n;
#line 211
  tmp = xrealloc(p, n * s);
  }
#line 211
  return (tmp);
}
}
#line 217
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 219
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 219 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 222
  if (sizeof(char ) == 1UL) {
    {
#line 222
    tmp = xmalloc(n);
#line 222
    tmp___1 = tmp;
    }
  } else {
    {
#line 222
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 222
    tmp___1 = tmp___0;
    }
  }
#line 222
  return ((char *)tmp___1);
}
}
#line 264
#pragma GCC diagnostic pop
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 38 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
#line 100
  if (9223372036854775807UL / s < n) {
    {
#line 102
    xalloc_die();
    }
  } else {
    {
#line 100
    p = calloc(n, s);
    }
#line 100
    if (! p) {
      {
#line 102
      xalloc_die();
      }
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/sed-4.3/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 52 "/home/khheo/project/benchmark/sed-4.3/lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/sed-4.3/lib/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2016);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-sed@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU sed", "http://www.gnu.org/software/sed/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 141 "/home/khheo/project/benchmark/sed-4.3/lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 52 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 58
int try_tempname(char *tmpl , int suffixlen , void *args , int (*tryfunc)(char * ,
                                                                          void * ) ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 141 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 259 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 317
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 177 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
static char const   letters[63]  = 
#line 177 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 186 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
static uint64_t value  ;
#line 180 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
int try_tempname(char *tmpl , int suffixlen , void *args , int (*tryfunc)(char * ,
                                                                          void * ) ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 189
  fd = -1;
#line 190
  tmp = __errno_location();
#line 190
  save_errno = *tmp;
#line 205
  attempts = 238328U;
#line 208
  tmp___0 = strlen((char const   *)tmpl);
#line 208
  len = (int )tmp___0;
  }
#line 209
  if (len < 6 + suffixlen) {
    {
#line 211
    tmp___1 = __errno_location();
#line 211
    *tmp___1 = 22;
    }
#line 212
    return (-1);
  } else {
    {
#line 209
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 209
    if (tmp___2) {
      {
#line 211
      tmp___1 = __errno_location();
#line 211
      *tmp___1 = 22;
      }
#line 212
      return (-1);
    }
  }
  {
#line 216
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 224
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 225
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 228
  tmp___3 = getpid();
#line 228
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 230
  count = 0U;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (count < attempts)) {
#line 230
      goto while_break;
    }
    {
#line 232
    v = value;
#line 235
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 236
    v /= 62UL;
#line 237
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 238
    v /= 62UL;
#line 239
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 240
    v /= 62UL;
#line 241
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 242
    v /= 62UL;
#line 243
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 244
    v /= 62UL;
#line 245
    *(XXXXXX + 5) = (char )letters[v % 62UL];
#line 247
    fd = (*tryfunc)(tmpl, args);
    }
#line 248
    if (fd >= 0) {
      {
#line 250
      tmp___4 = __errno_location();
#line 250
      *tmp___4 = save_errno;
      }
#line 251
      return (fd);
    } else {
      {
#line 253
      tmp___5 = __errno_location();
      }
#line 253
      if (*tmp___5 != 17) {
#line 254
        return (-1);
      }
    }
#line 230
    value += 7777UL;
#line 230
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  tmp___6 = __errno_location();
#line 258
  *tmp___6 = 17;
  }
#line 259
  return (-1);
}
}
#line 262 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
static int try_file(char *tmpl , void *flags ) 
{ 
  int *openflags ;
  int tmp ;

  {
  {
#line 265
  openflags = (int *)flags;
#line 266
  tmp = open((char const   *)tmpl, (((*openflags & -4) | 2) | 64) | 128, 384);
  }
#line 266
  return (tmp);
}
}
#line 271 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
static int try_dir(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 274
  tmp = mkdir((char const   *)tmpl, (__mode_t )448);
  }
#line 274
  return (tmp);
}
}
#line 277 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
static int try_nocreate(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 282
  tmp___0 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
  }
#line 282
  if (tmp___0 == 0) {
    {
#line 283
    tmp = __errno_location();
#line 283
    *tmp = 17;
    }
  }
  {
#line 284
  tmp___3 = __errno_location();
  }
#line 284
  if (*tmp___3 == 2) {
#line 284
    tmp___2 = 0;
  } else {
#line 284
    tmp___2 = -1;
  }
#line 284
  return (tmp___2);
}
}
#line 300 "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int (*tryfunc)(char * , void * ) ;
  int tmp ;

  {
  {
#line 307
  if (kind == 0) {
#line 307
    goto case_0;
  }
#line 311
  if (kind == 1) {
#line 311
    goto case_1;
  }
#line 315
  if (kind == 2) {
#line 315
    goto case_2;
  }
#line 319
  goto switch_default;
  case_0: /* CIL Label */ 
#line 308
  tryfunc = & try_file;
#line 309
  goto switch_break;
  case_1: /* CIL Label */ 
#line 312
  tryfunc = & try_dir;
#line 313
  goto switch_break;
  case_2: /* CIL Label */ 
#line 316
  tryfunc = & try_nocreate;
#line 317
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 320
  __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/khheo/project/benchmark/sed-4.3/lib/tempname.c",
                320U, "gen_tempname");
#line 321
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 323
  tmp = try_tempname(tmpl, suffixlen, (void *)(& flags), tryfunc);
  }
#line 323
  return (tmp);
}
}
#line 44 "/home/khheo/project/benchmark/sed-4.3/lib/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 46
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 48
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/sed-4.3/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 33 "/home/khheo/project/benchmark/sed-4.3/lib/acl.h"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 66 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 295
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) ;
#line 302
#pragma GCC diagnostic pop
#line 759 "/home/khheo/project/benchmark/sed-4.3/lib/set-permissions.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 762
  if (desc != -1) {
    {
#line 763
    tmp = fchmod(desc, mode);
    }
#line 763
    return (tmp);
  } else {
    {
#line 765
    tmp___0 = chmod(name, mode);
    }
#line 765
    return (tmp___0);
  }
}
}
#line 775 "/home/khheo/project/benchmark/sed-4.3/lib/set-permissions.c"
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) 
{ 
  _Bool acls_set  __attribute__((__unused__)) ;
  _Bool early_chmod ;
  _Bool must_chmod ;
  int ret ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 778
  acls_set = (_Bool)0;
#line 780
  must_chmod = (_Bool)0;
#line 781
  ret = 0;
#line 801
  early_chmod = (_Bool)1;
#line 804
  if (early_chmod) {
    {
#line 806
    ret = chmod_or_fchmod(name, desc, ctx->mode);
    }
#line 807
    if (ret != 0) {
#line 808
      return (-1);
    }
  }
#line 833
  if (must_chmod) {
#line 833
    if (! early_chmod) {
#line 835
      if (ret) {
        {
#line 835
        tmp = __errno_location();
#line 835
        tmp___0 = *tmp;
        }
      } else {
#line 835
        tmp___0 = 0;
      }
      {
#line 835
      saved_errno = tmp___0;
#line 837
      ret = chmod_or_fchmod(name, desc, ctx->mode);
      }
#line 839
      if (saved_errno) {
        {
#line 841
        tmp___1 = __errno_location();
#line 841
        *tmp___1 = saved_errno;
#line 842
        ret = -1;
        }
      }
    }
  }
#line 846
  return (ret);
}
}
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/acl.h"
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 30
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 44 "/home/khheo/project/benchmark/sed-4.3/lib/quote.h"
char const   *quote(char const   *arg ) ;
#line 41 "/home/khheo/project/benchmark/sed-4.3/lib/set-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 44
  tmp = qset_acl(name, desc, mode);
#line 44
  ret = tmp;
  }
#line 45
  if (ret != 0) {
    {
#line 46
    tmp___0 = quote(name);
#line 46
    tmp___1 = gettext("setting permissions for %s");
#line 46
    tmp___2 = __errno_location();
#line 46
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
    }
  }
#line 47
  return (ret);
}
}
#line 38 "./lib/selinux/selinux.h"
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 38
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 71 "./lib/selinux/selinux.h"
__inline int getcon(security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 73
  tmp = __errno_location();
#line 73
  *tmp = 95;
  }
#line 73
  return (-1);
}
}
#line 74 "./lib/selinux/selinux.h"
__inline void freecon(security_context_t con  __attribute__((__unused__)) ) 
{ 


  {
#line 75
  return;
}
}
#line 80 "./lib/selinux/selinux.h"
__inline int setfscreatecon(security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 82
  tmp = __errno_location();
#line 82
  *tmp = 95;
  }
#line 82
  return (-1);
}
}
#line 83 "./lib/selinux/selinux.h"
__inline int matchpathcon(char const   *file  __attribute__((__unused__)) , mode_t m  __attribute__((__unused__)) ,
                          security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 87
  tmp = __errno_location();
#line 87
  *tmp = 95;
  }
#line 87
  return (-1);
}
}
#line 88 "./lib/selinux/selinux.h"
__inline int getfilecon(char const   *file  __attribute__((__unused__)) , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 91
  tmp = __errno_location();
#line 91
  *tmp = 95;
  }
#line 91
  return (-1);
}
}
#line 96 "./lib/selinux/selinux.h"
__inline int fgetfilecon(int fd , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 98
  tmp = __errno_location();
#line 98
  *tmp = 95;
  }
#line 98
  return (-1);
}
}
#line 99 "./lib/selinux/selinux.h"
__inline int setfilecon(char const   *file  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 102
  tmp = __errno_location();
#line 102
  *tmp = 95;
  }
#line 102
  return (-1);
}
}
#line 107 "./lib/selinux/selinux.h"
__inline int fsetfilecon(int fd  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  *tmp = 95;
  }
#line 110
  return (-1);
}
}
#line 121 "./lib/selinux/selinux.h"
__inline int security_compute_create(security_context_t scon  __attribute__((__unused__)) ,
                                     security_context_t tcon  __attribute__((__unused__)) ,
                                     security_class_t tclass  __attribute__((__unused__)) ,
                                     security_context_t *newcon  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 126
  tmp = __errno_location();
#line 126
  *tmp = 95;
  }
#line 126
  return (-1);
}
}
#line 127 "./lib/selinux/selinux.h"
__inline security_class_t string_to_security_class(char const   *name ) 
{ 
  int *tmp ;

  {
  {
#line 129
  tmp = __errno_location();
#line 129
  *tmp = 95;
  }
#line 129
  return ((security_class_t )0);
}
}
#line 130 "./lib/selinux/selinux.h"
__inline int matchpathcon_init_prefix(char const   *path  __attribute__((__unused__)) ,
                                      char const   *prefix  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 133
  tmp = __errno_location();
#line 133
  *tmp = 95;
  }
#line 133
  return (-1);
}
}
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 10 "./lib/selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "./lib/selinux/context.h"
__inline context_t context_new(char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 39
  tmp = __errno_location();
#line 39
  *tmp = 95;
  }
#line 39
  return (0);
}
}
#line 40 "./lib/selinux/context.h"
__inline char *context_str(context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 41
  tmp = __errno_location();
#line 41
  *tmp = 95;
  }
#line 41
  return ((char *)((void *)0));
}
}
#line 42 "./lib/selinux/context.h"
__inline void context_free(context_t c  __attribute__((__unused__)) ) 
{ 


  {
#line 42
  return;
}
}
#line 44 "./lib/selinux/context.h"
__inline int context_user_set(context_t sc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 46
  tmp = __errno_location();
#line 46
  *tmp = 95;
  }
#line 46
  return (-1);
}
}
#line 65
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 267 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.h"
char const   * const  quoting_style_args[11] ;
#line 268
enum quoting_style  const  quoting_style_vals[10] ;
#line 278
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 281
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) ;
#line 285
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 294
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 300
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 311
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 326
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) ;
#line 333
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 342
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 352
char *quotearg_n(int n , char const   *arg ) ;
#line 355
char *quotearg(char const   *arg ) ;
#line 360
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 363
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 368
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 373
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 380
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 385
char *quotearg_char(char const   *arg , char ch ) ;
#line 388
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 391
char *quotearg_colon(char const   *arg ) ;
#line 394
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 397
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) ;
#line 403
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 408
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 413
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 418
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 423
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/sed-4.3/lib/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg ) ;
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 42 "/home/khheo/project/benchmark/sed-4.3/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 168 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isalnum(int c ) 
{ 


  {
  {
#line 175
  if (c == 90) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 89) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 88) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 87) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 86) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 85) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 84) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 83) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 82) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 81) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 80) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 79) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 78) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 77) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 76) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 75) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 74) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 73) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 72) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 71) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 70) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 69) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 68) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 67) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 66) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 65) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 122) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 121) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 120) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 119) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 118) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 117) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 116) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 115) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 114) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 113) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 112) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 111) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 110) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 109) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 108) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 107) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 106) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 105) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 104) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 103) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 102) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 101) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 100) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 99) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 98) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 97) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 57) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 56) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 55) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 54) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 53) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 52) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 51) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 50) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 49) {
#line 175
    goto case_90;
  }
#line 175
  if (c == 48) {
#line 175
    goto case_90;
  }
#line 177
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 176
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 178
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 182 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isalpha(int c ) 
{ 


  {
  {
#line 188
  if (c == 90) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 89) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 88) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 87) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 86) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 85) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 84) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 83) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 82) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 81) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 80) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 79) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 78) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 77) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 76) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 75) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 74) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 73) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 72) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 71) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 70) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 69) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 68) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 67) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 66) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 65) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 122) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 121) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 120) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 119) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 118) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 117) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 116) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 115) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 114) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 113) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 112) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 111) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 110) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 109) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 108) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 107) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 106) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 105) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 104) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 103) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 102) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 101) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 100) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 99) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 98) {
#line 188
    goto case_90;
  }
#line 188
  if (c == 97) {
#line 188
    goto case_90;
  }
#line 190
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 189
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 191
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 197 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isascii(int c ) 
{ 


  {
  {
#line 207
  if (c == 90) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 89) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 88) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 87) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 86) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 85) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 84) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 83) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 82) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 81) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 80) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 79) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 78) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 77) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 76) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 75) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 74) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 73) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 72) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 71) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 70) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 69) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 68) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 67) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 66) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 65) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 126) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 125) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 124) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 123) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 96) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 95) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 94) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 93) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 92) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 91) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 64) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 63) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 62) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 61) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 60) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 59) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 58) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 47) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 46) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 45) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 44) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 43) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 42) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 41) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 40) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 39) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 38) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 37) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 36) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 35) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 34) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 33) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 122) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 121) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 120) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 119) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 118) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 117) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 116) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 115) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 114) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 113) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 112) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 111) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 110) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 109) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 108) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 107) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 106) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 105) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 104) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 103) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 102) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 101) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 100) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 99) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 98) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 97) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 57) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 56) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 55) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 54) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 53) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 52) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 51) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 50) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 49) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 48) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 127) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 31) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 30) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 29) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 28) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 27) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 26) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 25) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 24) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 23) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 22) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 21) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 20) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 19) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 18) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 17) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 16) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 15) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 14) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 6) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 5) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 4) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 3) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 2) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 1) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 0) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 11) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 9) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 13) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 10) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 12) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 8) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 7) {
#line 207
    goto case_90;
  }
#line 207
  if (c == 32) {
#line 207
    goto case_90;
  }
#line 209
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 208
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 210
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 214 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 217
  if (c == 32) {
#line 217
    tmp = 1;
  } else
#line 217
  if (c == 9) {
#line 217
    tmp = 1;
  } else {
#line 217
    tmp = 0;
  }
#line 217
  return ((_Bool )tmp);
}
}
#line 220 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_iscntrl(int c ) 
{ 


  {
  {
#line 225
  if (c == 127) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 31) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 30) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 29) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 28) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 27) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 26) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 25) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 24) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 23) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 22) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 21) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 20) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 19) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 18) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 17) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 16) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 15) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 14) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 6) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 5) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 4) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 3) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 2) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 1) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 0) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 11) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 9) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 13) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 10) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 12) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 8) {
#line 225
    goto case_127;
  }
#line 225
  if (c == 7) {
#line 225
    goto case_127;
  }
#line 227
  goto switch_default;
  case_127: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_28: /* CIL Label */ 
  case_27: /* CIL Label */ 
  case_26: /* CIL Label */ 
  case_25: /* CIL Label */ 
  case_24: /* CIL Label */ 
  case_23: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_20: /* CIL Label */ 
  case_19: /* CIL Label */ 
  case_18: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_16: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_14: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_13: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
#line 226
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 228
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 232 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isdigit(int c ) 
{ 


  {
  {
#line 237
  if (c == 57) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 56) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 55) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 54) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 53) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 52) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 51) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 50) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 49) {
#line 237
    goto case_57;
  }
#line 237
  if (c == 48) {
#line 237
    goto case_57;
  }
#line 239
  goto switch_default;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 238
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 240
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 244 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isgraph(int c ) 
{ 


  {
  {
#line 252
  if (c == 90) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 89) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 88) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 87) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 86) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 85) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 84) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 83) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 82) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 81) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 80) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 79) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 78) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 77) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 76) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 75) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 74) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 73) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 72) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 71) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 70) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 69) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 68) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 67) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 66) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 65) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 126) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 125) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 124) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 123) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 96) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 95) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 94) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 93) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 92) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 91) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 64) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 63) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 62) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 61) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 60) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 59) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 58) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 47) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 46) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 45) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 44) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 43) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 42) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 41) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 40) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 39) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 38) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 37) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 36) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 35) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 34) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 33) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 122) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 121) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 120) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 119) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 118) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 117) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 116) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 115) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 114) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 113) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 112) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 111) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 110) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 109) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 108) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 107) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 106) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 105) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 104) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 103) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 102) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 101) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 100) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 99) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 98) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 97) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 57) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 56) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 55) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 54) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 53) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 52) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 51) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 50) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 49) {
#line 252
    goto case_90;
  }
#line 252
  if (c == 48) {
#line 252
    goto case_90;
  }
#line 254
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 253
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 255
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 259 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_islower(int c ) 
{ 


  {
  {
#line 264
  if (c == 122) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 121) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 120) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 119) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 118) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 117) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 116) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 115) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 114) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 113) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 112) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 111) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 110) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 109) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 108) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 107) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 106) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 105) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 104) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 103) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 102) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 101) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 100) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 99) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 98) {
#line 264
    goto case_122;
  }
#line 264
  if (c == 97) {
#line 264
    goto case_122;
  }
#line 266
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 265
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 267
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 271 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isprint(int c ) 
{ 


  {
  {
#line 280
  if (c == 90) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 89) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 88) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 87) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 86) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 85) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 84) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 83) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 82) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 81) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 80) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 79) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 78) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 77) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 76) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 75) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 74) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 73) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 72) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 71) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 70) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 69) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 68) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 67) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 66) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 65) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 126) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 125) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 124) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 123) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 96) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 95) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 94) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 93) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 92) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 91) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 64) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 63) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 62) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 61) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 60) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 59) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 58) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 47) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 46) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 45) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 44) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 43) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 42) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 41) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 40) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 39) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 38) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 37) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 36) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 35) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 34) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 33) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 122) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 121) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 120) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 119) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 118) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 117) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 116) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 115) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 114) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 113) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 112) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 111) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 110) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 109) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 108) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 107) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 106) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 105) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 104) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 103) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 102) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 101) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 100) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 99) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 98) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 97) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 57) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 56) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 55) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 54) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 53) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 52) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 51) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 50) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 49) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 48) {
#line 280
    goto case_90;
  }
#line 280
  if (c == 32) {
#line 280
    goto case_90;
  }
#line 282
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 281
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 283
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 287 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_ispunct(int c ) 
{ 


  {
  {
#line 292
  if (c == 126) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 125) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 124) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 123) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 96) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 95) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 94) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 93) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 92) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 91) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 64) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 63) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 62) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 61) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 60) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 59) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 58) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 47) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 46) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 45) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 44) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 43) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 42) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 41) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 40) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 39) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 38) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 37) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 36) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 35) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 34) {
#line 292
    goto case_126;
  }
#line 292
  if (c == 33) {
#line 292
    goto case_126;
  }
#line 294
  goto switch_default;
  case_126: /* CIL Label */ 
  case_125: /* CIL Label */ 
  case_124: /* CIL Label */ 
  case_123: /* CIL Label */ 
  case_96: /* CIL Label */ 
  case_95: /* CIL Label */ 
  case_94: /* CIL Label */ 
  case_93: /* CIL Label */ 
  case_92: /* CIL Label */ 
  case_91: /* CIL Label */ 
  case_64: /* CIL Label */ 
  case_63: /* CIL Label */ 
  case_62: /* CIL Label */ 
  case_61: /* CIL Label */ 
  case_60: /* CIL Label */ 
  case_59: /* CIL Label */ 
  case_58: /* CIL Label */ 
  case_47: /* CIL Label */ 
  case_46: /* CIL Label */ 
  case_45: /* CIL Label */ 
  case_44: /* CIL Label */ 
  case_43: /* CIL Label */ 
  case_42: /* CIL Label */ 
  case_41: /* CIL Label */ 
  case_40: /* CIL Label */ 
  case_39: /* CIL Label */ 
  case_38: /* CIL Label */ 
  case_37: /* CIL Label */ 
  case_36: /* CIL Label */ 
  case_35: /* CIL Label */ 
  case_34: /* CIL Label */ 
  case_33: /* CIL Label */ 
#line 293
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 295
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 299 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isspace(int c ) 
{ 


  {
  {
#line 304
  if (c == 13) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 12) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 11) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 10) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 9) {
#line 304
    goto case_13;
  }
#line 304
  if (c == 32) {
#line 304
    goto case_13;
  }
#line 306
  goto switch_default;
  case_13: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_11: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_32: /* CIL Label */ 
#line 305
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 307
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 311 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isupper(int c ) 
{ 


  {
  {
#line 316
  if (c == 90) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 89) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 88) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 87) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 86) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 85) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 84) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 83) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 82) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 81) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 80) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 79) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 78) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 77) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 76) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 75) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 74) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 73) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 72) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 71) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 70) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 69) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 68) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 67) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 66) {
#line 316
    goto case_90;
  }
#line 316
  if (c == 65) {
#line 316
    goto case_90;
  }
#line 318
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 317
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 319
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 323 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline _Bool c_isxdigit(int c ) 
{ 


  {
  {
#line 329
  if (c == 70) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 69) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 68) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 67) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 66) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 65) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 102) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 101) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 100) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 99) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 98) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 97) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 57) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 56) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 55) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 54) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 53) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 52) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 51) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 50) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 49) {
#line 329
    goto case_70;
  }
#line 329
  if (c == 48) {
#line 329
    goto case_70;
  }
#line 331
  goto switch_default;
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
#line 330
  return ((_Bool)1);
  switch_default: /* CIL Label */ 
#line 332
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 336 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline int c_tolower(int c ) 
{ 


  {
  {
#line 341
  if (c == 90) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 89) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 88) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 87) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 86) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 85) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 84) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 83) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 82) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 81) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 80) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 79) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 78) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 77) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 76) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 75) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 74) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 73) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 72) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 71) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 70) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 69) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 68) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 67) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 66) {
#line 341
    goto case_90;
  }
#line 341
  if (c == 65) {
#line 341
    goto case_90;
  }
#line 343
  goto switch_default;
  case_90: /* CIL Label */ 
  case_89: /* CIL Label */ 
  case_88: /* CIL Label */ 
  case_87: /* CIL Label */ 
  case_86: /* CIL Label */ 
  case_85: /* CIL Label */ 
  case_84: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_82: /* CIL Label */ 
  case_81: /* CIL Label */ 
  case_80: /* CIL Label */ 
  case_79: /* CIL Label */ 
  case_78: /* CIL Label */ 
  case_77: /* CIL Label */ 
  case_76: /* CIL Label */ 
  case_75: /* CIL Label */ 
  case_74: /* CIL Label */ 
  case_73: /* CIL Label */ 
  case_72: /* CIL Label */ 
  case_71: /* CIL Label */ 
  case_70: /* CIL Label */ 
  case_69: /* CIL Label */ 
  case_68: /* CIL Label */ 
  case_67: /* CIL Label */ 
  case_66: /* CIL Label */ 
  case_65: /* CIL Label */ 
#line 342
  return ((c - 65) + 97);
  switch_default: /* CIL Label */ 
#line 344
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 348 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
__inline int c_toupper(int c ) 
{ 


  {
  {
#line 353
  if (c == 122) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 121) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 120) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 119) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 118) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 117) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 116) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 115) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 114) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 113) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 112) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 111) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 110) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 109) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 108) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 107) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 106) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 105) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 104) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 103) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 102) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 101) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 100) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 99) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 98) {
#line 353
    goto case_122;
  }
#line 353
  if (c == 97) {
#line 353
    goto case_122;
  }
#line 355
  goto switch_default;
  case_122: /* CIL Label */ 
  case_121: /* CIL Label */ 
  case_120: /* CIL Label */ 
  case_119: /* CIL Label */ 
  case_118: /* CIL Label */ 
  case_117: /* CIL Label */ 
  case_116: /* CIL Label */ 
  case_115: /* CIL Label */ 
  case_114: /* CIL Label */ 
  case_113: /* CIL Label */ 
  case_112: /* CIL Label */ 
  case_111: /* CIL Label */ 
  case_110: /* CIL Label */ 
  case_109: /* CIL Label */ 
  case_108: /* CIL Label */ 
  case_107: /* CIL Label */ 
  case_106: /* CIL Label */ 
  case_105: /* CIL Label */ 
  case_104: /* CIL Label */ 
  case_103: /* CIL Label */ 
  case_102: /* CIL Label */ 
  case_101: /* CIL Label */ 
  case_100: /* CIL Label */ 
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  case_97: /* CIL Label */ 
#line 354
  return ((c - 97) + 65);
  switch_default: /* CIL Label */ 
#line 356
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 364
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/sed-4.3/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 587 "./lib/wchar.h"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 77 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char const   * const  quoting_style_args[11]  = 
#line 77 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"shell-escape", 
        (char const   */* const  */)"shell-escape-always",      (char const   */* const  */)"c",      (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape", 
        (char const   */* const  */)"locale",      (char const   */* const  */)"clocale",      (char const   */* const  */)0};
#line 93 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[10]  = 
#line 93
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7, 
        (enum quoting_style  const  )8,      (enum quoting_style  const  )9};
#line 108 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 113 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 116
  tmp = __errno_location();
#line 116
  e = *tmp;
  }
#line 117
  if (o) {
#line 117
    tmp___0 = o;
  } else {
#line 117
    tmp___0 = & default_quoting_options;
  }
  {
#line 117
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 117
  p = (struct quoting_options *)tmp___1;
#line 119
  tmp___2 = __errno_location();
#line 119
  *tmp___2 = e;
  }
#line 120
  return (p);
}
}
#line 124 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *tmp ;

  {
#line 127
  if (o) {
#line 127
    tmp = o;
  } else {
#line 127
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 127
  return ((enum quoting_style )tmp->style);
}
}
#line 132 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 135
  if (o) {
#line 135
    tmp = o;
  } else {
#line 135
    tmp = & default_quoting_options;
  }
#line 135
  tmp->style = s;
#line 136
  return;
}
}
#line 143 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 146
  uc = (unsigned char )c;
#line 147
  if (o) {
#line 147
    tmp = o;
  } else {
#line 147
    tmp = & default_quoting_options;
  }
#line 147
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 149
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 150
  r = (int )((*p >> shift) & 1U);
#line 151
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 152
  return (r);
}
}
#line 159 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 163
  if (! o) {
#line 164
    o = & default_quoting_options;
  }
#line 165
  r = o->flags;
#line 166
  o->flags = i;
#line 167
  return (r);
}
}
#line 170 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 174
  if (! o) {
#line 175
    o = & default_quoting_options;
  }
#line 176
  o->style = (enum quoting_style )10;
#line 177
  if (! left_quote) {
    {
#line 178
    abort();
    }
  } else
#line 177
  if (! right_quote) {
    {
#line 178
    abort();
    }
  }
#line 179
  o->left_quote = left_quote;
#line 180
  o->right_quote = right_quote;
#line 181
  return;
}
}
#line 184 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;
  unsigned int tmp ;

  {
#line 187
  o.style = (enum quoting_style )0;
#line 187
  o.flags = 0;
#line 187
  o.quote_these_too[0] = 0U;
#line 187
  tmp = 1U;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (tmp >= 8U) {
#line 187
      goto while_break;
    }
#line 187
    o.quote_these_too[tmp] = 0U;
#line 187
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  o.left_quote = (char const   *)((void *)0);
#line 187
  o.right_quote = (char const   *)((void *)0);
#line 188
  if ((unsigned int )style == 10U) {
    {
#line 189
    abort();
    }
  }
#line 190
  o.style = style;
#line 191
  return (o);
}
}
#line 198 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 201
  tmp = gettext(msgid);
#line 201
  translation = (char const   *)tmp;
  }
#line 204
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 205
    return (translation);
  }
  {
#line 225
  locale_code = locale_charset();
#line 226
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 226
  if (tmp___1 == 0) {
#line 227
    if ((int const   )*(msgid + 0) == 96) {
#line 227
      tmp___0 = "\342\200\230";
    } else {
#line 227
      tmp___0 = "\342\200\231";
    }
#line 227
    return (tmp___0);
  }
  {
#line 228
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 228
  if (tmp___3 == 0) {
#line 229
    if ((int const   )*(msgid + 0) == 96) {
#line 229
      tmp___2 = "\241\ae";
    } else {
#line 229
      tmp___2 = "\241\257";
    }
#line 229
    return (tmp___2);
  }
#line 231
  if ((unsigned int )s == 9U) {
#line 231
    tmp___4 = "\"";
  } else {
#line 231
    tmp___4 = "\'";
  }
#line 231
  return (tmp___4);
}
}
#line 247 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___0 , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  size_t orig_buffersize ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  _Bool pending_shell_escape_end ;
  _Bool encountered_single_quote ;
  _Bool all_c_and_shell_quote_compat ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  _Bool escaping ;
  _Bool c_and_shell_quote_compat ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;

  {
  {
#line 256
  len = (size_t )0;
#line 257
  orig_buffersize = (size_t )0;
#line 258
  quote_string = (char const   *)0;
#line 259
  quote_string_len = (size_t )0;
#line 260
  backslash_escapes = (_Bool)0;
#line 261
  tmp = __ctype_get_mb_cur_max();
#line 261
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 262
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 263
  pending_shell_escape_end = (_Bool)0;
#line 264
  encountered_single_quote = (_Bool)0;
#line 265
  all_c_and_shell_quote_compat = (_Bool)1;
  }
  process_input: 
  {
#line 310
  if ((unsigned int )quoting_style == 6U) {
#line 310
    goto case_6;
  }
#line 314
  if ((unsigned int )quoting_style == 5U) {
#line 314
    goto case_5;
  }
#line 322
  if ((unsigned int )quoting_style == 7U) {
#line 322
    goto case_7;
  }
#line 329
  if ((unsigned int )quoting_style == 10U) {
#line 329
    goto case_10;
  }
#line 329
  if ((unsigned int )quoting_style == 9U) {
#line 329
    goto case_10;
  }
#line 329
  if ((unsigned int )quoting_style == 8U) {
#line 329
    goto case_10;
  }
#line 366
  if ((unsigned int )quoting_style == 3U) {
#line 366
    goto case_3;
  }
#line 369
  if ((unsigned int )quoting_style == 1U) {
#line 369
    goto case_1;
  }
#line 372
  if ((unsigned int )quoting_style == 4U) {
#line 372
    goto case_4;
  }
#line 376
  if ((unsigned int )quoting_style == 2U) {
#line 376
    goto case_2;
  }
#line 384
  if ((unsigned int )quoting_style == 0U) {
#line 384
    goto case_0;
  }
#line 388
  goto switch_default;
  case_6: /* CIL Label */ 
#line 311
  quoting_style = (enum quoting_style )5;
#line 312
  elide_outer_quotes = (_Bool)1;
  case_5: /* CIL Label */ 
#line 315
  if (! elide_outer_quotes) {
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
#line 316
      if (len < buffersize) {
#line 316
        *(buffer___0 + len) = (char )'\"';
      }
#line 316
      len ++;
#line 316
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 317
  backslash_escapes = (_Bool)1;
#line 318
  quote_string = "\"";
#line 319
  quote_string_len = (size_t )1;
#line 320
  goto switch_break;
  case_7: /* CIL Label */ 
#line 323
  backslash_escapes = (_Bool)1;
#line 324
  elide_outer_quotes = (_Bool)0;
#line 325
  goto switch_break;
  case_10: /* CIL Label */ 
  case_9: /* CIL Label */ 
  case_8: /* CIL Label */ 
#line 331
  if ((unsigned int )quoting_style != 10U) {
    {
#line 354
    left_quote = gettext_quote("`", quoting_style);
#line 355
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 357
  if (! elide_outer_quotes) {
#line 358
    quote_string = left_quote;
    {
#line 358
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 358
      if (! *quote_string) {
#line 358
        goto while_break___0;
      }
      {
#line 359
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 359
        if (len < buffersize) {
#line 359
          *(buffer___0 + len) = (char )*quote_string;
        }
#line 359
        len ++;
#line 359
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 358
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 360
  backslash_escapes = (_Bool)1;
#line 361
  quote_string = right_quote;
#line 362
  quote_string_len = strlen(quote_string);
  }
#line 364
  goto switch_break;
  case_3: /* CIL Label */ 
#line 367
  backslash_escapes = (_Bool)1;
  case_1: /* CIL Label */ 
#line 370
  elide_outer_quotes = (_Bool)1;
  case_4: /* CIL Label */ 
#line 373
  if (! elide_outer_quotes) {
#line 374
    backslash_escapes = (_Bool)1;
  }
  case_2: /* CIL Label */ 
#line 377
  quoting_style = (enum quoting_style )2;
#line 378
  if (! elide_outer_quotes) {
    {
#line 379
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 379
      if (len < buffersize) {
#line 379
        *(buffer___0 + len) = (char )'\'';
      }
#line 379
      len ++;
#line 379
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 380
  quote_string = "\'";
#line 381
  quote_string_len = (size_t )1;
#line 382
  goto switch_break;
  case_0: /* CIL Label */ 
#line 385
  elide_outer_quotes = (_Bool)0;
#line 386
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 389
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 392
  i = (size_t )0;
  {
#line 392
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 392
    if (argsize == 0xffffffffffffffffUL) {
#line 392
      tmp___7 = (int const   )*(arg + i) == 0;
    } else {
#line 392
      tmp___7 = i == argsize;
    }
#line 392
    if (tmp___7) {
#line 392
      goto while_break___3;
    }
#line 396
    is_right_quote = (_Bool)0;
#line 397
    escaping = (_Bool)0;
#line 398
    c_and_shell_quote_compat = (_Bool)0;
#line 400
    if (backslash_escapes) {
#line 400
      if ((unsigned int )quoting_style != 2U) {
#line 400
        if (quote_string_len) {
#line 400
          if (argsize == 0xffffffffffffffffUL) {
#line 400
            if (1UL < quote_string_len) {
              {
#line 400
              argsize = strlen(arg);
#line 400
              tmp___0 = argsize;
              }
            } else {
#line 400
              tmp___0 = argsize;
            }
          } else {
#line 400
            tmp___0 = argsize;
          }
#line 400
          if (i + quote_string_len <= tmp___0) {
            {
#line 400
            tmp___1 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                             quote_string_len);
            }
#line 400
            if (tmp___1 == 0) {
#line 411
              if (elide_outer_quotes) {
#line 412
                goto force_outer_quoting_style;
              }
#line 413
              is_right_quote = (_Bool)1;
            }
          }
        }
      }
    }
#line 416
    c = (unsigned char )*(arg + i);
    {
#line 419
    if ((int )c == 0) {
#line 419
      goto case_0___0;
    }
#line 445
    if ((int )c == 63) {
#line 445
      goto case_63;
    }
#line 483
    if ((int )c == 7) {
#line 483
      goto case_7___0;
    }
#line 484
    if ((int )c == 8) {
#line 484
      goto case_8___0;
    }
#line 485
    if ((int )c == 12) {
#line 485
      goto case_12;
    }
#line 486
    if ((int )c == 10) {
#line 486
      goto case_10___0;
    }
#line 487
    if ((int )c == 13) {
#line 487
      goto case_13;
    }
#line 488
    if ((int )c == 9) {
#line 488
      goto case_9___0;
    }
#line 489
    if ((int )c == 11) {
#line 489
      goto case_11;
    }
#line 490
    if ((int )c == 92) {
#line 490
      goto case_92;
    }
#line 517
    if ((int )c == 125) {
#line 517
      goto case_125;
    }
#line 517
    if ((int )c == 123) {
#line 517
      goto case_125;
    }
#line 521
    if ((int )c == 126) {
#line 521
      goto case_126;
    }
#line 521
    if ((int )c == 35) {
#line 521
      goto case_126;
    }
#line 525
    if ((int )c == 32) {
#line 525
      goto case_32;
    }
#line 535
    if ((int )c == 124) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 96) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 94) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 91) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 62) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 61) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 60) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 59) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 42) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 41) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 40) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 38) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 36) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 34) {
#line 535
      goto case_124;
    }
#line 535
    if ((int )c == 33) {
#line 535
      goto case_124;
    }
#line 545
    if ((int )c == 39) {
#line 545
      goto case_39___0;
    }
#line 580
    if ((int )c == 122) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 121) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 120) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 119) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 118) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 117) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 116) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 115) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 114) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 113) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 112) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 111) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 110) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 109) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 108) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 107) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 106) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 105) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 104) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 103) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 102) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 101) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 100) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 99) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 98) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 97) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 95) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 93) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 90) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 89) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 88) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 87) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 86) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 85) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 84) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 83) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 82) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 81) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 80) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 79) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 78) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 77) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 76) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 75) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 74) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 73) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 72) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 71) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 70) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 69) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 68) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 67) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 66) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 65) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 58) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 57) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 56) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 55) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 54) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 53) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 52) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 51) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 50) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 49) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 48) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 47) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 46) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 45) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 44) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 43) {
#line 580
      goto case_122;
    }
#line 580
    if ((int )c == 37) {
#line 580
      goto case_122;
    }
#line 594
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 420
    if (backslash_escapes) {
      {
#line 422
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 422
        if (elide_outer_quotes) {
#line 422
          goto force_outer_quoting_style;
        }
#line 422
        escaping = (_Bool)1;
#line 422
        if ((unsigned int )quoting_style == 2U) {
#line 422
          if (! pending_shell_escape_end) {
            {
#line 422
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'\'';
              }
#line 422
              len ++;
#line 422
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 422
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'$';
              }
#line 422
              len ++;
#line 422
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
            {
#line 422
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 422
              if (len < buffersize) {
#line 422
                *(buffer___0 + len) = (char )'\'';
              }
#line 422
              len ++;
#line 422
              goto while_break___7;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 422
            pending_shell_escape_end = (_Bool)1;
          }
        }
        {
#line 422
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 422
          if (len < buffersize) {
#line 422
            *(buffer___0 + len) = (char )'\\';
          }
#line 422
          len ++;
#line 422
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 422
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 429
      if ((unsigned int )quoting_style != 2U) {
#line 429
        if (i + 1UL < argsize) {
#line 429
          if (48 <= (int )*(arg + (i + 1UL))) {
#line 429
            if ((int const   )*(arg + (i + 1UL)) <= 57) {
              {
#line 432
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 432
                if (len < buffersize) {
#line 432
                  *(buffer___0 + len) = (char )'0';
                }
#line 432
                len ++;
#line 432
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 433
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 433
                if (len < buffersize) {
#line 433
                  *(buffer___0 + len) = (char )'0';
                }
#line 433
                len ++;
#line 433
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
      }
#line 435
      c = (unsigned char )'0';
    } else
#line 441
    if (flags & 1) {
#line 442
      goto __Cont;
    }
#line 443
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 448
    if ((unsigned int )quoting_style == 2U) {
#line 448
      goto case_2___0;
    }
#line 453
    if ((unsigned int )quoting_style == 5U) {
#line 453
      goto case_5___0;
    }
#line 478
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 449
    if (elide_outer_quotes) {
#line 450
      goto force_outer_quoting_style;
    }
#line 451
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
#line 454
    if (flags & 4) {
#line 454
      if (i + 2UL < argsize) {
#line 454
        if ((int const   )*(arg + (i + 1UL)) == 63) {
          {
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 62) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 61) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 60) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 47) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 45) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 41) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 40) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 39) {
#line 460
            goto case_62;
          }
#line 460
          if ((int const   )*(arg + (i + 2UL)) == 33) {
#line 460
            goto case_62;
          }
#line 473
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 463
          if (elide_outer_quotes) {
#line 464
            goto force_outer_quoting_style;
          }
#line 465
          c = (unsigned char )*(arg + (i + 2UL));
#line 466
          i += 2UL;
          {
#line 467
          while (1) {
            while_continue___11: /* CIL Label */ ;
#line 467
            if (len < buffersize) {
#line 467
              *(buffer___0 + len) = (char )'?';
            }
#line 467
            len ++;
#line 467
            goto while_break___11;
          }
          while_break___11: /* CIL Label */ ;
          }
          {
#line 468
          while (1) {
            while_continue___12: /* CIL Label */ ;
#line 468
            if (len < buffersize) {
#line 468
              *(buffer___0 + len) = (char )'\"';
            }
#line 468
            len ++;
#line 468
            goto while_break___12;
          }
          while_break___12: /* CIL Label */ ;
          }
          {
#line 469
          while (1) {
            while_continue___13: /* CIL Label */ ;
#line 469
            if (len < buffersize) {
#line 469
              *(buffer___0 + len) = (char )'\"';
            }
#line 469
            len ++;
#line 469
            goto while_break___13;
          }
          while_break___13: /* CIL Label */ ;
          }
          {
#line 470
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 470
            if (len < buffersize) {
#line 470
              *(buffer___0 + len) = (char )'?';
            }
#line 470
            len ++;
#line 470
            goto while_break___14;
          }
          while_break___14: /* CIL Label */ ;
          }
#line 471
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 474
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 476
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 479
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 481
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 483
    esc = (unsigned char )'a';
#line 483
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 484
    esc = (unsigned char )'b';
#line 484
    goto c_escape;
    case_12: /* CIL Label */ 
#line 485
    esc = (unsigned char )'f';
#line 485
    goto c_escape;
    case_10___0: /* CIL Label */ 
#line 486
    esc = (unsigned char )'n';
#line 486
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 487
    esc = (unsigned char )'r';
#line 487
    goto c_and_shell_escape;
    case_9___0: /* CIL Label */ 
#line 488
    esc = (unsigned char )'t';
#line 488
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 489
    esc = (unsigned char )'v';
#line 489
    goto c_escape;
    case_92: /* CIL Label */ 
#line 490
    esc = c;
#line 492
    if ((unsigned int )quoting_style == 2U) {
#line 494
      if (elide_outer_quotes) {
#line 495
        goto force_outer_quoting_style;
      }
#line 496
      goto store_c;
    }
#line 501
    if (backslash_escapes) {
#line 501
      if (elide_outer_quotes) {
#line 501
        if (quote_string_len) {
#line 502
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 505
    if ((unsigned int )quoting_style == 2U) {
#line 505
      if (elide_outer_quotes) {
#line 507
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 510
    if (backslash_escapes) {
#line 512
      c = esc;
#line 513
      goto store_escape;
    }
#line 515
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 518
    if (argsize == 0xffffffffffffffffUL) {
#line 518
      tmp___2 = (int const   )*(arg + 1) == 0;
    } else {
#line 518
      tmp___2 = argsize == 1UL;
    }
#line 518
    if (! tmp___2) {
#line 519
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 522
    if (i != 0UL) {
#line 523
      goto switch_break___0;
    }
    case_32: /* CIL Label */ 
#line 526
    c_and_shell_quote_compat = (_Bool)1;
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
#line 540
    if ((unsigned int )quoting_style == 2U) {
#line 540
      if (elide_outer_quotes) {
#line 542
        goto force_outer_quoting_style;
      }
    }
#line 543
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 546
    encountered_single_quote = (_Bool)1;
#line 547
    c_and_shell_quote_compat = (_Bool)1;
#line 548
    if ((unsigned int )quoting_style == 2U) {
#line 550
      if (elide_outer_quotes) {
#line 551
        goto force_outer_quoting_style;
      }
#line 553
      if (buffersize) {
#line 553
        if (! orig_buffersize) {
#line 558
          orig_buffersize = buffersize;
#line 559
          buffersize = (size_t )0;
        }
      }
      {
#line 562
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 562
        if (len < buffersize) {
#line 562
          *(buffer___0 + len) = (char )'\'';
        }
#line 562
        len ++;
#line 562
        goto while_break___15;
      }
      while_break___15: /* CIL Label */ ;
      }
      {
#line 563
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 563
        if (len < buffersize) {
#line 563
          *(buffer___0 + len) = (char )'\\';
        }
#line 563
        len ++;
#line 563
        goto while_break___16;
      }
      while_break___16: /* CIL Label */ ;
      }
      {
#line 564
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 564
        if (len < buffersize) {
#line 564
          *(buffer___0 + len) = (char )'\'';
        }
#line 564
        len ++;
#line 564
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 565
      pending_shell_escape_end = (_Bool)0;
    }
#line 567
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 591
    c_and_shell_quote_compat = (_Bool)1;
#line 592
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 606
    if (unibyte_locale) {
      {
#line 608
      m = (size_t )1;
#line 609
      tmp___3 = __ctype_b_loc();
#line 609
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 614
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 616
      m = (size_t )0;
#line 617
      printable = (_Bool)1;
      }
#line 618
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 619
        argsize = strlen(arg);
        }
      }
      {
#line 621
      while (1) {
        while_continue___18: /* CIL Label */ ;
        {
#line 624
        tmp___4 = rpl_mbrtowc(& w, arg + (i + m), argsize - (i + m), & mbstate);
#line 624
        bytes = tmp___4;
        }
#line 626
        if (bytes == 0UL) {
#line 627
          goto while_break___18;
        } else
#line 628
        if (bytes == 0xffffffffffffffffUL) {
#line 630
          printable = (_Bool)0;
#line 631
          goto while_break___18;
        } else
#line 633
        if (bytes == 0xfffffffffffffffeUL) {
#line 635
          printable = (_Bool)0;
          {
#line 636
          while (1) {
            while_continue___19: /* CIL Label */ ;
#line 636
            if (i + m < argsize) {
#line 636
              if (! *(arg + (i + m))) {
#line 636
                goto while_break___19;
              }
            } else {
#line 636
              goto while_break___19;
            }
#line 637
            m ++;
          }
          while_break___19: /* CIL Label */ ;
          }
#line 638
          goto while_break___18;
        } else {
#line 646
          if (elide_outer_quotes) {
#line 646
            if ((unsigned int )quoting_style == 2U) {
#line 650
              j = (size_t )1;
              {
#line 650
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 650
                if (! (j < bytes)) {
#line 650
                  goto while_break___20;
                }
                {
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 124) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 96) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 94) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 92) {
#line 654
                  goto case_124___0;
                }
#line 654
                if ((int const   )*(arg + ((i + m) + j)) == 91) {
#line 654
                  goto case_124___0;
                }
#line 657
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 655
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 658
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 650
                j ++;
              }
              while_break___20: /* CIL Label */ ;
              }
            }
          }
          {
#line 662
          tmp___5 = iswprint((wint_t )w);
          }
#line 662
          if (! tmp___5) {
#line 663
            printable = (_Bool)0;
          }
#line 664
          m += bytes;
        }
        {
#line 621
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 621
        if (tmp___6) {
#line 621
          goto while_break___18;
        }
      }
      while_break___18: /* CIL Label */ ;
      }
    }
#line 670
    c_and_shell_quote_compat = printable;
#line 672
    if (1UL < m) {
#line 672
      goto _L___0;
    } else
#line 672
    if (backslash_escapes) {
#line 672
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 676
        ilim = i + m;
        {
#line 678
        while (1) {
          while_continue___21: /* CIL Label */ ;
#line 680
          if (backslash_escapes) {
#line 680
            if (! printable) {
              {
#line 682
              while (1) {
                while_continue___22: /* CIL Label */ ;
#line 682
                if (elide_outer_quotes) {
#line 682
                  goto force_outer_quoting_style;
                }
#line 682
                escaping = (_Bool)1;
#line 682
                if ((unsigned int )quoting_style == 2U) {
#line 682
                  if (! pending_shell_escape_end) {
                    {
#line 682
                    while (1) {
                      while_continue___23: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___23;
                    }
                    while_break___23: /* CIL Label */ ;
                    }
                    {
#line 682
                    while (1) {
                      while_continue___24: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'$';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___24;
                    }
                    while_break___24: /* CIL Label */ ;
                    }
                    {
#line 682
                    while (1) {
                      while_continue___25: /* CIL Label */ ;
#line 682
                      if (len < buffersize) {
#line 682
                        *(buffer___0 + len) = (char )'\'';
                      }
#line 682
                      len ++;
#line 682
                      goto while_break___25;
                    }
                    while_break___25: /* CIL Label */ ;
                    }
#line 682
                    pending_shell_escape_end = (_Bool)1;
                  }
                }
                {
#line 682
                while (1) {
                  while_continue___26: /* CIL Label */ ;
#line 682
                  if (len < buffersize) {
#line 682
                    *(buffer___0 + len) = (char )'\\';
                  }
#line 682
                  len ++;
#line 682
                  goto while_break___26;
                }
                while_break___26: /* CIL Label */ ;
                }
#line 682
                goto while_break___22;
              }
              while_break___22: /* CIL Label */ ;
              }
              {
#line 683
              while (1) {
                while_continue___27: /* CIL Label */ ;
#line 683
                if (len < buffersize) {
#line 683
                  *(buffer___0 + len) = (char )(48 + ((int )c >> 6));
                }
#line 683
                len ++;
#line 683
                goto while_break___27;
              }
              while_break___27: /* CIL Label */ ;
              }
              {
#line 684
              while (1) {
                while_continue___28: /* CIL Label */ ;
#line 684
                if (len < buffersize) {
#line 684
                  *(buffer___0 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 684
                len ++;
#line 684
                goto while_break___28;
              }
              while_break___28: /* CIL Label */ ;
              }
#line 685
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 680
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 687
          if (is_right_quote) {
            {
#line 689
            while (1) {
              while_continue___29: /* CIL Label */ ;
#line 689
              if (len < buffersize) {
#line 689
                *(buffer___0 + len) = (char )'\\';
              }
#line 689
              len ++;
#line 689
              goto while_break___29;
            }
            while_break___29: /* CIL Label */ ;
            }
#line 690
            is_right_quote = (_Bool)0;
          }
#line 692
          if (ilim <= i + 1UL) {
#line 693
            goto while_break___21;
          }
          {
#line 694
          while (1) {
            while_continue___30: /* CIL Label */ ;
#line 694
            if (pending_shell_escape_end) {
#line 694
              if (! escaping) {
                {
#line 694
                while (1) {
                  while_continue___31: /* CIL Label */ ;
#line 694
                  if (len < buffersize) {
#line 694
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 694
                  len ++;
#line 694
                  goto while_break___31;
                }
                while_break___31: /* CIL Label */ ;
                }
                {
#line 694
                while (1) {
                  while_continue___32: /* CIL Label */ ;
#line 694
                  if (len < buffersize) {
#line 694
                    *(buffer___0 + len) = (char )'\'';
                  }
#line 694
                  len ++;
#line 694
                  goto while_break___32;
                }
                while_break___32: /* CIL Label */ ;
                }
#line 694
                pending_shell_escape_end = (_Bool)0;
              }
            }
#line 694
            goto while_break___30;
          }
          while_break___30: /* CIL Label */ ;
          }
          {
#line 695
          while (1) {
            while_continue___33: /* CIL Label */ ;
#line 695
            if (len < buffersize) {
#line 695
              *(buffer___0 + len) = (char )c;
            }
#line 695
            len ++;
#line 695
            goto while_break___33;
          }
          while_break___33: /* CIL Label */ ;
          }
#line 696
          i ++;
#line 696
          c = (unsigned char )*(arg + i);
        }
        while_break___21: /* CIL Label */ ;
        }
#line 699
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 704
    if (backslash_escapes) {
#line 704
      if ((unsigned int )quoting_style != 2U) {
#line 704
        goto _L___3;
      } else {
#line 704
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 704
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 704
      if (quote_these_too) {
#line 704
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 704
          goto _L___2;
        }
      } else {
#line 704
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 704
    if (! is_right_quote) {
#line 709
      goto store_c;
    }
    store_escape: 
    {
#line 712
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 712
      if (elide_outer_quotes) {
#line 712
        goto force_outer_quoting_style;
      }
#line 712
      escaping = (_Bool)1;
#line 712
      if ((unsigned int )quoting_style == 2U) {
#line 712
        if (! pending_shell_escape_end) {
          {
#line 712
          while (1) {
            while_continue___35: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'\'';
            }
#line 712
            len ++;
#line 712
            goto while_break___35;
          }
          while_break___35: /* CIL Label */ ;
          }
          {
#line 712
          while (1) {
            while_continue___36: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'$';
            }
#line 712
            len ++;
#line 712
            goto while_break___36;
          }
          while_break___36: /* CIL Label */ ;
          }
          {
#line 712
          while (1) {
            while_continue___37: /* CIL Label */ ;
#line 712
            if (len < buffersize) {
#line 712
              *(buffer___0 + len) = (char )'\'';
            }
#line 712
            len ++;
#line 712
            goto while_break___37;
          }
          while_break___37: /* CIL Label */ ;
          }
#line 712
          pending_shell_escape_end = (_Bool)1;
        }
      }
      {
#line 712
      while (1) {
        while_continue___38: /* CIL Label */ ;
#line 712
        if (len < buffersize) {
#line 712
          *(buffer___0 + len) = (char )'\\';
        }
#line 712
        len ++;
#line 712
        goto while_break___38;
      }
      while_break___38: /* CIL Label */ ;
      }
#line 712
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    store_c: 
    {
#line 715
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 715
      if (pending_shell_escape_end) {
#line 715
        if (! escaping) {
          {
#line 715
          while (1) {
            while_continue___40: /* CIL Label */ ;
#line 715
            if (len < buffersize) {
#line 715
              *(buffer___0 + len) = (char )'\'';
            }
#line 715
            len ++;
#line 715
            goto while_break___40;
          }
          while_break___40: /* CIL Label */ ;
          }
          {
#line 715
          while (1) {
            while_continue___41: /* CIL Label */ ;
#line 715
            if (len < buffersize) {
#line 715
              *(buffer___0 + len) = (char )'\'';
            }
#line 715
            len ++;
#line 715
            goto while_break___41;
          }
          while_break___41: /* CIL Label */ ;
          }
#line 715
          pending_shell_escape_end = (_Bool)0;
        }
      }
#line 715
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    {
#line 716
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 716
      if (len < buffersize) {
#line 716
        *(buffer___0 + len) = (char )c;
      }
#line 716
      len ++;
#line 716
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
#line 718
    if (! c_and_shell_quote_compat) {
#line 719
      all_c_and_shell_quote_compat = (_Bool)0;
    }
    __Cont: /* CIL Label */ 
#line 392
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 722
  if (len == 0UL) {
#line 722
    if ((unsigned int )quoting_style == 2U) {
#line 722
      if (elide_outer_quotes) {
#line 724
        goto force_outer_quoting_style;
      }
    }
  }
#line 730
  if ((unsigned int )quoting_style == 2U) {
#line 730
    if (! elide_outer_quotes) {
#line 730
      if (encountered_single_quote) {
#line 733
        if (all_c_and_shell_quote_compat) {
          {
#line 734
          tmp___8 = quotearg_buffer_restyled(buffer___0, orig_buffersize, arg, argsize,
                                             (enum quoting_style )5, flags, quote_these_too,
                                             left_quote, right_quote);
          }
#line 734
          return (tmp___8);
        } else
#line 738
        if (! buffersize) {
#line 738
          if (orig_buffersize) {
#line 741
            buffersize = orig_buffersize;
#line 742
            len = (size_t )0;
#line 743
            goto process_input;
          }
        }
      }
    }
  }
#line 747
  if (quote_string) {
#line 747
    if (! elide_outer_quotes) {
      {
#line 748
      while (1) {
        while_continue___43: /* CIL Label */ ;
#line 748
        if (! *quote_string) {
#line 748
          goto while_break___43;
        }
        {
#line 749
        while (1) {
          while_continue___44: /* CIL Label */ ;
#line 749
          if (len < buffersize) {
#line 749
            *(buffer___0 + len) = (char )*quote_string;
          }
#line 749
          len ++;
#line 749
          goto while_break___44;
        }
        while_break___44: /* CIL Label */ ;
        }
#line 748
        quote_string ++;
      }
      while_break___43: /* CIL Label */ ;
      }
    }
  }
#line 751
  if (len < buffersize) {
#line 752
    *(buffer___0 + len) = (char )'\000';
  }
#line 753
  return (len);
  force_outer_quoting_style: 
#line 758
  if ((unsigned int )quoting_style == 2U) {
#line 758
    if (backslash_escapes) {
#line 759
      quoting_style = (enum quoting_style )4;
    }
  }
  {
#line 760
  tmp___9 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 760
  return (tmp___9);
}
}
#line 775 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
size_t quotearg_buffer(char *buffer___0 , size_t buffersize , char const   *arg ,
                       size_t argsize , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 780
  if (o) {
#line 780
    tmp = o;
  } else {
#line 780
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 780
  p = tmp;
#line 781
  tmp___0 = __errno_location();
#line 781
  e = *tmp___0;
#line 782
  tmp___1 = quotearg_buffer_restyled(buffer___0, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 782
  r = tmp___1;
#line 785
  tmp___2 = __errno_location();
#line 785
  *tmp___2 = e;
  }
#line 786
  return (r);
}
}
#line 790 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
  {
#line 794
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
  }
#line 794
  return (tmp);
}
}
#line 803 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 807
  if (o) {
#line 807
    tmp = o;
  } else {
#line 807
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 807
  p = tmp;
#line 808
  tmp___0 = __errno_location();
#line 808
  e = *tmp___0;
  }
#line 810
  if (size) {
#line 810
    tmp___1 = 0;
  } else {
#line 810
    tmp___1 = 1;
  }
  {
#line 810
  flags = (int )(p->flags | (int const   )tmp___1);
#line 811
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 811
  bufsize = tmp___2 + 1UL;
#line 815
  tmp___3 = xcharalloc(bufsize);
#line 815
  buf = tmp___3;
#line 816
  quotearg_buffer_restyled(buf, bufsize, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 819
  tmp___4 = __errno_location();
#line 819
  *tmp___4 = e;
  }
#line 820
  if (size) {
#line 821
    *size = bufsize - 1UL;
  }
#line 822
  return (buf);
}
}
#line 834 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static char slot0[256]  ;
#line 835 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static int nslots  =    1;
#line 836 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 837 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 839 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  int i ;

  {
#line 842
  sv = slotvec;
#line 844
  i = 1;
  {
#line 844
  while (1) {
    while_continue: /* CIL Label */ ;
#line 844
    if (! (i < nslots)) {
#line 844
      goto while_break;
    }
    {
#line 845
    free((void *)(sv + i)->val);
#line 844
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 846
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 848
    free((void *)(sv + 0)->val);
#line 849
    slotvec0.size = sizeof(slot0);
#line 850
    slotvec0.val = slot0;
    }
  }
#line 852
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 854
    free((void *)sv);
#line 855
    slotvec = & slotvec0;
    }
  }
#line 857
  nslots = 1;
#line 858
  return;
}
}
#line 868 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  struct slotvec *sv ;
  _Bool preallocated ;
  unsigned long tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 872
  tmp = __errno_location();
#line 872
  e = *tmp;
#line 874
  sv = slotvec;
  }
#line 876
  if (n < 0) {
    {
#line 877
    abort();
    }
  }
#line 879
  if (nslots <= n) {
#line 881
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 883
    if (2147483647UL < 9223372036854775807UL / sizeof(*sv)) {
#line 883
      tmp___0 = 2147483647UL;
    } else {
#line 883
      tmp___0 = 9223372036854775807UL / sizeof(*sv);
    }
#line 883
    if (tmp___0 <= (unsigned long )n) {
      {
#line 884
      xalloc_die();
      }
    }
#line 886
    if (preallocated) {
#line 886
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 886
      tmp___1 = sv;
    }
    {
#line 886
    tmp___2 = xrealloc((void *)tmp___1, (unsigned long )(n + 1) * sizeof(*sv));
#line 886
    sv = (struct slotvec *)tmp___2;
#line 886
    slotvec = sv;
    }
#line 887
    if (preallocated) {
#line 888
      *sv = slotvec0;
    }
    {
#line 889
    memset((void *)(sv + nslots), 0, (unsigned long )((n + 1) - nslots) * sizeof(*sv));
#line 890
    nslots = n + 1;
    }
  }
  {
#line 894
  size = (sv + n)->size;
#line 895
  val = (sv + n)->val;
#line 897
  flags = (int )(options->flags | 1);
#line 898
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 898
  qsize = tmp___3;
  }
#line 904
  if (size <= qsize) {
#line 906
    size = qsize + 1UL;
#line 906
    (sv + n)->size = size;
#line 907
    if ((unsigned long )val != (unsigned long )(slot0)) {
      {
#line 908
      free((void *)val);
      }
    }
    {
#line 909
    val = xcharalloc(size);
#line 909
    (sv + n)->val = val;
#line 910
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
    }
  }
  {
#line 916
  tmp___4 = __errno_location();
#line 916
  *tmp___4 = e;
  }
#line 917
  return (val);
}
}
#line 921 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 924
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 924
  return (tmp);
}
}
#line 927 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 930
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 930
  return (tmp);
}
}
#line 933 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 936
  tmp = quotearg_n(0, arg);
  }
#line 936
  return (tmp);
}
}
#line 939 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 942
  tmp = quotearg_n_mem(0, arg, argsize);
  }
#line 942
  return (tmp);
}
}
#line 945 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 948
  tmp = quoting_options_from_style(s);
#line 948
  o = tmp;
#line 949
  tmp___0 = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& o));
  }
#line 949
  return (tmp___0);
}
}
#line 952 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 956
  tmp = quoting_options_from_style(s);
#line 956
  o = tmp;
#line 957
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 957
  return (tmp___0);
}
}
#line 960 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 963
  tmp = quotearg_n_style(0, s, arg);
  }
#line 963
  return (tmp);
}
}
#line 966 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 969
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
  }
#line 969
  return (tmp);
}
}
#line 972 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 976
  options = default_quoting_options;
#line 977
  set_char_quoting(& options, ch, 1);
#line 978
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
  }
#line 978
  return (tmp);
}
}
#line 981 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 984
  tmp = quotearg_char_mem(arg, 0xffffffffffffffffUL, ch);
  }
#line 984
  return (tmp);
}
}
#line 987 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 990
  tmp = quotearg_char(arg, (char )':');
  }
#line 990
  return (tmp);
}
}
#line 993 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 996
  tmp = quotearg_char_mem(arg, argsize, (char )':');
  }
#line 996
  return (tmp);
}
}
#line 999 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n_style_colon(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
  {
#line 1003
  options = quoting_options_from_style(s);
#line 1004
  set_char_quoting(& options, (char )':', 1);
#line 1005
  tmp = quotearg_n_options(n, arg, 0xffffffffffffffffUL, (struct quoting_options  const  *)(& options));
  }
#line 1005
  return (tmp);
}
}
#line 1008 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1012
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, 0xffffffffffffffffUL);
  }
#line 1012
  return (tmp);
}
}
#line 1016 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
  {
#line 1021
  o = default_quoting_options;
#line 1022
  set_custom_quoting(& o, left_quote, right_quote);
#line 1023
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
  }
#line 1023
  return (tmp);
}
}
#line 1026 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
  {
#line 1030
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
  }
#line 1030
  return (tmp);
}
}
#line 1033 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1037
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
  }
#line 1037
  return (tmp);
}
}
#line 1043 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )8, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 1051 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 1054
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 1054
  return ((char const   *)tmp);
}
}
#line 1057 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char const   *quote_mem(char const   *arg , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 1060
  tmp = quote_n_mem(0, arg, argsize);
  }
#line 1060
  return (tmp);
}
}
#line 1063 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char const   *quote_n(int n , char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1066
  tmp = quote_n_mem(n, arg, 0xffffffffffffffffUL);
  }
#line 1066
  return (tmp);
}
}
#line 1069 "/home/khheo/project/benchmark/sed-4.3/lib/quotearg.c"
char const   *quote(char const   *arg ) 
{ 
  char const   *tmp ;

  {
  {
#line 1072
  tmp = quote_n(0, arg);
  }
#line 1072
  return (tmp);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 296
void free_permission_context(struct permission_context *ctx )  __attribute__((__const__)) ;
#line 302
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/sed-4.3/lib/qset-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ 
  struct permission_context ctx ;
  int ret ;

  {
  {
#line 44
  memset((void *)(& ctx), 0, sizeof(ctx));
#line 45
  ctx.mode = mode;
#line 46
  ret = set_permissions(& ctx, name, desc);
#line 47
  free_permission_context(& ctx);
  }
#line 48
  return (ret);
}
}
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/acl.h"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) ;
#line 66 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 294
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) ;
#line 302
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/sed-4.3/lib/qcopy-acl.c"
int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
              int dest_desc , mode_t mode ) 
{ 
  struct permission_context ctx ;
  int ret ;

  {
  {
#line 45
  ret = get_permissions(src_name, source_desc, mode, & ctx);
  }
#line 46
  if (ret != 0) {
#line 47
    return (-2);
  }
  {
#line 48
  ret = set_permissions(& ctx, dst_name, dest_desc);
#line 49
  free_permission_context(& ctx);
  }
#line 50
  return (ret);
}
}
#line 32 "/home/khheo/project/benchmark/sed-4.3/lib/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 33 "/home/khheo/project/benchmark/sed-4.3/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/khheo/project/benchmark/sed-4.3/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 213 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.h"
void _obstack_newchunk(struct obstack *h , size_t length ) ;
#line 214
void _obstack_free(struct obstack *h , void *obj ) ;
#line 215
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) ;
#line 218
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) ;
#line 222
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 230
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 83 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
static void *call_chunkfun(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
static void call_freefun(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
static int _obstack_begin_worker(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 149 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) 
{ 
  int tmp ;

  {
  {
#line 155
  h->chunkfun.plain = chunkfun;
#line 156
  h->freefun.plain = freefun;
#line 157
  h->use_extra_arg = 0U;
#line 158
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg ) 
{ 
  int tmp ;

  {
  {
#line 168
  h->chunkfun.extra = chunkfun;
#line 169
  h->freefun.extra = freefun;
#line 170
  h->extra_arg = arg;
#line 171
  h->use_extra_arg = 1U;
#line 172
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 172
  return (tmp);
}
}
#line 181 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
void _obstack_newchunk(struct obstack *h , size_t length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  size_t obj_size ;
  char *object_base ;
  size_t sum1 ;
  size_t sum2 ;
  size_t new_size ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 184
  old_chunk = h->chunk;
#line 185
  new_chunk = (struct _obstack_chunk *)0;
#line 186
  obj_size = (size_t )(h->next_free - h->object_base);
#line 190
  sum1 = obj_size + length;
#line 191
  sum2 = sum1 + h->alignment_mask;
#line 192
  new_size = (sum2 + (obj_size >> 3)) + 100UL;
#line 193
  if (new_size < sum2) {
#line 194
    new_size = sum2;
  }
#line 195
  if (new_size < h->chunk_size) {
#line 196
    new_size = h->chunk_size;
  }
#line 199
  if (obj_size <= sum1) {
#line 199
    if (sum1 <= sum2) {
      {
#line 200
      tmp = call_chunkfun(h, new_size);
#line 200
      new_chunk = (struct _obstack_chunk *)tmp;
      }
    }
  }
#line 201
  if (! new_chunk) {
    {
#line 202
    (*obstack_alloc_failed_handler)();
    }
  }
#line 203
  h->chunk = new_chunk;
#line 204
  new_chunk->prev = old_chunk;
#line 205
  tmp___0 = (char *)new_chunk + new_size;
#line 205
  h->chunk_limit = tmp___0;
#line 205
  new_chunk->limit = tmp___0;
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___1 = (char *)new_chunk;
  } else {
#line 208
    tmp___1 = (char *)0;
  }
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___2 = (char *)new_chunk;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
  {
#line 208
  object_base = tmp___1 + (((size_t )(new_chunk->contents - tmp___2) + h->alignment_mask) & ~ h->alignment_mask);
#line 212
  memcpy((void */* __restrict  */)object_base, (void const   */* __restrict  */)h->object_base,
         obj_size);
  }
#line 217
  if (! h->maybe_empty_object) {
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___3 = (char *)old_chunk;
    } else {
#line 217
      tmp___3 = (char *)0;
    }
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___4 = (char *)old_chunk;
    } else {
#line 217
      tmp___4 = (char *)0;
    }
#line 217
    if ((unsigned long )h->object_base == (unsigned long )(tmp___3 + (((size_t )(old_chunk->contents - tmp___4) + h->alignment_mask) & ~ h->alignment_mask))) {
      {
#line 222
      new_chunk->prev = old_chunk->prev;
#line 223
      call_freefun(h, (void *)old_chunk);
      }
    }
  }
#line 226
  h->object_base = object_base;
#line 227
  h->next_free = h->object_base + obj_size;
#line 229
  h->maybe_empty_object = 0U;
#line 230
  return;
}
}
#line 238
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 246
  lp = h->chunk;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 250
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 250
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 250
          goto while_break;
        }
      }
    } else {
#line 250
      goto while_break;
    }
#line 252
    plp = lp->prev;
#line 253
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 261 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 267
  lp = h->chunk;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 271
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 271
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 271
          goto while_break;
        }
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 273
    plp = lp->prev;
#line 274
    call_freefun(h, (void *)lp);
#line 275
    lp = plp;
#line 278
    h->maybe_empty_object = 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (lp) {
#line 282
    tmp = (char *)obj;
#line 282
    h->next_free = tmp;
#line 282
    h->object_base = tmp;
#line 283
    h->chunk_limit = lp->limit;
#line 284
    h->chunk = lp;
  } else
#line 286
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 288
    abort();
    }
  }
#line 289
  return;
}
}
#line 291
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 291 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
size_t _obstack_memory_used(struct obstack *h ) 
{ 
  struct _obstack_chunk *lp ;
  size_t nbytes ;

  {
#line 295
  nbytes = (size_t )0;
#line 297
  lp = h->chunk;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0))) {
#line 297
      goto while_break;
    }
#line 299
    nbytes += (size_t )(lp->limit - (char *)lp);
#line 297
    lp = lp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (nbytes);
}
}
#line 329
static  __attribute__((__noreturn__)) void print_and_abort(void) ;
#line 329 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
static void print_and_abort(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 351 "/home/khheo/project/benchmark/sed-4.3/lib/obstack.c"
 __attribute__((__noreturn__)) void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 296 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 23 "/home/khheo/project/benchmark/sed-4.3/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 333 "/home/khheo/project/benchmark/sed-4.3/lib/mbrtowc.c"
size_t rpl_mbrtowc(wchar_t *pwc , char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t ret ;
  wchar_t wc ;
  unsigned char uc ;
  _Bool tmp ;

  {
#line 353
  if (! pwc) {
#line 354
    pwc = & wc;
  }
  {
#line 388
  ret = mbrtowc((wchar_t */* __restrict  */)pwc, (char const   */* __restrict  */)s,
                n, (mbstate_t */* __restrict  */)ps);
  }
#line 396
  if (0xfffffffffffffffeUL <= ret) {
#line 396
    if (n != 0UL) {
      {
#line 396
      tmp = hard_locale(0);
      }
#line 396
      if (! tmp) {
#line 398
        uc = (unsigned char )*s;
#line 399
        *pwc = (wchar_t )uc;
#line 400
        return ((size_t )1);
      }
    }
  }
#line 404
  return (ret);
}
}
#line 616 "./lib/wchar.h"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) ;
#line 24 "/home/khheo/project/benchmark/sed-4.3/lib/mbrlen.c"
static mbstate_t internal_state  ;
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/mbrlen.c"
size_t rpl_mbrlen(char const   *s , size_t n , mbstate_t *ps ) 
{ 
  size_t tmp ;

  {
#line 29
  if ((unsigned long )ps == (unsigned long )((void *)0)) {
#line 30
    ps = & internal_state;
  }
  {
#line 31
  tmp = rpl_mbrtowc((wchar_t *)((void *)0), s, n, ps);
  }
#line 31
  return (tmp);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 70
void freea(void *p ) ;
#line 69 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 73 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  void *p ;
  void *tmp ;
  size_t slot ;
  union header *h ;

  {
#line 79
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 81
  if (nplus >= n) {
    {
#line 83
    tmp = malloc(nplus);
#line 83
    p = tmp;
    }
#line 85
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 88
      h = (union header *)p;
#line 90
      p = (void *)(h + 1);
#line 93
      h->magic.word = 336984906;
#line 96
      slot = (uintptr_t )p % 257UL;
#line 97
      h->next = mmalloca_results[slot];
#line 98
      mmalloca_results[slot] = p;
#line 100
      return (p);
    }
  }
#line 104
  return ((void *)0);
}
}
#line 115 "/home/khheo/project/benchmark/sed-4.3/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  union header *h ;
  union header *p_begin ;

  {
#line 119
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 125
    if (*((int *)p + -1) == 336984906) {
#line 129
      slot = (uintptr_t )p % 257UL;
#line 130
      chain = & mmalloca_results[slot];
      {
#line 131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 131
          goto while_break;
        }
#line 133
        h = (union header *)p;
#line 134
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 137
          p_begin = h - 1;
#line 138
          *chain = p_begin->next;
#line 139
          free((void *)p_begin);
          }
#line 140
          return;
        }
#line 142
        h = (union header *)*chain;
#line 143
        chain = & (h + -1)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 148
  return;
}
}
#line 47 "./lib/localeinfo.h"
void init_localeinfo(struct localeinfo *localeinfo___0 ) ;
#line 54
int case_folded_counterparts(wchar_t c , wchar_t *folded ) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 169
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/sed-4.3/lib/localeinfo.c"
static _Bool is_using_utf8(void) 
{ 
  wchar_t wc ;
  mbstate_t mbs ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 43
  mbs.__count = 0;
#line 43
  mbs.__value.__wch = 0U;
#line 44
  tmp = rpl_mbrtowc(& wc, "\304\200", (size_t )2, & mbs);
  }
#line 44
  if (tmp == 2UL) {
#line 44
    if (wc == 256) {
#line 44
      tmp___0 = 1;
    } else {
#line 44
      tmp___0 = 0;
    }
  } else {
#line 44
    tmp___0 = 0;
  }
#line 44
  return ((_Bool )tmp___0);
}
}
#line 49 "/home/khheo/project/benchmark/sed-4.3/lib/localeinfo.c"
void init_localeinfo(struct localeinfo *localeinfo___0 ) 
{ 
  int i ;
  size_t tmp ;
  char c ;
  unsigned char uc ;
  mbstate_t s ;
  wchar_t wc ;
  size_t len ;
  size_t tmp___0 ;

  {
  {
#line 54
  tmp = __ctype_get_mb_cur_max();
#line 54
  localeinfo___0->multibyte = (_Bool )(tmp > 1UL);
#line 55
  localeinfo___0->using_utf8 = is_using_utf8();
#line 57
  i = -128;
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i <= 127)) {
#line 57
      goto while_break;
    }
    {
#line 59
    c = (char )i;
#line 60
    uc = (unsigned char )i;
#line 61
    s.__count = 0;
#line 61
    s.__value.__wch = 0U;
#line 63
    tmp___0 = rpl_mbrtowc(& wc, (char const   *)(& c), (size_t )1, & s);
#line 63
    len = tmp___0;
    }
#line 64
    if (len <= 1UL) {
#line 64
      localeinfo___0->sbclen[uc] = (signed char)1;
    } else {
#line 64
      localeinfo___0->sbclen[uc] = (signed char )(- ((int )(- len)));
    }
#line 65
    if (len <= 1UL) {
#line 65
      localeinfo___0->sbctowc[uc] = (wint_t )wc;
    } else {
#line 65
      localeinfo___0->sbctowc[uc] = 4294967295U;
    }
#line 57
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  return;
}
}
#line 74 "/home/khheo/project/benchmark/sed-4.3/lib/localeinfo.c"
static short const   lonesome_lower[19]  = 
#line 74
  {      (short const   )181,      (short const   )305,      (short const   )383,      (short const   )453, 
        (short const   )456,      (short const   )459,      (short const   )498,      (short const   )837, 
        (short const   )962,      (short const   )976,      (short const   )977,      (short const   )981, 
        (short const   )982,      (short const   )1008,      (short const   )1009,      (short const   )1010, 
        (short const   )1013,      (short const   )7835,      (short const   )8126};
#line 95 "/home/khheo/project/benchmark/sed-4.3/lib/localeinfo.c"
int case_folded_counterparts(wchar_t c , wchar_t *folded ) 
{ 
  int i ;
  int n ;
  wint_t uc ;
  wint_t tmp ;
  wint_t lc ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  wint_t tmp___3 ;
  wint_t li ;
  int tmp___4 ;
  wint_t tmp___5 ;

  {
  {
#line 99
  n = 0;
#line 100
  tmp = towupper((wint_t )c);
#line 100
  uc = tmp;
#line 101
  tmp___0 = towlower(uc);
#line 101
  lc = tmp___0;
  }
#line 102
  if (uc != (wint_t )c) {
#line 103
    tmp___1 = n;
#line 103
    n ++;
#line 103
    *(folded + tmp___1) = (wchar_t )uc;
  }
#line 104
  if (lc != uc) {
#line 104
    if (lc != (wint_t )c) {
      {
#line 104
      tmp___3 = towupper(lc);
      }
#line 104
      if (tmp___3 == uc) {
#line 105
        tmp___2 = n;
#line 105
        n ++;
#line 105
        *(folded + tmp___2) = (wchar_t )lc;
      }
    }
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )i < sizeof(lonesome_lower) / sizeof(lonesome_lower[0]))) {
#line 106
      goto while_break;
    }
#line 108
    li = (wint_t )lonesome_lower[i];
#line 109
    if (li != lc) {
#line 109
      if (li != uc) {
#line 109
        if (li != (wint_t )c) {
          {
#line 109
          tmp___5 = towupper(li);
          }
#line 109
          if (tmp___5 == uc) {
#line 110
            tmp___4 = n;
#line 110
            n ++;
#line 110
            *(folded + tmp___4) = (wchar_t )li;
          }
        }
      }
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 112
  return (n);
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int getc_unlocked(FILE *__stream ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 141 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 120 "/home/khheo/project/benchmark/sed-4.3/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 123 "/home/khheo/project/benchmark/sed-4.3/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___0 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1___0[51] ;
  char buf2___0[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 128
  cp = (char const   *)charset_aliases;
#line 129
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    base = "charset.alias";
#line 138
    tmp = getenv("CHARSETALIASDIR");
#line 138
    dir = (char const   *)tmp;
    }
#line 139
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 140
      dir = "/usr/local/lib";
    } else
#line 139
    if ((int const   )*(dir + 0) == 0) {
#line 140
      dir = "/usr/local/lib";
    }
    {
#line 144
    tmp___0 = strlen(dir);
#line 144
    dir_len___0 = tmp___0;
#line 145
    tmp___1 = strlen(base);
#line 145
    base_len___0 = tmp___1;
    }
#line 146
    if (dir_len___0 > 0UL) {
#line 146
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 146
        tmp___2 = 1;
      } else {
#line 146
        tmp___2 = 0;
      }
    } else {
#line 146
      tmp___2 = 0;
    }
    {
#line 146
    add_slash = tmp___2;
#line 147
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 147
    file_name___0 = (char *)tmp___3;
    }
#line 148
    if ((unsigned long )file_name___0 != (unsigned long )((void *)0)) {
      {
#line 150
      memcpy((void */* __restrict  */)file_name___0, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 151
      if (add_slash) {
#line 152
        *(file_name___0 + dir_len___0) = (char )'/';
      }
      {
#line 153
      memcpy((void */* __restrict  */)((file_name___0 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 157
    if ((unsigned long )file_name___0 == (unsigned long )((void *)0)) {
#line 159
      cp = "";
    } else {
      {
#line 171
      fd = open((char const   *)file_name___0, 131072);
      }
#line 173
      if (fd < 0) {
#line 175
        cp = "";
      } else {
        {
#line 180
        fp = fdopen(fd, "r");
        }
#line 181
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 184
          close(fd);
#line 185
          cp = "";
          }
        } else {
#line 190
          res_ptr = (char *)((void *)0);
#line 191
          res_size = (size_t )0;
          {
#line 193
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 201
            c = getc_unlocked(fp);
            }
#line 202
            if (c == -1) {
#line 203
              goto while_break;
            }
#line 204
            if (c == 10) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 32) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 9) {
#line 205
              goto __Cont;
            }
#line 206
            if (c == 35) {
              {
#line 209
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 210
                c = getc_unlocked(fp);
                }
#line 209
                if (c == -1) {
#line 209
                  goto while_break___0;
                } else
#line 209
                if (c == 10) {
#line 209
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 212
              if (c == -1) {
#line 213
                goto while_break;
              }
#line 214
              goto __Cont;
            }
            {
#line 216
            ungetc(c, fp);
#line 217
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1___0, buf2___0);
            }
#line 217
            if (tmp___4 < 2) {
#line 218
              goto while_break;
            }
            {
#line 219
            l1 = strlen((char const   *)(buf1___0));
#line 220
            l2 = strlen((char const   *)(buf2___0));
#line 221
            old_res_ptr = res_ptr;
            }
#line 222
            if (res_size == 0UL) {
              {
#line 224
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 225
              tmp___5 = malloc(res_size + 1UL);
#line 225
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 229
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 230
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 230
              res_ptr = (char *)tmp___6;
              }
            }
#line 232
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 235
              res_size = (size_t )0;
#line 236
              free((void *)old_res_ptr);
              }
#line 237
              goto while_break;
            }
            {
#line 239
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1___0));
#line 240
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2___0));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 242
          fclose(fp);
          }
#line 243
          if (res_size == 0UL) {
#line 244
            cp = "";
          } else {
#line 247
            *(res_ptr + res_size) = (char )'\000';
#line 248
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 253
      free((void *)file_name___0);
      }
    }
#line 377
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 380
  return (cp);
}
}
#line 392 "/home/khheo/project/benchmark/sed-4.3/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 403
  tmp = nl_langinfo(14);
#line 403
  codeset = (char const   *)tmp;
  }
#line 584
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 586
    codeset = "";
  }
  {
#line 589
  aliases = get_charset_aliases();
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! ((int const   )*aliases != 0)) {
#line 589
      goto while_break;
    }
    {
#line 592
    tmp___3 = strcmp(codeset, aliases);
    }
#line 592
    if (tmp___3 == 0) {
      {
#line 595
      tmp___2 = strlen(aliases);
#line 595
      codeset = (aliases + tmp___2) + 1;
      }
#line 596
      goto while_break;
    } else
#line 592
    if ((int const   )*(aliases + 0) == 42) {
#line 592
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 595
        tmp___2 = strlen(aliases);
#line 595
        codeset = (aliases + tmp___2) + 1;
        }
#line 596
        goto while_break;
      }
    }
    {
#line 589
    tmp___0 = strlen(aliases);
#line 589
    aliases += tmp___0 + 1UL;
#line 589
    tmp___1 = strlen(aliases);
#line 589
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  if ((int const   )*(codeset + 0) == 0) {
#line 603
    codeset = "ASCII";
  }
#line 612
  return (codeset);
}
}
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 37 "/home/khheo/project/benchmark/sed-4.3/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 40
  hard = (_Bool)1;
#line 41
  tmp = setlocale(category, (char const   *)((void *)0));
#line 41
  p = (char const   *)tmp;
  }
#line 43
  if (p) {
#line 45
    if (1) {
      {
#line 47
      tmp___0 = strcmp(p, "C");
      }
#line 47
      if (tmp___0 == 0) {
#line 48
        hard = (_Bool)0;
      } else {
        {
#line 47
        tmp___1 = strcmp(p, "POSIX");
        }
#line 47
        if (tmp___1 == 0) {
#line 48
          hard = (_Bool)0;
        }
      }
    } else {
      {
#line 52
      tmp___2 = strdup(p);
#line 52
      locale = tmp___2;
      }
#line 53
      if (locale) {
        {
#line 58
        tmp___3 = setlocale(category, "C");
#line 58
        p = (char const   *)tmp___3;
        }
#line 58
        if (p) {
          {
#line 58
          tmp___4 = strcmp(p, (char const   *)locale);
          }
#line 58
          if (tmp___4 == 0) {
#line 62
            hard = (_Bool)0;
          } else {
#line 58
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 58
          tmp___5 = setlocale(category, "POSIX");
#line 58
          p = (char const   *)tmp___5;
          }
#line 58
          if (p) {
            {
#line 58
            tmp___6 = strcmp(p, (char const   *)locale);
            }
#line 58
            if (tmp___6 == 0) {
#line 62
              hard = (_Bool)0;
            }
          }
        }
        {
#line 65
        setlocale(category, (char const   *)locale);
#line 66
        free((void *)locale);
        }
      }
    }
  }
#line 71
  return (hard);
}
}
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/getprogname.h"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 49 "/home/khheo/project/benchmark/sed-4.3/lib/getprogname.c"
char const   *getprogname(void)  __attribute__((__pure__)) ;
#line 49 "/home/khheo/project/benchmark/sed-4.3/lib/getprogname.c"
char const   *getprogname(void) 
{ 


  {
#line 54
  return ((char const   *)program_invocation_short_name);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 302
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/sed-4.3/lib/get-permissions.c"
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) 
{ 


  {
  {
#line 36
  memset((void *)ctx, 0, sizeof(*ctx));
#line 37
  ctx->mode = mode;
  }
#line 289
  return (0);
}
}
#line 24 "/home/khheo/project/benchmark/sed-4.3/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 43 "/home/khheo/project/benchmark/sed-4.3/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 45
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/sed-4.3/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 51 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.h"
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 71
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) ;
#line 75
struct dfamust *dfamust(struct dfa  const  *d ) ;
#line 78
void dfamustfree(struct dfamust *dm ) ;
#line 83
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) ;
#line 97
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) ;
#line 104
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 107
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 110
void dfafree(struct dfa *d ) ;
#line 118
void dfawarn(char const   *mesg ) ;
#line 123
 __attribute__((__noreturn__)) void dfaerror(char const   *mesg ) ;
#line 108 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalnum)(int  ) ;
#line 109
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isalpha)(int  ) ;
#line 110
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iscntrl)(int  ) ;
#line 111
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isdigit)(int  ) ;
#line 112
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) islower)(int  ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isgraph)(int  ) ;
#line 114
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isprint)(int  ) ;
#line 115
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ispunct)(int  ) ;
#line 116
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isspace)(int  ) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isupper)(int  ) ;
#line 118
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isxdigit)(int  ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 130
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isblank)(int  ) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 329
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 288 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wctob)(wint_t __c ) ;
#line 301
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/xalloc.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264
#pragma GCC diagnostic pop
#line 96 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static unsigned long const   CHARCLASS_WORD_MASK  =    (charclass_word const   )(((1UL << 63) << 1) - 1UL);
#line 111 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static unsigned char to_uchar(char ch ) 
{ 


  {
#line 114
  return ((unsigned char )ch);
}
}
#line 552
static void regexp(struct dfa *dfa ) ;
#line 571 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static size_t mbs_to_wchar(wint_t *pwc , char const   *s , size_t n , struct dfa *d ) 
{ 
  unsigned char uc ;
  wint_t wc ;
  wchar_t wch ;
  size_t nbytes ;
  size_t tmp ;

  {
#line 574
  uc = (unsigned char )*(s + 0);
#line 575
  wc = d->localeinfo.sbctowc[uc];
#line 577
  if (wc == 4294967295U) {
    {
#line 580
    tmp = rpl_mbrtowc(& wch, s, n, & d->mbs);
#line 580
    nbytes = tmp;
    }
#line 581
    if (0UL < nbytes) {
#line 581
      if (nbytes < 0xfffffffffffffffeUL) {
#line 583
        *pwc = (wint_t )wch;
#line 584
        return (nbytes);
      }
    }
    {
#line 586
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 589
  *pwc = wc;
#line 590
  return ((size_t )1);
}
}
#line 673 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool tstbit(unsigned int b___0 , charclass_word * const  c ) 
{ 


  {
#line 676
  return ((_Bool )((*(c + b___0 / 64U) >> b___0 % 64U) & 1UL));
}
}
#line 679 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void setbit(unsigned int b___0 , charclass_word *c ) 
{ 


  {
#line 682
  *(c + b___0 / 64U) |= 1UL << b___0 % 64U;
#line 683
  return;
}
}
#line 685 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void clrbit(unsigned int b___0 , charclass_word *c ) 
{ 


  {
#line 688
  *(c + b___0 / 64U) &= ~ (1UL << b___0 % 64U);
#line 690
  return;
}
}
#line 692 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void copyset(charclass_word * const  src , charclass_word *dst ) 
{ 


  {
  {
#line 695
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(charclass ));
  }
#line 696
  return;
}
}
#line 698 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void zeroset(charclass_word *s ) 
{ 


  {
  {
#line 701
  memset((void *)s, 0, sizeof(charclass ));
  }
#line 702
  return;
}
}
#line 704 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void fillset(charclass_word *s ) 
{ 
  int i ;

  {
#line 708
  i = 0;
  {
#line 708
  while (1) {
    while_continue: /* CIL Label */ ;
#line 708
    if (! (i < 4)) {
#line 708
      goto while_break;
    }
#line 709
    *(s + i) = (charclass_word )CHARCLASS_WORD_MASK;
#line 708
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  return;
}
}
#line 712 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void notset(charclass_word *s ) 
{ 
  int i ;

  {
#line 716
  i = 0;
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (i < 4)) {
#line 716
      goto while_break;
    }
#line 717
    *(s + i) = (charclass_word )(CHARCLASS_WORD_MASK & (unsigned long const   )(~ *(s + i)));
#line 716
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 718
  return;
}
}
#line 720 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool equal(charclass_word * const  s1 , charclass_word * const  s2 ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 723
  w = (charclass_word )0;
#line 725
  i = 0;
  {
#line 725
  while (1) {
    while_continue: /* CIL Label */ ;
#line 725
    if (! (i < 4)) {
#line 725
      goto while_break;
    }
#line 726
    w |= *(s1 + i) ^ *(s2 + i);
#line 725
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 727
  return ((_Bool )(w == 0UL));
}
}
#line 730 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool emptyset(charclass_word * const  s ) 
{ 
  charclass_word w ;
  int i ;

  {
#line 733
  w = (charclass_word )0;
#line 735
  i = 0;
  {
#line 735
  while (1) {
    while_continue: /* CIL Label */ ;
#line 735
    if (! (i < 4)) {
#line 735
      goto while_break;
    }
#line 736
    w |= *(s + i);
#line 735
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return ((_Bool )(w == 0UL));
}
}
#line 756 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void *xpalloc(void *pa , ptrdiff_t *nitems , ptrdiff_t nitems_incr_min , ptrdiff_t nitems_max ,
                     ptrdiff_t item_size ) 
{ 
  ptrdiff_t n0 ;
  ptrdiff_t n ;
  ptrdiff_t nbytes ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  ptrdiff_t adjusted_nbytes ;
  int tmp___217 ;
  unsigned long tmp___218 ;
  int tmp___224 ;
  int tmp___225 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  int tmp___239 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  int tmp___251 ;
  int tmp___252 ;
  int tmp___258 ;
  int tmp___259 ;
  int tmp___260 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  int tmp___264 ;
  int tmp___270 ;
  int tmp___271 ;
  int tmp___272 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  int tmp___281 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tmp___293 ;
  int tmp___294 ;
  int tmp___295 ;
  int tmp___296 ;
  int tmp___297 ;
  int tmp___298 ;
  int tmp___304 ;
  int tmp___305 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  int tmp___309 ;
  int tmp___310 ;
  int tmp___316 ;
  int tmp___317 ;
  int tmp___318 ;
  int tmp___319 ;
  int tmp___320 ;
  int tmp___321 ;
  int tmp___327 ;
  int tmp___328 ;
  int tmp___329 ;
  int tmp___330 ;
  int tmp___331 ;
  int tmp___332 ;
  int tmp___333 ;
  int tmp___334 ;
  int tmp___335 ;
  int tmp___336 ;
  int tmp___337 ;
  int tmp___342 ;
  int tmp___343 ;
  int tmp___344 ;
  int tmp___345 ;
  int tmp___346 ;
  int tmp___351 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___361 ;
  int tmp___362 ;
  int tmp___363 ;
  int tmp___364 ;
  int tmp___365 ;
  int tmp___370 ;
  int tmp___371 ;
  int tmp___372 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  int tmp___383 ;
  int tmp___384 ;
  int tmp___389 ;
  int tmp___390 ;
  int tmp___391 ;
  int tmp___392 ;
  int tmp___393 ;
  int tmp___394 ;
  int tmp___399 ;
  int tmp___400 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  int tmp___411 ;
  int tmp___412 ;
  int tmp___413 ;
  int tmp___418 ;
  int tmp___419 ;
  int tmp___420 ;
  int tmp___421 ;
  int tmp___422 ;
  int tmp___427 ;
  int tmp___428 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  int tmp___432 ;
  int tmp___433 ;
  int tmp___434 ;
  int tmp___435 ;
  int tmp___436 ;
  int tmp___442 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  int tmp___446 ;
  int tmp___447 ;
  int tmp___453 ;
  int tmp___454 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  int tmp___458 ;
  int tmp___459 ;
  int tmp___465 ;
  int tmp___466 ;
  int tmp___467 ;
  int tmp___468 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  int tmp___479 ;
  int tmp___480 ;
  int tmp___481 ;
  int tmp___482 ;
  int tmp___488 ;
  int tmp___489 ;
  int tmp___490 ;
  int tmp___491 ;
  int tmp___492 ;
  int tmp___493 ;
  int tmp___499 ;
  int tmp___500 ;
  int tmp___501 ;
  int tmp___502 ;
  int tmp___503 ;
  int tmp___504 ;
  int tmp___505 ;
  int tmp___511 ;
  int tmp___512 ;
  int tmp___513 ;
  int tmp___514 ;
  int tmp___515 ;
  int tmp___516 ;
  int tmp___522 ;
  int tmp___523 ;
  int tmp___524 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  int tmp___528 ;
  int tmp___534 ;
  int tmp___535 ;
  int tmp___536 ;
  int tmp___537 ;
  int tmp___538 ;
  int tmp___539 ;
  int tmp___545 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  int tmp___549 ;
  int tmp___550 ;
  int tmp___551 ;
  int tmp___552 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;

  {
#line 760
  n0 = *nitems;
#line 773
  if (sizeof(n) == sizeof(signed char )) {
#line 773
    if (sizeof(n0 + (n0 >> 1)) < sizeof(signed char )) {
#line 773
      if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 773
        if ((int )((signed char )(n0 >> 1)) < 0) {
#line 773
          tmp___4 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1));
        } else {
#line 773
          tmp___4 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )(n0 >> 1)) < (int )((signed char )n0);
        }
#line 773
        tmp___7 = tmp___4;
      } else {
#line 773
        if ((int )((signed char )n0) < 0) {
#line 773
          tmp___6 = (int )((signed char )(n0 >> 1)) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
        } else {
#line 773
          if ((int )((signed char )(n0 >> 1)) < 0) {
#line 773
            tmp___5 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )(n0 >> 1));
          } else {
#line 773
            tmp___5 = (int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < (int )((signed char )(n0 >> 1));
          }
#line 773
          tmp___6 = tmp___5;
        }
#line 773
        tmp___7 = tmp___6;
      }
#line 773
      if (tmp___7) {
#line 773
        goto _L;
      } else
#line 773
      if ((int )((signed char )n0) + (int )((signed char )(n0 >> 1)) < -128) {
#line 773
        goto _L;
      } else
#line 773
      if (127 < (int )((signed char )n0) + (int )((signed char )(n0 >> 1))) {
        _L: /* CIL Label */ 
#line 773
        if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1))) <= 127) {
#line 773
          n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))));
        } else {
#line 773
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))) - -128)) + -128);
        }
#line 773
        tmp___3 = 1;
      } else {
#line 773
        if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1))) <= 127) {
#line 773
          n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))));
        } else {
#line 773
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )(n0 >> 1)))) - -128)) + -128);
        }
#line 773
        tmp___3 = 0;
      }
#line 773
      tmp___17 = tmp___3;
    } else {
#line 773
      if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 773
        if (n0 >> 1 < 0L) {
#line 773
          tmp___13 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
        } else {
#line 773
          tmp___13 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
        }
#line 773
        tmp___16 = tmp___13;
      } else {
#line 773
        if (n0 < 0L) {
#line 773
          tmp___15 = n0 >> 1 <= n0 + (n0 >> 1);
        } else {
#line 773
          if (n0 >> 1 < 0L) {
#line 773
            tmp___14 = n0 <= n0 + (n0 >> 1);
          } else {
#line 773
            tmp___14 = n0 + (n0 >> 1) < n0 >> 1;
          }
#line 773
          tmp___15 = tmp___14;
        }
#line 773
        tmp___16 = tmp___15;
      }
#line 773
      if (tmp___16) {
#line 773
        goto _L___0;
      } else
#line 773
      if (n0 + (n0 >> 1) < -128L) {
#line 773
        goto _L___0;
      } else
#line 773
      if (127L < n0 + (n0 >> 1)) {
        _L___0: /* CIL Label */ 
#line 773
        if ((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1)) <= 127) {
#line 773
          n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))));
        } else {
#line 773
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))) - -128)) + -128);
        }
#line 773
        tmp___12 = 1;
      } else {
#line 773
        if ((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1)) <= 127) {
#line 773
          n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))));
        } else {
#line 773
          n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )(n0 >> 1))) - -128)) + -128);
        }
#line 773
        tmp___12 = 0;
      }
#line 773
      tmp___17 = tmp___12;
    }
#line 773
    tmp___97 = tmp___17;
  } else {
#line 773
    if (sizeof(n) == sizeof(short )) {
#line 773
      if (sizeof(n0 + (n0 >> 1)) < sizeof(short )) {
#line 773
        if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 773
          if ((int )((short )(n0 >> 1)) < 0) {
#line 773
            tmp___23 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1));
          } else {
#line 773
            tmp___23 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )(n0 >> 1)) < (int )((short )n0);
          }
#line 773
          tmp___26 = tmp___23;
        } else {
#line 773
          if ((int )((short )n0) < 0) {
#line 773
            tmp___25 = (int )((short )(n0 >> 1)) <= (int )((short )n0) + (int )((short )(n0 >> 1));
          } else {
#line 773
            if ((int )((short )(n0 >> 1)) < 0) {
#line 773
              tmp___24 = (int )((short )n0) <= (int )((short )n0) + (int )((short )(n0 >> 1));
            } else {
#line 773
              tmp___24 = (int )((short )n0) + (int )((short )(n0 >> 1)) < (int )((short )(n0 >> 1));
            }
#line 773
            tmp___25 = tmp___24;
          }
#line 773
          tmp___26 = tmp___25;
        }
#line 773
        if (tmp___26) {
#line 773
          goto _L___1;
        } else
#line 773
        if ((int )((short )n0) + (int )((short )(n0 >> 1)) < -32768) {
#line 773
          goto _L___1;
        } else
#line 773
        if (32767 < (int )((short )n0) + (int )((short )(n0 >> 1))) {
          _L___1: /* CIL Label */ 
#line 773
          if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1))) <= 32767) {
#line 773
            n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))));
          } else {
#line 773
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))) - -32768)) + -32768);
          }
#line 773
          tmp___22 = 1;
        } else {
#line 773
          if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1))) <= 32767) {
#line 773
            n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))));
          } else {
#line 773
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )(n0 >> 1)))) - -32768)) + -32768);
          }
#line 773
          tmp___22 = 0;
        }
#line 773
        tmp___36 = tmp___22;
      } else {
#line 773
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 773
          if (n0 >> 1 < 0L) {
#line 773
            tmp___32 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
          } else {
#line 773
            tmp___32 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
          }
#line 773
          tmp___35 = tmp___32;
        } else {
#line 773
          if (n0 < 0L) {
#line 773
            tmp___34 = n0 >> 1 <= n0 + (n0 >> 1);
          } else {
#line 773
            if (n0 >> 1 < 0L) {
#line 773
              tmp___33 = n0 <= n0 + (n0 >> 1);
            } else {
#line 773
              tmp___33 = n0 + (n0 >> 1) < n0 >> 1;
            }
#line 773
            tmp___34 = tmp___33;
          }
#line 773
          tmp___35 = tmp___34;
        }
#line 773
        if (tmp___35) {
#line 773
          goto _L___2;
        } else
#line 773
        if (n0 + (n0 >> 1) < -32768L) {
#line 773
          goto _L___2;
        } else
#line 773
        if (32767L < n0 + (n0 >> 1)) {
          _L___2: /* CIL Label */ 
#line 773
          if ((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1)) <= 32767) {
#line 773
            n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))));
          } else {
#line 773
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))) - -32768)) + -32768);
          }
#line 773
          tmp___31 = 1;
        } else {
#line 773
          if ((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1)) <= 32767) {
#line 773
            n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))));
          } else {
#line 773
            n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )(n0 >> 1))) - -32768)) + -32768);
          }
#line 773
          tmp___31 = 0;
        }
#line 773
        tmp___36 = tmp___31;
      }
#line 773
      tmp___96 = tmp___36;
    } else {
#line 773
      if (sizeof(n) == sizeof(int )) {
#line 773
        if (sizeof(n0 + (n0 >> 1)) < sizeof(int )) {
#line 773
          if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 773
            if ((int )(n0 >> 1) < 0) {
#line 773
              tmp___42 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1);
            } else {
#line 773
              tmp___42 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )(n0 >> 1) < (int )n0;
            }
#line 773
            tmp___45 = tmp___42;
          } else {
#line 773
            if ((int )n0 < 0) {
#line 773
              tmp___44 = (int )(n0 >> 1) <= (int )n0 + (int )(n0 >> 1);
            } else {
#line 773
              if ((int )(n0 >> 1) < 0) {
#line 773
                tmp___43 = (int )n0 <= (int )n0 + (int )(n0 >> 1);
              } else {
#line 773
                tmp___43 = (int )n0 + (int )(n0 >> 1) < (int )(n0 >> 1);
              }
#line 773
              tmp___44 = tmp___43;
            }
#line 773
            tmp___45 = tmp___44;
          }
#line 773
          if (tmp___45) {
#line 773
            goto _L___3;
          } else
#line 773
          if ((int )n0 + (int )(n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 773
            goto _L___3;
          } else
#line 773
          if (2147483647 < (int )n0 + (int )(n0 >> 1)) {
            _L___3: /* CIL Label */ 
#line 773
            if ((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1)) <= 2147483647U) {
#line 773
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
            } else {
#line 773
              n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 773
            tmp___41 = 1;
          } else {
#line 773
            if ((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1)) <= 2147483647U) {
#line 773
              n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))));
            } else {
#line 773
              n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )(n0 >> 1))) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 773
            tmp___41 = 0;
          }
#line 773
          tmp___55 = tmp___41;
        } else {
#line 773
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 773
            if (n0 >> 1 < 0L) {
#line 773
              tmp___51 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
            } else {
#line 773
              tmp___51 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
            }
#line 773
            tmp___54 = tmp___51;
          } else {
#line 773
            if (n0 < 0L) {
#line 773
              tmp___53 = n0 >> 1 <= n0 + (n0 >> 1);
            } else {
#line 773
              if (n0 >> 1 < 0L) {
#line 773
                tmp___52 = n0 <= n0 + (n0 >> 1);
              } else {
#line 773
                tmp___52 = n0 + (n0 >> 1) < n0 >> 1;
              }
#line 773
              tmp___53 = tmp___52;
            }
#line 773
            tmp___54 = tmp___53;
          }
#line 773
          if (tmp___54) {
#line 773
            goto _L___4;
          } else
#line 773
          if (n0 + (n0 >> 1) < (-0x7FFFFFFF-1)) {
#line 773
            goto _L___4;
          } else
#line 773
          if (2147483647L < n0 + (n0 >> 1)) {
            _L___4: /* CIL Label */ 
#line 773
            if ((unsigned int )n0 + (unsigned int )(n0 >> 1) <= 2147483647U) {
#line 773
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
            } else {
#line 773
              n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )(n0 >> 1)) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 773
            tmp___50 = 1;
          } else {
#line 773
            if ((unsigned int )n0 + (unsigned int )(n0 >> 1) <= 2147483647U) {
#line 773
              n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )(n0 >> 1)));
            } else {
#line 773
              n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )(n0 >> 1)) - 2147483648U) + (-0x7FFFFFFF-1));
            }
#line 773
            tmp___50 = 0;
          }
#line 773
          tmp___55 = tmp___50;
        }
#line 773
        tmp___95 = tmp___55;
      } else {
#line 773
        if (sizeof(n) == sizeof(long )) {
#line 773
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long )) {
#line 773
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 773
              if (n0 >> 1 < 0L) {
#line 773
                tmp___61 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 773
                tmp___61 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 773
              tmp___64 = tmp___61;
            } else {
#line 773
              if (n0 < 0L) {
#line 773
                tmp___63 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 773
                if (n0 >> 1 < 0L) {
#line 773
                  tmp___62 = n0 <= n0 + (n0 >> 1);
                } else {
#line 773
                  tmp___62 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 773
                tmp___63 = tmp___62;
              }
#line 773
              tmp___64 = tmp___63;
            }
#line 773
            if (tmp___64) {
#line 773
              goto _L___5;
            } else
#line 773
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 773
              goto _L___5;
            } else
#line 773
            if (9223372036854775807L < n0 + (n0 >> 1)) {
              _L___5: /* CIL Label */ 
#line 773
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 773
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 773
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 773
              tmp___60 = 1;
            } else {
#line 773
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 773
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 773
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 773
              tmp___60 = 0;
            }
#line 773
            tmp___74 = tmp___60;
          } else {
#line 773
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 773
              if (n0 >> 1 < 0L) {
#line 773
                tmp___70 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 773
                tmp___70 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 773
              tmp___73 = tmp___70;
            } else {
#line 773
              if (n0 < 0L) {
#line 773
                tmp___72 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 773
                if (n0 >> 1 < 0L) {
#line 773
                  tmp___71 = n0 <= n0 + (n0 >> 1);
                } else {
#line 773
                  tmp___71 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 773
                tmp___72 = tmp___71;
              }
#line 773
              tmp___73 = tmp___72;
            }
#line 773
            if (tmp___73) {
#line 773
              goto _L___6;
            } else
#line 773
            if (n0 + (n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 773
              goto _L___6;
            } else
#line 773
            if (9223372036854775807L < n0 + (n0 >> 1)) {
              _L___6: /* CIL Label */ 
#line 773
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 773
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 773
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 773
              tmp___69 = 1;
            } else {
#line 773
              if ((unsigned long )n0 + (unsigned long )(n0 >> 1) <= 9223372036854775807UL) {
#line 773
                n = (long )((unsigned long )n0 + (unsigned long )(n0 >> 1));
              } else {
#line 773
                n = (long )(((unsigned long )n0 + (unsigned long )(n0 >> 1)) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
              }
#line 773
              tmp___69 = 0;
            }
#line 773
            tmp___74 = tmp___69;
          }
#line 773
          tmp___94 = tmp___74;
        } else {
#line 773
          if (sizeof(n0 + (n0 >> 1)) < sizeof(long long )) {
#line 773
            if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 773
              if ((long long )(n0 >> 1) < 0LL) {
#line 773
                tmp___80 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1);
              } else {
#line 773
                tmp___80 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )(n0 >> 1) < (long long )n0;
              }
#line 773
              tmp___83 = tmp___80;
            } else {
#line 773
              if ((long long )n0 < 0LL) {
#line 773
                tmp___82 = (long long )(n0 >> 1) <= (long long )n0 + (long long )(n0 >> 1);
              } else {
#line 773
                if ((long long )(n0 >> 1) < 0LL) {
#line 773
                  tmp___81 = (long long )n0 <= (long long )n0 + (long long )(n0 >> 1);
                } else {
#line 773
                  tmp___81 = (long long )n0 + (long long )(n0 >> 1) < (long long )(n0 >> 1);
                }
#line 773
                tmp___82 = tmp___81;
              }
#line 773
              tmp___83 = tmp___82;
            }
#line 773
            if (tmp___83) {
#line 773
              goto _L___7;
            } else
#line 773
            if ((long long )n0 + (long long )(n0 >> 1) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 773
              goto _L___7;
            } else
#line 773
            if (9223372036854775807LL < (long long )n0 + (long long )(n0 >> 1)) {
              _L___7: /* CIL Label */ 
#line 773
              if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1)) <= 9223372036854775807ULL) {
#line 773
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
              } else {
#line 773
                n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 773
              tmp___79 = 1;
            } else {
#line 773
              if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1)) <= 9223372036854775807ULL) {
#line 773
                n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))));
              } else {
#line 773
                n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )(n0 >> 1))) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 773
              tmp___79 = 0;
            }
#line 773
            tmp___93 = tmp___79;
          } else {
#line 773
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 773
              if (n0 >> 1 < 0L) {
#line 773
                tmp___89 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1);
              } else {
#line 773
                tmp___89 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - (n0 >> 1) < n0;
              }
#line 773
              tmp___92 = tmp___89;
            } else {
#line 773
              if (n0 < 0L) {
#line 773
                tmp___91 = n0 >> 1 <= n0 + (n0 >> 1);
              } else {
#line 773
                if (n0 >> 1 < 0L) {
#line 773
                  tmp___90 = n0 <= n0 + (n0 >> 1);
                } else {
#line 773
                  tmp___90 = n0 + (n0 >> 1) < n0 >> 1;
                }
#line 773
                tmp___91 = tmp___90;
              }
#line 773
              tmp___92 = tmp___91;
            }
#line 773
            if (tmp___92) {
#line 773
              goto _L___8;
            } else
#line 773
            if ((long long )(n0 + (n0 >> 1)) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 773
              goto _L___8;
            } else
#line 773
            if (9223372036854775807LL < (long long )(n0 + (n0 >> 1))) {
              _L___8: /* CIL Label */ 
#line 773
              if ((unsigned long long )n0 + (unsigned long long )(n0 >> 1) <= 9223372036854775807ULL) {
#line 773
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
              } else {
#line 773
                n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )(n0 >> 1)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 773
              tmp___88 = 1;
            } else {
#line 773
              if ((unsigned long long )n0 + (unsigned long long )(n0 >> 1) <= 9223372036854775807ULL) {
#line 773
                n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )(n0 >> 1)));
              } else {
#line 773
                n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )(n0 >> 1)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
              }
#line 773
              tmp___88 = 0;
            }
#line 773
            tmp___93 = tmp___88;
          }
#line 773
          tmp___94 = tmp___93;
        }
#line 773
        tmp___95 = tmp___94;
      }
#line 773
      tmp___96 = tmp___95;
    }
#line 773
    tmp___97 = tmp___96;
  }
#line 773
  if (tmp___97) {
#line 774
    n = 9223372036854775807L;
  }
#line 775
  if (0L <= nitems_max) {
#line 775
    if (nitems_max < n) {
#line 776
      n = nitems_max;
    }
  }
#line 778
  if (sizeof(nbytes) == sizeof(signed char )) {
#line 778
    if (sizeof(n * item_size) < sizeof(signed char )) {
#line 778
      if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 778
        if ((int )((signed char )n) < 0) {
#line 778
          if (0 < (int )((signed char )item_size)) {
#line 778
            goto _L___39;
          } else {
#line 778
            goto _L___41;
          }
        } else
        _L___41: /* CIL Label */ 
#line 778
        if ((int )((signed char )item_size) < 0) {
#line 778
          if (0 < (int )((signed char )n)) {
#line 778
            goto _L___39;
          } else {
#line 778
            goto _L___40;
          }
        } else {
#line 778
          goto _L___40;
        }
      } else {
        _L___40: /* CIL Label */ 
#line 778
        if ((int )((signed char )item_size) < 0) {
#line 778
          if ((int )((signed char )n) < 0) {
#line 778
            tmp___226 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
          } else {
#line 778
            if ((int )((signed char )item_size) == -1) {
#line 778
              tmp___225 = 0;
            } else {
#line 778
              tmp___225 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 778
            tmp___226 = tmp___225;
          }
#line 778
          tmp___229 = tmp___226;
        } else {
#line 778
          if ((int )((signed char )item_size) == 0) {
#line 778
            tmp___228 = 0;
          } else {
#line 778
            if ((int )((signed char )n) < 0) {
#line 778
              tmp___227 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
            } else {
#line 778
              tmp___227 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
            }
#line 778
            tmp___228 = tmp___227;
          }
#line 778
          tmp___229 = tmp___228;
        }
#line 778
        if (tmp___229) {
#line 778
          goto _L___39;
        } else
#line 778
        if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 778
          goto _L___39;
        } else
#line 778
        if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
          _L___39: /* CIL Label */ 
#line 778
          if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 778
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
          } else {
#line 778
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
          }
#line 778
          tmp___224 = 1;
        } else {
#line 778
          if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 778
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
          } else {
#line 778
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
          }
#line 778
          tmp___224 = 0;
        }
      }
#line 778
      tmp___241 = tmp___224;
    } else {
#line 778
      if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 778
        if (n < 0L) {
#line 778
          if (0L < item_size) {
#line 778
            goto _L___42;
          } else {
#line 778
            goto _L___44;
          }
        } else
        _L___44: /* CIL Label */ 
#line 778
        if (item_size < 0L) {
#line 778
          if (0L < n) {
#line 778
            goto _L___42;
          } else {
#line 778
            goto _L___43;
          }
        } else {
#line 778
          goto _L___43;
        }
      } else {
        _L___43: /* CIL Label */ 
#line 778
        if (item_size < 0L) {
#line 778
          if (n < 0L) {
#line 778
            tmp___237 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
          } else {
#line 778
            if (item_size == -1L) {
#line 778
              tmp___236 = 0;
            } else {
#line 778
              tmp___236 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 778
            tmp___237 = tmp___236;
          }
#line 778
          tmp___240 = tmp___237;
        } else {
#line 778
          if (item_size == 0L) {
#line 778
            tmp___239 = 0;
          } else {
#line 778
            if (n < 0L) {
#line 778
              tmp___238 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 778
              tmp___238 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
            }
#line 778
            tmp___239 = tmp___238;
          }
#line 778
          tmp___240 = tmp___239;
        }
#line 778
        if (tmp___240) {
#line 778
          goto _L___42;
        } else
#line 778
        if (n * item_size < -128L) {
#line 778
          goto _L___42;
        } else
#line 778
        if (127L < n * item_size) {
          _L___42: /* CIL Label */ 
#line 778
          if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 778
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
          } else {
#line 778
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
          }
#line 778
          tmp___235 = 1;
        } else {
#line 778
          if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 778
            nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
          } else {
#line 778
            nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
          }
#line 778
          tmp___235 = 0;
        }
      }
#line 778
      tmp___241 = tmp___235;
    }
#line 778
    tmp___337 = tmp___241;
  } else {
#line 778
    if (sizeof(nbytes) == sizeof(short )) {
#line 778
      if (sizeof(n * item_size) < sizeof(short )) {
#line 778
        if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 778
          if ((int )((short )n) < 0) {
#line 778
            if (0 < (int )((short )item_size)) {
#line 778
              goto _L___45;
            } else {
#line 778
              goto _L___47;
            }
          } else
          _L___47: /* CIL Label */ 
#line 778
          if ((int )((short )item_size) < 0) {
#line 778
            if (0 < (int )((short )n)) {
#line 778
              goto _L___45;
            } else {
#line 778
              goto _L___46;
            }
          } else {
#line 778
            goto _L___46;
          }
        } else {
          _L___46: /* CIL Label */ 
#line 778
          if ((int )((short )item_size) < 0) {
#line 778
            if ((int )((short )n) < 0) {
#line 778
              tmp___249 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
            } else {
#line 778
              if ((int )((short )item_size) == -1) {
#line 778
                tmp___248 = 0;
              } else {
#line 778
                tmp___248 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 778
              tmp___249 = tmp___248;
            }
#line 778
            tmp___252 = tmp___249;
          } else {
#line 778
            if ((int )((short )item_size) == 0) {
#line 778
              tmp___251 = 0;
            } else {
#line 778
              if ((int )((short )n) < 0) {
#line 778
                tmp___250 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
              } else {
#line 778
                tmp___250 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
              }
#line 778
              tmp___251 = tmp___250;
            }
#line 778
            tmp___252 = tmp___251;
          }
#line 778
          if (tmp___252) {
#line 778
            goto _L___45;
          } else
#line 778
          if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 778
            goto _L___45;
          } else
#line 778
          if (32767 < (int )((short )n) * (int )((short )item_size)) {
            _L___45: /* CIL Label */ 
#line 778
            if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 778
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
            } else {
#line 778
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
            }
#line 778
            tmp___247 = 1;
          } else {
#line 778
            if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 778
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
            } else {
#line 778
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
            }
#line 778
            tmp___247 = 0;
          }
        }
#line 778
        tmp___264 = tmp___247;
      } else {
#line 778
        if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 778
          if (n < 0L) {
#line 778
            if (0L < item_size) {
#line 778
              goto _L___48;
            } else {
#line 778
              goto _L___50;
            }
          } else
          _L___50: /* CIL Label */ 
#line 778
          if (item_size < 0L) {
#line 778
            if (0L < n) {
#line 778
              goto _L___48;
            } else {
#line 778
              goto _L___49;
            }
          } else {
#line 778
            goto _L___49;
          }
        } else {
          _L___49: /* CIL Label */ 
#line 778
          if (item_size < 0L) {
#line 778
            if (n < 0L) {
#line 778
              tmp___260 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
            } else {
#line 778
              if (item_size == -1L) {
#line 778
                tmp___259 = 0;
              } else {
#line 778
                tmp___259 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 778
              tmp___260 = tmp___259;
            }
#line 778
            tmp___263 = tmp___260;
          } else {
#line 778
            if (item_size == 0L) {
#line 778
              tmp___262 = 0;
            } else {
#line 778
              if (n < 0L) {
#line 778
                tmp___261 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 778
                tmp___261 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
              }
#line 778
              tmp___262 = tmp___261;
            }
#line 778
            tmp___263 = tmp___262;
          }
#line 778
          if (tmp___263) {
#line 778
            goto _L___48;
          } else
#line 778
          if (n * item_size < -32768L) {
#line 778
            goto _L___48;
          } else
#line 778
          if (32767L < n * item_size) {
            _L___48: /* CIL Label */ 
#line 778
            if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 778
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
            } else {
#line 778
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
            }
#line 778
            tmp___258 = 1;
          } else {
#line 778
            if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 778
              nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
            } else {
#line 778
              nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
            }
#line 778
            tmp___258 = 0;
          }
        }
#line 778
        tmp___264 = tmp___258;
      }
#line 778
      tmp___336 = tmp___264;
    } else {
#line 778
      if (sizeof(nbytes) == sizeof(int )) {
#line 778
        if (sizeof(n * item_size) < sizeof(int )) {
#line 778
          if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 778
            if ((int )n < 0) {
#line 778
              if (0 < (int )item_size) {
#line 778
                goto _L___51;
              } else {
#line 778
                goto _L___53;
              }
            } else
            _L___53: /* CIL Label */ 
#line 778
            if ((int )item_size < 0) {
#line 778
              if (0 < (int )n) {
#line 778
                goto _L___51;
              } else {
#line 778
                goto _L___52;
              }
            } else {
#line 778
              goto _L___52;
            }
          } else {
            _L___52: /* CIL Label */ 
#line 778
            if ((int )item_size < 0) {
#line 778
              if ((int )n < 0) {
#line 778
                tmp___272 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
              } else {
#line 778
                if ((int )item_size == -1) {
#line 778
                  tmp___271 = 0;
                } else {
#line 778
                  tmp___271 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 778
                tmp___272 = tmp___271;
              }
#line 778
              tmp___275 = tmp___272;
            } else {
#line 778
              if ((int )item_size == 0) {
#line 778
                tmp___274 = 0;
              } else {
#line 778
                if ((int )n < 0) {
#line 778
                  tmp___273 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                } else {
#line 778
                  tmp___273 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                }
#line 778
                tmp___274 = tmp___273;
              }
#line 778
              tmp___275 = tmp___274;
            }
#line 778
            if (tmp___275) {
#line 778
              goto _L___51;
            } else
#line 778
            if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 778
              goto _L___51;
            } else
#line 778
            if (2147483647 < (int )n * (int )item_size) {
              _L___51: /* CIL Label */ 
#line 778
              if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
              } else {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 778
              tmp___270 = 1;
            } else {
#line 778
              if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
              } else {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 778
              tmp___270 = 0;
            }
          }
#line 778
          tmp___287 = tmp___270;
        } else {
#line 778
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 778
            if (n < 0L) {
#line 778
              if (0L < item_size) {
#line 778
                goto _L___54;
              } else {
#line 778
                goto _L___56;
              }
            } else
            _L___56: /* CIL Label */ 
#line 778
            if (item_size < 0L) {
#line 778
              if (0L < n) {
#line 778
                goto _L___54;
              } else {
#line 778
                goto _L___55;
              }
            } else {
#line 778
              goto _L___55;
            }
          } else {
            _L___55: /* CIL Label */ 
#line 778
            if (item_size < 0L) {
#line 778
              if (n < 0L) {
#line 778
                tmp___283 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 778
                if (item_size == -1L) {
#line 778
                  tmp___282 = 0;
                } else {
#line 778
                  tmp___282 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 778
                tmp___283 = tmp___282;
              }
#line 778
              tmp___286 = tmp___283;
            } else {
#line 778
              if (item_size == 0L) {
#line 778
                tmp___285 = 0;
              } else {
#line 778
                if (n < 0L) {
#line 778
                  tmp___284 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 778
                  tmp___284 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 778
                tmp___285 = tmp___284;
              }
#line 778
              tmp___286 = tmp___285;
            }
#line 778
            if (tmp___286) {
#line 778
              goto _L___54;
            } else
#line 778
            if (n * item_size < (-0x7FFFFFFF-1)) {
#line 778
              goto _L___54;
            } else
#line 778
            if (2147483647L < n * item_size) {
              _L___54: /* CIL Label */ 
#line 778
              if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
              } else {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 778
              tmp___281 = 1;
            } else {
#line 778
              if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
              } else {
#line 778
                nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 778
              tmp___281 = 0;
            }
          }
#line 778
          tmp___287 = tmp___281;
        }
#line 778
        tmp___335 = tmp___287;
      } else {
#line 778
        if (sizeof(nbytes) == sizeof(long )) {
#line 778
          if (sizeof(n * item_size) < sizeof(long )) {
#line 778
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 778
              if (n < 0L) {
#line 778
                if (0L < item_size) {
#line 778
                  goto _L___57;
                } else {
#line 778
                  goto _L___59;
                }
              } else
              _L___59: /* CIL Label */ 
#line 778
              if (item_size < 0L) {
#line 778
                if (0L < n) {
#line 778
                  goto _L___57;
                } else {
#line 778
                  goto _L___58;
                }
              } else {
#line 778
                goto _L___58;
              }
            } else {
              _L___58: /* CIL Label */ 
#line 778
              if (item_size < 0L) {
#line 778
                if (n < 0L) {
#line 778
                  tmp___295 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 778
                  if (item_size == -1L) {
#line 778
                    tmp___294 = 0;
                  } else {
#line 778
                    tmp___294 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 778
                  tmp___295 = tmp___294;
                }
#line 778
                tmp___298 = tmp___295;
              } else {
#line 778
                if (item_size == 0L) {
#line 778
                  tmp___297 = 0;
                } else {
#line 778
                  if (n < 0L) {
#line 778
                    tmp___296 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 778
                    tmp___296 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 778
                  tmp___297 = tmp___296;
                }
#line 778
                tmp___298 = tmp___297;
              }
#line 778
              if (tmp___298) {
#line 778
                goto _L___57;
              } else
#line 778
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 778
                goto _L___57;
              } else
#line 778
              if (9223372036854775807L < n * item_size) {
                _L___57: /* CIL Label */ 
#line 778
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 778
                tmp___293 = 1;
              } else {
#line 778
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 778
                tmp___293 = 0;
              }
            }
#line 778
            tmp___310 = tmp___293;
          } else {
#line 778
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 778
              if (n < 0L) {
#line 778
                if (0L < item_size) {
#line 778
                  goto _L___60;
                } else {
#line 778
                  goto _L___62;
                }
              } else
              _L___62: /* CIL Label */ 
#line 778
              if (item_size < 0L) {
#line 778
                if (0L < n) {
#line 778
                  goto _L___60;
                } else {
#line 778
                  goto _L___61;
                }
              } else {
#line 778
                goto _L___61;
              }
            } else {
              _L___61: /* CIL Label */ 
#line 778
              if (item_size < 0L) {
#line 778
                if (n < 0L) {
#line 778
                  tmp___306 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 778
                  if (item_size == -1L) {
#line 778
                    tmp___305 = 0;
                  } else {
#line 778
                    tmp___305 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 778
                  tmp___306 = tmp___305;
                }
#line 778
                tmp___309 = tmp___306;
              } else {
#line 778
                if (item_size == 0L) {
#line 778
                  tmp___308 = 0;
                } else {
#line 778
                  if (n < 0L) {
#line 778
                    tmp___307 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 778
                    tmp___307 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 778
                  tmp___308 = tmp___307;
                }
#line 778
                tmp___309 = tmp___308;
              }
#line 778
              if (tmp___309) {
#line 778
                goto _L___60;
              } else
#line 778
              if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 778
                goto _L___60;
              } else
#line 778
              if (9223372036854775807L < n * item_size) {
                _L___60: /* CIL Label */ 
#line 778
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 778
                tmp___304 = 1;
              } else {
#line 778
                if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                } else {
#line 778
                  nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 778
                tmp___304 = 0;
              }
            }
#line 778
            tmp___310 = tmp___304;
          }
#line 778
          tmp___334 = tmp___310;
        } else {
#line 778
          if (sizeof(n * item_size) < sizeof(long long )) {
#line 778
            if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 778
              if ((long long )n < 0LL) {
#line 778
                if (0LL < (long long )item_size) {
#line 778
                  goto _L___63;
                } else {
#line 778
                  goto _L___65;
                }
              } else
              _L___65: /* CIL Label */ 
#line 778
              if ((long long )item_size < 0LL) {
#line 778
                if (0LL < (long long )n) {
#line 778
                  goto _L___63;
                } else {
#line 778
                  goto _L___64;
                }
              } else {
#line 778
                goto _L___64;
              }
            } else {
              _L___64: /* CIL Label */ 
#line 778
              if ((long long )item_size < 0LL) {
#line 778
                if ((long long )n < 0LL) {
#line 778
                  tmp___318 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                } else {
#line 778
                  if ((long long )item_size == -1LL) {
#line 778
                    tmp___317 = 0;
                  } else {
#line 778
                    tmp___317 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 778
                  tmp___318 = tmp___317;
                }
#line 778
                tmp___321 = tmp___318;
              } else {
#line 778
                if ((long long )item_size == 0LL) {
#line 778
                  tmp___320 = 0;
                } else {
#line 778
                  if ((long long )n < 0LL) {
#line 778
                    tmp___319 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                  } else {
#line 778
                    tmp___319 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                  }
#line 778
                  tmp___320 = tmp___319;
                }
#line 778
                tmp___321 = tmp___320;
              }
#line 778
              if (tmp___321) {
#line 778
                goto _L___63;
              } else
#line 778
              if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 778
                goto _L___63;
              } else
#line 778
              if (9223372036854775807LL < (long long )n * (long long )item_size) {
                _L___63: /* CIL Label */ 
#line 778
                if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                } else {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 778
                tmp___316 = 1;
              } else {
#line 778
                if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                } else {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 778
                tmp___316 = 0;
              }
            }
#line 778
            tmp___333 = tmp___316;
          } else {
#line 778
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 778
              if (n < 0L) {
#line 778
                if (0L < item_size) {
#line 778
                  goto _L___66;
                } else {
#line 778
                  goto _L___68;
                }
              } else
              _L___68: /* CIL Label */ 
#line 778
              if (item_size < 0L) {
#line 778
                if (0L < n) {
#line 778
                  goto _L___66;
                } else {
#line 778
                  goto _L___67;
                }
              } else {
#line 778
                goto _L___67;
              }
            } else {
              _L___67: /* CIL Label */ 
#line 778
              if (item_size < 0L) {
#line 778
                if (n < 0L) {
#line 778
                  tmp___329 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 778
                  if (item_size == -1L) {
#line 778
                    tmp___328 = 0;
                  } else {
#line 778
                    tmp___328 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 778
                  tmp___329 = tmp___328;
                }
#line 778
                tmp___332 = tmp___329;
              } else {
#line 778
                if (item_size == 0L) {
#line 778
                  tmp___331 = 0;
                } else {
#line 778
                  if (n < 0L) {
#line 778
                    tmp___330 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 778
                    tmp___330 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 778
                  tmp___331 = tmp___330;
                }
#line 778
                tmp___332 = tmp___331;
              }
#line 778
              if (tmp___332) {
#line 778
                goto _L___66;
              } else
#line 778
              if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 778
                goto _L___66;
              } else
#line 778
              if (9223372036854775807LL < (long long )(n * item_size)) {
                _L___66: /* CIL Label */ 
#line 778
                if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                } else {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 778
                tmp___327 = 1;
              } else {
#line 778
                if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                } else {
#line 778
                  nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 778
                tmp___327 = 0;
              }
            }
#line 778
            tmp___333 = tmp___327;
          }
#line 778
          tmp___334 = tmp___333;
        }
#line 778
        tmp___335 = tmp___334;
      }
#line 778
      tmp___336 = tmp___335;
    }
#line 778
    tmp___337 = tmp___336;
  }
#line 778
  if (tmp___337) {
#line 778
    tmp___218 = 9223372036854775807UL;
  } else
#line 778
  if (0xffffffffffffffffUL < (unsigned long )nbytes) {
#line 778
    tmp___218 = 9223372036854775807UL;
  } else {
#line 778
    if (nbytes < 128L) {
#line 778
      tmp___217 = 128;
    } else {
#line 778
      tmp___217 = 0;
    }
#line 778
    tmp___218 = (unsigned long )tmp___217;
  }
#line 778
  adjusted_nbytes = (ptrdiff_t )tmp___218;
#line 782
  if (adjusted_nbytes) {
#line 784
    n = adjusted_nbytes / item_size;
#line 785
    nbytes = adjusted_nbytes - adjusted_nbytes % item_size;
  }
#line 788
  if (! pa) {
#line 789
    *nitems = (ptrdiff_t )0;
  }
#line 790
  if (n - n0 < nitems_incr_min) {
#line 790
    if (sizeof(n) == sizeof(signed char )) {
#line 790
      if (sizeof(n0 + nitems_incr_min) < sizeof(signed char )) {
#line 790
        if (~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 790
          if ((int )((signed char )nitems_incr_min) < 0) {
#line 790
            tmp___343 = (int )((signed char )n0) < ~ (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min);
          } else {
#line 790
            tmp___343 = (((1 << (sizeof((int )((signed char )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((signed char )nitems_incr_min) < (int )((signed char )n0);
          }
#line 790
          tmp___346 = tmp___343;
        } else {
#line 790
          if ((int )((signed char )n0) < 0) {
#line 790
            tmp___345 = (int )((signed char )nitems_incr_min) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
          } else {
#line 790
            if ((int )((signed char )nitems_incr_min) < 0) {
#line 790
              tmp___344 = (int )((signed char )n0) <= (int )((signed char )n0) + (int )((signed char )nitems_incr_min);
            } else {
#line 790
              tmp___344 = (int )((signed char )n0) + (int )((signed char )nitems_incr_min) < (int )((signed char )nitems_incr_min);
            }
#line 790
            tmp___345 = tmp___344;
          }
#line 790
          tmp___346 = tmp___345;
        }
#line 790
        if (tmp___346) {
#line 790
          goto _L___69;
        } else
#line 790
        if ((int )((signed char )n0) + (int )((signed char )nitems_incr_min) < -128) {
#line 790
          goto _L___69;
        } else
#line 790
        if (127 < (int )((signed char )n0) + (int )((signed char )nitems_incr_min)) {
          _L___69: /* CIL Label */ 
#line 790
          if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min)) <= 127) {
#line 790
            n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))));
          } else {
#line 790
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))) - -128)) + -128);
          }
#line 790
          tmp___342 = 1;
        } else {
#line 790
          if ((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min)) <= 127) {
#line 790
            n = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))));
          } else {
#line 790
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )((signed char )n0)) + (int )((unsigned char )((signed char )nitems_incr_min))) - -128)) + -128);
          }
#line 790
          tmp___342 = 0;
        }
#line 790
        tmp___356 = tmp___342;
      } else {
#line 790
        if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 790
          if (nitems_incr_min < 0L) {
#line 790
            tmp___352 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
          } else {
#line 790
            tmp___352 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
          }
#line 790
          tmp___355 = tmp___352;
        } else {
#line 790
          if (n0 < 0L) {
#line 790
            tmp___354 = nitems_incr_min <= n0 + nitems_incr_min;
          } else {
#line 790
            if (nitems_incr_min < 0L) {
#line 790
              tmp___353 = n0 <= n0 + nitems_incr_min;
            } else {
#line 790
              tmp___353 = n0 + nitems_incr_min < nitems_incr_min;
            }
#line 790
            tmp___354 = tmp___353;
          }
#line 790
          tmp___355 = tmp___354;
        }
#line 790
        if (tmp___355) {
#line 790
          goto _L___70;
        } else
#line 790
        if (n0 + nitems_incr_min < -128L) {
#line 790
          goto _L___70;
        } else
#line 790
        if (127L < n0 + nitems_incr_min) {
          _L___70: /* CIL Label */ 
#line 790
          if ((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min) <= 127) {
#line 790
            n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)));
          } else {
#line 790
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)) - -128)) + -128);
          }
#line 790
          tmp___351 = 1;
        } else {
#line 790
          if ((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min) <= 127) {
#line 790
            n = (ptrdiff_t )((signed char )((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)));
          } else {
#line 790
            n = (ptrdiff_t )((int )((signed char )(((int )((unsigned char )n0) + (int )((unsigned char )nitems_incr_min)) - -128)) + -128);
          }
#line 790
          tmp___351 = 0;
        }
#line 790
        tmp___356 = tmp___351;
      }
#line 790
      tmp___436 = tmp___356;
    } else {
#line 790
      if (sizeof(n) == sizeof(short )) {
#line 790
        if (sizeof(n0 + nitems_incr_min) < sizeof(short )) {
#line 790
          if (~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 790
            if ((int )((short )nitems_incr_min) < 0) {
#line 790
              tmp___362 = (int )((short )n0) < ~ (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min);
            } else {
#line 790
              tmp___362 = (((1 << (sizeof((int )((short )n0)) * 8UL - 2UL)) - 1) * 2 + 1) - (int )((short )nitems_incr_min) < (int )((short )n0);
            }
#line 790
            tmp___365 = tmp___362;
          } else {
#line 790
            if ((int )((short )n0) < 0) {
#line 790
              tmp___364 = (int )((short )nitems_incr_min) <= (int )((short )n0) + (int )((short )nitems_incr_min);
            } else {
#line 790
              if ((int )((short )nitems_incr_min) < 0) {
#line 790
                tmp___363 = (int )((short )n0) <= (int )((short )n0) + (int )((short )nitems_incr_min);
              } else {
#line 790
                tmp___363 = (int )((short )n0) + (int )((short )nitems_incr_min) < (int )((short )nitems_incr_min);
              }
#line 790
              tmp___364 = tmp___363;
            }
#line 790
            tmp___365 = tmp___364;
          }
#line 790
          if (tmp___365) {
#line 790
            goto _L___71;
          } else
#line 790
          if ((int )((short )n0) + (int )((short )nitems_incr_min) < -32768) {
#line 790
            goto _L___71;
          } else
#line 790
          if (32767 < (int )((short )n0) + (int )((short )nitems_incr_min)) {
            _L___71: /* CIL Label */ 
#line 790
            if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min)) <= 32767) {
#line 790
              n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))));
            } else {
#line 790
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))) - -32768)) + -32768);
            }
#line 790
            tmp___361 = 1;
          } else {
#line 790
            if ((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min)) <= 32767) {
#line 790
              n = (ptrdiff_t )((short )((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))));
            } else {
#line 790
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )((short )n0)) + (int )((unsigned short )((short )nitems_incr_min))) - -32768)) + -32768);
            }
#line 790
            tmp___361 = 0;
          }
#line 790
          tmp___375 = tmp___361;
        } else {
#line 790
          if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 790
            if (nitems_incr_min < 0L) {
#line 790
              tmp___371 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
            } else {
#line 790
              tmp___371 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
            }
#line 790
            tmp___374 = tmp___371;
          } else {
#line 790
            if (n0 < 0L) {
#line 790
              tmp___373 = nitems_incr_min <= n0 + nitems_incr_min;
            } else {
#line 790
              if (nitems_incr_min < 0L) {
#line 790
                tmp___372 = n0 <= n0 + nitems_incr_min;
              } else {
#line 790
                tmp___372 = n0 + nitems_incr_min < nitems_incr_min;
              }
#line 790
              tmp___373 = tmp___372;
            }
#line 790
            tmp___374 = tmp___373;
          }
#line 790
          if (tmp___374) {
#line 790
            goto _L___72;
          } else
#line 790
          if (n0 + nitems_incr_min < -32768L) {
#line 790
            goto _L___72;
          } else
#line 790
          if (32767L < n0 + nitems_incr_min) {
            _L___72: /* CIL Label */ 
#line 790
            if ((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min) <= 32767) {
#line 790
              n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)));
            } else {
#line 790
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)) - -32768)) + -32768);
            }
#line 790
            tmp___370 = 1;
          } else {
#line 790
            if ((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min) <= 32767) {
#line 790
              n = (ptrdiff_t )((short )((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)));
            } else {
#line 790
              n = (ptrdiff_t )((int )((short )(((int )((unsigned short )n0) + (int )((unsigned short )nitems_incr_min)) - -32768)) + -32768);
            }
#line 790
            tmp___370 = 0;
          }
#line 790
          tmp___375 = tmp___370;
        }
#line 790
        tmp___435 = tmp___375;
      } else {
#line 790
        if (sizeof(n) == sizeof(int )) {
#line 790
          if (sizeof(n0 + nitems_incr_min) < sizeof(int )) {
#line 790
            if (~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) < 0) {
#line 790
              if ((int )nitems_incr_min < 0) {
#line 790
                tmp___381 = (int )n0 < ~ (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min;
              } else {
#line 790
                tmp___381 = (((1 << (sizeof((int )n0) * 8UL - 2UL)) - 1) * 2 + 1) - (int )nitems_incr_min < (int )n0;
              }
#line 790
              tmp___384 = tmp___381;
            } else {
#line 790
              if ((int )n0 < 0) {
#line 790
                tmp___383 = (int )nitems_incr_min <= (int )n0 + (int )nitems_incr_min;
              } else {
#line 790
                if ((int )nitems_incr_min < 0) {
#line 790
                  tmp___382 = (int )n0 <= (int )n0 + (int )nitems_incr_min;
                } else {
#line 790
                  tmp___382 = (int )n0 + (int )nitems_incr_min < (int )nitems_incr_min;
                }
#line 790
                tmp___383 = tmp___382;
              }
#line 790
              tmp___384 = tmp___383;
            }
#line 790
            if (tmp___384) {
#line 790
              goto _L___73;
            } else
#line 790
            if ((int )n0 + (int )nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 790
              goto _L___73;
            } else
#line 790
            if (2147483647 < (int )n0 + (int )nitems_incr_min) {
              _L___73: /* CIL Label */ 
#line 790
              if ((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min) <= 2147483647U) {
#line 790
                n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
              } else {
#line 790
                n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 790
              tmp___380 = 1;
            } else {
#line 790
              if ((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min) <= 2147483647U) {
#line 790
                n = (ptrdiff_t )((int )((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)));
              } else {
#line 790
                n = (ptrdiff_t )((int )(((unsigned int )((int )n0) + (unsigned int )((int )nitems_incr_min)) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 790
              tmp___380 = 0;
            }
#line 790
            tmp___394 = tmp___380;
          } else {
#line 790
            if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 790
              if (nitems_incr_min < 0L) {
#line 790
                tmp___390 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
              } else {
#line 790
                tmp___390 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
              }
#line 790
              tmp___393 = tmp___390;
            } else {
#line 790
              if (n0 < 0L) {
#line 790
                tmp___392 = nitems_incr_min <= n0 + nitems_incr_min;
              } else {
#line 790
                if (nitems_incr_min < 0L) {
#line 790
                  tmp___391 = n0 <= n0 + nitems_incr_min;
                } else {
#line 790
                  tmp___391 = n0 + nitems_incr_min < nitems_incr_min;
                }
#line 790
                tmp___392 = tmp___391;
              }
#line 790
              tmp___393 = tmp___392;
            }
#line 790
            if (tmp___393) {
#line 790
              goto _L___74;
            } else
#line 790
            if (n0 + nitems_incr_min < (-0x7FFFFFFF-1)) {
#line 790
              goto _L___74;
            } else
#line 790
            if (2147483647L < n0 + nitems_incr_min) {
              _L___74: /* CIL Label */ 
#line 790
              if ((unsigned int )n0 + (unsigned int )nitems_incr_min <= 2147483647U) {
#line 790
                n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
              } else {
#line 790
                n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )nitems_incr_min) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 790
              tmp___389 = 1;
            } else {
#line 790
              if ((unsigned int )n0 + (unsigned int )nitems_incr_min <= 2147483647U) {
#line 790
                n = (ptrdiff_t )((int )((unsigned int )n0 + (unsigned int )nitems_incr_min));
              } else {
#line 790
                n = (ptrdiff_t )((int )(((unsigned int )n0 + (unsigned int )nitems_incr_min) - 2147483648U) + (-0x7FFFFFFF-1));
              }
#line 790
              tmp___389 = 0;
            }
#line 790
            tmp___394 = tmp___389;
          }
#line 790
          tmp___434 = tmp___394;
        } else {
#line 790
          if (sizeof(n) == sizeof(long )) {
#line 790
            if (sizeof(n0 + nitems_incr_min) < sizeof(long )) {
#line 790
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 790
                if (nitems_incr_min < 0L) {
#line 790
                  tmp___400 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 790
                  tmp___400 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 790
                tmp___403 = tmp___400;
              } else {
#line 790
                if (n0 < 0L) {
#line 790
                  tmp___402 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 790
                  if (nitems_incr_min < 0L) {
#line 790
                    tmp___401 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 790
                    tmp___401 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 790
                  tmp___402 = tmp___401;
                }
#line 790
                tmp___403 = tmp___402;
              }
#line 790
              if (tmp___403) {
#line 790
                goto _L___75;
              } else
#line 790
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                goto _L___75;
              } else
#line 790
              if (9223372036854775807L < n0 + nitems_incr_min) {
                _L___75: /* CIL Label */ 
#line 790
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 790
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 790
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 790
                tmp___399 = 1;
              } else {
#line 790
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 790
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 790
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 790
                tmp___399 = 0;
              }
#line 790
              tmp___413 = tmp___399;
            } else {
#line 790
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 790
                if (nitems_incr_min < 0L) {
#line 790
                  tmp___409 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 790
                  tmp___409 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 790
                tmp___412 = tmp___409;
              } else {
#line 790
                if (n0 < 0L) {
#line 790
                  tmp___411 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 790
                  if (nitems_incr_min < 0L) {
#line 790
                    tmp___410 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 790
                    tmp___410 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 790
                  tmp___411 = tmp___410;
                }
#line 790
                tmp___412 = tmp___411;
              }
#line 790
              if (tmp___412) {
#line 790
                goto _L___76;
              } else
#line 790
              if (n0 + nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                goto _L___76;
              } else
#line 790
              if (9223372036854775807L < n0 + nitems_incr_min) {
                _L___76: /* CIL Label */ 
#line 790
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 790
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 790
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 790
                tmp___408 = 1;
              } else {
#line 790
                if ((unsigned long )n0 + (unsigned long )nitems_incr_min <= 9223372036854775807UL) {
#line 790
                  n = (long )((unsigned long )n0 + (unsigned long )nitems_incr_min);
                } else {
#line 790
                  n = (long )(((unsigned long )n0 + (unsigned long )nitems_incr_min) - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                }
#line 790
                tmp___408 = 0;
              }
#line 790
              tmp___413 = tmp___408;
            }
#line 790
            tmp___433 = tmp___413;
          } else {
#line 790
            if (sizeof(n0 + nitems_incr_min) < sizeof(long long )) {
#line 790
              if (~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) < 0LL) {
#line 790
                if ((long long )nitems_incr_min < 0LL) {
#line 790
                  tmp___419 = (long long )n0 < ~ (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min;
                } else {
#line 790
                  tmp___419 = (((1LL << (sizeof((long long )n0) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) - (long long )nitems_incr_min < (long long )n0;
                }
#line 790
                tmp___422 = tmp___419;
              } else {
#line 790
                if ((long long )n0 < 0LL) {
#line 790
                  tmp___421 = (long long )nitems_incr_min <= (long long )n0 + (long long )nitems_incr_min;
                } else {
#line 790
                  if ((long long )nitems_incr_min < 0LL) {
#line 790
                    tmp___420 = (long long )n0 <= (long long )n0 + (long long )nitems_incr_min;
                  } else {
#line 790
                    tmp___420 = (long long )n0 + (long long )nitems_incr_min < (long long )nitems_incr_min;
                  }
#line 790
                  tmp___421 = tmp___420;
                }
#line 790
                tmp___422 = tmp___421;
              }
#line 790
              if (tmp___422) {
#line 790
                goto _L___77;
              } else
#line 790
              if ((long long )n0 + (long long )nitems_incr_min < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                goto _L___77;
              } else
#line 790
              if (9223372036854775807LL < (long long )n0 + (long long )nitems_incr_min) {
                _L___77: /* CIL Label */ 
#line 790
                if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min) <= 9223372036854775807ULL) {
#line 790
                  n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
                } else {
#line 790
                  n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 790
                tmp___418 = 1;
              } else {
#line 790
                if ((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min) <= 9223372036854775807ULL) {
#line 790
                  n = (ptrdiff_t )((long long )((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)));
                } else {
#line 790
                  n = (ptrdiff_t )((long long )(((unsigned long long )((long long )n0) + (unsigned long long )((long long )nitems_incr_min)) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 790
                tmp___418 = 0;
              }
#line 790
              tmp___432 = tmp___418;
            } else {
#line 790
              if (~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 790
                if (nitems_incr_min < 0L) {
#line 790
                  tmp___428 = n0 < ~ (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min;
                } else {
#line 790
                  tmp___428 = (((1L << (sizeof(n0) * 8UL - 2UL)) - 1L) * 2L + 1L) - nitems_incr_min < n0;
                }
#line 790
                tmp___431 = tmp___428;
              } else {
#line 790
                if (n0 < 0L) {
#line 790
                  tmp___430 = nitems_incr_min <= n0 + nitems_incr_min;
                } else {
#line 790
                  if (nitems_incr_min < 0L) {
#line 790
                    tmp___429 = n0 <= n0 + nitems_incr_min;
                  } else {
#line 790
                    tmp___429 = n0 + nitems_incr_min < nitems_incr_min;
                  }
#line 790
                  tmp___430 = tmp___429;
                }
#line 790
                tmp___431 = tmp___430;
              }
#line 790
              if (tmp___431) {
#line 790
                goto _L___78;
              } else
#line 790
              if ((long long )(n0 + nitems_incr_min) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                goto _L___78;
              } else
#line 790
              if (9223372036854775807LL < (long long )(n0 + nitems_incr_min)) {
                _L___78: /* CIL Label */ 
#line 790
                if ((unsigned long long )n0 + (unsigned long long )nitems_incr_min <= 9223372036854775807ULL) {
#line 790
                  n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
                } else {
#line 790
                  n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )nitems_incr_min) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 790
                tmp___427 = 1;
              } else {
#line 790
                if ((unsigned long long )n0 + (unsigned long long )nitems_incr_min <= 9223372036854775807ULL) {
#line 790
                  n = (ptrdiff_t )((long long )((unsigned long long )n0 + (unsigned long long )nitems_incr_min));
                } else {
#line 790
                  n = (ptrdiff_t )((long long )(((unsigned long long )n0 + (unsigned long long )nitems_incr_min) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                }
#line 790
                tmp___427 = 0;
              }
#line 790
              tmp___432 = tmp___427;
            }
#line 790
            tmp___433 = tmp___432;
          }
#line 790
          tmp___434 = tmp___433;
        }
#line 790
        tmp___435 = tmp___434;
      }
#line 790
      tmp___436 = tmp___435;
    }
#line 790
    if (tmp___436) {
      {
#line 794
      xalloc_die();
      }
    } else
#line 790
    if (0L <= nitems_max) {
#line 790
      if (nitems_max < n) {
        {
#line 794
        xalloc_die();
        }
      } else {
#line 790
        goto _L___109;
      }
    } else {
      _L___109: /* CIL Label */ 
#line 790
      if (sizeof(nbytes) == sizeof(signed char )) {
#line 790
        if (sizeof(n * item_size) < sizeof(signed char )) {
#line 790
          if (~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 790
            if ((int )((signed char )n) < 0) {
#line 790
              if (0 < (int )((signed char )item_size)) {
#line 790
                goto _L___79;
              } else {
#line 790
                goto _L___81;
              }
            } else
            _L___81: /* CIL Label */ 
#line 790
            if ((int )((signed char )item_size) < 0) {
#line 790
              if (0 < (int )((signed char )n)) {
#line 790
                goto _L___79;
              } else {
#line 790
                goto _L___80;
              }
            } else {
#line 790
              goto _L___80;
            }
          } else {
            _L___80: /* CIL Label */ 
#line 790
            if ((int )((signed char )item_size) < 0) {
#line 790
              if ((int )((signed char )n) < 0) {
#line 790
                tmp___444 = (int )((signed char )n) < (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
              } else {
#line 790
                if ((int )((signed char )item_size) == -1) {
#line 790
                  tmp___443 = 0;
                } else {
#line 790
                  tmp___443 = ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 790
                tmp___444 = tmp___443;
              }
#line 790
              tmp___447 = tmp___444;
            } else {
#line 790
              if ((int )((signed char )item_size) == 0) {
#line 790
                tmp___446 = 0;
              } else {
#line 790
                if ((int )((signed char )n) < 0) {
#line 790
                  tmp___445 = (int )((signed char )n) < ~ (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size);
                } else {
#line 790
                  tmp___445 = (((1 << (sizeof((int )((signed char )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((signed char )item_size) < (int )((signed char )n);
                }
#line 790
                tmp___446 = tmp___445;
              }
#line 790
              tmp___447 = tmp___446;
            }
#line 790
            if (tmp___447) {
#line 790
              goto _L___79;
            } else
#line 790
            if ((int )((signed char )n) * (int )((signed char )item_size) < -128) {
#line 790
              goto _L___79;
            } else
#line 790
            if (127 < (int )((signed char )n) * (int )((signed char )item_size)) {
              _L___79: /* CIL Label */ 
#line 790
              if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 790
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
              } else {
#line 790
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
              }
#line 790
              tmp___442 = 1;
            } else {
#line 790
              if ((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) <= 127) {
#line 790
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size))));
              } else {
#line 790
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )((signed char )n)) * (int )((unsigned char )((signed char )item_size)) - -128)) + -128);
              }
#line 790
              tmp___442 = 0;
            }
          }
#line 790
          tmp___459 = tmp___442;
        } else {
#line 790
          if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 790
            if (n < 0L) {
#line 790
              if (0L < item_size) {
#line 790
                goto _L___82;
              } else {
#line 790
                goto _L___84;
              }
            } else
            _L___84: /* CIL Label */ 
#line 790
            if (item_size < 0L) {
#line 790
              if (0L < n) {
#line 790
                goto _L___82;
              } else {
#line 790
                goto _L___83;
              }
            } else {
#line 790
              goto _L___83;
            }
          } else {
            _L___83: /* CIL Label */ 
#line 790
            if (item_size < 0L) {
#line 790
              if (n < 0L) {
#line 790
                tmp___455 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
              } else {
#line 790
                if (item_size == -1L) {
#line 790
                  tmp___454 = 0;
                } else {
#line 790
                  tmp___454 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 790
                tmp___455 = tmp___454;
              }
#line 790
              tmp___458 = tmp___455;
            } else {
#line 790
              if (item_size == 0L) {
#line 790
                tmp___457 = 0;
              } else {
#line 790
                if (n < 0L) {
#line 790
                  tmp___456 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 790
                  tmp___456 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                }
#line 790
                tmp___457 = tmp___456;
              }
#line 790
              tmp___458 = tmp___457;
            }
#line 790
            if (tmp___458) {
#line 790
              goto _L___82;
            } else
#line 790
            if (n * item_size < -128L) {
#line 790
              goto _L___82;
            } else
#line 790
            if (127L < n * item_size) {
              _L___82: /* CIL Label */ 
#line 790
              if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 790
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
              } else {
#line 790
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
              }
#line 790
              tmp___453 = 1;
            } else {
#line 790
              if ((int )((unsigned char )n) * (int )((unsigned char )item_size) <= 127) {
#line 790
                nbytes = (ptrdiff_t )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size)));
              } else {
#line 790
                nbytes = (ptrdiff_t )((int )((signed char )((int )((unsigned char )n) * (int )((unsigned char )item_size) - -128)) + -128);
              }
#line 790
              tmp___453 = 0;
            }
          }
#line 790
          tmp___459 = tmp___453;
        }
#line 790
        tmp___555 = tmp___459;
      } else {
#line 790
        if (sizeof(nbytes) == sizeof(short )) {
#line 790
          if (sizeof(n * item_size) < sizeof(short )) {
#line 790
            if (~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 790
              if ((int )((short )n) < 0) {
#line 790
                if (0 < (int )((short )item_size)) {
#line 790
                  goto _L___85;
                } else {
#line 790
                  goto _L___87;
                }
              } else
              _L___87: /* CIL Label */ 
#line 790
              if ((int )((short )item_size) < 0) {
#line 790
                if (0 < (int )((short )n)) {
#line 790
                  goto _L___85;
                } else {
#line 790
                  goto _L___86;
                }
              } else {
#line 790
                goto _L___86;
              }
            } else {
              _L___86: /* CIL Label */ 
#line 790
              if ((int )((short )item_size) < 0) {
#line 790
                if ((int )((short )n) < 0) {
#line 790
                  tmp___467 = (int )((short )n) < (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                } else {
#line 790
                  if ((int )((short )item_size) == -1) {
#line 790
                    tmp___466 = 0;
                  } else {
#line 790
                    tmp___466 = ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 790
                  tmp___467 = tmp___466;
                }
#line 790
                tmp___470 = tmp___467;
              } else {
#line 790
                if ((int )((short )item_size) == 0) {
#line 790
                  tmp___469 = 0;
                } else {
#line 790
                  if ((int )((short )n) < 0) {
#line 790
                    tmp___468 = (int )((short )n) < ~ (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size);
                  } else {
#line 790
                    tmp___468 = (((1 << (sizeof((int )((short )n)) * 8UL - 2UL)) - 1) * 2 + 1) / (int )((short )item_size) < (int )((short )n);
                  }
#line 790
                  tmp___469 = tmp___468;
                }
#line 790
                tmp___470 = tmp___469;
              }
#line 790
              if (tmp___470) {
#line 790
                goto _L___85;
              } else
#line 790
              if ((int )((short )n) * (int )((short )item_size) < -32768) {
#line 790
                goto _L___85;
              } else
#line 790
              if (32767 < (int )((short )n) * (int )((short )item_size)) {
                _L___85: /* CIL Label */ 
#line 790
                if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 790
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
                } else {
#line 790
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
                }
#line 790
                tmp___465 = 1;
              } else {
#line 790
                if ((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) <= 32767) {
#line 790
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size))));
                } else {
#line 790
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )((short )n)) * (int )((unsigned short )((short )item_size)) - -32768)) + -32768);
                }
#line 790
                tmp___465 = 0;
              }
            }
#line 790
            tmp___482 = tmp___465;
          } else {
#line 790
            if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 790
              if (n < 0L) {
#line 790
                if (0L < item_size) {
#line 790
                  goto _L___88;
                } else {
#line 790
                  goto _L___90;
                }
              } else
              _L___90: /* CIL Label */ 
#line 790
              if (item_size < 0L) {
#line 790
                if (0L < n) {
#line 790
                  goto _L___88;
                } else {
#line 790
                  goto _L___89;
                }
              } else {
#line 790
                goto _L___89;
              }
            } else {
              _L___89: /* CIL Label */ 
#line 790
              if (item_size < 0L) {
#line 790
                if (n < 0L) {
#line 790
                  tmp___478 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                } else {
#line 790
                  if (item_size == -1L) {
#line 790
                    tmp___477 = 0;
                  } else {
#line 790
                    tmp___477 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 790
                  tmp___478 = tmp___477;
                }
#line 790
                tmp___481 = tmp___478;
              } else {
#line 790
                if (item_size == 0L) {
#line 790
                  tmp___480 = 0;
                } else {
#line 790
                  if (n < 0L) {
#line 790
                    tmp___479 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 790
                    tmp___479 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                  }
#line 790
                  tmp___480 = tmp___479;
                }
#line 790
                tmp___481 = tmp___480;
              }
#line 790
              if (tmp___481) {
#line 790
                goto _L___88;
              } else
#line 790
              if (n * item_size < -32768L) {
#line 790
                goto _L___88;
              } else
#line 790
              if (32767L < n * item_size) {
                _L___88: /* CIL Label */ 
#line 790
                if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 790
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
                } else {
#line 790
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
                }
#line 790
                tmp___476 = 1;
              } else {
#line 790
                if ((int )((unsigned short )n) * (int )((unsigned short )item_size) <= 32767) {
#line 790
                  nbytes = (ptrdiff_t )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size)));
                } else {
#line 790
                  nbytes = (ptrdiff_t )((int )((short )((int )((unsigned short )n) * (int )((unsigned short )item_size) - -32768)) + -32768);
                }
#line 790
                tmp___476 = 0;
              }
            }
#line 790
            tmp___482 = tmp___476;
          }
#line 790
          tmp___554 = tmp___482;
        } else {
#line 790
          if (sizeof(nbytes) == sizeof(int )) {
#line 790
            if (sizeof(n * item_size) < sizeof(int )) {
#line 790
              if (~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) == 0) {
#line 790
                if ((int )n < 0) {
#line 790
                  if (0 < (int )item_size) {
#line 790
                    goto _L___91;
                  } else {
#line 790
                    goto _L___93;
                  }
                } else
                _L___93: /* CIL Label */ 
#line 790
                if ((int )item_size < 0) {
#line 790
                  if (0 < (int )n) {
#line 790
                    goto _L___91;
                  } else {
#line 790
                    goto _L___92;
                  }
                } else {
#line 790
                  goto _L___92;
                }
              } else {
                _L___92: /* CIL Label */ 
#line 790
                if ((int )item_size < 0) {
#line 790
                  if ((int )n < 0) {
#line 790
                    tmp___490 = (int )n < (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                  } else {
#line 790
                    if ((int )item_size == -1) {
#line 790
                      tmp___489 = 0;
                    } else {
#line 790
                      tmp___489 = ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 790
                    tmp___490 = tmp___489;
                  }
#line 790
                  tmp___493 = tmp___490;
                } else {
#line 790
                  if ((int )item_size == 0) {
#line 790
                    tmp___492 = 0;
                  } else {
#line 790
                    if ((int )n < 0) {
#line 790
                      tmp___491 = (int )n < ~ (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size;
                    } else {
#line 790
                      tmp___491 = (((1 << (sizeof((int )n) * 8UL - 2UL)) - 1) * 2 + 1) / (int )item_size < (int )n;
                    }
#line 790
                    tmp___492 = tmp___491;
                  }
#line 790
                  tmp___493 = tmp___492;
                }
#line 790
                if (tmp___493) {
#line 790
                  goto _L___91;
                } else
#line 790
                if ((int )n * (int )item_size < (-0x7FFFFFFF-1)) {
#line 790
                  goto _L___91;
                } else
#line 790
                if (2147483647 < (int )n * (int )item_size) {
                  _L___91: /* CIL Label */ 
#line 790
                  if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
                  } else {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 790
                  tmp___488 = 1;
                } else {
#line 790
                  if ((unsigned int )((int )n) * (unsigned int )((int )item_size) <= 2147483647U) {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size)));
                  } else {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )((int )n) * (unsigned int )((int )item_size) - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 790
                  tmp___488 = 0;
                }
              }
#line 790
              tmp___505 = tmp___488;
            } else {
#line 790
              if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 790
                if (n < 0L) {
#line 790
                  if (0L < item_size) {
#line 790
                    goto _L___94;
                  } else {
#line 790
                    goto _L___96;
                  }
                } else
                _L___96: /* CIL Label */ 
#line 790
                if (item_size < 0L) {
#line 790
                  if (0L < n) {
#line 790
                    goto _L___94;
                  } else {
#line 790
                    goto _L___95;
                  }
                } else {
#line 790
                  goto _L___95;
                }
              } else {
                _L___95: /* CIL Label */ 
#line 790
                if (item_size < 0L) {
#line 790
                  if (n < 0L) {
#line 790
                    tmp___501 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                  } else {
#line 790
                    if (item_size == -1L) {
#line 790
                      tmp___500 = 0;
                    } else {
#line 790
                      tmp___500 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 790
                    tmp___501 = tmp___500;
                  }
#line 790
                  tmp___504 = tmp___501;
                } else {
#line 790
                  if (item_size == 0L) {
#line 790
                    tmp___503 = 0;
                  } else {
#line 790
                    if (n < 0L) {
#line 790
                      tmp___502 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 790
                      tmp___502 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                    }
#line 790
                    tmp___503 = tmp___502;
                  }
#line 790
                  tmp___504 = tmp___503;
                }
#line 790
                if (tmp___504) {
#line 790
                  goto _L___94;
                } else
#line 790
                if (n * item_size < (-0x7FFFFFFF-1)) {
#line 790
                  goto _L___94;
                } else
#line 790
                if (2147483647L < n * item_size) {
                  _L___94: /* CIL Label */ 
#line 790
                  if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
                  } else {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 790
                  tmp___499 = 1;
                } else {
#line 790
                  if ((unsigned int )n * (unsigned int )item_size <= 2147483647U) {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size));
                  } else {
#line 790
                    nbytes = (ptrdiff_t )((int )((unsigned int )n * (unsigned int )item_size - 2147483648U) + (-0x7FFFFFFF-1));
                  }
#line 790
                  tmp___499 = 0;
                }
              }
#line 790
              tmp___505 = tmp___499;
            }
#line 790
            tmp___553 = tmp___505;
          } else {
#line 790
            if (sizeof(nbytes) == sizeof(long )) {
#line 790
              if (sizeof(n * item_size) < sizeof(long )) {
#line 790
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 790
                  if (n < 0L) {
#line 790
                    if (0L < item_size) {
#line 790
                      goto _L___97;
                    } else {
#line 790
                      goto _L___99;
                    }
                  } else
                  _L___99: /* CIL Label */ 
#line 790
                  if (item_size < 0L) {
#line 790
                    if (0L < n) {
#line 790
                      goto _L___97;
                    } else {
#line 790
                      goto _L___98;
                    }
                  } else {
#line 790
                    goto _L___98;
                  }
                } else {
                  _L___98: /* CIL Label */ 
#line 790
                  if (item_size < 0L) {
#line 790
                    if (n < 0L) {
#line 790
                      tmp___513 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 790
                      if (item_size == -1L) {
#line 790
                        tmp___512 = 0;
                      } else {
#line 790
                        tmp___512 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 790
                      tmp___513 = tmp___512;
                    }
#line 790
                    tmp___516 = tmp___513;
                  } else {
#line 790
                    if (item_size == 0L) {
#line 790
                      tmp___515 = 0;
                    } else {
#line 790
                      if (n < 0L) {
#line 790
                        tmp___514 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 790
                        tmp___514 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 790
                      tmp___515 = tmp___514;
                    }
#line 790
                    tmp___516 = tmp___515;
                  }
#line 790
                  if (tmp___516) {
#line 790
                    goto _L___97;
                  } else
#line 790
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                    goto _L___97;
                  } else
#line 790
                  if (9223372036854775807L < n * item_size) {
                    _L___97: /* CIL Label */ 
#line 790
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 790
                    tmp___511 = 1;
                  } else {
#line 790
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 790
                    tmp___511 = 0;
                  }
                }
#line 790
                tmp___528 = tmp___511;
              } else {
#line 790
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 790
                  if (n < 0L) {
#line 790
                    if (0L < item_size) {
#line 790
                      goto _L___100;
                    } else {
#line 790
                      goto _L___102;
                    }
                  } else
                  _L___102: /* CIL Label */ 
#line 790
                  if (item_size < 0L) {
#line 790
                    if (0L < n) {
#line 790
                      goto _L___100;
                    } else {
#line 790
                      goto _L___101;
                    }
                  } else {
#line 790
                    goto _L___101;
                  }
                } else {
                  _L___101: /* CIL Label */ 
#line 790
                  if (item_size < 0L) {
#line 790
                    if (n < 0L) {
#line 790
                      tmp___524 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 790
                      if (item_size == -1L) {
#line 790
                        tmp___523 = 0;
                      } else {
#line 790
                        tmp___523 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 790
                      tmp___524 = tmp___523;
                    }
#line 790
                    tmp___527 = tmp___524;
                  } else {
#line 790
                    if (item_size == 0L) {
#line 790
                      tmp___526 = 0;
                    } else {
#line 790
                      if (n < 0L) {
#line 790
                        tmp___525 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 790
                        tmp___525 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 790
                      tmp___526 = tmp___525;
                    }
#line 790
                    tmp___527 = tmp___526;
                  }
#line 790
                  if (tmp___527) {
#line 790
                    goto _L___100;
                  } else
#line 790
                  if (n * item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                    goto _L___100;
                  } else
#line 790
                  if (9223372036854775807L < n * item_size) {
                    _L___100: /* CIL Label */ 
#line 790
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 790
                    tmp___522 = 1;
                  } else {
#line 790
                    if ((unsigned long )n * (unsigned long )item_size <= 9223372036854775807UL) {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size);
                    } else {
#line 790
                      nbytes = (long )((unsigned long )n * (unsigned long )item_size - 0x8000000000000000UL) + (-0x7FFFFFFFFFFFFFFF-1);
                    }
#line 790
                    tmp___522 = 0;
                  }
                }
#line 790
                tmp___528 = tmp___522;
              }
#line 790
              tmp___552 = tmp___528;
            } else {
#line 790
              if (sizeof(n * item_size) < sizeof(long long )) {
#line 790
                if (~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) == 0LL) {
#line 790
                  if ((long long )n < 0LL) {
#line 790
                    if (0LL < (long long )item_size) {
#line 790
                      goto _L___103;
                    } else {
#line 790
                      goto _L___105;
                    }
                  } else
                  _L___105: /* CIL Label */ 
#line 790
                  if ((long long )item_size < 0LL) {
#line 790
                    if (0LL < (long long )n) {
#line 790
                      goto _L___103;
                    } else {
#line 790
                      goto _L___104;
                    }
                  } else {
#line 790
                    goto _L___104;
                  }
                } else {
                  _L___104: /* CIL Label */ 
#line 790
                  if ((long long )item_size < 0LL) {
#line 790
                    if ((long long )n < 0LL) {
#line 790
                      tmp___536 = (long long )n < (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                    } else {
#line 790
                      if ((long long )item_size == -1LL) {
#line 790
                        tmp___535 = 0;
                      } else {
#line 790
                        tmp___535 = ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 790
                      tmp___536 = tmp___535;
                    }
#line 790
                    tmp___539 = tmp___536;
                  } else {
#line 790
                    if ((long long )item_size == 0LL) {
#line 790
                      tmp___538 = 0;
                    } else {
#line 790
                      if ((long long )n < 0LL) {
#line 790
                        tmp___537 = (long long )n < ~ (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size;
                      } else {
#line 790
                        tmp___537 = (((1LL << (sizeof((long long )n) * 8UL - 2UL)) - 1LL) * 2LL + 1LL) / (long long )item_size < (long long )n;
                      }
#line 790
                      tmp___538 = tmp___537;
                    }
#line 790
                    tmp___539 = tmp___538;
                  }
#line 790
                  if (tmp___539) {
#line 790
                    goto _L___103;
                  } else
#line 790
                  if ((long long )n * (long long )item_size < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                    goto _L___103;
                  } else
#line 790
                  if (9223372036854775807LL < (long long )n * (long long )item_size) {
                    _L___103: /* CIL Label */ 
#line 790
                    if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                    } else {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 790
                    tmp___534 = 1;
                  } else {
#line 790
                    if ((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) <= 9223372036854775807ULL) {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size)));
                    } else {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )((long long )n) * (unsigned long long )((long long )item_size) - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 790
                    tmp___534 = 0;
                  }
                }
#line 790
                tmp___551 = tmp___534;
              } else {
#line 790
                if (~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) == 0L) {
#line 790
                  if (n < 0L) {
#line 790
                    if (0L < item_size) {
#line 790
                      goto _L___106;
                    } else {
#line 790
                      goto _L___108;
                    }
                  } else
                  _L___108: /* CIL Label */ 
#line 790
                  if (item_size < 0L) {
#line 790
                    if (0L < n) {
#line 790
                      goto _L___106;
                    } else {
#line 790
                      goto _L___107;
                    }
                  } else {
#line 790
                    goto _L___107;
                  }
                } else {
                  _L___107: /* CIL Label */ 
#line 790
                  if (item_size < 0L) {
#line 790
                    if (n < 0L) {
#line 790
                      tmp___547 = n < (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                    } else {
#line 790
                      if (item_size == -1L) {
#line 790
                        tmp___546 = 0;
                      } else {
#line 790
                        tmp___546 = ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 790
                      tmp___547 = tmp___546;
                    }
#line 790
                    tmp___550 = tmp___547;
                  } else {
#line 790
                    if (item_size == 0L) {
#line 790
                      tmp___549 = 0;
                    } else {
#line 790
                      if (n < 0L) {
#line 790
                        tmp___548 = n < ~ (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size;
                      } else {
#line 790
                        tmp___548 = (((1L << (sizeof(n) * 8UL - 2UL)) - 1L) * 2L + 1L) / item_size < n;
                      }
#line 790
                      tmp___549 = tmp___548;
                    }
#line 790
                    tmp___550 = tmp___549;
                  }
#line 790
                  if (tmp___550) {
#line 790
                    goto _L___106;
                  } else
#line 790
                  if ((long long )(n * item_size) < (-0x7FFFFFFFFFFFFFFF-1)) {
#line 790
                    goto _L___106;
                  } else
#line 790
                  if (9223372036854775807LL < (long long )(n * item_size)) {
                    _L___106: /* CIL Label */ 
#line 790
                    if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                    } else {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 790
                    tmp___545 = 1;
                  } else {
#line 790
                    if ((unsigned long long )n * (unsigned long long )item_size <= 9223372036854775807ULL) {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size));
                    } else {
#line 790
                      nbytes = (ptrdiff_t )((long long )((unsigned long long )n * (unsigned long long )item_size - 0x8000000000000000ULL) + (-0x7FFFFFFFFFFFFFFF-1));
                    }
#line 790
                    tmp___545 = 0;
                  }
                }
#line 790
                tmp___551 = tmp___545;
              }
#line 790
              tmp___552 = tmp___551;
            }
#line 790
            tmp___553 = tmp___552;
          }
#line 790
          tmp___554 = tmp___553;
        }
#line 790
        tmp___555 = tmp___554;
      }
#line 790
      if (tmp___555) {
        {
#line 794
        xalloc_die();
        }
      }
    }
  }
  {
#line 795
  pa = xrealloc(pa, (size_t )nbytes);
#line 796
  *nitems = n;
  }
#line 797
  return (pa);
}
}
#line 809 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void *maybe_realloc(void *pa , ptrdiff_t i , ptrdiff_t *nitems , ptrdiff_t nitems_max ,
                           ptrdiff_t item_size ) 
{ 
  void *tmp ;

  {
#line 813
  if (i < *nitems) {
#line 814
    return (pa);
  }
  {
#line 815
  tmp = xpalloc(pa, nitems, (ptrdiff_t )1, nitems_max, item_size);
  }
#line 815
  return (tmp);
}
}
#line 819 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static ptrdiff_t charclass_index(struct dfa *d , charclass_word * const  s ) 
{ 
  ptrdiff_t i ;
  _Bool tmp ;
  void *tmp___0 ;

  {
#line 824
  i = (ptrdiff_t )0;
  {
#line 824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 824
    if (! (i < d->cindex)) {
#line 824
      goto while_break;
    }
    {
#line 825
    tmp = equal(s, (charclass_word */* const  */)(*(d->charclasses + i)));
    }
#line 825
    if (tmp) {
#line 826
      return (i);
    }
#line 824
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 827
  tmp___0 = maybe_realloc((void *)d->charclasses, d->cindex, & d->calloc, 9223372036854775532L,
                          (ptrdiff_t )sizeof(*(d->charclasses)));
#line 827
  d->charclasses = (charclass *)tmp___0;
#line 829
  (d->cindex) ++;
#line 830
  copyset(s, (charclass_word *)(*(d->charclasses + i)));
  }
#line 831
  return (i);
}
}
#line 834 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool unibyte_word_constituent(struct dfa  const  *dfa , unsigned char c ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 837
  if (dfa->localeinfo.sbctowc[c] != 4294967295U) {
    {
#line 837
    tmp = __ctype_b_loc();
    }
#line 837
    if ((int const   )*(*tmp + (int )c) & 8) {
#line 837
      tmp___0 = 1;
    } else
#line 837
    if ((int )c == 95) {
#line 837
      tmp___0 = 1;
    } else {
#line 837
      tmp___0 = 0;
    }
  } else {
#line 837
    tmp___0 = 0;
  }
#line 837
  return ((_Bool )tmp___0);
}
}
#line 840 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static int char_context(struct dfa  const  *dfa , unsigned char c ) 
{ 
  _Bool tmp ;

  {
#line 843
  if ((int )c == (int )dfa->syntax.eolbyte) {
#line 843
    if (! dfa->syntax.anchor) {
#line 844
      return (4);
    }
  }
  {
#line 845
  tmp = unibyte_word_constituent(dfa, c);
  }
#line 845
  if (tmp) {
#line 846
    return (2);
  }
#line 847
  return (1);
}
}
#line 855 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool setbit_wc(wint_t wc , charclass_word *c ) 
{ 
  int b___0 ;
  int tmp ;

  {
  {
#line 858
  tmp = wctob(wc);
#line 858
  b___0 = tmp;
  }
#line 859
  if (b___0 == -1) {
#line 860
    return ((_Bool)0);
  }
  {
#line 862
  setbit((unsigned int )b___0, c);
  }
#line 863
  return ((_Bool)1);
}
}
#line 868 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void setbit_case_fold_c(int b___0 , charclass_word *c ) 
{ 
  int ub ;
  int tmp ;
  int i ;
  int tmp___0 ;

  {
  {
#line 871
  tmp = toupper(b___0);
#line 871
  ub = tmp;
#line 873
  i = 0;
  }
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if (! (i < 256)) {
#line 873
      goto while_break;
    }
    {
#line 874
    tmp___0 = toupper(i);
    }
#line 874
    if (tmp___0 == ub) {
      {
#line 875
      setbit((unsigned int )i, c);
      }
    }
#line 873
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 876
  return;
}
}
#line 880 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool using_simple_locale(_Bool multibyte ) 
{ 
  char const   *loc ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 899
  if (multibyte) {
#line 900
    return ((_Bool)0);
  } else {
    {
#line 905
    tmp = setlocale(6, (char const   *)((void *)0));
#line 905
    loc = (char const   *)tmp;
    }
#line 906
    if (! loc) {
#line 906
      tmp___2 = 1;
    } else {
      {
#line 906
      tmp___0 = strcmp(loc, "C");
      }
#line 906
      if (tmp___0 == 0) {
#line 906
        tmp___2 = 1;
      } else {
        {
#line 906
        tmp___1 = strcmp(loc, "POSIX");
        }
#line 906
        if (tmp___1 == 0) {
#line 906
          tmp___2 = 1;
        } else {
#line 906
          tmp___2 = 0;
        }
      }
    }
#line 906
    return ((_Bool )tmp___2);
  }
}
}
#line 952 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static struct dfa_ctype  const  prednames[13]  = 
#line 952
  {      {"alpha", (predicate *)(& isalpha), (_Bool)0}, 
        {"upper", (predicate *)(& isupper), (_Bool)0}, 
        {"lower", (predicate *)(& islower), (_Bool)0}, 
        {"digit", (predicate *)(& isdigit), (_Bool)1}, 
        {"xdigit", (predicate *)(& isxdigit), (_Bool)0}, 
        {"space", (predicate *)(& isspace), (_Bool)0}, 
        {"punct", (predicate *)(& ispunct), (_Bool)0}, 
        {"alnum", (predicate *)(& isalnum), (_Bool)0}, 
        {"print", (predicate *)(& isprint), (_Bool)0}, 
        {"graph", (predicate *)(& isgraph), (_Bool)0}, 
        {"cntrl", (predicate *)(& iscntrl), (_Bool)0}, 
        {"blank", (predicate *)(& isblank), (_Bool)0}, 
        {(char const   *)((void *)0), (predicate *)((void *)0), (_Bool)0}};
#line 968 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static struct dfa_ctype  const  * __attribute__((__pure__)) find_pred(char const   *str ) 
{ 
  unsigned int i ;
  int tmp ;

  {
#line 972
  i = 0U;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 972
    if (! prednames[i].name) {
#line 972
      goto while_break;
    }
    {
#line 973
    tmp = strcmp(str, (char const   *)prednames[i].name);
    }
#line 973
    if (tmp == 0) {
#line 974
      return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)(& prednames[i]));
    }
#line 972
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 975
  return ((struct dfa_ctype  const  */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 980 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static token parse_bracket_exp(struct dfa *dfa ) 
{ 
  _Bool invert ;
  int c ;
  int c1 ;
  int c2 ;
  charclass ccl ;
  _Bool known_bracket_exp ;
  int colon_warning_state ;
  wint_t wc ;
  wint_t wc2 ;
  wint_t wc1 ;
  struct mb_char_classes *work_mbc ;
  ptrdiff_t chars_al ;
  void *tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  token tmp___2 ;
  char *tmp___3 ;
  wint_t _wc ;
  size_t nbytes ;
  size_t tmp___4 ;
  unsigned char tmp___5 ;
  char *tmp___6 ;
  token tmp___7 ;
  char *tmp___8 ;
  wint_t _wc___0 ;
  size_t nbytes___0 ;
  size_t tmp___9 ;
  unsigned char tmp___10 ;
  char *tmp___11 ;
  token tmp___12 ;
  char *tmp___13 ;
  wint_t _wc___1 ;
  size_t nbytes___1 ;
  size_t tmp___14 ;
  unsigned char tmp___15 ;
  char str[33] ;
  size_t len ;
  char *tmp___16 ;
  token tmp___17 ;
  char *tmp___18 ;
  wint_t _wc___2 ;
  size_t nbytes___2 ;
  size_t tmp___19 ;
  unsigned char tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  token tmp___23 ;
  char *tmp___24 ;
  wint_t _wc___3 ;
  size_t nbytes___3 ;
  size_t tmp___25 ;
  unsigned char tmp___26 ;
  char const   *class ;
  char const   *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  struct dfa_ctype  const  *pred ;
  struct dfa_ctype  const  * __attribute__((__pure__)) tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  token tmp___36 ;
  char *tmp___37 ;
  wint_t _wc___4 ;
  size_t nbytes___4 ;
  size_t tmp___38 ;
  unsigned char tmp___39 ;
  char *tmp___40 ;
  token tmp___41 ;
  char *tmp___42 ;
  wint_t _wc___5 ;
  size_t nbytes___5 ;
  size_t tmp___43 ;
  unsigned char tmp___44 ;
  char *tmp___45 ;
  token tmp___46 ;
  char *tmp___47 ;
  wint_t _wc___6 ;
  size_t nbytes___6 ;
  size_t tmp___48 ;
  unsigned char tmp___49 ;
  char *tmp___50 ;
  token tmp___51 ;
  char *tmp___52 ;
  wint_t _wc___7 ;
  size_t nbytes___7 ;
  size_t tmp___53 ;
  unsigned char tmp___54 ;
  char *tmp___55 ;
  token tmp___56 ;
  char *tmp___57 ;
  wint_t _wc___8 ;
  size_t nbytes___8 ;
  size_t tmp___58 ;
  unsigned char tmp___59 ;
  char *tmp___60 ;
  token tmp___61 ;
  char *tmp___62 ;
  wint_t _wc___9 ;
  size_t nbytes___9 ;
  size_t tmp___63 ;
  unsigned char tmp___64 ;
  int ci ;
  int uc ;
  int tmp___65 ;
  int uc2 ;
  int tmp___66 ;
  int uci ;
  int tmp___67 ;
  int tmp___68 ;
  wchar_t folded[33] ;
  unsigned int i ;
  unsigned int n ;
  int tmp___69 ;
  int tmp___70 ;
  void *tmp___71 ;
  ptrdiff_t tmp___72 ;
  _Bool tmp___73 ;
  char *tmp___74 ;
  ptrdiff_t tmp___76 ;
  _Bool tmp___77 ;
  ptrdiff_t tmp___79 ;

  {
#line 989
  known_bracket_exp = (_Bool)1;
#line 1000
  wc1 = (wint_t )0;
#line 1006
  chars_al = (ptrdiff_t )0;
#line 1007
  if (dfa->localeinfo.multibyte) {
    {
#line 1009
    tmp = maybe_realloc((void *)dfa->mbcsets, dfa->nmbcsets, & dfa->mbcsets_alloc,
                        (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dfa->mbcsets)));
#line 1009
    dfa->mbcsets = (struct mb_char_classes *)tmp;
#line 1018
    tmp___0 = dfa->nmbcsets;
#line 1018
    (dfa->nmbcsets) ++;
#line 1018
    work_mbc = dfa->mbcsets + tmp___0;
#line 1019
    memset((void *)work_mbc, 0, sizeof(*work_mbc));
    }
  } else {
#line 1022
    work_mbc = (struct mb_char_classes *)((void *)0);
  }
  {
#line 1024
  memset((void *)(ccl), 0, sizeof(ccl));
  }
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! dfa->lex.left) {
      {
#line 1025
      tmp___3 = gettext("unbalanced [");
      }
#line 1025
      if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
        {
#line 1025
        tmp___1 = gettext("unbalanced [");
#line 1025
        dfaerror((char const   *)tmp___1);
        }
      } else {
#line 1025
        tmp___2 = (token )-1;
#line 1025
        dfa->lex.lasttok = tmp___2;
#line 1025
        return (tmp___2);
      }
    } else {
      {
#line 1025
      tmp___4 = mbs_to_wchar(& _wc, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1025
      nbytes = tmp___4;
#line 1025
      dfa->lex.cur_mb_len = (int )nbytes;
#line 1025
      wc = _wc;
      }
#line 1025
      if (nbytes == 1UL) {
        {
#line 1025
        tmp___5 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1025
        c = (int )tmp___5;
        }
      } else {
#line 1025
        c = -1;
      }
#line 1025
      dfa->lex.ptr += nbytes;
#line 1025
      dfa->lex.left -= nbytes;
    }
#line 1025
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1026
  if (c == 94) {
    {
#line 1028
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1028
      if (! dfa->lex.left) {
        {
#line 1028
        tmp___8 = gettext("unbalanced [");
        }
#line 1028
        if ((unsigned long )tmp___8 != (unsigned long )((char *)0)) {
          {
#line 1028
          tmp___6 = gettext("unbalanced [");
#line 1028
          dfaerror((char const   *)tmp___6);
          }
        } else {
#line 1028
          tmp___7 = (token )-1;
#line 1028
          dfa->lex.lasttok = tmp___7;
#line 1028
          return (tmp___7);
        }
      } else {
        {
#line 1028
        tmp___9 = mbs_to_wchar(& _wc___0, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1028
        nbytes___0 = tmp___9;
#line 1028
        dfa->lex.cur_mb_len = (int )nbytes___0;
#line 1028
        wc = _wc___0;
        }
#line 1028
        if (nbytes___0 == 1UL) {
          {
#line 1028
          tmp___10 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1028
          c = (int )tmp___10;
          }
        } else {
#line 1028
          c = -1;
        }
#line 1028
        dfa->lex.ptr += nbytes___0;
#line 1028
        dfa->lex.left -= nbytes___0;
      }
#line 1028
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1029
    invert = (_Bool)1;
#line 1030
    known_bracket_exp = dfa->simple_locale;
  } else {
#line 1033
    invert = (_Bool)0;
  }
#line 1035
  colon_warning_state = c == 58;
  {
#line 1036
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1038
    c1 = 256;
#line 1039
    colon_warning_state &= -3;
#line 1045
    if (c == 91) {
      {
#line 1047
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1047
        if (! dfa->lex.left) {
          {
#line 1047
          tmp___13 = gettext("unbalanced [");
          }
#line 1047
          if ((unsigned long )tmp___13 != (unsigned long )((char *)0)) {
            {
#line 1047
            tmp___11 = gettext("unbalanced [");
#line 1047
            dfaerror((char const   *)tmp___11);
            }
          } else {
#line 1047
            tmp___12 = (token )-1;
#line 1047
            dfa->lex.lasttok = tmp___12;
#line 1047
            return (tmp___12);
          }
        } else {
          {
#line 1047
          tmp___14 = mbs_to_wchar(& _wc___1, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1047
          nbytes___1 = tmp___14;
#line 1047
          dfa->lex.cur_mb_len = (int )nbytes___1;
#line 1047
          wc1 = _wc___1;
          }
#line 1047
          if (nbytes___1 == 1UL) {
            {
#line 1047
            tmp___15 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1047
            c1 = (int )tmp___15;
            }
          } else {
#line 1047
            c1 = -1;
          }
#line 1047
          dfa->lex.ptr += nbytes___1;
#line 1047
          dfa->lex.left -= nbytes___1;
        }
#line 1047
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1049
      if (c1 == 58) {
#line 1049
        if (dfa->syntax.syntax_bits & ((1UL << 1) << 1)) {
#line 1049
          goto _L___0;
        } else {
#line 1049
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1049
      if (c1 == 46) {
#line 1049
        goto _L___0;
      } else
#line 1049
      if (c1 == 61) {
        _L___0: /* CIL Label */ 
#line 1054
        len = (size_t )0;
        {
#line 1055
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1057
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1057
            if (! dfa->lex.left) {
              {
#line 1057
              tmp___18 = gettext("unbalanced [");
              }
#line 1057
              if ((unsigned long )tmp___18 != (unsigned long )((char *)0)) {
                {
#line 1057
                tmp___16 = gettext("unbalanced [");
#line 1057
                dfaerror((char const   *)tmp___16);
                }
              } else {
#line 1057
                tmp___17 = (token )-1;
#line 1057
                dfa->lex.lasttok = tmp___17;
#line 1057
                return (tmp___17);
              }
            } else {
              {
#line 1057
              tmp___19 = mbs_to_wchar(& _wc___2, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1057
              nbytes___2 = tmp___19;
#line 1057
              dfa->lex.cur_mb_len = (int )nbytes___2;
#line 1057
              wc = _wc___2;
              }
#line 1057
              if (nbytes___2 == 1UL) {
                {
#line 1057
                tmp___20 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1057
                c = (int )tmp___20;
                }
              } else {
#line 1057
                c = -1;
              }
#line 1057
              dfa->lex.ptr += nbytes___2;
#line 1057
              dfa->lex.left -= nbytes___2;
            }
#line 1057
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 1058
          if (dfa->lex.left == 0UL) {
#line 1060
            goto while_break___3;
          } else
#line 1058
          if (c == c1) {
#line 1058
            if ((int const   )*(dfa->lex.ptr + 0) == 93) {
#line 1060
              goto while_break___3;
            }
          }
#line 1061
          if (len < 32UL) {
#line 1062
            tmp___21 = len;
#line 1062
            len ++;
#line 1062
            str[tmp___21] = (char )c;
          } else {
#line 1065
            str[0] = (char )'\000';
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1067
        str[len] = (char )'\000';
        {
#line 1070
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1070
          if (! dfa->lex.left) {
            {
#line 1070
            tmp___24 = gettext("unbalanced [");
            }
#line 1070
            if ((unsigned long )tmp___24 != (unsigned long )((char *)0)) {
              {
#line 1070
              tmp___22 = gettext("unbalanced [");
#line 1070
              dfaerror((char const   *)tmp___22);
              }
            } else {
#line 1070
              tmp___23 = (token )-1;
#line 1070
              dfa->lex.lasttok = tmp___23;
#line 1070
              return (tmp___23);
            }
          } else {
            {
#line 1070
            tmp___25 = mbs_to_wchar(& _wc___3, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1070
            nbytes___3 = tmp___25;
#line 1070
            dfa->lex.cur_mb_len = (int )nbytes___3;
#line 1070
            wc = _wc___3;
            }
#line 1070
            if (nbytes___3 == 1UL) {
              {
#line 1070
              tmp___26 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1070
              c = (int )tmp___26;
              }
            } else {
#line 1070
              c = -1;
            }
#line 1070
            dfa->lex.ptr += nbytes___3;
#line 1070
            dfa->lex.left -= nbytes___3;
          }
#line 1070
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1071
        if (c1 == 58) {
#line 1077
          if (dfa->syntax.case_fold) {
            {
#line 1077
            tmp___30 = strcmp((char const   *)(str), "upper");
            }
#line 1077
            if (tmp___30 == 0) {
#line 1077
              tmp___29 = "alpha";
            } else {
              {
#line 1077
              tmp___31 = strcmp((char const   *)(str), "lower");
              }
#line 1077
              if (tmp___31 == 0) {
#line 1077
                tmp___29 = "alpha";
              } else {
#line 1077
                tmp___29 = (char const   *)(str);
              }
            }
          } else {
#line 1077
            tmp___29 = (char const   *)(str);
          }
          {
#line 1077
          class = tmp___29;
#line 1081
          tmp___32 = find_pred(class);
#line 1081
          pred = (struct dfa_ctype  const  *)tmp___32;
          }
#line 1082
          if (! pred) {
            {
#line 1083
            tmp___33 = gettext("invalid character class");
#line 1083
            dfaerror((char const   *)tmp___33);
            }
          }
#line 1085
          if (dfa->localeinfo.multibyte) {
#line 1085
            if (! pred->single_byte_only) {
#line 1086
              known_bracket_exp = (_Bool)0;
            } else {
#line 1085
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 1088
            c2 = 0;
            {
#line 1088
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1088
              if (! (c2 < 256)) {
#line 1088
                goto while_break___6;
              }
              {
#line 1089
              tmp___34 = (*(pred->func))(c2);
              }
#line 1089
              if (tmp___34) {
                {
#line 1090
                setbit((unsigned int )c2, (charclass_word *)(ccl));
                }
              }
#line 1088
              c2 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        } else {
#line 1093
          known_bracket_exp = (_Bool)0;
        }
#line 1095
        colon_warning_state |= 8;
        {
#line 1098
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1098
          if (! dfa->lex.left) {
            {
#line 1098
            tmp___37 = gettext("unbalanced [");
            }
#line 1098
            if ((unsigned long )tmp___37 != (unsigned long )((char *)0)) {
              {
#line 1098
              tmp___35 = gettext("unbalanced [");
#line 1098
              dfaerror((char const   *)tmp___35);
              }
            } else {
#line 1098
              tmp___36 = (token )-1;
#line 1098
              dfa->lex.lasttok = tmp___36;
#line 1098
              return (tmp___36);
            }
          } else {
            {
#line 1098
            tmp___38 = mbs_to_wchar(& _wc___4, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1098
            nbytes___4 = tmp___38;
#line 1098
            dfa->lex.cur_mb_len = (int )nbytes___4;
#line 1098
            wc1 = _wc___4;
            }
#line 1098
            if (nbytes___4 == 1UL) {
              {
#line 1098
              tmp___39 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1098
              c1 = (int )tmp___39;
              }
            } else {
#line 1098
              c1 = -1;
            }
#line 1098
            dfa->lex.ptr += nbytes___4;
#line 1098
            dfa->lex.left -= nbytes___4;
          }
#line 1098
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1099
        goto __Cont;
      }
    }
#line 1106
    if (c == 92) {
#line 1106
      if (dfa->syntax.syntax_bits & 1UL) {
        {
#line 1107
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 1107
          if (! dfa->lex.left) {
            {
#line 1107
            tmp___42 = gettext("unbalanced [");
            }
#line 1107
            if ((unsigned long )tmp___42 != (unsigned long )((char *)0)) {
              {
#line 1107
              tmp___40 = gettext("unbalanced [");
#line 1107
              dfaerror((char const   *)tmp___40);
              }
            } else {
#line 1107
              tmp___41 = (token )-1;
#line 1107
              dfa->lex.lasttok = tmp___41;
#line 1107
              return (tmp___41);
            }
          } else {
            {
#line 1107
            tmp___43 = mbs_to_wchar(& _wc___5, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1107
            nbytes___5 = tmp___43;
#line 1107
            dfa->lex.cur_mb_len = (int )nbytes___5;
#line 1107
            wc = _wc___5;
            }
#line 1107
            if (nbytes___5 == 1UL) {
              {
#line 1107
              tmp___44 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1107
              c = (int )tmp___44;
              }
            } else {
#line 1107
              c = -1;
            }
#line 1107
            dfa->lex.ptr += nbytes___5;
#line 1107
            dfa->lex.left -= nbytes___5;
          }
#line 1107
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
    }
#line 1109
    if (c1 == 256) {
      {
#line 1110
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1110
        if (! dfa->lex.left) {
          {
#line 1110
          tmp___47 = gettext("unbalanced [");
          }
#line 1110
          if ((unsigned long )tmp___47 != (unsigned long )((char *)0)) {
            {
#line 1110
            tmp___45 = gettext("unbalanced [");
#line 1110
            dfaerror((char const   *)tmp___45);
            }
          } else {
#line 1110
            tmp___46 = (token )-1;
#line 1110
            dfa->lex.lasttok = tmp___46;
#line 1110
            return (tmp___46);
          }
        } else {
          {
#line 1110
          tmp___48 = mbs_to_wchar(& _wc___6, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1110
          nbytes___6 = tmp___48;
#line 1110
          dfa->lex.cur_mb_len = (int )nbytes___6;
#line 1110
          wc1 = _wc___6;
          }
#line 1110
          if (nbytes___6 == 1UL) {
            {
#line 1110
            tmp___49 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1110
            c1 = (int )tmp___49;
            }
          } else {
#line 1110
            c1 = -1;
          }
#line 1110
          dfa->lex.ptr += nbytes___6;
#line 1110
          dfa->lex.left -= nbytes___6;
        }
#line 1110
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 1112
    if (c1 == 45) {
      {
#line 1115
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1115
        if (! dfa->lex.left) {
          {
#line 1115
          tmp___52 = gettext("unbalanced [");
          }
#line 1115
          if ((unsigned long )tmp___52 != (unsigned long )((char *)0)) {
            {
#line 1115
            tmp___50 = gettext("unbalanced [");
#line 1115
            dfaerror((char const   *)tmp___50);
            }
          } else {
#line 1115
            tmp___51 = (token )-1;
#line 1115
            dfa->lex.lasttok = tmp___51;
#line 1115
            return (tmp___51);
          }
        } else {
          {
#line 1115
          tmp___53 = mbs_to_wchar(& _wc___7, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1115
          nbytes___7 = tmp___53;
#line 1115
          dfa->lex.cur_mb_len = (int )nbytes___7;
#line 1115
          wc2 = _wc___7;
          }
#line 1115
          if (nbytes___7 == 1UL) {
            {
#line 1115
            tmp___54 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1115
            c2 = (int )tmp___54;
            }
          } else {
#line 1115
            c2 = -1;
          }
#line 1115
          dfa->lex.ptr += nbytes___7;
#line 1115
          dfa->lex.left -= nbytes___7;
        }
#line 1115
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1120
      if (c2 == 91) {
#line 1120
        if ((int const   )*(dfa->lex.ptr + 0) == 46) {
#line 1122
          known_bracket_exp = (_Bool)0;
#line 1123
          c2 = ']';
        }
      }
#line 1126
      if (c2 == 93) {
#line 1130
        dfa->lex.ptr -= dfa->lex.cur_mb_len;
#line 1131
        dfa->lex.left += (size_t )dfa->lex.cur_mb_len;
      } else {
#line 1135
        if (c2 == 92) {
#line 1135
          if (dfa->syntax.syntax_bits & 1UL) {
            {
#line 1137
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 1137
              if (! dfa->lex.left) {
                {
#line 1137
                tmp___57 = gettext("unbalanced [");
                }
#line 1137
                if ((unsigned long )tmp___57 != (unsigned long )((char *)0)) {
                  {
#line 1137
                  tmp___55 = gettext("unbalanced [");
#line 1137
                  dfaerror((char const   *)tmp___55);
                  }
                } else {
#line 1137
                  tmp___56 = (token )-1;
#line 1137
                  dfa->lex.lasttok = tmp___56;
#line 1137
                  return (tmp___56);
                }
              } else {
                {
#line 1137
                tmp___58 = mbs_to_wchar(& _wc___8, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1137
                nbytes___8 = tmp___58;
#line 1137
                dfa->lex.cur_mb_len = (int )nbytes___8;
#line 1137
                wc2 = _wc___8;
                }
#line 1137
                if (nbytes___8 == 1UL) {
                  {
#line 1137
                  tmp___59 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1137
                  c2 = (int )tmp___59;
                  }
                } else {
#line 1137
                  c2 = -1;
                }
#line 1137
                dfa->lex.ptr += nbytes___8;
#line 1137
                dfa->lex.left -= nbytes___8;
              }
#line 1137
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
        }
#line 1139
        colon_warning_state |= 8;
        {
#line 1140
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 1140
          if (! dfa->lex.left) {
            {
#line 1140
            tmp___62 = gettext("unbalanced [");
            }
#line 1140
            if ((unsigned long )tmp___62 != (unsigned long )((char *)0)) {
              {
#line 1140
              tmp___60 = gettext("unbalanced [");
#line 1140
              dfaerror((char const   *)tmp___60);
              }
            } else {
#line 1140
              tmp___61 = (token )-1;
#line 1140
              dfa->lex.lasttok = tmp___61;
#line 1140
              return (tmp___61);
            }
          } else {
            {
#line 1140
            tmp___63 = mbs_to_wchar(& _wc___9, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1140
            nbytes___9 = tmp___63;
#line 1140
            dfa->lex.cur_mb_len = (int )nbytes___9;
#line 1140
            wc1 = _wc___9;
            }
#line 1140
            if (nbytes___9 == 1UL) {
              {
#line 1140
              tmp___64 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1140
              c1 = (int )tmp___64;
              }
            } else {
#line 1140
              c1 = -1;
            }
#line 1140
            dfa->lex.ptr += nbytes___9;
#line 1140
            dfa->lex.left -= nbytes___9;
          }
#line 1140
          goto while_break___12;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 1143
        if (wc != wc2) {
#line 1143
          goto _L___2;
        } else
#line 1143
        if (wc == 4294967295U) {
          _L___2: /* CIL Label */ 
#line 1145
          if (dfa->localeinfo.multibyte) {
#line 1146
            known_bracket_exp = (_Bool)0;
          } else
#line 1147
          if (dfa->simple_locale) {
#line 1150
            ci = c;
            {
#line 1150
            while (1) {
              while_continue___13: /* CIL Label */ ;
#line 1150
              if (! (ci <= c2)) {
#line 1150
                goto while_break___13;
              }
              {
#line 1151
              setbit((unsigned int )ci, (charclass_word *)(ccl));
#line 1150
              ci ++;
              }
            }
            while_break___13: /* CIL Label */ ;
            }
#line 1152
            if (dfa->syntax.case_fold) {
              {
#line 1154
              tmp___65 = toupper(c);
#line 1154
              uc = tmp___65;
#line 1155
              tmp___66 = toupper(c2);
#line 1155
              uc2 = tmp___66;
#line 1156
              ci = 0;
              }
              {
#line 1156
              while (1) {
                while_continue___14: /* CIL Label */ ;
#line 1156
                if (! (ci < 256)) {
#line 1156
                  goto while_break___14;
                }
                {
#line 1158
                tmp___67 = toupper(ci);
#line 1158
                uci = tmp___67;
                }
#line 1159
                if (uc <= uci) {
#line 1159
                  if (uci <= uc2) {
                    {
#line 1160
                    setbit((unsigned int )ci, (charclass_word *)(ccl));
                    }
                  }
                }
#line 1156
                ci ++;
              }
              while_break___14: /* CIL Label */ ;
              }
            }
          } else {
#line 1165
            known_bracket_exp = (_Bool)0;
          }
#line 1167
          goto __Cont;
        }
      }
    }
#line 1172
    if (c == 58) {
#line 1172
      tmp___68 = 2;
    } else {
#line 1172
      tmp___68 = 4;
    }
#line 1172
    colon_warning_state |= tmp___68;
#line 1174
    if (! dfa->localeinfo.multibyte) {
#line 1176
      if (dfa->syntax.case_fold) {
        {
#line 1177
        setbit_case_fold_c(c, (charclass_word *)(ccl));
        }
      } else {
        {
#line 1179
        setbit((unsigned int )c, (charclass_word *)(ccl));
        }
      }
#line 1180
      goto __Cont;
    }
#line 1183
    if (wc == 4294967295U) {
#line 1184
      known_bracket_exp = (_Bool)0;
    } else {
#line 1189
      if (dfa->syntax.case_fold) {
        {
#line 1189
        tmp___69 = case_folded_counterparts((wchar_t )wc, (wchar_t *)(folded + 1));
#line 1189
        tmp___70 = tmp___69 + 1;
        }
      } else {
#line 1189
        tmp___70 = 1;
      }
#line 1189
      n = (unsigned int )tmp___70;
#line 1192
      folded[0] = (wchar_t )wc;
#line 1193
      i = 0U;
      {
#line 1193
      while (1) {
        while_continue___15: /* CIL Label */ ;
#line 1193
        if (! (i < n)) {
#line 1193
          goto while_break___15;
        }
        {
#line 1194
        tmp___73 = setbit_wc((wint_t )folded[i], (charclass_word *)(ccl));
        }
#line 1194
        if (! tmp___73) {
          {
#line 1196
          tmp___71 = maybe_realloc((void *)work_mbc->chars, work_mbc->nchars, & chars_al,
                                   (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(work_mbc->chars)));
#line 1196
          work_mbc->chars = (wchar_t *)tmp___71;
#line 1199
          tmp___72 = work_mbc->nchars;
#line 1199
          (work_mbc->nchars) ++;
#line 1199
          *(work_mbc->chars + tmp___72) = folded[i];
          }
        }
#line 1193
        i ++;
      }
      while_break___15: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 1036
    wc = wc1;
#line 1036
    c = c1;
#line 1036
    if (! (c != 93)) {
#line 1036
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1205
  if (colon_warning_state == 7) {
    {
#line 1206
    tmp___74 = gettext("character class syntax is [[:space:]], not [:space:]");
#line 1206
    dfawarn((char const   *)tmp___74);
    }
  }
#line 1208
  if (! known_bracket_exp) {
#line 1209
    return ((token )257);
  }
#line 1211
  if (dfa->localeinfo.multibyte) {
    {
#line 1213
    work_mbc->invert = invert;
#line 1214
    tmp___77 = emptyset((charclass_word */* const  */)(ccl));
    }
#line 1214
    if (tmp___77) {
#line 1214
      work_mbc->cset = (ptrdiff_t )-1;
    } else {
      {
#line 1214
      tmp___76 = charclass_index(dfa, (charclass_word */* const  */)(ccl));
#line 1214
      work_mbc->cset = tmp___76;
      }
    }
#line 1215
    return ((token )273);
  }
#line 1218
  if (invert) {
#line 1220
    if (! (! dfa->localeinfo.multibyte)) {
      {
#line 1220
      __assert_fail("!dfa->localeinfo.multibyte", "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c",
                    1220U, "parse_bracket_exp");
      }
    }
    {
#line 1221
    notset((charclass_word *)(ccl));
    }
#line 1222
    if (dfa->syntax.syntax_bits & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      {
#line 1223
      clrbit((unsigned int )'\n', (charclass_word *)(ccl));
      }
    }
  }
  {
#line 1226
  tmp___79 = charclass_index(dfa, (charclass_word */* const  */)(ccl));
  }
#line 1226
  return (275L + tmp___79);
}
}
#line 1235 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void push_lex_state(struct dfa *dfa , struct lexptr *ls , char const   *s ) 
{ 


  {
  {
#line 1238
  ls->ptr = dfa->lex.ptr;
#line 1239
  ls->left = dfa->lex.left;
#line 1240
  dfa->lex.ptr = s;
#line 1241
  dfa->lex.left = strlen(s);
  }
#line 1242
  return;
}
}
#line 1244 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void pop_lex_state(struct dfa *dfa , struct lexptr  const  *ls ) 
{ 


  {
#line 1247
  dfa->lex.ptr = (char const   *)ls->ptr;
#line 1248
  dfa->lex.left = (size_t )ls->left;
#line 1249
  return;
}
}
#line 1251 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static token lex(struct dfa *dfa ) 
{ 
  int c ;
  int c2 ;
  _Bool backslash ;
  charclass ccl ;
  int i ;
  token tmp ;
  wint_t _wc ;
  size_t nbytes ;
  size_t tmp___0 ;
  unsigned char tmp___1 ;
  char *tmp___2 ;
  token tmp___3 ;
  token tmp___4 ;
  token tmp___5 ;
  token tmp___6 ;
  token tmp___7 ;
  token tmp___8 ;
  token tmp___9 ;
  token tmp___10 ;
  token tmp___11 ;
  token tmp___12 ;
  token tmp___13 ;
  token tmp___14 ;
  char const   *p ;
  char const   *lim ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  char const   *tmp___20 ;
  char *tmp___21 ;
  token tmp___22 ;
  token tmp___23 ;
  token tmp___24 ;
  token tmp___25 ;
  token tmp___26 ;
  ptrdiff_t tmp___27 ;
  token tmp___28 ;
  unsigned short const   **tmp___29 ;
  token tmp___30 ;
  ptrdiff_t tmp___31 ;
  struct lexptr ls ;
  token tmp___32 ;
  ptrdiff_t tmp___33 ;
  struct lexptr ls___0 ;
  token tmp___34 ;
  token tmp___35 ;
  token tmp___36 ;
  ptrdiff_t tmp___37 ;
  unsigned short const   **tmp___38 ;
  token tmp___39 ;

  {
#line 1255
  backslash = (_Bool)0;
#line 1265
  i = 0;
  {
#line 1265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1265
    if (! (i < 2)) {
#line 1265
      goto while_break;
    }
    {
#line 1267
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1267
      if (! dfa->lex.left) {
#line 1267
        tmp = (token )-1;
#line 1267
        dfa->lex.lasttok = tmp;
#line 1267
        return (tmp);
      } else {
        {
#line 1267
        tmp___0 = mbs_to_wchar(& _wc, dfa->lex.ptr, dfa->lex.left, dfa);
#line 1267
        nbytes = tmp___0;
#line 1267
        dfa->lex.cur_mb_len = (int )nbytes;
#line 1267
        dfa->lex.wctok = _wc;
        }
#line 1267
        if (nbytes == 1UL) {
          {
#line 1267
          tmp___1 = to_uchar((char )*(dfa->lex.ptr + 0));
#line 1267
          c = (int )tmp___1;
          }
        } else {
#line 1267
          c = -1;
        }
#line 1267
        dfa->lex.ptr += nbytes;
#line 1267
        dfa->lex.left -= nbytes;
      }
#line 1267
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1271
    if (c == 92) {
#line 1271
      goto case_92;
    }
#line 1279
    if (c == 94) {
#line 1279
      goto case_94;
    }
#line 1288
    if (c == 36) {
#line 1288
      goto case_36;
    }
#line 1316
    if (c == 57) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 56) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 55) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 54) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 53) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 52) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 51) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 50) {
#line 1316
      goto case_57;
    }
#line 1316
    if (c == 49) {
#line 1316
      goto case_57;
    }
#line 1324
    if (c == 96) {
#line 1324
      goto case_96;
    }
#line 1332
    if (c == 39) {
#line 1332
      goto case_39;
    }
#line 1340
    if (c == 60) {
#line 1340
      goto case_60;
    }
#line 1345
    if (c == 62) {
#line 1345
      goto case_62;
    }
#line 1350
    if (c == 98) {
#line 1350
      goto case_98;
    }
#line 1355
    if (c == 66) {
#line 1355
      goto case_66;
    }
#line 1360
    if (c == 63) {
#line 1360
      goto case_63;
    }
#line 1370
    if (c == 42) {
#line 1370
      goto case_42;
    }
#line 1378
    if (c == 43) {
#line 1378
      goto case_43;
    }
#line 1388
    if (c == 123) {
#line 1388
      goto case_123;
    }
#line 1446
    if (c == 124) {
#line 1446
      goto case_124;
    }
#line 1454
    if (c == 10) {
#line 1454
      goto case_10;
    }
#line 1461
    if (c == 40) {
#line 1461
      goto case_40;
    }
#line 1468
    if (c == 41) {
#line 1468
      goto case_41;
    }
#line 1478
    if (c == 46) {
#line 1478
      goto case_46;
    }
#line 1500
    if (c == 83) {
#line 1500
      goto case_83;
    }
#line 1500
    if (c == 115) {
#line 1500
      goto case_83;
    }
#line 1532
    if (c == 87) {
#line 1532
      goto case_87;
    }
#line 1532
    if (c == 119) {
#line 1532
      goto case_87;
    }
#line 1564
    if (c == 91) {
#line 1564
      goto case_91;
    }
#line 1570
    goto normal_char;
    case_92: /* CIL Label */ 
#line 1272
    if (backslash) {
#line 1273
      goto normal_char;
    }
#line 1274
    if (dfa->lex.left == 0UL) {
      {
#line 1275
      tmp___2 = gettext("unfinished \\ escape");
#line 1275
      dfaerror((char const   *)tmp___2);
      }
    }
#line 1276
    backslash = (_Bool)1;
#line 1277
    goto switch_break;
    case_94: /* CIL Label */ 
#line 1280
    if (backslash) {
#line 1281
      goto normal_char;
    }
#line 1282
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1285
      tmp___3 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___3;
#line 1285
      return (tmp___3);
    } else
#line 1282
    if (dfa->lex.lasttok == -1L) {
#line 1285
      tmp___3 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___3;
#line 1285
      return (tmp___3);
    } else
#line 1282
    if (dfa->lex.lasttok == 270L) {
#line 1285
      tmp___3 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___3;
#line 1285
      return (tmp___3);
    } else
#line 1282
    if (dfa->lex.lasttok == 269L) {
#line 1285
      tmp___3 = (token )258;
#line 1285
      dfa->lex.lasttok = tmp___3;
#line 1285
      return (tmp___3);
    }
#line 1286
    goto normal_char;
    case_36: /* CIL Label */ 
#line 1289
    if (backslash) {
#line 1290
      goto normal_char;
    }
#line 1291
    if (dfa->syntax.syntax_bits & (((1UL << 1) << 1) << 1)) {
#line 1305
      tmp___4 = (token )259;
#line 1305
      dfa->lex.lasttok = tmp___4;
#line 1305
      return (tmp___4);
    } else
#line 1291
    if (dfa->lex.left == 0UL) {
#line 1305
      tmp___4 = (token )259;
#line 1305
      dfa->lex.lasttok = tmp___4;
#line 1305
      return (tmp___4);
    } else
#line 1291
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1291
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 41) {
#line 1305
        tmp___4 = (token )259;
#line 1305
        dfa->lex.lasttok = tmp___4;
#line 1305
        return (tmp___4);
      } else {
#line 1291
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1291
    if (dfa->lex.left > (size_t )(! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1291
      if ((int const   )*(dfa->lex.ptr + (! (dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) & ((int const   )*(dfa->lex.ptr + 0) == 92))) == 124) {
#line 1305
        tmp___4 = (token )259;
#line 1305
        dfa->lex.lasttok = tmp___4;
#line 1305
        return (tmp___4);
      } else {
#line 1291
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1291
    if (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1291
      if (dfa->lex.left > 0UL) {
#line 1291
        if ((int const   )*(dfa->lex.ptr + 0) == 10) {
#line 1305
          tmp___4 = (token )259;
#line 1305
          dfa->lex.lasttok = tmp___4;
#line 1305
          return (tmp___4);
        }
      }
    }
#line 1306
    goto normal_char;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 1317
    if (backslash) {
#line 1317
      if (! (dfa->syntax.syntax_bits & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1319
        dfa->lex.laststart = (_Bool)0;
#line 1320
        tmp___5 = (token )257;
#line 1320
        dfa->lex.lasttok = tmp___5;
#line 1320
        return (tmp___5);
      }
    }
#line 1322
    goto normal_char;
    case_96: /* CIL Label */ 
#line 1325
    if (backslash) {
#line 1325
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1328
        tmp___6 = (token )258;
#line 1328
        dfa->lex.lasttok = tmp___6;
#line 1328
        return (tmp___6);
      }
    }
#line 1330
    goto normal_char;
    case_39: /* CIL Label */ 
#line 1333
    if (backslash) {
#line 1333
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1336
        tmp___7 = (token )259;
#line 1336
        dfa->lex.lasttok = tmp___7;
#line 1336
        return (tmp___7);
      }
    }
#line 1338
    goto normal_char;
    case_60: /* CIL Label */ 
#line 1341
    if (backslash) {
#line 1341
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1342
        tmp___8 = (token )260;
#line 1342
        dfa->lex.lasttok = tmp___8;
#line 1342
        return (tmp___8);
      }
    }
#line 1343
    goto normal_char;
    case_62: /* CIL Label */ 
#line 1346
    if (backslash) {
#line 1346
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1347
        tmp___9 = (token )261;
#line 1347
        dfa->lex.lasttok = tmp___9;
#line 1347
        return (tmp___9);
      }
    }
#line 1348
    goto normal_char;
    case_98: /* CIL Label */ 
#line 1351
    if (backslash) {
#line 1351
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1352
        tmp___10 = (token )262;
#line 1352
        dfa->lex.lasttok = tmp___10;
#line 1352
        return (tmp___10);
      }
    }
#line 1353
    goto normal_char;
    case_66: /* CIL Label */ 
#line 1356
    if (backslash) {
#line 1356
      if (! (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1357
        tmp___11 = (token )263;
#line 1357
        dfa->lex.lasttok = tmp___11;
#line 1357
        return (tmp___11);
      }
    }
#line 1358
    goto normal_char;
    case_63: /* CIL Label */ 
#line 1361
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1362
      goto normal_char;
    }
#line 1363
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1364
      goto normal_char;
    }
#line 1365
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1365
      if (dfa->lex.laststart) {
#line 1367
        goto normal_char;
      }
    }
#line 1368
    tmp___12 = (token )264;
#line 1368
    dfa->lex.lasttok = tmp___12;
#line 1368
    return (tmp___12);
    case_42: /* CIL Label */ 
#line 1371
    if (backslash) {
#line 1372
      goto normal_char;
    }
#line 1373
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1373
      if (dfa->lex.laststart) {
#line 1375
        goto normal_char;
      }
    }
#line 1376
    tmp___13 = (token )265;
#line 1376
    dfa->lex.lasttok = tmp___13;
#line 1376
    return (tmp___13);
    case_43: /* CIL Label */ 
#line 1379
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1380
      goto normal_char;
    }
#line 1381
    if ((int )backslash != ((dfa->syntax.syntax_bits & (1UL << 1)) != 0UL)) {
#line 1382
      goto normal_char;
    }
#line 1383
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1383
      if (dfa->lex.laststart) {
#line 1385
        goto normal_char;
      }
    }
#line 1386
    tmp___14 = (token )266;
#line 1386
    dfa->lex.lasttok = tmp___14;
#line 1386
    return (tmp___14);
    case_123: /* CIL Label */ 
#line 1389
    if (! (dfa->syntax.syntax_bits & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1390
      goto normal_char;
    }
#line 1391
    if ((int )backslash != ((dfa->syntax.syntax_bits & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1392
      goto normal_char;
    }
#line 1393
    if (! (dfa->syntax.syntax_bits & ((((1UL << 1) << 1) << 1) << 1))) {
#line 1393
      if (dfa->lex.laststart) {
#line 1395
        goto normal_char;
      }
    }
#line 1404
    p = dfa->lex.ptr;
#line 1405
    lim = p + dfa->lex.left;
#line 1406
    tmp___15 = -1;
#line 1406
    dfa->lex.maxrep = tmp___15;
#line 1406
    dfa->lex.minrep = tmp___15;
    {
#line 1407
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1407
      if ((unsigned long )p != (unsigned long )lim) {
#line 1407
        if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1407
          goto while_break___1;
        }
      } else {
#line 1407
        goto while_break___1;
      }
#line 1408
      if (dfa->lex.minrep < 0) {
#line 1408
        dfa->lex.minrep = (int )((int const   )*p - 48);
      } else {
#line 1408
        if (32768 < (dfa->lex.minrep * 10 + (int )*p) - 48) {
#line 1408
          tmp___16 = 32768;
        } else {
#line 1408
          tmp___16 = (dfa->lex.minrep * 10 + (int )*p) - 48;
        }
#line 1408
        dfa->lex.minrep = tmp___16;
      }
#line 1407
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1412
    if ((unsigned long )p != (unsigned long )lim) {
#line 1414
      if ((int const   )*p != 44) {
#line 1415
        dfa->lex.maxrep = dfa->lex.minrep;
      } else {
#line 1418
        if (dfa->lex.minrep < 0) {
#line 1419
          dfa->lex.minrep = 0;
        }
        {
#line 1420
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1420
          p ++;
#line 1420
          if ((unsigned long )p != (unsigned long )lim) {
#line 1420
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1420
              goto while_break___2;
            }
          } else {
#line 1420
            goto while_break___2;
          }
#line 1421
          if (dfa->lex.maxrep < 0) {
#line 1421
            dfa->lex.maxrep = (int )((int const   )*p - 48);
          } else {
#line 1421
            if (32768 < (dfa->lex.maxrep * 10 + (int )*p) - 48) {
#line 1421
              tmp___17 = 32768;
            } else {
#line 1421
              tmp___17 = (dfa->lex.maxrep * 10 + (int )*p) - 48;
            }
#line 1421
            dfa->lex.maxrep = tmp___17;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 1428
    if (! backslash) {
#line 1428
      goto _L___5;
    } else
#line 1428
    if ((unsigned long )p != (unsigned long )lim) {
#line 1428
      tmp___19 = p;
#line 1428
      p ++;
#line 1428
      if ((int const   )*tmp___19 == 92) {
        _L___5: /* CIL Label */ 
#line 1428
        if ((unsigned long )p != (unsigned long )lim) {
#line 1428
          tmp___20 = p;
#line 1428
          p ++;
#line 1428
          if ((int const   )*tmp___20 == 125) {
#line 1428
            if (0 <= dfa->lex.minrep) {
#line 1428
              if (! (dfa->lex.maxrep < 0)) {
#line 1428
                if (! (dfa->lex.minrep <= dfa->lex.maxrep)) {
#line 1428
                  goto _L___6;
                }
              }
            } else {
#line 1428
              goto _L___6;
            }
          } else {
#line 1428
            goto _L___6;
          }
        } else {
#line 1428
          goto _L___6;
        }
      } else {
#line 1428
        goto _L___6;
      }
    } else {
      _L___6: /* CIL Label */ 
#line 1434
      if (dfa->syntax.syntax_bits & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1435
        goto normal_char;
      }
      {
#line 1436
      tmp___18 = gettext("invalid content of \\{\\}");
#line 1436
      dfaerror((char const   *)tmp___18);
      }
    }
#line 1438
    if (32767 < dfa->lex.maxrep) {
      {
#line 1439
      tmp___21 = gettext("regular expression too big");
#line 1439
      dfaerror((char const   *)tmp___21);
      }
    }
#line 1440
    dfa->lex.ptr = p;
#line 1441
    dfa->lex.left = (size_t )(lim - p);
#line 1443
    dfa->lex.laststart = (_Bool)0;
#line 1444
    tmp___22 = (token )267;
#line 1444
    dfa->lex.lasttok = tmp___22;
#line 1444
    return (tmp___22);
    case_124: /* CIL Label */ 
#line 1447
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1448
      goto normal_char;
    }
#line 1449
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1450
      goto normal_char;
    }
#line 1451
    dfa->lex.laststart = (_Bool)1;
#line 1452
    tmp___23 = (token )269;
#line 1452
    dfa->lex.lasttok = tmp___23;
#line 1452
    return (tmp___23);
    case_10: /* CIL Label */ 
#line 1455
    if (dfa->syntax.syntax_bits & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1457
      goto normal_char;
    } else
#line 1455
    if (backslash) {
#line 1457
      goto normal_char;
    } else
#line 1455
    if (! (dfa->syntax.syntax_bits & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1457
      goto normal_char;
    }
#line 1458
    dfa->lex.laststart = (_Bool)1;
#line 1459
    tmp___24 = (token )269;
#line 1459
    dfa->lex.lasttok = tmp___24;
#line 1459
    return (tmp___24);
    case_40: /* CIL Label */ 
#line 1462
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1463
      goto normal_char;
    }
#line 1464
    (dfa->lex.parens) ++;
#line 1465
    dfa->lex.laststart = (_Bool)1;
#line 1466
    tmp___25 = (token )270;
#line 1466
    dfa->lex.lasttok = tmp___25;
#line 1466
    return (tmp___25);
    case_41: /* CIL Label */ 
#line 1469
    if ((int )backslash != ((dfa->syntax.syntax_bits & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0UL)) {
#line 1470
      goto normal_char;
    }
#line 1471
    if (dfa->lex.parens == 0UL) {
#line 1471
      if (dfa->syntax.syntax_bits & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1473
        goto normal_char;
      }
    }
#line 1474
    (dfa->lex.parens) --;
#line 1475
    dfa->lex.laststart = (_Bool)0;
#line 1476
    tmp___26 = (token )271;
#line 1476
    dfa->lex.lasttok = tmp___26;
#line 1476
    return (tmp___26);
    case_46: /* CIL Label */ 
#line 1479
    if (backslash) {
#line 1480
      goto normal_char;
    }
#line 1481
    if (dfa->canychar == 0xffffffffffffffffUL) {
      {
#line 1483
      fillset((charclass_word *)(ccl));
      }
#line 1484
      if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
        {
#line 1485
        clrbit((unsigned int )'\n', (charclass_word *)(ccl));
        }
      }
#line 1486
      if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        {
#line 1487
        clrbit((unsigned int )'\000', (charclass_word *)(ccl));
        }
      }
#line 1488
      if (dfa->localeinfo.multibyte) {
#line 1489
        c2 = 0;
        {
#line 1489
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1489
          if (! (c2 < 256)) {
#line 1489
            goto while_break___3;
          }
#line 1490
          if (dfa->localeinfo.sbctowc[c2] == 4294967295U) {
            {
#line 1491
            clrbit((unsigned int )c2, (charclass_word *)(ccl));
            }
          }
#line 1489
          c2 ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
      {
#line 1492
      tmp___27 = charclass_index(dfa, (charclass_word */* const  */)(ccl));
#line 1492
      dfa->canychar = (size_t )tmp___27;
      }
    }
#line 1494
    dfa->lex.laststart = (_Bool)0;
#line 1495
    if (dfa->localeinfo.multibyte) {
#line 1495
      tmp___28 = (token )272;
    } else {
#line 1495
      tmp___28 = (token )(275UL + dfa->canychar);
    }
#line 1495
    dfa->lex.lasttok = tmp___28;
#line 1495
    return (tmp___28);
    case_83: /* CIL Label */ 
    case_115: /* CIL Label */ 
#line 1501
    if (! backslash) {
#line 1502
      goto normal_char;
    } else
#line 1501
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1502
      goto normal_char;
    }
#line 1503
    if (! dfa->localeinfo.multibyte) {
      {
#line 1505
      zeroset((charclass_word *)(ccl));
#line 1506
      c2 = 0;
      }
      {
#line 1506
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1506
        if (! (c2 < 256)) {
#line 1506
          goto while_break___4;
        }
        {
#line 1507
        tmp___29 = __ctype_b_loc();
        }
#line 1507
        if ((int const   )*(*tmp___29 + c2) & 8192) {
          {
#line 1508
          setbit((unsigned int )c2, (charclass_word *)(ccl));
          }
        }
#line 1506
        c2 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1509
      if (c == 83) {
        {
#line 1510
        notset((charclass_word *)(ccl));
        }
      }
      {
#line 1511
      dfa->lex.laststart = (_Bool)0;
#line 1512
      tmp___31 = charclass_index(dfa, (charclass_word */* const  */)(ccl));
#line 1512
      tmp___30 = 275L + tmp___31;
#line 1512
      dfa->lex.lasttok = tmp___30;
      }
#line 1512
      return (tmp___30);
    }
    {
#line 1523
    push_lex_state(dfa, & ls, "^[:space:]]" + (c == 115));
#line 1524
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1525
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls));
#line 1528
    dfa->lex.laststart = (_Bool)0;
    }
#line 1529
    return (dfa->lex.lasttok);
    case_87: /* CIL Label */ 
    case_119: /* CIL Label */ 
#line 1533
    if (! backslash) {
#line 1534
      goto normal_char;
    } else
#line 1533
    if (dfa->syntax.syntax_bits & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1534
      goto normal_char;
    }
#line 1536
    if (! dfa->localeinfo.multibyte) {
      {
#line 1538
      zeroset((charclass_word *)(ccl));
#line 1539
      c2 = 0;
      }
      {
#line 1539
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1539
        if (! (c2 < 256)) {
#line 1539
          goto while_break___5;
        }
#line 1540
        if (dfa->syntax.sbit[c2] == 2) {
          {
#line 1541
          setbit((unsigned int )c2, (charclass_word *)(ccl));
          }
        }
#line 1539
        c2 ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1542
      if (c == 87) {
        {
#line 1543
        notset((charclass_word *)(ccl));
        }
      }
      {
#line 1544
      dfa->lex.laststart = (_Bool)0;
#line 1545
      tmp___33 = charclass_index(dfa, (charclass_word */* const  */)(ccl));
#line 1545
      tmp___32 = 275L + tmp___33;
#line 1545
      dfa->lex.lasttok = tmp___32;
      }
#line 1545
      return (tmp___32);
    }
    {
#line 1556
    push_lex_state(dfa, & ls___0, "^_[:alnum:]]" + (c == 119));
#line 1557
    dfa->lex.lasttok = parse_bracket_exp(dfa);
#line 1558
    pop_lex_state(dfa, (struct lexptr  const  *)(& ls___0));
#line 1561
    dfa->lex.laststart = (_Bool)0;
    }
#line 1562
    return (dfa->lex.lasttok);
    case_91: /* CIL Label */ 
#line 1565
    if (backslash) {
#line 1566
      goto normal_char;
    }
    {
#line 1567
    dfa->lex.laststart = (_Bool)0;
#line 1568
    tmp___34 = parse_bracket_exp(dfa);
#line 1568
    dfa->lex.lasttok = tmp___34;
    }
#line 1568
    return (tmp___34);
    normal_char: 
    switch_default: /* CIL Label */ 
#line 1572
    dfa->lex.laststart = (_Bool)0;
#line 1575
    if (dfa->localeinfo.multibyte) {
#line 1576
      tmp___35 = (token )274;
#line 1576
      dfa->lex.lasttok = tmp___35;
#line 1576
      return (tmp___35);
    }
#line 1578
    if (dfa->syntax.case_fold) {
      {
#line 1578
      tmp___38 = __ctype_b_loc();
      }
#line 1578
      if ((int const   )*(*tmp___38 + c) & 1024) {
        {
#line 1580
        zeroset((charclass_word *)(ccl));
#line 1581
        setbit_case_fold_c(c, (charclass_word *)(ccl));
#line 1582
        tmp___37 = charclass_index(dfa, (charclass_word */* const  */)(ccl));
#line 1582
        tmp___36 = 275L + tmp___37;
#line 1582
        dfa->lex.lasttok = tmp___36;
        }
#line 1582
        return (tmp___36);
      }
    }
#line 1585
    tmp___39 = (token )c;
#line 1585
    dfa->lex.lasttok = tmp___39;
#line 1585
    return (tmp___39);
    switch_break: /* CIL Label */ ;
    }
#line 1265
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1591
  abort();
  }
#line 1592
  return ((token )-1);
}
}
#line 1595 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void addtok_mb(struct dfa *dfa , token t , int mbprop ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1598
  if (dfa->talloc == dfa->tindex) {
    {
#line 1600
    tmp = x2nrealloc((void *)dfa->tokens, & dfa->talloc, sizeof(*(dfa->tokens)));
#line 1600
    dfa->tokens = (token *)tmp;
    }
#line 1602
    if (dfa->localeinfo.multibyte) {
      {
#line 1603
      tmp___0 = xnrealloc((void *)dfa->multibyte_prop, dfa->talloc, sizeof(*(dfa->multibyte_prop)));
#line 1603
      dfa->multibyte_prop = (int *)tmp___0;
      }
    }
  }
#line 1606
  if (dfa->localeinfo.multibyte) {
#line 1607
    *(dfa->multibyte_prop + dfa->tindex) = mbprop;
  }
#line 1608
  tmp___1 = dfa->tindex;
#line 1608
  (dfa->tindex) ++;
#line 1608
  *(dfa->tokens + tmp___1) = t;
  {
#line 1614
  if (t == 266L) {
#line 1614
    goto case_266;
  }
#line 1614
  if (t == 265L) {
#line 1614
    goto case_266;
  }
#line 1614
  if (t == 264L) {
#line 1614
    goto case_266;
  }
#line 1618
  if (t == 269L) {
#line 1618
    goto case_269;
  }
#line 1618
  if (t == 268L) {
#line 1618
    goto case_269;
  }
#line 1622
  if (t == 257L) {
#line 1622
    goto case_257;
  }
#line 1628
  if (t == 256L) {
#line 1628
    goto case_256;
  }
#line 1625
  goto switch_default;
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
#line 1615
  goto switch_break;
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
#line 1619
  (dfa->parse.depth) --;
#line 1620
  goto switch_break;
  case_257: /* CIL Label */ 
#line 1623
  dfa->fast = (_Bool)0;
  switch_default: /* CIL Label */ 
#line 1626
  (dfa->nleaves) ++;
  case_256: /* CIL Label */ 
#line 1629
  (dfa->parse.depth) ++;
#line 1630
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1632
  if (dfa->parse.depth > dfa->depth) {
#line 1633
    dfa->depth = dfa->parse.depth;
  }
#line 1634
  return;
}
}
#line 1636
static void addtok_wc(struct dfa *dfa , wint_t wc ) ;
#line 1640 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void addtok(struct dfa *dfa , token t ) 
{ 
  _Bool need_or ;
  struct mb_char_classes *work_mbc ;
  ptrdiff_t i ;

  {
#line 1643
  if (dfa->localeinfo.multibyte) {
#line 1643
    if (t == 273L) {
#line 1645
      need_or = (_Bool)0;
#line 1646
      work_mbc = dfa->mbcsets + (dfa->nmbcsets - 1L);
#line 1651
      i = (ptrdiff_t )0;
      {
#line 1651
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1651
        if (! (i < work_mbc->nchars)) {
#line 1651
          goto while_break;
        }
        {
#line 1653
        addtok_wc(dfa, (wint_t )*(work_mbc->chars + i));
        }
#line 1654
        if (need_or) {
          {
#line 1655
          addtok(dfa, (token )269);
          }
        }
#line 1656
        need_or = (_Bool)1;
#line 1651
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1658
      work_mbc->nchars = (ptrdiff_t )0;
#line 1662
      if (work_mbc->cset != -1L) {
        {
#line 1664
        addtok(dfa, 275L + work_mbc->cset);
        }
#line 1665
        if (need_or) {
          {
#line 1666
          addtok(dfa, (token )269);
          }
        }
      }
    } else {
      {
#line 1671
      addtok_mb(dfa, t, 3);
      }
    }
  } else {
    {
#line 1671
    addtok_mb(dfa, t, 3);
    }
  }
#line 1673
  return;
}
}
#line 1681 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void addtok_wc(struct dfa *dfa , wint_t wc ) 
{ 
  unsigned char buf[16] ;
  mbstate_t s ;
  int i ;
  size_t stored_bytes ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1685
  s.__count = 0;
#line 1685
  s.__value.__wch = 0U;
#line 1687
  tmp = wcrtomb((char */* __restrict  */)((char *)(buf)), (wchar_t )wc, (mbstate_t */* __restrict  */)(& s));
#line 1687
  stored_bytes = tmp;
  }
#line 1689
  if (stored_bytes != 0xffffffffffffffffUL) {
#line 1690
    dfa->lex.cur_mb_len = (int )stored_bytes;
  } else {
#line 1695
    dfa->lex.cur_mb_len = 1;
#line 1696
    buf[0] = (unsigned char)0;
  }
#line 1699
  if (dfa->lex.cur_mb_len == 1) {
#line 1699
    tmp___0 = 3;
  } else {
#line 1699
    tmp___0 = 1;
  }
  {
#line 1699
  addtok_mb(dfa, (token )buf[0], tmp___0);
#line 1700
  i = 1;
  }
  {
#line 1700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1700
    if (! (i < dfa->lex.cur_mb_len)) {
#line 1700
      goto while_break;
    }
#line 1702
    if (i == dfa->lex.cur_mb_len - 1) {
#line 1702
      tmp___1 = 2;
    } else {
#line 1702
      tmp___1 = 0;
    }
    {
#line 1702
    addtok_mb(dfa, (token )buf[i], tmp___1);
#line 1703
    addtok(dfa, (token )268);
#line 1700
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1705
  return;
}
}
#line 1710
static void add_utf8_anychar(struct dfa *dfa ) ;
#line 1710 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static charclass const   utf8_classes[5]  = { {        0UL,        0UL,        (4294967295UL << 32) + 4294967295UL,        0UL}, 
   {        (4294967295UL << 32) + 4294967295UL,        (4294967295UL << 32) + 4294967295UL,        0UL,        0UL}, 
   {        0UL,        0UL,        0UL,        4294967292UL}, 
   {        0UL,        0UL,        0UL,        65535UL << 32}, 
   {        0UL,        0UL,        0UL,        16711680UL << 32}};
#line 1707 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void add_utf8_anychar(struct dfa *dfa ) 
{ 
  unsigned int n ;
  unsigned int i ;
  charclass c ;
  ptrdiff_t tmp ;

  {
#line 1726
  n = (unsigned int )(sizeof(utf8_classes) / sizeof(utf8_classes[0]));
#line 1730
  if (dfa->utf8_anychar_classes[0] == 0L) {
#line 1731
    i = 0U;
    {
#line 1731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1731
      if (! (i < n)) {
#line 1731
        goto while_break;
      }
      {
#line 1734
      copyset((charclass_word */* const  */)(utf8_classes[i]), (charclass_word *)(c));
      }
#line 1735
      if (i == 1U) {
#line 1737
        if (! (dfa->syntax.syntax_bits & ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
          {
#line 1738
          clrbit((unsigned int )'\n', (charclass_word *)(c));
          }
        }
#line 1739
        if (dfa->syntax.syntax_bits & (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          {
#line 1740
          clrbit((unsigned int )'\000', (charclass_word *)(c));
          }
        }
      }
      {
#line 1742
      tmp = charclass_index(dfa, (charclass_word */* const  */)(c));
#line 1742
      dfa->utf8_anychar_classes[i] = 275L + tmp;
#line 1731
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1755
  i = 1U;
  {
#line 1755
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1755
    if (! (i < n)) {
#line 1755
      goto while_break___0;
    }
    {
#line 1756
    addtok(dfa, dfa->utf8_anychar_classes[i]);
#line 1755
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1757
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1757
    i --;
#line 1757
    if (! (i > 1U)) {
#line 1757
      goto while_break___1;
    }
    {
#line 1759
    addtok(dfa, dfa->utf8_anychar_classes[0]);
#line 1760
    addtok(dfa, (token )268);
#line 1761
    addtok(dfa, (token )269);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1763
  return;
}
}
#line 1800 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void atom(struct dfa *dfa ) 
{ 
  wchar_t folded[32] ;
  unsigned int i ;
  unsigned int n ;
  int tmp ;
  char *tmp___0 ;

  {
#line 1803
  if (dfa->parse.tok == 274L) {
#line 1805
    if (dfa->lex.wctok == 4294967295U) {
      {
#line 1806
      addtok(dfa, (token )257);
      }
    } else {
      {
#line 1809
      addtok_wc(dfa, dfa->lex.wctok);
      }
#line 1811
      if (dfa->syntax.case_fold) {
        {
#line 1814
        tmp = case_folded_counterparts((wchar_t )dfa->lex.wctok, (wchar_t *)(folded));
#line 1814
        n = (unsigned int )tmp;
#line 1816
        i = 0U;
        }
        {
#line 1816
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1816
          if (! (i < n)) {
#line 1816
            goto while_break;
          }
          {
#line 1818
          addtok_wc(dfa, (wint_t )folded[i]);
#line 1819
          addtok(dfa, (token )269);
#line 1816
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 1824
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1826
  if (dfa->parse.tok == 272L) {
#line 1826
    if (dfa->localeinfo.using_utf8) {
      {
#line 1835
      add_utf8_anychar(dfa);
#line 1836
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1826
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1838
  if (0L <= dfa->parse.tok) {
#line 1838
    if (dfa->parse.tok < 256L) {
      {
#line 1845
      addtok(dfa, dfa->parse.tok);
#line 1846
      dfa->parse.tok = lex(dfa);
      }
    } else {
#line 1838
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1838
  if (dfa->parse.tok >= 275L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 257L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 258L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 259L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 260L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 272L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 273L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 261L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 262L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1838
  if (dfa->parse.tok == 263L) {
    {
#line 1845
    addtok(dfa, dfa->parse.tok);
#line 1846
    dfa->parse.tok = lex(dfa);
    }
  } else
#line 1848
  if (dfa->parse.tok == 270L) {
    {
#line 1850
    dfa->parse.tok = lex(dfa);
#line 1851
    regexp(dfa);
    }
#line 1852
    if (dfa->parse.tok != 271L) {
      {
#line 1853
      tmp___0 = gettext("unbalanced (");
#line 1853
      dfaerror((char const   *)tmp___0);
      }
    }
    {
#line 1854
    dfa->parse.tok = lex(dfa);
    }
  } else {
    {
#line 1857
    addtok(dfa, (token )256);
    }
  }
#line 1858
  return;
}
}
#line 1861 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static size_t __attribute__((__pure__))  nsubtoks(struct dfa  const  *dfa , size_t tindex ) 
{ 
  size_t ntoks1 ;
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 1872
  if (*(dfa->tokens + (tindex - 1UL)) == 266L) {
#line 1872
    goto case_266;
  }
#line 1872
  if (*(dfa->tokens + (tindex - 1UL)) == 265L) {
#line 1872
    goto case_266;
  }
#line 1872
  if (*(dfa->tokens + (tindex - 1UL)) == 264L) {
#line 1872
    goto case_266;
  }
#line 1875
  if (*(dfa->tokens + (tindex - 1UL)) == 269L) {
#line 1875
    goto case_269;
  }
#line 1875
  if (*(dfa->tokens + (tindex - 1UL)) == 268L) {
#line 1875
    goto case_269;
  }
#line 1868
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1869
  return ((size_t __attribute__((__pure__))  )1);
  case_266: /* CIL Label */ 
  case_265: /* CIL Label */ 
  case_264: /* CIL Label */ 
  {
#line 1873
  tmp = nsubtoks(dfa, tindex - 1UL);
  }
#line 1873
  return ((size_t __attribute__((__pure__))  )1 + tmp);
  case_269: /* CIL Label */ 
  case_268: /* CIL Label */ 
  {
#line 1876
  tmp___0 = nsubtoks(dfa, tindex - 1UL);
#line 1876
  ntoks1 = (size_t )tmp___0;
#line 1877
  tmp___1 = nsubtoks(dfa, (tindex - 1UL) - ntoks1);
  }
#line 1877
  return ((size_t __attribute__((__pure__))  )((1UL + ntoks1) + (size_t )tmp___1));
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1882 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void copytoks(struct dfa *dfa , size_t tindex , size_t ntokens ) 
{ 
  size_t i ;

  {
#line 1887
  if (dfa->localeinfo.multibyte) {
#line 1888
    i = (size_t )0;
    {
#line 1888
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1888
      if (! (i < ntokens)) {
#line 1888
        goto while_break;
      }
      {
#line 1889
      addtok_mb(dfa, *(dfa->tokens + (tindex + i)), *(dfa->multibyte_prop + (tindex + i)));
#line 1888
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1891
    i = (size_t )0;
    {
#line 1891
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1891
      if (! (i < ntokens)) {
#line 1891
        goto while_break___0;
      }
      {
#line 1892
      addtok_mb(dfa, *(dfa->tokens + (tindex + i)), 3);
#line 1891
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1893
  return;
}
}
#line 1895 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void closure(struct dfa *dfa ) 
{ 
  int i ;
  size_t tindex ;
  size_t ntokens ;
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 1901
  atom(dfa);
  }
  {
#line 1902
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1902
    if (! (dfa->parse.tok == 264L)) {
#line 1902
      if (! (dfa->parse.tok == 265L)) {
#line 1902
        if (! (dfa->parse.tok == 266L)) {
#line 1902
          if (! (dfa->parse.tok == 267L)) {
#line 1902
            goto while_break;
          }
        }
      }
    }
#line 1904
    if (dfa->parse.tok == 267L) {
#line 1904
      if (dfa->lex.minrep) {
#line 1904
        goto _L___0;
      } else
#line 1904
      if (dfa->lex.maxrep) {
        _L___0: /* CIL Label */ 
        {
#line 1906
        tmp = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1906
        ntokens = (size_t )tmp;
#line 1907
        tindex = dfa->tindex - ntokens;
        }
#line 1908
        if (dfa->lex.maxrep < 0) {
          {
#line 1909
          addtok(dfa, (token )266);
          }
        }
#line 1910
        if (dfa->lex.minrep == 0) {
          {
#line 1911
          addtok(dfa, (token )264);
          }
        }
#line 1912
        i = 1;
        {
#line 1912
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1912
          if (! (i < dfa->lex.minrep)) {
#line 1912
            goto while_break___0;
          }
          {
#line 1914
          copytoks(dfa, tindex, ntokens);
#line 1915
          addtok(dfa, (token )268);
#line 1912
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1917
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1917
          if (! (i < dfa->lex.maxrep)) {
#line 1917
            goto while_break___1;
          }
          {
#line 1919
          copytoks(dfa, tindex, ntokens);
#line 1920
          addtok(dfa, (token )264);
#line 1921
          addtok(dfa, (token )268);
#line 1917
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1923
        dfa->parse.tok = lex(dfa);
        }
      } else {
#line 1904
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1925
    if (dfa->parse.tok == 267L) {
      {
#line 1927
      tmp___0 = nsubtoks((struct dfa  const  *)dfa, dfa->tindex);
#line 1927
      dfa->tindex -= (size_t )tmp___0;
#line 1928
      dfa->parse.tok = lex(dfa);
#line 1929
      closure(dfa);
      }
    } else {
      {
#line 1933
      addtok(dfa, dfa->parse.tok);
#line 1934
      dfa->parse.tok = lex(dfa);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1936
  return;
}
}
#line 1938 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void branch(struct dfa *dfa ) 
{ 


  {
  {
#line 1941
  closure(dfa);
  }
  {
#line 1942
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1942
    if (dfa->parse.tok != 271L) {
#line 1942
      if (dfa->parse.tok != 269L) {
#line 1942
        if (! (dfa->parse.tok >= 0L)) {
#line 1942
          goto while_break;
        }
      } else {
#line 1942
        goto while_break;
      }
    } else {
#line 1942
      goto while_break;
    }
    {
#line 1945
    closure(dfa);
#line 1946
    addtok(dfa, (token )268);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1948
  return;
}
}
#line 1950 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void regexp(struct dfa *dfa ) 
{ 


  {
  {
#line 1953
  branch(dfa);
  }
  {
#line 1954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1954
    if (! (dfa->parse.tok == 269L)) {
#line 1954
      goto while_break;
    }
    {
#line 1956
    dfa->parse.tok = lex(dfa);
#line 1957
    branch(dfa);
#line 1958
    addtok(dfa, (token )269);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1960
  return;
}
}
#line 1965 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void dfaparse(char const   *s , size_t len , struct dfa *d ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 1968
  d->lex.ptr = s;
#line 1969
  d->lex.left = len;
#line 1970
  d->lex.lasttok = (token )-1;
#line 1971
  d->lex.laststart = (_Bool)1;
#line 1972
  d->lex.parens = (size_t )0;
#line 1973
  if (d->localeinfo.multibyte) {
    {
#line 1975
    d->lex.cur_mb_len = 0;
#line 1976
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
  }
#line 1979
  if (! d->syntax.syntax_bits_set) {
    {
#line 1980
    tmp = gettext("no syntax specified");
#line 1980
    dfaerror((char const   *)tmp);
    }
  }
  {
#line 1982
  d->parse.tok = lex(d);
#line 1983
  d->parse.depth = d->depth;
#line 1985
  regexp(d);
  }
#line 1987
  if (d->parse.tok != -1L) {
    {
#line 1988
    tmp___0 = gettext("unbalanced )");
#line 1988
    dfaerror((char const   *)tmp___0);
    }
  }
  {
#line 1990
  addtok(d, (token )(0xffffffffffffffffUL - d->nregexps));
#line 1991
  addtok(d, (token )268);
  }
#line 1993
  if (d->nregexps) {
    {
#line 1994
    addtok(d, (token )269);
    }
  }
#line 1996
  (d->nregexps) ++;
#line 1997
  return;
}
}
#line 2002 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void copy(position_set const   *src , position_set *dst ) 
{ 
  void *tmp ;

  {
#line 2005
  if (dst->alloc < (ptrdiff_t )src->nelem) {
    {
#line 2007
    free((void *)dst->elems);
#line 2008
    tmp = xpalloc((void *)0, & dst->alloc, (ptrdiff_t )(src->nelem - (ptrdiff_t const   )dst->alloc),
                  (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(dst->elems)));
#line 2008
    dst->elems = (position *)tmp;
    }
  }
  {
#line 2011
  memcpy((void */* __restrict  */)dst->elems, (void const   */* __restrict  */)src->elems,
         (unsigned long )src->nelem * sizeof(*(dst->elems)));
#line 2012
  dst->nelem = (ptrdiff_t )src->nelem;
  }
#line 2013
  return;
}
}
#line 2015 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void alloc_position_set(position_set *s , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2018
  tmp = xnmalloc(size, sizeof(*(s->elems)));
#line 2018
  s->elems = (position *)tmp;
  }
#line 2019
  if (9223372036854775807UL < 0xffffffffffffffffUL / sizeof(*(s->elems))) {
#line 2019
    if (9223372036854775807UL < size) {
      {
#line 2020
      xalloc_die();
      }
    }
  }
#line 2021
  s->alloc = (ptrdiff_t )size;
#line 2022
  s->nelem = (ptrdiff_t )0;
#line 2023
  return;
}
}
#line 2029 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void insert(position p , position_set *s ) 
{ 
  ptrdiff_t count ;
  ptrdiff_t lo ;
  ptrdiff_t hi ;
  ptrdiff_t i ;
  ptrdiff_t mid ;
  void *tmp ;

  {
#line 2032
  count = s->nelem;
#line 2033
  lo = (ptrdiff_t )0;
#line 2033
  hi = count;
  {
#line 2035
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2035
    if (! (lo < hi)) {
#line 2035
      goto while_break;
    }
#line 2037
    mid = (lo + hi) >> 1;
#line 2038
    if ((s->elems + mid)->index > p.index) {
#line 2039
      lo = mid + 1L;
    } else
#line 2040
    if ((s->elems + mid)->index == p.index) {
#line 2042
      (s->elems + mid)->constraint |= p.constraint;
#line 2043
      return;
    } else {
#line 2046
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2049
  tmp = maybe_realloc((void *)s->elems, count, & s->alloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(s->elems)));
#line 2049
  s->elems = (position *)tmp;
#line 2050
  i = count;
  }
  {
#line 2050
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2050
    if (! (i > lo)) {
#line 2050
      goto while_break___0;
    }
#line 2051
    *(s->elems + i) = *(s->elems + (i - 1L));
#line 2050
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2052
  *(s->elems + lo) = p;
#line 2053
  (s->nelem) ++;
#line 2054
  return;
}
}
#line 2059 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void merge_constrained(position_set const   *s1 , position_set const   *s2 ,
                              unsigned int c2 , position_set *m ) 
{ 
  ptrdiff_t i ;
  ptrdiff_t j ;
  void *tmp ;
  unsigned int c ;
  ptrdiff_t tmp___0 ;
  unsigned int tmp___1 ;
  ptrdiff_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  ptrdiff_t tmp___4 ;

  {
#line 2063
  i = (ptrdiff_t )0;
#line 2063
  j = (ptrdiff_t )0;
#line 2065
  if (m->alloc - (ptrdiff_t )s1->nelem < (ptrdiff_t )s2->nelem) {
    {
#line 2067
    free((void *)m->elems);
#line 2068
    m->alloc = (ptrdiff_t )s1->nelem;
#line 2069
    tmp = xpalloc((void *)0, & m->alloc, (ptrdiff_t )s2->nelem, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(m->elems)));
#line 2069
    m->elems = (position *)tmp;
    }
  }
#line 2071
  m->nelem = (ptrdiff_t )0;
  {
#line 2072
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2072
    if (! (i < (ptrdiff_t )s1->nelem)) {
#line 2072
      if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2072
        goto while_break;
      }
    }
#line 2073
    if (! (j < (ptrdiff_t )s2->nelem)) {
#line 2073
      goto _L;
    } else
#line 2073
    if (i < (ptrdiff_t )s1->nelem) {
#line 2073
      if ((s1->elems + i)->index >= (s2->elems + j)->index) {
        _L: /* CIL Label */ 
#line 2076
        if (i < (ptrdiff_t )s1->nelem) {
#line 2076
          if (j < (ptrdiff_t )s2->nelem) {
#line 2076
            if ((s1->elems + i)->index == (s2->elems + j)->index) {
#line 2076
              tmp___0 = j;
#line 2076
              j ++;
#line 2076
              tmp___1 = (s2->elems + tmp___0)->constraint & c2;
            } else {
#line 2076
              tmp___1 = 0U;
            }
          } else {
#line 2076
            tmp___1 = 0U;
          }
        } else {
#line 2076
          tmp___1 = 0U;
        }
#line 2076
        c = tmp___1;
#line 2080
        (m->elems + m->nelem)->index = (s1->elems + i)->index;
#line 2081
        tmp___2 = m->nelem;
#line 2081
        (m->nelem) ++;
#line 2081
        tmp___3 = i;
#line 2081
        i ++;
#line 2081
        (m->elems + tmp___2)->constraint = (s1->elems + tmp___3)->constraint | c;
      } else {
#line 2073
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 2085
      if ((s2->elems + j)->constraint & c2) {
#line 2087
        (m->elems + m->nelem)->index = (s2->elems + j)->index;
#line 2088
        tmp___4 = m->nelem;
#line 2088
        (m->nelem) ++;
#line 2088
        (m->elems + tmp___4)->constraint = (s2->elems + j)->constraint & c2;
      }
#line 2090
      j ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2092
  return;
}
}
#line 2096 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void merge(position_set const   *s1 , position_set const   *s2 , position_set *m ) 
{ 


  {
  {
#line 2099
  merge_constrained(s1, s2, 4294967295U, m);
  }
#line 2099
  return;
}
}
#line 2104 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static unsigned int delete(size_t del , position_set *s ) 
{ 
  size_t count ;
  size_t lo ;
  size_t hi ;
  size_t mid ;
  unsigned int c ;
  size_t i ;

  {
#line 2107
  count = (size_t )s->nelem;
#line 2108
  lo = (size_t )0;
#line 2108
  hi = count;
  {
#line 2109
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2109
    if (! (lo < hi)) {
#line 2109
      goto while_break;
    }
#line 2111
    mid = (lo + hi) >> 1;
#line 2112
    if ((s->elems + mid)->index > del) {
#line 2113
      lo = mid + 1UL;
    } else
#line 2114
    if ((s->elems + mid)->index == del) {
#line 2116
      c = (s->elems + mid)->constraint;
#line 2118
      i = mid;
      {
#line 2118
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2118
        if (! (i + 1UL < count)) {
#line 2118
          goto while_break___0;
        }
#line 2119
        *(s->elems + i) = *(s->elems + (i + 1UL));
#line 2118
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2120
      s->nelem = (ptrdiff_t )i;
#line 2121
      return (c);
    } else {
#line 2124
      hi = mid;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2126
  return (0U);
}
}
#line 2130 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void replace(position_set *dst , size_t del , position_set *add , unsigned int constraint ,
                    position_set *tmp ) 
{ 
  unsigned int c ;
  unsigned int tmp___0 ;

  {
  {
#line 2134
  tmp___0 = delete(del, dst);
#line 2134
  c = tmp___0 & constraint;
  }
#line 2136
  if (c) {
    {
#line 2138
    copy((position_set const   *)dst, tmp);
#line 2139
    merge_constrained((position_set const   *)tmp, (position_set const   *)add, c,
                      dst);
    }
  }
#line 2141
  return;
}
}
#line 2146 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static state_num state_index(struct dfa *d , position_set const   *s , int context ) 
{ 
  size_t hash ;
  int constraint ;
  state_num i ;
  state_num j ;
  token first_end ;
  int c ;
  void *tmp ;

  {
#line 2149
  hash = (size_t )0;
#line 2150
  constraint = 0;
#line 2152
  first_end = (token )0;
#line 2154
  i = (state_num )0;
  {
#line 2154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2154
    if (! (i < (state_num )s->nelem)) {
#line 2154
      goto while_break;
    }
#line 2155
    hash ^= (s->elems + i)->index + (size_t )(s->elems + i)->constraint;
#line 2154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2158
  i = (state_num )0;
  {
#line 2158
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2158
    if (! (i < d->sindex)) {
#line 2158
      goto while_break___0;
    }
#line 2160
    if (hash != (d->states + i)->hash) {
#line 2162
      goto __Cont;
    } else
#line 2160
    if (s->nelem != (ptrdiff_t const   )(d->states + i)->elems.nelem) {
#line 2162
      goto __Cont;
    } else
#line 2160
    if (context != (int )(d->states + i)->context) {
#line 2162
      goto __Cont;
    }
#line 2163
    j = (state_num )0;
    {
#line 2163
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2163
      if (! (j < (state_num )s->nelem)) {
#line 2163
        goto while_break___1;
      }
#line 2164
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
#line 2166
        goto while_break___1;
      } else
#line 2164
      if ((s->elems + j)->index != ((d->states + i)->elems.elems + j)->index) {
#line 2166
        goto while_break___1;
      }
#line 2163
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2167
    if (j == (state_num )s->nelem) {
#line 2168
      return (i);
    }
    __Cont: /* CIL Label */ 
#line 2158
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2193
  j = (state_num )0;
  {
#line 2193
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2193
    if (! (j < (state_num )s->nelem)) {
#line 2193
      goto while_break___2;
    }
#line 2195
    c = (int )(s->elems + j)->constraint;
#line 2196
    if (*(d->tokens + (s->elems + j)->index) < 0L) {
#line 2198
      if ((((c & 15) | ((c >> 4) & 15)) | ((c >> 8) & 15)) & context) {
#line 2199
        constraint |= c;
      }
#line 2200
      if (! first_end) {
#line 2201
        first_end = *(d->tokens + (s->elems + j)->index);
      }
    } else
#line 2203
    if (*(d->tokens + (s->elems + j)->index) == 257L) {
#line 2204
      constraint = 1911;
    }
#line 2193
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2209
  tmp = maybe_realloc((void *)d->states, d->sindex, & d->salloc, (ptrdiff_t )-1, (ptrdiff_t )sizeof(*(d->states)));
#line 2209
  d->states = (dfa_state *)tmp;
#line 2211
  (d->states + i)->hash = hash;
#line 2212
  alloc_position_set(& (d->states + i)->elems, (size_t )s->nelem);
#line 2213
  copy(s, & (d->states + i)->elems);
#line 2214
  (d->states + i)->context = (unsigned char )context;
#line 2215
  (d->states + i)->constraint = (unsigned short )constraint;
#line 2216
  (d->states + i)->first_end = first_end;
#line 2217
  (d->states + i)->mbps.nelem = (ptrdiff_t )0;
#line 2218
  (d->states + i)->mbps.elems = (position *)((void *)0);
#line 2219
  (d->states + i)->mb_trindex = (state_num )-1;
#line 2221
  (d->sindex) ++;
  }
#line 2223
  return (i);
}
}
#line 2231 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void epsclosure(position_set *initial , struct dfa  const  *d ) 
{ 
  position_set tmp ;
  size_t i ;
  unsigned int constraint ;
  size_t j ;

  {
  {
#line 2235
  alloc_position_set(& tmp, (size_t )d->nleaves);
#line 2236
  i = (size_t )0;
  }
  {
#line 2236
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2236
    if (! (i < (size_t )d->tindex)) {
#line 2236
      goto while_break;
    }
#line 2237
    if ((d->follows + i)->nelem > 0L) {
#line 2237
      if (*(d->tokens + i) >= 256L) {
#line 2237
        if (*(d->tokens + i) != 257L) {
#line 2237
          if (*(d->tokens + i) != 272L) {
#line 2237
            if (*(d->tokens + i) != 273L) {
#line 2237
              if (*(d->tokens + i) < 275L) {
                {
#line 2244
                if (*(d->tokens + i) == 258L) {
#line 2244
                  goto case_258;
                }
#line 2247
                if (*(d->tokens + i) == 259L) {
#line 2247
                  goto case_259;
                }
#line 2250
                if (*(d->tokens + i) == 260L) {
#line 2250
                  goto case_260;
                }
#line 2253
                if (*(d->tokens + i) == 261L) {
#line 2253
                  goto case_261;
                }
#line 2256
                if (*(d->tokens + i) == 262L) {
#line 2256
                  goto case_262;
                }
#line 2259
                if (*(d->tokens + i) == 263L) {
#line 2259
                  goto case_263;
                }
#line 2262
                goto switch_default;
                case_258: /* CIL Label */ 
#line 2245
                constraint = 1092U;
#line 2246
                goto switch_break;
                case_259: /* CIL Label */ 
#line 2248
                constraint = 1792U;
#line 2249
                goto switch_break;
                case_260: /* CIL Label */ 
#line 2251
                constraint = 80U;
#line 2252
                goto switch_break;
                case_261: /* CIL Label */ 
#line 2254
                constraint = 514U;
#line 2255
                goto switch_break;
                case_262: /* CIL Label */ 
#line 2257
                constraint = 594U;
#line 2258
                goto switch_break;
                case_263: /* CIL Label */ 
#line 2260
                constraint = 1317U;
#line 2261
                goto switch_break;
                switch_default: /* CIL Label */ 
#line 2263
                constraint = 1911U;
#line 2264
                goto switch_break;
                switch_break: /* CIL Label */ ;
                }
                {
#line 2267
                delete(i, d->follows + i);
#line 2269
                j = (size_t )0;
                }
                {
#line 2269
                while (1) {
                  while_continue___0: /* CIL Label */ ;
#line 2269
                  if (! (j < (size_t )d->tindex)) {
#line 2269
                    goto while_break___0;
                  }
#line 2270
                  if (i != j) {
#line 2270
                    if ((d->follows + j)->nelem > 0L) {
                      {
#line 2271
                      replace(d->follows + j, i, d->follows + i, constraint, & tmp);
                      }
                    }
                  }
#line 2269
                  j ++;
                }
                while_break___0: /* CIL Label */ ;
                }
                {
#line 2273
                replace(initial, i, d->follows + i, constraint, & tmp);
                }
              }
            }
          }
        }
      }
    }
#line 2236
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2275
  return;
}
}
#line 2280 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static int charclass_context(struct dfa  const  *dfa , charclass_word *c ) 
{ 
  int context ;
  unsigned int j ;

  {
#line 2283
  context = 0;
#line 2286
  j = 0U;
  {
#line 2286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2286
    if (! (j < 4U)) {
#line 2286
      goto while_break;
    }
#line 2288
    if (*(c + j) & dfa->syntax.newline[j]) {
#line 2289
      context |= 4;
    }
#line 2290
    if (*(c + j) & dfa->syntax.letters[j]) {
#line 2291
      context |= 2;
    }
#line 2292
    if (*(c + j) & ~ (dfa->syntax.letters[j] | dfa->syntax.newline[j])) {
#line 2293
      context |= 1;
    }
#line 2286
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2296
  return (context);
}
}
#line 2305 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static int __attribute__((__pure__))  state_separate_contexts(position_set const   *s ) 
{ 
  int separate_contexts ;
  size_t j ;

  {
#line 2308
  separate_contexts = 0;
#line 2311
  j = (size_t )0;
  {
#line 2311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2311
    if (! (j < (size_t )s->nelem)) {
#line 2311
      goto while_break;
    }
#line 2313
    if ((((s->elems + j)->constraint >> 2) & 273U) != ((s->elems + j)->constraint & 273U)) {
#line 2314
      separate_contexts |= 4;
    }
#line 2315
    if ((((s->elems + j)->constraint >> 1) & 273U) != ((s->elems + j)->constraint & 273U)) {
#line 2316
      separate_contexts |= 2;
    }
#line 2311
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2319
  return ((int __attribute__((__pure__))  )separate_contexts);
}
}
#line 2375 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void dfaanalyze(struct dfa *d , _Bool searchflag ) 
{ 
  position *posalloc ;
  void *tmp ;
  position *firstpos ;
  position *lastpos ;
  struct __anonstruct_stkalloc_360611398 *stkalloc ;
  void *tmp___0 ;
  struct __anonstruct_stkalloc_360611398 *stk ;
  position_set tmp___1 ;
  position_set merged ;
  int separate_contexts ;
  size_t i ;
  size_t j ;
  position *pos ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  unsigned int tmp___7 ;
  int __attribute__((__pure__))  tmp___8 ;
  int tmp___9 ;
  state_num tmp___10 ;
  state_num tmp___11 ;

  {
  {
#line 2379
  tmp = xnmalloc(d->nleaves, 2UL * sizeof(*posalloc));
#line 2379
  posalloc = (position *)tmp;
#line 2381
  firstpos = posalloc + d->nleaves;
#line 2382
  lastpos = firstpos + d->nleaves;
#line 2385
  tmp___0 = xnmalloc(d->depth, sizeof(*stkalloc));
#line 2385
  stkalloc = (struct __anonstruct_stkalloc_360611398 *)tmp___0;
#line 2385
  stk = stkalloc;
#line 2411
  d->searchflag = searchflag;
#line 2412
  alloc_position_set(& merged, d->nleaves);
#line 2413
  tmp___2 = xcalloc(d->tindex, sizeof(*(d->follows)));
#line 2413
  d->follows = (position_set *)tmp___2;
#line 2415
  i = (size_t )0;
  }
  {
#line 2415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2415
    if (! (i < d->tindex)) {
#line 2415
      goto while_break;
    }
    {
#line 2419
    if (*(d->tokens + i) == 256L) {
#line 2419
      goto case_256;
    }
#line 2429
    if (*(d->tokens + i) == 266L) {
#line 2429
      goto case_266;
    }
#line 2429
    if (*(d->tokens + i) == 265L) {
#line 2429
      goto case_266;
    }
#line 2442
    if (*(d->tokens + i) == 264L) {
#line 2442
      goto case_264;
    }
#line 2448
    if (*(d->tokens + i) == 268L) {
#line 2448
      goto case_268;
    }
#line 2485
    if (*(d->tokens + i) == 269L) {
#line 2485
      goto case_269;
    }
#line 2497
    goto switch_default;
    case_256: /* CIL Label */ 
#line 2421
    stk->nullable = (_Bool)1;
#line 2424
    tmp___3 = (size_t )0;
#line 2424
    stk->nlastpos = tmp___3;
#line 2424
    stk->nfirstpos = tmp___3;
#line 2425
    stk ++;
#line 2426
    goto switch_break;
    case_266: /* CIL Label */ 
    case_265: /* CIL Label */ 
#line 2432
    tmp___1.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2433
    tmp___1.elems = firstpos;
#line 2434
    pos = lastpos;
#line 2435
    j = (size_t )0;
    {
#line 2435
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2435
      if (! (j < (stk + -1)->nlastpos)) {
#line 2435
        goto while_break___0;
      }
      {
#line 2437
      merge((position_set const   *)(& tmp___1), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2438
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2435
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    case_264: /* CIL Label */ 
#line 2444
    if (*(d->tokens + i) != 266L) {
#line 2445
      (stk + -1)->nullable = (_Bool)1;
    }
#line 2446
    goto switch_break;
    case_268: /* CIL Label */ 
#line 2451
    tmp___1.nelem = (ptrdiff_t )(stk + -1)->nfirstpos;
#line 2452
    tmp___1.elems = firstpos;
#line 2453
    pos = lastpos + (stk + -1)->nlastpos;
#line 2454
    j = (size_t )0;
    {
#line 2454
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2454
      if (! (j < (stk + -2)->nlastpos)) {
#line 2454
        goto while_break___1;
      }
      {
#line 2456
      merge((position_set const   *)(& tmp___1), (position_set const   *)(d->follows + (pos + j)->index),
            & merged);
#line 2457
      copy((position_set const   *)(& merged), d->follows + (pos + j)->index);
#line 2454
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2462
    if ((stk + -2)->nullable) {
#line 2463
      (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
    } else {
#line 2465
      firstpos += (stk + -1)->nfirstpos;
    }
#line 2469
    if ((stk + -1)->nullable) {
#line 2470
      (stk + -2)->nlastpos += (stk + -1)->nlastpos;
    } else {
#line 2473
      pos = lastpos + (stk + -2)->nlastpos;
#line 2474
      j = (stk + -1)->nlastpos;
      {
#line 2474
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2474
        tmp___4 = j;
#line 2474
        j --;
#line 2474
        if (! (tmp___4 > 0UL)) {
#line 2474
          goto while_break___2;
        }
#line 2475
        *(pos + j) = *(lastpos + j);
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2476
      lastpos += (stk + -2)->nlastpos;
#line 2477
      (stk + -2)->nlastpos = (stk + -1)->nlastpos;
    }
#line 2481
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable & (int )(stk + -1)->nullable);
#line 2482
    stk --;
#line 2483
    goto switch_break;
    case_269: /* CIL Label */ 
#line 2487
    (stk + -2)->nfirstpos += (stk + -1)->nfirstpos;
#line 2490
    (stk + -2)->nlastpos += (stk + -1)->nlastpos;
#line 2493
    (stk + -2)->nullable = (_Bool )((int )(stk + -2)->nullable | (int )(stk + -1)->nullable);
#line 2494
    stk --;
#line 2495
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2503
    stk->nullable = (_Bool )(*(d->tokens + i) == 257L);
#line 2506
    tmp___5 = (size_t )1;
#line 2506
    stk->nlastpos = tmp___5;
#line 2506
    stk->nfirstpos = tmp___5;
#line 2507
    stk ++;
#line 2509
    firstpos --;
#line 2509
    lastpos --;
#line 2510
    tmp___6 = i;
#line 2510
    lastpos->index = tmp___6;
#line 2510
    firstpos->index = tmp___6;
#line 2511
    tmp___7 = 1911U;
#line 2511
    lastpos->constraint = tmp___7;
#line 2511
    firstpos->constraint = tmp___7;
#line 2514
    alloc_position_set(d->follows + i, (size_t )1);
    }
#line 2515
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2415
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2560
  merged.nelem = (ptrdiff_t )0;
#line 2561
  i = (size_t )0;
  {
#line 2561
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2561
    if (! (i < (stk + -1)->nfirstpos)) {
#line 2561
      goto while_break___3;
    }
    {
#line 2562
    insert(*(firstpos + i), & merged);
#line 2561
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2566
  epsclosure(& merged, (struct dfa  const  *)d);
#line 2569
  tmp___8 = state_separate_contexts((position_set const   *)(& merged));
#line 2569
  separate_contexts = (int )tmp___8;
  }
#line 2570
  if (separate_contexts & 4) {
    {
#line 2571
    state_index(d, (position_set const   *)(& merged), 4);
    }
  }
  {
#line 2572
  tmp___10 = state_index(d, (position_set const   *)(& merged), separate_contexts ^ 7);
#line 2572
  tmp___9 = (int )tmp___10;
#line 2572
  d->min_trcount = tmp___9;
#line 2572
  d->initstate_notbol = (state_num )tmp___9;
  }
#line 2574
  if (separate_contexts & 2) {
    {
#line 2575
    tmp___11 = state_index(d, (position_set const   *)(& merged), 2);
#line 2575
    d->min_trcount = (int )tmp___11;
    }
  }
  {
#line 2576
  (d->min_trcount) ++;
#line 2577
  d->trcount = 0;
#line 2579
  free((void *)posalloc);
#line 2580
  free((void *)stkalloc);
#line 2581
  free((void *)merged.elems);
  }
#line 2582
  return;
}
}
#line 2615 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static state_num dfastate(state_num s , struct dfa *d , unsigned char uc , state_num *trans ) 
{ 
  leaf_set group ;
  charclass label ;
  position_set follows ;
  position_set tmp ;
  state_num state ;
  state_num state_newline ;
  state_num state_letter ;
  size_t i ;
  size_t j ;
  size_t k ;
  void *tmp___0 ;
  charclass matches ;
  position pos ;
  _Bool matched ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  size_t tmp___4 ;
  int possible_contexts ;
  int separate_contexts ;
  _Bool mergeit ;
  int __attribute__((__pure__))  tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;

  {
  {
#line 2631
  tmp___0 = xnmalloc(d->nleaves, sizeof(*(group.elems)));
#line 2631
  group.elems = (size_t *)tmp___0;
#line 2632
  group.nelem = (size_t )0;
#line 2634
  fillset((charclass_word *)(label));
#line 2636
  i = (size_t )0;
  }
  {
#line 2636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2636
    if (! (i < (size_t )(d->states + s)->elems.nelem)) {
#line 2636
      goto while_break;
    }
#line 2639
    pos = *((d->states + s)->elems.elems + i);
#line 2640
    matched = (_Bool)0;
#line 2641
    if (*(d->tokens + pos.index) >= 0L) {
#line 2641
      if (*(d->tokens + pos.index) < 256L) {
        {
#line 2643
        zeroset((charclass_word *)(matches));
#line 2644
        setbit((unsigned int )*(d->tokens + pos.index), (charclass_word *)(matches));
        }
#line 2645
        if (*(d->tokens + pos.index) == (token )uc) {
#line 2646
          matched = (_Bool)1;
        }
      } else {
#line 2641
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2648
    if (*(d->tokens + pos.index) >= 275L) {
      {
#line 2650
      copyset((charclass_word */* const  */)(*(d->charclasses + (*(d->tokens + pos.index) - 275L))),
              (charclass_word *)(matches));
#line 2651
      tmp___1 = tstbit((unsigned int )uc, (charclass_word */* const  */)(*(d->charclasses + (*(d->tokens + pos.index) - 275L))));
      }
#line 2651
      if (tmp___1) {
#line 2652
        matched = (_Bool)1;
      }
    } else
#line 2654
    if (*(d->tokens + pos.index) == 272L) {
      {
#line 2656
      copyset((charclass_word */* const  */)(*(d->charclasses + d->canychar)), (charclass_word *)(matches));
#line 2657
      tmp___2 = tstbit((unsigned int )uc, (charclass_word */* const  */)(*(d->charclasses + d->canychar)));
      }
#line 2657
      if (tmp___2) {
#line 2658
        matched = (_Bool)1;
      }
#line 2666
      if ((pos.constraint & 15U) & (unsigned int )(d->states + s)->context) {
#line 2669
        if ((d->states + s)->mbps.nelem == 0L) {
          {
#line 2670
          alloc_position_set(& (d->states + s)->mbps, (size_t )(d->follows + pos.index)->nelem);
          }
        }
#line 2672
        j = (size_t )0;
        {
#line 2672
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2672
          if (! (j < (size_t )(d->follows + pos.index)->nelem)) {
#line 2672
            goto while_break___0;
          }
          {
#line 2673
          insert(*((d->follows + pos.index)->elems + j), & (d->states + s)->mbps);
#line 2672
          j ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else {
#line 2677
      goto __Cont;
    }
#line 2681
    if (pos.constraint != 1911U) {
#line 2683
      if (! (((pos.constraint >> 8) & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2685
        j = (size_t )0;
        {
#line 2685
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2685
          if (! (j < 4UL)) {
#line 2685
            goto while_break___1;
          }
#line 2686
          matches[j] &= ~ d->syntax.newline[j];
#line 2685
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 2687
      if (! (((pos.constraint >> 4) & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2689
        j = (size_t )0;
        {
#line 2689
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 2689
          if (! (j < 4UL)) {
#line 2689
            goto while_break___2;
          }
#line 2690
          matches[j] &= ~ d->syntax.letters[j];
#line 2689
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 2691
      if (! ((pos.constraint & 15U) & (unsigned int )(d->states + s)->context)) {
#line 2693
        j = (size_t )0;
        {
#line 2693
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 2693
          if (! (j < 4UL)) {
#line 2693
            goto while_break___3;
          }
#line 2694
          matches[j] &= d->syntax.letters[j] | d->syntax.newline[j];
#line 2693
          j ++;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 2697
      j = (size_t )0;
      {
#line 2697
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2697
        if (j < 4UL) {
#line 2697
          if (! (! matches[j])) {
#line 2697
            goto while_break___4;
          }
        } else {
#line 2697
          goto while_break___4;
        }
#line 2698
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 2697
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2699
      if (j == 4UL) {
#line 2700
        goto __Cont;
      }
      {
#line 2705
      tmp___3 = tstbit((unsigned int )uc, (charclass_word */* const  */)(matches));
      }
#line 2705
      if (! tmp___3) {
#line 2706
        matched = (_Bool)0;
      }
    }
#line 2719
    if (matched) {
#line 2721
      k = (size_t )0;
      {
#line 2721
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2721
        if (! (k < 4UL)) {
#line 2721
          goto while_break___5;
        }
#line 2722
        label[k] &= matches[k];
#line 2721
        k ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 2723
      tmp___4 = group.nelem;
#line 2723
      (group.nelem) ++;
#line 2723
      *(group.elems + tmp___4) = pos.index;
    } else {
#line 2727
      k = (size_t )0;
      {
#line 2727
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2727
        if (! (k < 4UL)) {
#line 2727
          goto while_break___6;
        }
#line 2728
        label[k] &= ~ matches[k];
#line 2727
        k ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    __Cont: /* CIL Label */ 
#line 2636
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2732
  alloc_position_set(& follows, d->nleaves);
#line 2733
  alloc_position_set(& tmp, d->nleaves);
  }
#line 2735
  if (group.nelem > 0UL) {
#line 2740
    follows.nelem = (ptrdiff_t )0;
#line 2744
    j = (size_t )0;
    {
#line 2744
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 2744
      if (! (j < group.nelem)) {
#line 2744
        goto while_break___7;
      }
#line 2745
      k = (size_t )0;
      {
#line 2745
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2745
        if (! (k < (size_t )(d->follows + *(group.elems + j))->nelem)) {
#line 2745
          goto while_break___8;
        }
        {
#line 2746
        insert(*((d->follows + *(group.elems + j))->elems + k), & follows);
#line 2745
        k ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 2744
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 2750
    if (d->searchflag) {
#line 2769
      mergeit = (_Bool )(! d->localeinfo.multibyte);
#line 2770
      if (! mergeit) {
#line 2771
        mergeit = (_Bool)1;
#line 2771
        j = (size_t )0;
        {
#line 2771
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 2771
          if (mergeit) {
#line 2771
            if (! (j < (size_t )follows.nelem)) {
#line 2771
              goto while_break___9;
            }
          } else {
#line 2771
            goto while_break___9;
          }
#line 2772
          mergeit = (_Bool )((int )mergeit & *(d->multibyte_prop + (follows.elems + j)->index));
#line 2771
          j ++;
        }
        while_break___9: /* CIL Label */ ;
        }
      }
#line 2773
      if (mergeit) {
        {
#line 2775
        merge((position_set const   *)(& (d->states + 0)->elems), (position_set const   *)(& follows),
              & tmp);
#line 2776
        copy((position_set const   *)(& tmp), & follows);
        }
      }
    }
    {
#line 2781
    possible_contexts = charclass_context((struct dfa  const  *)d, (charclass_word *)(label));
#line 2782
    tmp___5 = state_separate_contexts((position_set const   *)(& follows));
#line 2782
    separate_contexts = (int )tmp___5;
    }
#line 2785
    if (possible_contexts & ~ separate_contexts) {
      {
#line 2786
      state = state_index(d, (position_set const   *)(& follows), separate_contexts ^ 7);
      }
    } else {
#line 2788
      state = (state_num )-1;
    }
#line 2789
    if ((separate_contexts & possible_contexts) & 4) {
      {
#line 2790
      state_newline = state_index(d, (position_set const   *)(& follows), 4);
      }
    } else {
#line 2792
      state_newline = state;
    }
#line 2793
    if ((separate_contexts & possible_contexts) & 2) {
      {
#line 2794
      state_letter = state_index(d, (position_set const   *)(& follows), 2);
      }
    } else {
#line 2796
      state_letter = state;
    }
  } else
#line 2802
  if (d->searchflag) {
#line 2804
    state_newline = (state_num )0;
#line 2805
    state_letter = (state_num )(d->min_trcount - 1);
#line 2806
    state = d->initstate_notbol;
  } else {
#line 2810
    state_newline = (state_num )-1;
#line 2811
    state_letter = (state_num )-1;
#line 2812
    state = (state_num )-1;
  }
#line 2816
  i = (size_t )0;
  {
#line 2816
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 2816
    if (! (i < 256UL)) {
#line 2816
      goto while_break___10;
    }
    {
#line 2817
    tmp___6 = tstbit((unsigned int )i, (charclass_word */* const  */)(label));
    }
#line 2817
    if (tmp___6) {
      {
#line 2820
      if (d->syntax.sbit[i] == 4) {
#line 2820
        goto case_4;
      }
#line 2823
      if (d->syntax.sbit[i] == 2) {
#line 2823
        goto case_2;
      }
#line 2826
      goto switch_default;
      case_4: /* CIL Label */ 
#line 2821
      *(trans + i) = state_newline;
#line 2822
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2824
      *(trans + i) = state_letter;
#line 2825
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 2827
      *(trans + i) = state;
#line 2828
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 2816
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 2842
  free((void *)group.elems);
#line 2843
  free((void *)follows.elems);
#line 2844
  free((void *)tmp.elems);
#line 2848
  tmp___7 = tstbit((unsigned int )d->syntax.eolbyte, (charclass_word */* const  */)(label));
  }
#line 2848
  if (tmp___7) {
#line 2850
    *(d->newlines + s) = *(trans + d->syntax.eolbyte);
#line 2851
    *(trans + d->syntax.eolbyte) = (state_num )-1;
  }
#line 2854
  return (*(trans + uc));
}
}
#line 2858 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void realloc_trans_if_necessary(struct dfa *d , state_num new_state ) 
{ 
  state_num oldalloc ;
  state_num **realtrans ;
  state_num **tmp ;
  ptrdiff_t newalloc ;
  ptrdiff_t newalloc1 ;
  void *tmp___0 ;
  state_num *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  state_num *tmp___6 ;

  {
#line 2861
  oldalloc = d->tralloc;
#line 2862
  if (oldalloc <= new_state) {
#line 2864
    if (d->trans) {
#line 2864
      tmp = d->trans - 2;
    } else {
#line 2864
      tmp = (state_num **)((void *)0);
    }
#line 2864
    realtrans = tmp;
#line 2866
    if (realtrans) {
#line 2866
      newalloc1 = d->tralloc + 2L;
    } else {
#line 2866
      newalloc1 = (ptrdiff_t )0;
    }
    {
#line 2867
    tmp___0 = xpalloc((void *)realtrans, & newalloc1, (new_state - oldalloc) + 1L,
                      (ptrdiff_t )-1, (ptrdiff_t )sizeof(*realtrans));
#line 2867
    realtrans = (state_num **)tmp___0;
#line 2869
    tmp___1 = (state_num *)((void *)0);
#line 2869
    *(realtrans + 1) = tmp___1;
#line 2869
    *(realtrans + 0) = tmp___1;
#line 2870
    d->trans = realtrans + 2;
#line 2871
    newalloc = newalloc1 - 2L;
#line 2871
    d->tralloc = newalloc;
#line 2872
    tmp___2 = xnrealloc((void *)d->fails, (size_t )newalloc, sizeof(*(d->fails)));
#line 2872
    d->fails = (state_num **)tmp___2;
#line 2873
    tmp___3 = xnrealloc((void *)d->success, (size_t )newalloc, sizeof(*(d->success)));
#line 2873
    d->success = (int *)tmp___3;
#line 2874
    tmp___4 = xnrealloc((void *)d->newlines, (size_t )newalloc, sizeof(*(d->newlines)));
#line 2874
    d->newlines = (state_num *)tmp___4;
    }
#line 2875
    if (d->localeinfo.multibyte) {
#line 2877
      if (d->mb_trans) {
#line 2877
        realtrans = d->mb_trans - 2;
      } else {
#line 2877
        realtrans = (state_num **)((void *)0);
      }
      {
#line 2878
      tmp___5 = xnrealloc((void *)realtrans, (size_t )newalloc1, sizeof(*realtrans));
#line 2878
      realtrans = (state_num **)tmp___5;
      }
#line 2879
      if (oldalloc == 0L) {
#line 2880
        tmp___6 = (state_num *)((void *)0);
#line 2880
        *(realtrans + 1) = tmp___6;
#line 2880
        *(realtrans + 0) = tmp___6;
      }
#line 2881
      d->mb_trans = realtrans + 2;
    }
    {
#line 2883
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2883
      if (! (oldalloc < newalloc)) {
#line 2883
        goto while_break;
      }
#line 2885
      *(d->trans + oldalloc) = (state_num *)((void *)0);
#line 2886
      *(d->fails + oldalloc) = (state_num *)((void *)0);
#line 2887
      if (d->localeinfo.multibyte) {
#line 2888
        *(d->mb_trans + oldalloc) = (state_num *)((void *)0);
      }
#line 2883
      oldalloc ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2891
  return;
}
}
#line 2897 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static state_num build_state(state_num s , struct dfa *d , unsigned char uc ) 
{ 
  state_num **ptrans ;
  state_num **tmp ;
  state_num *trans ;
  state_num i ;
  state_num *tmp___0 ;
  void *tmp___1 ;
  int i___0 ;
  state_num maxstate ;
  int i___1 ;

  {
#line 2901
  if ((d->states + s)->constraint) {
#line 2901
    tmp = d->fails;
  } else {
#line 2901
    tmp = d->trans;
  }
#line 2901
  ptrans = tmp + s;
#line 2902
  trans = *ptrans;
#line 2904
  if (! trans) {
#line 2910
    if (1024 <= d->trcount) {
#line 2912
      i = (state_num )d->min_trcount;
      {
#line 2912
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2912
        if (! (i < d->tralloc)) {
#line 2912
          goto while_break;
        }
        {
#line 2914
        free((void *)*(d->trans + i));
#line 2915
        free((void *)*(d->fails + i));
#line 2916
        tmp___0 = (state_num *)((void *)0);
#line 2916
        *(d->fails + i) = tmp___0;
#line 2916
        *(d->trans + i) = tmp___0;
#line 2912
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 2918
      d->trcount = 0;
    }
    {
#line 2921
    (d->trcount) ++;
#line 2922
    tmp___1 = xmalloc(256UL * sizeof(*trans));
#line 2922
    trans = (state_num *)tmp___1;
#line 2922
    *ptrans = trans;
#line 2926
    i___0 = 0;
    }
    {
#line 2926
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2926
      if (! (i___0 < 256)) {
#line 2926
        goto while_break___0;
      }
#line 2927
      *(trans + i___0) = (state_num )-2;
#line 2926
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2931
  *(d->success + s) = 0;
#line 2932
  if ((((int )(d->states + s)->constraint >> 8) & 15) & (int )(d->states + s)->context) {
#line 2933
    *(d->success + s) |= 4;
  }
#line 2934
  if ((((int )(d->states + s)->constraint >> 4) & 15) & (int )(d->states + s)->context) {
#line 2935
    *(d->success + s) |= 2;
  }
#line 2936
  if (((int )(d->states + s)->constraint & 15) & (int )(d->states + s)->context) {
#line 2937
    *(d->success + s) |= 1;
  }
  {
#line 2939
  s = dfastate(s, d, uc, trans);
#line 2944
  maxstate = (state_num )-1;
#line 2945
  i___1 = 0;
  }
  {
#line 2945
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2945
    if (! (i___1 < 256)) {
#line 2945
      goto while_break___1;
    }
#line 2946
    if (maxstate < *(trans + i___1)) {
#line 2947
      maxstate = *(trans + i___1);
    }
#line 2945
    i___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2948
  realloc_trans_if_necessary(d, maxstate);
  }
#line 2950
  return (s);
}
}
#line 2959 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static state_num transit_state_singlebyte(struct dfa *d , state_num s , unsigned char const   **pp ) 
{ 
  state_num *t ;
  unsigned char const   *tmp___0 ;

  {
#line 2964
  if (*(d->trans + s)) {
#line 2965
    t = *(d->trans + s);
  } else
#line 2966
  if (*(d->fails + s)) {
#line 2967
    t = *(d->fails + s);
  } else {
    {
#line 2970
    build_state(s, d, (unsigned char )*(*pp));
    }
#line 2971
    if (*(d->trans + s)) {
#line 2972
      t = *(d->trans + s);
    } else {
#line 2975
      t = *(d->fails + s);
#line 2976
      if (! t) {
        {
#line 2976
        __assert_fail("t", "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c", 2976U,
                      "transit_state_singlebyte");
        }
      }
    }
  }
#line 2980
  if (*(t + *(*pp)) == -2L) {
    {
#line 2981
    build_state(s, d, (unsigned char )*(*pp));
    }
  }
#line 2983
  tmp___0 = *pp;
#line 2983
  (*pp) ++;
#line 2983
  return (*(t + *tmp___0));
}
}
#line 2989 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static state_num transit_state(struct dfa *d , state_num s , unsigned char const   **pp ,
                               unsigned char const   *end ) 
{ 
  state_num s1 ;
  state_num s2 ;
  wint_t wc ;
  int separate_contexts ;
  size_t i ;
  int mbclen ;
  size_t tmp ;
  state_num s3 ;
  state_num tmp___0 ;
  void *tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;

  {
  {
#line 2998
  tmp = mbs_to_wchar(& wc, (char const   *)*pp, (size_t )(end - *pp), d);
#line 2998
  mbclen = (int )tmp;
#line 3001
  d->mb_follows.nelem = (ptrdiff_t )0;
#line 3005
  s1 = s;
#line 3006
  i = (size_t )0;
  }
  {
#line 3006
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3006
    if (i < (size_t )mbclen) {
#line 3006
      if (! (i == 0UL)) {
#line 3006
        if (! ((state_num )d->min_trcount <= s)) {
#line 3006
          goto while_break;
        }
      }
    } else {
#line 3006
      goto while_break;
    }
    {
#line 3007
    s = transit_state_singlebyte(d, s, pp);
#line 3006
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3008
  *pp += (size_t )mbclen - i;
#line 3010
  if (wc == 4294967295U) {
#line 3013
    return (s);
  }
#line 3019
  if ((d->states + s1)->mb_trindex < 0L) {
#line 3021
    if (1024L <= d->mb_trcount) {
#line 3024
      s3 = (state_num )-1;
      {
#line 3024
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3024
        if (! (s3 < d->tralloc)) {
#line 3024
          goto while_break___0;
        }
        {
#line 3026
        free((void *)*(d->mb_trans + s3));
#line 3027
        *(d->mb_trans + s3) = (state_num *)((void *)0);
#line 3024
        s3 ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3030
      i = (size_t )0;
      {
#line 3030
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3030
        if (! (i < (size_t )d->sindex)) {
#line 3030
          goto while_break___1;
        }
#line 3031
        (d->states + i)->mb_trindex = (state_num )-1;
#line 3030
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3032
      d->mb_trcount = (state_num )0;
    }
#line 3034
    tmp___0 = d->mb_trcount;
#line 3034
    (d->mb_trcount) ++;
#line 3034
    (d->states + s1)->mb_trindex = tmp___0;
  }
#line 3037
  if (! *(d->mb_trans + s)) {
    {
#line 3041
    tmp___1 = xmalloc((size_t )8192);
#line 3041
    *(d->mb_trans + s) = (state_num *)tmp___1;
#line 3042
    i = (size_t )0;
    }
    {
#line 3042
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3042
      if (! (i < 1024UL)) {
#line 3042
        goto while_break___2;
      }
#line 3043
      *(*(d->mb_trans + s) + i) = (state_num )-1;
#line 3042
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 3045
  if (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) >= 0L) {
#line 3046
    return (*(*(d->mb_trans + s) + (d->states + s1)->mb_trindex));
  }
#line 3048
  if (s == -1L) {
    {
#line 3049
    copy((position_set const   *)(& (d->states + s1)->mbps), & d->mb_follows);
    }
  } else {
    {
#line 3051
    merge((position_set const   *)(& (d->states + s1)->mbps), (position_set const   *)(& (d->states + s)->elems),
          & d->mb_follows);
    }
  }
  {
#line 3053
  tmp___2 = state_separate_contexts((position_set const   *)(& d->mb_follows));
#line 3053
  separate_contexts = (int )tmp___2;
#line 3054
  s2 = state_index(d, (position_set const   *)(& d->mb_follows), separate_contexts ^ 7);
#line 3055
  realloc_trans_if_necessary(d, s2);
#line 3057
  *(*(d->mb_trans + s) + (d->states + s1)->mb_trindex) = s2;
  }
#line 3059
  return (s2);
}
}
#line 3077 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static unsigned char const   *skip_remains_mb(struct dfa *d , unsigned char const   *p ,
                                              unsigned char const   *mbp , char const   *end ) 
{ 
  wint_t wc ;
  size_t tmp ;

  {
#line 3082
  if (d->syntax.never_trail[*p]) {
#line 3083
    return (p);
  }
  {
#line 3084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3084
    if (! ((unsigned long )mbp < (unsigned long )p)) {
#line 3084
      goto while_break;
    }
    {
#line 3085
    tmp = mbs_to_wchar(& wc, (char const   *)mbp, (size_t )(end - (char const   *)mbp),
                       d);
#line 3085
    mbp += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3087
  return (mbp);
}
}
#line 3110 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
__inline static char *dfaexec_main(struct dfa *d , char const   *begin , char *end ,
                                   _Bool allow_nl , size_t *count , _Bool multibyte ) 
{ 
  state_num s ;
  state_num s1 ;
  unsigned char const   *p ;
  unsigned char const   *mbp ;
  state_num **trans ;
  state_num *t ;
  unsigned char eol ;
  unsigned char saved_end ;
  size_t nlcount ;
  state_num *tmp ;
  unsigned char const   *tmp___0 ;
  unsigned char const   *tmp___1 ;
  state_num tmp___2 ;
  unsigned char const   *tmp___3 ;
  state_num tmp___4 ;
  state_num tmp___5 ;
  unsigned char const   *tmp___6 ;

  {
#line 3118
  eol = d->syntax.eolbyte;
#line 3120
  nlcount = (size_t )0;
#line 3122
  if (1024L <= d->sindex) {
#line 3124
    s = (state_num )d->min_trcount;
    {
#line 3124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3124
      if (! (s < d->sindex)) {
#line 3124
        goto while_break;
      }
      {
#line 3126
      free((void *)(d->states + s)->elems.elems);
#line 3127
      free((void *)(d->states + s)->mbps.elems);
#line 3124
      s ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3129
    d->sindex = (state_num )d->min_trcount;
#line 3131
    if (d->trans) {
#line 3133
      s = (state_num )0;
      {
#line 3133
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 3133
        if (! (s < d->tralloc)) {
#line 3133
          goto while_break___0;
        }
        {
#line 3135
        free((void *)*(d->trans + s));
#line 3136
        free((void *)*(d->fails + s));
#line 3137
        tmp = (state_num *)((void *)0);
#line 3137
        *(d->fails + s) = tmp;
#line 3137
        *(d->trans + s) = tmp;
#line 3133
        s ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 3139
      d->trcount = 0;
    }
#line 3142
    if (d->localeinfo.multibyte) {
#line 3142
      if (d->mb_trans) {
#line 3144
        s = (state_num )-1;
        {
#line 3144
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 3144
          if (! (s < d->tralloc)) {
#line 3144
            goto while_break___1;
          }
          {
#line 3146
          free((void *)*(d->mb_trans + s));
#line 3147
          *(d->mb_trans + s) = (state_num *)((void *)0);
#line 3144
          s ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 3149
        s = (state_num )0;
        {
#line 3149
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 3149
          if (! (s < (state_num )d->min_trcount)) {
#line 3149
            goto while_break___2;
          }
#line 3150
          (d->states + s)->mb_trindex = (state_num )-1;
#line 3149
          s ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 3151
        d->mb_trcount = (state_num )0;
      }
    }
  }
#line 3155
  if (! d->tralloc) {
    {
#line 3156
    realloc_trans_if_necessary(d, (state_num )0);
    }
  }
#line 3158
  s1 = (state_num )0;
#line 3158
  s = s1;
#line 3159
  mbp = (unsigned char const   *)begin;
#line 3159
  p = mbp;
#line 3160
  trans = d->trans;
#line 3161
  saved_end = *((unsigned char *)end);
#line 3162
  *end = (char )eol;
#line 3164
  if (multibyte) {
    {
#line 3166
    memset((void *)(& d->mbs), 0, sizeof(d->mbs));
    }
#line 3167
    if (d->mb_follows.alloc == 0L) {
      {
#line 3168
      alloc_position_set(& d->mb_follows, d->nleaves);
      }
    }
  }
  {
#line 3171
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 3173
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3173
      t = *(trans + s);
#line 3173
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 3173
        goto while_break___4;
      }
#line 3175
      if (s < (state_num )d->min_trcount) {
#line 3177
        if (! multibyte) {
#line 3177
          goto _L;
        } else
#line 3177
        if ((d->states + s)->mbps.nelem == 0L) {
          _L: /* CIL Label */ 
          {
#line 3179
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 3179
            if (! (*(t + *p) == s)) {
#line 3179
              goto while_break___5;
            }
#line 3180
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 3182
        if (multibyte) {
          {
#line 3183
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3183
          p = mbp;
          }
        }
      }
#line 3186
      if (multibyte) {
#line 3188
        s1 = s;
#line 3190
        if ((d->states + s)->mbps.nelem == 0L) {
#line 3195
          tmp___0 = p;
#line 3195
          p ++;
#line 3195
          s = *(t + *tmp___0);
        } else
#line 3190
        if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3195
          tmp___0 = p;
#line 3195
          p ++;
#line 3195
          s = *(t + *tmp___0);
        } else
#line 3190
        if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3195
          tmp___0 = p;
#line 3195
          p ++;
#line 3195
          s = *(t + *tmp___0);
        } else {
          {
#line 3199
          s = transit_state(d, s, & p, (unsigned char const   *)((unsigned char *)end));
#line 3200
          mbp = p;
#line 3201
          trans = d->trans;
          }
        }
      } else {
#line 3206
        tmp___1 = p;
#line 3206
        p ++;
#line 3206
        s1 = *(t + *tmp___1);
#line 3207
        t = *(trans + s1);
#line 3208
        if (! t) {
#line 3210
          tmp___2 = s;
#line 3211
          s = s1;
#line 3212
          s1 = tmp___2;
#line 3213
          goto while_break___4;
        }
#line 3215
        if (s < (state_num )d->min_trcount) {
          {
#line 3217
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 3217
            if (! (*(t + *p) == s1)) {
#line 3217
              goto while_break___6;
            }
#line 3218
            p ++;
          }
          while_break___6: /* CIL Label */ ;
          }
        }
#line 3220
        tmp___3 = p;
#line 3220
        p ++;
#line 3220
        s = *(t + *tmp___3);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3224
    if (s < 0L) {
#line 3226
      if (s == -2L) {
        {
#line 3228
        s = build_state(s1, d, (unsigned char )*(p + -1));
#line 3229
        trans = d->trans;
        }
      } else
#line 3231
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
#line 3231
        if ((int const   )*(p + -1) == (int const   )eol) {
#line 3231
          if (0L <= *(d->newlines + s1)) {
#line 3235
            nlcount ++;
#line 3236
            mbp = p;
#line 3238
            if (allow_nl) {
#line 3238
              s = *(d->newlines + s1);
            } else {
#line 3238
              if (d->syntax.sbit[eol] == 4) {
#line 3238
                tmp___5 = (state_num )0;
              } else {
#line 3238
                if (d->syntax.sbit[eol] == 2) {
#line 3238
                  tmp___4 = (state_num )(d->min_trcount - 1);
                } else {
#line 3238
                  tmp___4 = d->initstate_notbol;
                }
#line 3238
                tmp___5 = tmp___4;
              }
#line 3238
              s = tmp___5;
            }
          } else {
#line 3245
            p = (unsigned char const   *)((void *)0);
#line 3246
            goto done;
          }
        } else {
#line 3245
          p = (unsigned char const   *)((void *)0);
#line 3246
          goto done;
        }
      } else {
#line 3245
        p = (unsigned char const   *)((void *)0);
#line 3246
        goto done;
      }
    } else
#line 3249
    if (*(d->fails + s)) {
#line 3251
      if (*(d->success + s) & d->syntax.sbit[*p]) {
#line 3255
        goto done;
      } else
#line 3251
      if ((unsigned long )((char *)p) == (unsigned long )end) {
#line 3251
        if ((((int )(d->states + s)->constraint >> 8) & 15) & (int )(d->states + s)->context) {
#line 3255
          goto done;
        }
      }
#line 3257
      if (multibyte) {
#line 3257
        if (s < (state_num )d->min_trcount) {
          {
#line 3258
          mbp = skip_remains_mb(d, p, mbp, (char const   *)end);
#line 3258
          p = mbp;
          }
        }
      }
#line 3260
      s1 = s;
#line 3261
      if (! multibyte) {
#line 3266
        tmp___6 = p;
#line 3266
        p ++;
#line 3266
        s = *(*(d->fails + s) + *tmp___6);
      } else
#line 3261
      if ((d->states + s)->mbps.nelem == 0L) {
#line 3266
        tmp___6 = p;
#line 3266
        p ++;
#line 3266
        s = *(*(d->fails + s) + *tmp___6);
      } else
#line 3261
      if (d->localeinfo.sbctowc[*p] != 4294967295U) {
#line 3266
        tmp___6 = p;
#line 3266
        p ++;
#line 3266
        s = *(*(d->fails + s) + *tmp___6);
      } else
#line 3261
      if ((unsigned long )((char *)p) >= (unsigned long )end) {
#line 3266
        tmp___6 = p;
#line 3266
        p ++;
#line 3266
        s = *(*(d->fails + s) + *tmp___6);
      } else {
        {
#line 3270
        s = transit_state(d, s, & p, (unsigned char const   *)((unsigned char *)end));
#line 3271
        mbp = p;
#line 3272
        trans = d->trans;
        }
      }
    } else {
      {
#line 3277
      build_state(s, d, (unsigned char )*(p + 0));
#line 3278
      trans = d->trans;
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  done: 
#line 3283
  if (count) {
#line 3284
    *count += nlcount;
  }
#line 3285
  *end = (char )saved_end;
#line 3286
  return ((char *)p);
}
}
#line 3292 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char *dfaexec_mb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3296
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)1);
  }
#line 3296
  return (tmp);
}
}
#line 3299 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char *dfaexec_sb(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                        size_t *count , _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3303
  tmp = dfaexec_main(d, begin, end, allow_nl, count, (_Bool)0);
  }
#line 3303
  return (tmp);
}
}
#line 3308 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char *dfaexec_noop(struct dfa *d , char const   *begin , char *end , _Bool allow_nl ,
                          size_t *count , _Bool *backref ) 
{ 


  {
#line 3312
  *backref = (_Bool)1;
#line 3313
  return ((char *)begin);
}
}
#line 3320 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
char *dfaexec(struct dfa *d , char const   *begin , char *end , _Bool allow_nl , size_t *count ,
              _Bool *backref ) 
{ 
  char *tmp ;

  {
  {
#line 3324
  tmp = (*(d->dfaexec))(d, begin, end, allow_nl, count, backref);
  }
#line 3324
  return (tmp);
}
}
#line 3327
struct dfa *dfasuperset(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3327 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct dfa *dfasuperset(struct dfa  const  *d ) 
{ 


  {
#line 3330
  return ((struct dfa *)d->superset);
}
}
#line 3333
_Bool dfaisfast(struct dfa  const  *d )  __attribute__((__pure__)) ;
#line 3333 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
_Bool dfaisfast(struct dfa  const  *d ) 
{ 


  {
#line 3336
  return ((_Bool )d->fast);
}
}
#line 3339 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void free_mbdata(struct dfa *d ) 
{ 
  ptrdiff_t i ;
  state_num s ;

  {
  {
#line 3344
  free((void *)d->multibyte_prop);
#line 3346
  i = (ptrdiff_t )0;
  }
  {
#line 3346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3346
    if (! (i < d->nmbcsets)) {
#line 3346
      goto while_break;
    }
    {
#line 3347
    free((void *)(d->mbcsets + i)->chars);
#line 3346
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3349
  free((void *)d->mbcsets);
#line 3350
  free((void *)d->mb_follows.elems);
  }
#line 3352
  if (d->mb_trans) {
#line 3355
    s = (state_num )-1;
    {
#line 3355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3355
      if (! (s < d->tralloc)) {
#line 3355
        goto while_break___0;
      }
      {
#line 3356
      free((void *)*(d->mb_trans + s));
#line 3355
      s ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3357
    free((void *)(d->mb_trans - 2));
    }
  }
#line 3359
  return;
}
}
#line 3362 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static _Bool __attribute__((__pure__))  dfa_supported(struct dfa  const  *d ) 
{ 
  size_t i ;

  {
#line 3366
  i = (size_t )0;
  {
#line 3366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3366
    if (! (i < (size_t )d->tindex)) {
#line 3366
      goto while_break;
    }
    {
#line 3373
    if (*(d->tokens + i) == 263L) {
#line 3373
      goto case_263;
    }
#line 3373
    if (*(d->tokens + i) == 262L) {
#line 3373
      goto case_263;
    }
#line 3373
    if (*(d->tokens + i) == 261L) {
#line 3373
      goto case_263;
    }
#line 3373
    if (*(d->tokens + i) == 260L) {
#line 3373
      goto case_263;
    }
#line 3379
    if (*(d->tokens + i) == 273L) {
#line 3379
      goto case_273;
    }
#line 3379
    if (*(d->tokens + i) == 257L) {
#line 3379
      goto case_273;
    }
#line 3368
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3374
    if (! d->localeinfo.multibyte) {
#line 3375
      goto __Cont;
    }
    case_273: /* CIL Label */ 
    case_257: /* CIL Label */ 
#line 3380
    return ((_Bool __attribute__((__pure__))  )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 3366
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3383
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 3386 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void dfaoptimize(struct dfa *d ) 
{ 
  size_t i ;
  _Bool have_backref ;

  {
#line 3390
  have_backref = (_Bool)0;
#line 3392
  if (! d->localeinfo.using_utf8) {
#line 3393
    return;
  }
#line 3395
  i = (size_t )0;
  {
#line 3395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3395
    if (! (i < d->tindex)) {
#line 3395
      goto while_break;
    }
    {
#line 3399
    if (*(d->tokens + i) == 272L) {
#line 3399
      goto case_272;
    }
#line 3402
    if (*(d->tokens + i) == 257L) {
#line 3402
      goto case_257;
    }
#line 3405
    if (*(d->tokens + i) == 273L) {
#line 3405
      goto case_273;
    }
#line 3408
    goto switch_default;
    case_272: /* CIL Label */ 
    {
#line 3401
    abort();
    }
    case_257: /* CIL Label */ 
#line 3403
    have_backref = (_Bool)1;
#line 3404
    goto switch_break;
    case_273: /* CIL Label */ 
#line 3407
    return;
    switch_default: /* CIL Label */ 
#line 3409
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3395
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3413
  if (! have_backref) {
#line 3413
    if (d->superset) {
      {
#line 3416
      dfafree(d->superset);
#line 3417
      free((void *)d->superset);
#line 3418
      d->superset = (struct dfa *)((void *)0);
      }
    }
  }
  {
#line 3421
  free_mbdata(d);
#line 3422
  d->localeinfo.multibyte = (_Bool)0;
#line 3423
  d->dfaexec = & dfaexec_sb;
#line 3424
  d->fast = (_Bool)1;
  }
#line 3425
  return;
}
}
#line 3427 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void dfassbuild(struct dfa *d ) 
{ 
  size_t i ;
  size_t j ;
  _Bool have_achar ;
  _Bool have_nchar ;
  struct dfa *sup ;
  struct dfa *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  charclass ccl ;
  size_t tmp___2 ;
  ptrdiff_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
  {
#line 3431
  have_achar = (_Bool)0;
#line 3432
  have_nchar = (_Bool)0;
#line 3433
  tmp = dfaalloc();
#line 3433
  sup = tmp;
#line 3435
  *sup = *d;
#line 3436
  sup->localeinfo.multibyte = (_Bool)0;
#line 3437
  sup->dfaexec = & dfaexec_sb;
#line 3438
  sup->multibyte_prop = (int *)((void *)0);
#line 3439
  sup->mbcsets = (struct mb_char_classes *)((void *)0);
#line 3440
  sup->superset = (struct dfa *)((void *)0);
#line 3441
  sup->states = (dfa_state *)((void *)0);
#line 3442
  sup->sindex = (state_num )0;
#line 3443
  sup->follows = (position_set *)((void *)0);
#line 3444
  sup->tralloc = (state_num )0;
#line 3445
  sup->trans = (state_num **)((void *)0);
#line 3446
  sup->fails = (state_num **)((void *)0);
#line 3447
  sup->success = (int *)((void *)0);
#line 3448
  sup->newlines = (state_num *)((void *)0);
#line 3450
  tmp___0 = xnmalloc((size_t )sup->calloc, sizeof(*(sup->charclasses)));
#line 3450
  sup->charclasses = (charclass *)tmp___0;
  }
#line 3451
  if (d->cindex) {
    {
#line 3453
    memcpy((void */* __restrict  */)sup->charclasses, (void const   */* __restrict  */)d->charclasses,
           (unsigned long )d->cindex * sizeof(*(sup->charclasses)));
    }
  }
  {
#line 3457
  tmp___1 = xnmalloc(d->tindex, 2UL * sizeof(*(sup->tokens)));
#line 3457
  sup->tokens = (token *)tmp___1;
#line 3458
  sup->talloc = d->tindex * 2UL;
#line 3460
  j = (size_t )0;
#line 3460
  i = j;
  }
  {
#line 3460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3460
    if (! (i < d->tindex)) {
#line 3460
      goto while_break;
    }
    {
#line 3466
    if (*(d->tokens + i) == 257L) {
#line 3466
      goto case_257;
    }
#line 3466
    if (*(d->tokens + i) == 273L) {
#line 3466
      goto case_257;
    }
#line 3466
    if (*(d->tokens + i) == 272L) {
#line 3466
      goto case_257;
    }
#line 3481
    if (*(d->tokens + i) == 263L) {
#line 3481
      goto case_263;
    }
#line 3481
    if (*(d->tokens + i) == 262L) {
#line 3481
      goto case_263;
    }
#line 3481
    if (*(d->tokens + i) == 261L) {
#line 3481
      goto case_263;
    }
#line 3481
    if (*(d->tokens + i) == 260L) {
#line 3481
      goto case_263;
    }
#line 3490
    goto switch_default;
    case_257: /* CIL Label */ 
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    {
#line 3469
    fillset((charclass_word *)(ccl));
#line 3470
    tmp___2 = j;
#line 3470
    j ++;
#line 3470
    tmp___3 = charclass_index(sup, (charclass_word */* const  */)(ccl));
#line 3470
    *(sup->tokens + tmp___2) = 275L + tmp___3;
#line 3471
    tmp___4 = j;
#line 3471
    j ++;
#line 3471
    *(sup->tokens + tmp___4) = (token )265;
    }
#line 3472
    if (*(d->tokens + (i + 1UL)) == 264L) {
#line 3474
      i ++;
    } else
#line 3472
    if (*(d->tokens + (i + 1UL)) == 265L) {
#line 3474
      i ++;
    } else
#line 3472
    if (*(d->tokens + (i + 1UL)) == 266L) {
#line 3474
      i ++;
    }
#line 3475
    have_achar = (_Bool)1;
#line 3477
    goto switch_break;
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
#line 3482
    if (d->localeinfo.multibyte) {
#line 3486
      tmp___5 = j;
#line 3486
      j ++;
#line 3486
      *(sup->tokens + tmp___5) = (token )256;
#line 3487
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3491
    tmp___6 = j;
#line 3491
    j ++;
#line 3491
    *(sup->tokens + tmp___6) = *(d->tokens + i);
#line 3492
    if (0L <= *(d->tokens + i)) {
#line 3492
      if (*(d->tokens + i) < 256L) {
#line 3494
        have_nchar = (_Bool)1;
      } else {
#line 3492
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3492
    if (*(d->tokens + i) >= 275L) {
#line 3494
      have_nchar = (_Bool)1;
    }
#line 3495
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3460
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3498
  sup->tindex = j;
#line 3500
  if (have_nchar) {
#line 3500
    if (have_achar) {
#line 3501
      d->superset = sup;
    } else
#line 3500
    if (d->localeinfo.multibyte) {
#line 3501
      d->superset = sup;
    } else {
      {
#line 3504
      dfafree(sup);
#line 3505
      free((void *)sup);
      }
    }
  } else {
    {
#line 3504
    dfafree(sup);
#line 3505
    free((void *)sup);
    }
  }
#line 3507
  return;
}
}
#line 3510 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
void dfacomp(char const   *s , size_t len , struct dfa *d , _Bool searchflag ) 
{ 
  _Bool __attribute__((__pure__))  tmp ;

  {
  {
#line 3513
  dfaparse(s, len, d);
#line 3514
  dfassbuild(d);
#line 3516
  tmp = dfa_supported((struct dfa  const  *)d);
  }
#line 3516
  if (tmp) {
    {
#line 3518
    dfaoptimize(d);
#line 3519
    dfaanalyze(d, searchflag);
    }
  } else {
#line 3523
    d->dfaexec = & dfaexec_noop;
  }
#line 3526
  if (d->superset) {
    {
#line 3528
    d->fast = (_Bool)1;
#line 3529
    dfaanalyze(d->superset, searchflag);
    }
  }
#line 3531
  return;
}
}
#line 3534 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
void dfafree(struct dfa *d ) 
{ 
  size_t i ;

  {
  {
#line 3539
  free((void *)d->charclasses);
#line 3540
  free((void *)d->tokens);
  }
#line 3542
  if (d->localeinfo.multibyte) {
    {
#line 3543
    free_mbdata(d);
    }
  }
#line 3545
  i = (size_t )0;
  {
#line 3545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3545
    if (! (i < (size_t )d->sindex)) {
#line 3545
      goto while_break;
    }
    {
#line 3547
    free((void *)(d->states + i)->elems.elems);
#line 3548
    free((void *)(d->states + i)->mbps.elems);
#line 3545
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3550
  free((void *)d->states);
  }
#line 3552
  if (d->follows) {
#line 3554
    i = (size_t )0;
    {
#line 3554
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3554
      if (! (i < d->tindex)) {
#line 3554
        goto while_break___0;
      }
      {
#line 3555
      free((void *)(d->follows + i)->elems);
#line 3554
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3556
    free((void *)d->follows);
    }
  }
#line 3559
  if (d->trans) {
#line 3561
    i = (size_t )0;
    {
#line 3561
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3561
      if (! (i < (size_t )d->tralloc)) {
#line 3561
        goto while_break___1;
      }
      {
#line 3563
      free((void *)*(d->trans + i));
#line 3564
      free((void *)*(d->fails + i));
#line 3561
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3567
    free((void *)(d->trans - 2));
#line 3568
    free((void *)d->fails);
#line 3569
    free((void *)d->newlines);
#line 3570
    free((void *)d->success);
    }
  }
#line 3573
  if (d->superset) {
    {
#line 3574
    dfafree(d->superset);
    }
  }
#line 3575
  return;
}
}
#line 3659 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char *icatalloc(char *old , char const   *new ) 
{ 
  char *result ;
  size_t oldsize ;
  size_t newsize ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 3664
  tmp = strlen(new);
#line 3664
  newsize = tmp;
  }
#line 3665
  if (newsize == 0UL) {
#line 3666
    return (old);
  }
  {
#line 3667
  oldsize = strlen((char const   *)old);
#line 3668
  tmp___0 = xrealloc((void *)old, (oldsize + newsize) + 1UL);
#line 3668
  result = (char *)tmp___0;
#line 3669
  memcpy((void */* __restrict  */)(result + oldsize), (void const   */* __restrict  */)new,
         newsize + 1UL);
  }
#line 3670
  return (result);
}
}
#line 3673 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void freelist(char **cpp ) 
{ 
  char **tmp ;

  {
  {
#line 3676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3676
    if (! *cpp) {
#line 3676
      goto while_break;
    }
    {
#line 3677
    tmp = cpp;
#line 3677
    cpp ++;
#line 3677
    free((void *)*tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3678
  return;
}
}
#line 3680 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char **enlist(char **cpp , char *new , size_t len ) 
{ 
  size_t i ;
  size_t j ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3684
  tmp = xmalloc(len + 1UL);
#line 3684
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)new,
                   len);
#line 3684
  new = (char *)tmp___0;
#line 3685
  *(new + len) = (char )'\000';
#line 3687
  i = (size_t )0;
  }
  {
#line 3687
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3687
    if (! ((unsigned long )*(cpp + i) != (unsigned long )((void *)0))) {
#line 3687
      goto while_break;
    }
    {
#line 3688
    tmp___1 = strstr((char const   *)*(cpp + i), (char const   *)new);
    }
#line 3688
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
      {
#line 3690
      free((void *)new);
      }
#line 3691
      return (cpp);
    }
#line 3687
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3694
  j = (size_t )0;
  {
#line 3695
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3695
    if (! ((unsigned long )*(cpp + j) != (unsigned long )((void *)0))) {
#line 3695
      goto while_break___0;
    }
    {
#line 3696
    tmp___2 = strstr((char const   *)new, (char const   *)*(cpp + j));
    }
#line 3696
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 3697
      j ++;
    } else {
      {
#line 3700
      free((void *)*(cpp + j));
#line 3701
      i --;
      }
#line 3701
      if (i == j) {
#line 3702
        goto while_break___0;
      }
#line 3703
      *(cpp + j) = *(cpp + i);
#line 3704
      *(cpp + i) = (char *)((void *)0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3707
  tmp___3 = xnrealloc((void *)cpp, i + 2UL, sizeof(*cpp));
#line 3707
  cpp = (char **)tmp___3;
#line 3708
  *(cpp + i) = new;
#line 3709
  *(cpp + (i + 1UL)) = (char *)((void *)0);
  }
#line 3710
  return (cpp);
}
}
#line 3715 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char **comsubs(char *left , char const   *right ) 
{ 
  char **cpp ;
  void *tmp ;
  char *lcp ;
  size_t len ;
  char *rcp ;
  char *tmp___0 ;
  size_t i ;

  {
  {
#line 3718
  tmp = xzalloc(sizeof(*cpp));
#line 3718
  cpp = (char **)tmp;
#line 3721
  lcp = left;
  }
  {
#line 3721
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3721
    if (! ((int )*lcp != 0)) {
#line 3721
      goto while_break;
    }
    {
#line 3723
    len = (size_t )0;
#line 3724
    tmp___0 = strchr(right, (int )*lcp);
#line 3724
    rcp = tmp___0;
    }
    {
#line 3725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3725
      if (! ((unsigned long )rcp != (unsigned long )((void *)0))) {
#line 3725
        goto while_break___0;
      }
#line 3728
      i = (size_t )1;
      {
#line 3728
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3728
        if ((int )*(lcp + i) != 0) {
#line 3728
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
#line 3728
            goto while_break___1;
          }
        } else {
#line 3728
          goto while_break___1;
        }
#line 3729
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 3728
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 3730
      if (i > len) {
#line 3731
        len = i;
      }
      {
#line 3732
      rcp = strchr((char const   *)(rcp + 1), (int )*lcp);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3734
    if (len != 0UL) {
      {
#line 3735
      cpp = enlist(cpp, lcp, len);
      }
    }
#line 3721
    lcp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3737
  return (cpp);
}
}
#line 3740 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char **addlists(char **old , char **new ) 
{ 
  size_t tmp ;

  {
  {
#line 3743
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3743
    if (! *new) {
#line 3743
      goto while_break;
    }
    {
#line 3744
    tmp = strlen((char const   *)*new);
#line 3744
    old = enlist(old, *new, tmp);
#line 3743
    new ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3745
  return (old);
}
}
#line 3750 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static char **inboth(char **left , char **right ) 
{ 
  char **both ;
  void *tmp ;
  size_t lnum ;
  size_t rnum ;
  char **temp ;
  char **tmp___0 ;

  {
  {
#line 3753
  tmp = xzalloc(sizeof(*both));
#line 3753
  both = (char **)tmp;
#line 3756
  lnum = (size_t )0;
  }
  {
#line 3756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3756
    if (! ((unsigned long )*(left + lnum) != (unsigned long )((void *)0))) {
#line 3756
      goto while_break;
    }
#line 3758
    rnum = (size_t )0;
    {
#line 3758
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3758
      if (! ((unsigned long )*(right + rnum) != (unsigned long )((void *)0))) {
#line 3758
        goto while_break___0;
      }
      {
#line 3760
      tmp___0 = comsubs(*(left + lnum), (char const   *)*(right + rnum));
#line 3760
      temp = tmp___0;
#line 3761
      both = addlists(both, temp);
#line 3762
      freelist(temp);
#line 3763
      free((void *)temp);
#line 3758
      rnum ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3756
    lnum ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3766
  return (both);
}
}
#line 3782 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static must *allocmust(must *mp , size_t size ) 
{ 
  must *new_mp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3785
  tmp = xmalloc(sizeof(*new_mp));
#line 3785
  new_mp = (must *)tmp;
#line 3786
  tmp___0 = xzalloc(sizeof(*(new_mp->in)));
#line 3786
  new_mp->in = (char **)tmp___0;
#line 3787
  tmp___1 = xzalloc(size);
#line 3787
  new_mp->left = (char *)tmp___1;
#line 3788
  tmp___2 = xzalloc(size);
#line 3788
  new_mp->right = (char *)tmp___2;
#line 3789
  tmp___3 = xzalloc(size);
#line 3789
  new_mp->is = (char *)tmp___3;
#line 3790
  new_mp->begline = (_Bool)0;
#line 3791
  new_mp->endline = (_Bool)0;
#line 3792
  new_mp->prev = mp;
  }
#line 3793
  return (new_mp);
}
}
#line 3796 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void resetmust(must *mp ) 
{ 
  char tmp ;
  char tmp___0 ;

  {
  {
#line 3799
  freelist(mp->in);
#line 3800
  *(mp->in + 0) = (char *)((void *)0);
#line 3801
  tmp___0 = (char )'\000';
#line 3801
  *(mp->is + 0) = tmp___0;
#line 3801
  tmp = tmp___0;
#line 3801
  *(mp->right + 0) = tmp;
#line 3801
  *(mp->left + 0) = tmp;
#line 3802
  mp->begline = (_Bool)0;
#line 3803
  mp->endline = (_Bool)0;
  }
#line 3804
  return;
}
}
#line 3806 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
static void freemust(must *mp ) 
{ 


  {
  {
#line 3809
  freelist(mp->in);
#line 3810
  free((void *)mp->in);
#line 3811
  free((void *)mp->left);
#line 3812
  free((void *)mp->right);
#line 3813
  free((void *)mp->is);
#line 3814
  free((void *)mp);
  }
#line 3815
  return;
}
}
#line 3817 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct dfamust *dfamust(struct dfa  const  *d ) 
{ 
  must *mp ;
  char const   *result ;
  size_t i ;
  size_t ri ;
  _Bool exact ;
  _Bool begline ;
  _Bool endline ;
  size_t rj ;
  _Bool need_begline ;
  _Bool need_endline ;
  _Bool case_fold_unibyte ;
  size_t tmp ;
  int tmp___0 ;
  struct dfamust *dm ;
  token t ;
  char **new ;
  must *rmp ;
  must *lmp ;
  size_t j ;
  size_t ln ;
  size_t rn ;
  size_t n ;
  int tmp___1 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  must *rmp___0 ;
  must *lmp___0 ;
  size_t lrlen ;
  size_t tmp___6 ;
  size_t rllen ;
  size_t tmp___7 ;
  char *tp ;
  void *tmp___8 ;
  charclass *ccl ;
  int j___0 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char tmp___13 ;
  char tmp___14 ;
  int tmp___15 ;
  char tmp___16 ;
  char tmp___17 ;
  int tmp___18 ;
  char tmp___19 ;
  char tmp___20 ;
  void *tmp___21 ;
  must *prev ;

  {
#line 3820
  mp = (must *)((void *)0);
#line 3821
  result = "";
#line 3823
  exact = (_Bool)0;
#line 3824
  begline = (_Bool)0;
#line 3825
  endline = (_Bool)0;
#line 3827
  need_begline = (_Bool)0;
#line 3828
  need_endline = (_Bool)0;
#line 3829
  if (d->syntax.case_fold) {
    {
#line 3829
    tmp = __ctype_get_mb_cur_max();
    }
#line 3829
    if (tmp == 1UL) {
#line 3829
      tmp___0 = 1;
    } else {
#line 3829
      tmp___0 = 0;
    }
  } else {
#line 3829
    tmp___0 = 0;
  }
#line 3829
  case_fold_unibyte = (_Bool )tmp___0;
#line 3832
  ri = (size_t )0;
  {
#line 3832
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3832
    if (! (ri < (size_t )d->tindex)) {
#line 3832
      goto while_break;
    }
#line 3834
    t = *(d->tokens + ri);
    {
#line 3837
    if (t == 258L) {
#line 3837
      goto case_258;
    }
#line 3842
    if (t == 259L) {
#line 3842
      goto case_259;
    }
#line 3848
    if (t == 271L) {
#line 3848
      goto case_271;
    }
#line 3848
    if (t == 270L) {
#line 3848
      goto case_271;
    }
#line 3858
    if (t == 273L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 272L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 257L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 263L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 262L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 261L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 260L) {
#line 3858
      goto case_273;
    }
#line 3858
    if (t == 256L) {
#line 3858
      goto case_273;
    }
#line 3863
    if (t == 264L) {
#line 3863
      goto case_264;
    }
#line 3863
    if (t == 265L) {
#line 3863
      goto case_264;
    }
#line 3867
    if (t == 269L) {
#line 3867
      goto case_269;
    }
#line 3911
    if (t == 266L) {
#line 3911
      goto case_266;
    }
#line 3915
    if (t == -1L) {
#line 3915
      goto case_neg_1;
    }
#line 3930
    if (t == 268L) {
#line 3930
      goto case_268;
    }
#line 3973
    if (t == 0L) {
#line 3973
      goto case_0;
    }
#line 3977
    goto switch_default;
    case_258: /* CIL Label */ 
    {
#line 3838
    mp = allocmust(mp, (size_t )2);
#line 3839
    mp->begline = (_Bool)1;
#line 3840
    need_begline = (_Bool)1;
    }
#line 3841
    goto switch_break;
    case_259: /* CIL Label */ 
    {
#line 3843
    mp = allocmust(mp, (size_t )2);
#line 3844
    mp->endline = (_Bool)1;
#line 3845
    need_endline = (_Bool)1;
    }
#line 3846
    goto switch_break;
    case_271: /* CIL Label */ 
    case_270: /* CIL Label */ 
    {
#line 3849
    __assert_fail("!\"neither LPAREN nor RPAREN may appear here\"", "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c",
                  3849U, "dfamust");
    }
    case_273: /* CIL Label */ 
    case_272: /* CIL Label */ 
    case_257: /* CIL Label */ 
    case_263: /* CIL Label */ 
    case_262: /* CIL Label */ 
    case_261: /* CIL Label */ 
    case_260: /* CIL Label */ 
    case_256: /* CIL Label */ 
    {
#line 3859
    mp = allocmust(mp, (size_t )2);
    }
#line 3860
    goto switch_break;
    case_264: /* CIL Label */ 
    case_265: /* CIL Label */ 
    {
#line 3864
    resetmust(mp);
    }
#line 3865
    goto switch_break;
    case_269: /* CIL Label */ 
    {
#line 3870
    rmp = mp;
#line 3871
    mp = mp->prev;
#line 3871
    lmp = mp;
#line 3875
    tmp___1 = strcmp((char const   *)lmp->is, (char const   *)rmp->is);
    }
#line 3875
    if (tmp___1 == 0) {
#line 3877
      lmp->begline = (_Bool )((int )lmp->begline & (int )rmp->begline);
#line 3878
      lmp->endline = (_Bool )((int )lmp->endline & (int )rmp->endline);
    } else {
#line 3882
      *(lmp->is + 0) = (char )'\000';
#line 3883
      lmp->begline = (_Bool)0;
#line 3884
      lmp->endline = (_Bool)0;
    }
#line 3887
    i = (size_t )0;
    {
#line 3888
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3888
      if ((int )*(lmp->left + i) != 0) {
#line 3888
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
#line 3888
          goto while_break___0;
        }
      } else {
#line 3888
        goto while_break___0;
      }
#line 3889
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3890
    *(lmp->left + i) = (char )'\000';
#line 3892
    ln = strlen((char const   *)lmp->right);
#line 3893
    rn = strlen((char const   *)rmp->right);
#line 3894
    n = ln;
    }
#line 3895
    if (n > rn) {
#line 3896
      n = rn;
    }
#line 3897
    i = (size_t )0;
    {
#line 3897
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3897
      if (! (i < n)) {
#line 3897
        goto while_break___1;
      }
#line 3898
      if ((int )*(lmp->right + ((ln - i) - 1UL)) != (int )*(rmp->right + ((rn - i) - 1UL))) {
#line 3899
        goto while_break___1;
      }
#line 3897
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3900
    j = (size_t )0;
    {
#line 3900
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 3900
      if (! (j < i)) {
#line 3900
        goto while_break___2;
      }
#line 3901
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
#line 3900
      j ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 3902
    *(lmp->right + j) = (char )'\000';
#line 3903
    new = inboth(lmp->in, rmp->in);
#line 3904
    freelist(lmp->in);
#line 3905
    free((void *)lmp->in);
#line 3906
    lmp->in = new;
#line 3907
    freemust(rmp);
    }
#line 3909
    goto switch_break;
    case_266: /* CIL Label */ 
#line 3912
    *(mp->is + 0) = (char )'\000';
#line 3913
    goto switch_break;
    case_neg_1: /* CIL Label */ 
#line 3916
    if (! (! mp->prev)) {
      {
#line 3916
      __assert_fail("!mp->prev", "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c",
                    3916U, "dfamust");
      }
    }
#line 3917
    i = (size_t )0;
    {
#line 3917
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3917
      if (! ((unsigned long )*(mp->in + i) != (unsigned long )((void *)0))) {
#line 3917
        goto while_break___3;
      }
      {
#line 3918
      tmp___3 = strlen((char const   *)*(mp->in + i));
#line 3918
      tmp___4 = strlen(result);
      }
#line 3918
      if (tmp___3 > tmp___4) {
#line 3919
        result = (char const   *)*(mp->in + i);
      }
#line 3917
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 3920
    tmp___5 = strcmp(result, (char const   *)mp->is);
    }
#line 3920
    if (tmp___5 == 0) {
#line 3922
      if (! need_begline) {
#line 3922
        goto _L;
      } else
#line 3922
      if (mp->begline) {
        _L: /* CIL Label */ 
#line 3922
        if (! need_endline) {
#line 3924
          exact = (_Bool)1;
        } else
#line 3922
        if (mp->endline) {
#line 3924
          exact = (_Bool)1;
        }
      }
#line 3925
      begline = mp->begline;
#line 3926
      endline = mp->endline;
    }
#line 3928
    goto done;
    case_268: /* CIL Label */ 
    {
#line 3932
    rmp___0 = mp;
#line 3933
    mp = mp->prev;
#line 3933
    lmp___0 = mp;
#line 3938
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    }
#line 3939
    if ((int )*(lmp___0->right + 0) != 0) {
#line 3939
      if ((int )*(rmp___0->left + 0) != 0) {
        {
#line 3941
        tmp___6 = strlen((char const   *)lmp___0->right);
#line 3941
        lrlen = tmp___6;
#line 3942
        tmp___7 = strlen((char const   *)rmp___0->left);
#line 3942
        rllen = tmp___7;
#line 3943
        tmp___8 = xmalloc(lrlen + rllen);
#line 3943
        tp = (char *)tmp___8;
#line 3944
        memcpy((void */* __restrict  */)tp, (void const   */* __restrict  */)lmp___0->right,
               lrlen);
#line 3945
        memcpy((void */* __restrict  */)(tp + lrlen), (void const   */* __restrict  */)rmp___0->left,
               rllen);
#line 3946
        lmp___0->in = enlist(lmp___0->in, tp, lrlen + rllen);
#line 3947
        free((void *)tp);
        }
      }
    }
#line 3950
    if ((int )*(lmp___0->is + 0) != 0) {
      {
#line 3951
      lmp___0->left = icatalloc(lmp___0->left, (char const   *)rmp___0->left);
      }
    }
#line 3953
    if ((int )*(rmp___0->is + 0) == 0) {
#line 3954
      *(lmp___0->right + 0) = (char )'\000';
    }
    {
#line 3955
    lmp___0->right = icatalloc(lmp___0->right, (char const   *)rmp___0->right);
    }
#line 3957
    if ((int )*(lmp___0->is + 0) != 0) {
#line 3957
      goto _L___0;
    } else
#line 3957
    if (lmp___0->begline) {
      _L___0: /* CIL Label */ 
#line 3957
      if ((int )*(rmp___0->is + 0) != 0) {
        {
#line 3960
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3961
        lmp___0->endline = rmp___0->endline;
        }
      } else
#line 3957
      if (rmp___0->endline) {
        {
#line 3960
        lmp___0->is = icatalloc(lmp___0->is, (char const   *)rmp___0->is);
#line 3961
        lmp___0->endline = rmp___0->endline;
        }
      } else {
#line 3965
        *(lmp___0->is + 0) = (char )'\000';
#line 3966
        lmp___0->begline = (_Bool)0;
#line 3967
        lmp___0->endline = (_Bool)0;
      }
    } else {
#line 3965
      *(lmp___0->is + 0) = (char )'\000';
#line 3966
      lmp___0->begline = (_Bool)0;
#line 3967
      lmp___0->endline = (_Bool)0;
    }
    {
#line 3969
    freemust(rmp___0);
    }
#line 3971
    goto switch_break;
    case_0: /* CIL Label */ 
#line 3975
    goto done;
    switch_default: /* CIL Label */ 
#line 3978
    if (275L <= t) {
#line 3984
      ccl = d->charclasses + (t - 275L);
#line 3986
      j___0 = 0;
      {
#line 3986
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 3986
        if (! (j___0 < 256)) {
#line 3986
          goto while_break___4;
        }
        {
#line 3987
        tmp___9 = tstbit((unsigned int )j___0, (charclass_word */* const  */)(*ccl));
        }
#line 3987
        if (tmp___9) {
#line 3988
          goto while_break___4;
        }
#line 3986
        j___0 ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 3989
      if (! (j___0 < 256)) {
        {
#line 3991
        mp = allocmust(mp, (size_t )2);
        }
#line 3992
        goto switch_break;
      }
#line 3994
      t = (token )j___0;
      {
#line 3995
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 3995
        j___0 ++;
#line 3995
        if (! (j___0 < 256)) {
#line 3995
          goto while_break___5;
        }
        {
#line 3996
        tmp___10 = tstbit((unsigned int )j___0, (charclass_word */* const  */)(*ccl));
        }
#line 3996
        if (tmp___10) {
#line 3996
          if (case_fold_unibyte) {
            {
#line 3996
            tmp___11 = toupper(j___0);
#line 3996
            tmp___12 = toupper((int )t);
            }
#line 3996
            if (! (tmp___11 == tmp___12)) {
#line 3999
              goto while_break___5;
            }
          } else {
#line 3999
            goto while_break___5;
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 4000
      if (j___0 < 256) {
        {
#line 4002
        mp = allocmust(mp, (size_t )2);
        }
#line 4003
        goto switch_break;
      }
    }
#line 4007
    rj = ri + 2UL;
#line 4008
    if (*(d->tokens + (ri + 1UL)) == 268L) {
      {
#line 4010
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 4010
        if (! (rj < (size_t )(d->tindex - 1UL))) {
#line 4010
          goto while_break___6;
        }
#line 4012
        if (rj != ri) {
#line 4012
          if (*(d->tokens + rj) <= 0L) {
#line 4015
            goto while_break___6;
          } else
#line 4012
          if (256L <= *(d->tokens + rj)) {
#line 4015
            goto while_break___6;
          } else {
#line 4012
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 4012
        if (*(d->tokens + (rj + 1UL)) != 268L) {
#line 4015
          goto while_break___6;
        }
#line 4010
        rj += 2UL;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 4018
    mp = allocmust(mp, ((rj - ri) >> 1) + 1UL);
    }
#line 4019
    if (case_fold_unibyte) {
      {
#line 4019
      tmp___15 = toupper((int )t);
#line 4019
      tmp___14 = (char )tmp___15;
      }
    } else {
#line 4019
      tmp___14 = (char )t;
    }
#line 4019
    *(mp->right + 0) = tmp___14;
#line 4019
    tmp___13 = tmp___14;
#line 4019
    *(mp->left + 0) = tmp___13;
#line 4019
    *(mp->is + 0) = tmp___13;
#line 4022
    i = (size_t )1;
    {
#line 4022
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 4022
      if (! (ri + 2UL < rj)) {
#line 4022
        goto while_break___7;
      }
#line 4024
      ri += 2UL;
#line 4025
      t = *(d->tokens + ri);
#line 4026
      if (case_fold_unibyte) {
        {
#line 4026
        tmp___18 = toupper((int )t);
#line 4026
        tmp___17 = (char )tmp___18;
        }
      } else {
#line 4026
        tmp___17 = (char )t;
      }
#line 4026
      *(mp->right + i) = tmp___17;
#line 4026
      tmp___16 = tmp___17;
#line 4026
      *(mp->left + i) = tmp___16;
#line 4026
      *(mp->is + i) = tmp___16;
#line 4022
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 4029
    tmp___20 = (char )'\000';
#line 4029
    *(mp->right + i) = tmp___20;
#line 4029
    tmp___19 = tmp___20;
#line 4029
    *(mp->left + i) = tmp___19;
#line 4029
    *(mp->is + i) = tmp___19;
#line 4030
    mp->in = enlist(mp->in, mp->is, i);
    }
#line 4031
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 3832
    ri ++;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 4036
  dm = (struct dfamust *)((void *)0);
#line 4037
  if (*result) {
    {
#line 4039
    tmp___21 = xmalloc(sizeof(*dm));
#line 4039
    dm = (struct dfamust *)tmp___21;
#line 4040
    dm->exact = exact;
#line 4041
    dm->begline = begline;
#line 4042
    dm->endline = endline;
#line 4043
    dm->must = xstrdup(result);
    }
  }
  {
#line 4046
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 4046
    if (! mp) {
#line 4046
      goto while_break___8;
    }
    {
#line 4048
    prev = mp->prev;
#line 4049
    freemust(mp);
#line 4050
    mp = prev;
    }
  }
  while_break___8: /* CIL Label */ ;
  }
#line 4053
  return (dm);
}
}
#line 4056 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
void dfamustfree(struct dfamust *dm ) 
{ 


  {
  {
#line 4059
  free((void *)dm->must);
#line 4060
  free((void *)dm);
  }
#line 4061
  return;
}
}
#line 4063
struct dfa *dfaalloc(void)  __attribute__((__malloc__)) ;
#line 4063 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
struct dfa *dfaalloc(void) 
{ 
  void *tmp ;

  {
  {
#line 4066
  tmp = xmalloc(sizeof(struct dfa ));
  }
#line 4066
  return ((struct dfa *)tmp);
}
}
#line 4070 "/home/khheo/project/benchmark/sed-4.3/lib/dfa.c"
void dfasyntax(struct dfa *dfa , struct localeinfo  const  *linfo , reg_syntax_t bits ,
               int dfaopts ) 
{ 
  int i ;
  unsigned char uc ;
  char *tmp ;

  {
  {
#line 4075
  memset((void *)dfa, 0, (unsigned long )(& ((struct dfa *)0)->dfaexec));
  }
#line 4076
  if (linfo->multibyte) {
#line 4076
    dfa->dfaexec = & dfaexec_mb;
  } else {
#line 4076
    dfa->dfaexec = & dfaexec_sb;
  }
  {
#line 4077
  dfa->simple_locale = using_simple_locale((_Bool )linfo->multibyte);
#line 4078
  dfa->localeinfo = (struct localeinfo )*linfo;
#line 4080
  dfa->fast = (_Bool )(! dfa->localeinfo.multibyte);
#line 4082
  dfa->canychar = (size_t )-1;
#line 4083
  dfa->lex.cur_mb_len = 1;
#line 4084
  dfa->syntax.syntax_bits_set = (_Bool)1;
#line 4085
  dfa->syntax.case_fold = (_Bool )((bits & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL);
#line 4086
  dfa->syntax.anchor = (_Bool )((dfaopts & 1) != 0);
  }
#line 4087
  if (dfaopts & 2) {
#line 4087
    dfa->syntax.eolbyte = (unsigned char )'\000';
  } else {
#line 4087
    dfa->syntax.eolbyte = (unsigned char )'\n';
  }
#line 4088
  dfa->syntax.syntax_bits = bits;
#line 4090
  i = -128;
  {
#line 4090
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4090
    if (! (i <= 127)) {
#line 4090
      goto while_break;
    }
    {
#line 4092
    uc = (unsigned char )i;
#line 4094
    dfa->syntax.sbit[uc] = char_context((struct dfa  const  *)dfa, uc);
    }
    {
#line 4097
    if (dfa->syntax.sbit[uc] == 2) {
#line 4097
      goto case_2;
    }
#line 4100
    if (dfa->syntax.sbit[uc] == 4) {
#line 4100
      goto case_4;
    }
#line 4095
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 4098
    setbit((unsigned int )uc, (charclass_word *)(dfa->syntax.letters));
    }
#line 4099
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 4101
    setbit((unsigned int )uc, (charclass_word *)(dfa->syntax.newline));
    }
#line 4102
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 4107
    if (dfa->localeinfo.using_utf8) {
#line 4107
      dfa->syntax.never_trail[uc] = (_Bool )(((int )uc & 192) != 128);
    } else {
      {
#line 4107
      tmp = strchr("\n\r./", (int )uc);
#line 4107
      dfa->syntax.never_trail[uc] = (_Bool )((unsigned long )tmp != (unsigned long )((void *)0));
      }
    }
#line 4090
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4111
  return;
}
}
#line 32 "/home/khheo/project/benchmark/sed-4.3/lib/acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 42 "/home/khheo/project/benchmark/sed-4.3/lib/copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 46
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 46
  ret = tmp;
  }
  {
#line 49
  if (ret == -2) {
#line 49
    goto case_neg_2;
  }
#line 53
  if (ret == -1) {
#line 53
    goto case_neg_1;
  }
#line 57
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 50
  tmp___0 = quote(src_name);
#line 50
  tmp___1 = __errno_location();
#line 50
  error(0, *tmp___1, "%s", tmp___0);
  }
#line 51
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 54
  tmp___2 = quote(dst_name);
#line 54
  tmp___3 = gettext("preserving permissions for %s");
#line 54
  tmp___4 = __errno_location();
#line 54
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
  }
#line 55
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 58
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 60
  return (ret);
}
}
#line 28 "/home/khheo/project/benchmark/sed-4.3/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 141 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 2 "/home/khheo/project/benchmark/sed-4.3/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 36 "/home/khheo/project/benchmark/sed-4.3/lib/closeout.c"
static char const   *file_name  ;
#line 40 "/home/khheo/project/benchmark/sed-4.3/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 43
  file_name = file;
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/sed-4.3/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/khheo/project/benchmark/sed-4.3/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/khheo/project/benchmark/sed-4.3/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 109
  tmp___3 = close_stream(stdout);
  }
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
      {
#line 109
      tmp___4 = __errno_location();
      }
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 112
      tmp = gettext("write error");
#line 112
      write_error = (char const   *)tmp;
      }
#line 113
      if (file_name) {
        {
#line 114
        tmp___0 = quotearg_colon(file_name);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
        }
      } else {
        {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
        }
      }
      {
#line 119
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 122
  tmp___5 = close_stream(stderr);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 123
    _exit((int )exit_failure);
    }
  }
#line 124
  return;
}
}
#line 767 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/sed-4.3/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 47 "/home/khheo/project/benchmark/sed-4.3/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/sed-4.3/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 31 "/home/khheo/project/benchmark/sed-4.3/lib/c-ctype.h"
#pragma GCC diagnostic push
#line 31
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 31
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 364
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/sed-4.3/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 66 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 302
#pragma GCC diagnostic pop
#line 478 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.c"
void free_permission_context(struct permission_context *ctx )  __attribute__((__const__)) ;
#line 478 "/home/khheo/project/benchmark/sed-4.3/lib/acl-internal.c"
void free_permission_context(struct permission_context *ctx ) 
{ 


  {
#line 507
  return;
}
}
#line 27 "./lib/acl.h"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/sed-4.3/lib/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum ) 
{ 


  {
  {
#line 36
  if (errnum == 16) {
#line 36
    goto case_16;
  }
#line 37
  if (errnum == 22) {
#line 37
    goto case_22;
  }
#line 41
  if (errnum == 38) {
#line 41
    goto case_38;
  }
#line 49
  if (errnum == 95) {
#line 49
    goto case_95;
  }
#line 50
  goto switch_default;
  case_16: /* CIL Label */ 
#line 36
  return ((_Bool)0);
  case_22: /* CIL Label */ 
#line 37
  return ((_Bool)0);
  case_38: /* CIL Label */ 
#line 41
  return ((_Bool)0);
  case_95: /* CIL Label */ 
#line 49
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 50
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 2 "/home/khheo/project/benchmark/sed-4.3/sed/version.c"
char const   *Version  =    "4.3";
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 146
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 213
extern int fflush_unlocked(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 320
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 327
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 545
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 606
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 673
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 765
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr_unlocked)(FILE *__stream ) ;
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 739 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkostemp)(char *__template , int __flags ) ;
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 811 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 141 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 61 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ngettext)(char const   *__msgid1 ,
                                                                                 char const   *__msgid2 ,
                                                                                 unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 30 "/home/khheo/project/benchmark/sed-4.3/sed/utils.h"
 __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *str 
                                                                     , ...) ;
#line 32
FILE *ck_fopen(char const   *name , char const   *mode , int fail ) ;
#line 33
FILE *ck_fdopen(int fd , char const   *name , char const   *mode , int fail ) ;
#line 34
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 35
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) ;
#line 36
void ck_fflush(FILE *stream ) ;
#line 37
void ck_fclose(FILE *stream ) ;
#line 38
char const   *follow_symlink(char const   *fname ) ;
#line 39
size_t ck_getdelim(char **text , size_t *buflen , char buffer_delimiter___0 , FILE *stream ) ;
#line 41
FILE *( __attribute__((__nonnull__(1,2,3,4))) ck_mkstemp)(char **p_filename , char const   *tmpdir ,
                                                          char const   *base , char const   *mode ) ;
#line 43
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) ;
#line 45
void *ck_malloc(size_t size ) ;
#line 47
void *ck_realloc(void *ptr , size_t size ) ;
#line 48
char *ck_strdup(char const   *str ) ;
#line 49
void *ck_memdup(void const   *buf , size_t len ) ;
#line 51
struct buffer *init_buffer(void) ;
#line 52
char *get_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 53
size_t size_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 54
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) ;
#line 55
char *add1_buffer(struct buffer *b___0 , int c ) ;
#line 56
void free_buffer(struct buffer *b___0 ) ;
#line 58 "/home/khheo/project/benchmark/sed-4.3/sed/utils.h"
char const   *myname  ;
#line 56 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fwriting)(FILE *__fp ) ;
#line 48 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static struct open_file *open_files  =    (struct open_file *)((void *)0);
#line 49
static void do_ck_fclose(FILE *fp ) ;
#line 53
 __attribute__((__noreturn__)) void ( /* format attribute */  panic)(char const   *str 
                                                                     , ...) ;
#line 53 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void ( /* format attribute */  panic)(char const   *str  , ...) 
{ 
  va_list ap ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          myname);
#line 59
  __builtin_va_start(ap, str);
#line 60
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)str,
           ap);
#line 61
  __builtin_va_end(ap);
#line 62
  putc_unlocked('\n', stderr);
  }
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! open_files) {
#line 65
      goto while_break;
    }
#line 67
    if (open_files->temp) {
      {
#line 69
      fclose(open_files->fp);
#line 70
      tmp = __errno_location();
#line 70
      *tmp = 0;
#line 71
      unlink((char const   *)open_files->name);
#line 72
      tmp___3 = __errno_location();
      }
#line 72
      if (*tmp___3 != 0) {
        {
#line 73
        tmp___0 = __errno_location();
#line 73
        tmp___1 = strerror(*tmp___0);
#line 73
        tmp___2 = gettext("cannot remove %s: %s");
#line 73
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2,
                open_files->name, tmp___1);
        }
      }
    }
#line 77
    open_files = open_files->link;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 80
  exit(4);
  }
}
}
#line 85 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static char const   * __attribute__((__pure__)) utils_fp_name(FILE *fp ) 
{ 
  struct open_file *p ;

  {
#line 90
  p = open_files;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    if (! p) {
#line 90
      goto while_break;
    }
#line 91
    if ((unsigned long )p->fp == (unsigned long )fp) {
#line 92
      return ((char const   */* __attribute__((__pure__)) */)p->name);
    }
#line 90
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if ((unsigned long )fp == (unsigned long )stdin) {
#line 94
    return ((char const   */* __attribute__((__pure__)) */)"stdin");
  } else
#line 95
  if ((unsigned long )fp == (unsigned long )stdout) {
#line 96
    return ((char const   */* __attribute__((__pure__)) */)"stdout");
  } else
#line 97
  if ((unsigned long )fp == (unsigned long )stderr) {
#line 98
    return ((char const   */* __attribute__((__pure__)) */)"stderr");
  }
#line 100
  return ((char const   */* __attribute__((__pure__)) */)"<unknown>");
}
}
#line 103 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static void register_open_file(FILE *fp , char const   *name ) 
{ 
  struct open_file *p ;
  void *tmp ;

  {
#line 107
  p = open_files;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! p) {
#line 107
      goto while_break;
    }
#line 109
    if ((unsigned long )fp == (unsigned long )p->fp) {
      {
#line 111
      free((void *)p->name);
      }
#line 112
      goto while_break;
    }
#line 107
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if (! p) {
    {
#line 117
    tmp = ck_malloc(sizeof(struct open_file ));
#line 117
    p = (struct open_file *)tmp;
#line 118
    p->link = open_files;
#line 119
    open_files = p;
    }
  }
  {
#line 121
  p->name = ck_strdup(name);
#line 122
  p->fp = fp;
#line 123
  p->temp = 0U;
  }
#line 124
  return;
}
}
#line 127 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
FILE *ck_fopen(char const   *name , char const   *mode , int fail ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 132
  fp = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)mode);
  }
#line 133
  if (! fp) {
#line 135
    if (fail) {
      {
#line 136
      tmp = __errno_location();
#line 136
      tmp___0 = strerror(*tmp);
#line 136
      tmp___1 = gettext("couldn\'t open file %s: %s");
#line 136
      panic((char const   *)tmp___1, name, tmp___0);
      }
    }
#line 138
    return ((FILE *)((void *)0));
  }
  {
#line 141
  register_open_file(fp, name);
  }
#line 142
  return (fp);
}
}
#line 146 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
FILE *ck_fdopen(int fd , char const   *name , char const   *mode , int fail ) 
{ 
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 151
  fp = fdopen(fd, mode);
  }
#line 152
  if (! fp) {
#line 154
    if (fail) {
      {
#line 155
      tmp = __errno_location();
#line 155
      tmp___0 = strerror(*tmp);
#line 155
      tmp___1 = gettext("couldn\'t attach to %s: %s");
#line 155
      panic((char const   *)tmp___1, name, tmp___0);
      }
    }
#line 157
    return ((FILE *)((void *)0));
  }
  {
#line 160
  register_open_file(fp, name);
  }
#line 161
  return (fp);
}
}
#line 164 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
FILE *( __attribute__((__nonnull__(1,2,3,4))) ck_mkstemp)(char **p_filename , char const   *tmpdir ,
                                                          char const   *base , char const   *mode ) 
{ 
  char *template ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  mode_t save_umask ;
  __mode_t tmp___2 ;
  int fd ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  FILE *fp ;
  FILE *tmp___7 ;

  {
  {
#line 168
  tmp = strlen(tmpdir);
#line 168
  tmp___0 = strlen(base);
#line 168
  tmp___1 = xmalloc((tmp + tmp___0) + 8UL);
#line 168
  template = (char *)tmp___1;
#line 169
  sprintf((char */* __restrict  */)template, (char const   */* __restrict  */)"%s/%sXXXXXX",
          tmpdir, base);
#line 174
  tmp___2 = umask((__mode_t )448);
#line 174
  save_umask = tmp___2;
#line 175
  tmp___3 = mkostemp(template, 0);
#line 175
  fd = tmp___3;
#line 176
  umask(save_umask);
  }
#line 177
  if (fd == -1) {
    {
#line 178
    tmp___4 = __errno_location();
#line 178
    tmp___5 = strerror(*tmp___4);
#line 178
    tmp___6 = gettext("couldn\'t open temporary file %s: %s");
#line 178
    panic((char const   *)tmp___6, template, tmp___5);
    }
  }
  {
#line 180
  *p_filename = template;
#line 181
  tmp___7 = fdopen(fd, mode);
#line 181
  fp = tmp___7;
#line 182
  register_open_file(fp, (char const   *)template);
  }
#line 183
  return (fp);
}
}
#line 187 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void ck_fwrite(void const   *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   * __attribute__((__pure__)) tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 190
  clearerr_unlocked(stream);
  }
#line 191
  if (size) {
    {
#line 191
    tmp___3 = fwrite_unlocked((void const   */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 191
    if (tmp___3 != nmemb) {
      {
#line 192
      tmp = __errno_location();
#line 192
      tmp___0 = strerror(*tmp);
#line 192
      tmp___1 = utils_fp_name(stream);
#line 192
      tmp___2 = ngettext("couldn\'t write %llu item to %s: %s", "couldn\'t write %llu items to %s: %s",
                         nmemb);
#line 192
      panic((char const   *)tmp___2, (unsigned long long )nmemb, tmp___1, tmp___0);
      }
    }
  }
#line 196
  return;
}
}
#line 199 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
size_t ck_fread(void *ptr , size_t size , size_t nmemb , FILE *stream ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   * __attribute__((__pure__)) tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 202
  clearerr_unlocked(stream);
  }
#line 203
  if (size) {
    {
#line 203
    nmemb = fread_unlocked((void */* __restrict  */)ptr, size, nmemb, (FILE */* __restrict  */)stream);
    }
#line 203
    if (nmemb <= 0UL) {
      {
#line 203
      tmp___3 = ferror_unlocked(stream);
      }
#line 203
      if (tmp___3) {
        {
#line 204
        tmp = __errno_location();
#line 204
        tmp___0 = strerror(*tmp);
#line 204
        tmp___1 = utils_fp_name(stream);
#line 204
        tmp___2 = gettext("read error on %s: %s");
#line 204
        panic((char const   *)tmp___2, tmp___1, tmp___0);
        }
      }
    }
  }
#line 206
  return (nmemb);
}
}
#line 209 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
size_t ck_getdelim(char **text , size_t *buflen , char buffer_delimiter___0 , FILE *stream ) 
{ 
  ssize_t result ;
  _Bool error___0 ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char const   * __attribute__((__pure__)) tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 215
  tmp = ferror_unlocked(stream);
#line 215
  error___0 = (_Bool )tmp;
  }
#line 216
  if (! error___0) {
    {
#line 218
    result = getdelim((char **/* __restrict  */)text, (size_t */* __restrict  */)buflen,
                      (int )buffer_delimiter___0, (FILE */* __restrict  */)stream);
#line 219
    tmp___0 = ferror_unlocked(stream);
#line 219
    error___0 = (_Bool )tmp___0;
    }
  }
#line 222
  if (error___0) {
    {
#line 223
    tmp___1 = __errno_location();
#line 223
    tmp___2 = strerror(*tmp___1);
#line 223
    tmp___3 = utils_fp_name(stream);
#line 223
    tmp___4 = gettext("read error on %s: %s");
#line 223
    panic((char const   *)tmp___4, tmp___3, tmp___2);
    }
  }
#line 225
  return ((size_t )result);
}
}
#line 229 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void ck_fflush(FILE *stream ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 232
  tmp = __fwriting(stream);
  }
#line 232
  if (! (tmp != 0)) {
#line 233
    return;
  }
  {
#line 235
  clearerr_unlocked(stream);
#line 236
  tmp___3 = fflush_unlocked(stream);
  }
#line 236
  if (tmp___3 == -1) {
    {
#line 236
    tmp___4 = __errno_location();
    }
#line 236
    if (*tmp___4 != 9) {
      {
#line 237
      tmp___0 = __errno_location();
#line 237
      tmp___1 = strerror(*tmp___0);
#line 237
      tmp___2 = utils_fp_name(stream);
#line 237
      panic("couldn\'t flush %s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 238
  return;
}
}
#line 241 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void ck_fclose(FILE *stream ) 
{ 
  struct open_file r ;
  struct open_file *prev ;
  struct open_file *cur ;

  {
#line 249
  r.link = open_files;
#line 250
  prev = & r;
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
#line 251
    cur = prev->link;
#line 251
    if (! cur) {
#line 251
      goto while_break;
    }
#line 253
    if (! stream) {
      {
#line 255
      do_ck_fclose(cur->fp);
#line 256
      prev->link = cur->link;
#line 257
      free((void *)cur->name);
#line 258
      free((void *)cur);
      }
    } else
#line 253
    if ((unsigned long )stream == (unsigned long )cur->fp) {
      {
#line 255
      do_ck_fclose(cur->fp);
#line 256
      prev->link = cur->link;
#line 257
      free((void *)cur->name);
#line 258
      free((void *)cur);
      }
    } else {
#line 261
      prev = cur;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  open_files = r.link;
#line 269
  if (! stream) {
    {
#line 271
    do_ck_fclose(stdout);
#line 272
    do_ck_fclose(stderr);
    }
  }
#line 274
  return;
}
}
#line 277 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static void do_ck_fclose(FILE *fp ) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char const   * __attribute__((__pure__)) tmp___1 ;
  int tmp___2 ;

  {
  {
#line 280
  ck_fflush(fp);
#line 281
  clearerr_unlocked(fp);
#line 283
  tmp___2 = fclose(fp);
  }
#line 283
  if (tmp___2 == -1) {
    {
#line 284
    tmp = __errno_location();
#line 284
    tmp___0 = strerror(*tmp);
#line 284
    tmp___1 = utils_fp_name(fp);
#line 284
    panic("couldn\'t close %s: %s", tmp___1, tmp___0);
    }
  }
#line 285
  return;
}
}
#line 295 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static char *buf1  ;
#line 295 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static char *buf2  ;
#line 296 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static int buf_size  ;
#line 291 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
char const   *follow_symlink(char const   *fname ) 
{ 
  struct stat statbuf ;
  char const   *buf ;
  char const   *c ;
  int rc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int len ;
  void *tmp___7 ;
  void *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;

  {
#line 299
  buf = fname;
#line 302
  if (buf_size == 0) {
    {
#line 304
    tmp = ck_malloc((size_t )4097);
#line 304
    buf1 = (char *)tmp;
#line 305
    tmp___0 = ck_malloc((size_t )4097);
#line 305
    buf2 = (char *)tmp___0;
#line 306
    buf_size = 4097;
    }
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 309
    rc = lstat((char const   */* __restrict  */)buf, (struct stat */* __restrict  */)(& statbuf));
    }
#line 309
    if (rc == 0) {
#line 309
      if (! ((statbuf.st_mode & 40960U) == 40960U)) {
#line 309
        goto while_break;
      }
    } else {
#line 309
      goto while_break;
    }
#line 312
    if ((unsigned long )buf == (unsigned long )buf2) {
      {
#line 314
      strcpy((char */* __restrict  */)buf1, (char const   */* __restrict  */)buf2);
#line 315
      buf = (char const   *)buf1;
      }
    }
    {
#line 318
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 318
      tmp___3 = readlink((char const   */* __restrict  */)buf, (char */* __restrict  */)buf2,
                         (size_t )buf_size);
#line 318
      rc = (int )tmp___3;
      }
#line 318
      if (! (rc == buf_size)) {
#line 318
        goto while_break___0;
      }
      {
#line 320
      buf_size *= 2;
#line 321
      tmp___1 = ck_realloc((void *)buf1, (size_t )buf_size);
#line 321
      buf1 = (char *)tmp___1;
#line 322
      tmp___2 = ck_realloc((void *)buf2, (size_t )buf_size);
#line 322
      buf2 = (char *)tmp___2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 324
    if (rc < 0) {
      {
#line 325
      tmp___4 = __errno_location();
#line 325
      tmp___5 = strerror(*tmp___4);
#line 325
      tmp___6 = gettext("couldn\'t follow symlink %s: %s");
#line 325
      panic((char const   *)tmp___6, buf, tmp___5);
      }
    } else {
#line 327
      *(buf2 + rc) = (char )'\000';
    }
#line 329
    if ((int )*(buf2 + 0) != 47) {
      {
#line 329
      tmp___9 = strrchr(buf, '/');
#line 329
      c = (char const   *)tmp___9;
      }
#line 329
      if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 333
        len = (int )((c - buf) + 1L);
#line 334
        if ((len + rc) + 1 > buf_size) {
          {
#line 336
          buf_size = (len + rc) + 1;
#line 337
          tmp___7 = ck_realloc((void *)buf1, (size_t )buf_size);
#line 337
          buf1 = (char *)tmp___7;
#line 338
          tmp___8 = ck_realloc((void *)buf2, (size_t )buf_size);
#line 338
          buf2 = (char *)tmp___8;
          }
        }
#line 342
        if ((unsigned long )buf != (unsigned long )buf1) {
          {
#line 343
          memcpy((void */* __restrict  */)buf1, (void const   */* __restrict  */)buf,
                 (size_t )len);
          }
        }
        {
#line 346
        memcpy((void */* __restrict  */)(buf1 + len), (void const   */* __restrict  */)buf2,
               (size_t )(rc + 1));
#line 347
        buf = (char const   *)buf1;
        }
      } else {
#line 354
        buf = (char const   *)buf2;
      }
    } else {
#line 354
      buf = (char const   *)buf2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  if (rc < 0) {
    {
#line 359
    tmp___10 = __errno_location();
#line 359
    tmp___11 = strerror(*tmp___10);
#line 359
    tmp___12 = gettext("cannot stat %s: %s");
#line 359
    panic((char const   *)tmp___12, buf, tmp___11);
    }
  }
#line 361
  return (buf);
}
}
#line 368 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void ck_rename(char const   *from , char const   *to , char const   *unlink_if_fail ) 
{ 
  int rd ;
  int tmp ;
  int save_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 371
  tmp = rename(from, to);
#line 371
  rd = tmp;
  }
#line 372
  if (rd != -1) {
#line 373
    return;
  }
#line 375
  if (unlink_if_fail) {
    {
#line 377
    tmp___0 = __errno_location();
#line 377
    save_errno = *tmp___0;
#line 378
    tmp___1 = __errno_location();
#line 378
    *tmp___1 = 0;
#line 379
    unlink(unlink_if_fail);
#line 383
    tmp___5 = __errno_location();
    }
#line 383
    if (*tmp___5 != 0) {
      {
#line 384
      tmp___2 = __errno_location();
#line 384
      tmp___3 = strerror(*tmp___2);
#line 384
      tmp___4 = gettext("cannot remove %s: %s");
#line 384
      panic((char const   *)tmp___4, unlink_if_fail, tmp___3);
      }
    }
    {
#line 386
    tmp___6 = __errno_location();
#line 386
    *tmp___6 = save_errno;
    }
  }
  {
#line 389
  tmp___7 = __errno_location();
#line 389
  tmp___8 = strerror(*tmp___7);
#line 389
  tmp___9 = gettext("cannot rename %s: %s");
#line 389
  panic((char const   *)tmp___9, from, tmp___8);
  }
}
}
#line 396 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void *ck_malloc(size_t size ) 
{ 
  void *ret ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 399
  if (size) {
#line 399
    tmp = size;
  } else {
#line 399
    tmp = (size_t )1;
  }
  {
#line 399
  tmp___0 = calloc((size_t )1, tmp);
#line 399
  ret = tmp___0;
  }
#line 400
  if (! ret) {
    {
#line 401
    panic("couldn\'t allocate memory");
    }
  }
#line 402
  return (ret);
}
}
#line 406 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void *ck_realloc(void *ptr , size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 411
  if (size == 0UL) {
    {
#line 413
    free(ptr);
    }
#line 414
    return ((void *)0);
  }
#line 416
  if (! ptr) {
    {
#line 417
    tmp = ck_malloc(size);
    }
#line 417
    return (tmp);
  }
  {
#line 418
  ret = realloc(ptr, size);
  }
#line 419
  if (! ret) {
    {
#line 420
    panic("couldn\'t re-allocate memory");
    }
  }
#line 421
  return (ret);
}
}
#line 425 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
char *ck_strdup(char const   *str ) 
{ 
  char *ret ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 428
  tmp = strlen(str);
#line 428
  tmp___0 = ck_malloc((tmp + 1UL) * sizeof(char ));
#line 428
  ret = (char *)tmp___0;
#line 429
  tmp___1 = strcpy((char */* __restrict  */)ret, (char const   */* __restrict  */)str);
  }
#line 429
  return (tmp___1);
}
}
#line 433 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void *ck_memdup(void const   *buf , size_t len ) 
{ 
  void *ret ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 436
  tmp = ck_malloc(len);
#line 436
  ret = tmp;
#line 437
  tmp___0 = memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)buf,
                   len);
  }
#line 437
  return (tmp___0);
}
}
#line 453 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
struct buffer *init_buffer(void) 
{ 
  struct buffer *b___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 456
  tmp = ck_malloc(sizeof(struct buffer ));
#line 456
  b___0 = (struct buffer *)tmp;
#line 457
  tmp___0 = ck_malloc(50UL * sizeof(char ));
#line 457
  b___0->b = (char *)tmp___0;
#line 458
  b___0->allocated = (size_t )50;
#line 459
  b___0->length = (size_t )0;
  }
#line 460
  return (b___0);
}
}
#line 463
char *get_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 463 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
char *get_buffer(struct buffer  const  *b___0 ) 
{ 


  {
#line 466
  return ((char *)b___0->b);
}
}
#line 469
size_t size_buffer(struct buffer  const  *b___0 )  __attribute__((__pure__)) ;
#line 469 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
size_t size_buffer(struct buffer  const  *b___0 ) 
{ 


  {
#line 472
  return ((size_t )b___0->length);
}
}
#line 475 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
static void resize_buffer(struct buffer *b___0 , size_t newlen ) 
{ 
  char *try ;
  size_t alen ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 478
  try = (char *)((void *)0);
#line 479
  alen = b___0->allocated;
#line 481
  if (newlen <= alen) {
#line 482
    return;
  }
#line 483
  alen *= 2UL;
#line 484
  if (newlen < alen) {
    {
#line 485
    tmp = realloc((void *)b___0->b, alen);
#line 485
    try = (char *)tmp;
    }
  }
#line 486
  if (! try) {
    {
#line 488
    alen = newlen;
#line 489
    tmp___0 = ck_realloc((void *)b___0->b, alen * sizeof(char ));
#line 489
    try = (char *)tmp___0;
    }
  }
#line 491
  b___0->allocated = alen;
#line 492
  b___0->b = try;
#line 493
  return;
}
}
#line 495 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
char *add_buffer(struct buffer *b___0 , char const   *p , size_t n ) 
{ 
  char *result ;
  void *tmp ;

  {
#line 499
  if (b___0->allocated - b___0->length < n) {
    {
#line 500
    resize_buffer(b___0, b___0->length + n);
    }
  }
  {
#line 501
  tmp = memcpy((void */* __restrict  */)(b___0->b + b___0->length), (void const   */* __restrict  */)p,
               n);
#line 501
  result = (char *)tmp;
#line 502
  b___0->length += n;
  }
#line 503
  return (result);
}
}
#line 506 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
char *add1_buffer(struct buffer *b___0 , int c ) 
{ 
  char *result ;
  size_t tmp ;

  {
#line 515
  if (c != -1) {
#line 518
    if (b___0->allocated - b___0->length < 1UL) {
      {
#line 519
      resize_buffer(b___0, b___0->length + 1UL);
      }
    }
#line 520
    tmp = b___0->length;
#line 520
    (b___0->length) ++;
#line 520
    result = b___0->b + tmp;
#line 521
    *result = (char )c;
#line 522
    return (result);
  }
#line 525
  return ((char *)((void *)0));
}
}
#line 528 "/home/khheo/project/benchmark/sed-4.3/sed/utils.c"
void free_buffer(struct buffer *b___0 ) 
{ 


  {
#line 531
  if (b___0) {
    {
#line 532
    free((void *)b___0->b);
    }
  }
  {
#line 533
  free((void *)b___0);
  }
#line 534
  return;
}
}
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 190 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) ;
#line 191
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) ;
#line 192
void check_final_program(struct vector *program ) ;
#line 194
void finish_program(void) ;
#line 204
int process_files(struct vector *the_program___0 , char **argv ) ;
#line 206
int main(int argc , char **argv ) ;
#line 208 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
struct localeinfo localeinfo  ;
#line 210
int extended_regexp_flags ;
#line 213
char buffer_delimiter ;
#line 217
_Bool unbuffered ;
#line 220
_Bool no_default_output ;
#line 223
_Bool separate_files ;
#line 226
_Bool follow_symlinks ;
#line 229 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
enum posixicity_types posixicity  ;
#line 232
countT lcmd_out_line_len ;
#line 235
char *in_place_extension ;
#line 238
char const   *read_mode ;
#line 239
char const   *write_mode ;
#line 249
_Bool sandbox ;
#line 271
void initialize_mbcs(void) ;
#line 272
void register_cleanup_file(char const   *file ) ;
#line 273
void cancel_cleanup(void) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 592
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern char *optarg ;
#line 50
extern int optind ;
#line 141 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 40 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
int extended_regexp_flags  =    0;
#line 43 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
char buffer_delimiter  =    (char )'\n';
#line 46 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
_Bool unbuffered  =    (_Bool)0;
#line 49 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
_Bool no_default_output  =    (_Bool)0;
#line 52 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
_Bool separate_files  =    (_Bool)0;
#line 55 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
_Bool follow_symlinks  =    (_Bool)0;
#line 58 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
_Bool sandbox  =    (_Bool)0;
#line 61 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
char *in_place_extension  =    (char *)((void *)0);
#line 64 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
char const   *read_mode  =    "r";
#line 65 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
char const   *write_mode  =    "w";
#line 71 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
countT lcmd_out_line_len  =    (countT )70;
#line 74 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
static struct vector *the_program  =    (struct vector *)((void *)0);
#line 80 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
static char const   *G_file_to_unlink  ;
#line 86 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
static void cleanup(void) 
{ 


  {
#line 89
  if (G_file_to_unlink) {
    {
#line 90
    unlink(G_file_to_unlink);
    }
  }
#line 91
  return;
}
}
#line 94 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
void register_cleanup_file(char const   *file ) 
{ 


  {
#line 97
  G_file_to_unlink = file;
#line 98
  return;
}
}
#line 101 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
void cancel_cleanup(void) 
{ 


  {
#line 104
  G_file_to_unlink = (char const   *)((void *)0);
#line 105
  return;
}
}
#line 107
static  __attribute__((__noreturn__)) void usage(int status ) ;
#line 108 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
static void contact(int errmsg ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 111
  if (errmsg) {
#line 111
    tmp = stderr;
  } else {
#line 111
    tmp = stdout;
  }
  {
#line 111
  out = tmp;
#line 113
  tmp___0 = gettext("GNU sed home page: <http://www.gnu.org/software/sed/>.\nGeneral help using GNU software: <http://www.gnu.org/gethelp/>.\n");
#line 113
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0);
  }
#line 119
  if (! errmsg) {
    {
#line 120
    tmp___1 = gettext("E-mail bug reports to: <%s>.\n");
#line 120
    fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1,
            "bug-sed@gnu.org");
    }
  }
#line 121
  return;
}
}
#line 123
static  __attribute__((__noreturn__)) void usage(int status ) ;
#line 123 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
static void usage(int status ) 
{ 
  FILE *out ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;

  {
#line 126
  if (status) {
#line 126
    tmp = stderr;
  } else {
#line 126
    tmp = stdout;
  }
  {
#line 126
  out = tmp;
#line 134
  tmp___0 = gettext("Usage: %s [OPTION]... {script-only-if-no-other-script} [input-file]...\n\n");
#line 134
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___0,
          myname);
#line 138
  tmp___1 = gettext("  -n, --quiet, --silent\n                 suppress automatic printing of pattern space\n");
#line 138
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___1);
#line 140
  tmp___2 = gettext("  -e script, --expression=script\n                 add the script to the commands to be executed\n");
#line 140
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___2);
#line 142
  tmp___3 = gettext("  -f script-file, --file=script-file\n                 add the contents of script-file to the commands to be executed\n");
#line 142
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___3);
#line 146
  tmp___4 = gettext("  --follow-symlinks\n                 follow symlinks when processing in place\n");
#line 146
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___4);
#line 149
  tmp___5 = gettext("  -i[SUFFIX], --in-place[=SUFFIX]\n                 edit files in place (makes backup if SUFFIX supplied)\n");
#line 149
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___5);
#line 157
  tmp___6 = gettext("  -l N, --line-length=N\n                 specify the desired line-wrap length for the `l\' command\n");
#line 157
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___6);
#line 159
  tmp___7 = gettext("  --posix\n                 disable all GNU extensions.\n");
#line 159
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___7);
#line 161
  tmp___8 = gettext("  -E, -r, --regexp-extended\n                 use extended regular expressions in the script\n                 (for portability use POSIX -E).\n");
#line 161
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___8);
#line 167
  tmp___9 = gettext("  -s, --separate\n                 consider files as separate rather than as a single,\n                 continuous long stream.\n");
#line 167
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___9);
#line 170
  tmp___10 = gettext("      --sandbox\n                 operate in sandbox mode.\n");
#line 170
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___10);
#line 172
  tmp___11 = gettext("  -u, --unbuffered\n                 load minimal amounts of data from the input files and flush\n                 the output buffers more often\n");
#line 172
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___11);
#line 175
  tmp___12 = gettext("  -z, --null-data\n                 separate lines by NUL characters\n");
#line 175
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___12);
#line 177
  tmp___13 = gettext("      --help     display this help and exit\n");
#line 177
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___13);
#line 178
  tmp___14 = gettext("      --version  output version information and exit\n");
#line 178
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___14);
#line 179
  tmp___15 = gettext("\nIf no -e, --expression, -f, or --file option is given, then the first\nnon-option argument is taken as the sed script to interpret.  All\nremaining arguments are names of input files; if no input files are\nspecified, then the standard input is read.\n\n");
#line 179
  fprintf((FILE */* __restrict  */)out, (char const   */* __restrict  */)tmp___15);
#line 185
  contact(status);
#line 187
  ck_fclose((FILE *)((void *)0));
#line 188
  exit(status);
  }
}
}
#line 202 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
static struct option  const  longopts[18]  = 
#line 202
  {      {"binary", 0, (int *)((void *)0), 'b'}, 
        {"regexp-extended", 0, (int *)((void *)0), 'r'}, 
        {"expression", 1, (int *)((void *)0), 'e'}, 
        {"file", 1, (int *)((void *)0), 'f'}, 
        {"in-place", 2, (int *)((void *)0), 'i'}, 
        {"line-length", 1, (int *)((void *)0), 'l'}, 
        {"null-data", 0, (int *)((void *)0), 'z'}, 
        {"zero-terminated", 0, (int *)((void *)0), 'z'}, 
        {"quiet", 0, (int *)((void *)0), 'n'}, 
        {"posix", 0, (int *)((void *)0), 'p'}, 
        {"silent", 0, (int *)((void *)0), 'n'}, 
        {"sandbox", 0, (int *)((void *)0), 128}, 
        {"separate", 0, (int *)((void *)0), 's'}, 
        {"unbuffered", 0, (int *)((void *)0), 'u'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"follow-symlinks", 0, (int *)((void *)0), 'F'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 191 "/home/khheo/project/benchmark/sed-4.3/sed/sed.c"
int main(int argc , char **argv ) 
{ 
  int opt ;
  int return_code ;
  char const   *cols ;
  char *tmp ;
  char *tmp___0 ;
  countT t ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *arg ;
  int tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 230
  tmp = getenv("COLS");
#line 230
  cols = (char const   *)tmp;
#line 232
  program_name = (char const   *)*(argv + 0);
#line 236
  setlocale(6, "");
#line 238
  set_program_name((char const   *)*(argv + 0));
#line 239
  initialize_mbcs();
#line 240
  init_localeinfo(& localeinfo);
#line 244
  atexit(& cleanup);
#line 249
  bindtextdomain("sed", "/usr/local/share/locale");
#line 250
  textdomain("sed");
#line 253
  tmp___0 = getenv("POSIXLY_CORRECT");
  }
#line 253
  if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 254
    posixicity = (enum posixicity_types )1;
  } else {
#line 256
    posixicity = (enum posixicity_types )0;
  }
#line 262
  if (cols) {
    {
#line 264
    tmp___1 = atoi(cols);
#line 264
    t = (countT )tmp___1;
    }
#line 265
    if (t > 1UL) {
#line 266
      lcmd_out_line_len = t - 1UL;
    }
  }
#line 269
  myname = (char const   *)*argv;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 270
    opt = getopt_long(argc, (char * const  *)argv, "bsnrzuEe:f:l:i::V:", longopts,
                      (int *)((void *)0));
    }
#line 270
    if (! (opt != -1)) {
#line 270
      goto while_break;
    }
    {
#line 274
    if (opt == 110) {
#line 274
      goto case_110;
    }
#line 277
    if (opt == 101) {
#line 277
      goto case_101;
    }
#line 280
    if (opt == 102) {
#line 280
      goto case_102;
    }
#line 284
    if (opt == 122) {
#line 284
      goto case_122;
    }
#line 288
    if (opt == 70) {
#line 288
      goto case_70;
    }
#line 292
    if (opt == 105) {
#line 292
      goto case_105;
    }
#line 310
    if (opt == 108) {
#line 310
      goto case_108;
    }
#line 314
    if (opt == 112) {
#line 314
      goto case_112;
    }
#line 318
    if (opt == 98) {
#line 318
      goto case_98;
    }
#line 324
    if (opt == 114) {
#line 324
      goto case_114;
    }
#line 324
    if (opt == 69) {
#line 324
      goto case_114;
    }
#line 340
    if (opt == 115) {
#line 340
      goto case_115;
    }
#line 344
    if (opt == 128) {
#line 344
      goto case_128;
    }
#line 348
    if (opt == 117) {
#line 348
      goto case_117;
    }
#line 352
    if (opt == 118) {
#line 352
      goto case_118;
    }
#line 358
    if (opt == 104) {
#line 358
      goto case_104;
    }
#line 360
    goto switch_default;
    case_110: /* CIL Label */ 
#line 275
    no_default_output = (_Bool)1;
#line 276
    goto switch_break;
    case_101: /* CIL Label */ 
    {
#line 278
    tmp___2 = strlen((char const   *)optarg);
#line 278
    the_program = compile_string(the_program, optarg, tmp___2);
    }
#line 279
    goto switch_break;
    case_102: /* CIL Label */ 
    {
#line 281
    the_program = compile_file(the_program, (char const   *)optarg);
    }
#line 282
    goto switch_break;
    case_122: /* CIL Label */ 
#line 285
    buffer_delimiter = (char)0;
#line 286
    goto switch_break;
    case_70: /* CIL Label */ 
#line 289
    follow_symlinks = (_Bool)1;
#line 290
    goto switch_break;
    case_105: /* CIL Label */ 
#line 293
    separate_files = (_Bool)1;
#line 294
    if ((unsigned long )optarg == (unsigned long )((void *)0)) {
      {
#line 296
      in_place_extension = ck_strdup("*");
      }
    } else {
      {
#line 298
      tmp___5 = strchr((char const   *)optarg, '*');
      }
#line 298
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
        {
#line 299
        in_place_extension = ck_strdup((char const   *)optarg);
        }
      } else {
        {
#line 303
        tmp___3 = strlen((char const   *)optarg);
#line 303
        tmp___4 = ck_malloc((tmp___3 + 2UL) * sizeof(char ));
#line 303
        in_place_extension = (char *)tmp___4;
#line 304
        *(in_place_extension + 0) = (char )'*';
#line 305
        strcpy((char */* __restrict  */)(in_place_extension + 1), (char const   */* __restrict  */)optarg);
        }
      }
    }
#line 308
    goto switch_break;
    case_108: /* CIL Label */ 
    {
#line 311
    tmp___6 = atoi((char const   *)optarg);
#line 311
    lcmd_out_line_len = (countT )tmp___6;
    }
#line 312
    goto switch_break;
    case_112: /* CIL Label */ 
#line 315
    posixicity = (enum posixicity_types )2;
#line 316
    goto switch_break;
    case_98: /* CIL Label */ 
#line 319
    read_mode = "rb";
#line 320
    write_mode = "wb";
#line 321
    goto switch_break;
    case_114: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 329
    extended_regexp_flags = 1;
#line 330
    goto switch_break;
    case_115: /* CIL Label */ 
#line 341
    separate_files = (_Bool)1;
#line 342
    goto switch_break;
    case_128: /* CIL Label */ 
#line 345
    sandbox = (_Bool)1;
#line 346
    goto switch_break;
    case_117: /* CIL Label */ 
#line 349
    unbuffered = (_Bool)1;
#line 350
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 353
    tmp___7 = gettext("Paolo Bonzini");
#line 353
    tmp___8 = gettext("Ken Pizzini");
#line 353
    tmp___9 = gettext("Tom Lord");
#line 353
    tmp___10 = gettext("Jay Fenlason");
#line 353
    version_etc(stdout, program_name, "GNU sed", Version, tmp___10, tmp___9, tmp___8,
                tmp___7, (char *)((void *)0));
#line 355
    contact(0);
#line 356
    ck_fclose((FILE *)((void *)0));
#line 357
    exit(0);
    }
    case_104: /* CIL Label */ 
    {
#line 359
    usage(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 361
    usage(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 365
  if (! the_program) {
#line 367
    if (optind < argc) {
      {
#line 369
      tmp___11 = optind;
#line 369
      optind ++;
#line 369
      arg = *(argv + tmp___11);
#line 370
      tmp___12 = strlen((char const   *)arg);
#line 370
      the_program = compile_string(the_program, arg, tmp___12);
      }
    } else {
      {
#line 373
      usage(1);
      }
    }
  }
  {
#line 375
  check_final_program(the_program);
#line 377
  return_code = process_files(the_program, argv + optind);
#line 379
  finish_program();
#line 380
  ck_fclose((FILE *)((void *)0));
  }
#line 382
  return (return_code);
}
}
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 114
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 529 "./lib/regex.h"
extern reg_syntax_t re_set_syntax(reg_syntax_t __syntax ) ;
#line 539
extern char const   *re_compile_pattern(char const   *__pattern , size_t __length ,
                                        struct re_pattern_buffer *__buffer ) ;
#line 554
extern regoff_t re_search(struct re_pattern_buffer *__buffer , char const   *__String ,
                          regoff_t __length , regoff_t __start , regoff_t __range ,
                          struct re_registers *__regs ) ;
#line 188 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
 __attribute__((__noreturn__)) void bad_prog(char const   *why ) ;
#line 189
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) ;
#line 196
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) ;
#line 197
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) ;
#line 33 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
static char const   errors[72]  = 
#line 33 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
  {      (char const   )'n',      (char const   )'o',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'v',      (char const   )'i', 
        (char const   )'o',      (char const   )'u',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )'\000',      (char const   )'c', 
        (char const   )'a',      (char const   )'n',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'s',      (char const   )'p', 
        (char const   )'e',      (char const   )'c',      (char const   )'i',      (char const   )'f', 
        (char const   )'y',      (char const   )' ',      (char const   )'m',      (char const   )'o', 
        (char const   )'d',      (char const   )'i',      (char const   )'f',      (char const   )'i', 
        (char const   )'e',      (char const   )'r',      (char const   )'s',      (char const   )' ', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'e', 
        (char const   )'m',      (char const   )'p',      (char const   )'t',      (char const   )'y', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'\000'};
#line 42
 __attribute__((__noreturn__)) void dfaerror(char const   *mesg ) ;
#line 42 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
void dfaerror(char const   *mesg ) 
{ 


  {
  {
#line 45
  panic("%s", mesg);
  }
}
}
#line 48 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
void dfawarn(char const   *mesg ) 
{ 
  char *tmp ;

  {
  {
#line 51
  tmp = getenv("POSIXLY_CORRECT");
  }
#line 51
  if (! tmp) {
    {
#line 52
    dfaerror(mesg);
    }
  }
#line 53
  return;
}
}
#line 57 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
static void compile_regex_1(struct regex *new_regex , int needed_sub ) 
{ 
  char const   *error___0 ;
  int syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  char buf[200] ;
  char *tmp___3 ;
  int dfaopts ;
  int tmp___4 ;

  {
#line 75
  if (extended_regexp_flags & 1) {
#line 75
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 75
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
#line 75
  syntax = (int )tmp;
#line 79
  syntax = (int )((unsigned long )syntax & ~ (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 80
  syntax = (int )((unsigned long )syntax | ((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  {
#line 84
  if ((unsigned int )posixicity == 0U) {
#line 84
    goto case_0;
  }
#line 87
  if ((unsigned int )posixicity == 1U) {
#line 87
    goto case_1;
  }
#line 90
  if ((unsigned int )posixicity == 2U) {
#line 90
    goto case_2;
  }
#line 82
  goto switch_break;
  case_0: /* CIL Label */ 
#line 85
  syntax = (int )((unsigned long )syntax & ~ (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 86
  goto switch_break;
  case_1: /* CIL Label */ 
#line 88
  syntax = (int )((unsigned long )syntax | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 89
  goto switch_break;
  case_2: /* CIL Label */ 
#line 91
  syntax = (int )((unsigned long )syntax | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) | ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
#line 92
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 95
  if (new_regex->flags & (1 << 1)) {
#line 96
    syntax = (int )((unsigned long )syntax | ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  } else {
    {
#line 98
    tmp___0 = malloc((size_t )(1 << sizeof(char ) * 8UL));
#line 98
    new_regex->pattern.fastmap = (char *)tmp___0;
    }
  }
#line 99
  if (needed_sub) {
#line 99
    tmp___1 = 0UL;
  } else {
#line 99
    tmp___1 = ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  }
#line 99
  syntax = (int )((unsigned long )syntax | tmp___1);
#line 102
  if (new_regex->flags & (1 << 2)) {
#line 105
    syntax = (int )((unsigned long )syntax & ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1));
#line 106
    syntax = (int )((unsigned long )syntax | ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
  }
  {
#line 109
  re_set_syntax((reg_syntax_t )syntax);
#line 110
  error___0 = re_compile_pattern((char const   *)(new_regex->re), new_regex->sz, & new_regex->pattern);
  }
#line 112
  if ((int )buffer_delimiter == 10) {
#line 112
    if ((new_regex->flags & (1 << 2)) != 0) {
#line 112
      tmp___2 = 1;
    } else {
#line 112
      tmp___2 = 0;
    }
  } else {
#line 112
    tmp___2 = 0;
  }
#line 112
  new_regex->pattern.newline_anchor = (unsigned int )tmp___2;
#line 115
  new_regex->pattern.translate = (unsigned char *)((void *)0);
#line 128
  if (error___0) {
    {
#line 129
    bad_prog(error___0);
    }
  }
#line 133
  if (needed_sub) {
#line 133
    if (new_regex->pattern.re_nsub < (size_t )(needed_sub - 1)) {
#line 133
      if ((unsigned int )posixicity == 0U) {
        {
#line 138
        tmp___3 = gettext("invalid reference \\%d on `s\' command\'s RHS");
#line 138
        sprintf((char */* __restrict  */)(buf), (char const   */* __restrict  */)tmp___3,
                needed_sub - 1);
#line 140
        bad_prog((char const   *)(buf));
        }
      }
    }
  }
#line 143
  if ((int )buffer_delimiter == 10) {
#line 143
    tmp___4 = 0;
  } else {
#line 143
    tmp___4 = 2;
  }
  {
#line 143
  dfaopts = tmp___4;
#line 144
  new_regex->dfa = dfaalloc();
#line 145
  dfasyntax(new_regex->dfa, (struct localeinfo  const  *)(& localeinfo), (reg_syntax_t )syntax,
            dfaopts);
#line 146
  dfacomp((char const   *)(new_regex->re), new_regex->sz, new_regex->dfa, (_Bool)1);
  }
#line 152
  if (new_regex->sz == 1UL) {
#line 154
    if ((int )new_regex->re[0] == 94) {
#line 155
      new_regex->begline = (_Bool)1;
    }
#line 156
    if ((int )new_regex->re[0] == 36) {
#line 157
      new_regex->endline = (_Bool)1;
    }
  }
#line 159
  return;
}
}
#line 161 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
struct regex *compile_regex(struct buffer *b___0 , int flags , int needed_sub ) 
{ 
  struct regex *new_regex ;
  size_t re_len ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 168
  tmp___0 = size_buffer((struct buffer  const  *)b___0);
  }
#line 168
  if (tmp___0 == 0UL) {
#line 170
    if (flags > 0) {
      {
#line 171
      tmp = gettext(errors + sizeof("no previous regular expression"));
#line 171
      bad_prog((char const   *)tmp);
      }
    }
#line 172
    return ((struct regex *)((void *)0));
  }
  {
#line 175
  re_len = size_buffer((struct buffer  const  *)b___0);
#line 176
  tmp___1 = ck_malloc((sizeof(struct regex ) + re_len) - 1UL);
#line 176
  new_regex = (struct regex *)tmp___1;
#line 177
  new_regex->flags = flags;
#line 178
  tmp___2 = get_buffer((struct buffer  const  *)b___0);
#line 178
  memcpy((void */* __restrict  */)(new_regex->re), (void const   */* __restrict  */)tmp___2,
         re_len);
#line 184
  new_regex->sz = normalize_text(new_regex->re, re_len, (enum text_types )2);
#line 187
  compile_regex_1(new_regex, needed_sub);
  }
#line 188
  return (new_regex);
}
}
#line 235 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
static struct regex *regex_last  ;
#line 229 "/home/khheo/project/benchmark/sed-4.3/sed/regexp.c"
int match_regex(struct regex *regex , char *buf , size_t buflen , size_t buf_start_offset ,
                struct re_registers *regarray , int regsize ) 
{ 
  int ret ;
  char *tmp ;
  size_t offset ;
  char const   *p ;
  void *tmp___0 ;
  char const   *p___0 ;
  void *tmp___1 ;
  size_t i ;
  void *tmp___2 ;
  void *tmp___3 ;
  regoff_t tmp___4 ;
  struct dfa *superset ;
  struct dfa *tmp___5 ;
  char *tmp___6 ;
  _Bool backref ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char const   *beg ;
  char const   *end ;
  char const   *start ;
  char const   *eol ;
  void *tmp___9 ;
  void *tmp___10 ;
  struct re_registers *tmp___11 ;
  size_t i___0 ;
  struct re_registers *tmp___12 ;

  {
#line 245
  if (! regex) {
#line 247
    regex = regex_last;
#line 248
    if (! regex_last) {
      {
#line 249
      tmp = gettext(errors);
#line 249
      bad_prog((char const   *)tmp);
      }
    }
  } else {
#line 252
    regex_last = regex;
  }
#line 264
  if (regex->pattern.no_sub) {
#line 264
    if (regsize) {
      {
#line 265
      compile_regex_1(regex, regsize);
      }
    }
  }
#line 267
  regex->pattern.regs_allocated = 1U;
#line 270
  if (regex->begline) {
#line 270
    goto _L;
  } else
#line 270
  if (regex->endline) {
    _L: /* CIL Label */ 
#line 274
    if (regex->endline) {
#line 276
      p = (char const   *)((void *)0);
#line 278
      if (regex->flags & (1 << 2)) {
        {
#line 279
        tmp___0 = memchr((void const   *)(buf + buf_start_offset), (int )buffer_delimiter,
                         buflen);
#line 279
        p = (char const   *)tmp___0;
        }
      }
#line 281
      if (p) {
#line 281
        offset = (size_t )(p - (char const   *)buf);
      } else {
#line 281
        offset = buflen;
      }
    } else
#line 283
    if (buf_start_offset == 0UL) {
#line 285
      offset = (size_t )0;
    } else
#line 286
    if (! (regex->flags & (1 << 2))) {
#line 290
      return (0);
    } else
#line 291
    if ((int )*(buf + (buf_start_offset - 1UL)) == (int )buffer_delimiter) {
#line 296
      offset = buf_start_offset;
    } else {
      {
#line 303
      tmp___1 = memchr((void const   *)(buf + buf_start_offset), (int )buffer_delimiter,
                       buflen - buf_start_offset);
#line 303
      p___0 = (char const   *)tmp___1;
      }
#line 306
      if ((unsigned long )p___0 == (unsigned long )((void *)0)) {
#line 307
        return (0);
      }
#line 309
      offset = (size_t )((p___0 - (char const   *)buf) + 1L);
    }
#line 312
    if (regsize) {
#line 316
      if (! regarray->start) {
        {
#line 318
        tmp___2 = ck_malloc(sizeof(regoff_t ));
#line 318
        regarray->start = (regoff_t *)tmp___2;
#line 319
        tmp___3 = ck_malloc(sizeof(regoff_t ));
#line 319
        regarray->end = (regoff_t *)tmp___3;
#line 320
        regarray->num_regs = (__re_size_t )1;
        }
      }
#line 323
      *(regarray->start + 0) = (regoff_t )offset;
#line 324
      *(regarray->end + 0) = (regoff_t )offset;
#line 326
      i = (size_t )1;
      {
#line 326
      while (1) {
        while_continue: /* CIL Label */ ;
#line 326
        if (! (i < (size_t )regarray->num_regs)) {
#line 326
          goto while_break;
        }
#line 327
        tmp___4 = -1;
#line 327
        *(regarray->end + i) = tmp___4;
#line 327
        *(regarray->start + i) = tmp___4;
#line 326
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 330
    return (1);
  }
#line 333
  if (buf_start_offset == 0UL) {
    {
#line 335
    tmp___5 = dfasuperset((struct dfa  const  *)regex->dfa);
#line 335
    superset = tmp___5;
    }
#line 337
    if (superset) {
      {
#line 337
      tmp___6 = dfaexec(superset, (char const   *)buf, buf + buflen, (_Bool)1, (size_t *)((void *)0),
                        (_Bool *)((void *)0));
      }
#line 337
      if (! tmp___6) {
#line 338
        return (0);
      }
    }
#line 340
    if (! regsize) {
#line 340
      if (regex->flags & (1 << 2)) {
#line 340
        goto _L___0;
      } else {
#line 340
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 340
    if (! superset) {
      {
#line 340
      tmp___8 = dfaisfast((struct dfa  const  *)regex->dfa);
      }
#line 340
      if (tmp___8) {
        _L___0: /* CIL Label */ 
        {
#line 343
        backref = (_Bool)0;
#line 345
        tmp___7 = dfaexec(regex->dfa, (char const   *)buf, buf + buflen, (_Bool)1,
                          (size_t *)((void *)0), & backref);
        }
#line 345
        if (! tmp___7) {
#line 346
          return (0);
        }
#line 348
        if (! regsize) {
#line 348
          if (regex->flags & (1 << 2)) {
#line 348
            if (! backref) {
#line 349
              return (1);
            }
          }
        }
      }
    }
  }
#line 356
  if (regex->flags & (1 << 2)) {
#line 356
    if ((int )buffer_delimiter != 10) {
#line 361
      beg = (char const   *)buf;
#line 363
      if (buf_start_offset > 0UL) {
        {
#line 365
        tmp___9 = memrchr((void const   *)buf, (int )buffer_delimiter, buf_start_offset);
#line 365
        eol = (char const   *)tmp___9;
        }
#line 367
        if ((unsigned long )eol != (unsigned long )((void *)0)) {
#line 368
          beg = eol + 1;
        }
      }
#line 371
      start = (char const   *)(buf + buf_start_offset);
      {
#line 373
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 375
        tmp___10 = memchr((void const   *)beg, (int )buffer_delimiter, (size_t )((buf + buflen) - (char *)beg));
#line 375
        end = (char const   *)tmp___10;
        }
#line 377
        if ((unsigned long )end == (unsigned long )((void *)0)) {
#line 378
          end = (char const   *)(buf + buflen);
        }
#line 380
        if (regsize) {
#line 380
          tmp___11 = regarray;
        } else {
#line 380
          tmp___11 = (struct re_registers *)((void *)0);
        }
        {
#line 380
        ret = re_search(& regex->pattern, beg, (regoff_t )(end - beg), (regoff_t )(start - beg),
                        (regoff_t )(end - start), tmp___11);
        }
#line 384
        if (ret > -1) {
#line 388
          ret = (int )((long )ret + (beg - (char const   *)buf));
#line 390
          if (regsize) {
#line 392
            i___0 = (size_t )0;
            {
#line 392
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 392
              if (! (i___0 < (size_t )regarray->num_regs)) {
#line 392
                goto while_break___1;
              }
#line 394
              if (*(regarray->start + i___0) > -1) {
#line 395
                *(regarray->start + i___0) = (regoff_t )((long )*(regarray->start + i___0) + (beg - (char const   *)buf));
              }
#line 396
              if (*(regarray->end + i___0) > -1) {
#line 397
                *(regarray->end + i___0) = (regoff_t )((long )*(regarray->end + i___0) + (beg - (char const   *)buf));
              }
#line 392
              i___0 ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
#line 401
          goto while_break___0;
        }
#line 404
        if ((unsigned long )end == (unsigned long )(buf + buflen)) {
#line 405
          goto while_break___0;
        }
#line 407
        start = end + 1;
#line 407
        beg = start;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 356
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 411
    if (regsize) {
#line 411
      tmp___12 = regarray;
    } else {
#line 411
      tmp___12 = (struct re_registers *)((void *)0);
    }
    {
#line 411
    ret = re_search(& regex->pattern, (char const   *)buf, (regoff_t )buflen, (regoff_t )buf_start_offset,
                    (regoff_t )(buflen - buf_start_offset), tmp___12);
    }
  }
#line 415
  return (ret > -1);
}
}
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 245 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
int mb_cur_max  ;
#line 246 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
_Bool is_utf8  ;
#line 270
int is_mb_char(int ch , mbstate_t *cur_stat ) ;
#line 38 "/home/khheo/project/benchmark/sed-4.3/sed/mbcs.c"
int is_mb_char(int ch , mbstate_t *cur_stat ) 
{ 
  char c ;
  int mb_pending ;
  int tmp ;
  int tmp___0 ;
  int result ;
  size_t tmp___1 ;

  {
  {
#line 41
  c = (char )ch;
#line 42
  tmp = mbsinit((mbstate_t const   *)cur_stat);
  }
#line 42
  if (tmp) {
#line 42
    tmp___0 = 0;
  } else {
#line 42
    tmp___0 = 1;
  }
  {
#line 42
  mb_pending = tmp___0;
#line 43
  tmp___1 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(& c), (size_t )1,
                        cur_stat);
#line 43
  result = (int )tmp___1;
  }
  {
#line 47
  if (result == -2) {
#line 47
    goto case_neg_2;
  }
#line 50
  if (result == -1) {
#line 50
    goto case_neg_1;
  }
#line 54
  if (result == 1) {
#line 54
    goto case_1;
  }
#line 57
  if (result == 0) {
#line 57
    goto case_0;
  }
#line 61
  goto switch_default;
  case_neg_2: /* CIL Label */ 
#line 48
  return (1);
  case_neg_1: /* CIL Label */ 
  {
#line 51
  memset((void *)cur_stat, 0, sizeof(mbstate_t ));
  }
#line 52
  return (0);
  case_1: /* CIL Label */ 
#line 55
  return (mb_pending);
  case_0: /* CIL Label */ 
#line 59
  return (1);
  switch_default: /* CIL Label */ 
  {
#line 62
  panic("is_mb_char: mbrtowc (0x%x) returned %d", (unsigned int )ch, result);
  }
  switch_break: /* CIL Label */ ;
  }
}
}
#line 67 "/home/khheo/project/benchmark/sed-4.3/sed/mbcs.c"
void initialize_mbcs(void) 
{ 
  char const   *codeset_name ;
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 73
  codeset_name = locale_charset();
#line 74
  tmp = strcmp(codeset_name, "UTF-8");
#line 74
  is_utf8 = (_Bool )(tmp == 0);
#line 76
  tmp___0 = __ctype_get_mb_cur_max();
#line 76
  mb_cur_max = (int )tmp___0;
  }
#line 77
  return;
}
}
#line 284 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) btowc)(int __c ) ;
#line 294 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 766
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 800
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 806
extern int pclose(FILE *__stream ) ;
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 193 "/home/khheo/project/benchmark/sed-4.3/sed/sed.h"
void rewind_read_files(void) ;
#line 481 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 782
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 141 "./lib/unistd.h"
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1943
#pragma GCC diagnostic pop
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 38 "./lib/selinux/selinux.h"
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 38
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 10 "./lib/selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 65
#pragma GCC diagnostic pop
#line 115 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool replaced  =    (_Bool)0;
#line 118 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct output output_file  ;
#line 121 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct line line  ;
#line 124 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct line s_accum  ;
#line 127 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct line hold  ;
#line 131 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct line buffer  ;
#line 133 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct append_queue *append_head  =    (struct append_queue *)((void *)0);
#line 134 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct append_queue *append_tail  =    (struct append_queue *)((void *)0);
#line 139 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void resize_line(struct line *lb , size_t len ) 
{ 
  int inactive ;
  void *tmp ;

  {
#line 143
  inactive = (int )(lb->active - lb->text);
#line 147
  if ((size_t )inactive > lb->alloc * 2UL) {
    {
#line 149
    memmove((void *)lb->text, (void const   *)lb->active, lb->length);
#line 150
    lb->alloc += (size_t )(lb->active - lb->text);
#line 151
    lb->active = lb->text;
#line 152
    inactive = 0;
    }
#line 154
    if (lb->alloc > len) {
#line 155
      return;
    }
  }
#line 158
  lb->alloc *= 2UL;
#line 159
  if (lb->alloc < len) {
#line 160
    lb->alloc = len;
  }
#line 161
  if (lb->alloc < 50UL) {
#line 162
    lb->alloc = (size_t )50;
  }
  {
#line 164
  tmp = ck_realloc((void *)lb->text, (((size_t )inactive + lb->alloc) + 1UL) * sizeof(char ));
#line 164
  lb->text = (char *)tmp;
#line 165
  lb->active = lb->text + inactive;
  }
#line 166
  return;
}
}
#line 169 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void str_append(struct line *to , char const   *string , size_t length ) 
{ 
  size_t new_length ;
  size_t n ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 172
  new_length = to->length + length;
#line 174
  if (to->alloc < new_length) {
    {
#line 175
    resize_line(to, new_length);
    }
  }
  {
#line 176
  memcpy((void */* __restrict  */)(to->active + to->length), (void const   */* __restrict  */)string,
         length);
#line 177
  to->length = new_length;
  }
#line 179
  if (mb_cur_max > 1) {
#line 179
    if (! is_utf8) {
      {
#line 180
      while (1) {
        while_continue: /* CIL Label */ ;
#line 180
        if (! length) {
#line 180
          goto while_break;
        }
#line 182
        if (mb_cur_max == 1) {
#line 182
          tmp___0 = (size_t )1;
        } else {
          {
#line 182
          tmp = rpl_mbrtowc((wchar_t *)((void *)0), string, length, & to->mbstate);
#line 182
          tmp___0 = tmp;
          }
        }
#line 182
        n = tmp___0;
#line 186
        if (n == 0xffffffffffffffffUL) {
          {
#line 188
          memset((void *)(& to->mbstate), 0, sizeof(to->mbstate));
#line 189
          n = (size_t )1;
          }
        } else
#line 186
        if (n == 0xfffffffffffffffeUL) {
          {
#line 188
          memset((void *)(& to->mbstate), 0, sizeof(to->mbstate));
#line 189
          n = (size_t )1;
          }
        }
#line 192
        if (n == 0UL) {
#line 193
          goto while_break;
        }
#line 195
        string += n;
#line 196
        length -= n;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 198
  return;
}
}
#line 200 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void str_append_modified(struct line *to , char const   *string , size_t length ,
                                enum replacement_types type ) 
{ 
  mbstate_t from_stat ;
  wchar_t wc ;
  size_t n ;
  wint_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  wint_t tmp___2 ;
  wint_t tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  char *tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  char *tmp___11 ;

  {
#line 206
  if ((unsigned int )type == 0U) {
    {
#line 208
    str_append(to, string, length);
    }
#line 209
    return;
  }
#line 212
  if (to->alloc - to->length < length * (size_t )mb_cur_max) {
    {
#line 213
    resize_line(to, to->length + length * (size_t )mb_cur_max);
    }
  }
  {
#line 215
  memcpy((void */* __restrict  */)(& from_stat), (void const   */* __restrict  */)(& to->mbstate),
         sizeof(mbstate_t ));
  }
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! length) {
#line 216
      goto while_break;
    }
#line 219
    if (mb_cur_max == 1) {
      {
#line 219
      tmp = btowc((int )*((unsigned char *)string));
#line 219
      wc = (wchar_t )tmp;
#line 219
      tmp___1 = (size_t )1;
      }
    } else {
      {
#line 219
      tmp___0 = rpl_mbrtowc(& wc, string, length, & from_stat);
#line 219
      tmp___1 = tmp___0;
      }
    }
#line 219
    n = tmp___1;
#line 222
    if (n == 0xffffffffffffffffUL) {
#line 224
      type = (enum replacement_types )((unsigned int )type & 4294967283U);
#line 225
      if ((unsigned int )type == 0U) {
        {
#line 227
        str_append(to, string, length);
        }
#line 228
        return;
      }
      {
#line 231
      str_append(to, string, (size_t )1);
#line 232
      memset((void *)(& to->mbstate), 0, sizeof(from_stat));
#line 233
      n = (size_t )1;
#line 234
      string += n;
#line 234
      length -= n;
      }
#line 235
      goto while_continue;
    }
#line 238
    if (n == 0UL) {
      {
#line 241
      str_append(to, string, length);
      }
#line 242
      return;
    } else
#line 238
    if (n == 0xfffffffffffffffeUL) {
      {
#line 241
      str_append(to, string, length);
      }
#line 242
      return;
    }
#line 245
    string += n;
#line 245
    length -= n;
#line 248
    if ((unsigned int )type & 12U) {
#line 250
      if ((unsigned int )type & 4U) {
        {
#line 251
        tmp___2 = towupper((wint_t )wc);
#line 251
        wc = (wchar_t )tmp___2;
        }
      } else {
        {
#line 253
        tmp___3 = towlower((wint_t )wc);
#line 253
        wc = (wchar_t )tmp___3;
        }
      }
#line 255
      type = (enum replacement_types )((unsigned int )type & 4294967283U);
#line 256
      if ((unsigned int )type == 0U) {
#line 259
        if (mb_cur_max == 1) {
          {
#line 259
          tmp___4 = wctob((wint_t )wc);
#line 259
          *(to->active + to->length) = (char )tmp___4;
#line 259
          n = (size_t )1;
          }
        } else {
          {
#line 259
          tmp___5 = wcrtomb((char */* __restrict  */)(to->active + to->length), wc,
                            (mbstate_t */* __restrict  */)(& to->mbstate));
#line 259
          n = tmp___5;
          }
        }
#line 260
        to->length += n;
#line 261
        if (n == 0xffffffffffffffffUL) {
          {
#line 263
          tmp___6 = gettext("case conversion produced an invalid character");
#line 263
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 265
          abort();
          }
        } else
#line 261
        if (n == 0xfffffffffffffffeUL) {
          {
#line 263
          tmp___6 = gettext("case conversion produced an invalid character");
#line 263
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 265
          abort();
          }
        }
        {
#line 267
        str_append(to, string, length);
        }
#line 268
        return;
      }
    } else
#line 271
    if ((unsigned int )type & 1U) {
      {
#line 272
      tmp___7 = towupper((wint_t )wc);
#line 272
      wc = (wchar_t )tmp___7;
      }
    } else {
      {
#line 274
      tmp___8 = towlower((wint_t )wc);
#line 274
      wc = (wchar_t )tmp___8;
      }
    }
#line 277
    if (mb_cur_max == 1) {
      {
#line 277
      tmp___9 = wctob((wint_t )wc);
#line 277
      *(to->active + to->length) = (char )tmp___9;
#line 277
      n = (size_t )1;
      }
    } else {
      {
#line 277
      tmp___10 = wcrtomb((char */* __restrict  */)(to->active + to->length), wc, (mbstate_t */* __restrict  */)(& to->mbstate));
#line 277
      n = tmp___10;
      }
    }
#line 278
    to->length += n;
#line 279
    if (n == 0xffffffffffffffffUL) {
      {
#line 281
      tmp___11 = gettext("case conversion produced an invalid character");
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
#line 282
      abort();
      }
    } else
#line 279
    if (n == 0xfffffffffffffffeUL) {
      {
#line 281
      tmp___11 = gettext("case conversion produced an invalid character");
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
#line 282
      abort();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  return;
}
}
#line 289 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void line_init(struct line *buf , struct line *state , size_t initial_size ) 
{ 
  void *tmp ;

  {
  {
#line 292
  tmp = ck_malloc((initial_size + 1UL) * sizeof(char ));
#line 292
  buf->text = (char *)tmp;
#line 293
  buf->active = buf->text;
#line 294
  buf->alloc = initial_size;
#line 295
  buf->length = (size_t )0;
#line 296
  buf->chomped = (_Bool)1;
  }
#line 298
  if (state) {
    {
#line 299
    memcpy((void */* __restrict  */)(& buf->mbstate), (void const   */* __restrict  */)(& state->mbstate),
           sizeof(buf->mbstate));
    }
  } else {
    {
#line 301
    memset((void *)(& buf->mbstate), 0, sizeof(buf->mbstate));
    }
  }
#line 302
  return;
}
}
#line 306 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void line_reset(struct line *buf , struct line *state ) 
{ 


  {
#line 309
  if (buf->alloc == 0UL) {
    {
#line 310
    line_init(buf, state, (size_t )50);
    }
  } else {
#line 313
    buf->length = (size_t )0;
#line 314
    if (state) {
      {
#line 315
      memcpy((void */* __restrict  */)(& buf->mbstate), (void const   */* __restrict  */)(& state->mbstate),
             sizeof(buf->mbstate));
      }
    } else {
      {
#line 317
      memset((void *)(& buf->mbstate), 0, sizeof(buf->mbstate));
      }
    }
  }
#line 319
  return;
}
}
#line 324 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void line_copy(struct line *from , struct line *to , int state ) 
{ 
  void *tmp ;

  {
#line 328
  to->alloc += (size_t )(to->active - to->text);
#line 330
  if (to->alloc < from->length) {
#line 332
    to->alloc *= 2UL;
#line 333
    if (to->alloc < from->length) {
#line 334
      to->alloc = from->length;
    }
#line 335
    if (to->alloc < 50UL) {
#line 336
      to->alloc = (size_t )50;
    }
    {
#line 339
    free((void *)to->text);
#line 340
    tmp = ck_malloc((to->alloc + 1UL) * sizeof(char ));
#line 340
    to->text = (char *)tmp;
    }
  }
  {
#line 343
  to->active = to->text;
#line 344
  to->length = from->length;
#line 345
  to->chomped = from->chomped;
#line 346
  memcpy((void */* __restrict  */)to->active, (void const   */* __restrict  */)from->active,
         from->length);
  }
#line 348
  if (state) {
    {
#line 349
    memcpy((void */* __restrict  */)(& to->mbstate), (void const   */* __restrict  */)(& from->mbstate),
           sizeof(from->mbstate));
    }
  }
#line 350
  return;
}
}
#line 354 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void line_append(struct line *from , struct line *to , int state ) 
{ 


  {
  {
#line 357
  str_append(to, (char const   *)(& buffer_delimiter), (size_t )1);
#line 358
  str_append(to, (char const   *)from->active, from->length);
#line 359
  to->chomped = from->chomped;
  }
#line 361
  if (state) {
    {
#line 362
    memcpy((void */* __restrict  */)(& to->mbstate), (void const   */* __restrict  */)(& from->mbstate),
           sizeof(from->mbstate));
    }
  }
#line 363
  return;
}
}
#line 367 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void line_exchange(struct line *a , struct line *b___0 , int state ) 
{ 
  struct line t ;

  {
#line 372
  if (state) {
    {
#line 374
    memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, sizeof(struct line ));
#line 375
    memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, sizeof(struct line ));
#line 376
    memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t),
           sizeof(struct line ));
    }
  } else {
    {
#line 380
    memcpy((void */* __restrict  */)(& t), (void const   */* __restrict  */)a, (unsigned long )(& ((struct line *)0)->mbstate));
#line 381
    memcpy((void */* __restrict  */)a, (void const   */* __restrict  */)b___0, (unsigned long )(& ((struct line *)0)->mbstate));
#line 382
    memcpy((void */* __restrict  */)b___0, (void const   */* __restrict  */)(& t),
           (unsigned long )(& ((struct line *)0)->mbstate));
    }
  }
#line 384
  return;
}
}
#line 388 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool read_always_fail(struct input *input  __attribute__((__unused__)) ) 
{ 


  {
#line 391
  return ((_Bool)0);
}
}
#line 397 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static char *b  ;
#line 398 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static size_t blen  ;
#line 394 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool read_file_line(struct input *input ) 
{ 
  long result ;
  size_t tmp ;

  {
  {
#line 400
  tmp = ck_getdelim(& b, & blen, buffer_delimiter, input->fp);
#line 400
  result = (long )tmp;
  }
#line 401
  if (result <= 0L) {
#line 402
    return ((_Bool)0);
  }
#line 405
  if ((int )*(b + (result - 1L)) == (int )buffer_delimiter) {
#line 406
    result --;
  } else {
#line 408
    line.chomped = (_Bool)0;
  }
  {
#line 410
  str_append(& line, (char const   *)b, (size_t )result);
  }
#line 411
  return ((_Bool)1);
}
}
#line 415 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
__inline static void output_missing_newline(struct output *outf ) 
{ 


  {
#line 418
  if (outf->missing_newline) {
    {
#line 420
    ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, outf->fp);
#line 421
    outf->missing_newline = (_Bool)0;
    }
  }
#line 423
  return;
}
}
#line 425 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
__inline static void flush_output(FILE *fp ) 
{ 


  {
#line 428
  if ((unsigned long )fp != (unsigned long )stdout) {
    {
#line 429
    ck_fflush(fp);
    }
  } else
#line 428
  if (unbuffered) {
    {
#line 429
    ck_fflush(fp);
    }
  }
#line 430
  return;
}
}
#line 432 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void output_line(char const   *text , size_t length , int nl , struct output *outf ) 
{ 


  {
#line 435
  if (! text) {
#line 436
    return;
  }
  {
#line 438
  output_missing_newline(outf);
  }
#line 439
  if (length) {
    {
#line 440
    ck_fwrite((void const   *)text, (size_t )1, length, outf->fp);
    }
  }
#line 441
  if (nl) {
    {
#line 442
    ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, outf->fp);
    }
  } else {
#line 444
    outf->missing_newline = (_Bool)1;
  }
  {
#line 446
  flush_output(outf->fp);
  }
#line 447
  return;
}
}
#line 449 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct append_queue *next_append_slot(void) 
{ 
  struct append_queue *n ;
  void *tmp ;

  {
  {
#line 452
  tmp = ck_malloc(sizeof(struct append_queue ));
#line 452
  n = (struct append_queue *)tmp;
#line 454
  n->fname = (char const   *)((void *)0);
#line 455
  n->text = (char *)((void *)0);
#line 456
  n->textlen = (size_t )0;
#line 457
  n->next = (struct append_queue *)((void *)0);
#line 458
  n->free = (_Bool)0;
  }
#line 460
  if (append_tail) {
#line 461
    append_tail->next = n;
  } else {
#line 463
    append_head = n;
  }
#line 464
  append_tail = n;
#line 464
  return (append_tail);
}
}
#line 467 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void release_append_queue(void) 
{ 
  struct append_queue *p ;
  struct append_queue *q ;

  {
#line 472
  p = append_head;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (! p) {
#line 472
      goto while_break;
    }
#line 474
    if (p->free) {
      {
#line 475
      free((void *)p->text);
      }
    }
    {
#line 477
    q = p->next;
#line 478
    free((void *)p);
#line 472
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  append_tail = (struct append_queue *)((void *)0);
#line 480
  append_head = append_tail;
#line 481
  return;
}
}
#line 483 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void dump_append_queue(void) 
{ 
  struct append_queue *p ;
  char buf[8192] ;
  size_t cnt ;
  FILE *fp ;

  {
  {
#line 488
  output_missing_newline(& output_file);
#line 489
  p = append_head;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! p) {
#line 489
      goto while_break;
    }
#line 491
    if (p->text) {
      {
#line 492
      ck_fwrite((void const   *)p->text, (size_t )1, p->textlen, output_file.fp);
      }
    }
#line 494
    if (p->fname) {
      {
#line 504
      fp = ck_fopen(p->fname, read_mode, 0);
      }
#line 505
      if (fp) {
        {
#line 507
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 507
          cnt = ck_fread((void *)(buf), (size_t )1, sizeof(buf), fp);
          }
#line 507
          if (! (cnt > 0UL)) {
#line 507
            goto while_break___0;
          }
          {
#line 508
          ck_fwrite((void const   *)(buf), (size_t )1, cnt, output_file.fp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 509
        ck_fclose(fp);
        }
      }
    }
#line 489
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 514
  flush_output(output_file.fp);
#line 515
  release_append_queue();
  }
#line 516
  return;
}
}
#line 520 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static char *get_backup_file_name(char const   *name ) 
{ 
  char *old_asterisk ;
  char *asterisk ;
  char *backup ;
  char *p ;
  int name_length ;
  size_t tmp ;
  int backup_length ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 524
  tmp = strlen(name);
#line 524
  name_length = (int )tmp;
#line 524
  tmp___0 = strlen((char const   *)in_place_extension);
#line 524
  backup_length = (int )tmp___0;
#line 527
  asterisk = in_place_extension - 1;
#line 527
  old_asterisk = asterisk + 1;
  }
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 527
    asterisk = strchr((char const   *)old_asterisk, '*');
    }
#line 527
    if (! asterisk) {
#line 527
      goto while_break;
    }
#line 530
    backup_length += name_length - 1;
#line 527
    old_asterisk = asterisk + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 532
  tmp___1 = xmalloc((size_t )(backup_length + 1));
#line 532
  backup = (char *)tmp___1;
#line 532
  p = backup;
#line 535
  asterisk = in_place_extension - 1;
#line 535
  old_asterisk = asterisk + 1;
  }
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 535
    asterisk = strchr((char const   *)old_asterisk, '*');
    }
#line 535
    if (! asterisk) {
#line 535
      goto while_break___0;
    }
    {
#line 539
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)old_asterisk,
           (size_t )(asterisk - old_asterisk));
#line 540
    p += asterisk - old_asterisk;
#line 541
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)name);
#line 542
    p += name_length;
#line 535
    old_asterisk = asterisk + 1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 546
  strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)old_asterisk);
  }
#line 547
  return (backup);
}
}
#line 551 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void open_next_file(char const   *name , struct input *input ) 
{ 
  char const   *ptr ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;
  int input_fd ;
  char *tmpdir ;
  char *p ;
  security_context_t old_fscreatecon ;
  int reset_fscreatecon ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;

  {
#line 554
  buffer.length = (size_t )0;
#line 556
  input->in_file_name = name;
#line 557
  if ((int const   )*(name + 0) == 45) {
#line 557
    if ((int const   )*(name + 1) == 0) {
#line 557
      if (! in_place_extension) {
        {
#line 559
        clearerr_unlocked(stdin);
#line 564
        input->fp = stdin;
        }
      } else {
#line 557
        goto _L___0;
      }
    } else {
#line 557
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 569
    if (follow_symlinks) {
      {
#line 570
      input->in_file_name = follow_symlink(name);
      }
    }
    {
#line 572
    tmp___2 = ck_fopen(name, read_mode, 0);
#line 572
    input->fp = tmp___2;
    }
#line 572
    if (! tmp___2) {
      {
#line 574
      tmp = __errno_location();
#line 574
      tmp___0 = strerror(*tmp);
#line 574
      ptr = (char const   *)tmp___0;
#line 575
      tmp___1 = gettext("%s: can\'t read %s: %s\n");
#line 575
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
              myname, name, ptr);
#line 576
      input->read_fn = & read_always_fail;
#line 577
      (input->bad_count) ++;
      }
#line 578
      return;
    }
  }
#line 582
  input->read_fn = & read_file_line;
#line 584
  if (in_place_extension) {
    {
#line 589
    reset_fscreatecon = 0;
#line 590
    memset((void *)(& old_fscreatecon), 0, sizeof(old_fscreatecon));
#line 593
    tmpdir = ck_strdup(input->in_file_name);
#line 594
    p = strrchr((char const   *)tmpdir, '/');
    }
#line 594
    if (p) {
#line 595
      *p = (char)0;
    } else {
      {
#line 597
      strcpy((char */* __restrict  */)tmpdir, (char const   */* __restrict  */)".");
      }
    }
    {
#line 599
    tmp___4 = fileno(input->fp);
#line 599
    tmp___5 = isatty(tmp___4);
    }
#line 599
    if (tmp___5) {
      {
#line 600
      tmp___3 = gettext("couldn\'t edit %s: is a terminal");
#line 600
      panic((char const   *)tmp___3, input->in_file_name);
      }
    }
    {
#line 602
    input_fd = fileno(input->fp);
#line 603
    fstat(input_fd, & input->st);
    }
#line 604
    if (! ((input->st.st_mode & 61440U) == 32768U)) {
      {
#line 605
      tmp___6 = gettext("couldn\'t edit %s: not a regular file");
#line 605
      panic((char const   *)tmp___6, input->in_file_name);
      }
    }
    {
#line 630
    output_file.fp = ck_mkstemp(& input->out_file_name, (char const   *)tmpdir, "sed",
                                write_mode);
#line 632
    register_cleanup_file((char const   *)input->out_file_name);
#line 633
    output_file.missing_newline = (_Bool)0;
#line 634
    free((void *)tmpdir);
    }
#line 636
    if (reset_fscreatecon) {
      {
#line 638
      setfscreatecon(old_fscreatecon);
#line 639
      freecon(old_fscreatecon);
      }
    }
#line 642
    if (! output_file.fp) {
      {
#line 643
      tmp___17 = __errno_location();
#line 643
      tmp___18 = strerror(*tmp___17);
#line 643
      tmp___19 = gettext("couldn\'t open temporary file %s: %s");
#line 643
      panic((char const   *)tmp___19, input->out_file_name, tmp___18);
      }
    }
  } else {
#line 648
    if (input->fp) {
#line 648
      if (unbuffered) {
        {
#line 649
        setvbuf((FILE */* __restrict  */)input->fp, (char */* __restrict  */)((void *)0),
                2, (size_t )0);
        }
      }
    }
#line 650
    output_file.fp = stdout;
  }
#line 652
  return;
}
}
#line 656 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void closedown(struct input *input ) 
{ 
  char const   *target_name ;
  int input_fd ;
  int output_fd ;
  int __x ;
  int tmp ;
  int tmp___0 ;
  char *backup_file_name ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 659
  input->read_fn = & read_always_fail;
#line 660
  if (! input->fp) {
#line 661
    return;
  }
#line 663
  if (in_place_extension) {
#line 663
    if ((unsigned long )output_file.fp != (unsigned long )((void *)0)) {
      {
#line 668
      target_name = input->in_file_name;
#line 669
      input_fd = fileno(input->fp);
#line 670
      output_fd = fileno(output_file.fp);
#line 674
      tmp___0 = fchown(output_fd, input->st.st_uid, input->st.st_gid);
      }
#line 674
      if (tmp___0 == -1) {
        {
#line 675
        tmp = fchown(output_fd, (__uid_t )-1, input->st.st_gid);
#line 675
        __x = tmp;
        }
      }
      {
#line 677
      copy_acl(input->in_file_name, input_fd, (char const   *)input->out_file_name,
               output_fd, input->st.st_mode);
#line 681
      ck_fclose(input->fp);
#line 682
      ck_fclose(output_file.fp);
#line 683
      tmp___2 = strcmp((char const   *)in_place_extension, "*");
      }
#line 683
      if (tmp___2 != 0) {
        {
#line 685
        tmp___1 = get_backup_file_name(target_name);
#line 685
        backup_file_name = tmp___1;
#line 686
        ck_rename(target_name, (char const   *)backup_file_name, (char const   *)input->out_file_name);
#line 687
        free((void *)backup_file_name);
        }
      }
      {
#line 690
      ck_rename((char const   *)input->out_file_name, target_name, (char const   *)input->out_file_name);
#line 691
      cancel_cleanup();
#line 692
      free((void *)input->out_file_name);
      }
    } else {
      {
#line 695
      ck_fclose(input->fp);
      }
    }
  } else {
    {
#line 695
    ck_fclose(input->fp);
    }
  }
#line 697
  input->fp = (FILE *)((void *)0);
#line 698
  return;
}
}
#line 701 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void reset_addresses(struct vector *vec ) 
{ 
  struct sed_cmd *cur_cmd ;
  int n ;
  int tmp ;

  {
#line 707
  cur_cmd = vec->v;
#line 707
  n = (int )vec->v_length;
  {
#line 707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 707
    tmp = n;
#line 707
    n --;
#line 707
    if (! tmp) {
#line 707
      goto while_break;
    }
#line 708
    if (cur_cmd->a1) {
#line 708
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 708
        if ((cur_cmd->a1)->addr_number == 0UL) {
#line 711
          cur_cmd->range_state = (enum addr_state )1;
        } else {
#line 713
          cur_cmd->range_state = (enum addr_state )0;
        }
      } else {
#line 713
        cur_cmd->range_state = (enum addr_state )0;
      }
    } else {
#line 713
      cur_cmd->range_state = (enum addr_state )0;
    }
#line 707
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return;
}
}
#line 718 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool read_pattern_space(struct input *input , struct vector *the_program___0 ,
                                int append ) 
{ 
  char **tmp ;
  _Bool tmp___0 ;

  {
#line 721
  if (append_head) {
    {
#line 722
    dump_append_queue();
    }
  }
#line 723
  replaced = (_Bool)0;
#line 724
  if (! append) {
#line 725
    line.length = (size_t )0;
  }
#line 726
  line.chomped = (_Bool)1;
  {
#line 728
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 728
    tmp___0 = (*(input->read_fn))(input);
    }
#line 728
    if (tmp___0) {
#line 728
      goto while_break;
    }
    {
#line 730
    closedown(input);
    }
#line 732
    if (! *(input->file_list)) {
#line 733
      return ((_Bool)0);
    }
#line 735
    if (input->reset_at_next_file) {
      {
#line 737
      input->line_number = (countT )0;
#line 738
      hold.length = (size_t )0;
#line 739
      reset_addresses(the_program___0);
#line 740
      rewind_read_files();
      }
#line 745
      if (in_place_extension) {
#line 746
        output_file.missing_newline = (_Bool)0;
      }
#line 748
      input->reset_at_next_file = separate_files;
    }
    {
#line 751
    tmp = input->file_list;
#line 751
    (input->file_list) ++;
#line 751
    open_next_file((char const   *)*tmp, input);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  (input->line_number) ++;
#line 755
  return ((_Bool)1);
}
}
#line 759 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool last_file_with_data_p(struct input *input ) 
{ 
  int ch ;
  char **tmp ;

  {
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 766
    closedown(input);
    }
#line 767
    if (! *(input->file_list)) {
#line 768
      return ((_Bool)1);
    }
    {
#line 769
    tmp = input->file_list;
#line 769
    (input->file_list) ++;
#line 769
    open_next_file((char const   *)*tmp, input);
    }
#line 770
    if (input->fp) {
      {
#line 772
      ch = getc_unlocked(input->fp);
      }
#line 772
      if (ch != -1) {
        {
#line 774
        ungetc(ch, input->fp);
        }
#line 775
        return ((_Bool)0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 782 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool test_eof(struct input *input ) 
{ 
  int ch ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
#line 787
  if (buffer.length) {
#line 788
    return ((_Bool)0);
  }
#line 789
  if (! input->fp) {
#line 790
    if (separate_files) {
#line 790
      tmp___0 = 1;
    } else {
      {
#line 790
      tmp = last_file_with_data_p(input);
      }
#line 790
      if (tmp) {
#line 790
        tmp___0 = 1;
      } else {
#line 790
        tmp___0 = 0;
      }
    }
#line 790
    return ((_Bool )tmp___0);
  }
  {
#line 791
  tmp___3 = feof_unlocked(input->fp);
  }
#line 791
  if (tmp___3) {
#line 792
    if (separate_files) {
#line 792
      tmp___2 = 1;
    } else {
      {
#line 792
      tmp___1 = last_file_with_data_p(input);
      }
#line 792
      if (tmp___1) {
#line 792
        tmp___2 = 1;
      } else {
#line 792
        tmp___2 = 0;
      }
    }
#line 792
    return ((_Bool )tmp___2);
  }
  {
#line 793
  ch = getc_unlocked(input->fp);
  }
#line 793
  if (ch == -1) {
#line 794
    if (separate_files) {
#line 794
      tmp___5 = 1;
    } else {
      {
#line 794
      tmp___4 = last_file_with_data_p(input);
      }
#line 794
      if (tmp___4) {
#line 794
        tmp___5 = 1;
      } else {
#line 794
        tmp___5 = 0;
      }
    }
#line 794
    return ((_Bool )tmp___5);
  }
  {
#line 795
  ungetc(ch, input->fp);
  }
#line 796
  return ((_Bool)0);
}
}
#line 801 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool match_an_address_p(struct addr *addr , struct input *input ) 
{ 
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 806
  if ((unsigned int )addr->addr_type == 0U) {
#line 806
    goto case_0;
  }
#line 809
  if ((unsigned int )addr->addr_type == 1U) {
#line 809
    goto case_1;
  }
#line 813
  if ((unsigned int )addr->addr_type == 3U) {
#line 813
    goto case_3;
  }
#line 819
  if ((unsigned int )addr->addr_type == 5U) {
#line 819
    goto case_5;
  }
#line 819
  if ((unsigned int )addr->addr_type == 4U) {
#line 819
    goto case_5;
  }
#line 825
  if ((unsigned int )addr->addr_type == 6U) {
#line 825
    goto case_6;
  }
#line 828
  if ((unsigned int )addr->addr_type == 2U) {
#line 828
    goto case_2;
  }
#line 832
  goto switch_default;
  case_0: /* CIL Label */ 
#line 807
  return ((_Bool)1);
  case_1: /* CIL Label */ 
  {
#line 810
  tmp = match_regex(addr->addr_regex, line.active, line.length, (size_t )0, (struct re_registers *)((void *)0),
                    0);
  }
#line 810
  return ((_Bool )tmp);
  case_3: /* CIL Label */ 
#line 814
  if (input->line_number >= addr->addr_number) {
#line 814
    if ((input->line_number - addr->addr_number) % addr->addr_step == 0UL) {
#line 814
      tmp___0 = 1;
    } else {
#line 814
      tmp___0 = 0;
    }
  } else {
#line 814
    tmp___0 = 0;
  }
#line 814
  return ((_Bool )tmp___0);
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 823
  return ((_Bool )(addr->addr_number <= input->line_number));
  case_6: /* CIL Label */ 
  {
#line 826
  tmp___1 = test_eof(input);
  }
#line 826
  return (tmp___1);
  case_2: /* CIL Label */ 
#line 830
  return ((_Bool )(addr->addr_number == input->line_number));
  switch_default: /* CIL Label */ 
  {
#line 833
  panic("INTERNAL ERROR: bad address type");
  }
  switch_break: /* CIL Label */ ;
  }
#line 836
  return ((_Bool)0);
}
}
#line 840 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static _Bool match_address_p(struct sed_cmd *cmd , struct input *input ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
#line 843
  if (! cmd->a1) {
#line 844
    return ((_Bool)1);
  }
#line 846
  if ((unsigned int )cmd->range_state != 1U) {
#line 848
    if (! cmd->a2) {
      {
#line 849
      tmp = match_an_address_p(cmd->a1, input);
      }
#line 849
      return (tmp);
    }
#line 854
    if ((unsigned int )(cmd->a1)->addr_type == 2U) {
#line 856
      if ((unsigned int )cmd->range_state == 2U) {
#line 858
        return ((_Bool)0);
      } else
#line 856
      if (input->line_number < (cmd->a1)->addr_number) {
#line 858
        return ((_Bool)0);
      }
    } else {
      {
#line 862
      tmp___0 = match_an_address_p(cmd->a1, input);
      }
#line 862
      if (! tmp___0) {
#line 863
        return ((_Bool)0);
      }
    }
#line 867
    cmd->range_state = (enum addr_state )1;
    {
#line 870
    if ((unsigned int )(cmd->a2)->addr_type == 1U) {
#line 870
      goto case_1;
    }
#line 873
    if ((unsigned int )(cmd->a2)->addr_type == 2U) {
#line 873
      goto case_2;
    }
#line 879
    if ((unsigned int )(cmd->a2)->addr_type == 4U) {
#line 879
      goto case_4;
    }
#line 882
    if ((unsigned int )(cmd->a2)->addr_type == 5U) {
#line 882
      goto case_5;
    }
#line 886
    goto switch_default;
    case_1: /* CIL Label */ 
#line 872
    return ((_Bool)1);
    case_2: /* CIL Label */ 
#line 875
    if (input->line_number >= (cmd->a2)->addr_number) {
#line 876
      cmd->range_state = (enum addr_state )2;
    }
#line 877
    if (input->line_number <= (cmd->a2)->addr_number) {
#line 877
      tmp___2 = 1;
    } else {
      {
#line 877
      tmp___1 = match_an_address_p(cmd->a1, input);
      }
#line 877
      if (tmp___1) {
#line 877
        tmp___2 = 1;
      } else {
#line 877
        tmp___2 = 0;
      }
    }
#line 877
    return ((_Bool )tmp___2);
    case_4: /* CIL Label */ 
#line 880
    (cmd->a2)->addr_number = input->line_number + (cmd->a2)->addr_step;
#line 881
    return ((_Bool)1);
    case_5: /* CIL Label */ 
#line 883
    (cmd->a2)->addr_number = (input->line_number + (cmd->a2)->addr_step) - input->line_number % (cmd->a2)->addr_step;
#line 885
    return ((_Bool)1);
    switch_default: /* CIL Label */ 
#line 887
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 894
  if ((unsigned int )(cmd->a2)->addr_type == 2U) {
#line 900
    if (input->line_number >= (cmd->a2)->addr_number) {
#line 901
      cmd->range_state = (enum addr_state )2;
    }
#line 903
    return ((_Bool )(input->line_number <= (cmd->a2)->addr_number));
  }
  {
#line 907
  tmp___3 = match_an_address_p(cmd->a2, input);
  }
#line 907
  if (tmp___3) {
#line 908
    cmd->range_state = (enum addr_state )2;
  }
#line 910
  return ((_Bool)1);
}
}
#line 914 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void do_list(int line_len ) 
{ 
  unsigned char *p ;
  countT len ;
  countT width ;
  char obuf[180] ;
  char *o ;
  size_t olen ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  countT tmp___11 ;

  {
  {
#line 917
  p = (unsigned char *)line.active;
#line 918
  len = line.length;
#line 919
  width = (countT )0;
#line 923
  fp = output_file.fp;
#line 925
  output_missing_newline(& output_file);
  }
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    tmp___11 = len;
#line 926
    len --;
#line 926
    if (! tmp___11) {
#line 926
      goto while_break;
    }
#line 927
    o = obuf;
#line 933
    if (((int )*p & -128) == 0) {
      {
#line 933
      tmp___10 = __ctype_b_loc();
      }
#line 933
      if ((int const   )*(*tmp___10 + (int )*p) & 16384) {
#line 937
        tmp = o;
#line 937
        o ++;
#line 937
        *tmp = (char )*p;
#line 938
        if ((int )*p == 92) {
#line 939
          tmp___0 = o;
#line 939
          o ++;
#line 939
          *tmp___0 = (char )'\\';
        }
      } else {
#line 933
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 941
      tmp___1 = o;
#line 941
      o ++;
#line 941
      *tmp___1 = (char )'\\';
      {
#line 944
      if ((int )*p == 7) {
#line 944
        goto case_7;
      }
#line 948
      if ((int )*p == 8) {
#line 948
        goto case_8;
      }
#line 949
      if ((int )*p == 12) {
#line 949
        goto case_12;
      }
#line 950
      if ((int )*p == 10) {
#line 950
        goto case_10;
      }
#line 951
      if ((int )*p == 13) {
#line 951
        goto case_13;
      }
#line 952
      if ((int )*p == 9) {
#line 952
        goto case_9;
      }
#line 953
      if ((int )*p == 11) {
#line 953
        goto case_11;
      }
#line 954
      goto switch_default;
      case_7: /* CIL Label */ 
#line 944
      tmp___2 = o;
#line 944
      o ++;
#line 944
      *tmp___2 = (char )'a';
#line 944
      goto switch_break;
      case_8: /* CIL Label */ 
#line 948
      tmp___3 = o;
#line 948
      o ++;
#line 948
      *tmp___3 = (char )'b';
#line 948
      goto switch_break;
      case_12: /* CIL Label */ 
#line 949
      tmp___4 = o;
#line 949
      o ++;
#line 949
      *tmp___4 = (char )'f';
#line 949
      goto switch_break;
      case_10: /* CIL Label */ 
#line 950
      tmp___5 = o;
#line 950
      o ++;
#line 950
      *tmp___5 = (char )'n';
#line 950
      goto switch_break;
      case_13: /* CIL Label */ 
#line 951
      tmp___6 = o;
#line 951
      o ++;
#line 951
      *tmp___6 = (char )'r';
#line 951
      goto switch_break;
      case_9: /* CIL Label */ 
#line 952
      tmp___7 = o;
#line 952
      o ++;
#line 952
      *tmp___7 = (char )'t';
#line 952
      goto switch_break;
      case_11: /* CIL Label */ 
#line 953
      tmp___8 = o;
#line 953
      o ++;
#line 953
      *tmp___8 = (char )'v';
#line 953
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 955
      sprintf((char */* __restrict  */)o, (char const   */* __restrict  */)"%03o",
              (int )*p);
#line 956
      tmp___9 = strlen((char const   *)o);
#line 956
      o += tmp___9;
      }
#line 957
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 960
    olen = (size_t )(o - obuf);
#line 961
    if (width + olen >= (countT )line_len) {
#line 961
      if (line_len > 0) {
        {
#line 962
        ck_fwrite((void const   *)"\\", (size_t )1, (size_t )1, fp);
#line 963
        ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, fp);
#line 964
        width = (countT )0;
        }
      }
    }
    {
#line 966
    ck_fwrite((void const   *)(obuf), (size_t )1, olen, fp);
#line 967
    width += olen;
#line 926
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 969
  ck_fwrite((void const   *)"$", (size_t )1, (size_t )1, fp);
#line 970
  ck_fwrite((void const   *)(& buffer_delimiter), (size_t )1, (size_t )1, fp);
#line 971
  flush_output(fp);
  }
#line 972
  return;
}
}
#line 975 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void append_replacement(struct line *buf , struct replacement *p , struct re_registers *regs___0 ) 
{ 
  enum replacement_types repl_mod ;
  int i ;
  enum replacement_types curr_type ;

  {
#line 978
  repl_mod = (enum replacement_types )0;
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (! p) {
#line 980
      goto while_break;
    }
#line 982
    i = p->subst_id;
#line 988
    if ((unsigned int )p->repl_type & 12U) {
#line 988
      curr_type = p->repl_type;
    } else {
#line 988
      curr_type = (enum replacement_types )((unsigned int )p->repl_type | (unsigned int )repl_mod);
    }
#line 992
    repl_mod = (enum replacement_types )0;
#line 993
    if (p->prefix_length) {
      {
#line 995
      str_append_modified(buf, (char const   *)p->prefix, p->prefix_length, curr_type);
#line 997
      curr_type = (enum replacement_types )((unsigned int )curr_type & 4294967283U);
      }
    }
#line 1000
    if (0 <= i) {
#line 1002
      if (*(regs___0->end + i) == *(regs___0->start + i)) {
#line 1002
        if ((unsigned int )p->repl_type & 12U) {
#line 1006
          repl_mod = (enum replacement_types )((unsigned int )curr_type & 12U);
        } else {
#line 1002
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1008
      if (*(regs___0->end + i) != *(regs___0->start + i)) {
        {
#line 1009
        str_append_modified(buf, (char const   *)(line.active + *(regs___0->start + i)),
                            (size_t )(*(regs___0->end + i) - *(regs___0->start + i)),
                            curr_type);
        }
      }
    }
#line 980
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1014
  return;
}
}
#line 1024 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static struct re_registers regs  ;
#line 1016 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void do_subst(struct subst *sub ) 
{ 
  size_t start ;
  size_t last_end ;
  countT count ;
  _Bool again ;
  int tmp ;
  size_t offset ;
  size_t matched ;
  int tmp___0 ;
  FILE *pipe_fp ;
  char buf[4096] ;
  int n ;
  size_t tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1019
  start = (size_t )0;
#line 1020
  last_end = (size_t )0;
#line 1021
  count = (countT )0;
#line 1022
  again = (_Bool)1;
#line 1026
  line_reset(& s_accum, & line);
#line 1030
  tmp = match_regex(sub->regx, line.active, line.length, start, & regs, (int )(sub->max_id + 1U));
  }
#line 1030
  if (! tmp) {
#line 1032
    return;
  }
#line 1034
  if (! sub->replacement) {
#line 1034
    if (sub->numb <= 1UL) {
#line 1036
      if (*(regs.start + 0) == 0) {
#line 1036
        if (! sub->global) {
#line 1039
          replaced = (_Bool)1;
#line 1041
          line.active += *(regs.end + 0);
#line 1042
          line.length -= (size_t )*(regs.end + 0);
#line 1043
          line.alloc -= (size_t )*(regs.end + 0);
#line 1044
          goto post_subst;
        } else {
#line 1036
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1046
      if ((size_t )*(regs.end + 0) == line.length) {
#line 1049
        replaced = (_Bool)1;
#line 1051
        line.length = (size_t )*(regs.start + 0);
#line 1052
        goto post_subst;
      }
    }
  }
  {
#line 1056
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1058
    offset = (size_t )*(regs.start + 0);
#line 1059
    matched = (size_t )(*(regs.end + 0) - *(regs.start + 0));
#line 1062
    if (start < offset) {
      {
#line 1063
      str_append(& s_accum, (char const   *)(line.active + start), offset - start);
      }
    }
#line 1074
    if (matched > 0UL) {
#line 1074
      goto _L___1;
    } else
#line 1074
    if (count == 0UL) {
#line 1074
      goto _L___1;
    } else
#line 1074
    if (offset > last_end) {
      _L___1: /* CIL Label */ 
#line 1074
      count ++;
#line 1074
      if (count >= sub->numb) {
        {
#line 1078
        replaced = (_Bool)1;
#line 1081
        append_replacement(& s_accum, sub->replacement, & regs);
#line 1082
        again = (_Bool )sub->global;
        }
      } else {
#line 1074
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 1089
      if (matched == 0UL) {
#line 1091
        if (start < line.length) {
#line 1092
          matched = (size_t )1;
        } else {
#line 1094
          goto while_break;
        }
      }
      {
#line 1097
      str_append(& s_accum, (char const   *)(line.active + offset), matched);
      }
    }
#line 1103
    start = offset + matched;
#line 1104
    last_end = (size_t )*(regs.end + 0);
#line 1056
    if (again) {
#line 1056
      if (start <= line.length) {
        {
#line 1056
        tmp___0 = match_regex(sub->regx, line.active, line.length, start, & regs,
                              (int )(sub->max_id + 1U));
        }
#line 1056
        if (! tmp___0) {
#line 1056
          goto while_break;
        }
      } else {
#line 1056
        goto while_break;
      }
    } else {
#line 1056
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1112
  if (start < line.length) {
    {
#line 1113
    str_append(& s_accum, (char const   *)(line.active + start), line.length - start);
    }
  }
  {
#line 1114
  s_accum.chomped = line.chomped;
#line 1118
  line_exchange(& line, & s_accum, 0);
  }
#line 1121
  if (count < sub->numb) {
#line 1122
    return;
  }
  post_subst: 
#line 1125
  if (sub->print & 1U) {
    {
#line 1126
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1128
  if (sub->eval) {
    {
#line 1132
    line_reset(& s_accum, (struct line *)((void *)0));
#line 1134
    str_append(& line, "", (size_t )1);
#line 1135
    pipe_fp = popen((char const   *)line.active, "r");
    }
#line 1137
    if ((unsigned long )pipe_fp != (unsigned long )((void *)0)) {
      {
#line 1139
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1139
        tmp___2 = feof_unlocked(pipe_fp);
        }
#line 1139
        if (tmp___2) {
#line 1139
          goto while_break___0;
        }
        {
#line 1142
        tmp___1 = fread_unlocked((void */* __restrict  */)(buf), sizeof(char ), (size_t )4096,
                                 (FILE */* __restrict  */)pipe_fp);
#line 1142
        n = (int )tmp___1;
        }
#line 1143
        if (n > 0) {
          {
#line 1144
          str_append(& s_accum, (char const   *)(buf), (size_t )n);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1147
      pclose(pipe_fp);
#line 1152
      line_exchange(& line, & s_accum, 1);
      }
#line 1153
      if (line.length) {
#line 1153
        if ((int )*(line.active + (line.length - 1UL)) == (int )buffer_delimiter) {
#line 1155
          (line.length) --;
        }
      }
    } else {
      {
#line 1158
      tmp___3 = gettext("error in subprocess");
#line 1158
      panic((char const   *)tmp___3);
      }
    }
  }
#line 1164
  if (sub->print & 2U) {
    {
#line 1165
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1166
  if (sub->outf) {
    {
#line 1167
    output_line((char const   *)line.active, line.length, (int )line.chomped, sub->outf);
    }
  }
#line 1168
  return;
}
}
#line 1223 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static void translate_mb(char * const  *trans ) 
{ 
  size_t idx ;
  mbstate_t mbstate ;
  unsigned int i ;
  size_t mbclen ;
  size_t tmp ;
  size_t tmp___0 ;
  _Bool move_remain_buffer ;
  char const   *tr ;
  size_t trans_len ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t new_len ;
  size_t prev_idx ;
  char const   *move_from ;
  char *move_to ;
  size_t move_len ;
  size_t move_offset ;
  int tmp___3 ;

  {
#line 1227
  mbstate.__count = 0;
#line 1227
  mbstate.__value.__wch = 0U;
#line 1228
  idx = (size_t )0;
  {
#line 1228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1228
    if (! (idx < line.length)) {
#line 1228
      goto while_break;
    }
#line 1231
    if (mb_cur_max == 1) {
#line 1231
      tmp___0 = (size_t )1;
    } else {
      {
#line 1231
      tmp = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(line.active + idx),
                        line.length - idx, & mbstate);
#line 1231
      tmp___0 = tmp;
      }
    }
#line 1231
    mbclen = tmp___0;
#line 1235
    if (mbclen == 0xffffffffffffffffUL) {
#line 1236
      mbclen = (size_t )1;
    } else
#line 1235
    if (mbclen == 0xfffffffffffffffeUL) {
#line 1236
      mbclen = (size_t )1;
    } else
#line 1235
    if (mbclen == 0UL) {
#line 1236
      mbclen = (size_t )1;
    }
#line 1239
    i = 0U;
    {
#line 1239
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1239
      if (! ((unsigned long )*(trans + 2U * i) != (unsigned long )((void *)0))) {
#line 1239
        goto while_break___0;
      }
      {
#line 1241
      tmp___3 = strncmp((char const   *)(line.active + idx), (char const   *)*(trans + 2U * i),
                        mbclen);
      }
#line 1241
      if (tmp___3 == 0) {
#line 1243
        move_remain_buffer = (_Bool)0;
#line 1244
        tr = (char const   *)*(trans + (2U * i + 1U));
#line 1245
        if ((int const   )*tr == 0) {
#line 1245
          tmp___2 = (size_t )1;
        } else {
          {
#line 1245
          tmp___1 = strlen(tr);
#line 1245
          tmp___2 = tmp___1;
          }
        }
#line 1245
        trans_len = tmp___2;
#line 1247
        if (mbclen < trans_len) {
#line 1249
          new_len = ((line.length + 1UL) + trans_len) - mbclen;
#line 1252
          if (line.alloc < new_len) {
            {
#line 1255
            resize_line(& line, new_len);
            }
          }
#line 1257
          move_remain_buffer = (_Bool)1;
        } else
#line 1259
        if (mbclen > trans_len) {
#line 1262
          move_remain_buffer = (_Bool)1;
        }
#line 1264
        prev_idx = idx;
#line 1265
        if (move_remain_buffer) {
          {
#line 1268
          move_from = (char const   *)((line.active + idx) + mbclen);
#line 1269
          move_to = (line.active + idx) + trans_len;
#line 1270
          move_len = ((line.length + 1UL) - idx) - mbclen;
#line 1271
          move_offset = trans_len - mbclen;
#line 1272
          memmove((void *)move_to, (void const   *)move_from, move_len);
#line 1273
          line.length += move_offset;
#line 1274
          idx += move_offset;
          }
        }
        {
#line 1276
        memcpy((void */* __restrict  */)(line.active + prev_idx), (void const   */* __restrict  */)*(trans + (2U * i + 1U)),
               trans_len);
        }
#line 1278
        goto while_break___0;
      }
#line 1239
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1281
    idx += mbclen;
  }
  while_break: /* CIL Label */ ;
  }
#line 1283
  return;
}
}
#line 1287 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static int execute_program(struct vector *vec , struct input *input ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct sed_cmd *end_cmd ;
  struct append_queue *aq ;
  struct append_queue *tmp ;
  char *p ;
  void *tmp___0 ;
  FILE *pipe_fp ;
  int cmd_length ;
  char *tmp___1 ;
  char buf[4096] ;
  int n ;
  size_t tmp___2 ;
  int tmp___3 ;
  countT tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  char *p___0 ;
  void *tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  int tmp___12 ;
  struct append_queue *aq___0 ;
  struct append_queue *tmp___13 ;
  struct append_queue *aq___1 ;
  size_t buflen ;
  char *text ;
  int result ;
  size_t tmp___14 ;
  int tmp___15 ;
  char *p___1 ;
  void *tmp___16 ;
  int tmp___17 ;
  size_t tmp___18 ;
  unsigned char *p___2 ;
  unsigned char *e ;
  _Bool tmp___19 ;

  {
#line 1293
  cur_cmd = vec->v;
#line 1294
  end_cmd = vec->v + vec->v_length;
  {
#line 1295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1295
    if (! ((unsigned long )cur_cmd < (unsigned long )end_cmd)) {
#line 1295
      goto while_break;
    }
    {
#line 1297
    tmp___19 = match_address_p(cur_cmd, input);
    }
#line 1297
    if ((int )tmp___19 != (int )cur_cmd->addr_bang) {
      {
#line 1301
      if ((int )cur_cmd->cmd == 97) {
#line 1301
        goto case_97;
      }
#line 1310
      if ((int )cur_cmd->cmd == 98) {
#line 1310
        goto case_98;
      }
#line 1310
      if ((int )cur_cmd->cmd == 123) {
#line 1310
        goto case_98;
      }
#line 1316
      if ((int )cur_cmd->cmd == 58) {
#line 1316
        goto case_58;
      }
#line 1316
      if ((int )cur_cmd->cmd == 35) {
#line 1316
        goto case_58;
      }
#line 1316
      if ((int )cur_cmd->cmd == 125) {
#line 1316
        goto case_58;
      }
#line 1320
      if ((int )cur_cmd->cmd == 99) {
#line 1320
        goto case_99;
      }
#line 1328
      if ((int )cur_cmd->cmd == 100) {
#line 1328
        goto case_100;
      }
#line 1331
      if ((int )cur_cmd->cmd == 68) {
#line 1331
        goto case_68;
      }
#line 1347
      if ((int )cur_cmd->cmd == 101) {
#line 1347
        goto case_101;
      }
#line 1403
      if ((int )cur_cmd->cmd == 103) {
#line 1403
        goto case_103;
      }
#line 1414
      if ((int )cur_cmd->cmd == 71) {
#line 1414
        goto case_71;
      }
#line 1423
      if ((int )cur_cmd->cmd == 104) {
#line 1423
        goto case_104;
      }
#line 1428
      if ((int )cur_cmd->cmd == 72) {
#line 1428
        goto case_72;
      }
#line 1433
      if ((int )cur_cmd->cmd == 105) {
#line 1433
        goto case_105;
      }
#line 1439
      if ((int )cur_cmd->cmd == 108) {
#line 1439
        goto case_108;
      }
#line 1445
      if ((int )cur_cmd->cmd == 110) {
#line 1445
        goto case_110;
      }
#line 1453
      if ((int )cur_cmd->cmd == 78) {
#line 1453
        goto case_78;
      }
#line 1466
      if ((int )cur_cmd->cmd == 112) {
#line 1466
        goto case_112;
      }
#line 1470
      if ((int )cur_cmd->cmd == 80) {
#line 1470
        goto case_80;
      }
#line 1478
      if ((int )cur_cmd->cmd == 113) {
#line 1478
        goto case_113;
      }
#line 1485
      if ((int )cur_cmd->cmd == 81) {
#line 1485
        goto case_81;
      }
#line 1488
      if ((int )cur_cmd->cmd == 114) {
#line 1488
        goto case_114;
      }
#line 1496
      if ((int )cur_cmd->cmd == 82) {
#line 1496
        goto case_82;
      }
#line 1516
      if ((int )cur_cmd->cmd == 115) {
#line 1516
        goto case_115;
      }
#line 1520
      if ((int )cur_cmd->cmd == 116) {
#line 1520
        goto case_116;
      }
#line 1529
      if ((int )cur_cmd->cmd == 84) {
#line 1529
        goto case_84;
      }
#line 1539
      if ((int )cur_cmd->cmd == 119) {
#line 1539
        goto case_119;
      }
#line 1545
      if ((int )cur_cmd->cmd == 87) {
#line 1545
        goto case_87;
      }
#line 1554
      if ((int )cur_cmd->cmd == 120) {
#line 1554
        goto case_120;
      }
#line 1559
      if ((int )cur_cmd->cmd == 121) {
#line 1559
        goto case_121;
      }
#line 1571
      if ((int )cur_cmd->cmd == 122) {
#line 1571
        goto case_122;
      }
#line 1575
      if ((int )cur_cmd->cmd == 61) {
#line 1575
        goto case_61;
      }
#line 1583
      if ((int )cur_cmd->cmd == 70) {
#line 1583
        goto case_70;
      }
#line 1591
      goto switch_default;
      case_97: /* CIL Label */ 
      {
#line 1303
      tmp = next_append_slot();
#line 1303
      aq = tmp;
#line 1304
      aq->text = cur_cmd->x.cmd_txt.text;
#line 1305
      aq->textlen = cur_cmd->x.cmd_txt.text_length;
      }
#line 1307
      goto switch_break;
      case_98: /* CIL Label */ 
      case_123: /* CIL Label */ 
#line 1311
      cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1312
      goto while_continue;
      case_58: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_125: /* CIL Label */ 
#line 1318
      goto switch_break;
      case_99: /* CIL Label */ 
#line 1321
      if ((unsigned int )cur_cmd->range_state != 1U) {
        {
#line 1322
        output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                    1, & output_file);
        }
      }
      case_100: /* CIL Label */ 
#line 1329
      return (-1);
      case_68: /* CIL Label */ 
      {
#line 1333
      tmp___0 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1333
      p = (char *)tmp___0;
      }
#line 1334
      if (! p) {
#line 1335
        return (-1);
      }
#line 1337
      p ++;
#line 1338
      line.alloc -= (size_t )(p - line.active);
#line 1339
      line.length -= (size_t )(p - line.active);
#line 1340
      line.active += p - line.active;
#line 1343
      cur_cmd = vec->v;
#line 1344
      goto while_continue;
      case_101: /* CIL Label */ 
      {
#line 1352
      cmd_length = (int )cur_cmd->x.cmd_txt.text_length;
#line 1353
      line_reset(& s_accum, (struct line *)((void *)0));
      }
#line 1355
      if (! cmd_length) {
        {
#line 1357
        str_append(& line, "", (size_t )1);
#line 1358
        pipe_fp = popen((char const   *)line.active, "r");
        }
      } else {
        {
#line 1362
        *(cur_cmd->x.cmd_txt.text + (cmd_length - 1)) = (char)0;
#line 1363
        pipe_fp = popen((char const   *)cur_cmd->x.cmd_txt.text, "r");
#line 1364
        output_missing_newline(& output_file);
        }
      }
#line 1367
      if ((unsigned long )pipe_fp == (unsigned long )((void *)0)) {
        {
#line 1368
        tmp___1 = gettext("error in subprocess");
#line 1368
        panic((char const   *)tmp___1);
        }
      }
      {
#line 1373
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1373
        tmp___3 = feof_unlocked(pipe_fp);
        }
#line 1373
        if (tmp___3) {
#line 1373
          goto while_break___0;
        }
        {
#line 1374
        tmp___2 = fread_unlocked((void */* __restrict  */)(buf), sizeof(char ), (size_t )4096,
                                 (FILE */* __restrict  */)pipe_fp);
#line 1374
        n = (int )tmp___2;
        }
#line 1374
        if (n > 0) {
#line 1376
          if (! cmd_length) {
            {
#line 1377
            str_append(& s_accum, (char const   *)(buf), (size_t )n);
            }
          } else {
            {
#line 1379
            ck_fwrite((void const   *)(buf), (size_t )1, (size_t )n, output_file.fp);
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1382
      pclose(pipe_fp);
      }
#line 1383
      if (! cmd_length) {
#line 1386
        if (s_accum.length) {
#line 1386
          if ((int )*(s_accum.active + (s_accum.length - 1UL)) == (int )buffer_delimiter) {
#line 1388
            (s_accum.length) --;
          }
        }
        {
#line 1394
        line_exchange(& line, & s_accum, 1);
        }
      } else {
        {
#line 1397
        flush_output(output_file.fp);
        }
      }
#line 1400
      goto switch_break;
      case_103: /* CIL Label */ 
      {
#line 1411
      line_copy(& hold, & line, 1);
      }
#line 1412
      goto switch_break;
      case_71: /* CIL Label */ 
      {
#line 1420
      line_append(& hold, & line, 1);
      }
#line 1421
      goto switch_break;
      case_104: /* CIL Label */ 
      {
#line 1425
      line_copy(& line, & hold, 1);
      }
#line 1426
      goto switch_break;
      case_72: /* CIL Label */ 
      {
#line 1430
      line_append(& line, & hold, 1);
      }
#line 1431
      goto switch_break;
      case_105: /* CIL Label */ 
      {
#line 1434
      output_line((char const   *)cur_cmd->x.cmd_txt.text, cur_cmd->x.cmd_txt.text_length - 1UL,
                  1, & output_file);
      }
#line 1437
      goto switch_break;
      case_108: /* CIL Label */ 
#line 1440
      if (cur_cmd->x.int_arg == -1) {
#line 1440
        tmp___4 = lcmd_out_line_len;
      } else {
#line 1440
        tmp___4 = (countT )cur_cmd->x.int_arg;
      }
      {
#line 1440
      do_list((int )tmp___4);
      }
#line 1443
      goto switch_break;
      case_110: /* CIL Label */ 
#line 1446
      if (! no_default_output) {
        {
#line 1447
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    & output_file);
        }
      }
      {
#line 1449
      tmp___5 = test_eof(input);
      }
#line 1449
      if (tmp___5) {
#line 1450
        return (-1);
      } else {
        {
#line 1449
        tmp___6 = read_pattern_space(input, vec, 0);
        }
#line 1449
        if (! tmp___6) {
#line 1450
          return (-1);
        }
      }
#line 1451
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 1454
      str_append(& line, (char const   *)(& buffer_delimiter), (size_t )1);
#line 1456
      tmp___7 = test_eof(input);
      }
#line 1456
      if (tmp___7) {
#line 1456
        goto _L;
      } else {
        {
#line 1456
        tmp___8 = read_pattern_space(input, vec, 1);
        }
#line 1456
        if (! tmp___8) {
          _L: /* CIL Label */ 
#line 1458
          (line.length) --;
#line 1459
          if ((unsigned int )posixicity == 0U) {
#line 1459
            if (! no_default_output) {
              {
#line 1460
              output_line((char const   *)line.active, line.length, (int )line.chomped,
                          & output_file);
              }
            }
          }
#line 1462
          return (-1);
        }
      }
#line 1464
      goto switch_break;
      case_112: /* CIL Label */ 
      {
#line 1467
      output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
      }
#line 1468
      goto switch_break;
      case_80: /* CIL Label */ 
      {
#line 1472
      tmp___9 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1472
      p___0 = (char *)tmp___9;
      }
#line 1473
      if (p___0) {
#line 1473
        tmp___10 = 1;
      } else {
#line 1473
        tmp___10 = (int )line.chomped;
      }
#line 1473
      if (p___0) {
#line 1473
        tmp___11 = (size_t )(p___0 - line.active);
      } else {
#line 1473
        tmp___11 = line.length;
      }
      {
#line 1473
      output_line((char const   *)line.active, tmp___11, tmp___10, & output_file);
      }
#line 1476
      goto switch_break;
      case_113: /* CIL Label */ 
#line 1479
      if (! no_default_output) {
        {
#line 1480
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    & output_file);
        }
      }
      {
#line 1482
      dump_append_queue();
      }
      case_81: /* CIL Label */ 
#line 1486
      if (cur_cmd->x.int_arg == -1) {
#line 1486
        tmp___12 = 0;
      } else {
#line 1486
        tmp___12 = cur_cmd->x.int_arg;
      }
#line 1486
      return (tmp___12);
      case_114: /* CIL Label */ 
#line 1489
      if (cur_cmd->x.fname) {
        {
#line 1491
        tmp___13 = next_append_slot();
#line 1491
        aq___0 = tmp___13;
#line 1492
        aq___0->fname = (char const   *)cur_cmd->x.fname;
        }
      }
#line 1494
      goto switch_break;
      case_82: /* CIL Label */ 
#line 1497
      if (cur_cmd->x.fp) {
        {
#line 1497
        tmp___15 = feof_unlocked(cur_cmd->x.fp);
        }
#line 1497
        if (! tmp___15) {
          {
#line 1501
          text = (char *)((void *)0);
#line 1504
          tmp___14 = ck_getdelim(& text, & buflen, buffer_delimiter, cur_cmd->x.fp);
#line 1504
          result = (int )tmp___14;
          }
#line 1506
          if (result != -1) {
            {
#line 1508
            aq___1 = next_append_slot();
#line 1509
            aq___1->free = (_Bool)1;
#line 1510
            aq___1->text = text;
#line 1511
            aq___1->textlen = (size_t )result;
            }
          }
        }
      }
#line 1514
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 1517
      do_subst(cur_cmd->x.cmd_subst);
      }
#line 1518
      goto switch_break;
      case_116: /* CIL Label */ 
#line 1521
      if (replaced) {
#line 1523
        replaced = (_Bool)0;
#line 1524
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1525
        goto while_continue;
      }
#line 1527
      goto switch_break;
      case_84: /* CIL Label */ 
#line 1530
      if (! replaced) {
#line 1532
        cur_cmd = vec->v + cur_cmd->x.jump_index;
#line 1533
        goto while_continue;
      } else {
#line 1536
        replaced = (_Bool)0;
      }
#line 1537
      goto switch_break;
      case_119: /* CIL Label */ 
#line 1540
      if (cur_cmd->x.fp) {
        {
#line 1541
        output_line((char const   *)line.active, line.length, (int )line.chomped,
                    cur_cmd->x.outf);
        }
      }
#line 1543
      goto switch_break;
      case_87: /* CIL Label */ 
#line 1546
      if (cur_cmd->x.fp) {
        {
#line 1548
        tmp___16 = memchr((void const   *)line.active, (int )buffer_delimiter, line.length);
#line 1548
        p___1 = (char *)tmp___16;
        }
#line 1549
        if (p___1) {
#line 1549
          tmp___17 = 1;
        } else {
#line 1549
          tmp___17 = (int )line.chomped;
        }
#line 1549
        if (p___1) {
#line 1549
          tmp___18 = (size_t )(p___1 - line.active);
        } else {
#line 1549
          tmp___18 = line.length;
        }
        {
#line 1549
        output_line((char const   *)line.active, tmp___18, tmp___17, cur_cmd->x.outf);
        }
      }
#line 1552
      goto switch_break;
      case_120: /* CIL Label */ 
      {
#line 1556
      line_exchange(& line, & hold, 0);
      }
#line 1557
      goto switch_break;
      case_121: /* CIL Label */ 
#line 1560
      if (mb_cur_max > 1) {
        {
#line 1561
        translate_mb((char * const  *)cur_cmd->x.translatemb);
        }
      } else {
#line 1565
        p___2 = (unsigned char *)line.active;
#line 1566
        e = p___2 + line.length;
        {
#line 1566
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1566
          if (! ((unsigned long )p___2 < (unsigned long )e)) {
#line 1566
            goto while_break___1;
          }
#line 1567
          *p___2 = *(cur_cmd->x.translate + *p___2);
#line 1566
          p___2 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1569
      goto switch_break;
      case_122: /* CIL Label */ 
#line 1572
      line.length = (size_t )0;
#line 1573
      goto switch_break;
      case_61: /* CIL Label */ 
      {
#line 1576
      output_missing_newline(& output_file);
#line 1577
      fprintf((FILE */* __restrict  */)output_file.fp, (char const   */* __restrict  */)"%lu%c",
              input->line_number, (int )buffer_delimiter);
#line 1580
      flush_output(output_file.fp);
      }
#line 1581
      goto switch_break;
      case_70: /* CIL Label */ 
      {
#line 1584
      output_missing_newline(& output_file);
#line 1585
      fprintf((FILE */* __restrict  */)output_file.fp, (char const   */* __restrict  */)"%s%c",
              input->in_file_name, (int )buffer_delimiter);
#line 1588
      flush_output(output_file.fp);
      }
#line 1589
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 1592
      panic("INTERNAL ERROR: Bad cmd %c", (int )cur_cmd->cmd);
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1645
    cur_cmd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1648
  if (! no_default_output) {
    {
#line 1649
    output_line((char const   *)line.active, line.length, (int )line.chomped, & output_file);
    }
  }
#line 1650
  return (-1);
}
}
#line 1659 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static char dash[2]  = {      (char )'-',      (char )'\000'};
#line 1660 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
static char *stdin_argv[2]  = {      dash,      (char *)((void *)0)};
#line 1656 "/home/khheo/project/benchmark/sed-4.3/sed/execute.c"
int process_files(struct vector *the_program___0 , char **argv ) 
{ 
  struct input input ;
  int status ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1664
  line_init(& line, (struct line *)((void *)0), (size_t )50);
#line 1665
  line_init(& hold, (struct line *)((void *)0), (size_t )0);
#line 1666
  line_init(& buffer, (struct line *)((void *)0), (size_t )0);
#line 1671
  input.reset_at_next_file = (_Bool)1;
  }
#line 1672
  if (argv) {
#line 1672
    if (*argv) {
#line 1673
      input.file_list = argv;
    } else {
#line 1672
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1674
  if (in_place_extension) {
    {
#line 1675
    tmp = gettext("no input files");
#line 1675
    panic((char const   *)tmp);
    }
  } else {
#line 1677
    input.file_list = stdin_argv;
  }
#line 1679
  input.bad_count = (countT )0;
#line 1680
  input.line_number = (countT )0;
#line 1681
  input.read_fn = & read_always_fail;
#line 1682
  input.fp = (FILE *)((void *)0);
#line 1684
  status = 0;
  {
#line 1685
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1685
    tmp___0 = read_pattern_space(& input, the_program___0, 0);
    }
#line 1685
    if (! tmp___0) {
#line 1685
      goto while_break;
    }
    {
#line 1687
    status = execute_program(the_program___0, & input);
    }
#line 1688
    if (status == -1) {
#line 1689
      status = 0;
    } else {
#line 1691
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1693
  closedown(& input);
  }
#line 1708
  if (input.bad_count) {
#line 1709
    status = 2;
  }
#line 1711
  return (status);
}
}
#line 689 "/usr/include/stdio.h"
extern long ftell(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 80 "./lib/wctype.h"
#pragma GCC diagnostic push
#line 80
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 80
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 870
#pragma GCC diagnostic pop
#line 466 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strverscmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 80 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static FILE *my_stdin  ;
#line 80 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static FILE *my_stdout  ;
#line 80 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static FILE *my_stderr  ;
#line 81 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct special_files special_files[4]  = {      {{(char *)"/dev/stdin", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdin}, 
        {{(char *)"/dev/stdout", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stdout}, 
        {{(char *)"/dev/stderr", (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      & my_stderr}, 
        {{(char *)((void *)0), (_Bool)0, (FILE *)((void *)0), (struct output *)((void *)0)},
      (FILE **)((void *)0)}};
#line 90 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct prog_info prog  ;
#line 91 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct error_info cur_input  ;
#line 95 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct sed_label *jumps  =    (struct sed_label *)((void *)0);
#line 96 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct sed_label *labels  =    (struct sed_label *)((void *)0);
#line 100 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static _Bool first_script  =    (_Bool)1;
#line 103 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct buffer *pending_text  =    (struct buffer *)((void *)0);
#line 104 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct text_buf *old_text_buf  =    (struct text_buf *)((void *)0);
#line 108 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct sed_label *blocks  =    (struct sed_label *)((void *)0);
#line 111 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct obstack obs  ;
#line 114 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static char const   errors___0[860]  = 
#line 114
  {      (char const   )'m',      (char const   )'u',      (char const   )'l',      (char const   )'t', 
        (char const   )'i',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'`',      (char const   )'!',      (char const   )'\'', 
        (char const   )'s',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )',',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'+',      (char const   )'N', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'~',      (char const   )'N',      (char const   )' ',      (char const   )'a', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'i', 
        (char const   )'r',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'m',      (char const   )'a', 
        (char const   )'t',      (char const   )'c',      (char const   )'h',      (char const   )'e', 
        (char const   )'d',      (char const   )' ',      (char const   )'`',      (char const   )'{', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'e',      (char const   )'x',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )' ',      (char const   )'c', 
        (char const   )'h',      (char const   )'a',      (char const   )'r',      (char const   )'a', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'f', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'a',      (char const   )'\'', 
        (char const   )',',      (char const   )' ',      (char const   )'`',      (char const   )'c', 
        (char const   )'\'',      (char const   )' ',      (char const   )'o',      (char const   )'r', 
        (char const   )' ',      (char const   )'`',      (char const   )'i',      (char const   )'\'', 
        (char const   )'\000',      (char const   )'`',      (char const   )'}',      (char const   )'\'', 
        (char const   )' ',      (char const   )'d',      (char const   )'o',      (char const   )'e', 
        (char const   )'s',      (char const   )'n',      (char const   )'\'',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'a',      (char const   )'n', 
        (char const   )'t',      (char const   )' ',      (char const   )'a',      (char const   )'n', 
        (char const   )'y',      (char const   )' ',      (char const   )'a',      (char const   )'d', 
        (char const   )'d',      (char const   )'r',      (char const   )'e',      (char const   )'s', 
        (char const   )'s',      (char const   )'e',      (char const   )'s',      (char const   )'\000', 
        (char const   )':',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'e',      (char const   )'s',      (char const   )'n',      (char const   )'\'', 
        (char const   )'t',      (char const   )' ',      (char const   )'w',      (char const   )'a', 
        (char const   )'n',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'e',      (char const   )'n',      (char const   )'t', 
        (char const   )'s',      (char const   )' ',      (char const   )'d',      (char const   )'o', 
        (char const   )'n',      (char const   )'\'',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'c',      (char const   )'c',      (char const   )'e', 
        (char const   )'p',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )'n',      (char const   )'y',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'e',      (char const   )'s', 
        (char const   )'\000',      (char const   )'m',      (char const   )'i',      (char const   )'s', 
        (char const   )'s',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'o',      (char const   )'n',      (char const   )'l', 
        (char const   )'y',      (char const   )' ',      (char const   )'u',      (char const   )'s', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'a',      (char const   )'d',      (char const   )'d',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'g',      (char const   )'e', 
        (char const   )'x',      (char const   )'\000',      (char const   )'u',      (char const   )'n', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'m', 
        (char const   )'i',      (char const   )'n',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'`', 
        (char const   )'s',      (char const   )'\'',      (char const   )' ',      (char const   )'c', 
        (char const   )'o',      (char const   )'m',      (char const   )'m',      (char const   )'a', 
        (char const   )'n',      (char const   )'d',      (char const   )'\000',      (char const   )'u', 
        (char const   )'n',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )'m',      (char const   )'i',      (char const   )'n',      (char const   )'a', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'`',      (char const   )'y',      (char const   )'\'',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'m',      (char const   )'m', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'\000', 
        (char const   )'u',      (char const   )'n',      (char const   )'k',      (char const   )'n', 
        (char const   )'o',      (char const   )'w',      (char const   )'n',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'p',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'`', 
        (char const   )'g',      (char const   )'\'',      (char const   )' ',      (char const   )'o', 
        (char const   )'p',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'m',      (char const   )'u', 
        (char const   )'l',      (char const   )'t',      (char const   )'i',      (char const   )'p', 
        (char const   )'l',      (char const   )'e',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'o',      (char const   )'p', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )'s',      (char const   )' ',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'`',      (char const   )'s',      (char const   )'\'', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )'\000',      (char const   )'n',      (char const   )'u',      (char const   )'m', 
        (char const   )'b',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'o',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )' ',      (char const   )'`',      (char const   )'s', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )' ',      (char const   )'z',      (char const   )'e',      (char const   )'r', 
        (char const   )'o',      (char const   )'\000',      (char const   )'s',      (char const   )'t', 
        (char const   )'r',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )'s',      (char const   )' ',      (char const   )'f',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'`',      (char const   )'y', 
        (char const   )'\'',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'f',      (char const   )'f',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'l',      (char const   )'e',      (char const   )'n',      (char const   )'g', 
        (char const   )'t',      (char const   )'h',      (char const   )'s',      (char const   )'\000', 
        (char const   )'d',      (char const   )'e',      (char const   )'l',      (char const   )'i', 
        (char const   )'m',      (char const   )'i',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'n', 
        (char const   )'o',      (char const   )'t',      (char const   )' ',      (char const   )'a', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )'l',      (char const   )'e',      (char const   )'-', 
        (char const   )'b',      (char const   )'y',      (char const   )'t',      (char const   )'e', 
        (char const   )' ',      (char const   )'c',      (char const   )'h',      (char const   )'a', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )'e',      (char const   )'r',      (char const   )'\000',      (char const   )'e', 
        (char const   )'x',      (char const   )'p',      (char const   )'e',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'n',      (char const   )'e',      (char const   )'w',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'d', 
        (char const   )'\000',      (char const   )'i',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'u',      (char const   )'s',      (char const   )'a', 
        (char const   )'g',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'f',      (char const   )' ',      (char const   )'l',      (char const   )'i', 
        (char const   )'n',      (char const   )'e',      (char const   )' ',      (char const   )'a', 
        (char const   )'d',      (char const   )'d',      (char const   )'r',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'0', 
        (char const   )'\000',      (char const   )'u',      (char const   )'n',      (char const   )'k', 
        (char const   )'n',      (char const   )'o',      (char const   )'w',      (char const   )'n', 
        (char const   )' ',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )':',      (char const   )' ',      (char const   )'`',      (char const   )'%', 
        (char const   )'c',      (char const   )'\'',      (char const   )'\000',      (char const   )'i', 
        (char const   )'n',      (char const   )'c',      (char const   )'o',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'\"',      (char const   )':', 
        (char const   )'\"',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )' ', 
        (char const   )'a',      (char const   )' ',      (char const   )'l',      (char const   )'a', 
        (char const   )'b',      (char const   )'e',      (char const   )'l',      (char const   )'\000', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'u', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'s', 
        (char const   )'c',      (char const   )'a',      (char const   )'p',      (char const   )'i', 
        (char const   )'n',      (char const   )'g',      (char const   )' ',      (char const   )'a', 
        (char const   )'f',      (char const   )'t',      (char const   )'e',      (char const   )'r', 
        (char const   )' ',      (char const   )'\\',      (char const   )'c',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )'o', 
        (char const   )'w',      (char const   )'e',      (char const   )'d',      (char const   )'\000', 
        (char const   )'e',      (char const   )'/',      (char const   )'r',      (char const   )'/', 
        (char const   )'w',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'m',      (char const   )'m',      (char const   )'a',      (char const   )'n', 
        (char const   )'d',      (char const   )'s',      (char const   )' ',      (char const   )'d', 
        (char const   )'i',      (char const   )'s',      (char const   )'a',      (char const   )'b', 
        (char const   )'l',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )'b', 
        (char const   )'o',      (char const   )'x',      (char const   )' ',      (char const   )'m', 
        (char const   )'o',      (char const   )'d',      (char const   )'e',      (char const   )'\000'};
#line 194 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct output *file_read  =    (struct output *)((void *)0);
#line 195 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct output *file_write  =    (struct output *)((void *)0);
#line 199 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static void bad_command(char ch ) 
{ 
  char const   *msg ;
  char *tmp ;
  char *unknown_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 202
  tmp = gettext((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0"));
#line 202
  msg = (char const   *)tmp;
#line 203
  tmp___0 = strlen(msg);
#line 203
  tmp___1 = xmalloc(tmp___0);
#line 203
  unknown_cmd = (char *)tmp___1;
#line 204
  sprintf((char */* __restrict  */)unknown_cmd, (char const   */* __restrict  */)msg,
          (int )ch);
#line 205
  bad_prog((char const   *)unknown_cmd);
  }
}
}
#line 209
 __attribute__((__noreturn__)) void bad_prog(char const   *why ) ;
#line 209 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
void bad_prog(char const   *why ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 212
  if (cur_input.name) {
    {
#line 213
    tmp = gettext("%s: file %s line %lu: %s\n");
#line 213
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            myname, cur_input.name, cur_input.line, why);
    }
  } else {
    {
#line 216
    tmp___0 = gettext("%s: -e expression #%lu, char %lu: %s\n");
#line 216
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            myname, cur_input.string_expr_count, (unsigned long )(prog.cur - prog.base),
            why);
    }
  }
  {
#line 221
  exit(1);
  }
}
}
#line 228 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static int inchar(void) 
{ 
  int ch ;
  unsigned char const   *tmp ;
  int tmp___0 ;

  {
#line 231
  ch = -1;
#line 233
  if (prog.cur) {
#line 235
    if ((unsigned long )prog.cur < (unsigned long )prog.end) {
#line 236
      tmp = prog.cur;
#line 236
      (prog.cur) ++;
#line 236
      ch = (int )*tmp;
    }
  } else
#line 238
  if (prog.file) {
    {
#line 240
    tmp___0 = feof_unlocked(prog.file);
    }
#line 240
    if (! tmp___0) {
      {
#line 241
      ch = getc_unlocked(prog.file);
      }
    }
  }
#line 243
  if (ch == 10) {
#line 244
    (cur_input.line) ++;
  }
#line 245
  return (ch);
}
}
#line 249 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static void savchar(int ch ) 
{ 


  {
#line 252
  if (ch == -1) {
#line 253
    return;
  }
#line 254
  if (ch == 10) {
#line 254
    if (cur_input.line > 0UL) {
#line 255
      (cur_input.line) --;
    }
  }
#line 256
  if (prog.cur) {
#line 258
    if ((unsigned long )prog.cur <= (unsigned long )prog.base) {
      {
#line 259
      panic("Called savchar() with unexpected pushback (%x)", (int )((unsigned char )ch));
      }
    } else {
#line 258
      (prog.cur) --;
#line 258
      if ((int const   )*(prog.cur) != (int const   )ch) {
        {
#line 259
        panic("Called savchar() with unexpected pushback (%x)", (int )((unsigned char )ch));
        }
      }
    }
  } else {
    {
#line 263
    ungetc(ch, prog.file);
    }
  }
#line 264
  return;
}
}
#line 267 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static int in_nonblank(void) 
{ 
  int ch ;
  unsigned short const   **tmp ;

  {
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 272
    ch = inchar();
#line 271
    tmp = __ctype_b_loc();
    }
#line 271
    if (! ((int const   )*(*tmp + ch) & 1)) {
#line 271
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (ch);
}
}
#line 278 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static countT in_integer(int ch ) 
{ 
  countT num ;
  unsigned short const   **tmp ;

  {
#line 281
  num = (countT )0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    tmp = __ctype_b_loc();
    }
#line 283
    if (! ((int const   )*(*tmp + (int )((unsigned char )ch)) & 2048)) {
#line 283
      goto while_break;
    }
    {
#line 285
    num = (num * 10UL + (countT )ch) - 48UL;
#line 286
    ch = inchar();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  savchar(ch);
  }
#line 289
  return (num);
}
}
#line 292 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static int add_then_next(struct buffer *b___0 , int ch ) 
{ 
  int tmp ;

  {
  {
#line 295
  add1_buffer(b___0, ch);
#line 296
  tmp = inchar();
  }
#line 296
  return (tmp);
}
}
#line 299 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static char *convert_number(char *result , char *buf , char const   *bufend , int base ) 
{ 
  int n ;
  int max ;
  char *p ;
  int d ;

  {
#line 302
  n = 0;
#line 303
  max = 1;
#line 306
  p = buf + 1;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if ((unsigned long )p < (unsigned long )bufend) {
#line 306
      if (! (max <= 255)) {
#line 306
        goto while_break;
      }
    } else {
#line 306
      goto while_break;
    }
#line 308
    d = -1;
    {
#line 311
    if ((int )*p == 48) {
#line 311
      goto case_48;
    }
#line 312
    if ((int )*p == 49) {
#line 312
      goto case_49;
    }
#line 313
    if ((int )*p == 50) {
#line 313
      goto case_50;
    }
#line 314
    if ((int )*p == 51) {
#line 314
      goto case_51;
    }
#line 315
    if ((int )*p == 52) {
#line 315
      goto case_52;
    }
#line 316
    if ((int )*p == 53) {
#line 316
      goto case_53;
    }
#line 317
    if ((int )*p == 54) {
#line 317
      goto case_54;
    }
#line 318
    if ((int )*p == 55) {
#line 318
      goto case_55;
    }
#line 319
    if ((int )*p == 56) {
#line 319
      goto case_56;
    }
#line 320
    if ((int )*p == 57) {
#line 320
      goto case_57;
    }
#line 321
    if ((int )*p == 97) {
#line 321
      goto case_97;
    }
#line 321
    if ((int )*p == 65) {
#line 321
      goto case_97;
    }
#line 322
    if ((int )*p == 98) {
#line 322
      goto case_98;
    }
#line 322
    if ((int )*p == 66) {
#line 322
      goto case_98;
    }
#line 323
    if ((int )*p == 99) {
#line 323
      goto case_99;
    }
#line 323
    if ((int )*p == 67) {
#line 323
      goto case_99;
    }
#line 324
    if ((int )*p == 100) {
#line 324
      goto case_100;
    }
#line 324
    if ((int )*p == 68) {
#line 324
      goto case_100;
    }
#line 325
    if ((int )*p == 101) {
#line 325
      goto case_101;
    }
#line 325
    if ((int )*p == 69) {
#line 325
      goto case_101;
    }
#line 326
    if ((int )*p == 102) {
#line 326
      goto case_102;
    }
#line 326
    if ((int )*p == 70) {
#line 326
      goto case_102;
    }
#line 309
    goto switch_break;
    case_48: /* CIL Label */ 
#line 311
    d = 0;
#line 311
    goto switch_break;
    case_49: /* CIL Label */ 
#line 312
    d = 1;
#line 312
    goto switch_break;
    case_50: /* CIL Label */ 
#line 313
    d = 2;
#line 313
    goto switch_break;
    case_51: /* CIL Label */ 
#line 314
    d = 3;
#line 314
    goto switch_break;
    case_52: /* CIL Label */ 
#line 315
    d = 4;
#line 315
    goto switch_break;
    case_53: /* CIL Label */ 
#line 316
    d = 5;
#line 316
    goto switch_break;
    case_54: /* CIL Label */ 
#line 317
    d = 6;
#line 317
    goto switch_break;
    case_55: /* CIL Label */ 
#line 318
    d = 7;
#line 318
    goto switch_break;
    case_56: /* CIL Label */ 
#line 319
    d = 8;
#line 319
    goto switch_break;
    case_57: /* CIL Label */ 
#line 320
    d = 9;
#line 320
    goto switch_break;
    case_97: /* CIL Label */ 
    case_65: /* CIL Label */ 
#line 321
    d = 10;
#line 321
    goto switch_break;
    case_98: /* CIL Label */ 
    case_66: /* CIL Label */ 
#line 322
    d = 11;
#line 322
    goto switch_break;
    case_99: /* CIL Label */ 
    case_67: /* CIL Label */ 
#line 323
    d = 12;
#line 323
    goto switch_break;
    case_100: /* CIL Label */ 
    case_68: /* CIL Label */ 
#line 324
    d = 13;
#line 324
    goto switch_break;
    case_101: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 325
    d = 14;
#line 325
    goto switch_break;
    case_102: /* CIL Label */ 
    case_70: /* CIL Label */ 
#line 326
    d = 15;
#line 326
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 328
    if (d < 0) {
#line 329
      goto while_break;
    } else
#line 328
    if (base <= d) {
#line 329
      goto while_break;
    }
#line 330
    n = n * base + d;
#line 306
    p ++;
#line 306
    max *= base;
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  if ((unsigned long )p == (unsigned long )(buf + 1)) {
#line 333
    *result = *buf;
  } else {
#line 335
    *result = (char )n;
  }
#line 336
  return (p);
}
}
#line 341 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct buffer *read_filename(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *tmp ;

  {
#line 347
  if (sandbox) {
    {
#line 348
    tmp = gettext((((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label")) + sizeof("recursive escaping after \\c not allowed"));
#line 348
    bad_prog((char const   *)tmp);
    }
  }
  {
#line 350
  b___0 = init_buffer();
#line 351
  ch = in_nonblank();
  }
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (ch != -1) {
#line 352
      if (! (ch != 10)) {
#line 352
        goto while_break;
      }
    } else {
#line 352
      goto while_break;
    }
    {
#line 362
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  add1_buffer(b___0, '\000');
  }
#line 365
  return (b___0);
}
}
#line 368 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct output *get_openfile(struct output **file_ptrs , char const   *mode ,
                                   int fail ) 
{ 
  struct buffer *b___0 ;
  char *file_name___0 ;
  struct output *p ;
  int tmp ;
  struct special_files *special ;
  int tmp___0 ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 375
  b___0 = read_filename();
#line 376
  file_name___0 = get_buffer((struct buffer  const  *)b___0);
#line 377
  p = *file_ptrs;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! p) {
#line 377
      goto while_break;
    }
    {
#line 378
    tmp = strcmp((char const   *)p->name, (char const   *)file_name___0);
    }
#line 378
    if (tmp == 0) {
#line 379
      goto while_break;
    }
#line 377
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if ((unsigned int )posixicity == 0U) {
#line 384
    special = special_files;
#line 388
    my_stdin = stdin;
#line 388
    my_stdout = stdout;
#line 388
    my_stderr = stderr;
#line 389
    special = special_files;
    {
#line 389
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 389
      if (! special->outf.name) {
#line 389
        goto while_break___0;
      }
      {
#line 390
      tmp___0 = strcmp((char const   *)special->outf.name, (char const   *)file_name___0);
      }
#line 390
      if (tmp___0 == 0) {
        {
#line 392
        special->outf.fp = *(special->pfp);
#line 393
        free_buffer(b___0);
        }
#line 394
        return (& special->outf);
      }
#line 389
      special ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 398
  if (! p) {
#line 400
    __h = & obs;
#line 400
    __o = __h;
#line 400
    __len = sizeof(struct output );
#line 400
    __o1 = (struct obstack  const  *)__o;
#line 400
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 400
      _obstack_newchunk(__o, __len);
      }
    }
#line 400
    __o->next_free += __len;
#line 400
    __o1___0 = __h;
#line 400
    __value = (void *)__o1___0->object_base;
#line 400
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 400
      __o1___0->maybe_empty_object = 1U;
    }
#line 400
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 400
      tmp___1 = __o1___0->object_base;
    } else {
#line 400
      tmp___1 = (char *)0;
    }
#line 400
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 400
      tmp___2 = __o1___0->object_base;
    } else {
#line 400
      tmp___2 = (char *)0;
    }
#line 400
    __o1___0->next_free = tmp___1 + (((size_t )(__o1___0->next_free - tmp___2) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 400
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 400
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 400
    __o1___0->object_base = __o1___0->next_free;
#line 400
    p = (struct output *)__value;
#line 401
    p->name = ck_strdup((char const   *)file_name___0);
#line 402
    p->fp = ck_fopen((char const   *)p->name, mode, fail);
#line 403
    p->missing_newline = (_Bool)0;
#line 404
    p->link = *file_ptrs;
#line 405
    *file_ptrs = p;
    }
  }
  {
#line 407
  free_buffer(b___0);
  }
#line 408
  return (p);
}
}
#line 412 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct sed_cmd *next_cmd_entry(struct vector **vectorp ) 
{ 
  struct sed_cmd *cmd ;
  struct vector *v ;
  void *tmp ;

  {
#line 418
  v = *vectorp;
#line 419
  if (v->v_length == v->v_allocated) {
    {
#line 421
    v->v_allocated += 40UL;
#line 422
    tmp = ck_realloc((void *)v->v, v->v_allocated * sizeof(struct sed_cmd ));
#line 422
    v->v = (struct sed_cmd *)tmp;
    }
  }
#line 425
  cmd = v->v + v->v_length;
#line 426
  cmd->a1 = (struct addr *)((void *)0);
#line 427
  cmd->a2 = (struct addr *)((void *)0);
#line 428
  cmd->range_state = (enum addr_state )0;
#line 429
  cmd->addr_bang = (char)0;
#line 430
  cmd->cmd = (char )'\000';
#line 432
  *vectorp = v;
#line 433
  return (cmd);
}
}
#line 436 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static int snarf_char_class(struct buffer *b___0 , mbstate_t *cur_stat ) 
{ 
  int ch ;
  int state ;
  int delim ;
  int mb_char ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 440
  state = 0;
#line 441
  delim = 0;
#line 443
  ch = inchar();
  }
#line 444
  if (ch == 94) {
    {
#line 445
    ch = add_then_next(b___0, ch);
    }
  }
#line 446
  if (ch == 93) {
    {
#line 447
    ch = add_then_next(b___0, ch);
    }
  }
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (mb_cur_max == 1) {
#line 457
      tmp___0 = 0;
    } else {
      {
#line 457
      tmp = is_mb_char(ch, cur_stat);
#line 457
      tmp___0 = tmp;
      }
    }
#line 457
    mb_char = tmp___0;
    {
#line 462
    if (ch == 10) {
#line 462
      goto case_10;
    }
#line 462
    if (ch == -1) {
#line 462
      goto case_10;
    }
#line 467
    if (ch == 61) {
#line 467
      goto case_61;
    }
#line 467
    if (ch == 58) {
#line 467
      goto case_61;
    }
#line 467
    if (ch == 46) {
#line 467
      goto case_61;
    }
#line 483
    if (ch == 91) {
#line 483
      goto case_91;
    }
#line 491
    if (ch == 93) {
#line 491
      goto case_93;
    }
#line 502
    goto switch_default;
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 463
    return (ch);
    case_61: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 468
    if (mb_char) {
#line 469
      goto __Cont;
    }
#line 471
    if (state == 1) {
#line 473
      delim = ch;
#line 474
      state = 2;
    } else
#line 476
    if (state == 2) {
#line 476
      if (ch == delim) {
#line 477
        state = 3;
      } else {
#line 479
        goto switch_break;
      }
    } else {
#line 479
      goto switch_break;
    }
#line 481
    goto __Cont;
    case_91: /* CIL Label */ 
#line 484
    if (mb_char) {
#line 485
      goto __Cont;
    }
#line 487
    if (state == 0) {
#line 488
      state = 1;
    }
#line 489
    goto __Cont;
    case_93: /* CIL Label */ 
#line 492
    if (mb_char) {
#line 493
      goto __Cont;
    }
#line 495
    if (state == 0) {
#line 496
      return (ch);
    } else
#line 495
    if (state == 1) {
#line 496
      return (ch);
    } else
#line 497
    if (state == 3) {
#line 498
      state = 0;
    }
#line 500
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 503
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 509
    state &= -2;
    __Cont: /* CIL Label */ 
    {
#line 455
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 513 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct buffer *match_slash(int slash , int regex ) 
{ 
  struct buffer *b___0 ;
  int ch ;
  mbstate_t cur_stat ;
  int tmp ;
  int tmp___0 ;
  int mb_char ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 518
  cur_stat.__count = 0;
#line 518
  cur_stat.__value.__wch = 0U;
#line 521
  if (mb_cur_max == 1) {
#line 521
    tmp___0 = 0;
  } else {
    {
#line 521
    tmp = is_mb_char(slash, & cur_stat);
#line 521
    tmp___0 = tmp;
    }
  }
#line 521
  if (tmp___0) {
    {
#line 522
    bad_prog(((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths"));
    }
  }
  {
#line 524
  memset((void *)(& cur_stat), 0, sizeof(cur_stat));
#line 526
  b___0 = init_buffer();
  }
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 527
    ch = inchar();
    }
#line 527
    if (ch != -1) {
#line 527
      if (! (ch != 10)) {
#line 527
        goto while_break;
      }
    } else {
#line 527
      goto while_break;
    }
#line 529
    if (mb_cur_max == 1) {
#line 529
      tmp___2 = 0;
    } else {
      {
#line 529
      tmp___1 = is_mb_char(ch, & cur_stat);
#line 529
      tmp___2 = tmp___1;
      }
    }
#line 529
    mb_char = tmp___2;
#line 531
    if (! mb_char) {
#line 533
      if (ch == slash) {
#line 534
        return (b___0);
      } else
#line 535
      if (ch == 92) {
        {
#line 537
        ch = inchar();
        }
#line 538
        if (ch == -1) {
#line 539
          goto while_break;
        } else
#line 541
        if (ch == 110) {
#line 541
          if (regex) {
#line 542
            ch = '\n';
          } else {
#line 541
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 544
        if (ch != 10) {
#line 544
          if (ch != slash) {
            {
#line 545
            add1_buffer(b___0, '\\');
            }
          } else
#line 544
          if (! regex) {
#line 544
            if (ch == 38) {
              {
#line 545
              add1_buffer(b___0, '\\');
              }
            }
          }
        }
      } else
#line 547
      if (ch == 91) {
#line 547
        if (regex) {
          {
#line 549
          add1_buffer(b___0, ch);
#line 550
          ch = snarf_char_class(b___0, & cur_stat);
          }
#line 551
          if (ch != 93) {
#line 552
            goto while_break;
          }
        }
      }
    }
    {
#line 556
    add1_buffer(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 559
  if (ch == 10) {
    {
#line 560
    savchar(ch);
    }
  }
  {
#line 561
  free_buffer(b___0);
  }
#line 562
  return ((struct buffer *)((void *)0));
}
}
#line 565 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static int mark_subst_opts(struct subst *cmd ) 
{ 
  int flags ;
  int ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 568
  flags = 0;
#line 571
  cmd->global = 0U;
#line 572
  cmd->print = 0U;
#line 573
  cmd->eval = 0U;
#line 574
  cmd->numb = (countT )0;
#line 575
  cmd->outf = (struct output *)((void *)0);
  {
#line 577
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 578
    ch = in_nonblank();
    }
    {
#line 581
    if (ch == 73) {
#line 581
      goto case_73;
    }
#line 581
    if (ch == 105) {
#line 581
      goto case_73;
    }
#line 606
    if (ch == 77) {
#line 606
      goto case_77;
    }
#line 606
    if (ch == 109) {
#line 606
      goto case_77;
    }
#line 612
    if (ch == 101) {
#line 612
      goto case_101;
    }
#line 618
    if (ch == 112) {
#line 618
      goto case_112;
    }
#line 624
    if (ch == 103) {
#line 624
      goto case_103;
    }
#line 630
    if (ch == 119) {
#line 630
      goto case_119;
    }
#line 635
    if (ch == 57) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 56) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 55) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 54) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 53) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 52) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 51) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 50) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 49) {
#line 635
      goto case_57;
    }
#line 635
    if (ch == 48) {
#line 635
      goto case_57;
    }
#line 644
    if (ch == 35) {
#line 644
      goto case_35;
    }
#line 644
    if (ch == 125) {
#line 644
      goto case_35;
    }
#line 649
    if (ch == 59) {
#line 649
      goto case_59;
    }
#line 649
    if (ch == 10) {
#line 649
      goto case_59;
    }
#line 649
    if (ch == -1) {
#line 649
      goto case_59;
    }
#line 652
    if (ch == 13) {
#line 652
      goto case_13;
    }
#line 657
    goto switch_default;
    case_73: /* CIL Label */ 
    case_105: /* CIL Label */ 
#line 582
    if ((unsigned int )posixicity == 2U) {
      {
#line 583
      tmp = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 583
      bad_prog((char const   *)tmp);
      }
    }
#line 584
    flags |= 1 << 1;
#line 585
    goto switch_break;
    case_77: /* CIL Label */ 
    case_109: /* CIL Label */ 
#line 607
    if ((unsigned int )posixicity == 2U) {
      {
#line 608
      tmp___0 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 608
      bad_prog((char const   *)tmp___0);
      }
    }
#line 609
    flags |= 1 << 2;
#line 610
    goto switch_break;
    case_101: /* CIL Label */ 
#line 613
    if ((unsigned int )posixicity == 2U) {
      {
#line 614
      tmp___1 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 614
      bad_prog((char const   *)tmp___1);
      }
    }
#line 615
    cmd->eval = 1U;
#line 616
    goto switch_break;
    case_112: /* CIL Label */ 
#line 619
    if (cmd->print) {
      {
#line 620
      tmp___2 = gettext((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'"));
#line 620
      bad_prog((char const   *)tmp___2);
      }
    }
#line 621
    cmd->print |= (unsigned int )(1 << cmd->eval);
#line 622
    goto switch_break;
    case_103: /* CIL Label */ 
#line 625
    if (cmd->global) {
      {
#line 626
      tmp___3 = gettext(((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command"));
#line 626
      bad_prog((char const   *)tmp___3);
      }
    }
#line 627
    cmd->global = 1U;
#line 628
    goto switch_break;
    case_119: /* CIL Label */ 
    {
#line 631
    cmd->outf = get_openfile(& file_write, write_mode, 1);
    }
#line 632
    return (flags);
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
#line 636
    if (cmd->numb) {
      {
#line 637
      tmp___4 = gettext((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command"));
#line 637
      bad_prog((char const   *)tmp___4);
      }
    }
    {
#line 638
    cmd->numb = in_integer(ch);
    }
#line 639
    if (! cmd->numb) {
      {
#line 640
      tmp___5 = gettext(((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command"));
#line 640
      bad_prog((char const   *)tmp___5);
      }
    }
#line 641
    goto switch_break;
    case_35: /* CIL Label */ 
    case_125: /* CIL Label */ 
    {
#line 645
    savchar(ch);
    }
    case_59: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_neg_1: /* CIL Label */ 
#line 650
    return (flags);
    case_13: /* CIL Label */ 
    {
#line 653
    tmp___6 = inchar();
    }
#line 653
    if (tmp___6 == 10) {
#line 654
      return (flags);
    }
    switch_default: /* CIL Label */ 
    {
#line 658
    tmp___7 = gettext(((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command"));
#line 658
    bad_prog((char const   *)tmp___7);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 665 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static char *read_label(void) 
{ 
  struct buffer *b___0 ;
  int ch ;
  char *ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;

  {
  {
#line 672
  b___0 = init_buffer();
#line 673
  ch = in_nonblank();
  }
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (ch != -1) {
#line 675
      if (ch != 10) {
        {
#line 675
        tmp = __ctype_b_loc();
        }
#line 675
        if ((int const   )*(*tmp + ch) & 1) {
#line 675
          goto while_break;
        } else
#line 675
        if (ch != 59) {
#line 675
          if (ch != 125) {
#line 675
            if (! (ch != 35)) {
#line 675
              goto while_break;
            }
          } else {
#line 675
            goto while_break;
          }
        } else {
#line 675
          goto while_break;
        }
      } else {
#line 675
        goto while_break;
      }
    } else {
#line 675
      goto while_break;
    }
    {
#line 677
    ch = add_then_next(b___0, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 679
  savchar(ch);
#line 680
  add1_buffer(b___0, '\000');
#line 681
  tmp___0 = get_buffer((struct buffer  const  *)b___0);
#line 681
  ret = ck_strdup((char const   *)tmp___0);
#line 682
  free_buffer(b___0);
  }
#line 683
  return (ret);
}
}
#line 690 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct sed_label *setup_label(struct sed_label *list , countT idx , char *name ,
                                     struct error_info  const  *err_info ) 
{ 
  struct sed_label *ret ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 694
  __h = & obs;
#line 694
  __o = __h;
#line 694
  __len = sizeof(struct sed_label );
#line 694
  __o1 = (struct obstack  const  *)__o;
#line 694
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 694
    _obstack_newchunk(__o, __len);
    }
  }
#line 694
  __o->next_free += __len;
#line 694
  __o1___0 = __h;
#line 694
  __value = (void *)__o1___0->object_base;
#line 694
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 694
    __o1___0->maybe_empty_object = 1U;
  }
#line 694
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 694
    tmp = __o1___0->object_base;
  } else {
#line 694
    tmp = (char *)0;
  }
#line 694
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 694
    tmp___0 = __o1___0->object_base;
  } else {
#line 694
    tmp___0 = (char *)0;
  }
#line 694
  __o1___0->next_free = tmp + (((size_t )(__o1___0->next_free - tmp___0) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 694
  if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 694
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 694
  __o1___0->object_base = __o1___0->next_free;
#line 694
  ret = (struct sed_label *)__value;
#line 695
  ret->v_index = idx;
#line 696
  ret->name = name;
#line 697
  if (err_info) {
    {
#line 698
    memcpy((void */* __restrict  */)(& ret->err_info), (void const   */* __restrict  */)err_info,
           sizeof(ret->err_info));
    }
  }
#line 699
  ret->next = list;
#line 700
  return (ret);
}
}
#line 703 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct sed_label *release_label(struct sed_label *list_head ) 
{ 
  struct sed_label *ret ;

  {
#line 708
  if (! list_head) {
#line 709
    return ((struct sed_label *)((void *)0));
  }
  {
#line 710
  ret = list_head->next;
#line 712
  free((void *)list_head->name);
  }
#line 718
  return (ret);
}
}
#line 721 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct replacement *new_replacement(char *text , size_t length , enum replacement_types type ) 
{ 
  struct replacement *r ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 724
  __h = & obs;
#line 724
  __o = __h;
#line 724
  __len = sizeof(struct replacement );
#line 724
  __o1 = (struct obstack  const  *)__o;
#line 724
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 724
    _obstack_newchunk(__o, __len);
    }
  }
#line 724
  __o->next_free += __len;
#line 724
  __o1___0 = __h;
#line 724
  __value = (void *)__o1___0->object_base;
#line 724
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 724
    __o1___0->maybe_empty_object = 1U;
  }
#line 724
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 724
    tmp = __o1___0->object_base;
  } else {
#line 724
    tmp = (char *)0;
  }
#line 724
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 724
    tmp___0 = __o1___0->object_base;
  } else {
#line 724
    tmp___0 = (char *)0;
  }
#line 724
  __o1___0->next_free = tmp + (((size_t )(__o1___0->next_free - tmp___0) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 724
  if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 724
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 724
  __o1___0->object_base = __o1___0->next_free;
#line 724
  r = (struct replacement *)__value;
#line 726
  r->prefix = text;
#line 727
  r->prefix_length = length;
#line 728
  r->subst_id = -1;
#line 729
  r->repl_type = type;
#line 732
  return (r);
}
}
#line 735 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static void setup_replacement(struct subst *sub , char const   *text , size_t length ) 
{ 
  char *base ;
  char *p ;
  char *text_end ;
  enum replacement_types repl_type ;
  enum replacement_types save_type ;
  struct replacement root ;
  struct replacement *tail ;
  void *tmp ;
  struct replacement *tmp___0 ;
  unsigned short const   **tmp___1 ;
  struct replacement *tmp___2 ;
  struct replacement *tmp___3 ;

  {
  {
#line 741
  repl_type = (enum replacement_types )0;
#line 741
  save_type = (enum replacement_types )0;
#line 745
  sub->max_id = 0U;
#line 746
  tmp = ck_memdup((void const   *)((void *)text), length * sizeof(char ));
#line 746
  base = (char *)tmp;
#line 747
  length = normalize_text(base, length, (enum text_types )1);
#line 749
  text_end = base + length;
#line 750
  tail = & root;
#line 752
  p = base;
  }
  {
#line 752
  while (1) {
    while_continue: /* CIL Label */ ;
#line 752
    if (! ((unsigned long )p < (unsigned long )text_end)) {
#line 752
      goto while_break;
    }
#line 754
    if ((int )*p == 92) {
      {
#line 757
      tmp___0 = new_replacement(base, (size_t )(p - base), repl_type);
#line 757
      tail->next = tmp___0;
#line 757
      tail = tmp___0;
#line 760
      repl_type = save_type;
#line 764
      p ++;
      }
#line 765
      if ((unsigned long )p == (unsigned long )text_end) {
#line 766
        (tail->prefix_length) ++;
      } else
#line 768
      if ((unsigned int )posixicity == 2U) {
        {
#line 768
        tmp___1 = __ctype_b_loc();
        }
#line 768
        if ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 2048) {
#line 768
          goto _L;
        } else {
#line 770
          *(p + -1) = *p;
#line 771
          (tail->prefix_length) ++;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 778
        if ((int )*p == 57) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 56) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 55) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 54) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 53) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 52) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 51) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 50) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 49) {
#line 778
          goto case_57;
        }
#line 778
        if ((int )*p == 48) {
#line 778
          goto case_57;
        }
#line 784
        if ((int )*p == 76) {
#line 784
          goto case_76;
        }
#line 789
        if ((int )*p == 85) {
#line 789
          goto case_85;
        }
#line 794
        if ((int )*p == 69) {
#line 794
          goto case_69;
        }
#line 799
        if ((int )*p == 108) {
#line 799
          goto case_108;
        }
#line 804
        if ((int )*p == 117) {
#line 804
          goto case_117;
        }
#line 809
        goto switch_default;
        case_57: /* CIL Label */ 
        case_56: /* CIL Label */ 
        case_55: /* CIL Label */ 
        case_54: /* CIL Label */ 
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
        case_51: /* CIL Label */ 
        case_50: /* CIL Label */ 
        case_49: /* CIL Label */ 
        case_48: /* CIL Label */ 
#line 779
        tail->subst_id = (int )*p - 48;
#line 780
        if (sub->max_id < (unsigned int )tail->subst_id) {
#line 781
          sub->max_id = (unsigned int )tail->subst_id;
        }
#line 782
        goto switch_break;
        case_76: /* CIL Label */ 
#line 785
        repl_type = (enum replacement_types )2;
#line 786
        save_type = (enum replacement_types )2;
#line 787
        goto switch_break;
        case_85: /* CIL Label */ 
#line 790
        repl_type = (enum replacement_types )1;
#line 791
        save_type = (enum replacement_types )1;
#line 792
        goto switch_break;
        case_69: /* CIL Label */ 
#line 795
        repl_type = (enum replacement_types )0;
#line 796
        save_type = (enum replacement_types )0;
#line 797
        goto switch_break;
        case_108: /* CIL Label */ 
#line 800
        save_type = repl_type;
#line 801
        repl_type = (enum replacement_types )((unsigned int )repl_type | 8U);
#line 802
        goto switch_break;
        case_117: /* CIL Label */ 
#line 805
        save_type = repl_type;
#line 806
        repl_type = (enum replacement_types )((unsigned int )repl_type | 4U);
#line 807
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 810
        *(p + -1) = *p;
#line 811
        (tail->prefix_length) ++;
        switch_break: /* CIL Label */ ;
        }
      }
#line 814
      base = p + 1;
    } else
#line 816
    if ((int )*p == 38) {
      {
#line 819
      tmp___2 = new_replacement(base, (size_t )(p - base), repl_type);
#line 819
      tail->next = tmp___2;
#line 819
      tail = tmp___2;
#line 822
      repl_type = save_type;
#line 823
      tail->subst_id = 0;
#line 824
      base = p + 1;
      }
    }
#line 752
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 828
  if ((unsigned long )base < (unsigned long )text_end) {
    {
#line 829
    tmp___3 = new_replacement(base, (size_t )(text_end - base), repl_type);
#line 829
    tail->next = tmp___3;
#line 829
    tail = tmp___3;
    }
  }
#line 832
  tail->next = (struct replacement *)((void *)0);
#line 833
  sub->replacement = root.next;
#line 834
  return;
}
}
#line 836 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static void read_text(struct text_buf *buf , int leadin_ch ) 
{ 
  int ch ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 842
  if (buf) {
#line 844
    if (pending_text) {
      {
#line 845
      free_buffer(pending_text);
      }
    }
    {
#line 846
    pending_text = init_buffer();
#line 847
    buf->text = (char *)((void *)0);
#line 848
    buf->text_length = (size_t )0;
#line 849
    old_text_buf = buf;
    }
  }
#line 853
  if (leadin_ch == -1) {
#line 854
    return;
  }
#line 856
  if (leadin_ch != 10) {
    {
#line 857
    add1_buffer(pending_text, leadin_ch);
    }
  }
  {
#line 859
  ch = inchar();
  }
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (ch != -1) {
#line 860
      if (! (ch != 10)) {
#line 860
        goto while_break;
      }
    } else {
#line 860
      goto while_break;
    }
#line 862
    if (ch == 92) {
      {
#line 864
      ch = inchar();
      }
#line 865
      if (ch != -1) {
        {
#line 866
        add1_buffer(pending_text, '\\');
        }
      }
    }
#line 869
    if (ch == -1) {
      {
#line 871
      add1_buffer(pending_text, '\n');
      }
#line 872
      return;
    }
    {
#line 875
    ch = add_then_next(pending_text, ch);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 878
  add1_buffer(pending_text, '\n');
  }
#line 879
  if (! buf) {
#line 880
    buf = old_text_buf;
  }
  {
#line 881
  tmp = size_buffer((struct buffer  const  *)pending_text);
#line 881
  tmp___0 = get_buffer((struct buffer  const  *)pending_text);
#line 881
  buf->text_length = normalize_text(tmp___0, tmp, (enum text_types )0);
#line 883
  tmp___1 = get_buffer((struct buffer  const  *)pending_text);
#line 883
  tmp___2 = ck_memdup((void const   *)((void *)tmp___1), buf->text_length * sizeof(char ));
#line 883
  buf->text = (char *)tmp___2;
#line 884
  free_buffer(pending_text);
#line 885
  pending_text = (struct buffer *)((void *)0);
  }
#line 886
  return;
}
}
#line 893 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static _Bool compile_address(struct addr *addr , int ch ) 
{ 
  int flags ;
  struct buffer *b___0 ;
  char *tmp ;
  countT step ;
  int tmp___0 ;
  countT tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
#line 896
  addr->addr_type = (enum addr_types )0;
#line 897
  addr->addr_step = (countT )0;
#line 898
  addr->addr_number = ~ ((countT )0);
#line 899
  addr->addr_regex = (struct regex *)((void *)0);
#line 901
  if (ch == 47) {
#line 901
    goto _L___1;
  } else
#line 901
  if (ch == 92) {
    _L___1: /* CIL Label */ 
#line 903
    flags = 0;
#line 905
    addr->addr_type = (enum addr_types )1;
#line 906
    if (ch == 92) {
      {
#line 907
      ch = inchar();
      }
    }
    {
#line 908
    b___0 = match_slash(ch, 1);
    }
#line 908
    if (! b___0) {
      {
#line 909
      tmp = gettext((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address"));
#line 909
      bad_prog((char const   *)tmp);
      }
    }
    {
#line 911
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 913
      ch = in_nonblank();
      }
#line 914
      if ((unsigned int )posixicity == 2U) {
#line 915
        goto posix_address_modifier;
      }
      {
#line 918
      if (ch == 73) {
#line 918
        goto case_73;
      }
#line 934
      if (ch == 77) {
#line 934
        goto case_77;
      }
#line 938
      goto posix_address_modifier;
      case_73: /* CIL Label */ 
#line 919
      flags |= 1 << 1;
#line 920
      goto switch_break;
      case_77: /* CIL Label */ 
#line 935
      flags |= 1 << 2;
#line 936
      goto switch_break;
      posix_address_modifier: 
      switch_default: /* CIL Label */ 
      {
#line 940
      savchar(ch);
#line 941
      addr->addr_regex = compile_regex(b___0, flags, 0);
#line 942
      free_buffer(b___0);
      }
#line 943
      return ((_Bool)1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 947
    tmp___3 = __ctype_b_loc();
    }
#line 947
    if ((int const   )*(*tmp___3 + (int )((unsigned char )ch)) & 2048) {
      {
#line 949
      addr->addr_number = in_integer(ch);
#line 950
      addr->addr_type = (enum addr_types )2;
#line 951
      ch = in_nonblank();
      }
#line 952
      if (ch != 126) {
        {
#line 954
        savchar(ch);
        }
      } else
#line 952
      if ((unsigned int )posixicity == 2U) {
        {
#line 954
        savchar(ch);
        }
      } else {
        {
#line 958
        tmp___0 = in_nonblank();
#line 958
        tmp___1 = in_integer(tmp___0);
#line 958
        step = tmp___1;
        }
#line 959
        if (step > 0UL) {
#line 961
          addr->addr_step = step;
#line 962
          addr->addr_type = (enum addr_types )3;
        }
      }
    } else
#line 966
    if (ch == 43) {
#line 966
      goto _L___0;
    } else
#line 966
    if (ch == 126) {
      _L___0: /* CIL Label */ 
#line 966
      if ((unsigned int )posixicity != 2U) {
        {
#line 968
        tmp___2 = in_nonblank();
#line 968
        addr->addr_step = in_integer(tmp___2);
        }
#line 969
        if (! (addr->addr_step == 0UL)) {
#line 971
          if (ch == 43) {
#line 972
            addr->addr_type = (enum addr_types )4;
          } else {
#line 974
            addr->addr_type = (enum addr_types )5;
          }
        }
      } else {
#line 966
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 976
    if (ch == 36) {
#line 978
      addr->addr_type = (enum addr_types )6;
    } else {
#line 981
      return ((_Bool)0);
    }
  }
#line 983
  return ((_Bool)1);
}
}
#line 988 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static struct vector *compile_program(struct vector *vector ) 
{ 
  struct sed_cmd *cur_cmd ;
  struct buffer *b___0 ;
  int ch ;
  void *tmp ;
  struct addr a ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  long tmp___12 ;
  char *version ;
  char *tmp___13 ;
  char const   *compared_version ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *label ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  countT tmp___27 ;
  unsigned short const   **tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  struct output *tmp___32 ;
  struct buffer *b2 ;
  int flags ;
  int slash ;
  char *tmp___33 ;
  char *tmp___34 ;
  struct obstack *__h ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___35 ;
  char *tmp___36 ;
  size_t tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  size_t len ;
  size_t dest_len ;
  int slash___0 ;
  struct buffer *b2___0 ;
  char *src_buf ;
  char *dest_buf ;
  char *tmp___40 ;
  size_t tmp___41 ;
  char *tmp___42 ;
  size_t tmp___43 ;
  size_t i ;
  size_t j ;
  size_t idx ;
  size_t src_char_num ;
  size_t *src_lens ;
  void *tmp___44 ;
  char **trans_pairs ;
  size_t mbclen ;
  mbstate_t cur_stat ;
  size_t tmp___45 ;
  size_t tmp___46 ;
  void *tmp___47 ;
  char *tmp___48 ;
  void *tmp___49 ;
  size_t tmp___50 ;
  void *tmp___51 ;
  char *tmp___52 ;
  unsigned char *translate ;
  struct obstack *__h___0 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o1___2 ;
  void *__value___0 ;
  char *tmp___53 ;
  char *tmp___54 ;
  unsigned char *ustring ;
  char *tmp___55 ;
  unsigned char *tmp___56 ;
  char *tmp___57 ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;

  {
#line 995
  if (! vector) {
    {
#line 997
    tmp = ck_malloc(sizeof(struct vector ));
#line 997
    vector = (struct vector *)tmp;
#line 998
    vector->v = (struct sed_cmd *)((void *)0);
#line 999
    vector->v_allocated = (size_t )0;
#line 1000
    vector->v_length = (size_t )0;
#line 1002
    _obstack_begin(& obs, (size_t )0, (size_t )0, & ck_malloc, (void (*)(void * ))(& free));
    }
  }
#line 1004
  if (pending_text) {
    {
#line 1005
    read_text((struct text_buf *)((void *)0), '\n');
    }
  }
  {
#line 1007
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1011
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1011
      ch = inchar();
      }
#line 1011
      if (! (ch == 59)) {
        {
#line 1011
        tmp___0 = __ctype_b_loc();
        }
#line 1011
        if (! ((int const   )*(*tmp___0 + ch) & 8192)) {
#line 1011
          goto while_break___0;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1013
    if (ch == -1) {
#line 1014
      goto while_break;
    }
    {
#line 1016
    cur_cmd = next_cmd_entry(& vector);
#line 1017
    tmp___8 = compile_address(& a, ch);
    }
#line 1017
    if (tmp___8) {
#line 1019
      if ((unsigned int )a.addr_type == 4U) {
        {
#line 1021
        tmp___1 = gettext((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
#line 1021
        bad_prog((char const   *)tmp___1);
        }
      } else
#line 1019
      if ((unsigned int )a.addr_type == 5U) {
        {
#line 1021
        tmp___1 = gettext((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'"));
#line 1021
        bad_prog((char const   *)tmp___1);
        }
      }
      {
#line 1023
      tmp___2 = ck_memdup((void const   *)((void *)(& a)), sizeof(struct addr ));
#line 1023
      cur_cmd->a1 = (struct addr *)tmp___2;
#line 1024
      ch = in_nonblank();
      }
#line 1025
      if (ch == 44) {
        {
#line 1027
        tmp___4 = in_nonblank();
#line 1027
        tmp___5 = compile_address(& a, tmp___4);
        }
#line 1027
        if (! tmp___5) {
          {
#line 1028
          tmp___3 = gettext(errors___0 + sizeof("multiple `!\'s"));
#line 1028
          bad_prog((char const   *)tmp___3);
          }
        }
        {
#line 1030
        tmp___6 = ck_memdup((void const   *)((void *)(& a)), sizeof(struct addr ));
#line 1030
        cur_cmd->a2 = (struct addr *)tmp___6;
#line 1031
        ch = in_nonblank();
        }
      }
#line 1034
      if ((unsigned int )(cur_cmd->a1)->addr_type == 2U) {
#line 1034
        if ((cur_cmd->a1)->addr_number == 0UL) {
#line 1034
          if (! cur_cmd->a2) {
            {
#line 1038
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1038
            bad_prog((char const   *)tmp___7);
            }
          } else
#line 1034
          if ((unsigned int )(cur_cmd->a2)->addr_type != 1U) {
            {
#line 1038
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1038
            bad_prog((char const   *)tmp___7);
            }
          } else
#line 1034
          if ((unsigned int )posixicity == 2U) {
            {
#line 1038
            tmp___7 = gettext(((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed"));
#line 1038
            bad_prog((char const   *)tmp___7);
            }
          }
        }
      }
    }
#line 1040
    if (ch == 33) {
      {
#line 1042
      cur_cmd->addr_bang = (char)1;
#line 1043
      ch = in_nonblank();
      }
#line 1044
      if (ch == 33) {
        {
#line 1045
        tmp___9 = gettext(errors___0);
#line 1045
        bad_prog((char const   *)tmp___9);
        }
      }
    }
#line 1050
    if ((unsigned int )posixicity == 2U) {
      {
#line 1054
      if (ch == 87) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 82) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 84) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 81) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 76) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 122) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 118) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 70) {
#line 1054
        goto case_87;
      }
#line 1054
      if (ch == 101) {
#line 1054
        goto case_87;
      }
#line 1059
      if (ch == 114) {
#line 1059
        goto case_114;
      }
#line 1059
      if (ch == 61) {
#line 1059
        goto case_114;
      }
#line 1059
      if (ch == 108) {
#line 1059
        goto case_114;
      }
#line 1059
      if (ch == 105) {
#line 1059
        goto case_114;
      }
#line 1059
      if (ch == 97) {
#line 1059
        goto case_114;
      }
#line 1051
      goto switch_break;
      case_87: /* CIL Label */ 
      case_82: /* CIL Label */ 
      case_84: /* CIL Label */ 
      case_81: /* CIL Label */ 
      case_76: /* CIL Label */ 
      case_122: /* CIL Label */ 
      case_118: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_101: /* CIL Label */ 
      {
#line 1055
      bad_command((char )ch);
      }
      case_114: /* CIL Label */ 
      case_61: /* CIL Label */ 
      case_108: /* CIL Label */ 
      case_105: /* CIL Label */ 
      case_97: /* CIL Label */ 
#line 1060
      if (cur_cmd->a2) {
        {
#line 1061
        tmp___10 = gettext(((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
#line 1061
        bad_prog((char const   *)tmp___10);
        }
      }
      switch_break: /* CIL Label */ ;
      }
    }
#line 1064
    cur_cmd->cmd = (char )ch;
    {
#line 1067
    if (ch == 35) {
#line 1067
      goto case_35;
    }
#line 1079
    if (ch == 118) {
#line 1079
      goto case_118___0;
    }
#line 1096
    if (ch == 123) {
#line 1096
      goto case_123;
    }
#line 1101
    if (ch == 125) {
#line 1101
      goto case_125;
    }
#line 1116
    if (ch == 101) {
#line 1116
      goto case_101___0;
    }
#line 1131
    if (ch == 99) {
#line 1131
      goto case_99;
    }
#line 1131
    if (ch == 105) {
#line 1131
      goto case_99;
    }
#line 1131
    if (ch == 97) {
#line 1131
      goto case_99;
    }
#line 1151
    if (ch == 58) {
#line 1151
      goto case_58;
    }
#line 1164
    if (ch == 116) {
#line 1164
      goto case_116;
    }
#line 1164
    if (ch == 98) {
#line 1164
      goto case_116;
    }
#line 1164
    if (ch == 84) {
#line 1164
      goto case_116;
    }
#line 1169
    if (ch == 113) {
#line 1169
      goto case_113;
    }
#line 1169
    if (ch == 81) {
#line 1169
      goto case_113;
    }
#line 1175
    if (ch == 108) {
#line 1175
      goto case_108___0;
    }
#line 1175
    if (ch == 76) {
#line 1175
      goto case_108___0;
    }
#line 1205
    if (ch == 120) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 122) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 80) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 112) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 78) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 110) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 72) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 104) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 71) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 103) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 70) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 68) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 100) {
#line 1205
      goto case_120;
    }
#line 1205
    if (ch == 61) {
#line 1205
      goto case_120;
    }
#line 1213
    if (ch == 114) {
#line 1213
      goto case_114___0;
    }
#line 1219
    if (ch == 82) {
#line 1219
      goto case_82___0;
    }
#line 1224
    if (ch == 119) {
#line 1224
      goto case_119;
    }
#line 1224
    if (ch == 87) {
#line 1224
      goto case_119;
    }
#line 1228
    if (ch == 115) {
#line 1228
      goto case_115;
    }
#line 1255
    if (ch == 121) {
#line 1255
      goto case_121;
    }
#line 1359
    if (ch == -1) {
#line 1359
      goto case_neg_1;
    }
#line 1363
    goto switch_default;
    case_35: /* CIL Label */ 
#line 1068
    if (cur_cmd->a1) {
      {
#line 1069
      tmp___11 = gettext(((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses"));
#line 1069
      bad_prog((char const   *)tmp___11);
      }
    }
    {
#line 1070
    ch = inchar();
    }
#line 1071
    if (ch == 110) {
#line 1071
      if (first_script) {
#line 1071
        if (cur_input.line < 2UL) {
#line 1072
          if (prog.base) {
#line 1072
            if ((unsigned long )prog.cur == (unsigned long )(prog.base + 2)) {
#line 1074
              no_default_output = (_Bool)1;
            } else {
#line 1072
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1072
          if (prog.file) {
#line 1072
            if (! prog.base) {
              {
#line 1072
              tmp___12 = ftell(prog.file);
              }
#line 1072
              if (2L == tmp___12) {
#line 1074
                no_default_output = (_Bool)1;
              }
            }
          }
        }
      }
    }
    {
#line 1075
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1075
      if (ch != -1) {
#line 1075
        if (! (ch != 10)) {
#line 1075
          goto while_break___1;
        }
      } else {
#line 1075
        goto while_break___1;
      }
      {
#line 1076
      ch = inchar();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1077
    goto __Cont;
    case_118___0: /* CIL Label */ 
    {
#line 1085
    tmp___13 = read_label();
#line 1085
    version = tmp___13;
    }
#line 1087
    if ((int )*version == 0) {
#line 1087
      compared_version = "4.0";
    } else {
#line 1087
      compared_version = (char const   *)version;
    }
    {
#line 1088
    tmp___15 = strverscmp(compared_version, "4.3");
    }
#line 1088
    if (tmp___15 > 0) {
      {
#line 1089
      tmp___14 = gettext((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character"));
#line 1089
      bad_prog((char const   *)tmp___14);
      }
    }
    {
#line 1091
    free((void *)version);
#line 1092
    posixicity = (enum posixicity_types )0;
    }
#line 1094
    goto __Cont;
    case_123: /* CIL Label */ 
    {
#line 1097
    blocks = setup_label(blocks, vector->v_length, (char *)((void *)0), (struct error_info  const  *)(& cur_input));
#line 1098
    cur_cmd->addr_bang = (char )(! cur_cmd->addr_bang);
    }
#line 1099
    goto switch_break___0;
    case_125: /* CIL Label */ 
#line 1102
    if (! blocks) {
      {
#line 1103
      tmp___16 = gettext((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'"));
#line 1103
      bad_prog((char const   *)tmp___16);
      }
    }
#line 1104
    if (cur_cmd->a1) {
      {
#line 1105
      tmp___17 = gettext(((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'"));
#line 1105
      bad_prog((char const   *)tmp___17);
      }
    }
    {
#line 1106
    ch = in_nonblank();
    }
#line 1107
    if (ch == 125) {
      {
#line 1108
      savchar(ch);
      }
    } else
#line 1107
    if (ch == 35) {
      {
#line 1108
      savchar(ch);
      }
    } else
#line 1109
    if (ch != -1) {
#line 1109
      if (ch != 10) {
#line 1109
        if (ch != 59) {
          {
#line 1110
          tmp___18 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1110
          bad_prog((char const   *)tmp___18);
          }
        }
      }
    }
    {
#line 1112
    (vector->v + blocks->v_index)->x.jump_index = vector->v_length;
#line 1113
    blocks = release_label(blocks);
    }
#line 1114
    goto switch_break___0;
    case_101___0: /* CIL Label */ 
#line 1117
    if (sandbox) {
      {
#line 1118
      tmp___19 = gettext((((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label")) + sizeof("recursive escaping after \\c not allowed"));
#line 1118
      bad_prog((char const   *)tmp___19);
      }
    }
    {
#line 1120
    ch = in_nonblank();
    }
#line 1121
    if (ch == -1) {
#line 1123
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1124
      goto switch_break___0;
    } else
#line 1121
    if (ch == 10) {
#line 1123
      cur_cmd->x.cmd_txt.text_length = (size_t )0;
#line 1124
      goto switch_break___0;
    } else {
#line 1127
      goto read_text_to_slash;
    }
    case_99: /* CIL Label */ 
    case_105___0: /* CIL Label */ 
    case_97___0: /* CIL Label */ 
    {
#line 1132
    ch = in_nonblank();
    }
    read_text_to_slash: 
#line 1135
    if (ch == -1) {
      {
#line 1136
      tmp___20 = gettext((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
#line 1136
      bad_prog((char const   *)tmp___20);
      }
    }
#line 1138
    if (ch == 92) {
      {
#line 1139
      ch = inchar();
      }
    } else {
#line 1142
      if ((unsigned int )posixicity == 2U) {
        {
#line 1143
        tmp___21 = gettext((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command"));
#line 1143
        bad_prog((char const   *)tmp___21);
        }
      }
      {
#line 1144
      savchar(ch);
#line 1145
      ch = '\n';
      }
    }
    {
#line 1148
    read_text(& cur_cmd->x.cmd_txt, ch);
    }
#line 1149
    goto switch_break___0;
    case_58: /* CIL Label */ 
#line 1152
    if (cur_cmd->a1) {
      {
#line 1153
      tmp___22 = gettext((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses"));
#line 1153
      bad_prog((char const   *)tmp___22);
      }
    }
    {
#line 1155
    tmp___23 = read_label();
#line 1155
    label = tmp___23;
    }
#line 1156
    if (! *label) {
      {
#line 1157
      tmp___24 = gettext((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command"));
#line 1157
      bad_prog((char const   *)tmp___24);
      }
    }
    {
#line 1158
    labels = setup_label(labels, vector->v_length, label, (struct error_info  const  *)((void *)0));
    }
#line 1160
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_84___0: /* CIL Label */ 
    {
#line 1165
    tmp___25 = read_label();
#line 1165
    jumps = setup_label(jumps, vector->v_length, tmp___25, (struct error_info  const  *)((void *)0));
    }
#line 1166
    goto switch_break___0;
    case_113: /* CIL Label */ 
    case_81___0: /* CIL Label */ 
#line 1170
    if (cur_cmd->a2) {
      {
#line 1171
      tmp___26 = gettext(((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command"));
#line 1171
      bad_prog((char const   *)tmp___26);
      }
    }
    case_108___0: /* CIL Label */ 
    case_76___0: /* CIL Label */ 
    {
#line 1176
    ch = in_nonblank();
#line 1177
    tmp___28 = __ctype_b_loc();
    }
#line 1177
    if ((int const   )*(*tmp___28 + (int )((unsigned char )ch)) & 2048) {
#line 1177
      if ((unsigned int )posixicity != 2U) {
        {
#line 1179
        tmp___27 = in_integer(ch);
#line 1179
        cur_cmd->x.int_arg = (int )tmp___27;
#line 1180
        ch = in_nonblank();
        }
      } else {
#line 1183
        cur_cmd->x.int_arg = -1;
      }
    } else {
#line 1183
      cur_cmd->x.int_arg = -1;
    }
#line 1185
    if (ch == 125) {
      {
#line 1186
      savchar(ch);
      }
    } else
#line 1185
    if (ch == 35) {
      {
#line 1186
      savchar(ch);
      }
    } else
#line 1187
    if (ch != -1) {
#line 1187
      if (ch != 10) {
#line 1187
        if (ch != 59) {
          {
#line 1188
          tmp___29 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1188
          bad_prog((char const   *)tmp___29);
          }
        }
      }
    }
#line 1190
    goto switch_break___0;
    case_120: /* CIL Label */ 
    case_122___0: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_70___0: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    {
#line 1206
    ch = in_nonblank();
    }
#line 1207
    if (ch == 125) {
      {
#line 1208
      savchar(ch);
      }
    } else
#line 1207
    if (ch == 35) {
      {
#line 1208
      savchar(ch);
      }
    } else
#line 1209
    if (ch != -1) {
#line 1209
      if (ch != 10) {
#line 1209
        if (ch != 59) {
          {
#line 1210
          tmp___30 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1210
          bad_prog((char const   *)tmp___30);
          }
        }
      }
    }
#line 1211
    goto switch_break___0;
    case_114___0: /* CIL Label */ 
    {
#line 1214
    b___0 = read_filename();
#line 1215
    tmp___31 = get_buffer((struct buffer  const  *)b___0);
#line 1215
    cur_cmd->x.fname = ck_strdup((char const   *)tmp___31);
#line 1216
    free_buffer(b___0);
    }
#line 1217
    goto switch_break___0;
    case_82___0: /* CIL Label */ 
    {
#line 1220
    tmp___32 = get_openfile(& file_read, read_mode, 0);
#line 1220
    cur_cmd->x.fp = tmp___32->fp;
    }
#line 1221
    goto switch_break___0;
    case_119: /* CIL Label */ 
    case_87___0: /* CIL Label */ 
    {
#line 1225
    cur_cmd->x.outf = get_openfile(& file_write, write_mode, 1);
    }
#line 1226
    goto switch_break___0;
    case_115: /* CIL Label */ 
    {
#line 1234
    slash = inchar();
#line 1235
    b___0 = match_slash(slash, 1);
    }
#line 1235
    if (! b___0) {
      {
#line 1236
      tmp___33 = gettext(((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
#line 1236
      bad_prog((char const   *)tmp___33);
      }
    }
    {
#line 1237
    b2 = match_slash(slash, 0);
    }
#line 1237
    if (! b2) {
      {
#line 1238
      tmp___34 = gettext(((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex"));
#line 1238
      bad_prog((char const   *)tmp___34);
      }
    }
#line 1240
    __h = & obs;
#line 1240
    __o = __h;
#line 1240
    __len = sizeof(struct subst );
#line 1240
    __o1 = (struct obstack  const  *)__o;
#line 1240
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 1240
      _obstack_newchunk(__o, __len);
      }
    }
#line 1240
    __o->next_free += __len;
#line 1240
    __o1___0 = __h;
#line 1240
    __value = (void *)__o1___0->object_base;
#line 1240
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 1240
      __o1___0->maybe_empty_object = 1U;
    }
#line 1240
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1240
      tmp___35 = __o1___0->object_base;
    } else {
#line 1240
      tmp___35 = (char *)0;
    }
#line 1240
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1240
      tmp___36 = __o1___0->object_base;
    } else {
#line 1240
      tmp___36 = (char *)0;
    }
#line 1240
    __o1___0->next_free = tmp___35 + (((size_t )(__o1___0->next_free - tmp___36) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 1240
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 1240
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 1240
    __o1___0->object_base = __o1___0->next_free;
#line 1240
    cur_cmd->x.cmd_subst = (struct subst *)__value;
#line 1241
    tmp___37 = size_buffer((struct buffer  const  *)b2);
#line 1241
    tmp___38 = get_buffer((struct buffer  const  *)b2);
#line 1241
    setup_replacement(cur_cmd->x.cmd_subst, (char const   *)tmp___38, tmp___37);
#line 1243
    free_buffer(b2);
#line 1245
    flags = mark_subst_opts(cur_cmd->x.cmd_subst);
#line 1246
    (cur_cmd->x.cmd_subst)->regx = compile_regex(b___0, flags, (int )((cur_cmd->x.cmd_subst)->max_id + 1U));
#line 1248
    free_buffer(b___0);
    }
#line 1250
    if ((cur_cmd->x.cmd_subst)->eval) {
#line 1250
      if (sandbox) {
        {
#line 1251
        tmp___39 = gettext((((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label")) + sizeof("recursive escaping after \\c not allowed"));
#line 1251
        bad_prog((char const   *)tmp___39);
        }
      }
    }
#line 1253
    goto switch_break___0;
    case_121: /* CIL Label */ 
    {
#line 1262
    slash___0 = inchar();
#line 1263
    b___0 = match_slash(slash___0, 0);
    }
#line 1263
    if (! b___0) {
      {
#line 1264
      tmp___40 = gettext((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
#line 1264
      bad_prog((char const   *)tmp___40);
      }
    }
    {
#line 1265
    src_buf = get_buffer((struct buffer  const  *)b___0);
#line 1266
    tmp___41 = size_buffer((struct buffer  const  *)b___0);
#line 1266
    len = normalize_text(src_buf, tmp___41, (enum text_types )0);
#line 1268
    b2___0 = match_slash(slash___0, 0);
    }
#line 1268
    if (! b2___0) {
      {
#line 1269
      tmp___42 = gettext((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command"));
#line 1269
      bad_prog((char const   *)tmp___42);
      }
    }
    {
#line 1270
    dest_buf = get_buffer((struct buffer  const  *)b2___0);
#line 1271
    tmp___43 = size_buffer((struct buffer  const  *)b2___0);
#line 1271
    dest_len = normalize_text(dest_buf, tmp___43, (enum text_types )0);
    }
#line 1273
    if (mb_cur_max > 1) {
      {
#line 1276
      tmp___44 = ck_malloc(len * sizeof(size_t ));
#line 1276
      src_lens = (size_t *)tmp___44;
#line 1279
      cur_stat.__count = 0;
#line 1279
      cur_stat.__value.__wch = 0U;
#line 1282
      i = (size_t )0;
#line 1282
      j = (size_t )0;
      }
      {
#line 1282
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1282
        if (! (i < len)) {
#line 1282
          goto while_break___2;
        }
#line 1284
        if (mb_cur_max == 1) {
#line 1284
          mbclen = (size_t )1;
        } else {
          {
#line 1284
          tmp___45 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(src_buf + i),
                                 len - i, & cur_stat);
#line 1284
          mbclen = tmp___45;
          }
        }
#line 1287
        if (mbclen == 0xffffffffffffffffUL) {
#line 1289
          mbclen = (size_t )1;
        } else
#line 1287
        if (mbclen == 0xfffffffffffffffeUL) {
#line 1289
          mbclen = (size_t )1;
        } else
#line 1287
        if (mbclen == 0UL) {
#line 1289
          mbclen = (size_t )1;
        }
#line 1290
        tmp___46 = j;
#line 1290
        j ++;
#line 1290
        *(src_lens + tmp___46) = mbclen;
#line 1291
        i += mbclen;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 1293
      src_char_num = j;
#line 1295
      memset((void *)(& cur_stat), 0, sizeof(cur_stat));
#line 1296
      idx = (size_t )0;
#line 1302
      tmp___47 = ck_malloc((2UL * src_char_num + 1UL) * sizeof(char *));
#line 1302
      trans_pairs = (char **)tmp___47;
#line 1303
      cur_cmd->x.translatemb = trans_pairs;
#line 1304
      i = (size_t )0;
      }
      {
#line 1304
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1304
        if (! (i < src_char_num)) {
#line 1304
          goto while_break___3;
        }
#line 1306
        if (idx >= dest_len) {
          {
#line 1307
          tmp___48 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1307
          bad_prog((char const   *)tmp___48);
          }
        }
        {
#line 1310
        tmp___49 = ck_malloc((*(src_lens + i) + 1UL) * sizeof(char ));
#line 1310
        *(trans_pairs + 2UL * i) = (char *)tmp___49;
#line 1311
        memcpy((void */* __restrict  */)*(trans_pairs + 2UL * i), (void const   */* __restrict  */)src_buf,
               *(src_lens + i));
#line 1312
        *(*(trans_pairs + 2UL * i) + *(src_lens + i)) = (char )'\000';
#line 1313
        src_buf += *(src_lens + i);
        }
#line 1316
        if (mb_cur_max == 1) {
#line 1316
          mbclen = (size_t )1;
        } else {
          {
#line 1316
          tmp___50 = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)(dest_buf + idx),
                                 dest_len - idx, & cur_stat);
#line 1316
          mbclen = tmp___50;
          }
        }
#line 1319
        if (mbclen == 0xffffffffffffffffUL) {
#line 1321
          mbclen = (size_t )1;
        } else
#line 1319
        if (mbclen == 0xfffffffffffffffeUL) {
#line 1321
          mbclen = (size_t )1;
        } else
#line 1319
        if (mbclen == 0UL) {
#line 1321
          mbclen = (size_t )1;
        }
        {
#line 1324
        tmp___51 = ck_malloc((mbclen + 1UL) * sizeof(char ));
#line 1324
        *(trans_pairs + (2UL * i + 1UL)) = (char *)tmp___51;
#line 1325
        memcpy((void */* __restrict  */)*(trans_pairs + (2UL * i + 1UL)), (void const   */* __restrict  */)(dest_buf + idx),
               mbclen);
#line 1326
        *(*(trans_pairs + (2UL * i + 1UL)) + mbclen) = (char )'\000';
#line 1327
        idx += mbclen;
#line 1304
        i ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1329
      *(trans_pairs + 2UL * i) = (char *)((void *)0);
#line 1330
      if (idx != dest_len) {
        {
#line 1331
        tmp___52 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1331
        bad_prog((char const   *)tmp___52);
        }
      }
    } else {
#line 1336
      __h___0 = & obs;
#line 1336
      __o___0 = __h___0;
#line 1336
      __len___0 = 256UL * sizeof(unsigned char );
#line 1336
      __o1___1 = (struct obstack  const  *)__o___0;
#line 1336
      if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
        {
#line 1336
        _obstack_newchunk(__o___0, __len___0);
        }
      }
#line 1336
      __o___0->next_free += __len___0;
#line 1336
      __o1___2 = __h___0;
#line 1336
      __value___0 = (void *)__o1___2->object_base;
#line 1336
      if ((unsigned long )__o1___2->next_free == (unsigned long )__value___0) {
#line 1336
        __o1___2->maybe_empty_object = 1U;
      }
#line 1336
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1336
        tmp___53 = __o1___2->object_base;
      } else {
#line 1336
        tmp___53 = (char *)0;
      }
#line 1336
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1336
        tmp___54 = __o1___2->object_base;
      } else {
#line 1336
        tmp___54 = (char *)0;
      }
#line 1336
      __o1___2->next_free = tmp___53 + (((size_t )(__o1___2->next_free - tmp___54) + __o1___2->alignment_mask) & ~ __o1___2->alignment_mask);
#line 1336
      if ((size_t )(__o1___2->next_free - (char *)__o1___2->chunk) > (size_t )(__o1___2->chunk_limit - (char *)__o1___2->chunk)) {
#line 1336
        __o1___2->next_free = __o1___2->chunk_limit;
      }
#line 1336
      __o1___2->object_base = __o1___2->next_free;
#line 1336
      translate = (unsigned char *)__value___0;
#line 1337
      ustring = (unsigned char *)src_buf;
#line 1339
      if (len != dest_len) {
        {
#line 1340
        tmp___55 = gettext((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero"));
#line 1340
        bad_prog((char const   *)tmp___55);
        }
      }
#line 1342
      len = (size_t )0;
      {
#line 1342
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1342
        if (! (len < 256UL)) {
#line 1342
          goto while_break___4;
        }
#line 1343
        *(translate + len) = (unsigned char )len;
#line 1342
        len ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1345
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1345
        tmp___58 = dest_len;
#line 1345
        dest_len --;
#line 1345
        if (! tmp___58) {
#line 1345
          goto while_break___5;
        }
#line 1346
        tmp___56 = ustring;
#line 1346
        ustring ++;
#line 1346
        tmp___57 = dest_buf;
#line 1346
        dest_buf ++;
#line 1346
        *(translate + *tmp___56) = (unsigned char )*tmp___57;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1348
      cur_cmd->x.translate = translate;
    }
    {
#line 1351
    ch = in_nonblank();
    }
#line 1351
    if (ch != -1) {
#line 1351
      if (ch != 10) {
#line 1351
        if (ch != 59) {
          {
#line 1352
          tmp___59 = gettext(((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'"));
#line 1352
          bad_prog((char const   *)tmp___59);
          }
        }
      }
    }
    {
#line 1354
    free_buffer(b___0);
#line 1355
    free_buffer(b2___0);
    }
#line 1357
    goto switch_break___0;
    case_neg_1: /* CIL Label */ 
    {
#line 1360
    tmp___60 = gettext((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses"));
#line 1360
    bad_prog((char const   *)tmp___60);
    }
    switch_default: /* CIL Label */ 
    {
#line 1364
    bad_command((char )ch);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1369
    (vector->v_length) ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1371
  if ((unsigned int )posixicity == 2U) {
#line 1371
    if (pending_text) {
      {
#line 1372
      tmp___61 = gettext(((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'"));
#line 1372
      bad_prog((char const   *)tmp___61);
      }
    }
  }
#line 1373
  return (vector);
}
}
#line 1378 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
size_t normalize_text(char *buf , size_t len , enum text_types buftype ) 
{ 
  char const   *bufend ;
  char *p ;
  char *q ;
  char ch ;
  int base ;
  int bracket_state ;
  int mbclen ;
  mbstate_t cur_stat ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 1381
  bufend = (char const   *)(buf + len);
#line 1382
  p = buf;
#line 1383
  q = buf;
#line 1393
  bracket_state = 0;
#line 1396
  cur_stat.__count = 0;
#line 1396
  cur_stat.__value.__wch = 0U;
  {
#line 1398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1398
    if (! ((unsigned long )p < (unsigned long )bufend)) {
#line 1398
      goto while_break;
    }
#line 1400
    if (mb_cur_max == 1) {
#line 1400
      mbclen = 1;
    } else {
      {
#line 1400
      tmp = rpl_mbrtowc((wchar_t *)((void *)0), (char const   *)p, (size_t )(bufend - (char const   *)p),
                        & cur_stat);
#line 1400
      mbclen = (int )tmp;
      }
    }
#line 1401
    if (mbclen != 1) {
#line 1405
      if ((size_t )mbclen == 0xffffffffffffffffUL) {
#line 1406
        mbclen = 1;
      } else
#line 1405
      if ((size_t )mbclen == 0xfffffffffffffffeUL) {
#line 1406
        mbclen = 1;
      } else
#line 1405
      if (mbclen == 0) {
#line 1406
        mbclen = 1;
      }
      {
#line 1408
      memmove((void *)q, (void const   *)p, (size_t )mbclen);
#line 1409
      q += mbclen;
#line 1410
      p += mbclen;
      }
#line 1411
      goto while_continue;
    }
#line 1414
    if ((int )*p == 92) {
#line 1414
      if ((unsigned long )(p + 1) < (unsigned long )bufend) {
#line 1414
        if (bracket_state == 0) {
#line 1415
          p ++;
          {
#line 1418
          if ((int )*p == 97) {
#line 1418
            goto case_97;
          }
#line 1423
          if ((int )*p == 102) {
#line 1423
            goto case_102;
          }
#line 1425
          if ((int )*p == 110) {
#line 1425
            goto case_110;
          }
#line 1425
          if ((int )*p == 10) {
#line 1425
            goto case_110;
          }
#line 1426
          if ((int )*p == 114) {
#line 1426
            goto case_114;
          }
#line 1427
          if ((int )*p == 116) {
#line 1427
            goto case_116;
          }
#line 1428
          if ((int )*p == 118) {
#line 1428
            goto case_118;
          }
#line 1430
          if ((int )*p == 100) {
#line 1430
            goto case_100;
          }
#line 1434
          if ((int )*p == 120) {
#line 1434
            goto case_120;
          }
#line 1472
          if ((int )*p == 111) {
#line 1472
            goto case_111;
          }
#line 1484
          if ((int )*p == 99) {
#line 1484
            goto case_99;
          }
#line 1505
          goto switch_default;
          case_97: /* CIL Label */ 
#line 1418
          tmp___0 = q;
#line 1418
          q ++;
#line 1418
          *tmp___0 = (char )'\a';
#line 1418
          p ++;
#line 1418
          goto while_continue;
          case_102: /* CIL Label */ 
#line 1423
          tmp___1 = q;
#line 1423
          q ++;
#line 1423
          *tmp___1 = (char )'\f';
#line 1423
          p ++;
#line 1423
          goto while_continue;
          case_110: /* CIL Label */ 
          case_10: /* CIL Label */ 
#line 1425
          tmp___2 = q;
#line 1425
          q ++;
#line 1425
          *tmp___2 = (char )'\n';
#line 1425
          p ++;
#line 1425
          goto while_continue;
          case_114: /* CIL Label */ 
#line 1426
          tmp___3 = q;
#line 1426
          q ++;
#line 1426
          *tmp___3 = (char )'\r';
#line 1426
          p ++;
#line 1426
          goto while_continue;
          case_116: /* CIL Label */ 
#line 1427
          tmp___4 = q;
#line 1427
          q ++;
#line 1427
          *tmp___4 = (char )'\t';
#line 1427
          p ++;
#line 1427
          goto while_continue;
          case_118: /* CIL Label */ 
#line 1428
          tmp___5 = q;
#line 1428
          q ++;
#line 1428
          *tmp___5 = (char )'\v';
#line 1428
          p ++;
#line 1428
          goto while_continue;
          case_100: /* CIL Label */ 
#line 1431
          base = 10;
#line 1432
          goto convert;
          case_120: /* CIL Label */ 
#line 1435
          base = 16;
#line 1436
          goto convert;
          case_111: /* CIL Label */ 
#line 1473
          base = 8;
          convert: 
          {
#line 1476
          p = convert_number(& ch, p, bufend, base);
          }
#line 1479
          if ((unsigned int )buftype == 1U) {
#line 1479
            if ((int )ch == 38) {
#line 1480
              tmp___6 = q;
#line 1480
              q ++;
#line 1480
              *tmp___6 = (char )'\\';
            }
          }
#line 1481
          tmp___7 = q;
#line 1481
          q ++;
#line 1481
          *tmp___7 = ch;
#line 1482
          goto while_continue;
          case_99: /* CIL Label */ 
#line 1485
          p ++;
#line 1485
          if ((unsigned long )p < (unsigned long )bufend) {
            {
#line 1487
            tmp___8 = q;
#line 1487
            q ++;
#line 1487
            tmp___9 = toupper((int )((unsigned char )*p));
#line 1487
            *tmp___8 = (char )(tmp___9 ^ 64);
            }
#line 1488
            if ((int )*p == 92) {
#line 1490
              p ++;
#line 1491
              if ((int )*p != 92) {
                {
#line 1492
                bad_prog(((((((((((((((((((((((((((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address")) + sizeof("unmatched `{\'")) + sizeof("unexpected `}\'")) + sizeof("extra characters after command")) + sizeof("expected \\ after `a\', `c\' or `i\'")) + sizeof("`}\' doesn\'t want any addresses")) + sizeof(": doesn\'t want any addresses")) + sizeof("comments don\'t accept any addresses")) + sizeof("missing command")) + sizeof("command only uses one address")) + sizeof("unterminated address regex")) + sizeof("unterminated `s\' command")) + sizeof("unterminated `y\' command")) + sizeof("unknown option to `s\'")) + sizeof("multiple `p\' options to `s\' command")) + sizeof("multiple `g\' options to `s\' command")) + sizeof("multiple number options to `s\' command")) + sizeof("number option to `s\' command may not be zero")) + sizeof("strings for `y\' command are different lengths")) + sizeof("delimiter character is not a single-byte character")) + sizeof("expected newer version of sed")) + sizeof("invalid usage of line address 0")) + sizeof("unknown command: `%c\'")) + sizeof("incomplete command")) + sizeof("\":\" lacks a label"));
                }
              }
            }
#line 1494
            p ++;
#line 1495
            goto while_continue;
          } else {
#line 1500
            if ((unsigned int )buftype != 0U) {
#line 1501
              tmp___10 = q;
#line 1501
              q ++;
#line 1501
              *tmp___10 = (char )'\\';
            }
#line 1502
            goto while_continue;
          }
          switch_default: /* CIL Label */ 
#line 1507
          if ((unsigned int )buftype != 0U) {
#line 1508
            tmp___11 = q;
#line 1508
            q ++;
#line 1508
            *tmp___11 = (char )'\\';
          }
#line 1509
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        } else {
#line 1414
          goto _L___0;
        }
      } else {
#line 1414
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1511
    if ((unsigned int )buftype == 2U) {
#line 1511
      if ((unsigned int )posixicity != 0U) {
        {
#line 1514
        if ((int )*p == 91) {
#line 1514
          goto case_91;
        }
#line 1521
        if ((int )*p == 61) {
#line 1521
          goto case_61;
        }
#line 1521
        if ((int )*p == 46) {
#line 1521
          goto case_61;
        }
#line 1521
        if ((int )*p == 58) {
#line 1521
          goto case_61;
        }
#line 1526
        if ((int )*p == 93) {
#line 1526
          goto case_93;
        }
#line 1512
        goto switch_break___0;
        case_91: /* CIL Label */ 
#line 1515
        if (! bracket_state) {
#line 1516
          bracket_state = -1;
        }
#line 1517
        goto switch_break___0;
        case_61: /* CIL Label */ 
        case_46: /* CIL Label */ 
        case_58: /* CIL Label */ 
#line 1522
        if (bracket_state == -1) {
#line 1522
          if ((int )*(p + -1) == 91) {
#line 1523
            bracket_state = (int )*p;
          }
        }
#line 1524
        goto switch_break___0;
        case_93: /* CIL Label */ 
#line 1527
        if (! (bracket_state == 0)) {
#line 1529
          if (bracket_state == -1) {
#line 1530
            bracket_state = 0;
          } else
#line 1531
          if ((int )*(p + -2) != bracket_state) {
#line 1531
            if ((int )*(p + -1) == bracket_state) {
#line 1532
              bracket_state = -1;
            }
          }
        }
#line 1533
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1536
    tmp___12 = q;
#line 1536
    q ++;
#line 1536
    tmp___13 = p;
#line 1536
    p ++;
#line 1536
    *tmp___12 = *tmp___13;
  }
  while_break: /* CIL Label */ ;
  }
#line 1538
  return ((size_t )(q - buf));
}
}
#line 1547 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
static countT string_expr_count  =    (countT )0;
#line 1544 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
struct vector *compile_string(struct vector *cur_program , char *str , size_t len ) 
{ 
  struct vector *ret ;

  {
  {
#line 1550
  prog.file = (FILE *)((void *)0);
#line 1551
  prog.base = (unsigned char const   *)((unsigned char *)str);
#line 1552
  prog.cur = prog.base;
#line 1553
  prog.end = prog.cur + len;
#line 1555
  cur_input.line = (countT )0;
#line 1556
  cur_input.name = (char const   *)((void *)0);
#line 1557
  string_expr_count ++;
#line 1557
  cur_input.string_expr_count = string_expr_count;
#line 1559
  ret = compile_program(cur_program);
#line 1560
  prog.base = (unsigned char const   *)((void *)0);
#line 1561
  prog.cur = (unsigned char const   *)((void *)0);
#line 1562
  prog.end = (unsigned char const   *)((void *)0);
#line 1564
  first_script = (_Bool)0;
  }
#line 1565
  return (ret);
}
}
#line 1571 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
struct vector *compile_file(struct vector *cur_program , char const   *cmdfile ) 
{ 
  struct vector *ret ;

  {
#line 1576
  prog.file = stdin;
#line 1577
  if ((int const   )*(cmdfile + 0) != 45) {
    {
#line 1580
    prog.file = ck_fopen(cmdfile, "rt", 1);
    }
  } else
#line 1577
  if ((int const   )*(cmdfile + 1) != 0) {
    {
#line 1580
    prog.file = ck_fopen(cmdfile, "rt", 1);
    }
  }
  {
#line 1586
  cur_input.line = (countT )1;
#line 1587
  cur_input.name = cmdfile;
#line 1588
  cur_input.string_expr_count = (countT )0;
#line 1590
  ret = compile_program(cur_program);
  }
#line 1591
  if ((unsigned long )prog.file != (unsigned long )stdin) {
    {
#line 1592
    ck_fclose(prog.file);
    }
  }
#line 1593
  prog.file = (FILE *)((void *)0);
#line 1595
  first_script = (_Bool)0;
#line 1596
  return (ret);
}
}
#line 1602 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
void check_final_program(struct vector *program ) 
{ 
  struct sed_label *go ;
  struct sed_label *lbl ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  struct output *p ;

  {
#line 1609
  if (blocks) {
    {
#line 1612
    memcpy((void */* __restrict  */)(& cur_input), (void const   */* __restrict  */)(& blocks->err_info),
           sizeof(cur_input));
#line 1613
    tmp = gettext(((errors___0 + sizeof("multiple `!\'s")) + sizeof("unexpected `,\'")) + sizeof("invalid usage of +N or ~N as first address"));
#line 1613
    bad_prog((char const   *)tmp);
    }
  }
#line 1617
  if (pending_text) {
    {
#line 1619
    old_text_buf->text_length = size_buffer((struct buffer  const  *)pending_text);
    }
#line 1620
    if (old_text_buf->text_length) {
      {
#line 1621
      tmp___0 = get_buffer((struct buffer  const  *)pending_text);
#line 1621
      tmp___1 = ck_memdup((void const   *)((void *)tmp___0), old_text_buf->text_length * sizeof(char ));
#line 1621
      old_text_buf->text = (char *)tmp___1;
      }
    }
    {
#line 1623
    free_buffer(pending_text);
#line 1624
    pending_text = (struct buffer *)((void *)0);
    }
  }
#line 1627
  go = jumps;
  {
#line 1627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1627
    if (! go) {
#line 1627
      goto while_break;
    }
#line 1629
    lbl = labels;
    {
#line 1629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1629
      if (! lbl) {
#line 1629
        goto while_break___0;
      }
      {
#line 1630
      tmp___2 = strcmp((char const   *)lbl->name, (char const   *)go->name);
      }
#line 1630
      if (tmp___2 == 0) {
#line 1631
        goto while_break___0;
      }
#line 1629
      lbl = lbl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1632
    if (lbl) {
#line 1634
      (program->v + go->v_index)->x.jump_index = lbl->v_index;
    } else {
#line 1638
      if (*(go->name)) {
        {
#line 1639
        tmp___3 = gettext("can\'t find label for jump to `%s\'");
#line 1639
        panic((char const   *)tmp___3, go->name);
        }
      }
#line 1640
      (program->v + go->v_index)->x.jump_index = program->v_length;
    }
    {
#line 1627
    go = release_label(go);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1643
  jumps = (struct sed_label *)((void *)0);
#line 1645
  lbl = labels;
  {
#line 1645
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1645
    if (! lbl) {
#line 1645
      goto while_break___1;
    }
    {
#line 1645
    lbl = release_label(lbl);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1647
  labels = (struct sed_label *)((void *)0);
#line 1653
  p = file_read;
  {
#line 1653
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1653
    if (! p) {
#line 1653
      goto while_break___2;
    }
#line 1654
    if (p->name) {
      {
#line 1656
      free((void *)p->name);
#line 1657
      p->name = (char *)((void *)0);
      }
    }
#line 1653
    p = p->link;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1660
  p = file_write;
  {
#line 1660
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1660
    if (! p) {
#line 1660
      goto while_break___3;
    }
#line 1661
    if (p->name) {
      {
#line 1663
      free((void *)p->name);
#line 1664
      p->name = (char *)((void *)0);
      }
    }
#line 1660
    p = p->link;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1667
  return;
}
}
#line 1670 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
void rewind_read_files(void) 
{ 
  struct output *p ;

  {
#line 1675
  p = file_read;
  {
#line 1675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1675
    if (! p) {
#line 1675
      goto while_break;
    }
#line 1676
    if (p->fp) {
      {
#line 1677
      rewind(p->fp);
      }
    }
#line 1675
    p = p->link;
  }
  while_break: /* CIL Label */ ;
  }
#line 1678
  return;
}
}
#line 1681 "/home/khheo/project/benchmark/sed-4.3/sed/compile.c"
void finish_program(void) 
{ 
  struct output *p ;
  struct output *q ;

  {
#line 1688
  p = file_read;
  {
#line 1688
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1688
    if (! p) {
#line 1688
      goto while_break;
    }
#line 1690
    if (p->fp) {
      {
#line 1691
      ck_fclose(p->fp);
      }
    }
#line 1692
    q = p->link;
#line 1688
    p = q;
  }
  while_break: /* CIL Label */ ;
  }
#line 1699
  p = file_write;
  {
#line 1699
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1699
    if (! p) {
#line 1699
      goto while_break___0;
    }
#line 1701
    if (p->fp) {
      {
#line 1702
      ck_fclose(p->fp);
      }
    }
#line 1703
    q = p->link;
#line 1699
    p = q;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1709
  file_write = (struct output *)((void *)0);
#line 1709
  file_read = file_write;
#line 1715
  return;
}
}
