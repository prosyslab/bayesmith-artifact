/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 44 "gzip.h"
typedef unsigned char uch;
#line 45 "gzip.h"
typedef unsigned short ush;
#line 151 "gzip.h"
typedef int file_t;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef unsigned long size_t___0;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t___0;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t___0;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t___0;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker___0 {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE___0 {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker___0 *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t___0 _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t___0 *_lock ;
   __off64_t___0 _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t___0 __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t___0 )] ;
};
#line 14 "gzip.h"
typedef void *voidp___0;
#line 44 "gzip.h"
typedef unsigned char uch___0;
#line 45 "gzip.h"
typedef unsigned short ush___0;
#line 46 "gzip.h"
typedef unsigned long ulg___0;
#line 128 "deflate.c"
typedef ush___0 Pos;
#line 129 "deflate.c"
typedef unsigned int IPos;
#line 212 "deflate.c"
struct config {
   ush___0 good_length ;
   ush___0 max_lazy ;
   ush___0 nice_length ;
   ush___0 max_chain ;
};
#line 212 "deflate.c"
typedef struct config config;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h"
typedef unsigned long size_t___1;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t___1;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t___1;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t___1;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker___1 {
   struct _IO_marker___0 *_next ;
   struct _IO_FILE___0 *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE___1 {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker___1 *_markers ;
   struct _IO_FILE___0 *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t___1 _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t___1 *_lock ;
   __off64_t___1 _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t___1 __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t___1 )] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t___2;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t___2;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t___2;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t___2;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t___2;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t___2;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t___2;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t___2;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t___2;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t___2;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t___2;
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t___2 off_t___2;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t___2 time_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t___2 tv_sec ;
   __syscall_slong_t___2 tv_nsec ;
};
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t___2 st_dev ;
   __ino_t___2 st_ino ;
   __nlink_t___2 st_nlink ;
   __mode_t___2 st_mode ;
   __uid_t___2 st_uid ;
   __gid_t___2 st_gid ;
   int __pad0 ;
   __dev_t___2 st_rdev ;
   __off_t___2 st_size ;
   __blksize_t___2 st_blksize ;
   __blkcnt_t___2 st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t___2 __glibc_reserved[3] ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE___1 FILE___2;
#line 44 "gzip.h"
typedef unsigned char uch___1;
#line 45 "gzip.h"
typedef unsigned short ush___1;
#line 46 "gzip.h"
typedef unsigned long ulg___1;
#line 77 "getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 36 "/usr/include/utime.h"
struct utimbuf {
   __time_t___2 actime ;
   __time_t___2 modtime ;
};
#line 14 "gzip.h"
typedef void *voidp___2;
#line 44 "gzip.h"
typedef unsigned char uch___2;
#line 45 "gzip.h"
typedef unsigned short ush___2;
#line 46 "gzip.h"
typedef unsigned long ulg___2;
#line 121 "inflate.c"
union __anonunion_v_597249420 {
   ush___2 n ;
   struct huft *t ;
};
#line 121 "inflate.c"
struct huft {
   uch___2 e ;
   uch___2 b ;
   union __anonunion_v_597249420 v ;
};
#line 44 "gzip.h"
typedef unsigned char uch___4;
#line 45 "gzip.h"
typedef unsigned short ush___4;
#line 46 "gzip.h"
typedef unsigned long ulg___4;
#line 160 "trees.c"
union __anonunion_fc_152553610 {
   ush___4 freq ;
   ush___4 code ;
};
#line 160 "trees.c"
union __anonunion_dl_152553611 {
   ush___4 dad ;
   ush___4 len ;
};
#line 160 "trees.c"
struct ct_data {
   union __anonunion_fc_152553610 fc ;
   union __anonunion_dl_152553611 dl ;
};
#line 160 "trees.c"
typedef struct ct_data ct_data;
#line 197 "trees.c"
struct tree_desc {
   ct_data *dyn_tree ;
   ct_data *static_tree ;
   int *extra_bits ;
   int extra_base ;
   int elems ;
   int max_length ;
   int max_code ;
};
#line 197 "trees.c"
typedef struct tree_desc tree_desc;
#line 44 "gzip.h"
typedef unsigned char uch___5;
#line 45 "gzip.h"
typedef unsigned short ush___5;
#line 14 "gzip.h"
typedef void *voidp___6;
#line 46 "gzip.h"
typedef unsigned long ulg___6;
#line 28 "unlzw.c"
typedef unsigned char char_type;
#line 29 "unlzw.c"
typedef long code_int;
#line 32 "unlzw.c"
typedef unsigned long cmp_code_int;
#line 44 "gzip.h"
typedef unsigned char uch___7;
#line 46 "gzip.h"
typedef unsigned long ulg___7;
#line 44 "gzip.h"
typedef unsigned char uch___8;
#line 45 "gzip.h"
typedef unsigned short ush___8;
#line 46 "gzip.h"
typedef unsigned long ulg___8;
#line 14 "gzip.h"
typedef void *voidp___9;
#line 46 "gzip.h"
typedef unsigned long ulg___9;
#line 44 "gzip.h"
typedef unsigned char uch___10;
#line 45 "gzip.h"
typedef unsigned short ush___10;
#line 46 "gzip.h"
typedef unsigned long ulg___10;
#line 434 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_putc(int __c , struct _IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 137
extern struct _IO_FILE *stderr ;
#line 204
extern int fflush(struct _IO_FILE *__stream ) ;
#line 312
extern int fprintf(struct _IO_FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 564
extern char *fgets(char * __restrict  __s , int __n , struct _IO_FILE * __restrict  __stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(struct _IO_FILE *__stream ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 unsigned long __n ) ;
#line 60
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               unsigned long __n ) ;
#line 63
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               unsigned long __n )  __attribute__((__pure__)) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  unsigned long __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 136
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 139
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                unsigned long __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 272
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1,2),
__leaf__)) strcspn)(char const   *__s , char const   *__reject )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1,2),
__leaf__)) strspn)(char const   *__s , char const   *__accept )  __attribute__((__pure__)) ;
#line 384
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 61 "gzip.h"
int method ;
#line 115 "gzip.h"
unsigned char inbuf[32832]  ;
#line 116 "gzip.h"
unsigned char outbuf[18432]  ;
#line 117 "gzip.h"
unsigned short d_buf[32768]  ;
#line 118 "gzip.h"
unsigned char window[65536L]  ;
#line 123 "gzip.h"
unsigned short prev[1L << 16]  ;
#line 131 "gzip.h"
unsigned int insize  ;
#line 132 "gzip.h"
unsigned int inptr  ;
#line 133 "gzip.h"
unsigned int outcnt  ;
#line 135 "gzip.h"
long bytes_in  ;
#line 136 "gzip.h"
long bytes_out  ;
#line 137 "gzip.h"
long header_bytes  ;
#line 142 "gzip.h"
int ifd  ;
#line 143 "gzip.h"
int ofd  ;
#line 144 "gzip.h"
char ifname[1024]  ;
#line 145 "gzip.h"
char ofname[1024]  ;
#line 146 "gzip.h"
char *progname  ;
#line 148 "gzip.h"
long time_stamp  ;
#line 149 "gzip.h"
long ifile_size  ;
#line 193 "gzip.h"
int decrypt  ;
#line 194
int exit_code ;
#line 195
int verbose ;
#line 196
int quiet ;
#line 197
int level ;
#line 198
int test ;
#line 199
int to_stdout ;
#line 200 "gzip.h"
int save_orig_name  ;
#line 262
int zip(int in___6 , int out___5 ) ;
#line 263
int file_read(char *buf___2 , unsigned int size___0 ) ;
#line 266
int unzip(int in___4 , int out___3 ) ;
#line 267
int check_zipfile(int in___3 ) ;
#line 270
int unpack(int in___2 , int out___2 ) ;
#line 273
int unlzh(int in___0 , int out___0 ) ;
#line 276
void abort_gzip(void) ;
#line 279
void lm_init(int pack_level , unsigned short *flags ) ;
#line 280
unsigned long deflate(void) ;
#line 283
void ct_init(unsigned short *attr , int *methodp ) ;
#line 284
int ct_tally(int dist___0 , int lc ) ;
#line 285
unsigned long flush_block(char *buf , unsigned long stored_len , int eof ) ;
#line 288
void bi_init(file_t zipfile ) ;
#line 289
void send_bits(int value , int length ) ;
#line 290
unsigned int bi_reverse(unsigned int code , int len ) ;
#line 291
void bi_windup(void) ;
#line 292
void copy_block(char *buf , unsigned int len , int header ) ;
#line 293 "gzip.h"
int (*read_buf)(char *buf , unsigned int size )  ;
#line 296
int copy(int in___5 , int out___4 ) ;
#line 297
unsigned long updcrc(unsigned char *s___0 , unsigned int n___19 ) ;
#line 298
void clear_bufs(void) ;
#line 299
int fill_inbuf(int eof_ok ) ;
#line 300
void flush_outbuf(void) ;
#line 301
void flush_window(void) ;
#line 302
void write_buf(int fd , void *buf___1 , unsigned int cnt ) ;
#line 303
char *strlwr(char *s___1 ) ;
#line 304
char *basename(char *fname ) ;
#line 305
void make_simple_name(char *name ) ;
#line 306
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) ;
#line 307
void error(char *m___3 ) ;
#line 308
void warn(char *a___0 , char *b___4 ) ;
#line 309
void read_error(void) ;
#line 310
void write_error(void) ;
#line 311
void display_ratio(long num , long den , struct _IO_FILE *file ) ;
#line 312
void *xmalloc(unsigned int size ) ;
#line 315
int inflate(void) ;
#line 70 "bits.c"
static file_t zfile  ;
#line 72 "bits.c"
static unsigned short bi_buf  ;
#line 82 "bits.c"
static int bi_valid  ;
#line 97 "bits.c"
void bi_init(file_t zipfile ) 
{ 


  {
#line 100
  zfile = zipfile;
#line 101
  bi_buf = (unsigned short)0;
#line 102
  bi_valid = 0;
#line 110
  if (zfile != -1) {
#line 111
    read_buf = & file_read;
  }
#line 113
  return;
}
}
#line 119 "bits.c"
void send_bits(int value , int length ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 132
  if (bi_valid > (int )(16UL * sizeof(char )) - length) {
#line 133
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 134
    if (outcnt < 16382U) {
#line 134
      tmp = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 134
      tmp___0 = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 134
      tmp___1 = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 134
      if (outcnt == 16384U) {
        {
#line 134
        flush_outbuf();
        }
      }
#line 134
      tmp___2 = outcnt;
#line 134
      outcnt ++;
#line 134
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 134
      if (outcnt == 16384U) {
        {
#line 134
        flush_outbuf();
        }
      }
    }
#line 135
    bi_buf = (unsigned short )((int )((ush )value) >> (16UL * sizeof(char ) - (unsigned long )bi_valid));
#line 136
    bi_valid = (int )((unsigned long )bi_valid + ((unsigned long )length - 16UL * sizeof(char )));
  } else {
#line 138
    bi_buf = (unsigned short )((int )bi_buf | (value << bi_valid));
#line 139
    bi_valid += length;
  }
#line 141
  return;
}
}
#line 148 "bits.c"
unsigned int bi_reverse(unsigned int code , int len ) 
{ 
  register unsigned int res ;

  {
#line 152
  res = 0U;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    res |= code & 1U;
#line 155
    code >>= 1;
#line 155
    res <<= 1;
#line 153
    len --;
#line 153
    if (! (len > 0)) {
#line 153
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return (res >> 1);
}
}
#line 163 "bits.c"
void bi_windup(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 165
  if (bi_valid > 8) {
#line 166
    if (outcnt < 16382U) {
#line 166
      tmp = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp] = (uch )((int )bi_buf & 255);
#line 166
      tmp___0 = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp___0] = (uch )((int )bi_buf >> 8);
    } else {
#line 166
      tmp___1 = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp___1] = (uch )((int )bi_buf & 255);
#line 166
      if (outcnt == 16384U) {
        {
#line 166
        flush_outbuf();
        }
      }
#line 166
      tmp___2 = outcnt;
#line 166
      outcnt ++;
#line 166
      outbuf[tmp___2] = (uch )((int )bi_buf >> 8);
#line 166
      if (outcnt == 16384U) {
        {
#line 166
        flush_outbuf();
        }
      }
    }
  } else
#line 167
  if (bi_valid > 0) {
#line 168
    tmp___3 = outcnt;
#line 168
    outcnt ++;
#line 168
    outbuf[tmp___3] = (uch )bi_buf;
#line 168
    if (outcnt == 16384U) {
      {
#line 168
      flush_outbuf();
      }
    }
  }
#line 170
  bi_buf = (unsigned short)0;
#line 171
  bi_valid = 0;
#line 175
  return;
}
}
#line 181 "bits.c"
void copy_block(char *buf , unsigned int len , int header ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  char *tmp___8 ;
  unsigned int tmp___9 ;

  {
  {
#line 186
  bi_windup();
  }
#line 188
  if (header) {
#line 189
    if (outcnt < 16382U) {
#line 189
      tmp = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp] = (uch )((int )((ush )len) & 255);
#line 189
      tmp___0 = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp___0] = (uch )((int )((ush )len) >> 8);
    } else {
#line 189
      tmp___1 = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp___1] = (uch )((int )((ush )len) & 255);
#line 189
      if (outcnt == 16384U) {
        {
#line 189
        flush_outbuf();
        }
      }
#line 189
      tmp___2 = outcnt;
#line 189
      outcnt ++;
#line 189
      outbuf[tmp___2] = (uch )((int )((ush )len) >> 8);
#line 189
      if (outcnt == 16384U) {
        {
#line 189
        flush_outbuf();
        }
      }
    }
#line 190
    if (outcnt < 16382U) {
#line 190
      tmp___3 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___3] = (uch )((int )((ush )(~ len)) & 255);
#line 190
      tmp___4 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___4] = (uch )((int )((ush )(~ len)) >> 8);
    } else {
#line 190
      tmp___5 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___5] = (uch )((int )((ush )(~ len)) & 255);
#line 190
      if (outcnt == 16384U) {
        {
#line 190
        flush_outbuf();
        }
      }
#line 190
      tmp___6 = outcnt;
#line 190
      outcnt ++;
#line 190
      outbuf[tmp___6] = (uch )((int )((ush )(~ len)) >> 8);
#line 190
      if (outcnt == 16384U) {
        {
#line 190
        flush_outbuf();
        }
      }
    }
  }
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    tmp___9 = len;
#line 198
    len --;
#line 198
    if (! tmp___9) {
#line 198
      goto while_break;
    }
#line 203
    tmp___7 = outcnt;
#line 203
    outcnt ++;
#line 203
    tmp___8 = buf;
#line 203
    buf ++;
#line 203
    outbuf[tmp___7] = (uch )*tmp___8;
#line 203
    if (outcnt == 16384U) {
      {
#line 203
      flush_outbuf();
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 38 "lzw.h"
int maxbits ;
#line 39
int block_mode ;
#line 41
int lzw(int in , int out ) ;
#line 42
int unlzw(int in___1 , int out___1 ) ;
#line 154 "deflate.c"
ulg___0 window_size  =    65536UL;
#line 159 "deflate.c"
long block_start  ;
#line 164 "deflate.c"
static unsigned int ins_h  ;
#line 173 "deflate.c"
unsigned int prev_length  ;
#line 178 "deflate.c"
unsigned int strstart  ;
#line 179 "deflate.c"
unsigned int match_start  ;
#line 180 "deflate.c"
static int eofile  ;
#line 181 "deflate.c"
static unsigned int lookahead  ;
#line 183 "deflate.c"
unsigned int max_chain_length  ;
#line 188 "deflate.c"
static unsigned int max_lazy_match  ;
#line 199 "deflate.c"
static int compr_level  ;
#line 202 "deflate.c"
unsigned int good_match  ;
#line 222 "deflate.c"
int nice_match  ;
#line 225 "deflate.c"
static config configuration_table[10]  = 
#line 225
  {      {(ush___0 )0, (ush___0 )0, (ush___0 )0, (ush___0 )0}, 
        {(ush___0 )4, (ush___0 )4, (ush___0 )8, (ush___0 )4}, 
        {(ush___0 )4, (ush___0 )5, (ush___0 )16, (ush___0 )8}, 
        {(ush___0 )4, (ush___0 )6, (ush___0 )32, (ush___0 )32}, 
        {(ush___0 )4, (ush___0 )4, (ush___0 )16, (ush___0 )16}, 
        {(ush___0 )8, (ush___0 )16, (ush___0 )32, (ush___0 )32}, 
        {(ush___0 )8, (ush___0 )16, (ush___0 )128, (ush___0 )128}, 
        {(ush___0 )8, (ush___0 )32, (ush___0 )128, (ush___0 )256}, 
        {(ush___0 )32, (ush___0 )128, (ush___0 )258, (ush___0 )1024}, 
        {(ush___0 )32, (ush___0 )258, (ush___0 )258, (ush___0 )4096}};
#line 250
static void fill_window(void) ;
#line 251
static ulg___0 deflate_fast(void) ;
#line 253
int longest_match(IPos cur_match ) ;
#line 286 "deflate.c"
void lm_init(int pack_level , unsigned short *flags ) 
{ 
  register unsigned int j ;
  unsigned int tmp ;
  int tmp___0 ;

  {
#line 292
  if (pack_level < 1) {
    {
#line 292
    error((char *)"bad pack level");
    }
  } else
#line 292
  if (pack_level > 9) {
    {
#line 292
    error((char *)"bad pack level");
    }
  }
  {
#line 293
  compr_level = pack_level;
#line 299
  memset((voidp___0 )((char *)(prev + 32768)), 0, (unsigned long )((unsigned int )(1 << 15)) * sizeof(*(prev + 32768)));
#line 305
  max_lazy_match = (unsigned int )configuration_table[pack_level].max_lazy;
#line 306
  good_match = (unsigned int )configuration_table[pack_level].good_length;
#line 308
  nice_match = (int )configuration_table[pack_level].nice_length;
#line 310
  max_chain_length = (unsigned int )configuration_table[pack_level].max_chain;
  }
#line 311
  if (pack_level == 1) {
#line 312
    *flags = (unsigned short )((int )*flags | 4);
  } else
#line 313
  if (pack_level == 9) {
#line 314
    *flags = (unsigned short )((int )*flags | 2);
  }
#line 318
  strstart = 0U;
#line 319
  block_start = 0L;
#line 324
  if (sizeof(int ) <= 2UL) {
#line 324
    tmp = 32768U;
  } else {
#line 324
    tmp = 65536U;
  }
  {
#line 324
  tmp___0 = (*read_buf)((char *)(window), tmp);
#line 324
  lookahead = (unsigned int )tmp___0;
  }
#line 327
  if (lookahead == 0U) {
#line 328
    eofile = 1;
#line 328
    lookahead = 0U;
#line 329
    return;
  } else
#line 327
  if (lookahead == 4294967295U) {
#line 328
    eofile = 1;
#line 328
    lookahead = 0U;
#line 329
    return;
  }
#line 331
  eofile = 0;
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (lookahead < 262U) {
#line 335
      if (! (! eofile)) {
#line 335
        goto while_break;
      }
    } else {
#line 335
      goto while_break;
    }
    {
#line 335
    fill_window();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  ins_h = 0U;
#line 338
  j = 0U;
  {
#line 338
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! (j < 2U)) {
#line 338
      goto while_break___0;
    }
#line 338
    ins_h = ((ins_h << 5) ^ (unsigned int )window[j]) & ((unsigned int )(1 << 15) - 1U);
#line 338
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 357 "deflate.c"
int longest_match(IPos cur_match ) 
{ 
  unsigned int chain_length ;
  register uch___0 *scan ;
  register uch___0 *match ;
  register int len ;
  int best_len ;
  IPos limit ;
  unsigned int tmp ;
  register uch___0 *strend ;
  register uch___0 scan_end1 ;
  register uch___0 scan_end ;

  {
#line 360
  chain_length = max_chain_length;
#line 361
  scan = window + strstart;
#line 364
  best_len = (int )prev_length;
#line 365
  if (strstart > 32506U) {
#line 365
    tmp = strstart - 32506U;
  } else {
#line 365
    tmp = 0U;
  }
#line 365
  limit = tmp;
#line 385
  strend = (window + strstart) + 258;
#line 386
  scan_end1 = *(scan + (best_len - 1));
#line 387
  scan_end = *(scan + best_len);
#line 391
  if (prev_length >= good_match) {
#line 392
    chain_length >>= 2;
  }
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    match = window + cur_match;
#line 437
    if ((int )*(match + best_len) != (int )scan_end) {
#line 440
      goto __Cont;
    } else
#line 437
    if ((int )*(match + (best_len - 1)) != (int )scan_end1) {
#line 440
      goto __Cont;
    } else
#line 437
    if ((int )*match != (int )*scan) {
#line 440
      goto __Cont;
    } else {
#line 437
      match ++;
#line 437
      if ((int )*match != (int )*(scan + 1)) {
#line 440
        goto __Cont;
      }
    }
#line 448
    scan += 2;
#line 448
    match ++;
    {
#line 453
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 453
      scan ++;
#line 453
      match ++;
#line 453
      if ((int )*scan == (int )*match) {
#line 453
        scan ++;
#line 453
        match ++;
#line 453
        if ((int )*scan == (int )*match) {
#line 453
          scan ++;
#line 453
          match ++;
#line 453
          if ((int )*scan == (int )*match) {
#line 453
            scan ++;
#line 453
            match ++;
#line 453
            if ((int )*scan == (int )*match) {
#line 453
              scan ++;
#line 453
              match ++;
#line 453
              if ((int )*scan == (int )*match) {
#line 453
                scan ++;
#line 453
                match ++;
#line 453
                if ((int )*scan == (int )*match) {
#line 453
                  scan ++;
#line 453
                  match ++;
#line 453
                  if ((int )*scan == (int )*match) {
#line 453
                    scan ++;
#line 453
                    match ++;
#line 453
                    if ((int )*scan == (int )*match) {
#line 453
                      if (! ((unsigned long )scan < (unsigned long )strend)) {
#line 453
                        goto while_break___0;
                      }
                    } else {
#line 453
                      goto while_break___0;
                    }
                  } else {
#line 453
                    goto while_break___0;
                  }
                } else {
#line 453
                  goto while_break___0;
                }
              } else {
#line 453
                goto while_break___0;
              }
            } else {
#line 453
              goto while_break___0;
            }
          } else {
#line 453
            goto while_break___0;
          }
        } else {
#line 453
          goto while_break___0;
        }
      } else {
#line 453
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 460
    len = 258 - (int )(strend - scan);
#line 461
    scan = strend - 258;
#line 465
    if (len > best_len) {
#line 466
      match_start = cur_match;
#line 467
      best_len = len;
#line 468
      if (len >= nice_match) {
#line 468
        goto while_break;
      }
#line 472
      scan_end1 = *(scan + (best_len - 1));
#line 473
      scan_end = *(scan + best_len);
    }
    __Cont: /* CIL Label */ 
#line 396
    cur_match = (IPos )prev[cur_match & 32767U];
#line 396
    if (cur_match > limit) {
#line 396
      chain_length --;
#line 396
      if (! (chain_length != 0U)) {
#line 396
        goto while_break;
      }
    } else {
#line 396
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 479
  return (best_len);
}
}
#line 516 "deflate.c"
static void fill_window(void) 
{ 
  register unsigned int n ;
  register unsigned int m ;
  unsigned int more ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;

  {
#line 519
  more = (unsigned int )((window_size - (ulg___0 )lookahead) - (ulg___0 )strstart);
#line 525
  if (more == 4294967295U) {
#line 529
    more --;
  } else
#line 530
  if (strstart >= 65274U) {
    {
#line 536
    memcpy((void */* __restrict  */)((char *)(window)), (void const   */* __restrict  */)((char *)(window) + 32768),
           32768UL);
#line 537
    match_start -= 32768U;
#line 538
    strstart -= 32768U;
#line 540
    block_start -= 32768L;
#line 542
    n = 0U;
    }
    {
#line 542
    while (1) {
      while_continue: /* CIL Label */ ;
#line 542
      if (! (n < (unsigned int )(1 << 15))) {
#line 542
        goto while_break;
      }
#line 543
      m = (unsigned int )*((prev + 32768) + n);
#line 544
      if (m >= 32768U) {
#line 544
        tmp = m - 32768U;
      } else {
#line 544
        tmp = 0U;
      }
#line 544
      *((prev + 32768) + n) = (Pos )tmp;
#line 542
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 546
    n = 0U;
    {
#line 546
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 546
      if (! (n < 32768U)) {
#line 546
        goto while_break___0;
      }
#line 547
      m = (unsigned int )prev[n];
#line 548
      if (m >= 32768U) {
#line 548
        tmp___0 = m - 32768U;
      } else {
#line 548
        tmp___0 = 0U;
      }
#line 548
      prev[n] = (Pos )tmp___0;
#line 546
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 553
    more += 32768U;
  }
#line 556
  if (! eofile) {
    {
#line 557
    tmp___1 = (*read_buf)(((char *)(window) + strstart) + lookahead, more);
#line 557
    n = (unsigned int )tmp___1;
    }
#line 558
    if (n == 0U) {
#line 559
      eofile = 1;
    } else
#line 558
    if (n == 4294967295U) {
#line 559
      eofile = 1;
    } else {
#line 561
      lookahead += n;
    }
  }
#line 564
  return;
}
}
#line 580 "deflate.c"
static ulg___0 deflate_fast(void) 
{ 
  IPos hash_head ;
  int flush ;
  unsigned int match_length ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned long tmp___2 ;

  {
#line 584
  match_length = 0U;
#line 586
  prev_length = 2U;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! (lookahead != 0U)) {
#line 587
      goto while_break;
    }
#line 591
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 591
    hash_head = (IPos )*((prev + 32768) + ins_h);
#line 591
    prev[strstart & 32767U] = (unsigned short )hash_head;
#line 591
    *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 596
    if (hash_head != 0U) {
#line 596
      if (strstart - hash_head <= 32506U) {
        {
#line 601
        tmp = longest_match(hash_head);
#line 601
        match_length = (unsigned int )tmp;
        }
#line 603
        if (match_length > lookahead) {
#line 603
          match_length = lookahead;
        }
      }
    }
#line 605
    if (match_length >= 3U) {
      {
#line 608
      flush = ct_tally((int )(strstart - match_start), (int )(match_length - 3U));
#line 610
      lookahead -= match_length;
      }
#line 615
      if (match_length <= max_lazy_match) {
#line 616
        match_length --;
        {
#line 617
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 618
          strstart ++;
#line 619
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 619
          hash_head = (IPos )*((prev + 32768) + ins_h);
#line 619
          prev[strstart & 32767U] = (unsigned short )hash_head;
#line 619
          *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 617
          match_length --;
#line 617
          if (! (match_length != 0U)) {
#line 617
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 626
        strstart ++;
      } else {
#line 628
        strstart += match_length;
#line 629
        match_length = 0U;
#line 630
        ins_h = (unsigned int )window[strstart];
#line 631
        ins_h = ((ins_h << 5) ^ (unsigned int )window[strstart + 1U]) & ((unsigned int )(1 << 15) - 1U);
      }
    } else {
      {
#line 639
      flush = ct_tally(0, (int )window[strstart]);
#line 640
      lookahead --;
#line 641
      strstart ++;
      }
    }
#line 643
    if (flush) {
#line 643
      if (block_start >= 0L) {
#line 643
        tmp___0 = (char *)(& window[(unsigned int )block_start]);
      } else {
#line 643
        tmp___0 = (char *)((void *)0);
      }
      {
#line 643
      flush_block(tmp___0, (unsigned long )((long )strstart - block_start), 0);
#line 643
      block_start = (long )strstart;
      }
    }
    {
#line 650
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 650
      if (lookahead < 262U) {
#line 650
        if (! (! eofile)) {
#line 650
          goto while_break___1;
        }
      } else {
#line 650
        goto while_break___1;
      }
      {
#line 650
      fill_window();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if (block_start >= 0L) {
#line 653
    tmp___1 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 653
    tmp___1 = (char *)((void *)0);
  }
  {
#line 653
  tmp___2 = flush_block(tmp___1, (unsigned long )((long )strstart - block_start),
                        1);
  }
#line 653
  return (tmp___2);
}
}
#line 661 "deflate.c"
unsigned long deflate(void) 
{ 
  IPos hash_head ;
  IPos prev_match ;
  int flush ;
  int match_available ;
  register unsigned int match_length ;
  ulg___0 tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  unsigned long tmp___5 ;

  {
#line 666
  match_available = 0;
#line 667
  match_length = 2U;
#line 672
  if (compr_level <= 3) {
    {
#line 672
    tmp = deflate_fast();
    }
#line 672
    return (tmp);
  }
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 675
    if (! (lookahead != 0U)) {
#line 675
      goto while_break;
    }
#line 679
    ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 679
    hash_head = (IPos )*((prev + 32768) + ins_h);
#line 679
    prev[strstart & 32767U] = (unsigned short )hash_head;
#line 679
    *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 683
    prev_length = match_length;
#line 683
    prev_match = match_start;
#line 684
    match_length = 2U;
#line 686
    if (hash_head != 0U) {
#line 686
      if (prev_length < max_lazy_match) {
#line 686
        if (strstart - hash_head <= 32506U) {
          {
#line 692
          tmp___0 = longest_match(hash_head);
#line 692
          match_length = (unsigned int )tmp___0;
          }
#line 694
          if (match_length > lookahead) {
#line 694
            match_length = lookahead;
          }
#line 697
          if (match_length == 3U) {
#line 697
            if (strstart - match_start > 4096U) {
#line 701
              match_length --;
            }
          }
        }
      }
    }
#line 707
    if (prev_length >= 3U) {
#line 707
      if (match_length <= prev_length) {
        {
#line 711
        flush = ct_tally((int )((strstart - 1U) - prev_match), (int )(prev_length - 3U));
#line 716
        lookahead -= prev_length - 1U;
#line 717
        prev_length -= 2U;
        }
        {
#line 718
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 719
          strstart ++;
#line 720
          ins_h = ((ins_h << 5) ^ (unsigned int )window[(strstart + 3U) - 1U]) & ((unsigned int )(1 << 15) - 1U);
#line 720
          hash_head = (IPos )*((prev + 32768) + ins_h);
#line 720
          prev[strstart & 32767U] = (unsigned short )hash_head;
#line 720
          *((prev + 32768) + ins_h) = (unsigned short )strstart;
#line 718
          prev_length --;
#line 718
          if (! (prev_length != 0U)) {
#line 718
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 727
        match_available = 0;
#line 728
        match_length = 2U;
#line 729
        strstart ++;
#line 730
        if (flush) {
#line 730
          if (block_start >= 0L) {
#line 730
            tmp___1 = (char *)(& window[(unsigned int )block_start]);
          } else {
#line 730
            tmp___1 = (char *)((void *)0);
          }
          {
#line 730
          flush_block(tmp___1, (unsigned long )((long )strstart - block_start), 0);
#line 730
          block_start = (long )strstart;
          }
        }
      } else {
#line 707
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 732
    if (match_available) {
      {
#line 738
      tmp___3 = ct_tally(0, (int )window[strstart - 1U]);
      }
#line 738
      if (tmp___3) {
#line 739
        if (block_start >= 0L) {
#line 739
          tmp___2 = (char *)(& window[(unsigned int )block_start]);
        } else {
#line 739
          tmp___2 = (char *)((void *)0);
        }
        {
#line 739
        flush_block(tmp___2, (unsigned long )((long )strstart - block_start), 0);
#line 739
        block_start = (long )strstart;
        }
      }
#line 741
      strstart ++;
#line 742
      lookahead --;
    } else {
#line 747
      match_available = 1;
#line 748
      strstart ++;
#line 749
      lookahead --;
    }
    {
#line 758
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 758
      if (lookahead < 262U) {
#line 758
        if (! (! eofile)) {
#line 758
          goto while_break___1;
        }
      } else {
#line 758
        goto while_break___1;
      }
      {
#line 758
      fill_window();
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 760
  if (match_available) {
    {
#line 760
    ct_tally(0, (int )window[strstart - 1U]);
    }
  }
#line 762
  if (block_start >= 0L) {
#line 762
    tmp___4 = (char *)(& window[(unsigned int )block_start]);
  } else {
#line 762
    tmp___4 = (char *)((void *)0);
  }
  {
#line 762
  tmp___5 = flush_block(tmp___4, (unsigned long )((long )strstart - block_start),
                        1);
  }
#line 762
  return (tmp___5);
}
}
#line 12 "gzip.c"
static char *license_msg[15]  = 
#line 12 "gzip.c"
  {      (char *)"   Copyright (C) 1992-1993 Jean-loup Gailly",      (char *)"   This program is free software; you can redistribute it and/or modify",      (char *)"   it under the terms of the GNU General Public License as published by",      (char *)"   the Free Software Foundation; either version 2, or (at your option)", 
        (char *)"   any later version.",      (char *)"",      (char *)"   This program is distributed in the hope that it will be useful,",      (char *)"   but WITHOUT ANY WARRANTY; without even the implied warranty of", 
        (char *)"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",      (char *)"   GNU General Public License for more details.",      (char *)"",      (char *)"   You should have received a copy of the GNU General Public License", 
        (char *)"   along with this program; if not, write to the Free Software",      (char *)"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",      (char *)0};
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 280
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t___2 __mode ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 31 "getopt.h"
extern char *optarg ;
#line 45
extern int optind ;
#line 104
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 142 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 539
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(unsigned long __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(unsigned long __nmemb ,
                                                                               unsigned long __size )  __attribute__((__malloc__)) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 631
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 44 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 201 "gzip.c"
int ascii  =    0;
#line 202 "gzip.c"
int to_stdout  =    0;
#line 203 "gzip.c"
int decompress  =    0;
#line 204 "gzip.c"
int force  =    0;
#line 205 "gzip.c"
int no_name  =    -1;
#line 206 "gzip.c"
int no_time  =    -1;
#line 207 "gzip.c"
int recursive  =    0;
#line 208 "gzip.c"
int list  =    0;
#line 209 "gzip.c"
int verbose  =    0;
#line 210 "gzip.c"
int quiet  =    0;
#line 211 "gzip.c"
int do_lzw  =    0;
#line 212 "gzip.c"
int test  =    0;
#line 213 "gzip.c"
int foreground  ;
#line 215 "gzip.c"
int maxbits  =    16;
#line 216 "gzip.c"
int method  =    8;
#line 217 "gzip.c"
int level  =    6;
#line 218 "gzip.c"
int exit_code  =    0;
#line 220 "gzip.c"
int last_member  ;
#line 221 "gzip.c"
int part_nb  ;
#line 224 "gzip.c"
char *env  ;
#line 225 "gzip.c"
char **args  =    (char **)((void *)0);
#line 226 "gzip.c"
char z_suffix[31]  ;
#line 227 "gzip.c"
int z_len  ;
#line 231 "gzip.c"
long total_in  =    0L;
#line 232 "gzip.c"
long total_out  =    0L;
#line 235 "gzip.c"
int remove_ofname  =    0;
#line 236 "gzip.c"
struct stat istat  ;
#line 243 "gzip.c"
struct option longopts[24]  = 
#line 243
  {      {"ascii", 0, (int *)0, 'a'}, 
        {"to-stdout", 0, (int *)0, 'c'}, 
        {"stdout", 0, (int *)0, 'c'}, 
        {"decompress", 0, (int *)0, 'd'}, 
        {"uncompress", 0, (int *)0, 'd'}, 
        {"force", 0, (int *)0, 'f'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"list", 0, (int *)0, 'l'}, 
        {"license", 0, (int *)0, 'L'}, 
        {"no-name", 0, (int *)0, 'n'}, 
        {"name", 0, (int *)0, 'N'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {"silent", 0, (int *)0, 'q'}, 
        {"recursive", 0, (int *)0, 'r'}, 
        {"suffix", 1, (int *)0, 'S'}, 
        {"test", 0, (int *)0, 't'}, 
        {"no-time", 0, (int *)0, 'T'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"version", 0, (int *)0, 'V'}, 
        {"fast", 0, (int *)0, '1'}, 
        {"best", 0, (int *)0, '9'}, 
        {"lzw", 0, (int *)0, 'Z'}, 
        {"bits", 1, (int *)0, 'b'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 276
static void usage(void) ;
#line 277
static void help(void) ;
#line 278
static void license(void) ;
#line 279
static void version(void) ;
#line 280
static void treat_stdin(void) ;
#line 281
static void treat_file(char *iname ) ;
#line 282
static int create_outfile(void) ;
#line 283
static int do_stat(char *name , struct stat *sbuf ) ;
#line 284
static char *get_suffix(char *name ) ;
#line 285
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 286
static int make_ofname(void) ;
#line 287
static int same_file(struct stat *stat1 , struct stat *stat2 ) ;
#line 288
static int name_too_long(char *name , struct stat *statb ) ;
#line 289
static void shorten_name(char *name ) ;
#line 290
static int get_method(int in ) ;
#line 291
static void do_list(int ifd___0 , int method___0 ) ;
#line 292
static int check_ofname(void) ;
#line 293
static void copy_stat(struct stat *ifstat ) ;
#line 294
static void do_exit(int exitcode ) ;
#line 295
int main(int argc , char **argv ) ;
#line 296 "gzip.c"
int (*work)(int infile , int outfile )  =    & zip;
#line 302
static void reset_times(char *name , struct stat *statb ) ;
#line 308 "gzip.c"
static void usage(void) 
{ 


  {
  {
#line 310
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n",
          progname, "", "");
  }
#line 323
  return;
}
}
#line 328
static void help(void) ;
#line 328 "gzip.c"
static char *help_msg[17]  = 
#line 328
  {      (char *)" -c --stdout      write on standard output, keep original files unchanged",      (char *)" -d --decompress  decompress",      (char *)" -f --force       force overwrite of output file and compress links",      (char *)" -h --help        give this help", 
        (char *)" -l --list        list compressed file contents",      (char *)" -L --license     display software license",      (char *)" -n --no-name     do not save or restore the original name and time stamp",      (char *)" -N --name        save or restore the original name and time stamp", 
        (char *)" -q --quiet       suppress all warnings",      (char *)" -S .suf  --suffix .suf     use suffix .suf on compressed files",      (char *)" -t --test        test compressed file integrity",      (char *)" -v --verbose     verbose mode", 
        (char *)" -V --version     display version number",      (char *)" -1 --fast        compress faster",      (char *)" -9 --best        compress better",      (char *)" file...          files to (de)compress. If none given, use standard input.", 
        (char *)0};
#line 326 "gzip.c"
static void help(void) 
{ 
  char **p ;
  char **tmp ;

  {
  {
#line 362
  p = help_msg;
#line 364
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
#line 365
  usage();
  }
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! *p) {
#line 366
      goto while_break;
    }
    {
#line 366
    tmp = p;
#line 366
    p ++;
#line 366
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  return;
}
}
#line 370 "gzip.c"
static void license(void) 
{ 
  char **p ;
  char **tmp ;

  {
  {
#line 372
  p = license_msg;
#line 374
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
  }
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! *p) {
#line 375
      goto while_break;
    }
    {
#line 375
    tmp = p;
#line 375
    p ++;
#line 375
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            *tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return;
}
}
#line 379 "gzip.c"
static void version(void) 
{ 


  {
  {
#line 381
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s %s (%s)\n",
          progname, "1.2.4", "18 Aug 93");
#line 383
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Compilation options:\n%s %s ",
          "NO_DIR", "UTIME");
#line 420
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 421
  return;
}
}
#line 424 "gzip.c"
int main(int argc , char **argv ) 
{ 
  int file_count ;
  int proglen ;
  int optc ;
  unsigned long tmp ;
  int tmp___0 ;
  __sighandler_t tmp___1 ;
  __sighandler_t tmp___2 ;
  __sighandler_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 434
  progname = basename(*(argv + 0));
#line 435
  tmp = strlen((char const   *)progname);
#line 435
  proglen = (int )tmp;
  }
#line 438
  if (proglen > 4) {
    {
#line 438
    tmp___0 = strcmp((char const   *)((progname + proglen) - 4), ".exe");
    }
#line 438
    if (tmp___0 == 0) {
#line 439
      *(progname + (proglen - 4)) = (char )'\000';
    }
  }
  {
#line 443
  env = add_envopt(& argc, & argv, (char *)"GZIP");
  }
#line 444
  if ((unsigned long )env != (unsigned long )((void *)0)) {
#line 444
    args = argv;
  }
  {
#line 446
  tmp___1 = signal(2, (void (*)(int  ))1);
#line 446
  foreground = (unsigned long )tmp___1 != (unsigned long )((void (*)(int  ))1);
  }
#line 447
  if (foreground) {
    {
#line 448
    signal(2, (void (*)(int  ))(& abort_gzip));
    }
  }
  {
#line 451
  tmp___2 = signal(15, (void (*)(int  ))1);
  }
#line 451
  if ((unsigned long )tmp___2 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 452
    signal(15, (void (*)(int  ))(& abort_gzip));
    }
  }
  {
#line 456
  tmp___3 = signal(1, (void (*)(int  ))1);
  }
#line 456
  if ((unsigned long )tmp___3 != (unsigned long )((void (*)(int  ))1)) {
    {
#line 457
    signal(1, (void (*)(int  ))(& abort_gzip));
    }
  }
  {
#line 469
  tmp___6 = strncmp((char const   *)progname, "un", 2UL);
  }
#line 469
  if (tmp___6 == 0) {
#line 471
    decompress = 1;
  } else {
    {
#line 469
    tmp___7 = strncmp((char const   *)progname, "gun", 3UL);
    }
#line 469
    if (tmp___7 == 0) {
#line 471
      decompress = 1;
    } else {
      {
#line 472
      tmp___4 = strcmp((char const   *)(progname + 1), "cat");
      }
#line 472
      if (tmp___4 == 0) {
#line 474
        to_stdout = 1;
#line 474
        decompress = to_stdout;
      } else {
        {
#line 472
        tmp___5 = strcmp((char const   *)progname, "gzcat");
        }
#line 472
        if (tmp___5 == 0) {
#line 474
          to_stdout = 1;
#line 474
          decompress = to_stdout;
        }
      }
    }
  }
  {
#line 478
  strncpy((char */* __restrict  */)(z_suffix), (char const   */* __restrict  */)".gz",
          sizeof(z_suffix) - 1UL);
#line 479
  tmp___8 = strlen((char const   *)(z_suffix));
#line 479
  z_len = (int )tmp___8;
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 481
    optc = getopt_long(argc, (char * const  *)argv, "ab:cdfhH?lLmMnNqrS:tvVZ123456789",
                       (struct option  const  *)(longopts), (int *)0);
    }
#line 481
    if (! (optc != -1)) {
#line 481
      goto while_break;
    }
    {
#line 484
    if (optc == 97) {
#line 484
      goto case_97;
    }
#line 486
    if (optc == 98) {
#line 486
      goto case_98;
    }
#line 489
    if (optc == 99) {
#line 489
      goto case_99;
    }
#line 491
    if (optc == 100) {
#line 491
      goto case_100;
    }
#line 493
    if (optc == 102) {
#line 493
      goto case_102;
    }
#line 495
    if (optc == 63) {
#line 495
      goto case_63;
    }
#line 495
    if (optc == 72) {
#line 495
      goto case_63;
    }
#line 495
    if (optc == 104) {
#line 495
      goto case_63;
    }
#line 497
    if (optc == 108) {
#line 497
      goto case_108;
    }
#line 499
    if (optc == 76) {
#line 499
      goto case_76;
    }
#line 501
    if (optc == 109) {
#line 501
      goto case_109;
    }
#line 503
    if (optc == 77) {
#line 503
      goto case_77;
    }
#line 505
    if (optc == 110) {
#line 505
      goto case_110;
    }
#line 507
    if (optc == 78) {
#line 507
      goto case_78;
    }
#line 509
    if (optc == 113) {
#line 509
      goto case_113;
    }
#line 511
    if (optc == 114) {
#line 511
      goto case_114;
    }
#line 519
    if (optc == 83) {
#line 519
      goto case_83;
    }
#line 526
    if (optc == 116) {
#line 526
      goto case_116;
    }
#line 529
    if (optc == 118) {
#line 529
      goto case_118;
    }
#line 531
    if (optc == 86) {
#line 531
      goto case_86;
    }
#line 533
    if (optc == 90) {
#line 533
      goto case_90;
    }
#line 543
    if (optc == 57) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 56) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 55) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 54) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 53) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 52) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 51) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 50) {
#line 543
      goto case_57;
    }
#line 543
    if (optc == 49) {
#line 543
      goto case_57;
    }
#line 546
    goto switch_default;
    case_97: /* CIL Label */ 
#line 485
    ascii = 1;
#line 485
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 487
    maxbits = atoi((char const   *)optarg);
    }
#line 488
    goto switch_break;
    case_99: /* CIL Label */ 
#line 490
    to_stdout = 1;
#line 490
    goto switch_break;
    case_100: /* CIL Label */ 
#line 492
    decompress = 1;
#line 492
    goto switch_break;
    case_102: /* CIL Label */ 
#line 494
    force ++;
#line 494
    goto switch_break;
    case_63: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_104: /* CIL Label */ 
    {
#line 496
    help();
#line 496
    do_exit(0);
    }
#line 496
    goto switch_break;
    case_108: /* CIL Label */ 
#line 498
    to_stdout = 1;
#line 498
    decompress = to_stdout;
#line 498
    list = decompress;
#line 498
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 500
    license();
#line 500
    do_exit(0);
    }
#line 500
    goto switch_break;
    case_109: /* CIL Label */ 
#line 502
    no_time = 1;
#line 502
    goto switch_break;
    case_77: /* CIL Label */ 
#line 504
    no_time = 0;
#line 504
    goto switch_break;
    case_110: /* CIL Label */ 
#line 506
    no_time = 1;
#line 506
    no_name = no_time;
#line 506
    goto switch_break;
    case_78: /* CIL Label */ 
#line 508
    no_time = 0;
#line 508
    no_name = no_time;
#line 508
    goto switch_break;
    case_113: /* CIL Label */ 
#line 510
    quiet = 1;
#line 510
    verbose = 0;
#line 510
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 513
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -r not supported on this system\n",
            progname);
#line 514
    usage();
#line 515
    do_exit(1);
    }
#line 515
    goto switch_break;
    case_83: /* CIL Label */ 
    {
#line 523
    tmp___9 = strlen((char const   *)optarg);
#line 523
    z_len = (int )tmp___9;
#line 524
    strcpy((char */* __restrict  */)(z_suffix), (char const   */* __restrict  */)optarg);
    }
#line 525
    goto switch_break;
    case_116: /* CIL Label */ 
#line 527
    to_stdout = 1;
#line 527
    decompress = to_stdout;
#line 527
    test = decompress;
#line 528
    goto switch_break;
    case_118: /* CIL Label */ 
#line 530
    verbose ++;
#line 530
    quiet = 0;
#line 530
    goto switch_break;
    case_86: /* CIL Label */ 
    {
#line 532
    version();
#line 532
    do_exit(0);
    }
#line 532
    goto switch_break;
    case_90: /* CIL Label */ 
    {
#line 537
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: -Z not supported in this version\n",
            progname);
#line 539
    usage();
#line 540
    do_exit(1);
    }
#line 540
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
#line 544
    level = optc - 48;
#line 545
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 548
    usage();
#line 549
    do_exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 556
  if (no_time < 0) {
#line 556
    no_time = decompress;
  }
#line 557
  if (no_name < 0) {
#line 557
    no_name = decompress;
  }
#line 559
  file_count = argc - optind;
#line 563
  if (ascii) {
#line 563
    if (! quiet) {
      {
#line 564
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: option --ascii ignored on this system\n",
              progname);
      }
    }
  }
#line 568
  if (z_len == 0) {
#line 568
    if (! decompress) {
      {
#line 569
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect suffix \'%s\'\n",
              progname, optarg);
#line 571
      do_exit(1);
      }
    } else {
#line 568
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 568
  if (z_len > 30) {
    {
#line 569
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: incorrect suffix \'%s\'\n",
            progname, optarg);
#line 571
    do_exit(1);
    }
  }
#line 573
  if (do_lzw) {
#line 573
    if (! decompress) {
#line 573
      work = & lzw;
    }
  }
#line 588
  if (file_count != 0) {
#line 589
    if (to_stdout) {
#line 589
      if (! test) {
#line 589
        if (! list) {
#line 589
          if (! decompress) {
#line 589
            tmp___10 = 1;
          } else
#line 589
          if (! ascii) {
#line 589
            tmp___10 = 1;
          } else {
#line 589
            tmp___10 = 0;
          }
        } else {
#line 589
          tmp___10 = 0;
        }
      } else {
#line 589
        tmp___10 = 0;
      }
    } else {
#line 589
      tmp___10 = 0;
    }
    {
#line 592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 592
      if (! (optind < argc)) {
#line 592
        goto while_break___0;
      }
      {
#line 593
      tmp___11 = optind;
#line 593
      optind ++;
#line 593
      treat_file(*(argv + tmp___11));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 596
    treat_stdin();
    }
  }
#line 598
  if (list) {
#line 598
    if (! quiet) {
#line 598
      if (file_count > 1) {
        {
#line 599
        do_list(-1, -1);
        }
      }
    }
  }
  {
#line 601
  do_exit(exit_code);
  }
#line 602
  return (exit_code);
}
}
#line 610
extern int ( /* missing proto */  isatty)() ;
#line 608 "gzip.c"
static void treat_stdin(void) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;
  struct _IO_FILE *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 610
  if (! force) {
#line 610
    if (! list) {
#line 610
      if (decompress) {
#line 610
        tmp___1 = stdin;
      } else {
#line 610
        tmp___1 = stdout;
      }
      {
#line 610
      tmp___2 = fileno((struct _IO_FILE *)((FILE___2 *)tmp___1));
#line 610
      tmp___3 = isatty(tmp___2);
      }
#line 610
      if (tmp___3) {
#line 624
        if (decompress) {
#line 624
          tmp = "de";
        } else {
#line 624
          tmp = "";
        }
#line 624
        if (decompress) {
#line 624
          tmp___0 = "read from";
        } else {
#line 624
          tmp___0 = "written to";
        }
        {
#line 624
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: compressed data not %s a terminal. Use -f to force %scompression.\n",
                progname, tmp___0, tmp);
#line 628
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For help, type: %s -h\n",
                progname);
#line 629
        do_exit(1);
        }
      }
    }
  }
#line 632
  if (decompress) {
#line 632
    tmp___4 = 1;
  } else
#line 632
  if (! ascii) {
#line 632
    tmp___4 = 1;
  } else {
#line 632
    tmp___4 = 0;
  }
#line 635
  if (! test) {
#line 635
    if (! list) {
#line 635
      if (! decompress) {
#line 635
        tmp___5 = 1;
      } else
#line 635
      if (! ascii) {
#line 635
        tmp___5 = 1;
      } else {
#line 635
        tmp___5 = 0;
      }
    } else {
#line 635
      tmp___5 = 0;
    }
  } else {
#line 635
    tmp___5 = 0;
  }
  {
#line 638
  strcpy((char */* __restrict  */)(ifname), (char const   */* __restrict  */)"stdin");
#line 639
  strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)"stdout");
#line 642
  time_stamp = 0L;
  }
#line 645
  if (list) {
#line 645
    goto _L;
  } else
#line 645
  if (! no_time) {
    _L: /* CIL Label */ 
    {
#line 646
    tmp___6 = fileno(stdin);
#line 646
    tmp___7 = fstat(tmp___6, & istat);
    }
#line 646
    if (tmp___7 != 0) {
      {
#line 647
      error((char *)"fstat(stdin)");
      }
    }
#line 652
    time_stamp = istat.st_mtim.tv_sec;
  }
  {
#line 655
  ifile_size = -1L;
#line 657
  clear_bufs();
#line 658
  to_stdout = 1;
#line 659
  part_nb = 0;
  }
#line 661
  if (decompress) {
    {
#line 662
    method = get_method(ifd);
    }
#line 663
    if (method < 0) {
      {
#line 664
      do_exit(exit_code);
      }
    }
  }
#line 667
  if (list) {
    {
#line 668
    do_list(ifd, method);
    }
#line 669
    return;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 675
    tmp___8 = fileno(stdout);
#line 675
    tmp___9 = fileno(stdin);
#line 675
    tmp___10 = (*work)(tmp___9, tmp___8);
    }
#line 675
    if (tmp___10 != 0) {
#line 675
      return;
    }
#line 677
    if (! decompress) {
#line 677
      goto while_break;
    } else
#line 677
    if (last_member) {
#line 677
      goto while_break;
    } else
#line 677
    if (inptr == insize) {
#line 677
      goto while_break;
    }
    {
#line 680
    method = get_method(ifd);
    }
#line 681
    if (method < 0) {
#line 681
      return;
    }
#line 682
    bytes_out = 0L;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (verbose) {
#line 686
    if (test) {
      {
#line 687
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" OK\n");
      }
    } else
#line 689
    if (! decompress) {
      {
#line 690
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
#line 691
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 699
  return;
}
}
#line 778
extern int ( /* missing proto */  close)() ;
#line 831
extern int ( /* missing proto */  unlink)() ;
#line 704 "gzip.c"
static void treat_file(char *iname ) 
{ 
  int cflag ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___7 ;
  unsigned long tmp___8 ;
  char const   *tmp___9 ;
  unsigned long tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 708
  tmp = strcmp((char const   *)iname, "-");
  }
#line 708
  if (tmp == 0) {
    {
#line 709
    cflag = to_stdout;
#line 710
    treat_stdin();
#line 711
    to_stdout = cflag;
    }
#line 712
    return;
  }
  {
#line 716
  tmp___0 = get_istat(iname, & istat);
  }
#line 716
  if (tmp___0 != 0) {
#line 716
    return;
  }
#line 719
  if ((istat.st_mode & 61440U) == 16384U) {
#line 731
    if (! quiet) {
      {
#line 731
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is a directory -- ignored\n",
              progname, ifname);
      }
    }
#line 731
    if (exit_code == 0) {
#line 731
      exit_code = 2;
    }
#line 732
    return;
  }
#line 734
  if (! ((istat.st_mode & 61440U) == 32768U)) {
#line 735
    if (! quiet) {
      {
#line 735
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is not a directory or a regular file - ignored\n",
              progname, ifname);
      }
    }
#line 735
    if (exit_code == 0) {
#line 735
      exit_code = 2;
    }
#line 738
    return;
  }
#line 740
  if (istat.st_nlink > 1UL) {
#line 740
    if (! to_stdout) {
#line 740
      if (! force) {
#line 741
        if (! quiet) {
#line 741
          if (istat.st_nlink > 2UL) {
#line 741
            tmp___1 = 's';
          } else {
#line 741
            tmp___1 = ' ';
          }
          {
#line 741
          fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has %d other link%c -- unchanged\n",
                  progname, ifname, (int )istat.st_nlink - 1, tmp___1);
          }
        }
#line 741
        if (exit_code == 0) {
#line 741
          exit_code = 2;
        }
#line 744
        return;
      }
    }
  }
#line 747
  ifile_size = istat.st_size;
#line 748
  if (no_time) {
#line 748
    if (! list) {
#line 748
      time_stamp = 0L;
    } else {
#line 748
      time_stamp = istat.st_mtim.tv_sec;
    }
  } else {
#line 748
    time_stamp = istat.st_mtim.tv_sec;
  }
#line 753
  if (to_stdout) {
#line 753
    if (! list) {
#line 753
      if (! test) {
        {
#line 754
        strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)"stdout");
        }
      } else {
#line 753
        goto _L___0;
      }
    } else {
#line 753
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 756
    tmp___2 = make_ofname();
    }
#line 756
    if (tmp___2 != 0) {
#line 757
      return;
    }
  }
#line 764
  if (ascii) {
#line 764
    if (! decompress) {
#line 764
      tmp___3 = 0;
    } else {
#line 764
      tmp___3 = 0;
    }
  } else {
#line 764
    tmp___3 = 0;
  }
  {
#line 764
  ifd = open((char const   *)(ifname), tmp___3, 384);
  }
#line 766
  if (ifd == -1) {
    {
#line 767
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 768
    perror((char const   *)(ifname));
#line 769
    exit_code = 1;
    }
#line 770
    return;
  }
  {
#line 772
  clear_bufs();
#line 773
  part_nb = 0;
  }
#line 775
  if (decompress) {
    {
#line 776
    method = get_method(ifd);
    }
#line 777
    if (method < 0) {
      {
#line 778
      close(ifd);
      }
#line 779
      return;
    }
  }
#line 782
  if (list) {
    {
#line 783
    do_list(ifd, method);
#line 784
    close(ifd);
    }
#line 785
    return;
  }
#line 792
  if (to_stdout) {
    {
#line 793
    ofd = fileno(stdout);
    }
  } else {
    {
#line 796
    tmp___4 = create_outfile();
    }
#line 796
    if (tmp___4 != 0) {
#line 796
      return;
    }
#line 798
    if (! decompress) {
#line 798
      if (save_orig_name) {
#line 798
        if (! verbose) {
#line 798
          if (! quiet) {
            {
#line 799
            fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s compressed to %s\n",
                    progname, ifname, ofname);
            }
          }
        }
      }
    }
  }
#line 804
  if (! save_orig_name) {
#line 804
    save_orig_name = ! no_name;
  }
#line 806
  if (verbose) {
    {
#line 807
    tmp___10 = strlen((char const   *)(ifname));
    }
#line 807
    if ((int )tmp___10 >= 15) {
#line 807
      tmp___9 = "";
    } else {
      {
#line 807
      tmp___8 = strlen((char const   *)(ifname));
      }
#line 807
      if ((int )tmp___8 >= 7) {
#line 807
        tmp___7 = "\t";
      } else {
#line 807
        tmp___7 = "\t\t";
      }
#line 807
      tmp___9 = tmp___7;
    }
    {
#line 807
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:\t%s",
            ifname, tmp___9);
    }
  }
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 814
    tmp___11 = (*work)(ifd, ofd);
    }
#line 814
    if (tmp___11 != 0) {
#line 815
      method = -1;
#line 816
      goto while_break;
    }
#line 818
    if (! decompress) {
#line 818
      goto while_break;
    } else
#line 818
    if (last_member) {
#line 818
      goto while_break;
    } else
#line 818
    if (inptr == insize) {
#line 818
      goto while_break;
    }
    {
#line 821
    method = get_method(ifd);
    }
#line 822
    if (method < 0) {
#line 822
      goto while_break;
    }
#line 823
    bytes_out = 0L;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  close(ifd);
  }
#line 827
  if (! to_stdout) {
    {
#line 827
    tmp___12 = close(ofd);
    }
#line 827
    if (tmp___12) {
      {
#line 828
      write_error();
      }
    }
  }
#line 830
  if (method == -1) {
#line 831
    if (! to_stdout) {
      {
#line 831
      unlink(ofname);
      }
    }
#line 832
    return;
  }
#line 835
  if (verbose) {
#line 836
    if (test) {
      {
#line 837
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" OK");
      }
    } else
#line 838
    if (decompress) {
      {
#line 839
      display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stderr);
      }
    } else {
      {
#line 841
      display_ratio(bytes_in - (bytes_out - header_bytes), bytes_in, stderr);
      }
    }
#line 843
    if (! test) {
#line 843
      if (! to_stdout) {
        {
#line 844
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -- replaced with %s",
                ofname);
        }
      }
    }
    {
#line 846
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
    }
  }
#line 849
  if (! to_stdout) {
    {
#line 850
    copy_stat(& istat);
    }
  }
#line 852
  return;
}
}
#line 863 "gzip.c"
static int create_outfile(void) 
{ 
  struct stat ostat ;
  int flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 866
  flags = 193;
#line 868
  if (ascii) {
#line 868
    if (decompress) {
#line 869
      flags &= -1;
    }
  }
  {
#line 871
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 873
    tmp = check_ofname();
    }
#line 873
    if (tmp != 0) {
      {
#line 874
      close(ifd);
      }
#line 875
      return (1);
    }
    {
#line 878
    remove_ofname = 1;
#line 879
    ofd = open((char const   *)(ofname), flags, 384);
    }
#line 880
    if (ofd == -1) {
      {
#line 881
      perror((char const   *)(ofname));
#line 882
      close(ifd);
#line 883
      exit_code = 1;
      }
#line 884
      return (1);
    }
    {
#line 891
    tmp___0 = fstat(ofd, & ostat);
    }
#line 891
    if (tmp___0 != 0) {
      {
#line 893
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
#line 894
      perror((char const   *)(ofname));
#line 895
      close(ifd);
#line 895
      close(ofd);
#line 896
      unlink(ofname);
#line 897
      exit_code = 1;
      }
#line 898
      return (1);
    }
    {
#line 900
    tmp___1 = name_too_long(ofname, & ostat);
    }
#line 900
    if (! tmp___1) {
#line 900
      return (0);
    }
#line 902
    if (decompress) {
#line 904
      if (! quiet) {
        {
#line 904
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: warning, name truncated\n",
                progname, ofname);
        }
      }
#line 904
      if (exit_code == 0) {
#line 904
        exit_code = 2;
      }
#line 906
      return (0);
    }
    {
#line 908
    close(ofd);
#line 909
    unlink(ofname);
#line 915
    shorten_name(ofname);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 923 "gzip.c"
static int do_stat(char *name , struct stat *sbuf ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 927
  tmp = __errno_location();
#line 927
  *tmp = 0;
  }
#line 929
  if (! to_stdout) {
#line 929
    if (! force) {
      {
#line 930
      tmp___0 = lstat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)sbuf);
      }
#line 930
      return (tmp___0);
    }
  }
  {
#line 933
  tmp___1 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)sbuf);
  }
#line 933
  return (tmp___1);
}
}
#line 953
static char *get_suffix(char *name ) ;
#line 953 "gzip.c"
static char *known_suffixes[9]  = 
#line 953
  {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)".taz", 
        (char *)".tgz",      (char *)"-gz",      (char *)"-z",      (char *)"_z", 
        (char *)((void *)0)};
#line 948 "gzip.c"
static char *get_suffix(char *name ) 
{ 
  int nlen ;
  int slen ;
  char suffix[33] ;
  char **suf ;
  int tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int s ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
  {
#line 959
  suf = known_suffixes;
#line 961
  tmp = strcmp((char const   *)(z_suffix), "z");
  }
#line 961
  if (tmp == 0) {
#line 961
    suf ++;
  }
  {
#line 970
  tmp___0 = strlen((char const   *)name);
#line 970
  nlen = (int )tmp___0;
  }
#line 971
  if (nlen <= 32) {
    {
#line 972
    strcpy((char */* __restrict  */)(suffix), (char const   */* __restrict  */)name);
    }
  } else {
    {
#line 974
    strcpy((char */* __restrict  */)(suffix), (char const   */* __restrict  */)(((name + nlen) - 30) - 2));
    }
  }
  {
#line 976
  strlwr(suffix);
#line 977
  tmp___1 = strlen((char const   *)(suffix));
#line 977
  slen = (int )tmp___1;
  }
  {
#line 978
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 979
    tmp___2 = strlen((char const   *)*suf);
#line 979
    s = (int )tmp___2;
    }
#line 980
    if (slen > s) {
#line 980
      if ((int )suffix[(slen - s) - 1] != 47) {
        {
#line 980
        tmp___3 = strcmp((char const   *)((suffix + slen) - s), (char const   *)*suf);
        }
#line 980
        if (tmp___3 == 0) {
#line 982
          return ((name + nlen) - s);
        }
      }
    }
#line 978
    suf ++;
#line 978
    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
#line 978
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 986
  return ((char *)((void *)0));
}
}
#line 1002
static int get_istat(char *iname , struct stat *sbuf ) ;
#line 1002 "gzip.c"
static char *suffixes[6]  = {      z_suffix,      (char *)".gz",      (char *)".z",      (char *)"-z", 
        (char *)".Z",      (char *)((void *)0)};
#line 997 "gzip.c"
static int get_istat(char *iname , struct stat *sbuf ) 
{ 
  int ilen ;
  char **suf ;
  char *s ;
  int tmp ;
  int *tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1003
  suf = suffixes;
#line 1009
  strcpy((char */* __restrict  */)(ifname), (char const   */* __restrict  */)iname);
#line 1012
  tmp = do_stat(ifname, sbuf);
  }
#line 1012
  if (tmp == 0) {
#line 1012
    return (0);
  }
#line 1014
  if (! decompress) {
    {
#line 1015
    perror((char const   *)(ifname));
#line 1016
    exit_code = 1;
    }
#line 1017
    return (1);
  } else {
    {
#line 1014
    tmp___0 = __errno_location();
    }
#line 1014
    if (*tmp___0 != 2) {
      {
#line 1015
      perror((char const   *)(ifname));
#line 1016
      exit_code = 1;
      }
#line 1017
      return (1);
    }
  }
  {
#line 1022
  s = get_suffix(ifname);
  }
#line 1023
  if ((unsigned long )s != (unsigned long )((void *)0)) {
    {
#line 1024
    perror((char const   *)(ifname));
#line 1025
    exit_code = 1;
    }
#line 1026
    return (1);
  }
  {
#line 1035
  tmp___1 = strlen((char const   *)(ifname));
#line 1035
  ilen = (int )tmp___1;
#line 1036
  tmp___2 = strcmp((char const   *)(z_suffix), ".gz");
  }
#line 1036
  if (tmp___2 == 0) {
#line 1036
    suf ++;
  }
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1040
    s = *suf;
#line 1051
    strcat((char */* __restrict  */)(ifname), (char const   */* __restrict  */)s);
#line 1052
    tmp___3 = do_stat(ifname, sbuf);
    }
#line 1052
    if (tmp___3 == 0) {
#line 1052
      return (0);
    }
#line 1053
    ifname[ilen] = (char )'\000';
#line 1039
    suf ++;
#line 1039
    if (! ((unsigned long )*suf != (unsigned long )((void *)0))) {
#line 1039
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1062
  strcat((char */* __restrict  */)(ifname), (char const   */* __restrict  */)(z_suffix));
#line 1063
  perror((char const   *)(ifname));
#line 1064
  exit_code = 1;
  }
#line 1065
  return (1);
}
}
#line 1072 "gzip.c"
static int make_ofname(void) 
{ 
  char *suff ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1076
  strcpy((char */* __restrict  */)(ofname), (char const   */* __restrict  */)(ifname));
#line 1078
  suff = get_suffix(ofname);
  }
#line 1080
  if (decompress) {
#line 1081
    if ((unsigned long )suff == (unsigned long )((void *)0)) {
#line 1085
      if (! recursive) {
#line 1085
        if (list) {
#line 1085
          return (0);
        } else
#line 1085
        if (test) {
#line 1085
          return (0);
        }
      }
#line 1088
      if (verbose) {
#line 1088
        goto _L;
      } else
#line 1088
      if (! recursive) {
#line 1088
        if (! quiet) {
          _L: /* CIL Label */ 
#line 1089
          if (! quiet) {
            {
#line 1089
            fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unknown suffix -- ignored\n",
                    progname, ifname);
            }
          }
#line 1089
          if (exit_code == 0) {
#line 1089
            exit_code = 2;
          }
        }
      }
#line 1092
      return (2);
    }
    {
#line 1095
    strlwr(suff);
#line 1096
    tmp = strcmp((char const   *)suff, ".tgz");
    }
#line 1096
    if (tmp == 0) {
      {
#line 1097
      strcpy((char */* __restrict  */)suff, (char const   */* __restrict  */)".tar");
      }
    } else {
      {
#line 1096
      tmp___0 = strcmp((char const   *)suff, ".taz");
      }
#line 1096
      if (tmp___0 == 0) {
        {
#line 1097
        strcpy((char */* __restrict  */)suff, (char const   */* __restrict  */)".tar");
        }
      } else {
#line 1099
        *suff = (char )'\000';
      }
    }
  } else
#line 1103
  if ((unsigned long )suff != (unsigned long )((void *)0)) {
#line 1105
    if (verbose) {
      {
#line 1106
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already has %s suffix -- unchanged\n",
              progname, ifname, suff);
      }
    } else
#line 1105
    if (! recursive) {
#line 1105
      if (! quiet) {
        {
#line 1106
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already has %s suffix -- unchanged\n",
                progname, ifname, suff);
        }
      }
    }
#line 1109
    if (exit_code == 0) {
#line 1109
      exit_code = 2;
    }
#line 1110
    return (2);
  } else {
    {
#line 1112
    save_orig_name = 0;
#line 1133
    strcat((char */* __restrict  */)(ofname), (char const   */* __restrict  */)(z_suffix));
    }
  }
#line 1136
  return (0);
}
}
#line 1151 "gzip.c"
static int get_method(int in ) 
{ 
  uch___1 flags ;
  char magic[2] ;
  ulg___1 stamp ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  unsigned int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  unsigned int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  unsigned int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;
  unsigned int part ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  unsigned int len ;
  unsigned int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  unsigned int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  unsigned int tmp___43 ;
  unsigned int tmp___44 ;
  char c ;
  unsigned int tmp___45 ;
  int tmp___46 ;
  char *p ;
  char *tmp___47 ;
  char *base ;
  unsigned int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  unsigned int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;

  {
#line 1161
  if (force) {
#line 1161
    if (to_stdout) {
#line 1162
      if (inptr < insize) {
#line 1162
        tmp = inptr;
#line 1162
        inptr ++;
#line 1162
        tmp___1 = (int )inbuf[tmp];
      } else {
        {
#line 1162
        tmp___0 = fill_inbuf(1);
#line 1162
        tmp___1 = tmp___0;
        }
      }
#line 1162
      magic[0] = (char )tmp___1;
#line 1163
      if (inptr < insize) {
#line 1163
        tmp___2 = inptr;
#line 1163
        inptr ++;
#line 1163
        tmp___4 = (int )inbuf[tmp___2];
      } else {
        {
#line 1163
        tmp___3 = fill_inbuf(1);
#line 1163
        tmp___4 = tmp___3;
        }
      }
#line 1163
      magic[1] = (char )tmp___4;
    } else {
#line 1161
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1166
    if (inptr < insize) {
#line 1166
      tmp___5 = inptr;
#line 1166
      inptr ++;
#line 1166
      tmp___7 = (int )inbuf[tmp___5];
    } else {
      {
#line 1166
      tmp___6 = fill_inbuf(0);
#line 1166
      tmp___7 = tmp___6;
      }
    }
#line 1166
    magic[0] = (char )tmp___7;
#line 1167
    if (inptr < insize) {
#line 1167
      tmp___8 = inptr;
#line 1167
      inptr ++;
#line 1167
      tmp___10 = (int )inbuf[tmp___8];
    } else {
      {
#line 1167
      tmp___9 = fill_inbuf(0);
#line 1167
      tmp___10 = tmp___9;
      }
    }
#line 1167
    magic[1] = (char )tmp___10;
  }
  {
#line 1169
  method = -1;
#line 1170
  part_nb ++;
#line 1171
  header_bytes = 0L;
#line 1172
  last_member = 0;
#line 1175
  tmp___61 = memcmp((void const   *)(magic), (void const   *)"\037\213", 2UL);
  }
#line 1175
  if (tmp___61 == 0) {
#line 1175
    goto _L___4;
  } else {
    {
#line 1175
    tmp___62 = memcmp((void const   *)(magic), (void const   *)"\037\236", 2UL);
    }
#line 1175
    if (tmp___62 == 0) {
      _L___4: /* CIL Label */ 
#line 1178
      if (inptr < insize) {
#line 1178
        tmp___11 = inptr;
#line 1178
        inptr ++;
#line 1178
        tmp___13 = (int )inbuf[tmp___11];
      } else {
        {
#line 1178
        tmp___12 = fill_inbuf(0);
#line 1178
        tmp___13 = tmp___12;
        }
      }
#line 1178
      method = tmp___13;
#line 1179
      if (method != 8) {
        {
#line 1180
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: unknown method %d -- get newer version of gzip\n",
                progname, ifname, method);
#line 1183
        exit_code = 1;
        }
#line 1184
        return (-1);
      }
#line 1186
      work = & unzip;
#line 1187
      if (inptr < insize) {
#line 1187
        tmp___14 = inptr;
#line 1187
        inptr ++;
#line 1187
        tmp___16 = (int )inbuf[tmp___14];
      } else {
        {
#line 1187
        tmp___15 = fill_inbuf(0);
#line 1187
        tmp___16 = tmp___15;
        }
      }
#line 1187
      flags = (uch___1 )tmp___16;
#line 1189
      if (((int )flags & 32) != 0) {
        {
#line 1190
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is encrypted -- get newer version of gzip\n",
                progname, ifname);
#line 1193
        exit_code = 1;
        }
#line 1194
        return (-1);
      }
#line 1196
      if (((int )flags & 2) != 0) {
        {
#line 1197
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s is a a multi-part gzip file -- get newer version of gzip\n",
                progname, ifname);
#line 1200
        exit_code = 1;
        }
#line 1201
        if (force <= 1) {
#line 1201
          return (-1);
        }
      }
#line 1203
      if (((int )flags & 192) != 0) {
        {
#line 1204
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has flags 0x%x -- get newer version of gzip\n",
                progname, ifname, (int )flags);
#line 1207
        exit_code = 1;
        }
#line 1208
        if (force <= 1) {
#line 1208
          return (-1);
        }
      }
#line 1210
      if (inptr < insize) {
#line 1210
        tmp___17 = inptr;
#line 1210
        inptr ++;
#line 1210
        tmp___19 = (int )inbuf[tmp___17];
      } else {
        {
#line 1210
        tmp___18 = fill_inbuf(0);
#line 1210
        tmp___19 = tmp___18;
        }
      }
#line 1210
      stamp = (ulg___1 )tmp___19;
#line 1211
      if (inptr < insize) {
#line 1211
        tmp___20 = inptr;
#line 1211
        inptr ++;
#line 1211
        tmp___22 = (int )inbuf[tmp___20];
      } else {
        {
#line 1211
        tmp___21 = fill_inbuf(0);
#line 1211
        tmp___22 = tmp___21;
        }
      }
#line 1211
      stamp |= (ulg___1 )tmp___22 << 8;
#line 1212
      if (inptr < insize) {
#line 1212
        tmp___23 = inptr;
#line 1212
        inptr ++;
#line 1212
        tmp___25 = (int )inbuf[tmp___23];
      } else {
        {
#line 1212
        tmp___24 = fill_inbuf(0);
#line 1212
        tmp___25 = tmp___24;
        }
      }
#line 1212
      stamp |= (ulg___1 )tmp___25 << 16;
#line 1213
      if (inptr < insize) {
#line 1213
        tmp___26 = inptr;
#line 1213
        inptr ++;
#line 1213
        tmp___28 = (int )inbuf[tmp___26];
      } else {
        {
#line 1213
        tmp___27 = fill_inbuf(0);
#line 1213
        tmp___28 = tmp___27;
        }
      }
#line 1213
      stamp |= (ulg___1 )tmp___28 << 24;
#line 1214
      if (stamp != 0UL) {
#line 1214
        if (! no_time) {
#line 1214
          time_stamp = (long )stamp;
        }
      }
#line 1216
      if (inptr < insize) {
#line 1216
        tmp___29 = inptr;
#line 1216
        inptr ++;
      } else {
        {
#line 1216
        fill_inbuf(0);
        }
      }
#line 1217
      if (inptr < insize) {
#line 1217
        tmp___30 = inptr;
#line 1217
        inptr ++;
      } else {
        {
#line 1217
        fill_inbuf(0);
        }
      }
#line 1219
      if (((int )flags & 2) != 0) {
#line 1220
        if (inptr < insize) {
#line 1220
          tmp___31 = inptr;
#line 1220
          inptr ++;
#line 1220
          tmp___33 = (int )inbuf[tmp___31];
        } else {
          {
#line 1220
          tmp___32 = fill_inbuf(0);
#line 1220
          tmp___33 = tmp___32;
          }
        }
#line 1220
        part = (unsigned int )tmp___33;
#line 1221
        if (inptr < insize) {
#line 1221
          tmp___34 = inptr;
#line 1221
          inptr ++;
#line 1221
          tmp___36 = (int )inbuf[tmp___34];
        } else {
          {
#line 1221
          tmp___35 = fill_inbuf(0);
#line 1221
          tmp___36 = tmp___35;
          }
        }
#line 1221
        part |= (unsigned int )tmp___36 << 8;
#line 1222
        if (verbose) {
          {
#line 1223
          fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: part number %u\n",
                  progname, ifname, part);
          }
        }
      }
#line 1227
      if (((int )flags & 4) != 0) {
#line 1228
        if (inptr < insize) {
#line 1228
          tmp___37 = inptr;
#line 1228
          inptr ++;
#line 1228
          tmp___39 = (int )inbuf[tmp___37];
        } else {
          {
#line 1228
          tmp___38 = fill_inbuf(0);
#line 1228
          tmp___39 = tmp___38;
          }
        }
#line 1228
        len = (unsigned int )tmp___39;
#line 1229
        if (inptr < insize) {
#line 1229
          tmp___40 = inptr;
#line 1229
          inptr ++;
#line 1229
          tmp___42 = (int )inbuf[tmp___40];
        } else {
          {
#line 1229
          tmp___41 = fill_inbuf(0);
#line 1229
          tmp___42 = tmp___41;
          }
        }
#line 1229
        len |= (unsigned int )tmp___42 << 8;
#line 1230
        if (verbose) {
          {
#line 1231
          fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: extra field of %u bytes ignored\n",
                  progname, ifname, len);
          }
        }
        {
#line 1234
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1234
          tmp___44 = len;
#line 1234
          len --;
#line 1234
          if (! tmp___44) {
#line 1234
            goto while_break;
          }
#line 1234
          if (inptr < insize) {
#line 1234
            tmp___43 = inptr;
#line 1234
            inptr ++;
          } else {
            {
#line 1234
            fill_inbuf(0);
            }
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 1238
      if (((int )flags & 8) != 0) {
#line 1239
        if (no_name) {
#line 1239
          goto _L___0;
        } else
#line 1239
        if (to_stdout) {
#line 1239
          if (! list) {
#line 1239
            goto _L___0;
          } else {
#line 1239
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1239
        if (part_nb > 1) {
          _L___0: /* CIL Label */ 
          {
#line 1242
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1242
            if (inptr < insize) {
#line 1242
              tmp___45 = inptr;
#line 1242
              inptr ++;
#line 1242
              c = (char )inbuf[tmp___45];
            } else {
              {
#line 1242
              tmp___46 = fill_inbuf(0);
#line 1242
              c = (char )tmp___46;
              }
            }
#line 1242
            if (! ((int )c != 0)) {
#line 1242
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
          {
#line 1245
          tmp___47 = basename(ofname);
#line 1245
          p = tmp___47;
#line 1246
          base = p;
          }
          {
#line 1247
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1248
            if (inptr < insize) {
#line 1248
              tmp___48 = inptr;
#line 1248
              inptr ++;
#line 1248
              tmp___50 = (int )inbuf[tmp___48];
            } else {
              {
#line 1248
              tmp___49 = fill_inbuf(0);
#line 1248
              tmp___50 = tmp___49;
              }
            }
#line 1248
            *p = (char )tmp___50;
#line 1249
            tmp___51 = p;
#line 1249
            p ++;
#line 1249
            if ((int )*tmp___51 == 0) {
#line 1249
              goto while_break___1;
            }
#line 1250
            if ((unsigned long )p >= (unsigned long )(ofname + sizeof(ofname))) {
              {
#line 1251
              error((char *)"corrupted input -- file name too large");
              }
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1255
          if (! list) {
#line 1257
            if (base) {
#line 1257
              list = 0;
            }
          }
        }
      }
#line 1263
      if (((int )flags & 16) != 0) {
        {
#line 1264
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1264
          if (inptr < insize) {
#line 1264
            tmp___52 = inptr;
#line 1264
            inptr ++;
#line 1264
            tmp___54 = (int )inbuf[tmp___52];
          } else {
            {
#line 1264
            tmp___53 = fill_inbuf(0);
#line 1264
            tmp___54 = tmp___53;
            }
          }
#line 1264
          if (! (tmp___54 != 0)) {
#line 1264
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1266
      if (part_nb == 1) {
#line 1267
        header_bytes = (long )((unsigned long )inptr + 2UL * sizeof(long ));
      }
    } else {
      {
#line 1270
      tmp___59 = memcmp((void const   *)(magic), (void const   *)"PK\003\004", 2UL);
      }
#line 1270
      if (tmp___59 == 0) {
#line 1270
        if (inptr == 2U) {
          {
#line 1270
          tmp___60 = memcmp((void const   *)((char *)(inbuf)), (void const   *)"PK\003\004",
                            4UL);
          }
#line 1270
          if (tmp___60 == 0) {
            {
#line 1275
            inptr = 0U;
#line 1276
            work = & unzip;
#line 1277
            tmp___55 = check_zipfile(in);
            }
#line 1277
            if (tmp___55 != 0) {
#line 1277
              return (-1);
            }
#line 1279
            last_member = 1;
          } else {
#line 1270
            goto _L___3;
          }
        } else {
#line 1270
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
        {
#line 1281
        tmp___58 = memcmp((void const   *)(magic), (void const   *)"\037\036", 2UL);
        }
#line 1281
        if (tmp___58 == 0) {
#line 1282
          work = & unpack;
#line 1283
          method = 2;
        } else {
          {
#line 1285
          tmp___57 = memcmp((void const   *)(magic), (void const   *)"\037\235", 2UL);
          }
#line 1285
          if (tmp___57 == 0) {
#line 1286
            work = & unlzw;
#line 1287
            method = 1;
#line 1288
            last_member = 1;
          } else {
            {
#line 1290
            tmp___56 = memcmp((void const   *)(magic), (void const   *)"\037\240",
                              2UL);
            }
#line 1290
            if (tmp___56 == 0) {
#line 1291
              work = & unlzh;
#line 1292
              method = 3;
#line 1293
              last_member = 1;
            } else
#line 1295
            if (force) {
#line 1295
              if (to_stdout) {
#line 1295
                if (! list) {
#line 1296
                  method = 0;
#line 1297
                  work = & copy;
#line 1298
                  inptr = 0U;
#line 1299
                  last_member = 1;
                }
              }
            }
          }
        }
      }
    }
  }
#line 1301
  if (method >= 0) {
#line 1301
    return (method);
  }
#line 1303
  if (part_nb == 1) {
    {
#line 1304
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not in gzip format\n",
            progname, ifname);
#line 1305
    exit_code = 1;
    }
#line 1306
    return (-1);
  } else {
#line 1308
    if (! quiet) {
      {
#line 1308
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: decompression OK, trailing garbage ignored\n",
              progname, ifname);
      }
    }
#line 1308
    if (exit_code == 0) {
#line 1308
      exit_code = 2;
    }
#line 1310
    return (-2);
  }
}
}
#line 1324
static void do_list(int ifd___0 , int method___0 ) ;
#line 1324 "gzip.c"
static int first_time  =    1;
#line 1325
static void do_list(int ifd___0 , int method___0 ) ;
#line 1325 "gzip.c"
static char *methods[9]  = 
#line 1325
  {      (char *)"store",      (char *)"compr",      (char *)"pack ",      (char *)"lzh  ", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"defla"};
#line 1369
extern int ( /* missing proto */  lseek)() ;
#line 1373
extern int ( /* missing proto */  read)() ;
#line 1319 "gzip.c"
static void do_list(int ifd___0 , int method___0 ) 
{ 
  ulg___1 crc ;
  char *date ;
  int tmp ;
  uch___1 buf[8] ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 1334
  if (first_time) {
#line 1334
    if (method___0 >= 0) {
#line 1335
      first_time = 0;
#line 1336
      if (verbose) {
        {
#line 1337
        printf((char const   */* __restrict  */)"method  crc     date  time  ");
        }
      }
#line 1339
      if (! quiet) {
        {
#line 1340
        printf((char const   */* __restrict  */)"compressed  uncompr. ratio uncompressed_name\n");
        }
      }
    } else {
#line 1334
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1342
  if (method___0 < 0) {
#line 1343
    if (total_in <= 0L) {
#line 1343
      return;
    } else
#line 1343
    if (total_out <= 0L) {
#line 1343
      return;
    }
#line 1344
    if (verbose) {
      {
#line 1345
      printf((char const   */* __restrict  */)"                            %9lu %9lu ",
             total_in, total_out);
      }
    } else
#line 1347
    if (! quiet) {
      {
#line 1348
      printf((char const   */* __restrict  */)"%9ld %9ld ", total_in, total_out);
      }
    }
    {
#line 1350
    display_ratio(total_out - (total_in - header_bytes), total_out, stdout);
#line 1354
    printf((char const   */* __restrict  */)" (totals)\n");
    }
#line 1355
    return;
  }
#line 1357
  crc = (ulg___1 )(~ 0);
#line 1358
  bytes_out = -1L;
#line 1359
  bytes_in = ifile_size;
#line 1362
  if (method___0 == 8) {
#line 1362
    if (! last_member) {
      {
#line 1369
      tmp = lseek(ifd___0, (off_t___2 )-8, 2);
#line 1369
      bytes_in = (long )tmp;
      }
#line 1370
      if (bytes_in != -1L) {
        {
#line 1372
        bytes_in += 8L;
#line 1373
        tmp___0 = read(ifd___0, (char *)(buf), sizeof(buf));
        }
#line 1373
        if ((unsigned long )tmp___0 != sizeof(buf)) {
          {
#line 1374
          read_error();
          }
        }
#line 1376
        crc = (ulg___1 )((int )((ush___1 )buf[0]) | ((int )((ush___1 )buf[1]) << 8)) | ((ulg___1 )((int )((ush___1 )*((buf + 2) + 0)) | ((int )((ush___1 )*((buf + 2) + 1)) << 8)) << 16);
#line 1377
        bytes_out = (long )((ulg___1 )((int )((ush___1 )*((buf + 4) + 0)) | ((int )((ush___1 )*((buf + 4) + 1)) << 8)) | ((ulg___1 )((int )((ush___1 )*(((buf + 4) + 2) + 0)) | ((int )((ush___1 )*(((buf + 4) + 2) + 1)) << 8)) << 16));
      }
    }
  }
  {
#line 1381
  tmp___1 = ctime((time_t const   *)(& time_stamp));
#line 1381
  date = tmp___1 + 4;
#line 1382
  *(date + 12) = (char )'\000';
  }
#line 1383
  if (verbose) {
    {
#line 1384
    printf((char const   */* __restrict  */)"%5s %08lx %11s ", methods[method___0],
           crc, date);
    }
  }
  {
#line 1386
  printf((char const   */* __restrict  */)"%9ld %9ld ", bytes_in, bytes_out);
  }
#line 1387
  if (bytes_in == -1L) {
#line 1388
    total_in = -1L;
#line 1389
    header_bytes = 0L;
#line 1389
    bytes_out = header_bytes;
#line 1389
    bytes_in = bytes_out;
  } else
#line 1390
  if (total_in >= 0L) {
#line 1391
    total_in += bytes_in;
  }
#line 1393
  if (bytes_out == -1L) {
#line 1394
    total_out = -1L;
#line 1395
    header_bytes = 0L;
#line 1395
    bytes_out = header_bytes;
#line 1395
    bytes_in = bytes_out;
  } else
#line 1396
  if (total_out >= 0L) {
#line 1397
    total_out += bytes_out;
  }
  {
#line 1399
  display_ratio(bytes_out - (bytes_in - header_bytes), bytes_out, stdout);
#line 1400
  printf((char const   */* __restrict  */)" %s\n", ofname);
  }
#line 1401
  return;
}
}
#line 1406 "gzip.c"
static int same_file(struct stat *stat1 , struct stat *stat2 ) 
{ 
  int tmp ;

  {
#line 1410
  if (stat1->st_ino == stat2->st_ino) {
#line 1410
    if (stat1->st_dev == stat2->st_dev) {
#line 1410
      tmp = 1;
    } else {
#line 1410
      tmp = 0;
    }
  } else {
#line 1410
    tmp = 0;
  }
#line 1410
  return (tmp);
}
}
#line 1429 "gzip.c"
static int name_too_long(char *name , struct stat *statb ) 
{ 
  int s ;
  unsigned long tmp ;
  char c ;
  struct stat tstat ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1433
  tmp = strlen((char const   *)name);
#line 1433
  s = (int )tmp;
#line 1434
  c = *(name + (s - 1));
#line 1438
  tstat = *statb;
#line 1439
  *(name + (s - 1)) = (char )'\000';
#line 1440
  tmp___0 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& tstat));
  }
#line 1440
  if (tmp___0 == 0) {
    {
#line 1440
    tmp___1 = same_file(statb, & tstat);
    }
#line 1440
    if (tmp___1) {
#line 1440
      tmp___2 = 1;
    } else {
#line 1440
      tmp___2 = 0;
    }
  } else {
#line 1440
    tmp___2 = 0;
  }
#line 1440
  res = tmp___2;
#line 1441
  *(name + (s - 1)) = c;
#line 1443
  return (res);
}
}
#line 1455 "gzip.c"
static void shorten_name(char *name ) 
{ 
  int len ;
  char *trunc ;
  int plen ;
  int min_part ;
  char *p ;
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1459
  trunc = (char *)((void *)0);
#line 1461
  min_part = 3;
#line 1464
  tmp = strlen((char const   *)name);
#line 1464
  len = (int )tmp;
  }
#line 1465
  if (decompress) {
#line 1466
    if (len <= 1) {
      {
#line 1466
      error((char *)"name too short");
      }
    }
#line 1467
    *(name + (len - 1)) = (char )'\000';
#line 1468
    return;
  }
  {
#line 1470
  p = get_suffix(name);
  }
#line 1471
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 1471
    error((char *)"can\'t recover suffix\n");
    }
  }
#line 1472
  *p = (char )'\000';
#line 1473
  save_orig_name = 1;
#line 1476
  if (len > 4) {
    {
#line 1476
    tmp___0 = strcmp((char const   *)(p - 4), ".tar");
    }
#line 1476
    if (tmp___0 == 0) {
      {
#line 1477
      strcpy((char */* __restrict  */)(p - 4), (char const   */* __restrict  */)".tgz");
      }
#line 1478
      return;
    }
  }
  {
#line 1483
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1484
    p = strrchr((char const   *)name, '/');
    }
#line 1485
    if (p) {
#line 1485
      p ++;
    } else {
#line 1485
      p = name;
    }
    {
#line 1486
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1486
      if (! *p) {
#line 1486
        goto while_break___0;
      }
      {
#line 1487
      tmp___1 = strcspn((char const   *)p, ".");
#line 1487
      plen = (int )tmp___1;
#line 1488
      p += plen;
      }
#line 1489
      if (plen > min_part) {
#line 1489
        trunc = p - 1;
      }
#line 1490
      if (*p) {
#line 1490
        p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1483
    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
#line 1483
      min_part --;
#line 1483
      if (! (min_part != 0)) {
#line 1483
        goto while_break;
      }
    } else {
#line 1483
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1494
  if ((unsigned long )trunc != (unsigned long )((void *)0)) {
    {
#line 1495
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1496
      *(trunc + 0) = *(trunc + 1);
#line 1495
      tmp___2 = trunc;
#line 1495
      trunc ++;
#line 1495
      if (! *tmp___2) {
#line 1495
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1498
    trunc --;
  } else {
    {
#line 1500
    trunc = strrchr((char const   *)name, (int )*("." + 0));
    }
#line 1501
    if ((unsigned long )trunc == (unsigned long )((void *)0)) {
      {
#line 1501
      error((char *)"internal error in shorten_name");
      }
    }
#line 1502
    if ((int )*(trunc + 1) == 0) {
#line 1502
      trunc --;
    }
  }
  {
#line 1504
  strcpy((char */* __restrict  */)trunc, (char const   */* __restrict  */)(z_suffix));
  }
#line 1505
  return;
}
}
#line 1521 "gzip.c"
static int check_ofname(void) 
{ 
  struct stat ostat ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char response[80] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  unsigned short const   **tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1529
  tmp = __errno_location();
#line 1529
  *tmp = 0;
  }
  {
#line 1530
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1530
    tmp___1 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& ostat));
    }
#line 1530
    if (! (tmp___1 != 0)) {
#line 1530
      goto while_break;
    }
    {
#line 1531
    tmp___0 = __errno_location();
    }
#line 1531
    if (*tmp___0 != 36) {
#line 1531
      return (0);
    }
    {
#line 1532
    shorten_name(ofname);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1541
  if (! decompress) {
    {
#line 1541
    tmp___3 = name_too_long(ofname, & ostat);
    }
#line 1541
    if (tmp___3) {
      {
#line 1542
      shorten_name(ofname);
#line 1543
      tmp___2 = stat((char const   */* __restrict  */)(ofname), (struct stat */* __restrict  */)(& ostat));
      }
#line 1543
      if (tmp___2 != 0) {
#line 1543
        return (0);
      }
    }
  }
  {
#line 1549
  tmp___6 = same_file(& istat, & ostat);
  }
#line 1549
  if (tmp___6) {
    {
#line 1550
    tmp___5 = strcmp((char const   *)(ifname), (char const   *)(ofname));
    }
#line 1550
    if (tmp___5 == 0) {
#line 1551
      if (decompress) {
#line 1551
        tmp___4 = "de";
      } else {
#line 1551
        tmp___4 = "";
      }
      {
#line 1551
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: cannot %scompress onto itself\n",
              progname, ifname, tmp___4);
      }
    } else {
      {
#line 1554
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s and %s are the same file\n",
              progname, ifname, ofname);
      }
    }
#line 1557
    exit_code = 1;
#line 1558
    return (1);
  }
#line 1561
  if (! force) {
    {
#line 1563
    strcpy((char */* __restrict  */)(response), (char const   */* __restrict  */)"n");
#line 1564
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s already exists;",
            progname, ofname);
    }
#line 1565
    if (foreground) {
      {
#line 1565
      tmp___7 = fileno(stdin);
#line 1565
      tmp___8 = isatty(tmp___7);
      }
#line 1565
      if (tmp___8) {
        {
#line 1566
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" do you wish to overwrite (y or n)? ");
#line 1567
        fflush(stderr);
#line 1568
        fgets((char */* __restrict  */)(response), (int )(sizeof(response) - 1UL),
              (struct _IO_FILE */* __restrict  */)stdin);
        }
      }
    }
    {
#line 1570
    tmp___11 = __ctype_b_loc();
    }
#line 1570
    if ((int const   )*(*tmp___11 + (int )response[0]) & 256) {
#line 1570
      tmp___10 = ((int )response[0] - 65) + 97;
    } else {
#line 1570
      tmp___10 = (int )response[0];
    }
#line 1570
    if (tmp___10 != 121) {
      {
#line 1571
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tnot overwritten\n");
      }
#line 1572
      if (exit_code == 0) {
#line 1572
        exit_code = 2;
      }
#line 1573
      return (1);
    }
  }
  {
#line 1576
  chmod((char const   *)(ofname), (__mode_t___2 )511);
#line 1577
  tmp___12 = unlink(ofname);
  }
#line 1577
  if (tmp___12) {
    {
#line 1578
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
#line 1579
    perror((char const   *)(ofname));
#line 1580
    exit_code = 1;
    }
#line 1581
    return (1);
  }
#line 1583
  return (0);
}
}
#line 1591 "gzip.c"
static void reset_times(char *name , struct stat *statb ) 
{ 
  struct utimbuf timep ;
  int tmp ;

  {
  {
#line 1598
  timep.actime = statb->st_atim.tv_sec;
#line 1599
  timep.modtime = statb->st_mtim.tv_sec;
#line 1602
  tmp = utime((char const   *)name, (struct utimbuf  const  *)(& timep));
  }
#line 1602
  if (tmp) {
#line 1602
    if (! ((statb->st_mode & 61440U) == 16384U)) {
#line 1603
      if (! quiet) {
        {
#line 1603
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                progname);
        }
      }
#line 1603
      if (exit_code == 0) {
#line 1603
        exit_code = 2;
      }
#line 1604
      if (! quiet) {
        {
#line 1604
        perror((char const   *)(ofname));
        }
      }
    }
  }
#line 1606
  return;
}
}
#line 1632
extern int ( /* missing proto */  chown)() ;
#line 1614 "gzip.c"
static void copy_stat(struct stat *ifstat ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1618
  if (decompress) {
#line 1618
    if (time_stamp != 0L) {
#line 1618
      if (ifstat->st_mtim.tv_sec != time_stamp) {
#line 1619
        ifstat->st_mtim.tv_sec = time_stamp;
#line 1620
        if (verbose > 1) {
          {
#line 1621
          fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: time stamp restored\n",
                  ofname);
          }
        }
      }
    }
  }
  {
#line 1624
  reset_times(ofname, ifstat);
#line 1627
  tmp = chmod((char const   *)(ofname), ifstat->st_mode & 4095U);
  }
#line 1627
  if (tmp) {
#line 1628
    if (! quiet) {
      {
#line 1628
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
    }
#line 1628
    if (exit_code == 0) {
#line 1628
      exit_code = 2;
    }
#line 1629
    if (! quiet) {
      {
#line 1629
      perror((char const   *)(ofname));
      }
    }
  }
  {
#line 1632
  chown(ofname, ifstat->st_uid, ifstat->st_gid);
#line 1634
  remove_ofname = 0;
#line 1636
  chmod((char const   *)(ifname), (__mode_t___2 )511);
#line 1637
  tmp___0 = unlink(ifname);
  }
#line 1637
  if (tmp___0) {
#line 1638
    if (! quiet) {
      {
#line 1638
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
              progname);
      }
    }
#line 1638
    if (exit_code == 0) {
#line 1638
      exit_code = 2;
    }
#line 1639
    if (! quiet) {
      {
#line 1639
      perror((char const   *)(ifname));
      }
    }
  }
#line 1641
  return;
}
}
#line 1715
static void do_exit(int exitcode ) ;
#line 1715 "gzip.c"
static int in_exit  =    0;
#line 1712 "gzip.c"
static void do_exit(int exitcode ) 
{ 


  {
#line 1717
  if (in_exit) {
    {
#line 1717
    exit(exitcode);
    }
  }
#line 1718
  in_exit = 1;
#line 1719
  if ((unsigned long )env != (unsigned long )((void *)0)) {
    {
#line 1719
    free((void *)env);
#line 1719
    env = (char *)((void *)0);
    }
  }
#line 1720
  if ((unsigned long )args != (unsigned long )((void *)0)) {
    {
#line 1720
    free((void *)((char *)args));
#line 1720
    args = (char **)((void *)0);
    }
  }
  {
#line 1731
  exit(exitcode);
  }
}
}
#line 1737 "gzip.c"
void abort_gzip(void) 
{ 


  {
#line 1739
  if (remove_ofname) {
    {
#line 1740
    close(ofd);
#line 1741
    unlink(ofname);
    }
  }
  {
#line 1743
  do_exit(1);
  }
#line 1744
  return;
}
}
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__asm__("error in function __bswap_32");
#line 108
__asm__("error in function __bswap_64");
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__asm__("error in function __uint16_identity");
#line 38
__asm__("error in function __uint32_identity");
#line 44
__asm__("error in function __uint64_identity");
#line 132 "inflate.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush___2 *d , ush___2 *e ,
               struct huft **t , int *m ) ;
#line 134
int huft_free(struct huft *t___0 ) ;
#line 135
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) ;
#line 136
int inflate_stored(void) ;
#line 137
int inflate_fixed(void) ;
#line 138
int inflate_dynamic(void) ;
#line 139
int inflate_block(int *e___1 ) ;
#line 156 "inflate.c"
static unsigned int border[19]  = 
#line 156
  {      16U,      17U,      18U,      0U, 
        8U,      7U,      9U,      6U, 
        10U,      5U,      11U,      4U, 
        12U,      3U,      13U,      2U, 
        14U,      1U,      15U};
#line 158 "inflate.c"
static ush___2 cplens[31]  = 
#line 158
  {      (ush___2 )3,      (ush___2 )4,      (ush___2 )5,      (ush___2 )6, 
        (ush___2 )7,      (ush___2 )8,      (ush___2 )9,      (ush___2 )10, 
        (ush___2 )11,      (ush___2 )13,      (ush___2 )15,      (ush___2 )17, 
        (ush___2 )19,      (ush___2 )23,      (ush___2 )27,      (ush___2 )31, 
        (ush___2 )35,      (ush___2 )43,      (ush___2 )51,      (ush___2 )59, 
        (ush___2 )67,      (ush___2 )83,      (ush___2 )99,      (ush___2 )115, 
        (ush___2 )131,      (ush___2 )163,      (ush___2 )195,      (ush___2 )227, 
        (ush___2 )258,      (ush___2 )0,      (ush___2 )0};
#line 162 "inflate.c"
static ush___2 cplext[31]  = 
#line 162
  {      (ush___2 )0,      (ush___2 )0,      (ush___2 )0,      (ush___2 )0, 
        (ush___2 )0,      (ush___2 )0,      (ush___2 )0,      (ush___2 )0, 
        (ush___2 )1,      (ush___2 )1,      (ush___2 )1,      (ush___2 )1, 
        (ush___2 )2,      (ush___2 )2,      (ush___2 )2,      (ush___2 )2, 
        (ush___2 )3,      (ush___2 )3,      (ush___2 )3,      (ush___2 )3, 
        (ush___2 )4,      (ush___2 )4,      (ush___2 )4,      (ush___2 )4, 
        (ush___2 )5,      (ush___2 )5,      (ush___2 )5,      (ush___2 )5, 
        (ush___2 )0,      (ush___2 )99,      (ush___2 )99};
#line 165 "inflate.c"
static ush___2 cpdist[30]  = 
#line 165
  {      (ush___2 )1,      (ush___2 )2,      (ush___2 )3,      (ush___2 )4, 
        (ush___2 )5,      (ush___2 )7,      (ush___2 )9,      (ush___2 )13, 
        (ush___2 )17,      (ush___2 )25,      (ush___2 )33,      (ush___2 )49, 
        (ush___2 )65,      (ush___2 )97,      (ush___2 )129,      (ush___2 )193, 
        (ush___2 )257,      (ush___2 )385,      (ush___2 )513,      (ush___2 )769, 
        (ush___2 )1025,      (ush___2 )1537,      (ush___2 )2049,      (ush___2 )3073, 
        (ush___2 )4097,      (ush___2 )6145,      (ush___2 )8193,      (ush___2 )12289, 
        (ush___2 )16385,      (ush___2 )24577};
#line 169 "inflate.c"
static ush___2 cpdext[30]  = 
#line 169
  {      (ush___2 )0,      (ush___2 )0,      (ush___2 )0,      (ush___2 )0, 
        (ush___2 )1,      (ush___2 )1,      (ush___2 )2,      (ush___2 )2, 
        (ush___2 )3,      (ush___2 )3,      (ush___2 )4,      (ush___2 )4, 
        (ush___2 )5,      (ush___2 )5,      (ush___2 )6,      (ush___2 )6, 
        (ush___2 )7,      (ush___2 )7,      (ush___2 )8,      (ush___2 )8, 
        (ush___2 )9,      (ush___2 )9,      (ush___2 )10,      (ush___2 )10, 
        (ush___2 )11,      (ush___2 )11,      (ush___2 )12,      (ush___2 )12, 
        (ush___2 )13,      (ush___2 )13};
#line 206 "inflate.c"
ulg___2 bb  ;
#line 207 "inflate.c"
unsigned int bk  ;
#line 209 "inflate.c"
ush___2 mask_bits[17]  = 
#line 209
  {      (ush___2 )0,      (ush___2 )1,      (ush___2 )3,      (ush___2 )7, 
        (ush___2 )15,      (ush___2 )31,      (ush___2 )63,      (ush___2 )127, 
        (ush___2 )255,      (ush___2 )511,      (ush___2 )1023,      (ush___2 )2047, 
        (ush___2 )4095,      (ush___2 )8191,      (ush___2 )16383,      (ush___2 )32767, 
        (ush___2 )65535};
#line 259 "inflate.c"
int lbits  =    9;
#line 260 "inflate.c"
int dbits  =    6;
#line 268 "inflate.c"
unsigned int hufts  ;
#line 271 "inflate.c"
int huft_build(unsigned int *b , unsigned int n , unsigned int s , ush___2 *d , ush___2 *e ,
               struct huft **t , int *m ) 
{ 
  unsigned int a ;
  unsigned int c[17] ;
  unsigned int f ;
  int g ;
  int h ;
  register unsigned int i ;
  register unsigned int j ;
  register int k ;
  int l ;
  register unsigned int *p ;
  register struct huft *q ;
  struct huft r ;
  struct huft *u[16] ;
  unsigned int v[288] ;
  register int w ;
  unsigned int x[17] ;
  unsigned int *xp ;
  int y ;
  unsigned int z ;
  unsigned int *tmp ;
  unsigned int *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned int *tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 307
  memset((voidp___2 )(c), 0, sizeof(c));
#line 308
  p = b;
#line 308
  i = n;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    (c[*p]) ++;
#line 313
    p ++;
#line 309
    i --;
#line 309
    if (! i) {
#line 309
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (c[0] == n) {
#line 317
    *t = (struct huft *)((void *)0);
#line 318
    *m = 0;
#line 319
    return (0);
  }
#line 324
  l = *m;
#line 325
  j = 1U;
  {
#line 325
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 325
    if (! (j <= 16U)) {
#line 325
      goto while_break___0;
    }
#line 326
    if (c[j]) {
#line 327
      goto while_break___0;
    }
#line 325
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  k = (int )j;
#line 329
  if ((unsigned int )l < j) {
#line 330
    l = (int )j;
  }
#line 331
  i = 16U;
  {
#line 331
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 331
    if (! i) {
#line 331
      goto while_break___1;
    }
#line 332
    if (c[i]) {
#line 333
      goto while_break___1;
    }
#line 331
    i --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 334
  g = (int )i;
#line 335
  if ((unsigned int )l > i) {
#line 336
    l = (int )i;
  }
#line 337
  *m = l;
#line 341
  y = 1 << j;
  {
#line 341
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 341
    if (! (j < i)) {
#line 341
      goto while_break___2;
    }
#line 342
    y = (int )((unsigned int )y - c[j]);
#line 342
    if (y < 0) {
#line 343
      return (2);
    }
#line 341
    j ++;
#line 341
    y <<= 1;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 344
  y = (int )((unsigned int )y - c[i]);
#line 344
  if (y < 0) {
#line 345
    return (2);
  }
#line 346
  c[i] += (unsigned int )y;
#line 350
  j = 0U;
#line 350
  x[1] = j;
#line 351
  p = c + 1;
#line 351
  xp = x + 2;
  {
#line 352
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 352
    i --;
#line 352
    if (! i) {
#line 352
      goto while_break___3;
    }
#line 353
    tmp = xp;
#line 353
    xp ++;
#line 353
    tmp___0 = p;
#line 353
    p ++;
#line 353
    j += *tmp___0;
#line 353
    *tmp = j;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 358
  p = b;
#line 358
  i = 0U;
  {
#line 359
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 360
    tmp___2 = p;
#line 360
    p ++;
#line 360
    j = *tmp___2;
#line 360
    if (j != 0U) {
#line 361
      tmp___1 = x[j];
#line 361
      (x[j]) ++;
#line 361
      v[tmp___1] = i;
    }
#line 359
    i ++;
#line 359
    if (! (i < n)) {
#line 359
      goto while_break___4;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 366
  i = 0U;
#line 366
  x[0] = i;
#line 367
  p = v;
#line 368
  h = -1;
#line 369
  w = - l;
#line 370
  u[0] = (struct huft *)((void *)0);
#line 371
  q = (struct huft *)((void *)0);
#line 372
  z = 0U;
  {
#line 375
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 375
    if (! (k <= g)) {
#line 375
      goto while_break___5;
    }
#line 377
    a = c[k];
    {
#line 378
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 378
      tmp___6 = a;
#line 378
      a --;
#line 378
      if (! tmp___6) {
#line 378
        goto while_break___6;
      }
      {
#line 382
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 382
        if (! (k > w + l)) {
#line 382
          goto while_break___7;
        }
#line 384
        h ++;
#line 385
        w += l;
#line 388
        z = (unsigned int )(g - w);
#line 388
        if (z > (unsigned int )l) {
#line 388
          z = (unsigned int )l;
        } else {
#line 388
          z = z;
        }
#line 389
        j = (unsigned int )(k - w);
#line 389
        f = (unsigned int )(1 << j);
#line 389
        if (f > a + 1U) {
#line 391
          f -= a + 1U;
#line 392
          xp = c + k;
          {
#line 393
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 393
            j ++;
#line 393
            if (! (j < z)) {
#line 393
              goto while_break___8;
            }
#line 395
            f <<= 1;
#line 395
            xp ++;
#line 395
            if (f <= *xp) {
#line 396
              goto while_break___8;
            }
#line 397
            f -= *xp;
          }
          while_break___8: /* CIL Label */ ;
          }
        }
        {
#line 400
        z = (unsigned int )(1 << j);
#line 403
        tmp___3 = malloc((unsigned long )(z + 1U) * sizeof(struct huft ));
#line 403
        q = (struct huft *)tmp___3;
        }
#line 403
        if ((unsigned long )q == (unsigned long )((struct huft *)((void *)0))) {
#line 406
          if (h) {
            {
#line 407
            huft_free(u[0]);
            }
          }
#line 408
          return (3);
        }
#line 410
        hufts += z + 1U;
#line 411
        *t = q + 1;
#line 412
        t = & q->v.t;
#line 412
        *t = (struct huft *)((void *)0);
#line 413
        q ++;
#line 413
        u[h] = q;
#line 416
        if (h) {
#line 418
          x[h] = i;
#line 419
          r.b = (uch___2 )l;
#line 420
          r.e = (uch___2 )(16U + j);
#line 421
          r.v.t = q;
#line 422
          j = i >> (w - l);
#line 423
          *(u[h - 1] + j) = r;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 428
      r.b = (uch___2 )(k - w);
#line 429
      if ((unsigned long )p >= (unsigned long )(v + n)) {
#line 430
        r.e = (uch___2 )99;
      } else
#line 431
      if (*p < s) {
#line 433
        if (*p < 256U) {
#line 433
          tmp___4 = 16;
        } else {
#line 433
          tmp___4 = 15;
        }
#line 433
        r.e = (uch___2 )tmp___4;
#line 434
        r.v.n = (ush___2 )*p;
#line 435
        p ++;
      } else {
#line 439
        r.e = (uch___2 )*(e + (*p - s));
#line 440
        tmp___5 = p;
#line 440
        p ++;
#line 440
        r.v.n = *(d + (*tmp___5 - s));
      }
#line 444
      f = (unsigned int )(1 << (k - w));
#line 445
      j = i >> w;
      {
#line 445
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 445
        if (! (j < z)) {
#line 445
          goto while_break___9;
        }
#line 446
        *(q + j) = r;
#line 445
        j += f;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 449
      j = (unsigned int )(1 << (k - 1));
      {
#line 449
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 449
        if (! (i & j)) {
#line 449
          goto while_break___10;
        }
#line 450
        i ^= j;
#line 449
        j >>= 1;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 451
      i ^= j;
      {
#line 454
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 454
        if (! ((i & (unsigned int )((1 << w) - 1)) != x[h])) {
#line 454
          goto while_break___11;
        }
#line 456
        h --;
#line 457
        w -= l;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 375
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 464
  if (y != 0) {
#line 464
    if (g != 1) {
#line 464
      tmp___7 = 1;
    } else {
#line 464
      tmp___7 = 0;
    }
  } else {
#line 464
    tmp___7 = 0;
  }
#line 464
  return (tmp___7);
}
}
#line 469 "inflate.c"
int huft_free(struct huft *t___0 ) 
{ 
  register struct huft *p___0 ;
  register struct huft *q___0 ;

  {
#line 479
  p___0 = t___0;
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! ((unsigned long )p___0 != (unsigned long )((struct huft *)((void *)0)))) {
#line 480
      goto while_break;
    }
    {
#line 482
    p___0 --;
#line 482
    q___0 = p___0->v.t;
#line 483
    free((void *)((char *)p___0));
#line 484
    p___0 = q___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return (0);
}
}
#line 490 "inflate.c"
int inflate_codes(struct huft *tl , struct huft *td , int bl , int bd ) 
{ 
  register unsigned int e___0 ;
  unsigned int n___0 ;
  unsigned int d___0 ;
  unsigned int w___0 ;
  struct huft *t___1 ;
  unsigned int ml ;
  unsigned int md ;
  register ulg___2 b___0 ;
  register unsigned int k___0 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  unsigned int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  unsigned int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  unsigned int tmp___28 ;
  unsigned int tmp___29 ;
  unsigned int tmp___30 ;

  {
#line 506
  b___0 = bb;
#line 507
  k___0 = bk;
#line 508
  w___0 = outcnt;
#line 511
  ml = (unsigned int )mask_bits[bl];
#line 512
  md = (unsigned int )mask_bits[bd];
  {
#line 513
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 515
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 515
      if (! (k___0 < (unsigned int )bl)) {
#line 515
        goto while_break___0;
      }
#line 515
      if (inptr < insize) {
#line 515
        tmp___8 = inptr;
#line 515
        inptr ++;
#line 515
        tmp___10 = (int )inbuf[tmp___8];
      } else {
        {
#line 515
        tmp___9 = fill_inbuf(0);
#line 515
        tmp___10 = tmp___9;
        }
      }
#line 515
      b___0 |= (ulg___2 )((uch___2 )tmp___10) << k___0;
#line 515
      k___0 += 8U;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 516
    t___1 = tl + ((unsigned int )b___0 & ml);
#line 516
    e___0 = (unsigned int )t___1->e;
#line 516
    if (e___0 > 16U) {
      {
#line 517
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 518
        if (e___0 == 99U) {
#line 519
          return (1);
        }
#line 520
        b___0 >>= (int )t___1->b;
#line 520
        k___0 -= (unsigned int )t___1->b;
#line 521
        e___0 -= 16U;
        {
#line 522
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 522
          if (! (k___0 < e___0)) {
#line 522
            goto while_break___2;
          }
#line 522
          if (inptr < insize) {
#line 522
            tmp___11 = inptr;
#line 522
            inptr ++;
#line 522
            tmp___13 = (int )inbuf[tmp___11];
          } else {
            {
#line 522
            tmp___12 = fill_inbuf(0);
#line 522
            tmp___13 = tmp___12;
            }
          }
#line 522
          b___0 |= (ulg___2 )((uch___2 )tmp___13) << k___0;
#line 522
          k___0 += 8U;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 517
        t___1 = t___1->v.t + ((unsigned int )b___0 & (unsigned int )mask_bits[e___0]);
#line 517
        e___0 = (unsigned int )t___1->e;
#line 517
        if (! (e___0 > 16U)) {
#line 517
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 524
    b___0 >>= (int )t___1->b;
#line 524
    k___0 -= (unsigned int )t___1->b;
#line 525
    if (e___0 == 16U) {
#line 527
      tmp___14 = w___0;
#line 527
      w___0 ++;
#line 527
      window[tmp___14] = (uch___2 )t___1->v.n;
#line 529
      if (w___0 == 32768U) {
        {
#line 531
        outcnt = w___0;
#line 531
        flush_window();
#line 532
        w___0 = 0U;
        }
      }
    } else {
#line 538
      if (e___0 == 15U) {
#line 539
        goto while_break;
      }
      {
#line 542
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 542
        if (! (k___0 < e___0)) {
#line 542
          goto while_break___3;
        }
#line 542
        if (inptr < insize) {
#line 542
          tmp___15 = inptr;
#line 542
          inptr ++;
#line 542
          tmp___17 = (int )inbuf[tmp___15];
        } else {
          {
#line 542
          tmp___16 = fill_inbuf(0);
#line 542
          tmp___17 = tmp___16;
          }
        }
#line 542
        b___0 |= (ulg___2 )((uch___2 )tmp___17) << k___0;
#line 542
        k___0 += 8U;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 543
      n___0 = (unsigned int )t___1->v.n + ((unsigned int )b___0 & (unsigned int )mask_bits[e___0]);
#line 544
      b___0 >>= e___0;
#line 544
      k___0 -= e___0;
      {
#line 547
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 547
        if (! (k___0 < (unsigned int )bd)) {
#line 547
          goto while_break___4;
        }
#line 547
        if (inptr < insize) {
#line 547
          tmp___18 = inptr;
#line 547
          inptr ++;
#line 547
          tmp___20 = (int )inbuf[tmp___18];
        } else {
          {
#line 547
          tmp___19 = fill_inbuf(0);
#line 547
          tmp___20 = tmp___19;
          }
        }
#line 547
        b___0 |= (ulg___2 )((uch___2 )tmp___20) << k___0;
#line 547
        k___0 += 8U;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 548
      t___1 = td + ((unsigned int )b___0 & md);
#line 548
      e___0 = (unsigned int )t___1->e;
#line 548
      if (e___0 > 16U) {
        {
#line 549
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 550
          if (e___0 == 99U) {
#line 551
            return (1);
          }
#line 552
          b___0 >>= (int )t___1->b;
#line 552
          k___0 -= (unsigned int )t___1->b;
#line 553
          e___0 -= 16U;
          {
#line 554
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 554
            if (! (k___0 < e___0)) {
#line 554
              goto while_break___6;
            }
#line 554
            if (inptr < insize) {
#line 554
              tmp___21 = inptr;
#line 554
              inptr ++;
#line 554
              tmp___23 = (int )inbuf[tmp___21];
            } else {
              {
#line 554
              tmp___22 = fill_inbuf(0);
#line 554
              tmp___23 = tmp___22;
              }
            }
#line 554
            b___0 |= (ulg___2 )((uch___2 )tmp___23) << k___0;
#line 554
            k___0 += 8U;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 549
          t___1 = t___1->v.t + ((unsigned int )b___0 & (unsigned int )mask_bits[e___0]);
#line 549
          e___0 = (unsigned int )t___1->e;
#line 549
          if (! (e___0 > 16U)) {
#line 549
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 556
      b___0 >>= (int )t___1->b;
#line 556
      k___0 -= (unsigned int )t___1->b;
      {
#line 557
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 557
        if (! (k___0 < e___0)) {
#line 557
          goto while_break___7;
        }
#line 557
        if (inptr < insize) {
#line 557
          tmp___24 = inptr;
#line 557
          inptr ++;
#line 557
          tmp___26 = (int )inbuf[tmp___24];
        } else {
          {
#line 557
          tmp___25 = fill_inbuf(0);
#line 557
          tmp___26 = tmp___25;
          }
        }
#line 557
        b___0 |= (ulg___2 )((uch___2 )tmp___26) << k___0;
#line 557
        k___0 += 8U;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 558
      d___0 = (w___0 - (unsigned int )t___1->v.n) - ((unsigned int )b___0 & (unsigned int )mask_bits[e___0]);
#line 559
      b___0 >>= e___0;
#line 559
      k___0 -= e___0;
      {
#line 563
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 564
        d___0 &= 32767U;
#line 564
        if (d___0 > w___0) {
#line 564
          tmp___28 = d___0;
        } else {
#line 564
          tmp___28 = w___0;
        }
#line 564
        e___0 = 32768U - tmp___28;
#line 564
        if (e___0 > n___0) {
#line 564
          e___0 = n___0;
        } else {
#line 564
          e___0 = e___0;
        }
#line 564
        n___0 -= e___0;
#line 566
        if (w___0 - d___0 >= e___0) {
          {
#line 568
          memcpy((void */* __restrict  */)(window + w___0), (void const   */* __restrict  */)(window + d___0),
                 (unsigned long )e___0);
#line 569
          w___0 += e___0;
#line 570
          d___0 += e___0;
          }
        } else {
          {
#line 574
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 575
            tmp___29 = w___0;
#line 575
            w___0 ++;
#line 575
            tmp___30 = d___0;
#line 575
            d___0 ++;
#line 575
            window[tmp___29] = window[tmp___30];
#line 574
            e___0 --;
#line 574
            if (! e___0) {
#line 574
              goto while_break___9;
            }
          }
          while_break___9: /* CIL Label */ ;
          }
        }
#line 578
        if (w___0 == 32768U) {
          {
#line 580
          outcnt = w___0;
#line 580
          flush_window();
#line 581
          w___0 = 0U;
          }
        }
#line 563
        if (! n___0) {
#line 563
          goto while_break___8;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  outcnt = w___0;
#line 590
  bb = b___0;
#line 591
  bk = k___0;
#line 594
  return (0);
}
}
#line 599 "inflate.c"
int inflate_stored(void) 
{ 
  unsigned int n___1 ;
  unsigned int w___1 ;
  register ulg___2 b___1 ;
  register unsigned int k___1 ;
  unsigned int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  unsigned int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  unsigned int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;

  {
#line 609
  b___1 = bb;
#line 610
  k___1 = bk;
#line 611
  w___1 = outcnt;
#line 615
  n___1 = k___1 & 7U;
#line 616
  b___1 >>= n___1;
#line 616
  k___1 -= n___1;
  {
#line 620
  while (1) {
    while_continue: /* CIL Label */ ;
#line 620
    if (! (k___1 < 16U)) {
#line 620
      goto while_break;
    }
#line 620
    if (inptr < insize) {
#line 620
      tmp___31 = inptr;
#line 620
      inptr ++;
#line 620
      tmp___33 = (int )inbuf[tmp___31];
    } else {
      {
#line 620
      tmp___32 = fill_inbuf(0);
#line 620
      tmp___33 = tmp___32;
      }
    }
#line 620
    b___1 |= (ulg___2 )((uch___2 )tmp___33) << k___1;
#line 620
    k___1 += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  n___1 = (unsigned int )b___1 & 65535U;
#line 622
  b___1 >>= 16;
#line 622
  k___1 -= 16U;
  {
#line 623
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 623
    if (! (k___1 < 16U)) {
#line 623
      goto while_break___0;
    }
#line 623
    if (inptr < insize) {
#line 623
      tmp___34 = inptr;
#line 623
      inptr ++;
#line 623
      tmp___36 = (int )inbuf[tmp___34];
    } else {
      {
#line 623
      tmp___35 = fill_inbuf(0);
#line 623
      tmp___36 = tmp___35;
      }
    }
#line 623
    b___1 |= (ulg___2 )((uch___2 )tmp___36) << k___1;
#line 623
    k___1 += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 624
  if (n___1 != (unsigned int )(~ b___1 & 65535UL)) {
#line 625
    return (1);
  }
#line 626
  b___1 >>= 16;
#line 626
  k___1 -= 16U;
  {
#line 630
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 630
    tmp___41 = n___1;
#line 630
    n___1 --;
#line 630
    if (! tmp___41) {
#line 630
      goto while_break___1;
    }
    {
#line 632
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 632
      if (! (k___1 < 8U)) {
#line 632
        goto while_break___2;
      }
#line 632
      if (inptr < insize) {
#line 632
        tmp___37 = inptr;
#line 632
        inptr ++;
#line 632
        tmp___39 = (int )inbuf[tmp___37];
      } else {
        {
#line 632
        tmp___38 = fill_inbuf(0);
#line 632
        tmp___39 = tmp___38;
        }
      }
#line 632
      b___1 |= (ulg___2 )((uch___2 )tmp___39) << k___1;
#line 632
      k___1 += 8U;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 633
    tmp___40 = w___1;
#line 633
    w___1 ++;
#line 633
    window[tmp___40] = (uch___2 )b___1;
#line 634
    if (w___1 == 32768U) {
      {
#line 636
      outcnt = w___1;
#line 636
      flush_window();
#line 637
      w___1 = 0U;
      }
    }
#line 639
    b___1 >>= 8;
#line 639
    k___1 -= 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 644
  outcnt = w___1;
#line 645
  bb = b___1;
#line 646
  bk = k___1;
#line 647
  return (0);
}
}
#line 652 "inflate.c"
int inflate_fixed(void) 
{ 
  int i___0 ;
  struct huft *tl___0 ;
  struct huft *td___0 ;
  int bl___0 ;
  int bd___0 ;
  unsigned int l___0[288] ;
  int tmp___42 ;

  {
#line 666
  i___0 = 0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! (i___0 < 144)) {
#line 666
      goto while_break;
    }
#line 667
    l___0[i___0] = 8U;
#line 666
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 668
    if (! (i___0 < 256)) {
#line 668
      goto while_break___0;
    }
#line 669
    l___0[i___0] = 9U;
#line 668
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 670
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 670
    if (! (i___0 < 280)) {
#line 670
      goto while_break___1;
    }
#line 671
    l___0[i___0] = 7U;
#line 670
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 672
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 672
    if (! (i___0 < 288)) {
#line 672
      goto while_break___2;
    }
#line 673
    l___0[i___0] = 8U;
#line 672
    i___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 674
  bl___0 = 7;
#line 675
  i___0 = huft_build(l___0, 288U, 257U, cplens, cplext, & tl___0, & bl___0);
  }
#line 675
  if (i___0 != 0) {
#line 676
    return (i___0);
  }
#line 680
  i___0 = 0;
  {
#line 680
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 680
    if (! (i___0 < 30)) {
#line 680
      goto while_break___3;
    }
#line 681
    l___0[i___0] = 5U;
#line 680
    i___0 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 682
  bd___0 = 5;
#line 683
  i___0 = huft_build(l___0, 30U, 0U, cpdist, cpdext, & td___0, & bd___0);
  }
#line 683
  if (i___0 > 1) {
    {
#line 685
    huft_free(tl___0);
    }
#line 686
    return (i___0);
  }
  {
#line 691
  tmp___42 = inflate_codes(tl___0, td___0, bl___0, bd___0);
  }
#line 691
  if (tmp___42) {
#line 692
    return (1);
  }
  {
#line 696
  huft_free(tl___0);
#line 697
  huft_free(td___0);
  }
#line 698
  return (0);
}
}
#line 703 "inflate.c"
int inflate_dynamic(void) 
{ 
  int i___1 ;
  unsigned int j___0 ;
  unsigned int l___1 ;
  unsigned int m___0 ;
  unsigned int n___2 ;
  struct huft *tl___1 ;
  struct huft *td___1 ;
  int bl___1 ;
  int bd___1 ;
  unsigned int nb ;
  unsigned int nl ;
  unsigned int nd ;
  unsigned int ll[316] ;
  register ulg___2 b___2 ;
  register unsigned int k___2 ;
  unsigned int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  unsigned int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  unsigned int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  unsigned int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  unsigned int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  unsigned int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  unsigned int tmp___63 ;
  unsigned int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  unsigned int tmp___73 ;
  int tmp___74 ;

  {
#line 728
  b___2 = bb;
#line 729
  k___2 = bk;
  {
#line 733
  while (1) {
    while_continue: /* CIL Label */ ;
#line 733
    if (! (k___2 < 5U)) {
#line 733
      goto while_break;
    }
#line 733
    if (inptr < insize) {
#line 733
      tmp___43 = inptr;
#line 733
      inptr ++;
#line 733
      tmp___45 = (int )inbuf[tmp___43];
    } else {
      {
#line 733
      tmp___44 = fill_inbuf(0);
#line 733
      tmp___45 = tmp___44;
      }
    }
#line 733
    b___2 |= (ulg___2 )((uch___2 )tmp___45) << k___2;
#line 733
    k___2 += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  nl = 257U + ((unsigned int )b___2 & 31U);
#line 735
  b___2 >>= 5;
#line 735
  k___2 -= 5U;
  {
#line 736
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 736
    if (! (k___2 < 5U)) {
#line 736
      goto while_break___0;
    }
#line 736
    if (inptr < insize) {
#line 736
      tmp___46 = inptr;
#line 736
      inptr ++;
#line 736
      tmp___48 = (int )inbuf[tmp___46];
    } else {
      {
#line 736
      tmp___47 = fill_inbuf(0);
#line 736
      tmp___48 = tmp___47;
      }
    }
#line 736
    b___2 |= (ulg___2 )((uch___2 )tmp___48) << k___2;
#line 736
    k___2 += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  nd = 1U + ((unsigned int )b___2 & 31U);
#line 738
  b___2 >>= 5;
#line 738
  k___2 -= 5U;
  {
#line 739
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 739
    if (! (k___2 < 4U)) {
#line 739
      goto while_break___1;
    }
#line 739
    if (inptr < insize) {
#line 739
      tmp___49 = inptr;
#line 739
      inptr ++;
#line 739
      tmp___51 = (int )inbuf[tmp___49];
    } else {
      {
#line 739
      tmp___50 = fill_inbuf(0);
#line 739
      tmp___51 = tmp___50;
      }
    }
#line 739
    b___2 |= (ulg___2 )((uch___2 )tmp___51) << k___2;
#line 739
    k___2 += 8U;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 740
  nb = 4U + ((unsigned int )b___2 & 15U);
#line 741
  b___2 >>= 4;
#line 741
  k___2 -= 4U;
#line 745
  if (nl > 286U) {
#line 747
    return (1);
  } else
#line 745
  if (nd > 30U) {
#line 747
    return (1);
  }
#line 751
  j___0 = 0U;
  {
#line 751
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 751
    if (! (j___0 < nb)) {
#line 751
      goto while_break___2;
    }
    {
#line 753
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 753
      if (! (k___2 < 3U)) {
#line 753
        goto while_break___3;
      }
#line 753
      if (inptr < insize) {
#line 753
        tmp___52 = inptr;
#line 753
        inptr ++;
#line 753
        tmp___54 = (int )inbuf[tmp___52];
      } else {
        {
#line 753
        tmp___53 = fill_inbuf(0);
#line 753
        tmp___54 = tmp___53;
        }
      }
#line 753
      b___2 |= (ulg___2 )((uch___2 )tmp___54) << k___2;
#line 753
      k___2 += 8U;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 754
    ll[border[j___0]] = (unsigned int )b___2 & 7U;
#line 755
    b___2 >>= 3;
#line 755
    k___2 -= 3U;
#line 751
    j___0 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 757
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 757
    if (! (j___0 < 19U)) {
#line 757
      goto while_break___4;
    }
#line 758
    ll[border[j___0]] = 0U;
#line 757
    j___0 ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 762
  bl___1 = 7;
#line 763
  i___1 = huft_build(ll, 19U, 19U, (ush___2 *)((void *)0), (ush___2 *)((void *)0),
                     & tl___1, & bl___1);
  }
#line 763
  if (i___1 != 0) {
#line 765
    if (i___1 == 1) {
      {
#line 766
      huft_free(tl___1);
      }
    }
#line 767
    return (i___1);
  }
#line 772
  n___2 = nl + nd;
#line 773
  m___0 = (unsigned int )mask_bits[bl___1];
#line 774
  l___1 = 0U;
#line 774
  i___1 = (int )l___1;
  {
#line 775
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 775
    if (! ((unsigned int )i___1 < n___2)) {
#line 775
      goto while_break___5;
    }
    {
#line 777
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 777
      if (! (k___2 < (unsigned int )bl___1)) {
#line 777
        goto while_break___6;
      }
#line 777
      if (inptr < insize) {
#line 777
        tmp___55 = inptr;
#line 777
        inptr ++;
#line 777
        tmp___57 = (int )inbuf[tmp___55];
      } else {
        {
#line 777
        tmp___56 = fill_inbuf(0);
#line 777
        tmp___57 = tmp___56;
        }
      }
#line 777
      b___2 |= (ulg___2 )((uch___2 )tmp___57) << k___2;
#line 777
      k___2 += 8U;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 778
    td___1 = tl___1 + ((unsigned int )b___2 & m___0);
#line 778
    j___0 = (unsigned int )td___1->b;
#line 779
    b___2 >>= j___0;
#line 779
    k___2 -= j___0;
#line 780
    j___0 = (unsigned int )td___1->v.n;
#line 781
    if (j___0 < 16U) {
#line 782
      tmp___58 = i___1;
#line 782
      i___1 ++;
#line 782
      l___1 = j___0;
#line 782
      ll[tmp___58] = l___1;
    } else
#line 783
    if (j___0 == 16U) {
      {
#line 785
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 785
        if (! (k___2 < 2U)) {
#line 785
          goto while_break___7;
        }
#line 785
        if (inptr < insize) {
#line 785
          tmp___59 = inptr;
#line 785
          inptr ++;
#line 785
          tmp___61 = (int )inbuf[tmp___59];
        } else {
          {
#line 785
          tmp___60 = fill_inbuf(0);
#line 785
          tmp___61 = tmp___60;
          }
        }
#line 785
        b___2 |= (ulg___2 )((uch___2 )tmp___61) << k___2;
#line 785
        k___2 += 8U;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 786
      j___0 = 3U + ((unsigned int )b___2 & 3U);
#line 787
      b___2 >>= 2;
#line 787
      k___2 -= 2U;
#line 788
      if ((unsigned int )i___1 + j___0 > n___2) {
#line 789
        return (1);
      }
      {
#line 790
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 790
        tmp___63 = j___0;
#line 790
        j___0 --;
#line 790
        if (! tmp___63) {
#line 790
          goto while_break___8;
        }
#line 791
        tmp___62 = i___1;
#line 791
        i___1 ++;
#line 791
        ll[tmp___62] = l___1;
      }
      while_break___8: /* CIL Label */ ;
      }
    } else
#line 793
    if (j___0 == 17U) {
      {
#line 795
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 795
        if (! (k___2 < 3U)) {
#line 795
          goto while_break___9;
        }
#line 795
        if (inptr < insize) {
#line 795
          tmp___64 = inptr;
#line 795
          inptr ++;
#line 795
          tmp___66 = (int )inbuf[tmp___64];
        } else {
          {
#line 795
          tmp___65 = fill_inbuf(0);
#line 795
          tmp___66 = tmp___65;
          }
        }
#line 795
        b___2 |= (ulg___2 )((uch___2 )tmp___66) << k___2;
#line 795
        k___2 += 8U;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 796
      j___0 = 3U + ((unsigned int )b___2 & 7U);
#line 797
      b___2 >>= 3;
#line 797
      k___2 -= 3U;
#line 798
      if ((unsigned int )i___1 + j___0 > n___2) {
#line 799
        return (1);
      }
      {
#line 800
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 800
        tmp___68 = j___0;
#line 800
        j___0 --;
#line 800
        if (! tmp___68) {
#line 800
          goto while_break___10;
        }
#line 801
        tmp___67 = i___1;
#line 801
        i___1 ++;
#line 801
        ll[tmp___67] = 0U;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 802
      l___1 = 0U;
    } else {
      {
#line 806
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 806
        if (! (k___2 < 7U)) {
#line 806
          goto while_break___11;
        }
#line 806
        if (inptr < insize) {
#line 806
          tmp___69 = inptr;
#line 806
          inptr ++;
#line 806
          tmp___71 = (int )inbuf[tmp___69];
        } else {
          {
#line 806
          tmp___70 = fill_inbuf(0);
#line 806
          tmp___71 = tmp___70;
          }
        }
#line 806
        b___2 |= (ulg___2 )((uch___2 )tmp___71) << k___2;
#line 806
        k___2 += 8U;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 807
      j___0 = 11U + ((unsigned int )b___2 & 127U);
#line 808
      b___2 >>= 7;
#line 808
      k___2 -= 7U;
#line 809
      if ((unsigned int )i___1 + j___0 > n___2) {
#line 810
        return (1);
      }
      {
#line 811
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 811
        tmp___73 = j___0;
#line 811
        j___0 --;
#line 811
        if (! tmp___73) {
#line 811
          goto while_break___12;
        }
#line 812
        tmp___72 = i___1;
#line 812
        i___1 ++;
#line 812
        ll[tmp___72] = 0U;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 813
      l___1 = 0U;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 819
  huft_free(tl___1);
#line 823
  bb = b___2;
#line 824
  bk = k___2;
#line 828
  bl___1 = lbits;
#line 829
  i___1 = huft_build(ll, nl, 257U, cplens, cplext, & tl___1, & bl___1);
  }
#line 829
  if (i___1 != 0) {
#line 831
    if (i___1 == 1) {
      {
#line 832
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" incomplete literal tree\n");
#line 833
      huft_free(tl___1);
      }
    }
#line 835
    return (i___1);
  }
  {
#line 837
  bd___1 = dbits;
#line 838
  i___1 = huft_build(ll + nl, nd, 0U, cpdist, cpdext, & td___1, & bd___1);
  }
#line 838
  if (i___1 != 0) {
#line 840
    if (i___1 == 1) {
      {
#line 841
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" incomplete distance tree\n");
#line 846
      huft_free(td___1);
      }
    }
    {
#line 848
    huft_free(tl___1);
    }
#line 849
    return (i___1);
  }
  {
#line 855
  tmp___74 = inflate_codes(tl___1, td___1, bl___1, bd___1);
  }
#line 855
  if (tmp___74) {
#line 856
    return (1);
  }
  {
#line 860
  huft_free(tl___1);
#line 861
  huft_free(td___1);
  }
#line 862
  return (0);
}
}
#line 867 "inflate.c"
int inflate_block(int *e___1 ) 
{ 
  unsigned int t___2 ;
  register ulg___2 b___3 ;
  register unsigned int k___3 ;
  unsigned int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  unsigned int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;

  {
#line 877
  b___3 = bb;
#line 878
  k___3 = bk;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (k___3 < 1U)) {
#line 882
      goto while_break;
    }
#line 882
    if (inptr < insize) {
#line 882
      tmp___75 = inptr;
#line 882
      inptr ++;
#line 882
      tmp___77 = (int )inbuf[tmp___75];
    } else {
      {
#line 882
      tmp___76 = fill_inbuf(0);
#line 882
      tmp___77 = tmp___76;
      }
    }
#line 882
    b___3 |= (ulg___2 )((uch___2 )tmp___77) << k___3;
#line 882
    k___3 += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 883
  *e___1 = (int )b___3 & 1;
#line 884
  b___3 >>= 1;
#line 884
  k___3 --;
  {
#line 888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 888
    if (! (k___3 < 2U)) {
#line 888
      goto while_break___0;
    }
#line 888
    if (inptr < insize) {
#line 888
      tmp___78 = inptr;
#line 888
      inptr ++;
#line 888
      tmp___80 = (int )inbuf[tmp___78];
    } else {
      {
#line 888
      tmp___79 = fill_inbuf(0);
#line 888
      tmp___80 = tmp___79;
      }
    }
#line 888
    b___3 |= (ulg___2 )((uch___2 )tmp___80) << k___3;
#line 888
    k___3 += 8U;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 889
  t___2 = (unsigned int )b___3 & 3U;
#line 890
  b___3 >>= 2;
#line 890
  k___3 -= 2U;
#line 894
  bb = b___3;
#line 895
  bk = k___3;
#line 899
  if (t___2 == 2U) {
    {
#line 900
    tmp___81 = inflate_dynamic();
    }
#line 900
    return (tmp___81);
  }
#line 901
  if (t___2 == 0U) {
    {
#line 902
    tmp___82 = inflate_stored();
    }
#line 902
    return (tmp___82);
  }
#line 903
  if (t___2 == 1U) {
    {
#line 904
    tmp___83 = inflate_fixed();
    }
#line 904
    return (tmp___83);
  }
#line 908
  return (2);
}
}
#line 913 "inflate.c"
int inflate(void) 
{ 
  int e___2 ;
  int r___0 ;
  unsigned int h___0 ;

  {
#line 922
  outcnt = 0U;
#line 923
  bk = 0U;
#line 924
  bb = (ulg___2 )0;
#line 928
  h___0 = 0U;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 930
    hufts = 0U;
#line 931
    r___0 = inflate_block(& e___2);
    }
#line 931
    if (r___0 != 0) {
#line 932
      return (r___0);
    }
#line 933
    if (hufts > h___0) {
#line 934
      h___0 = hufts;
    }
#line 929
    if (! (! e___2)) {
#line 929
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 940
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 940
    if (! (bk >= 8U)) {
#line 940
      goto while_break___0;
    }
#line 941
    bk -= 8U;
#line 942
    inptr --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 946
  outcnt = outcnt;
#line 946
  flush_window();
  }
#line 953
  return (0);
}
}
#line 13 "lzw.c"
static int msg_done  =    0;
#line 16 "lzw.c"
int lzw(int in , int out ) 
{ 


  {
#line 19
  if (msg_done) {
#line 19
    return (1);
  }
  {
#line 20
  msg_done = 1;
#line 21
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"output in compress .Z format not supported\n");
  }
#line 22
  if (in != out) {
#line 23
    exit_code = 1;
  }
#line 25
  return (1);
}
}
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__asm__("error in function __bswap_32");
#line 108
__asm__("error in function __bswap_64");
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__asm__("error in function __uint16_identity");
#line 38
__asm__("error in function __uint32_identity");
#line 44
__asm__("error in function __uint64_identity");
#line 94 "trees.c"
static int extra_lbits[29]  = 
#line 94 "trees.c"
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        1,      1,      1,      1, 
        2,      2,      2,      2, 
        3,      3,      3,      3, 
        4,      4,      4,      4, 
        5,      5,      5,      5, 
        0};
#line 97 "trees.c"
static int extra_dbits[30]  = 
#line 97
  {      0,      0,      0,      0, 
        1,      1,      2,      2, 
        3,      3,      4,      4, 
        5,      5,      6,      6, 
        7,      7,      8,      8, 
        9,      9,      10,      10, 
        11,      11,      12,      12, 
        13,      13};
#line 100 "trees.c"
static int extra_blbits[19]  = 
#line 100
  {      0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        0,      0,      0,      0, 
        2,      3,      7};
#line 179 "trees.c"
static ct_data dyn_ltree[573]  ;
#line 180 "trees.c"
static ct_data dyn_dtree[61]  ;
#line 182 "trees.c"
static ct_data static_ltree[288]  ;
#line 189 "trees.c"
static ct_data static_dtree[30]  ;
#line 194 "trees.c"
static ct_data bl_tree[39]  ;
#line 207 "trees.c"
static tree_desc l_desc  =    {dyn_ltree, static_ltree, extra_lbits, 257, 286, 15, 0};
#line 210 "trees.c"
static tree_desc d_desc  =    {dyn_dtree, static_dtree, extra_dbits, 0, 30, 15, 0};
#line 213 "trees.c"
static tree_desc bl_desc  =    {bl_tree, (ct_data *)0, extra_blbits, 0, 19, 7, 0};
#line 217 "trees.c"
static ush___4 bl_count[16]  ;
#line 220 "trees.c"
static uch___4 bl_order[19]  = 
#line 220
  {      (uch___4 )16,      (uch___4 )17,      (uch___4 )18,      (uch___4 )0, 
        (uch___4 )8,      (uch___4 )7,      (uch___4 )9,      (uch___4 )6, 
        (uch___4 )10,      (uch___4 )5,      (uch___4 )11,      (uch___4 )4, 
        (uch___4 )12,      (uch___4 )3,      (uch___4 )13,      (uch___4 )2, 
        (uch___4 )14,      (uch___4 )1,      (uch___4 )15};
#line 226 "trees.c"
static int heap[573]  ;
#line 227 "trees.c"
static int heap_len  ;
#line 228 "trees.c"
static int heap_max  ;
#line 233 "trees.c"
static uch___4 depth[573]  ;
#line 236 "trees.c"
static uch___4 length_code[256]  ;
#line 239 "trees.c"
static uch___4 dist_code[512]  ;
#line 245 "trees.c"
static int base_length[29]  ;
#line 248 "trees.c"
static int base_dist[30]  ;
#line 256 "trees.c"
static uch___4 flag_buf[4096]  ;
#line 261 "trees.c"
static unsigned int last_lit  ;
#line 262 "trees.c"
static unsigned int last_dist  ;
#line 263 "trees.c"
static unsigned int last_flags  ;
#line 264 "trees.c"
static uch___4 flags  ;
#line 265 "trees.c"
static uch___4 flag_bit  ;
#line 271 "trees.c"
static ulg___4 opt_len  ;
#line 272 "trees.c"
static ulg___4 static_len  ;
#line 274 "trees.c"
static ulg___4 compressed_len  ;
#line 276 "trees.c"
static ulg___4 input_len  ;
#line 279 "trees.c"
ush___4 *file_type  ;
#line 280 "trees.c"
int *file_method  ;
#line 294
static void init_block(void) ;
#line 295
static void pqdownheap(ct_data *tree , int k___4 ) ;
#line 296
static void gen_bitlen(tree_desc *desc ) ;
#line 297
static void gen_codes(ct_data *tree___1 , int max_code___0 ) ;
#line 298
static void build_tree(tree_desc *desc___0 ) ;
#line 299
static void scan_tree(ct_data *tree___3 , int max_code___2 ) ;
#line 300
static void send_tree(ct_data *tree___4 , int max_code___3 ) ;
#line 301
static int build_bl_tree(void) ;
#line 302
static void send_all_trees(int lcodes , int dcodes , int blcodes ) ;
#line 303
static void compress_block(ct_data *ltree , ct_data *dtree ) ;
#line 304
static void set_file_type(void) ;
#line 332 "trees.c"
void ct_init(unsigned short *attr , int *methodp ) 
{ 
  int n___3 ;
  int bits ;
  int length ;
  int code ;
  int dist ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  unsigned int tmp___91 ;

  {
#line 342
  file_type = attr;
#line 343
  file_method = methodp;
#line 344
  input_len = (ulg___4 )0L;
#line 344
  compressed_len = input_len;
#line 346
  if ((int )static_dtree[0].dl.len != 0) {
#line 346
    return;
  }
#line 349
  length = 0;
#line 350
  code = 0;
  {
#line 350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 350
    if (! (code < 28)) {
#line 350
      goto while_break;
    }
#line 351
    base_length[code] = length;
#line 352
    n___3 = 0;
    {
#line 352
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 352
      if (! (n___3 < 1 << extra_lbits[code])) {
#line 352
        goto while_break___0;
      }
#line 353
      tmp___84 = length;
#line 353
      length ++;
#line 353
      length_code[tmp___84] = (uch___4 )code;
#line 352
      n___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 350
    code ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  length_code[length - 1] = (uch___4 )code;
#line 364
  dist = 0;
#line 365
  code = 0;
  {
#line 365
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 365
    if (! (code < 16)) {
#line 365
      goto while_break___1;
    }
#line 366
    base_dist[code] = dist;
#line 367
    n___3 = 0;
    {
#line 367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 367
      if (! (n___3 < 1 << extra_dbits[code])) {
#line 367
        goto while_break___2;
      }
#line 368
      tmp___85 = dist;
#line 368
      dist ++;
#line 368
      dist_code[tmp___85] = (uch___4 )code;
#line 367
      n___3 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 365
    code ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 372
  dist >>= 7;
  {
#line 373
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 373
    if (! (code < 30)) {
#line 373
      goto while_break___3;
    }
#line 374
    base_dist[code] = dist << 7;
#line 375
    n___3 = 0;
    {
#line 375
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 375
      if (! (n___3 < 1 << (extra_dbits[code] - 7))) {
#line 375
        goto while_break___4;
      }
#line 376
      tmp___86 = dist;
#line 376
      dist ++;
#line 376
      dist_code[256 + tmp___86] = (uch___4 )code;
#line 375
      n___3 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 373
    code ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 382
  bits = 0;
  {
#line 382
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 382
    if (! (bits <= 15)) {
#line 382
      goto while_break___5;
    }
#line 382
    bl_count[bits] = (ush___4 )0;
#line 382
    bits ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 383
  n___3 = 0;
  {
#line 384
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 384
    if (! (n___3 <= 143)) {
#line 384
      goto while_break___6;
    }
#line 384
    tmp___87 = n___3;
#line 384
    n___3 ++;
#line 384
    static_ltree[tmp___87].dl.len = (ush___4 )8;
#line 384
    bl_count[8] = (ush___4 )((int )bl_count[8] + 1);
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 385
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 385
    if (! (n___3 <= 255)) {
#line 385
      goto while_break___7;
    }
#line 385
    tmp___88 = n___3;
#line 385
    n___3 ++;
#line 385
    static_ltree[tmp___88].dl.len = (ush___4 )9;
#line 385
    bl_count[9] = (ush___4 )((int )bl_count[9] + 1);
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 386
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 386
    if (! (n___3 <= 279)) {
#line 386
      goto while_break___8;
    }
#line 386
    tmp___89 = n___3;
#line 386
    n___3 ++;
#line 386
    static_ltree[tmp___89].dl.len = (ush___4 )7;
#line 386
    bl_count[7] = (ush___4 )((int )bl_count[7] + 1);
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 387
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 387
    if (! (n___3 <= 287)) {
#line 387
      goto while_break___9;
    }
#line 387
    tmp___90 = n___3;
#line 387
    n___3 ++;
#line 387
    static_ltree[tmp___90].dl.len = (ush___4 )8;
#line 387
    bl_count[8] = (ush___4 )((int )bl_count[8] + 1);
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 392
  gen_codes(static_ltree, 287);
#line 395
  n___3 = 0;
  }
  {
#line 395
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 395
    if (! (n___3 < 30)) {
#line 395
      goto while_break___10;
    }
    {
#line 396
    static_dtree[n___3].dl.len = (ush___4 )5;
#line 397
    tmp___91 = bi_reverse((unsigned int )n___3, 5);
#line 397
    static_dtree[n___3].fc.code = (ush___4 )tmp___91;
#line 395
    n___3 ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 401
  init_block();
  }
#line 402
  return;
}
}
#line 407 "trees.c"
static void init_block(void) 
{ 
  int n___4 ;

  {
#line 412
  n___4 = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (n___4 < 286)) {
#line 412
      goto while_break;
    }
#line 412
    dyn_ltree[n___4].fc.freq = (ush___4 )0;
#line 412
    n___4 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  n___4 = 0;
  {
#line 413
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 413
    if (! (n___4 < 30)) {
#line 413
      goto while_break___0;
    }
#line 413
    dyn_dtree[n___4].fc.freq = (ush___4 )0;
#line 413
    n___4 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 414
  n___4 = 0;
  {
#line 414
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 414
    if (! (n___4 < 19)) {
#line 414
      goto while_break___1;
    }
#line 414
    bl_tree[n___4].fc.freq = (ush___4 )0;
#line 414
    n___4 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 416
  dyn_ltree[256].fc.freq = (ush___4 )1;
#line 417
  static_len = (ulg___4 )0L;
#line 417
  opt_len = static_len;
#line 418
  last_flags = 0U;
#line 418
  last_dist = last_flags;
#line 418
  last_lit = last_dist;
#line 419
  flags = (uch___4 )0;
#line 419
  flag_bit = (uch___4 )1;
#line 420
  return;
}
}
#line 451 "trees.c"
static void pqdownheap(ct_data *tree , int k___4 ) 
{ 
  int v___0 ;
  int j___1 ;

  {
#line 455
  v___0 = heap[k___4];
#line 456
  j___1 = k___4 << 1;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (j___1 <= heap_len)) {
#line 457
      goto while_break;
    }
#line 459
    if (j___1 < heap_len) {
#line 459
      if ((int )(tree + heap[j___1 + 1])->fc.freq < (int )(tree + heap[j___1])->fc.freq) {
#line 459
        j___1 ++;
      } else
#line 459
      if ((int )(tree + heap[j___1 + 1])->fc.freq == (int )(tree + heap[j___1])->fc.freq) {
#line 459
        if ((int )depth[heap[j___1 + 1]] <= (int )depth[heap[j___1]]) {
#line 459
          j___1 ++;
        }
      }
    }
#line 462
    if ((int )(tree + v___0)->fc.freq < (int )(tree + heap[j___1])->fc.freq) {
#line 462
      goto while_break;
    } else
#line 462
    if ((int )(tree + v___0)->fc.freq == (int )(tree + heap[j___1])->fc.freq) {
#line 462
      if ((int )depth[v___0] <= (int )depth[heap[j___1]]) {
#line 462
        goto while_break;
      }
    }
#line 465
    heap[k___4] = heap[j___1];
#line 465
    k___4 = j___1;
#line 468
    j___1 <<= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  heap[k___4] = v___0;
#line 471
  return;
}
}
#line 483 "trees.c"
static void gen_bitlen(tree_desc *desc ) 
{ 
  ct_data *tree___0 ;
  int *extra ;
  int base ;
  int max_code ;
  int max_length ;
  ct_data *stree ;
  int h___1 ;
  int n___5 ;
  int m___1 ;
  int bits___0 ;
  int xbits ;
  ush___4 f___0 ;
  int overflow ;

  {
#line 486
  tree___0 = desc->dyn_tree;
#line 487
  extra = desc->extra_bits;
#line 488
  base = desc->extra_base;
#line 489
  max_code = desc->max_code;
#line 490
  max_length = desc->max_length;
#line 491
  stree = desc->static_tree;
#line 497
  overflow = 0;
#line 499
  bits___0 = 0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (bits___0 <= 15)) {
#line 499
      goto while_break;
    }
#line 499
    bl_count[bits___0] = (ush___4 )0;
#line 499
    bits___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  (tree___0 + heap[heap_max])->dl.len = (ush___4 )0;
#line 506
  h___1 = heap_max + 1;
  {
#line 506
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 506
    if (! (h___1 < 573)) {
#line 506
      goto while_break___0;
    }
#line 507
    n___5 = heap[h___1];
#line 508
    bits___0 = (int )(tree___0 + (tree___0 + n___5)->dl.dad)->dl.len + 1;
#line 509
    if (bits___0 > max_length) {
#line 509
      bits___0 = max_length;
#line 509
      overflow ++;
    }
#line 510
    (tree___0 + n___5)->dl.len = (ush___4 )bits___0;
#line 513
    if (n___5 > max_code) {
#line 513
      goto __Cont;
    }
#line 515
    bl_count[bits___0] = (ush___4 )((int )bl_count[bits___0] + 1);
#line 516
    xbits = 0;
#line 517
    if (n___5 >= base) {
#line 517
      xbits = *(extra + (n___5 - base));
    }
#line 518
    f___0 = (tree___0 + n___5)->fc.freq;
#line 519
    opt_len += (ulg___4 )f___0 * (ulg___4 )(bits___0 + xbits);
#line 520
    if (stree) {
#line 520
      static_len += (ulg___4 )f___0 * (ulg___4 )((int )(stree + n___5)->dl.len + xbits);
    }
    __Cont: /* CIL Label */ 
#line 506
    h___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 522
  if (overflow == 0) {
#line 522
    return;
  }
  {
#line 528
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 529
    bits___0 = max_length - 1;
    {
#line 530
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 530
      if (! ((int )bl_count[bits___0] == 0)) {
#line 530
        goto while_break___2;
      }
#line 530
      bits___0 --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 531
    bl_count[bits___0] = (ush___4 )((int )bl_count[bits___0] - 1);
#line 532
    bl_count[bits___0 + 1] = (ush___4 )((int )bl_count[bits___0 + 1] + 2);
#line 533
    bl_count[max_length] = (ush___4 )((int )bl_count[max_length] - 1);
#line 537
    overflow -= 2;
#line 528
    if (! (overflow > 0)) {
#line 528
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 545
  bits___0 = max_length;
  {
#line 545
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 545
    if (! (bits___0 != 0)) {
#line 545
      goto while_break___3;
    }
#line 546
    n___5 = (int )bl_count[bits___0];
    {
#line 547
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 547
      if (! (n___5 != 0)) {
#line 547
        goto while_break___4;
      }
#line 548
      h___1 --;
#line 548
      m___1 = heap[h___1];
#line 549
      if (m___1 > max_code) {
#line 549
        goto while_continue___4;
      }
#line 550
      if ((unsigned int )(tree___0 + m___1)->dl.len != (unsigned int )bits___0) {
#line 552
        opt_len += (ulg___4 )(((long )bits___0 - (long )(tree___0 + m___1)->dl.len) * (long )(tree___0 + m___1)->fc.freq);
#line 553
        (tree___0 + m___1)->dl.len = (ush___4 )bits___0;
      }
#line 555
      n___5 --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 545
    bits___0 --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 558
  return;
}
}
#line 568 "trees.c"
static void gen_codes(ct_data *tree___1 , int max_code___0 ) 
{ 
  ush___4 next_code[16] ;
  ush___4 code___0 ;
  int bits___1 ;
  int n___6 ;
  int len ;
  ush___4 tmp___92 ;
  unsigned int tmp___93 ;

  {
#line 573
  code___0 = (ush___4 )0;
#line 580
  bits___1 = 1;
  {
#line 580
  while (1) {
    while_continue: /* CIL Label */ ;
#line 580
    if (! (bits___1 <= 15)) {
#line 580
      goto while_break;
    }
#line 581
    code___0 = (ush___4 )(((int )code___0 + (int )bl_count[bits___1 - 1]) << 1);
#line 581
    next_code[bits___1] = code___0;
#line 580
    bits___1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  n___6 = 0;
  {
#line 590
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 590
    if (! (n___6 <= max_code___0)) {
#line 590
      goto while_break___0;
    }
#line 591
    len = (int )(tree___1 + n___6)->dl.len;
#line 592
    if (len == 0) {
#line 592
      goto __Cont___0;
    }
    {
#line 594
    tmp___92 = next_code[len];
#line 594
    next_code[len] = (ush___4 )((int )next_code[len] + 1);
#line 594
    tmp___93 = bi_reverse((unsigned int )tmp___92, len);
#line 594
    (tree___1 + n___6)->fc.code = (ush___4 )tmp___93;
    }
    __Cont___0: /* CIL Label */ 
#line 590
    n___6 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 599
  return;
}
}
#line 609 "trees.c"
static void build_tree(tree_desc *desc___0 ) 
{ 
  ct_data *tree___2 ;
  ct_data *stree___0 ;
  int elems ;
  int n___7 ;
  int m___2 ;
  int max_code___1 ;
  int node ;
  int new ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  ush___4 tmp___97 ;
  int tmp___98 ;

  {
#line 612
  tree___2 = desc___0->dyn_tree;
#line 613
  stree___0 = desc___0->static_tree;
#line 614
  elems = desc___0->elems;
#line 616
  max_code___1 = -1;
#line 617
  node = elems;
#line 623
  heap_len = 0;
#line 623
  heap_max = 573;
#line 625
  n___7 = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 625
    if (! (n___7 < elems)) {
#line 625
      goto while_break;
    }
#line 626
    if ((int )(tree___2 + n___7)->fc.freq != 0) {
#line 627
      heap_len ++;
#line 627
      max_code___1 = n___7;
#line 627
      heap[heap_len] = max_code___1;
#line 628
      depth[n___7] = (uch___4 )0;
    } else {
#line 630
      (tree___2 + n___7)->dl.len = (ush___4 )0;
    }
#line 625
    n___7 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 639
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 639
    if (! (heap_len < 2)) {
#line 639
      goto while_break___0;
    }
#line 640
    heap_len ++;
#line 640
    if (max_code___1 < 2) {
#line 640
      max_code___1 ++;
#line 640
      tmp___94 = max_code___1;
    } else {
#line 640
      tmp___94 = 0;
    }
#line 640
    heap[heap_len] = tmp___94;
#line 640
    new = tmp___94;
#line 641
    (tree___2 + new)->fc.freq = (ush___4 )1;
#line 642
    depth[new] = (uch___4 )0;
#line 643
    opt_len --;
#line 643
    if (stree___0) {
#line 643
      static_len -= (ulg___4 )(stree___0 + new)->dl.len;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 646
  desc___0->max_code = max_code___1;
#line 651
  n___7 = heap_len / 2;
  {
#line 651
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 651
    if (! (n___7 >= 1)) {
#line 651
      goto while_break___1;
    }
    {
#line 651
    pqdownheap(tree___2, n___7);
#line 651
    n___7 --;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 656
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 657
    n___7 = heap[1];
#line 657
    tmp___95 = heap_len;
#line 657
    heap_len --;
#line 657
    heap[1] = heap[tmp___95];
#line 657
    pqdownheap(tree___2, 1);
#line 658
    m___2 = heap[1];
#line 660
    heap_max --;
#line 660
    heap[heap_max] = n___7;
#line 661
    heap_max --;
#line 661
    heap[heap_max] = m___2;
#line 664
    (tree___2 + node)->fc.freq = (ush___4 )((int )(tree___2 + n___7)->fc.freq + (int )(tree___2 + m___2)->fc.freq);
    }
#line 665
    if ((int )depth[n___7] >= (int )depth[m___2]) {
#line 665
      tmp___96 = (int )depth[n___7];
    } else {
#line 665
      tmp___96 = (int )depth[m___2];
    }
    {
#line 665
    depth[node] = (uch___4 )(tmp___96 + 1);
#line 666
    tmp___97 = (ush___4 )node;
#line 666
    (tree___2 + m___2)->dl.dad = tmp___97;
#line 666
    (tree___2 + n___7)->dl.dad = tmp___97;
#line 674
    tmp___98 = node;
#line 674
    node ++;
#line 674
    heap[1] = tmp___98;
#line 675
    pqdownheap(tree___2, 1);
    }
#line 656
    if (! (heap_len >= 2)) {
#line 656
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 679
  heap_max --;
#line 679
  heap[heap_max] = heap[1];
#line 684
  gen_bitlen(desc___0);
#line 687
  gen_codes(tree___2, max_code___1);
  }
#line 688
  return;
}
}
#line 696 "trees.c"
static void scan_tree(ct_data *tree___3 , int max_code___2 ) 
{ 
  int n___8 ;
  int prevlen ;
  int curlen ;
  int nextlen ;
  int count ;
  int max_count ;
  int min_count ;

  {
#line 701
  prevlen = -1;
#line 703
  nextlen = (int )(tree___3 + 0)->dl.len;
#line 704
  count = 0;
#line 705
  max_count = 7;
#line 706
  min_count = 4;
#line 708
  if (nextlen == 0) {
#line 708
    max_count = 138;
#line 708
    min_count = 3;
  }
#line 709
  (tree___3 + (max_code___2 + 1))->dl.len = (ush___4 )65535;
#line 711
  n___8 = 0;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! (n___8 <= max_code___2)) {
#line 711
      goto while_break;
    }
#line 712
    curlen = nextlen;
#line 712
    nextlen = (int )(tree___3 + (n___8 + 1))->dl.len;
#line 713
    count ++;
#line 713
    if (count < max_count) {
#line 713
      if (curlen == nextlen) {
#line 714
        goto __Cont___1;
      } else {
#line 713
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 715
    if (count < min_count) {
#line 716
      bl_tree[curlen].fc.freq = (ush___4 )((int )bl_tree[curlen].fc.freq + count);
    } else
#line 717
    if (curlen != 0) {
#line 718
      if (curlen != prevlen) {
#line 718
        bl_tree[curlen].fc.freq = (ush___4 )((int )bl_tree[curlen].fc.freq + 1);
      }
#line 719
      bl_tree[16].fc.freq = (ush___4 )((int )bl_tree[16].fc.freq + 1);
    } else
#line 720
    if (count <= 10) {
#line 721
      bl_tree[17].fc.freq = (ush___4 )((int )bl_tree[17].fc.freq + 1);
    } else {
#line 723
      bl_tree[18].fc.freq = (ush___4 )((int )bl_tree[18].fc.freq + 1);
    }
#line 725
    count = 0;
#line 725
    prevlen = curlen;
#line 726
    if (nextlen == 0) {
#line 727
      max_count = 138;
#line 727
      min_count = 3;
    } else
#line 728
    if (curlen == nextlen) {
#line 729
      max_count = 6;
#line 729
      min_count = 3;
    } else {
#line 731
      max_count = 7;
#line 731
      min_count = 4;
    }
    __Cont___1: /* CIL Label */ 
#line 711
    n___8 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return;
}
}
#line 740 "trees.c"
static void send_tree(ct_data *tree___4 , int max_code___3 ) 
{ 
  int n___9 ;
  int prevlen___0 ;
  int curlen___0 ;
  int nextlen___0 ;
  int count___0 ;
  int max_count___0 ;
  int min_count___0 ;

  {
#line 745
  prevlen___0 = -1;
#line 747
  nextlen___0 = (int )(tree___4 + 0)->dl.len;
#line 748
  count___0 = 0;
#line 749
  max_count___0 = 7;
#line 750
  min_count___0 = 4;
#line 753
  if (nextlen___0 == 0) {
#line 753
    max_count___0 = 138;
#line 753
    min_count___0 = 3;
  }
#line 755
  n___9 = 0;
  {
#line 755
  while (1) {
    while_continue: /* CIL Label */ ;
#line 755
    if (! (n___9 <= max_code___3)) {
#line 755
      goto while_break;
    }
#line 756
    curlen___0 = nextlen___0;
#line 756
    nextlen___0 = (int )(tree___4 + (n___9 + 1))->dl.len;
#line 757
    count___0 ++;
#line 757
    if (count___0 < max_count___0) {
#line 757
      if (curlen___0 == nextlen___0) {
#line 758
        goto __Cont___2;
      } else {
#line 757
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 759
    if (count___0 < min_count___0) {
      {
#line 760
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 760
        send_bits((int )bl_tree[curlen___0].fc.code, (int )bl_tree[curlen___0].dl.len);
#line 760
        count___0 --;
        }
#line 760
        if (! (count___0 != 0)) {
#line 760
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 762
    if (curlen___0 != 0) {
#line 763
      if (curlen___0 != prevlen___0) {
        {
#line 764
        send_bits((int )bl_tree[curlen___0].fc.code, (int )bl_tree[curlen___0].dl.len);
#line 764
        count___0 --;
        }
      }
      {
#line 767
      send_bits((int )bl_tree[16].fc.code, (int )bl_tree[16].dl.len);
#line 767
      send_bits(count___0 - 3, 2);
      }
    } else
#line 769
    if (count___0 <= 10) {
      {
#line 770
      send_bits((int )bl_tree[17].fc.code, (int )bl_tree[17].dl.len);
#line 770
      send_bits(count___0 - 3, 3);
      }
    } else {
      {
#line 773
      send_bits((int )bl_tree[18].fc.code, (int )bl_tree[18].dl.len);
#line 773
      send_bits(count___0 - 11, 7);
      }
    }
#line 775
    count___0 = 0;
#line 775
    prevlen___0 = curlen___0;
#line 776
    if (nextlen___0 == 0) {
#line 777
      max_count___0 = 138;
#line 777
      min_count___0 = 3;
    } else
#line 778
    if (curlen___0 == nextlen___0) {
#line 779
      max_count___0 = 6;
#line 779
      min_count___0 = 3;
    } else {
#line 781
      max_count___0 = 7;
#line 781
      min_count___0 = 4;
    }
    __Cont___2: /* CIL Label */ 
#line 755
    n___9 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 784
  return;
}
}
#line 790 "trees.c"
static int build_bl_tree(void) 
{ 
  int max_blindex ;

  {
  {
#line 795
  scan_tree(dyn_ltree, l_desc.max_code);
#line 796
  scan_tree(dyn_dtree, d_desc.max_code);
#line 799
  build_tree(& bl_desc);
#line 808
  max_blindex = 18;
  }
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    if (! (max_blindex >= 3)) {
#line 808
      goto while_break;
    }
#line 809
    if ((int )bl_tree[bl_order[max_blindex]].dl.len != 0) {
#line 809
      goto while_break;
    }
#line 808
    max_blindex --;
  }
  while_break: /* CIL Label */ ;
  }
#line 812
  opt_len += (ulg___4 )(((3 * (max_blindex + 1) + 5) + 5) + 4);
#line 815
  return (max_blindex);
}
}
#line 823 "trees.c"
static void send_all_trees(int lcodes , int dcodes , int blcodes ) 
{ 
  int rank ;

  {
  {
#line 832
  send_bits(lcodes - 257, 5);
#line 833
  send_bits(dcodes - 1, 5);
#line 834
  send_bits(blcodes - 4, 4);
#line 835
  rank = 0;
  }
  {
#line 835
  while (1) {
    while_continue: /* CIL Label */ ;
#line 835
    if (! (rank < blcodes)) {
#line 835
      goto while_break;
    }
    {
#line 837
    send_bits((int )bl_tree[bl_order[rank]].dl.len, 3);
#line 835
    rank ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 841
  send_tree(dyn_ltree, lcodes - 1);
#line 844
  send_tree(dyn_dtree, dcodes - 1);
  }
#line 846
  return;
}
}
#line 853 "trees.c"
unsigned long flush_block(char *buf , unsigned long stored_len , int eof ) 
{ 
  ulg___4 opt_lenb ;
  ulg___4 static_lenb ;
  int max_blindex___0 ;

  {
#line 861
  flag_buf[last_flags] = flags;
#line 864
  if ((int )*file_type == 65535) {
    {
#line 864
    set_file_type();
    }
  }
  {
#line 867
  build_tree(& l_desc);
#line 870
  build_tree(& d_desc);
#line 879
  max_blindex___0 = build_bl_tree();
#line 882
  opt_lenb = ((opt_len + 3UL) + 7UL) >> 3;
#line 883
  static_lenb = ((static_len + 3UL) + 7UL) >> 3;
#line 884
  input_len += stored_len;
  }
#line 890
  if (static_lenb <= opt_lenb) {
#line 890
    opt_lenb = static_lenb;
  }
#line 899
  if (stored_len <= opt_lenb) {
#line 899
    if (eof) {
#line 899
      if (compressed_len == 0UL) {
#line 899
        goto _L___4;
      } else {
#line 899
        goto _L___4;
      }
    } else {
#line 899
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 911
  if (stored_len + 4UL <= opt_lenb) {
#line 911
    if ((unsigned long )buf != (unsigned long )((char *)0)) {
      {
#line 920
      send_bits(eof, 3);
#line 921
      compressed_len = ((compressed_len + 3UL) + 7UL) & 0xfffffffffffffff8UL;
#line 922
      compressed_len += (stored_len + 4UL) << 3;
#line 924
      copy_block(buf, (unsigned int )stored_len, 1);
      }
    } else {
#line 911
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 929
  if (static_lenb == opt_lenb) {
    {
#line 931
    send_bits((1 << 1) + eof, 3);
#line 932
    compress_block(static_ltree, static_dtree);
#line 933
    compressed_len += 3UL + static_len;
    }
  } else {
    {
#line 935
    send_bits((2 << 1) + eof, 3);
#line 936
    send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex___0 + 1);
#line 937
    compress_block(dyn_ltree, dyn_dtree);
#line 938
    compressed_len += 3UL + opt_len;
    }
  }
  {
#line 941
  init_block();
  }
#line 943
  if (eof) {
    {
#line 945
    bi_windup();
#line 946
    compressed_len += 7UL;
    }
  }
#line 951
  return (compressed_len >> 3);
}
}
#line 958 "trees.c"
int ct_tally(int dist___0 , int lc ) 
{ 
  unsigned int tmp___99 ;
  int tmp___100 ;
  unsigned int tmp___101 ;
  unsigned int tmp___102 ;
  ulg___4 out_length ;
  ulg___4 in_length ;
  int dcode ;
  int tmp___103 ;

  {
#line 962
  tmp___99 = last_lit;
#line 962
  last_lit ++;
#line 962
  inbuf[tmp___99] = (uch___4 )lc;
#line 963
  if (dist___0 == 0) {
#line 965
    dyn_ltree[lc].fc.freq = (ush___4 )((int )dyn_ltree[lc].fc.freq + 1);
  } else {
#line 968
    dist___0 --;
#line 973
    dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq = (ush___4 )((int )dyn_ltree[((int )length_code[lc] + 256) + 1].fc.freq + 1);
#line 974
    if (dist___0 < 256) {
#line 974
      tmp___100 = (int )dist_code[dist___0];
    } else {
#line 974
      tmp___100 = (int )dist_code[256 + (dist___0 >> 7)];
    }
#line 974
    dyn_dtree[tmp___100].fc.freq = (ush___4 )((int )dyn_dtree[tmp___100].fc.freq + 1);
#line 976
    tmp___101 = last_dist;
#line 976
    last_dist ++;
#line 976
    d_buf[tmp___101] = (ush___4 )dist___0;
#line 977
    flags = (uch___4 )((int )flags | (int )flag_bit);
  }
#line 979
  flag_bit = (uch___4 )((int )flag_bit << 1);
#line 982
  if ((last_lit & 7U) == 0U) {
#line 983
    tmp___102 = last_flags;
#line 983
    last_flags ++;
#line 983
    flag_buf[tmp___102] = flags;
#line 984
    flags = (uch___4 )0;
#line 984
    flag_bit = (uch___4 )1;
  }
#line 987
  if (level > 2) {
#line 987
    if ((last_lit & 4095U) == 0U) {
#line 989
      out_length = (ulg___4 )last_lit * 8UL;
#line 990
      in_length = (ulg___4 )strstart - (ulg___4 )block_start;
#line 992
      dcode = 0;
      {
#line 992
      while (1) {
        while_continue: /* CIL Label */ ;
#line 992
        if (! (dcode < 30)) {
#line 992
          goto while_break;
        }
#line 993
        out_length += (ulg___4 )dyn_dtree[dcode].fc.freq * (ulg___4 )(5L + (long )extra_dbits[dcode]);
#line 992
        dcode ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 995
      out_length >>= 3;
#line 999
      if (last_dist < last_lit / 2U) {
#line 999
        if (out_length < in_length / 2UL) {
#line 999
          return (1);
        }
      }
    }
  }
#line 1001
  if (last_lit == 32767U) {
#line 1001
    tmp___103 = 1;
  } else
#line 1001
  if (last_dist == 32768U) {
#line 1001
    tmp___103 = 1;
  } else {
#line 1001
    tmp___103 = 0;
  }
#line 1001
  return (tmp___103);
}
}
#line 1011 "trees.c"
static void compress_block(ct_data *ltree , ct_data *dtree ) 
{ 
  unsigned int dist___1 ;
  int lc___0 ;
  unsigned int lx ;
  unsigned int dx ;
  unsigned int fx ;
  uch___4 flag ;
  unsigned int code___1 ;
  int extra___0 ;
  unsigned int tmp___104 ;
  unsigned int tmp___105 ;
  unsigned int tmp___106 ;

  {
#line 1017
  lx = 0U;
#line 1018
  dx = 0U;
#line 1019
  fx = 0U;
#line 1020
  flag = (uch___4 )0;
#line 1024
  if (last_lit != 0U) {
    {
#line 1024
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1025
      if ((lx & 7U) == 0U) {
#line 1025
        tmp___104 = fx;
#line 1025
        fx ++;
#line 1025
        flag = flag_buf[tmp___104];
      }
#line 1026
      tmp___105 = lx;
#line 1026
      lx ++;
#line 1026
      lc___0 = (int )inbuf[tmp___105];
#line 1027
      if (((int )flag & 1) == 0) {
        {
#line 1028
        send_bits((int )(ltree + lc___0)->fc.code, (int )(ltree + lc___0)->dl.len);
        }
      } else {
        {
#line 1032
        code___1 = (unsigned int )length_code[lc___0];
#line 1033
        send_bits((int )(ltree + ((code___1 + 256U) + 1U))->fc.code, (int )(ltree + ((code___1 + 256U) + 1U))->dl.len);
#line 1034
        extra___0 = extra_lbits[code___1];
        }
#line 1035
        if (extra___0 != 0) {
          {
#line 1036
          lc___0 -= base_length[code___1];
#line 1037
          send_bits(lc___0, extra___0);
          }
        }
#line 1039
        tmp___106 = dx;
#line 1039
        dx ++;
#line 1039
        dist___1 = (unsigned int )d_buf[tmp___106];
#line 1041
        if (dist___1 < 256U) {
#line 1041
          code___1 = (unsigned int )dist_code[dist___1];
        } else {
#line 1041
          code___1 = (unsigned int )dist_code[256U + (dist___1 >> 7)];
        }
        {
#line 1044
        send_bits((int )(dtree + code___1)->fc.code, (int )(dtree + code___1)->dl.len);
#line 1045
        extra___0 = extra_dbits[code___1];
        }
#line 1046
        if (extra___0 != 0) {
          {
#line 1047
          dist___1 -= (unsigned int )base_dist[code___1];
#line 1048
          send_bits((int )dist___1, extra___0);
          }
        }
      }
#line 1051
      flag = (uch___4 )((int )flag >> 1);
#line 1024
      if (! (lx < last_lit)) {
#line 1024
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1054
  send_bits((int )(ltree + 256)->fc.code, (int )(ltree + 256)->dl.len);
  }
#line 1055
  return;
}
}
#line 1063 "trees.c"
static void set_file_type(void) 
{ 
  int n___10 ;
  unsigned int ascii_freq ;
  unsigned int bin_freq ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;

  {
#line 1065
  n___10 = 0;
#line 1066
  ascii_freq = 0U;
#line 1067
  bin_freq = 0U;
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (n___10 < 7)) {
#line 1068
      goto while_break;
    }
#line 1068
    tmp___107 = n___10;
#line 1068
    n___10 ++;
#line 1068
    bin_freq += (unsigned int )dyn_ltree[tmp___107].fc.freq;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1069
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1069
    if (! (n___10 < 128)) {
#line 1069
      goto while_break___0;
    }
#line 1069
    tmp___108 = n___10;
#line 1069
    n___10 ++;
#line 1069
    ascii_freq += (unsigned int )dyn_ltree[tmp___108].fc.freq;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1070
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1070
    if (! (n___10 < 256)) {
#line 1070
      goto while_break___1;
    }
#line 1070
    tmp___109 = n___10;
#line 1070
    n___10 ++;
#line 1070
    bin_freq += (unsigned int )dyn_ltree[tmp___109].fc.freq;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1071
  if (bin_freq > ascii_freq >> 2) {
#line 1071
    *file_type = (ush___4 )0;
  } else {
#line 1071
    *file_type = (ush___4 )1;
  }
#line 1072
  if ((int )*file_type == 0) {

  }
#line 1075
  return;
}
}
#line 18 "unlzh.c"
static unsigned int decode(unsigned int count___2 , uch___5 *buffer ) ;
#line 19
static void decode_start(void) ;
#line 22
static void huf_decode_start(void) ;
#line 23
static unsigned int decode_c(void) ;
#line 24
static unsigned int decode_p(void) ;
#line 25
static void read_pt_len(int nn , int nbit , int i_special ) ;
#line 26
static void read_c_len(void) ;
#line 29
static void fillbuf(int n___11 ) ;
#line 30
static unsigned int getbits(int n___12 ) ;
#line 31
static void init_getbits(void) ;
#line 35
static void make_table(int nchar , uch___5 *bitlen , int tablebits , ush___5 *table ) ;
#line 91 "unlzh.c"
static uch___5 pt_len[19]  ;
#line 92 "unlzh.c"
static unsigned int blocksize  ;
#line 93 "unlzh.c"
static ush___5 pt_table[256]  ;
#line 105 "unlzh.c"
static ush___5 bitbuf  ;
#line 106 "unlzh.c"
static unsigned int subbitbuf  ;
#line 107 "unlzh.c"
static int bitcount  ;
#line 109 "unlzh.c"
static void fillbuf(int n___11 ) 
{ 
  unsigned int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;

  {
#line 112
  bitbuf = (ush___5 )((int )bitbuf << n___11);
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (n___11 > bitcount)) {
#line 113
      goto while_break;
    }
#line 114
    n___11 -= bitcount;
#line 114
    bitbuf = (ush___5 )((unsigned int )bitbuf | (subbitbuf << n___11));
#line 115
    if (inptr < insize) {
#line 115
      tmp___110 = inptr;
#line 115
      inptr ++;
#line 115
      tmp___112 = (int )inbuf[tmp___110];
    } else {
      {
#line 115
      tmp___111 = fill_inbuf(1);
#line 115
      tmp___112 = tmp___111;
      }
    }
#line 115
    subbitbuf = (unsigned int )tmp___112;
#line 116
    if ((int )subbitbuf == -1) {
#line 116
      subbitbuf = 0U;
    }
#line 117
    bitcount = 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  bitcount -= n___11;
#line 119
  bitbuf = (ush___5 )((unsigned int )bitbuf | (subbitbuf >> bitcount));
#line 120
  return;
}
}
#line 122 "unlzh.c"
static unsigned int getbits(int n___12 ) 
{ 
  unsigned int x___0 ;

  {
  {
#line 127
  x___0 = (unsigned int )((int )bitbuf >> (16UL * sizeof(char ) - (unsigned long )n___12));
#line 127
  fillbuf(n___12);
  }
#line 128
  return (x___0);
}
}
#line 131 "unlzh.c"
static void init_getbits(void) 
{ 


  {
  {
#line 133
  bitbuf = (ush___5 )0;
#line 133
  subbitbuf = 0U;
#line 133
  bitcount = 0;
#line 134
  fillbuf((int )(16UL * sizeof(char )));
  }
#line 135
  return;
}
}
#line 141 "unlzh.c"
static void make_table(int nchar , uch___5 *bitlen , int tablebits , ush___5 *table ) 
{ 
  ush___5 count___1[17] ;
  ush___5 weight[17] ;
  ush___5 start[18] ;
  ush___5 *p___1 ;
  unsigned int i___2 ;
  unsigned int k___5 ;
  unsigned int len___0 ;
  unsigned int ch ;
  unsigned int jutbits ;
  unsigned int avail ;
  unsigned int nextcode ;
  unsigned int mask ;
  unsigned int tmp___113 ;
  unsigned short tmp___114 ;
  unsigned int tmp___115 ;

  {
#line 150
  i___2 = 1U;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (i___2 <= 16U)) {
#line 150
      goto while_break;
    }
#line 150
    count___1[i___2] = (ush___5 )0;
#line 150
    i___2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 151
  i___2 = 0U;
  {
#line 151
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 151
    if (! (i___2 < (unsigned int )nchar)) {
#line 151
      goto while_break___0;
    }
#line 151
    count___1[*(bitlen + i___2)] = (ush___5 )((int )count___1[*(bitlen + i___2)] + 1);
#line 151
    i___2 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  start[1] = (ush___5 )0;
#line 154
  i___2 = 1U;
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 154
    if (! (i___2 <= 16U)) {
#line 154
      goto while_break___1;
    }
#line 155
    start[i___2 + 1U] = (ush___5 )((int )start[i___2] + ((int )count___1[i___2] << (16U - i___2)));
#line 154
    i___2 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 156
  if (((int )start[17] & 65535) != 0) {
    {
#line 157
    error((char *)"Bad table\n");
    }
  }
#line 159
  jutbits = (unsigned int )(16 - tablebits);
#line 160
  i___2 = 1U;
  {
#line 160
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 160
    if (! (i___2 <= (unsigned int )tablebits)) {
#line 160
      goto while_break___2;
    }
#line 161
    start[i___2] = (ush___5 )((int )start[i___2] >> jutbits);
#line 162
    weight[i___2] = (ush___5 )(1U << ((unsigned int )tablebits - i___2));
#line 160
    i___2 ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 164
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 164
    if (! (i___2 <= 16U)) {
#line 164
      goto while_break___3;
    }
#line 165
    weight[i___2] = (ush___5 )(1U << (16U - i___2));
#line 166
    i___2 ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 169
  i___2 = (unsigned int )((int )start[tablebits + 1] >> jutbits);
#line 170
  if (i___2 != 0U) {
#line 171
    k___5 = (unsigned int )(1 << tablebits);
    {
#line 172
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 172
      if (! (i___2 != k___5)) {
#line 172
        goto while_break___4;
      }
#line 172
      tmp___113 = i___2;
#line 172
      i___2 ++;
#line 172
      *(table + tmp___113) = (ush___5 )0;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 175
  avail = (unsigned int )nchar;
#line 176
  mask = 1U << (15 - tablebits);
#line 177
  ch = 0U;
  {
#line 177
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 177
    if (! (ch < (unsigned int )nchar)) {
#line 177
      goto while_break___5;
    }
#line 178
    len___0 = (unsigned int )*(bitlen + ch);
#line 178
    if (len___0 == 0U) {
#line 178
      goto __Cont___3;
    }
#line 179
    nextcode = (unsigned int )((int )start[len___0] + (int )weight[len___0]);
#line 180
    if (len___0 <= (unsigned int )tablebits) {
#line 181
      i___2 = (unsigned int )start[len___0];
      {
#line 181
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 181
        if (! (i___2 < nextcode)) {
#line 181
          goto while_break___6;
        }
#line 181
        *(table + i___2) = (ush___5 )ch;
#line 181
        i___2 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else {
#line 183
      k___5 = (unsigned int )start[len___0];
#line 184
      p___1 = table + (k___5 >> jutbits);
#line 185
      i___2 = len___0 - (unsigned int )tablebits;
      {
#line 186
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 186
        if (! (i___2 != 0U)) {
#line 186
          goto while_break___7;
        }
#line 187
        if ((int )*p___1 == 0) {
#line 188
          tmp___114 = (unsigned short)0;
#line 188
          prev[avail] = tmp___114;
#line 188
          *((prev + 32768) + avail) = tmp___114;
#line 189
          tmp___115 = avail;
#line 189
          avail ++;
#line 189
          *p___1 = (ush___5 )tmp___115;
        }
#line 191
        if (k___5 & mask) {
#line 191
          p___1 = (prev + 32768) + *p___1;
        } else {
#line 192
          p___1 = & prev[*p___1];
        }
#line 193
        k___5 <<= 1;
#line 193
        i___2 --;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 195
      *p___1 = (ush___5 )ch;
    }
#line 197
    start[len___0] = (ush___5 )nextcode;
    __Cont___3: /* CIL Label */ 
#line 177
    ch ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 199
  return;
}
}
#line 205 "unlzh.c"
static void read_pt_len(int nn , int nbit , int i_special ) 
{ 
  int i___3 ;
  int c___0 ;
  int n___13 ;
  unsigned int mask___0 ;
  unsigned int tmp___116 ;
  unsigned int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  unsigned int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;

  {
  {
#line 213
  tmp___116 = getbits(nbit);
#line 213
  n___13 = (int )tmp___116;
  }
#line 214
  if (n___13 == 0) {
    {
#line 215
    tmp___117 = getbits(nbit);
#line 215
    c___0 = (int )tmp___117;
#line 216
    i___3 = 0;
    }
    {
#line 216
    while (1) {
      while_continue: /* CIL Label */ ;
#line 216
      if (! (i___3 < nn)) {
#line 216
        goto while_break;
      }
#line 216
      pt_len[i___3] = (uch___5 )0;
#line 216
      i___3 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 217
    i___3 = 0;
    {
#line 217
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 217
      if (! (i___3 < 256)) {
#line 217
        goto while_break___0;
      }
#line 217
      pt_table[i___3] = (ush___5 )c___0;
#line 217
      i___3 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 219
    i___3 = 0;
    {
#line 220
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 220
      if (! (i___3 < n___13)) {
#line 220
        goto while_break___1;
      }
#line 221
      c___0 = (int )bitbuf >> (16UL * sizeof(char ) - 3UL);
#line 222
      if (c___0 == 7) {
#line 223
        mask___0 = 1U << ((16UL * sizeof(char ) - 1UL) - 3UL);
        {
#line 224
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 224
          if (! (mask___0 & (unsigned int )bitbuf)) {
#line 224
            goto while_break___2;
          }
#line 224
          mask___0 >>= 1;
#line 224
          c___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 226
      if (c___0 < 7) {
#line 226
        tmp___118 = 3;
      } else {
#line 226
        tmp___118 = c___0 - 3;
      }
      {
#line 226
      fillbuf(tmp___118);
#line 227
      tmp___119 = i___3;
#line 227
      i___3 ++;
#line 227
      pt_len[tmp___119] = (uch___5 )c___0;
      }
#line 228
      if (i___3 == i_special) {
        {
#line 229
        tmp___120 = getbits(2);
#line 229
        c___0 = (int )tmp___120;
        }
        {
#line 230
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 230
          c___0 --;
#line 230
          if (! (c___0 >= 0)) {
#line 230
            goto while_break___3;
          }
#line 230
          tmp___121 = i___3;
#line 230
          i___3 ++;
#line 230
          pt_len[tmp___121] = (uch___5 )0;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 233
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 233
      if (! (i___3 < nn)) {
#line 233
        goto while_break___4;
      }
#line 233
      tmp___122 = i___3;
#line 233
      i___3 ++;
#line 233
      pt_len[tmp___122] = (uch___5 )0;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 234
    make_table(nn, pt_len, 8, pt_table);
    }
  }
#line 236
  return;
}
}
#line 238 "unlzh.c"
static void read_c_len(void) 
{ 
  int i___4 ;
  int c___1 ;
  int n___14 ;
  unsigned int mask___1 ;
  unsigned int tmp___123 ;
  unsigned int tmp___124 ;
  unsigned int tmp___125 ;
  unsigned int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;

  {
  {
#line 243
  tmp___123 = getbits(9);
#line 243
  n___14 = (int )tmp___123;
  }
#line 244
  if (n___14 == 0) {
    {
#line 245
    tmp___124 = getbits(9);
#line 245
    c___1 = (int )tmp___124;
#line 246
    i___4 = 0;
    }
    {
#line 246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 246
      if (! (i___4 < 510)) {
#line 246
        goto while_break;
      }
#line 246
      outbuf[i___4] = (unsigned char)0;
#line 246
      i___4 ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 247
    i___4 = 0;
    {
#line 247
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 247
      if (! (i___4 < 4096)) {
#line 247
        goto while_break___0;
      }
#line 247
      d_buf[i___4] = (unsigned short )c___1;
#line 247
      i___4 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 249
    i___4 = 0;
    {
#line 250
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 250
      if (! (i___4 < n___14)) {
#line 250
        goto while_break___1;
      }
#line 251
      c___1 = (int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
#line 252
      if (c___1 >= 19) {
#line 253
        mask___1 = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
        {
#line 254
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 255
          if ((unsigned int )bitbuf & mask___1) {
#line 255
            c___1 = (int )*((prev + 32768) + c___1);
          } else {
#line 256
            c___1 = (int )prev[c___1];
          }
#line 257
          mask___1 >>= 1;
#line 254
          if (! (c___1 >= 19)) {
#line 254
            goto while_break___2;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
      {
#line 260
      fillbuf((int )pt_len[c___1]);
      }
#line 261
      if (c___1 <= 2) {
#line 262
        if (c___1 == 0) {
#line 262
          c___1 = 1;
        } else
#line 263
        if (c___1 == 1) {
          {
#line 263
          tmp___125 = getbits(4);
#line 263
          c___1 = (int )(tmp___125 + 3U);
          }
        } else {
          {
#line 264
          tmp___126 = getbits(9);
#line 264
          c___1 = (int )(tmp___126 + 20U);
          }
        }
        {
#line 265
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 265
          c___1 --;
#line 265
          if (! (c___1 >= 0)) {
#line 265
            goto while_break___3;
          }
#line 265
          tmp___127 = i___4;
#line 265
          i___4 ++;
#line 265
          outbuf[tmp___127] = (unsigned char)0;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 266
        tmp___128 = i___4;
#line 266
        i___4 ++;
#line 266
        outbuf[tmp___128] = (unsigned char )(c___1 - 2);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 268
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 268
      if (! (i___4 < 510)) {
#line 268
        goto while_break___4;
      }
#line 268
      tmp___129 = i___4;
#line 268
      i___4 ++;
#line 268
      outbuf[tmp___129] = (unsigned char)0;
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 269
    make_table(510, outbuf, 12, d_buf);
    }
  }
#line 271
  return;
}
}
#line 273 "unlzh.c"
static unsigned int decode_c(void) 
{ 
  unsigned int j___2 ;
  unsigned int mask___2 ;

  {
#line 277
  if (blocksize == 0U) {
    {
#line 278
    blocksize = getbits(16);
    }
#line 279
    if (blocksize == 0U) {
#line 280
      return (510U);
    }
    {
#line 282
    read_pt_len(19, 5, 3);
#line 283
    read_c_len();
#line 284
    read_pt_len(14, 4, -1);
    }
  }
#line 286
  blocksize --;
#line 287
  j___2 = (unsigned int )d_buf[(int )bitbuf >> (16UL * sizeof(char ) - 12UL)];
#line 288
  if (j___2 >= 510U) {
#line 289
    mask___2 = 1U << ((16UL * sizeof(char ) - 1UL) - 12UL);
    {
#line 290
    while (1) {
      while_continue: /* CIL Label */ ;
#line 291
      if ((unsigned int )bitbuf & mask___2) {
#line 291
        j___2 = (unsigned int )*((prev + 32768) + j___2);
      } else {
#line 292
        j___2 = (unsigned int )prev[j___2];
      }
#line 293
      mask___2 >>= 1;
#line 290
      if (! (j___2 >= 510U)) {
#line 290
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 296
  fillbuf((int )outbuf[j___2]);
  }
#line 297
  return (j___2);
}
}
#line 300 "unlzh.c"
static unsigned int decode_p(void) 
{ 
  unsigned int j___3 ;
  unsigned int mask___3 ;
  unsigned int tmp___130 ;

  {
#line 304
  j___3 = (unsigned int )pt_table[(int )bitbuf >> (16UL * sizeof(char ) - 8UL)];
#line 305
  if (j___3 >= 14U) {
#line 306
    mask___3 = 1U << ((16UL * sizeof(char ) - 1UL) - 8UL);
    {
#line 307
    while (1) {
      while_continue: /* CIL Label */ ;
#line 308
      if ((unsigned int )bitbuf & mask___3) {
#line 308
        j___3 = (unsigned int )*((prev + 32768) + j___3);
      } else {
#line 309
        j___3 = (unsigned int )prev[j___3];
      }
#line 310
      mask___3 >>= 1;
#line 307
      if (! (j___3 >= 14U)) {
#line 307
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 313
  fillbuf((int )pt_len[j___3]);
  }
#line 314
  if (j___3 != 0U) {
    {
#line 314
    tmp___130 = getbits((int )(j___3 - 1U));
#line 314
    j___3 = (1U << (j___3 - 1U)) + tmp___130;
    }
  }
#line 315
  return (j___3);
}
}
#line 318 "unlzh.c"
static void huf_decode_start(void) 
{ 


  {
  {
#line 320
  init_getbits();
#line 320
  blocksize = 0U;
  }
#line 321
  return;
}
}
#line 327
__asm__("booo - error in global j (unlzh.c:327)");
#line 328 "unlzh.c"
static int done  ;
#line 330 "unlzh.c"
static void decode_start(void) 
{ 


  {
  {
#line 332
  huf_decode_start();
#line 333
  __asm__  ("booo_exp(unlzh.c:333)":);
#line 334
  done = 0;
  }
#line 335
  return;
}
}
#line 351 "unlzh.c"
static unsigned int i___5  ;
#line 339 "unlzh.c"
static unsigned int decode(unsigned int count___2 , uch___5 *buffer ) 
{ 
  unsigned int r___1 ;
  unsigned int c___2 ;
  unsigned int tmp___131 ;

  {
#line 354
  r___1 = 0U;
  {
#line 355
  while (1) {
    while_continue: /* CIL Label */ ;
#line 355
    __asm__  ("booo_exp(unlzh.c:355)":);
#line 356
    *(buffer + r___1) = *(buffer + i___5);
#line 357
    i___5 = (i___5 + 1U) & ((1U << 13) - 1U);
#line 358
    r___1 ++;
#line 358
    if (r___1 == count___2) {
#line 358
      return (r___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 361
    c___2 = decode_c();
    }
#line 362
    if (c___2 == 510U) {
#line 363
      done = 1;
#line 364
      return (r___1);
    }
#line 366
    if (c___2 <= 255U) {
#line 367
      *(buffer + r___1) = (uch___5 )c___2;
#line 368
      r___1 ++;
#line 368
      if (r___1 == count___2) {
#line 368
        return (r___1);
      }
    } else {
      {
#line 370
      __asm__  ("booo_exp(unlzh.c:370)":);
#line 371
      tmp___131 = decode_p();
#line 371
      i___5 = ((r___1 - tmp___131) - 1U) & ((1U << 13) - 1U);
      }
      {
#line 372
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 372
        __asm__  ("booo_exp(unlzh.c:372)":);
#line 373
        *(buffer + r___1) = *(buffer + i___5);
#line 374
        i___5 = (i___5 + 1U) & ((1U << 13) - 1U);
#line 375
        r___1 ++;
#line 375
        if (r___1 == count___2) {
#line 375
          return (r___1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 385 "unlzh.c"
int unlzh(int in___0 , int out___0 ) 
{ 
  unsigned int n___15 ;

  {
  {
#line 390
  ifd = in___0;
#line 391
  ofd = out___0;
#line 393
  decode_start();
  }
  {
#line 394
  while (1) {
    while_continue: /* CIL Label */ ;
#line 394
    if (! (! done)) {
#line 394
      goto while_break;
    }
    {
#line 395
    n___15 = decode(1U << 13, window);
    }
#line 396
    if (! test) {
#line 396
      if (n___15 > 0U) {
        {
#line 397
        write_buf(out___0, (void *)((char *)(window)), n___15);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (0);
}
}
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__asm__("error in function __bswap_32");
#line 108
__asm__("error in function __bswap_64");
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__asm__("error in function __uint16_identity");
#line 38
__asm__("error in function __uint32_identity");
#line 44
__asm__("error in function __uint64_identity");
#line 181 "unlzw.c"
int block_mode  =    128;
#line 192 "unlzw.c"
int unlzw(int in___1 , int out___1 ) 
{ 
  register char_type *stackp ;
  code_int code___2 ;
  int finchar ;
  code_int oldcode ;
  code_int incode ;
  long inbits ;
  long posbits ;
  int outpos ;
  unsigned int bitmask ;
  code_int free_ent ;
  code_int maxcode ;
  code_int maxmaxcode ;
  int n_bits ;
  int rsize ;
  unsigned int tmp___132 ;
  int tmp___133 ;
  register int i___6 ;
  int e___3 ;
  int o ;
  register char_type *p___2 ;
  int tmp___134 ;
  char const   *tmp___135 ;
  register int i___7 ;

  {
#line 215
  if (inptr < insize) {
#line 215
    tmp___132 = inptr;
#line 215
    inptr ++;
#line 215
    maxbits = (int )inbuf[tmp___132];
  } else {
    {
#line 215
    tmp___133 = fill_inbuf(0);
#line 215
    maxbits = tmp___133;
    }
  }
#line 216
  block_mode = maxbits & 128;
#line 217
  if ((maxbits & 96) != 0) {
#line 218
    if (! quiet) {
      {
#line 218
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: warning, unknown flags 0x%x\n",
              progname, ifname, maxbits & 96);
      }
    }
#line 218
    if (exit_code == 0) {
#line 218
      exit_code = 2;
    }
  }
#line 221
  maxbits &= 31;
#line 222
  maxmaxcode = 1L << maxbits;
#line 224
  if (maxbits > 16) {
    {
#line 225
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: compressed with %d bits, can only handle %d bits\n",
            progname, ifname, maxbits, 16);
#line 228
    exit_code = 1;
    }
#line 229
    return (1);
  }
#line 231
  rsize = (int )insize;
#line 232
  n_bits = 9;
#line 232
  maxcode = (1L << n_bits) - 1L;
#line 233
  bitmask = (unsigned int )((1 << n_bits) - 1);
#line 234
  oldcode = (code_int )-1;
#line 235
  finchar = 0;
#line 236
  outpos = 0;
#line 237
  posbits = (long )(inptr << 3);
#line 239
  if (block_mode) {
#line 239
    free_ent = (code_int )257;
  } else {
#line 239
    free_ent = (code_int )256;
  }
  {
#line 241
  memset((voidp___6 )(prev), 0, 256UL);
#line 243
  code___2 = (code_int )255;
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (code___2 >= 0L)) {
#line 243
      goto while_break;
    }
#line 244
    window[code___2] = (char_type )code___2;
#line 243
    code___2 --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
    resetbuf: 
#line 252
    o = (int )(posbits >> 3);
#line 252
    e___3 = (int )(insize - (unsigned int )o);
#line 254
    i___6 = 0;
    {
#line 254
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 254
      if (! (i___6 < e___3)) {
#line 254
        goto while_break___1;
      }
#line 255
      inbuf[i___6] = inbuf[i___6 + o];
#line 254
      i___6 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 257
    insize = (unsigned int )e___3;
#line 258
    posbits = 0L;
#line 260
    if (insize < 64U) {
      {
#line 261
      rsize = read(in___1, (char *)(inbuf) + insize, 32768);
      }
#line 261
      if (rsize == -1) {
        {
#line 262
        read_error();
        }
      }
#line 264
      insize += (unsigned int )rsize;
#line 265
      bytes_in = (long )((ulg___6 )bytes_in + (ulg___6 )rsize);
    }
#line 267
    if (rsize != 0) {
#line 267
      inbits = ((long )insize - (long )(insize % (unsigned int )n_bits)) << 3;
    } else {
#line 267
      inbits = ((long )insize << 3) - (long )(n_bits - 1);
    }
    {
#line 270
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 270
      if (! (inbits > posbits)) {
#line 270
        goto while_break___2;
      }
#line 271
      if (free_ent > maxcode) {
#line 272
        posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 274
        n_bits ++;
#line 275
        if (n_bits == maxbits) {
#line 276
          maxcode = maxmaxcode;
        } else {
#line 278
          maxcode = (1L << n_bits) - 1L;
        }
#line 280
        bitmask = (unsigned int )((1 << n_bits) - 1);
#line 281
        goto resetbuf;
      }
#line 283
      p___2 = & inbuf[posbits >> 3];
#line 283
      code___2 = ((((long )*(p___2 + 0) | ((long )*(p___2 + 1) << 8)) | ((long )*(p___2 + 2) << 16)) >> (posbits & 7L)) & (long )bitmask;
#line 283
      posbits += (long )n_bits;
#line 286
      if (oldcode == -1L) {
#line 287
        if (code___2 >= 256L) {
          {
#line 287
          error((char *)"corrupt input.");
          }
        }
#line 288
        tmp___134 = outpos;
#line 288
        outpos ++;
#line 288
        oldcode = code___2;
#line 288
        finchar = (int )oldcode;
#line 288
        outbuf[tmp___134] = (char_type )finchar;
#line 289
        goto while_continue___2;
      }
#line 291
      if (code___2 == 256L) {
#line 291
        if (block_mode) {
          {
#line 292
          memset((voidp___6 )(prev), 0, 256UL);
#line 293
          free_ent = (code_int )256;
#line 294
          posbits = (posbits - 1L) + ((long )(n_bits << 3) - ((posbits - 1L) + (long )(n_bits << 3)) % (long )(n_bits << 3));
#line 296
          n_bits = 9;
#line 296
          maxcode = (1L << n_bits) - 1L;
#line 297
          bitmask = (unsigned int )((1 << n_bits) - 1);
          }
#line 298
          goto resetbuf;
        }
      }
#line 300
      incode = code___2;
#line 301
      stackp = (char_type *)(& d_buf[32767]);
#line 303
      if (code___2 >= free_ent) {
#line 304
        if (code___2 > free_ent) {
#line 317
          if (! test) {
#line 317
            if (outpos > 0) {
              {
#line 318
              write_buf(out___1, (void *)((char *)(outbuf)), (unsigned int )outpos);
#line 319
              bytes_out = (long )((ulg___6 )bytes_out + (ulg___6 )outpos);
              }
            }
          }
#line 321
          if (to_stdout) {
#line 321
            tmp___135 = "corrupt input.";
          } else {
#line 321
            tmp___135 = "corrupt input. Use zcat to recover some data.";
          }
          {
#line 321
          error((char *)tmp___135);
          }
        }
#line 324
        stackp --;
#line 324
        *stackp = (char_type )finchar;
#line 325
        code___2 = oldcode;
      }
      {
#line 328
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 328
        if (! ((cmp_code_int )code___2 >= 256UL)) {
#line 328
          goto while_break___3;
        }
#line 330
        stackp --;
#line 330
        *stackp = window[code___2];
#line 331
        code___2 = (code_int )prev[code___2];
      }
      while_break___3: /* CIL Label */ ;
      }
#line 333
      stackp --;
#line 333
      finchar = (int )window[code___2];
#line 333
      *stackp = (char_type )finchar;
#line 339
      i___7 = (int )((char_type *)(& d_buf[32767]) - stackp);
#line 339
      if (outpos + i___7 >= 16384) {
        {
#line 340
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 341
          if (i___7 > 16384 - outpos) {
#line 341
            i___7 = 16384 - outpos;
          }
#line 343
          if (i___7 > 0) {
            {
#line 344
            memcpy((void */* __restrict  */)(outbuf + outpos), (void const   */* __restrict  */)stackp,
                   (unsigned long )i___7);
#line 345
            outpos += i___7;
            }
          }
#line 347
          if (outpos >= 16384) {
#line 348
            if (! test) {
              {
#line 349
              write_buf(out___1, (void *)((char *)(outbuf)), (unsigned int )outpos);
#line 350
              bytes_out = (long )((ulg___6 )bytes_out + (ulg___6 )outpos);
              }
            }
#line 352
            outpos = 0;
          }
#line 354
          stackp += i___7;
#line 340
          i___7 = (int )((char_type *)(& d_buf[32767]) - stackp);
#line 340
          if (! (i___7 > 0)) {
#line 340
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
      } else {
        {
#line 357
        memcpy((void */* __restrict  */)(outbuf + outpos), (void const   */* __restrict  */)stackp,
               (unsigned long )i___7);
#line 358
        outpos += i___7;
        }
      }
#line 362
      code___2 = free_ent;
#line 362
      if (code___2 < maxmaxcode) {
#line 364
        prev[code___2] = (unsigned short )oldcode;
#line 365
        window[code___2] = (char_type )finchar;
#line 366
        free_ent = code___2 + 1L;
      }
#line 368
      oldcode = incode;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 246
    if (! (rsize != 0)) {
#line 246
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  if (! test) {
#line 372
    if (outpos > 0) {
      {
#line 373
      write_buf(out___1, (void *)((char *)(outbuf)), (unsigned int )outpos);
#line 374
      bytes_out = (long )((ulg___6 )bytes_out + (ulg___6 )outpos);
      }
    }
  }
#line 376
  return (0);
}
}
#line 32 "unpack.c"
static ulg___7 orig_len  ;
#line 33 "unpack.c"
static int max_len  ;
#line 35 "unpack.c"
static uch___7 literal[256]  ;
#line 40 "unpack.c"
static int lit_base[26]  ;
#line 46 "unpack.c"
static int leaves[26]  ;
#line 47 "unpack.c"
static int parents[26]  ;
#line 49 "unpack.c"
static int peek_bits  ;
#line 64
__asm__("booo - error in global bitbuf (unpack.c:64)");
#line 67 "unpack.c"
static int valid  ;
#line 88
static void read_tree(void) ;
#line 89
__asm__("booo - error in global build_tree (unpack.c:89)");
#line 94 "unpack.c"
static void read_tree(void) 
{ 
  int len___1 ;
  int base___0 ;
  int n___16 ;
  unsigned int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  unsigned int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  unsigned int tmp___142 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  unsigned int tmp___146 ;
  int tmp___147 ;
  int tmp___148 ;

  {
#line 101
  orig_len = (ulg___7 )0;
#line 102
  n___16 = 1;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (n___16 <= 4)) {
#line 102
      goto while_break;
    }
#line 102
    if (inptr < insize) {
#line 102
      tmp___136 = inptr;
#line 102
      inptr ++;
#line 102
      tmp___138 = (int )inbuf[tmp___136];
    } else {
      {
#line 102
      tmp___137 = fill_inbuf(0);
#line 102
      tmp___138 = tmp___137;
      }
    }
#line 102
    orig_len = (orig_len << 8) | (ulg___7 )tmp___138;
#line 102
    n___16 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  if (inptr < insize) {
#line 104
    tmp___139 = inptr;
#line 104
    inptr ++;
#line 104
    tmp___141 = (int )inbuf[tmp___139];
  } else {
    {
#line 104
    tmp___140 = fill_inbuf(0);
#line 104
    tmp___141 = tmp___140;
    }
  }
#line 104
  max_len = tmp___141;
#line 105
  if (max_len > 25) {
    {
#line 106
    error((char *)"invalid compressed data -- Huffman code > 32 bits");
    }
  }
#line 110
  n___16 = 0;
#line 111
  len___1 = 1;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! (len___1 <= max_len)) {
#line 111
      goto while_break___0;
    }
#line 112
    if (inptr < insize) {
#line 112
      tmp___142 = inptr;
#line 112
      inptr ++;
#line 112
      tmp___144 = (int )inbuf[tmp___142];
    } else {
      {
#line 112
      tmp___143 = fill_inbuf(0);
#line 112
      tmp___144 = tmp___143;
      }
    }
#line 112
    leaves[len___1] = tmp___144;
#line 113
    n___16 += leaves[len___1];
#line 111
    len___1 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 115
  if (n___16 > 256) {
    {
#line 116
    error((char *)"too many leaves in Huffman tree");
    }
  }
#line 127
  (leaves[max_len]) ++;
#line 130
  base___0 = 0;
#line 131
  len___1 = 1;
  {
#line 131
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 131
    if (! (len___1 <= max_len)) {
#line 131
      goto while_break___1;
    }
#line 133
    lit_base[len___1] = base___0;
#line 135
    n___16 = leaves[len___1];
    {
#line 135
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 135
      if (! (n___16 > 0)) {
#line 135
        goto while_break___2;
      }
#line 136
      tmp___145 = base___0;
#line 136
      base___0 ++;
#line 136
      if (inptr < insize) {
#line 136
        tmp___146 = inptr;
#line 136
        inptr ++;
#line 136
        tmp___148 = (int )inbuf[tmp___146];
      } else {
        {
#line 136
        tmp___147 = fill_inbuf(0);
#line 136
        tmp___148 = tmp___147;
        }
      }
#line 136
      literal[tmp___145] = (uch___7 )tmp___148;
#line 135
      n___16 --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 131
    len___1 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 139
  (leaves[max_len]) ++;
#line 140
  return;
}
}
#line 145
__asm__("error in function build_tree");
#line 185 "unpack.c"
int unpack(int in___2 , int out___2 ) 
{ 
  int len___2 ;
  unsigned int eob ;
  register unsigned int peek ;
  unsigned int peek_mask ;
  unsigned int tmp___149 ;
  int tmp___150 ;
  int tmp___151 ;
  ulg___7 mask___4 ;
  unsigned int tmp___152 ;
  int tmp___153 ;
  int tmp___154 ;
  unsigned int tmp___155 ;

  {
  {
#line 193
  ifd = in___2;
#line 194
  ofd = out___2;
#line 196
  read_tree();
#line 197
  build_tree();
#line 198
  valid = 0;
#line 198
  bitbuf = (ush___5 )0;
#line 199
  peek_mask = (unsigned int )((1 << peek_bits) - 1);
#line 202
  eob = (unsigned int )(leaves[max_len] - 1);
  }
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (valid < peek_bits)) {
#line 211
        goto while_break___0;
      }
#line 211
      if (inptr < insize) {
#line 211
        tmp___149 = inptr;
#line 211
        inptr ++;
#line 211
        tmp___151 = (int )inbuf[tmp___149];
      } else {
        {
#line 211
        tmp___150 = fill_inbuf(0);
#line 211
        tmp___151 = tmp___150;
        }
      }
#line 211
      bitbuf = (ush___5 )((unsigned long )((int )bitbuf << 8) | (ulg___7 )tmp___151);
#line 211
      valid += 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 211
    peek = (unsigned int )((int )bitbuf >> (valid - peek_bits)) & peek_mask;
#line 212
    len___2 = (int )outbuf[peek];
#line 213
    if (len___2 > 0) {
#line 214
      peek >>= peek_bits - len___2;
    } else {
#line 217
      mask___4 = (ulg___7 )peek_mask;
#line 218
      len___2 = peek_bits;
      {
#line 219
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 220
        len___2 ++;
#line 220
        mask___4 = (mask___4 << 1) + 1UL;
        {
#line 221
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 221
          if (! (valid < len___2)) {
#line 221
            goto while_break___2;
          }
#line 221
          if (inptr < insize) {
#line 221
            tmp___152 = inptr;
#line 221
            inptr ++;
#line 221
            tmp___154 = (int )inbuf[tmp___152];
          } else {
            {
#line 221
            tmp___153 = fill_inbuf(0);
#line 221
            tmp___154 = tmp___153;
            }
          }
#line 221
          bitbuf = (ush___5 )((unsigned long )((int )bitbuf << 8) | (ulg___7 )tmp___154);
#line 221
          valid += 8;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 221
        peek = (unsigned int )((unsigned long )((int )bitbuf >> (valid - len___2)) & mask___4);
#line 219
        if (! (peek < (unsigned int )parents[len___2])) {
#line 219
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 226
    if (peek == eob) {
#line 226
      if (len___2 == max_len) {
#line 226
        goto while_break;
      }
    }
#line 227
    tmp___155 = outcnt;
#line 227
    outcnt ++;
#line 227
    window[tmp___155] = literal[peek + (unsigned int )lit_base[len___2]];
#line 227
    if (outcnt == 32768U) {
      {
#line 227
      flush_window();
      }
    }
#line 230
    valid -= len___2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 233
  flush_window();
  }
#line 235
  if (orig_len != (ulg___7 )bytes_out) {
    {
#line 236
    error((char *)"invalid compressed data--length error");
    }
  }
#line 238
  return (0);
}
}
#line 43 "unzip.c"
char *key  ;
#line 44 "unzip.c"
int pkzip  =    0;
#line 45 "unzip.c"
int ext_header  =    0;
#line 51 "unzip.c"
int check_zipfile(int in___3 ) 
{ 
  uch___8 *h___2 ;

  {
#line 54
  h___2 = inbuf + inptr;
#line 56
  ifd = in___3;
#line 59
  inptr += (unsigned int )((30 + ((int )((ush___8 )*((h___2 + 26) + 0)) | ((int )((ush___8 )*((h___2 + 26) + 1)) << 8))) + ((int )((ush___8 )*((h___2 + 28) + 0)) | ((int )((ush___8 )*((h___2 + 28) + 1)) << 8)));
#line 61
  if (inptr > insize) {
    {
#line 62
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not a valid zip file\n",
            progname, ifname);
#line 64
    exit_code = 1;
    }
#line 65
    return (1);
  } else
#line 61
  if (((ulg___8 )((int )((ush___8 )*(h___2 + 0)) | ((int )((ush___8 )*(h___2 + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*((h___2 + 2) + 0)) | ((int )((ush___8 )*((h___2 + 2) + 1)) << 8)) << 16)) != 67324752UL) {
    {
#line 62
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: not a valid zip file\n",
            progname, ifname);
#line 64
    exit_code = 1;
    }
#line 65
    return (1);
  }
#line 67
  method = (int )*(h___2 + 8);
#line 68
  if (method != 0) {
#line 68
    if (method != 8) {
      {
#line 69
      fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: first entry not deflated or stored -- use unzip\n",
              progname, ifname);
#line 72
      exit_code = 1;
      }
#line 73
      return (1);
    }
  }
#line 77
  decrypt = (int )*(h___2 + 6) & 1;
#line 77
  if (decrypt != 0) {
    {
#line 78
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: encrypted file -- use unzip\n",
            progname, ifname);
#line 80
    exit_code = 1;
    }
#line 81
    return (1);
  }
#line 85
  ext_header = ((int )*(h___2 + 6) & 8) != 0;
#line 86
  pkzip = 1;
#line 89
  return (0);
}
}
#line 99 "unzip.c"
int unzip(int in___4 , int out___3 ) 
{ 
  ulg___8 orig_crc ;
  ulg___8 orig_len___0 ;
  int n___17 ;
  uch___8 buf___0[16] ;
  int res ;
  int tmp___156 ;
  register ulg___8 n___18 ;
  int tmp___157 ;
  uch___8 c___3 ;
  unsigned int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  unsigned int tmp___161 ;
  ulg___8 tmp___162 ;
  unsigned int tmp___163 ;
  int tmp___164 ;
  int tmp___165 ;
  unsigned int tmp___166 ;
  int tmp___167 ;
  int tmp___168 ;
  unsigned long tmp___169 ;

  {
  {
#line 102
  orig_crc = (ulg___8 )0;
#line 103
  orig_len___0 = (ulg___8 )0;
#line 107
  ifd = in___4;
#line 108
  ofd = out___3;
#line 110
  updcrc((unsigned char *)((void *)0), 0U);
  }
#line 112
  if (pkzip) {
#line 112
    if (! ext_header) {
#line 113
      orig_crc = (ulg___8 )((int )((ush___8 )*((inbuf + 14) + 0)) | ((int )((ush___8 )*((inbuf + 14) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((inbuf + 14) + 2) + 0)) | ((int )((ush___8 )*(((inbuf + 14) + 2) + 1)) << 8)) << 16);
#line 114
      orig_len___0 = (ulg___8 )((int )((ush___8 )*((inbuf + 22) + 0)) | ((int )((ush___8 )*((inbuf + 22) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((inbuf + 22) + 2) + 0)) | ((int )((ush___8 )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
    }
  }
#line 118
  if (method == 8) {
    {
#line 120
    tmp___156 = inflate();
#line 120
    res = tmp___156;
    }
#line 122
    if (res == 3) {
      {
#line 123
      error((char *)"out of memory");
      }
    } else
#line 124
    if (res != 0) {
      {
#line 125
      error((char *)"invalid compressed data--format violated");
      }
    }
  } else
#line 128
  if (pkzip) {
#line 128
    if (method == 0) {
#line 130
      n___18 = (ulg___8 )((int )((ush___8 )*((inbuf + 22) + 0)) | ((int )((ush___8 )*((inbuf + 22) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((inbuf + 22) + 2) + 0)) | ((int )((ush___8 )*(((inbuf + 22) + 2) + 1)) << 8)) << 16);
#line 132
      if (decrypt) {
#line 132
        tmp___157 = 12;
      } else {
#line 132
        tmp___157 = 0;
      }
#line 132
      if (n___18 != ((ulg___8 )((int )((ush___8 )*((inbuf + 18) + 0)) | ((int )((ush___8 )*((inbuf + 18) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((inbuf + 18) + 2) + 0)) | ((int )((ush___8 )*(((inbuf + 18) + 2) + 1)) << 8)) << 16)) - (unsigned long )tmp___157) {
        {
#line 134
        fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"len %ld, siz %ld\n",
                n___18, (ulg___8 )((int )((ush___8 )*((inbuf + 18) + 0)) | ((int )((ush___8 )*((inbuf + 18) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((inbuf + 18) + 2) + 0)) | ((int )((ush___8 )*(((inbuf + 18) + 2) + 1)) << 8)) << 16));
#line 135
        error((char *)"invalid compressed data--length mismatch");
        }
      }
      {
#line 137
      while (1) {
        while_continue: /* CIL Label */ ;
#line 137
        tmp___162 = n___18;
#line 137
        n___18 --;
#line 137
        if (! tmp___162) {
#line 137
          goto while_break;
        }
#line 138
        if (inptr < insize) {
#line 138
          tmp___158 = inptr;
#line 138
          inptr ++;
#line 138
          tmp___160 = (int )inbuf[tmp___158];
        } else {
          {
#line 138
          tmp___159 = fill_inbuf(0);
#line 138
          tmp___160 = tmp___159;
          }
        }
#line 138
        c___3 = (uch___8 )tmp___160;
#line 142
        tmp___161 = outcnt;
#line 142
        outcnt ++;
#line 142
        window[tmp___161] = c___3;
#line 142
        if (outcnt == 32768U) {
          {
#line 142
          flush_window();
          }
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 144
      flush_window();
      }
    } else {
      {
#line 146
      error((char *)"internal error, invalid method");
      }
    }
  } else {
    {
#line 146
    error((char *)"internal error, invalid method");
    }
  }
#line 150
  if (! pkzip) {
#line 154
    n___17 = 0;
    {
#line 154
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 154
      if (! (n___17 < 8)) {
#line 154
        goto while_break___0;
      }
#line 155
      if (inptr < insize) {
#line 155
        tmp___163 = inptr;
#line 155
        inptr ++;
#line 155
        tmp___165 = (int )inbuf[tmp___163];
      } else {
        {
#line 155
        tmp___164 = fill_inbuf(0);
#line 155
        tmp___165 = tmp___164;
        }
      }
#line 155
      buf___0[n___17] = (uch___8 )tmp___165;
#line 154
      n___17 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 157
    orig_crc = (ulg___8 )((int )((ush___8 )buf___0[0]) | ((int )((ush___8 )buf___0[1]) << 8)) | ((ulg___8 )((int )((ush___8 )*((buf___0 + 2) + 0)) | ((int )((ush___8 )*((buf___0 + 2) + 1)) << 8)) << 16);
#line 158
    orig_len___0 = (ulg___8 )((int )((ush___8 )*((buf___0 + 4) + 0)) | ((int )((ush___8 )*((buf___0 + 4) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((buf___0 + 4) + 2) + 0)) | ((int )((ush___8 )*(((buf___0 + 4) + 2) + 1)) << 8)) << 16);
  } else
#line 160
  if (ext_header) {
#line 166
    n___17 = 0;
    {
#line 166
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 166
      if (! (n___17 < 16)) {
#line 166
        goto while_break___1;
      }
#line 167
      if (inptr < insize) {
#line 167
        tmp___166 = inptr;
#line 167
        inptr ++;
#line 167
        tmp___168 = (int )inbuf[tmp___166];
      } else {
        {
#line 167
        tmp___167 = fill_inbuf(0);
#line 167
        tmp___168 = tmp___167;
        }
      }
#line 167
      buf___0[n___17] = (uch___8 )tmp___168;
#line 166
      n___17 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 169
    orig_crc = (ulg___8 )((int )((ush___8 )*((buf___0 + 4) + 0)) | ((int )((ush___8 )*((buf___0 + 4) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((buf___0 + 4) + 2) + 0)) | ((int )((ush___8 )*(((buf___0 + 4) + 2) + 1)) << 8)) << 16);
#line 170
    orig_len___0 = (ulg___8 )((int )((ush___8 )*((buf___0 + 12) + 0)) | ((int )((ush___8 )*((buf___0 + 12) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((buf___0 + 12) + 2) + 0)) | ((int )((ush___8 )*(((buf___0 + 12) + 2) + 1)) << 8)) << 16);
  }
  {
#line 174
  tmp___169 = updcrc(outbuf, 0U);
  }
#line 174
  if (orig_crc != tmp___169) {
    {
#line 175
    error((char *)"invalid compressed data--crc error");
    }
  }
#line 177
  if (orig_len___0 != (ulg___8 )bytes_out) {
    {
#line 178
    error((char *)"invalid compressed data--length error");
    }
  }
#line 182
  if (pkzip) {
#line 182
    if (inptr + 4U < insize) {
#line 182
      if (((ulg___8 )((int )((ush___8 )*((inbuf + inptr) + 0)) | ((int )((ush___8 )*((inbuf + inptr) + 1)) << 8)) | ((ulg___8 )((int )((ush___8 )*(((inbuf + inptr) + 2) + 0)) | ((int )((ush___8 )*(((inbuf + inptr) + 2) + 1)) << 8)) << 16)) == 67324752UL) {
#line 183
        if (to_stdout) {
#line 184
          if (! quiet) {
            {
#line 184
            fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has more than one entry--rest ignored\n",
                    progname, ifname);
            }
          }
#line 184
          if (exit_code == 0) {
#line 184
            exit_code = 2;
          }
        } else {
          {
#line 189
          fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s has more than one entry -- unchanged\n",
                  progname, ifname);
#line 192
          exit_code = 1;
#line 193
          pkzip = 0;
#line 193
          ext_header = pkzip;
          }
#line 194
          return (1);
        }
      }
    }
  }
#line 197
  pkzip = 0;
#line 197
  ext_header = pkzip;
#line 198
  return (0);
}
}
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__asm__("error in function __bswap_32");
#line 108
__asm__("error in function __bswap_64");
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__asm__("error in function __uint16_identity");
#line 38
__asm__("error in function __uint32_identity");
#line 44
__asm__("error in function __uint64_identity");
#line 33 "util.c"
ulg___9 crc_32_tab[256] ;
#line 39 "util.c"
int copy(int in___5 , int out___4 ) 
{ 
  int *tmp___170 ;
  int tmp___171 ;
  int *tmp___172 ;

  {
  {
#line 42
  tmp___170 = __errno_location();
#line 42
  *tmp___170 = 0;
  }
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (insize != 0U) {
#line 43
      if (! ((int )insize != -1)) {
#line 43
        goto while_break;
      }
    } else {
#line 43
      goto while_break;
    }
    {
#line 44
    write_buf(out___4, (void *)((char *)(inbuf)), insize);
#line 45
    bytes_out += (long )insize;
#line 46
    tmp___171 = read(in___5, (char *)(inbuf), 32768);
#line 46
    insize = (unsigned int )tmp___171;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  if ((int )insize == -1) {
    {
#line 48
    tmp___172 = __errno_location();
    }
#line 48
    if (*tmp___172 != 0) {
      {
#line 49
      read_error();
      }
    }
  }
#line 51
  bytes_in = bytes_out;
#line 52
  return (0);
}
}
#line 66
unsigned long updcrc(unsigned char *s___0 , unsigned int n___19 ) ;
#line 66 "util.c"
static ulg___9 crc___0  =    (ulg___9 )4294967295L;
#line 60 "util.c"
unsigned long updcrc(unsigned char *s___0 , unsigned int n___19 ) 
{ 
  register ulg___9 c___4 ;
  unsigned char *tmp___173 ;

  {
#line 68
  if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 69
    c___4 = (ulg___9 )4294967295L;
  } else {
#line 71
    c___4 = crc___0;
#line 72
    if (n___19) {
      {
#line 72
      while (1) {
        while_continue: /* CIL Label */ ;
#line 73
        tmp___173 = s___0;
#line 73
        s___0 ++;
#line 73
        c___4 = crc_32_tab[((int )c___4 ^ (int )*tmp___173) & 255] ^ (c___4 >> 8);
#line 72
        n___19 --;
#line 72
        if (! n___19) {
#line 72
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 76
  crc___0 = c___4;
#line 77
  return (c___4 ^ 4294967295UL);
}
}
#line 83 "util.c"
void clear_bufs(void) 
{ 


  {
#line 85
  outcnt = 0U;
#line 86
  inptr = 0U;
#line 86
  insize = inptr;
#line 87
  bytes_out = 0L;
#line 87
  bytes_in = bytes_out;
#line 88
  return;
}
}
#line 93 "util.c"
int fill_inbuf(int eof_ok ) 
{ 
  int len___3 ;
  int *tmp___174 ;

  {
  {
#line 99
  insize = 0U;
#line 100
  tmp___174 = __errno_location();
#line 100
  *tmp___174 = 0;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 102
    len___3 = read(ifd, (char *)(inbuf) + insize, 32768U - insize);
    }
#line 103
    if (len___3 == 0) {
#line 103
      goto while_break;
    } else
#line 103
    if (len___3 == -1) {
#line 103
      goto while_break;
    }
#line 104
    insize += (unsigned int )len___3;
#line 101
    if (! (insize < 32768U)) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  if (insize == 0U) {
#line 108
    if (eof_ok) {
#line 108
      return (-1);
    }
    {
#line 109
    read_error();
    }
  }
#line 111
  bytes_in = (long )((ulg___9 )bytes_in + (ulg___9 )insize);
#line 112
  inptr = 1U;
#line 113
  return ((int )inbuf[0]);
}
}
#line 120 "util.c"
void flush_outbuf(void) 
{ 


  {
#line 122
  if (outcnt == 0U) {
#line 122
    return;
  }
  {
#line 124
  write_buf(ofd, (void *)((char *)(outbuf)), outcnt);
#line 125
  bytes_out = (long )((ulg___9 )bytes_out + (ulg___9 )outcnt);
#line 126
  outcnt = 0U;
  }
#line 127
  return;
}
}
#line 133 "util.c"
void flush_window(void) 
{ 


  {
#line 135
  if (outcnt == 0U) {
#line 135
    return;
  }
  {
#line 136
  updcrc(window, outcnt);
  }
#line 138
  if (! test) {
    {
#line 139
    write_buf(ofd, (void *)((char *)(window)), outcnt);
    }
  }
#line 141
  bytes_out = (long )((ulg___9 )bytes_out + (ulg___9 )outcnt);
#line 142
  outcnt = 0U;
#line 143
  return;
}
}
#line 156
extern int ( /* missing proto */  write)() ;
#line 149 "util.c"
void write_buf(int fd , void *buf___1 , unsigned int cnt ) 
{ 
  unsigned int n___20 ;
  int tmp___175 ;

  {
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 156
    tmp___175 = write(fd, buf___1, cnt);
#line 156
    n___20 = (unsigned int )tmp___175;
    }
#line 156
    if (! (n___20 != cnt)) {
#line 156
      goto while_break;
    }
#line 157
    if (n___20 == 4294967295U) {
      {
#line 158
      write_error();
      }
    }
#line 160
    cnt -= n___20;
#line 161
    buf___1 = (voidp___9 )((char *)buf___1 + n___20);
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 168 "util.c"
char *strlwr(char *s___1 ) 
{ 
  char *t___3 ;
  unsigned short const   **tmp___177 ;

  {
#line 172
  t___3 = s___1;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! *t___3) {
#line 172
      goto while_break;
    }
    {
#line 172
    tmp___177 = __ctype_b_loc();
    }
#line 172
    if ((int const   )*(*tmp___177 + (int )*t___3) & 256) {
#line 172
      *t___3 = (char )(((int )*t___3 - 65) + 97);
    } else {
#line 172
      *t___3 = *t___3;
    }
#line 172
    t___3 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  return (s___1);
}
}
#line 181 "util.c"
char *basename(char *fname ) 
{ 
  char *p___3 ;

  {
  {
#line 186
  p___3 = strrchr((char const   *)fname, '/');
  }
#line 186
  if ((unsigned long )p___3 != (unsigned long )((void *)0)) {
#line 186
    fname = p___3 + 1;
  }
#line 197
  return (fname);
}
}
#line 208 "util.c"
void make_simple_name(char *name ) 
{ 
  char *p___4 ;
  char *tmp___178 ;

  {
  {
#line 211
  tmp___178 = strrchr((char const   *)name, '.');
#line 211
  p___4 = tmp___178;
  }
#line 212
  if ((unsigned long )p___4 == (unsigned long )((void *)0)) {
#line 212
    return;
  }
#line 213
  if ((unsigned long )p___4 == (unsigned long )name) {
#line 213
    p___4 ++;
  }
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    p___4 --;
#line 215
    if ((int )*p___4 == 46) {
#line 215
      *p___4 = (char )'_';
    }
#line 214
    if (! ((unsigned long )p___4 != (unsigned long )name)) {
#line 214
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 279 "util.c"
char *add_envopt(int *argcp , char ***argvp , char *env___0 ) 
{ 
  char *p___5 ;
  char **oargv ;
  char **nargv ;
  int oargc ;
  int nargc ;
  char *tmp___179 ;
  unsigned long tmp___180 ;
  void *tmp___181 ;
  unsigned long tmp___182 ;
  unsigned long tmp___183 ;
  char *tmp___184 ;
  void *tmp___185 ;
  int tmp___186 ;
  char **tmp___187 ;
  char **tmp___188 ;
  unsigned long tmp___189 ;
  char **tmp___190 ;
  char *tmp___191 ;
  char **tmp___192 ;
  char **tmp___193 ;
  int tmp___194 ;

  {
  {
#line 287
  oargc = *argcp;
#line 288
  nargc = 0;
#line 290
  tmp___179 = getenv((char const   *)env___0);
#line 290
  env___0 = tmp___179;
  }
#line 291
  if ((unsigned long )env___0 == (unsigned long )((void *)0)) {
#line 291
    return ((char *)((void *)0));
  }
  {
#line 293
  tmp___180 = strlen((char const   *)env___0);
#line 293
  tmp___181 = xmalloc((unsigned int )(tmp___180 + 1UL));
#line 293
  p___5 = (char *)tmp___181;
#line 294
  env___0 = strcpy((char */* __restrict  */)p___5, (char const   */* __restrict  */)env___0);
#line 296
  p___5 = env___0;
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! *p___5) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp___182 = strspn((char const   *)p___5, " \t");
#line 297
    p___5 += tmp___182;
    }
#line 298
    if ((int )*p___5 == 0) {
#line 298
      goto while_break;
    }
    {
#line 300
    tmp___183 = strcspn((char const   *)p___5, " \t");
#line 300
    p___5 += tmp___183;
    }
#line 301
    if (*p___5) {
#line 301
      tmp___184 = p___5;
#line 301
      p___5 ++;
#line 301
      *tmp___184 = (char )'\000';
    }
#line 296
    nargc ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  if (nargc == 0) {
    {
#line 304
    free((void *)env___0);
    }
#line 305
    return ((char *)((void *)0));
  }
  {
#line 307
  *argcp += nargc;
#line 311
  tmp___185 = calloc((unsigned long )(*argcp + 1), sizeof(char *));
#line 311
  nargv = (char **)tmp___185;
  }
#line 312
  if ((unsigned long )nargv == (unsigned long )((void *)0)) {
    {
#line 312
    error((char *)"out of memory");
    }
  }
#line 313
  oargv = *argvp;
#line 314
  *argvp = nargv;
#line 317
  tmp___186 = oargc;
#line 317
  oargc --;
#line 317
  if (tmp___186 < 0) {
    {
#line 317
    error((char *)"argc<=0");
    }
  }
#line 318
  tmp___187 = nargv;
#line 318
  nargv ++;
#line 318
  tmp___188 = oargv;
#line 318
  oargv ++;
#line 318
  *tmp___187 = *tmp___188;
#line 321
  p___5 = env___0;
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! (nargc > 0)) {
#line 321
      goto while_break___0;
    }
    {
#line 322
    tmp___189 = strspn((char const   *)p___5, " \t");
#line 322
    p___5 += tmp___189;
#line 323
    tmp___190 = nargv;
#line 323
    nargv ++;
#line 323
    *tmp___190 = p___5;
    }
    {
#line 324
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 324
      tmp___191 = p___5;
#line 324
      p___5 ++;
#line 324
      if (! *tmp___191) {
#line 324
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 321
    nargc --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 328
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 328
    tmp___194 = oargc;
#line 328
    oargc --;
#line 328
    if (! tmp___194) {
#line 328
      goto while_break___2;
    }
#line 328
    tmp___192 = nargv;
#line 328
    nargv ++;
#line 328
    tmp___193 = oargv;
#line 328
    oargv ++;
#line 328
    *tmp___192 = *tmp___193;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 329
  *nargv = (char *)((void *)0);
#line 330
  return (env___0);
}
}
#line 336 "util.c"
void error(char *m___3 ) 
{ 


  {
  {
#line 339
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: %s: %s\n",
          progname, ifname, m___3);
#line 340
  abort_gzip();
  }
#line 341
  return;
}
}
#line 343 "util.c"
void warn(char *a___0 , char *b___4 ) 
{ 


  {
#line 346
  if (! quiet) {
    {
#line 346
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: %s: warning: %s%s\n",
            progname, ifname, a___0, b___4);
    }
  }
#line 346
  if (exit_code == 0) {
#line 346
    exit_code = 2;
  }
#line 347
  return;
}
}
#line 349 "util.c"
void read_error(void) 
{ 
  int *tmp___195 ;

  {
  {
#line 351
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: ",
          progname);
#line 352
  tmp___195 = __errno_location();
  }
#line 352
  if (*tmp___195 != 0) {
    {
#line 353
    perror((char const   *)(ifname));
    }
  } else {
    {
#line 355
    fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unexpected end of file\n",
            ifname);
    }
  }
  {
#line 357
  abort_gzip();
  }
#line 358
  return;
}
}
#line 360 "util.c"
void write_error(void) 
{ 


  {
  {
#line 362
  fprintf((struct _IO_FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n%s: ",
          progname);
#line 363
  perror((char const   *)(ofname));
#line 364
  abort_gzip();
  }
#line 365
  return;
}
}
#line 370 "util.c"
void display_ratio(long num , long den , struct _IO_FILE *file ) 
{ 
  long ratio ;

  {
#line 377
  if (den == 0L) {
#line 378
    ratio = 0L;
  } else
#line 379
  if (den < 2147483L) {
#line 380
    ratio = (1000L * num) / den;
  } else {
#line 382
    ratio = num / (den / 1000L);
  }
#line 384
  if (ratio < 0L) {
    {
#line 385
    _IO_putc('-', file);
#line 386
    ratio = - ratio;
    }
  } else {
    {
#line 388
    _IO_putc(' ', file);
    }
  }
  {
#line 390
  fprintf((struct _IO_FILE */* __restrict  */)file, (char const   */* __restrict  */)"%2ld.%1ld%%",
          ratio / 10L, ratio % 10L);
  }
#line 391
  return;
}
}
#line 397 "util.c"
void *xmalloc(unsigned int size ) 
{ 
  voidp___9 cp ;
  void *tmp___196 ;

  {
  {
#line 400
  tmp___196 = malloc((unsigned long )size);
#line 400
  cp = tmp___196;
  }
#line 402
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 402
    error((char *)"out of memory");
    }
  }
#line 403
  return (cp);
}
}
#line 409 "util.c"
ulg___9 crc_32_tab[256]  = 
#line 409
  {      (ulg___9 )0L,      (ulg___9 )1996959894L,      (ulg___9 )3993919788L,      (ulg___9 )2567524794L, 
        (ulg___9 )124634137L,      (ulg___9 )1886057615L,      (ulg___9 )3915621685L,      (ulg___9 )2657392035L, 
        (ulg___9 )249268274L,      (ulg___9 )2044508324L,      (ulg___9 )3772115230L,      (ulg___9 )2547177864L, 
        (ulg___9 )162941995L,      (ulg___9 )2125561021L,      (ulg___9 )3887607047L,      (ulg___9 )2428444049L, 
        (ulg___9 )498536548L,      (ulg___9 )1789927666L,      (ulg___9 )4089016648L,      (ulg___9 )2227061214L, 
        (ulg___9 )450548861L,      (ulg___9 )1843258603L,      (ulg___9 )4107580753L,      (ulg___9 )2211677639L, 
        (ulg___9 )325883990L,      (ulg___9 )1684777152L,      (ulg___9 )4251122042L,      (ulg___9 )2321926636L, 
        (ulg___9 )335633487L,      (ulg___9 )1661365465L,      (ulg___9 )4195302755L,      (ulg___9 )2366115317L, 
        (ulg___9 )997073096L,      (ulg___9 )1281953886L,      (ulg___9 )3579855332L,      (ulg___9 )2724688242L, 
        (ulg___9 )1006888145L,      (ulg___9 )1258607687L,      (ulg___9 )3524101629L,      (ulg___9 )2768942443L, 
        (ulg___9 )901097722L,      (ulg___9 )1119000684L,      (ulg___9 )3686517206L,      (ulg___9 )2898065728L, 
        (ulg___9 )853044451L,      (ulg___9 )1172266101L,      (ulg___9 )3705015759L,      (ulg___9 )2882616665L, 
        (ulg___9 )651767980L,      (ulg___9 )1373503546L,      (ulg___9 )3369554304L,      (ulg___9 )3218104598L, 
        (ulg___9 )565507253L,      (ulg___9 )1454621731L,      (ulg___9 )3485111705L,      (ulg___9 )3099436303L, 
        (ulg___9 )671266974L,      (ulg___9 )1594198024L,      (ulg___9 )3322730930L,      (ulg___9 )2970347812L, 
        (ulg___9 )795835527L,      (ulg___9 )1483230225L,      (ulg___9 )3244367275L,      (ulg___9 )3060149565L, 
        (ulg___9 )1994146192L,      (ulg___9 )31158534L,      (ulg___9 )2563907772L,      (ulg___9 )4023717930L, 
        (ulg___9 )1907459465L,      (ulg___9 )112637215L,      (ulg___9 )2680153253L,      (ulg___9 )3904427059L, 
        (ulg___9 )2013776290L,      (ulg___9 )251722036L,      (ulg___9 )2517215374L,      (ulg___9 )3775830040L, 
        (ulg___9 )2137656763L,      (ulg___9 )141376813L,      (ulg___9 )2439277719L,      (ulg___9 )3865271297L, 
        (ulg___9 )1802195444L,      (ulg___9 )476864866L,      (ulg___9 )2238001368L,      (ulg___9 )4066508878L, 
        (ulg___9 )1812370925L,      (ulg___9 )453092731L,      (ulg___9 )2181625025L,      (ulg___9 )4111451223L, 
        (ulg___9 )1706088902L,      (ulg___9 )314042704L,      (ulg___9 )2344532202L,      (ulg___9 )4240017532L, 
        (ulg___9 )1658658271L,      (ulg___9 )366619977L,      (ulg___9 )2362670323L,      (ulg___9 )4224994405L, 
        (ulg___9 )1303535960L,      (ulg___9 )984961486L,      (ulg___9 )2747007092L,      (ulg___9 )3569037538L, 
        (ulg___9 )1256170817L,      (ulg___9 )1037604311L,      (ulg___9 )2765210733L,      (ulg___9 )3554079995L, 
        (ulg___9 )1131014506L,      (ulg___9 )879679996L,      (ulg___9 )2909243462L,      (ulg___9 )3663771856L, 
        (ulg___9 )1141124467L,      (ulg___9 )855842277L,      (ulg___9 )2852801631L,      (ulg___9 )3708648649L, 
        (ulg___9 )1342533948L,      (ulg___9 )654459306L,      (ulg___9 )3188396048L,      (ulg___9 )3373015174L, 
        (ulg___9 )1466479909L,      (ulg___9 )544179635L,      (ulg___9 )3110523913L,      (ulg___9 )3462522015L, 
        (ulg___9 )1591671054L,      (ulg___9 )702138776L,      (ulg___9 )2966460450L,      (ulg___9 )3352799412L, 
        (ulg___9 )1504918807L,      (ulg___9 )783551873L,      (ulg___9 )3082640443L,      (ulg___9 )3233442989L, 
        (ulg___9 )3988292384L,      (ulg___9 )2596254646L,      (ulg___9 )62317068L,      (ulg___9 )1957810842L, 
        (ulg___9 )3939845945L,      (ulg___9 )2647816111L,      (ulg___9 )81470997L,      (ulg___9 )1943803523L, 
        (ulg___9 )3814918930L,      (ulg___9 )2489596804L,      (ulg___9 )225274430L,      (ulg___9 )2053790376L, 
        (ulg___9 )3826175755L,      (ulg___9 )2466906013L,      (ulg___9 )167816743L,      (ulg___9 )2097651377L, 
        (ulg___9 )4027552580L,      (ulg___9 )2265490386L,      (ulg___9 )503444072L,      (ulg___9 )1762050814L, 
        (ulg___9 )4150417245L,      (ulg___9 )2154129355L,      (ulg___9 )426522225L,      (ulg___9 )1852507879L, 
        (ulg___9 )4275313526L,      (ulg___9 )2312317920L,      (ulg___9 )282753626L,      (ulg___9 )1742555852L, 
        (ulg___9 )4189708143L,      (ulg___9 )2394877945L,      (ulg___9 )397917763L,      (ulg___9 )1622183637L, 
        (ulg___9 )3604390888L,      (ulg___9 )2714866558L,      (ulg___9 )953729732L,      (ulg___9 )1340076626L, 
        (ulg___9 )3518719985L,      (ulg___9 )2797360999L,      (ulg___9 )1068828381L,      (ulg___9 )1219638859L, 
        (ulg___9 )3624741850L,      (ulg___9 )2936675148L,      (ulg___9 )906185462L,      (ulg___9 )1090812512L, 
        (ulg___9 )3747672003L,      (ulg___9 )2825379669L,      (ulg___9 )829329135L,      (ulg___9 )1181335161L, 
        (ulg___9 )3412177804L,      (ulg___9 )3160834842L,      (ulg___9 )628085408L,      (ulg___9 )1382605366L, 
        (ulg___9 )3423369109L,      (ulg___9 )3138078467L,      (ulg___9 )570562233L,      (ulg___9 )1426400815L, 
        (ulg___9 )3317316542L,      (ulg___9 )2998733608L,      (ulg___9 )733239954L,      (ulg___9 )1555261956L, 
        (ulg___9 )3268935591L,      (ulg___9 )3050360625L,      (ulg___9 )752459403L,      (ulg___9 )1541320221L, 
        (ulg___9 )2607071920L,      (ulg___9 )3965973030L,      (ulg___9 )1969922972L,      (ulg___9 )40735498L, 
        (ulg___9 )2617837225L,      (ulg___9 )3943577151L,      (ulg___9 )1913087877L,      (ulg___9 )83908371L, 
        (ulg___9 )2512341634L,      (ulg___9 )3803740692L,      (ulg___9 )2075208622L,      (ulg___9 )213261112L, 
        (ulg___9 )2463272603L,      (ulg___9 )3855990285L,      (ulg___9 )2094854071L,      (ulg___9 )198958881L, 
        (ulg___9 )2262029012L,      (ulg___9 )4057260610L,      (ulg___9 )1759359992L,      (ulg___9 )534414190L, 
        (ulg___9 )2176718541L,      (ulg___9 )4139329115L,      (ulg___9 )1873836001L,      (ulg___9 )414664567L, 
        (ulg___9 )2282248934L,      (ulg___9 )4279200368L,      (ulg___9 )1711684554L,      (ulg___9 )285281116L, 
        (ulg___9 )2405801727L,      (ulg___9 )4167216745L,      (ulg___9 )1634467795L,      (ulg___9 )376229701L, 
        (ulg___9 )2685067896L,      (ulg___9 )3608007406L,      (ulg___9 )1308918612L,      (ulg___9 )956543938L, 
        (ulg___9 )2808555105L,      (ulg___9 )3495958263L,      (ulg___9 )1231636301L,      (ulg___9 )1047427035L, 
        (ulg___9 )2932959818L,      (ulg___9 )3654703836L,      (ulg___9 )1088359270L,      (ulg___9 )936918000L, 
        (ulg___9 )2847714899L,      (ulg___9 )3736837829L,      (ulg___9 )1202900863L,      (ulg___9 )817233897L, 
        (ulg___9 )3183342108L,      (ulg___9 )3401237130L,      (ulg___9 )1404277552L,      (ulg___9 )615818150L, 
        (ulg___9 )3134207493L,      (ulg___9 )3453421203L,      (ulg___9 )1423857449L,      (ulg___9 )601450431L, 
        (ulg___9 )3009837614L,      (ulg___9 )3294710456L,      (ulg___9 )1567103746L,      (ulg___9 )711928724L, 
        (ulg___9 )3020668471L,      (ulg___9 )3272380065L,      (ulg___9 )1510334235L,      (ulg___9 )755167117L};
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__asm__("error in function __bswap_32");
#line 108
__asm__("error in function __bswap_64");
#line 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h"
__asm__("error in function __uint16_identity");
#line 38
__asm__("error in function __uint32_identity");
#line 44
__asm__("error in function __uint64_identity");
#line 25 "zip.c"
static ulg___10 crc  ;
#line 33 "zip.c"
int zip(int in___6 , int out___5 ) 
{ 
  uch___10 flags___0 ;
  ush___10 attr___0 ;
  ush___10 deflate_flags ;
  unsigned int tmp___197 ;
  unsigned int tmp___198 ;
  unsigned int tmp___199 ;
  unsigned int tmp___200 ;
  unsigned int tmp___201 ;
  unsigned int tmp___202 ;
  unsigned int tmp___203 ;
  unsigned int tmp___204 ;
  unsigned int tmp___205 ;
  unsigned int tmp___206 ;
  unsigned int tmp___207 ;
  unsigned int tmp___208 ;
  unsigned int tmp___209 ;
  unsigned int tmp___210 ;
  char *p___6 ;
  char *tmp___211 ;
  unsigned int tmp___212 ;
  char *tmp___213 ;
  unsigned int tmp___214 ;
  unsigned int tmp___215 ;
  unsigned int tmp___216 ;
  unsigned int tmp___217 ;
  unsigned int tmp___218 ;
  unsigned int tmp___219 ;
  unsigned int tmp___220 ;
  unsigned int tmp___221 ;
  unsigned int tmp___222 ;
  unsigned int tmp___223 ;
  unsigned int tmp___224 ;
  unsigned int tmp___225 ;
  unsigned int tmp___226 ;
  unsigned int tmp___227 ;
  unsigned int tmp___228 ;
  unsigned int tmp___229 ;

  {
#line 36
  flags___0 = (uch___10 )0;
#line 37
  attr___0 = (ush___10 )0;
#line 38
  deflate_flags = (ush___10 )0;
#line 40
  ifd = in___6;
#line 41
  ofd = out___5;
#line 42
  outcnt = 0U;
#line 46
  method = 8;
#line 47
  tmp___197 = outcnt;
#line 47
  outcnt ++;
#line 47
  outbuf[tmp___197] = (uch___10 )*("\037\213" + 0);
#line 47
  if (outcnt == 16384U) {
    {
#line 47
    flush_outbuf();
    }
  }
#line 48
  tmp___198 = outcnt;
#line 48
  outcnt ++;
#line 48
  outbuf[tmp___198] = (uch___10 )*("\037\213" + 1);
#line 48
  if (outcnt == 16384U) {
    {
#line 48
    flush_outbuf();
    }
  }
#line 49
  tmp___199 = outcnt;
#line 49
  outcnt ++;
#line 49
  outbuf[tmp___199] = (uch___10 )8;
#line 49
  if (outcnt == 16384U) {
    {
#line 49
    flush_outbuf();
    }
  }
#line 51
  if (save_orig_name) {
#line 52
    flags___0 = (uch___10 )((int )flags___0 | 8);
  }
#line 54
  tmp___200 = outcnt;
#line 54
  outcnt ++;
#line 54
  outbuf[tmp___200] = flags___0;
#line 54
  if (outcnt == 16384U) {
    {
#line 54
    flush_outbuf();
    }
  }
#line 55
  if (outcnt < 16382U) {
#line 55
    tmp___201 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___201] = (uch___10 )((time_stamp & 65535L) & 255L);
#line 55
    tmp___202 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___202] = (uch___10 )((int )((ush___10 )(time_stamp & 65535L)) >> 8);
  } else {
#line 55
    tmp___203 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___203] = (uch___10 )((time_stamp & 65535L) & 255L);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
#line 55
    tmp___204 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___204] = (uch___10 )((int )((ush___10 )(time_stamp & 65535L)) >> 8);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
  }
#line 55
  if (outcnt < 16382U) {
#line 55
    tmp___205 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___205] = (uch___10 )(((ulg___10 )time_stamp >> 16) & 255UL);
#line 55
    tmp___206 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___206] = (uch___10 )((int )((ush___10 )((ulg___10 )time_stamp >> 16)) >> 8);
  } else {
#line 55
    tmp___207 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___207] = (uch___10 )(((ulg___10 )time_stamp >> 16) & 255UL);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
#line 55
    tmp___208 = outcnt;
#line 55
    outcnt ++;
#line 55
    outbuf[tmp___208] = (uch___10 )((int )((ush___10 )((ulg___10 )time_stamp >> 16)) >> 8);
#line 55
    if (outcnt == 16384U) {
      {
#line 55
      flush_outbuf();
      }
    }
  }
  {
#line 58
  crc = updcrc((unsigned char *)0, 0U);
#line 60
  bi_init(out___5);
#line 61
  ct_init(& attr___0, & method);
#line 62
  lm_init(level, & deflate_flags);
#line 64
  tmp___209 = outcnt;
#line 64
  outcnt ++;
#line 64
  outbuf[tmp___209] = (uch___10 )deflate_flags;
  }
#line 64
  if (outcnt == 16384U) {
    {
#line 64
    flush_outbuf();
    }
  }
#line 65
  tmp___210 = outcnt;
#line 65
  outcnt ++;
#line 65
  outbuf[tmp___210] = (uch___10 )3;
#line 65
  if (outcnt == 16384U) {
    {
#line 65
    flush_outbuf();
    }
  }
#line 67
  if (save_orig_name) {
    {
#line 68
    tmp___211 = basename(ifname);
#line 68
    p___6 = tmp___211;
    }
    {
#line 69
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      tmp___212 = outcnt;
#line 70
      outcnt ++;
#line 70
      outbuf[tmp___212] = (uch___10 )*p___6;
#line 70
      if (outcnt == 16384U) {
        {
#line 70
        flush_outbuf();
        }
      }
#line 69
      tmp___213 = p___6;
#line 69
      p___6 ++;
#line 69
      if (! *tmp___213) {
#line 69
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 73
  header_bytes = (long )outcnt;
#line 75
  deflate();
  }
#line 89
  if (outcnt < 16382U) {
#line 89
    tmp___214 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___214] = (uch___10 )((crc & 65535UL) & 255UL);
#line 89
    tmp___215 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___215] = (uch___10 )((int )((ush___10 )(crc & 65535UL)) >> 8);
  } else {
#line 89
    tmp___216 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___216] = (uch___10 )((crc & 65535UL) & 255UL);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
#line 89
    tmp___217 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___217] = (uch___10 )((int )((ush___10 )(crc & 65535UL)) >> 8);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
  }
#line 89
  if (outcnt < 16382U) {
#line 89
    tmp___218 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___218] = (uch___10 )((crc >> 16) & 255UL);
#line 89
    tmp___219 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___219] = (uch___10 )((int )((ush___10 )(crc >> 16)) >> 8);
  } else {
#line 89
    tmp___220 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___220] = (uch___10 )((crc >> 16) & 255UL);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
#line 89
    tmp___221 = outcnt;
#line 89
    outcnt ++;
#line 89
    outbuf[tmp___221] = (uch___10 )((int )((ush___10 )(crc >> 16)) >> 8);
#line 89
    if (outcnt == 16384U) {
      {
#line 89
      flush_outbuf();
      }
    }
  }
#line 90
  if (outcnt < 16382U) {
#line 90
    tmp___222 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___222] = (uch___10 )((bytes_in & 65535L) & 255L);
#line 90
    tmp___223 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___223] = (uch___10 )((int )((ush___10 )(bytes_in & 65535L)) >> 8);
  } else {
#line 90
    tmp___224 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___224] = (uch___10 )((bytes_in & 65535L) & 255L);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
#line 90
    tmp___225 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___225] = (uch___10 )((int )((ush___10 )(bytes_in & 65535L)) >> 8);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
  }
#line 90
  if (outcnt < 16382U) {
#line 90
    tmp___226 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___226] = (uch___10 )(((ulg___10 )bytes_in >> 16) & 255UL);
#line 90
    tmp___227 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___227] = (uch___10 )((int )((ush___10 )((ulg___10 )bytes_in >> 16)) >> 8);
  } else {
#line 90
    tmp___228 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___228] = (uch___10 )(((ulg___10 )bytes_in >> 16) & 255UL);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
#line 90
    tmp___229 = outcnt;
#line 90
    outcnt ++;
#line 90
    outbuf[tmp___229] = (uch___10 )((int )((ush___10 )((ulg___10 )bytes_in >> 16)) >> 8);
#line 90
    if (outcnt == 16384U) {
      {
#line 90
      flush_outbuf();
      }
    }
  }
  {
#line 91
  header_bytes = (long )((unsigned long )header_bytes + 2UL * sizeof(long ));
#line 93
  flush_outbuf();
  }
#line 94
  return (0);
}
}
#line 103 "zip.c"
int file_read(char *buf___2 , unsigned int size___0 ) 
{ 
  unsigned int len___4 ;
  int tmp___230 ;

  {
  {
#line 111
  tmp___230 = read(ifd, buf___2, size___0);
#line 111
  len___4 = (unsigned int )tmp___230;
  }
#line 112
  if (len___4 == 4294967295U) {
#line 112
    return ((int )len___4);
  } else
#line 112
  if (len___4 == 0U) {
#line 112
    return ((int )len___4);
  }
  {
#line 114
  crc = updcrc((uch___10 *)buf___2, len___4);
#line 115
  bytes_in = (long )((ulg___10 )bytes_in + (ulg___10 )len___4);
  }
#line 116
  return ((int )len___4);
}
}
