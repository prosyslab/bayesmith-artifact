/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 52 "vhdl_flex.c"
typedef short flex_int16_t;
#line 53 "vhdl_flex.c"
typedef int flex_int32_t;
#line 124 "vhdl_flex.c"
typedef void *yyscan_t;
#line 170
struct yy_buffer_state ;
#line 170 "vhdl_flex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 204 "vhdl_flex.c"
typedef size_t yy_size_t;
#line 209 "vhdl_flex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 335 "vhdl_flex.c"
typedef unsigned char YY_CHAR;
#line 337 "vhdl_flex.c"
typedef int yy_state_type;
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct scan_extra {
   int proc_mode ;
   int Compile_Errors ;
   int Base ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct scan_extra scan_extra_t;
#line 206 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/vhdl_bison.h"
union YYSTYPE {
   int integer ;
   char *str ;
};
#line 206 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/vhdl_bison.h"
typedef union YYSTYPE YYSTYPE;
#line 973 "vhdl_flex.c"
struct yyguts_t {
   scan_extra_t *yyextra_r ;
   FILE *yyin_r ;
   FILE *yyout_r ;
   size_t yy_buffer_stack_top ;
   size_t yy_buffer_stack_max ;
   YY_BUFFER_STATE *yy_buffer_stack ;
   char yy_hold_char ;
   int yy_n_chars ;
   int yyleng_r ;
   char *yy_c_buf_p ;
   int yy_init ;
   int yy_start ;
   int yy_did_buffer_switch_on_eof ;
   int yy_start_stack_ptr ;
   int yy_start_stack_depth ;
   int *yy_start_stack ;
   yy_state_type yy_last_accepting_state ;
   char *yy_last_accepting_cpos ;
   int yylineno_r ;
   int yy_flex_debug_r ;
   yy_state_type *yy_state_buf ;
   yy_state_type *yy_state_ptr ;
   char *yy_full_match ;
   int yy_lp ;
   int yy_looking_for_trail_begin ;
   int yy_full_lp ;
   int *yy_full_state ;
   char *yytext_r ;
   int yy_more_flag ;
   int yy_more_len ;
   YYSTYPE *yylval_r ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h"
typedef __int32_t int32_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 29 "../../include/bssignal.h"
struct signal ;
#line 29 "../../include/bssignal.h"
typedef struct signal signal_t;
#line 28 "../../include/bsbit.h"
struct bsbit ;
#line 28 "../../include/bsbit.h"
typedef struct bsbit bsbit_t;
#line 40 "../../include/bsbit.h"
struct bsbit {
   int bit ;
   char *name ;
   int type ;
   signal_t *signal ;
   int safe ;
   int control ;
   int control_value ;
   int control_state ;
};
#line 33 "../../include/bssignal.h"
struct signal {
   char *name ;
   char *pin ;
   signal_t *next ;
   bsbit_t *input ;
   bsbit_t *output ;
};
#line 41
struct salias ;
#line 41 "../../include/bssignal.h"
typedef struct salias salias_t;
#line 43 "../../include/bssignal.h"
struct salias {
   char *name ;
   salias_t *next ;
   signal_t *signal ;
};
#line 29 "../../include/register.h"
struct tap_register {
   char *data ;
   int len ;
   char *string ;
};
#line 29 "../../include/register.h"
typedef struct tap_register tap_register;
#line 32 "../../include/data_register.h"
struct data_register ;
#line 32 "../../include/data_register.h"
typedef struct data_register data_register;
#line 34 "../../include/data_register.h"
struct data_register {
   char name[33] ;
   tap_register *in ;
   tap_register *out ;
   data_register *next ;
};
#line 33 "../../include/instruction.h"
struct instruction ;
#line 33 "../../include/instruction.h"
typedef struct instruction instruction;
#line 35 "../../include/instruction.h"
struct instruction {
   char name[21] ;
   tap_register *value ;
   tap_register *out ;
   data_register *data_register ;
   instruction *next ;
};
#line 39 "../../include/part.h"
struct part ;
#line 39 "../../include/part.h"
typedef struct part part_t;
#line 41 "../../include/part.h"
struct part {
   tap_register *id ;
   char *alias ;
   char manufacturer[26] ;
   char part[21] ;
   char stepping[9] ;
   signal_t *signals ;
   salias_t *saliases ;
   int instruction_length ;
   instruction *instructions ;
   instruction *active_instruction ;
   data_register *data_registers ;
   int boundary_length ;
   bsbit_t **bsbits ;
};
#line 68
struct parts ;
#line 68 "../../include/part.h"
typedef struct parts parts_t;
#line 70 "../../include/part.h"
struct parts {
   int len ;
   part_t **parts ;
};
#line 30 "../../include/chain.h"
struct chain_t ;
#line 30 "../../include/chain.h"
typedef struct chain_t chain_t;
#line 31 "../../include/cable.h"
struct cable_t ;
#line 31 "../../include/cable.h"
typedef struct cable_t cable_t;
#line 32 "../../include/usbconn.h"
struct usbconn_t ;
#line 32 "../../include/usbconn.h"
typedef struct usbconn_t usbconn_t;
#line 36 "../../include/usbconn.h"
struct __anonstruct_usbconn_cable_t_589600422 {
   char *name ;
   char *desc ;
   char *driver ;
   int32_t vid ;
   int32_t pid ;
};
#line 36 "../../include/usbconn.h"
typedef struct __anonstruct_usbconn_cable_t_589600422 usbconn_cable_t;
#line 45 "../../include/usbconn.h"
struct __anonstruct_usbconn_driver_t_12444765 {
   char const   *type ;
   usbconn_t *(*connect)(char const   ** , int  , usbconn_cable_t * ) ;
   void (*free)(usbconn_t * ) ;
   int (*open)(usbconn_t * ) ;
   int (*close)(usbconn_t * ) ;
   int (*read)(usbconn_t * , uint8_t * , int  ) ;
   int (*write)(usbconn_t * , uint8_t * , int  , int  ) ;
};
#line 45 "../../include/usbconn.h"
typedef struct __anonstruct_usbconn_driver_t_12444765 usbconn_driver_t;
#line 55 "../../include/usbconn.h"
struct usbconn_t {
   usbconn_driver_t *driver ;
   void *params ;
   cable_t *cable ;
};
#line 31 "../../include/parport.h"
struct parport_t ;
#line 31 "../../include/parport.h"
typedef struct parport_t parport_t;
#line 35 "../../include/parport.h"
struct __anonstruct_parport_driver_t_422815707 {
   char const   *type ;
   parport_t *(*connect)(char const   ** , int  ) ;
   void (*parport_free)(parport_t * ) ;
   int (*open)(parport_t * ) ;
   int (*close)(parport_t * ) ;
   int (*set_data)(parport_t * , uint8_t  ) ;
   int (*get_data)(parport_t * ) ;
   int (*get_status)(parport_t * ) ;
   int (*set_control)(parport_t * , uint8_t  ) ;
};
#line 35 "../../include/parport.h"
typedef struct __anonstruct_parport_driver_t_422815707 parport_driver_t;
#line 47 "../../include/parport.h"
struct parport_t {
   parport_driver_t *driver ;
   void *params ;
   cable_t *cable ;
};
#line 37 "../../include/cable.h"
struct cable_driver_t ;
#line 37 "../../include/cable.h"
typedef struct cable_driver_t cable_driver_t;
#line 39
enum __anonenum_cable_flush_amount_t_322558321 {
    OPTIONALLY = 0,
    TO_OUTPUT = 1,
    COMPLETELY = 2
} ;
#line 39 "../../include/cable.h"
typedef enum __anonenum_cable_flush_amount_t_322558321 cable_flush_amount_t;
#line 47 "../../include/cable.h"
struct cable_driver_t {
   char const   *name ;
   char const   *description ;
   int (*connect)(char **params , cable_t *cable ) ;
   void (*disconnect)(cable_t *cable ) ;
   void (*cable_free)(cable_t *cable ) ;
   int (*init)(cable_t * ) ;
   void (*done)(cable_t * ) ;
   void (*set_frequency)(cable_t * , uint32_t freq ) ;
   void (*clock)(cable_t * , int  , int  , int  ) ;
   int (*get_tdo)(cable_t * ) ;
   int (*transfer)(cable_t * , int  , char * , char * ) ;
   int (*set_trst)(cable_t * , int  ) ;
   int (*get_trst)(cable_t * ) ;
   void (*flush)(cable_t * , cable_flush_amount_t  ) ;
   void (*help)(char const   * ) ;
};
#line 65
struct cable_queue_t ;
#line 65 "../../include/cable.h"
typedef struct cable_queue_t cable_queue_t;
#line 67
enum __anonenum_action_990402164 {
    CABLE_CLOCK = 0,
    CABLE_GET_TDO = 1,
    CABLE_TRANSFER = 2,
    CABLE_SET_TRST = 3,
    CABLE_GET_TRST = 4
} ;
#line 67 "../../include/cable.h"
struct __anonstruct_clock_582275743 {
   int tms ;
   int tdi ;
   int n ;
};
#line 67 "../../include/cable.h"
struct __anonstruct_value_582275744 {
   int tdo ;
   int trst ;
   int val ;
};
#line 67 "../../include/cable.h"
struct __anonstruct_transfer_255056401 {
   int len ;
   char *in ;
   char *out ;
};
#line 67 "../../include/cable.h"
struct __anonstruct_xferred_478576807 {
   int len ;
   int res ;
   char *out ;
};
#line 67 "../../include/cable.h"
union __anonunion_arg_890022643 {
   struct __anonstruct_clock_582275743 clock ;
   struct __anonstruct_value_582275744 value ;
   struct __anonstruct_transfer_255056401 transfer ;
   struct __anonstruct_xferred_478576807 xferred ;
};
#line 67 "../../include/cable.h"
struct cable_queue_t {
   enum __anonenum_action_990402164 action ;
   union __anonunion_arg_890022643 arg ;
};
#line 99
struct cable_queue_info_t ;
#line 99 "../../include/cable.h"
typedef struct cable_queue_info_t cable_queue_info_t;
#line 101 "../../include/cable.h"
struct cable_queue_info_t {
   cable_queue_t *data ;
   int max_items ;
   int num_items ;
   int next_item ;
   int next_free ;
};
#line 109 "../../include/cable.h"
union __anonunion_link_107830755 {
   usbconn_t *usb ;
   parport_t *port ;
};
#line 109 "../../include/cable.h"
struct cable_t {
   cable_driver_t *driver ;
   union __anonunion_link_107830755 link ;
   void *params ;
   chain_t *chain ;
   cable_queue_info_t todo ;
   cable_queue_info_t done ;
   uint32_t delay ;
   uint32_t frequency ;
};
#line 30 "../../include/bsdl.h"
struct __anonstruct_bsdl_globs_t_990402165 {
   char **path_list ;
   int debug ;
};
#line 30 "../../include/bsdl.h"
typedef struct __anonstruct_bsdl_globs_t_990402165 bsdl_globs_t;
#line 40 "../../include/chain.h"
struct chain_t {
   int state ;
   parts_t *parts ;
   int total_instr_len ;
   int active_part ;
   cable_t *cable ;
   bsdl_globs_t bsdl ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct instr_elem {
   struct instr_elem *next ;
   char *instr ;
   char *opcode ;
};
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct instr_elem instr_elem_t;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct ainfo_elem {
   struct ainfo_elem *next ;
   char *reg ;
   int reg_len ;
   instr_elem_t *instr_list ;
};
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct ainfo_elem ainfo_elem_t;
#line 71 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct cell_info {
   struct cell_info *next ;
   int bit_num ;
   char *port_name ;
   int cell_function ;
   char *basic_safe_value ;
   int ctrl_bit_num ;
   int disable_safe_value ;
};
#line 83 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct cell_info cell_info_t;
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct string_elem {
   struct string_elem *next ;
   char *string ;
};
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct string_elem string_elem_t;
#line 98 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct port_desc {
   string_elem_t *names_list ;
   struct port_desc *next ;
   int is_vector ;
   int low_idx ;
   int high_idx ;
};
#line 106 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct port_desc port_desc_t;
#line 108
enum __anonenum_vhdl_elem_type_t_892056807 {
    VET_CONSTANT = 0,
    VET_ATTRIBUTE_STRING = 1,
    VET_ATTRIBUTE_DECIMAL = 2,
    VET_UNKNOWN = 3
} ;
#line 108 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef enum __anonenum_vhdl_elem_type_t_892056807 vhdl_elem_type_t;
#line 116 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct vhdl_elem {
   struct vhdl_elem *next ;
   vhdl_elem_type_t type ;
   char *name ;
   char *payload ;
   int line ;
};
#line 124 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct vhdl_elem vhdl_elem_t;
#line 126
enum __anonenum_bsdl_conformance_t_460874531 {
    CONF_1990 = 0,
    CONF_1993 = 1,
    CONF_2001 = 2,
    CONF_UNKNOWN = 3
} ;
#line 126 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef enum __anonenum_bsdl_conformance_t_460874531 bsdl_conformance_t;
#line 136 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct jtag_ctrl {
   int proc_mode ;
   chain_t *chain ;
   part_t *part ;
   port_desc_t *port_desc ;
   vhdl_elem_t *vhdl_elem_first ;
   vhdl_elem_t *vhdl_elem_last ;
   char *idcode ;
   char *usercode ;
   int instr_len ;
   int bsr_len ;
   bsdl_conformance_t conformance ;
   instr_elem_t *instr_list ;
   ainfo_elem_t *ainfo_list ;
   cell_info_t *cell_info_first ;
   cell_info_t *cell_info_last ;
};
#line 156 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct jtag_ctrl jtag_ctrl_t;
#line 160 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct vhdl_parser_priv {
   char Package_File_Name[100] ;
   int Reading_Package ;
   char *buffer ;
   size_t len_buffer ;
   void *scanner ;
   jtag_ctrl_t *jtag_ctrl ;
   port_desc_t tmp_port_desc ;
};
#line 170 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct vhdl_parser_priv vhdl_parser_priv_t;
#line 341 "vhdl_bison.c"
typedef unsigned char yytype_uint8;
#line 356 "vhdl_bison.c"
typedef unsigned short yytype_uint16;
#line 362 "vhdl_bison.c"
typedef short yytype_int16;
#line 493 "vhdl_bison.c"
union yyalloc {
   yytype_int16 yyss ;
   YYSTYPE yyvs ;
};
#line 174 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
struct bsdl_parser_priv {
   void *scanner ;
   jtag_ctrl_t *jtag_ctrl ;
   int lineno ;
   ainfo_elem_t ainfo ;
   cell_info_t tmp_cell_info ;
   port_desc_t tmp_port_desc ;
};
#line 183 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_types.h"
typedef struct bsdl_parser_priv bsdl_parser_priv_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 46 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
struct __anonstruct___sigset_t_973126068 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 5 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h"
typedef struct __anonstruct___sigset_t_973126068 __sigset_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h"
typedef __sigset_t sigset_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h"
typedef union sigval __sigval_t;
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__kill_244518854 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__timer_490064738 {
   int si_tid ;
   int si_overrun ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__rt_619254530 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   __sigval_t si_sigval ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigchld_284671705 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __clock_t si_utime ;
   __clock_t si_stime ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__addr_bnd_5259977 {
   void *_lower ;
   void *_upper ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__bounds_366523479 {
   struct __anonstruct__addr_bnd_5259977 _addr_bnd ;
   __uint32_t _pkey ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigfault_647925373 {
   void *si_addr ;
   short si_addr_lsb ;
   union __anonunion__bounds_366523479 _bounds ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigpoll_386613454 {
   long si_band ;
   int si_fd ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct__sigsys_243330693 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
union __anonunion__sifields_881964849 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_244518854 _kill ;
   struct __anonstruct__timer_490064738 _timer ;
   struct __anonstruct__rt_619254530 _rt ;
   struct __anonstruct__sigchld_284671705 _sigchld ;
   struct __anonstruct__sigfault_647925373 _sigfault ;
   struct __anonstruct__sigpoll_386613454 _sigpoll ;
   struct __anonstruct__sigsys_243330693 _sigsys ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
struct __anonstruct_siginfo_t_715868880 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   int __pad0 ;
   union __anonunion__sifields_881964849 _sifields ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h"
typedef struct __anonstruct_siginfo_t_715868880 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_363639592 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_363639592 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
enum generic_irdr_coding {
    generic_ir = 0,
    generic_dr = 1
} ;
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct ths_params {
   double number ;
   char *tdi ;
   char *tdo ;
   char *mask ;
   char *smask ;
};
#line 55 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct path_states {
   int states[64] ;
   int num_states ;
};
#line 60 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct runtest {
   int run_state ;
   uint32_t run_count ;
   int run_clk ;
   double min_time ;
   double max_time ;
   int end_state ;
};
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct __anonstruct_sxr_t_450495659 {
   struct ths_params params ;
   int no_tdi ;
   int no_tdo ;
};
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
typedef struct __anonstruct_sxr_t_450495659 sxr_t;
#line 76 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct svf_parser_params {
   struct ths_params ths_params ;
   struct path_states path_states ;
   struct runtest runtest ;
};
#line 85 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct parser_priv {
   struct svf_parser_params parser_params ;
   void *scanner ;
   part_t *part ;
   instruction *ir ;
   data_register *dr ;
   sxr_t sir_params ;
   sxr_t sdr_params ;
   int endir ;
   int enddr ;
   int runtest_run_state ;
   int runtest_end_state ;
   int svf_stop_on_mismatch ;
   int svf_trst_absent ;
   int svf_state_executed ;
   int issued_runtest_maxtime ;
};
#line 103 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
typedef struct parser_priv parser_priv_t;
#line 111
struct YYLTYPE ;
#line 187 "svf_bison.h"
struct YYLTYPE {
   int first_line ;
   int first_column ;
   int last_line ;
   int last_column ;
};
#line 187 "svf_bison.h"
typedef struct YYLTYPE YYLTYPE;
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct tdval {
   int token ;
   double dvalue ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct tcval {
   int token ;
   char *cvalue ;
   struct tcval *next ;
};
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
struct scanner_extra {
   int num_lines ;
   int print_progress ;
};
#line 109 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
typedef struct scanner_extra scanner_extra_t;
#line 166 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf_bison.h"
union YYSTYPE___0 {
   int token ;
   double dvalue ;
   char *cvalue ;
   int ivalue ;
   struct tdval tdval ;
   struct tcval *tcval ;
};
#line 166 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf_bison.h"
typedef union YYSTYPE___0 YYSTYPE___0;
#line 538 "svf_flex.c"
struct yyguts_t___0 {
   scanner_extra_t *yyextra_r ;
   FILE *yyin_r ;
   FILE *yyout_r ;
   size_t yy_buffer_stack_top ;
   size_t yy_buffer_stack_max ;
   YY_BUFFER_STATE *yy_buffer_stack ;
   char yy_hold_char ;
   int yy_n_chars ;
   int yyleng_r ;
   char *yy_c_buf_p ;
   int yy_init ;
   int yy_start ;
   int yy_did_buffer_switch_on_eof ;
   int yy_start_stack_ptr ;
   int yy_start_stack_depth ;
   int *yy_start_stack ;
   yy_state_type yy_last_accepting_state ;
   char *yy_last_accepting_cpos ;
   int yylineno_r ;
   int yy_flex_debug_r ;
   char *yytext_r ;
   int yy_more_flag ;
   int yy_more_len ;
   YYSTYPE___0 *yylval_r ;
   YYLTYPE *yylloc_r ;
};
#line 191 "svf_flex.l"
struct rwtable {
   char *rw_name ;
   int rw_yylex ;
};
#line 292 "svf_bison.c"
typedef signed char yytype_int8;
#line 438 "svf_bison.c"
union yyalloc___0 {
   yytype_int16 yyss ;
   YYSTYPE___0 yyvs ;
   YYLTYPE yyls ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 42 "../../include/bus_driver.h"
struct __anonstruct_bus_area_t_36066931 {
   char const   *description ;
   uint32_t start ;
   uint64_t length ;
   unsigned int width ;
};
#line 42 "../../include/bus_driver.h"
typedef struct __anonstruct_bus_area_t_36066931 bus_area_t;
#line 49
struct bus ;
#line 49 "../../include/bus_driver.h"
typedef struct bus bus_t;
#line 50
struct bus_driver ;
#line 50 "../../include/bus_driver.h"
typedef struct bus_driver bus_driver_t;
#line 52 "../../include/bus_driver.h"
struct bus_driver {
   char const   *name ;
   char const   *description ;
   bus_t *(*new_bus)(chain_t *chain , bus_driver_t const   *driver , char **cmd_params ) ;
   void (*free_bus)(bus_t *bus ) ;
   void (*printinfo)(bus_t *bus ) ;
   void (*prepare)(bus_t *bus ) ;
   int (*area)(bus_t *bus , uint32_t adr , bus_area_t *area ) ;
   void (*read_start)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_next)(bus_t *bus , uint32_t adr ) ;
   uint32_t (*read_end)(bus_t *bus ) ;
   uint32_t (*read)(bus_t *bus , uint32_t adr ) ;
   void (*write)(bus_t *bus , uint32_t adr , uint32_t data ) ;
   int (*init)(bus_t *bus ) ;
};
#line 68 "../../include/bus_driver.h"
struct bus {
   chain_t *chain ;
   part_t *part ;
   void *params ;
   int initialized ;
   bus_driver_t const   *driver ;
};
#line 100 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
typedef int ctype_t;
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
struct __anonstruct_component_t_641410113 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[25] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *nbyte ;
   signal_t *sts ;
   signal_t *nrp ;
   signal_t *si ;
   signal_t *so ;
   signal_t *sck ;
};
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
typedef struct __anonstruct_component_t_641410113 component_t;
#line 120 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
struct __anonstruct_bus_params_t_587417150 {
   uint32_t last_addr ;
   component_t flash ;
   component_t ram0 ;
   component_t ram1 ;
   component_t eeprom ;
   component_t eeprom_status ;
};
#line 120 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
typedef struct __anonstruct_bus_params_t_587417150 bus_params_t;
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
struct __anonstruct_bus_params_t_486360324 {
   signal_t *oe ;
   signal_t *swe ;
   signal_t *romce[4] ;
   signal_t *sdcs[4] ;
   signal_t *addr[20] ;
   signal_t *data[16] ;
};
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
typedef struct __anonstruct_bus_params_t_486360324 bus_params_t___0;
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
struct __anonstruct_bus_params_t_36729363 {
   uint32_t last_adr ;
   signal_t *ad[20] ;
   signal_t *dq[16] ;
   signal_t *nsdce ;
   signal_t *sdclk ;
   signal_t *noe ;
   signal_t *nsrce ;
   signal_t *nflce ;
   signal_t *nflbyte ;
   signal_t *nflby ;
   signal_t *nwe ;
   signal_t *lcde ;
   signal_t *lcdrs ;
   signal_t *lcdrw ;
};
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
typedef struct __anonstruct_bus_params_t_36729363 bus_params_t___1;
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
struct __anonstruct_bus_params_t_691994717 {
   uint32_t last_adr ;
   signal_t *ma[19] ;
   signal_t *md[8] ;
   signal_t *bms ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
typedef struct __anonstruct_bus_params_t_691994717 bus_params_t___2;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
struct __anonstruct_bus_params_t_41583134 {
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[8] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *bs ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
typedef struct __anonstruct_bus_params_t_41583134 bus_params_t___3;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
struct __anonstruct_bus_params_t_611392575 {
   signal_t *a[26] ;
   signal_t *d[64] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *rdwr2 ;
   signal_t *rd2 ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
typedef struct __anonstruct_bus_params_t_611392575 bus_params_t___4;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
struct __anonstruct_bus_params_t_611392575___0 {
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *cs[7] ;
   signal_t *we[4] ;
   signal_t *rdwr ;
   signal_t *rd ;
   signal_t *md3 ;
   signal_t *md4 ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
typedef struct __anonstruct_bus_params_t_611392575___0 bus_params_t___5;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
struct __anonstruct_bus_params_t_486360324___0 {
   signal_t *a[26] ;
   signal_t *d[32] ;
   signal_t *ncs[6] ;
   signal_t *rd_nwr ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
typedef struct __anonstruct_bus_params_t_486360324___0 bus_params_t___6;
#line 75 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
struct __anonstruct_bus_params_t_788593795 {
   signal_t *a[22] ;
   signal_t *d[32] ;
   signal_t *nrcs[6] ;
   signal_t *necs[4] ;
   signal_t *nsdcs[4] ;
   signal_t *nwbe[4] ;
   signal_t *noe ;
   int dbuswidth ;
};
#line 75 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
typedef struct __anonstruct_bus_params_t_788593795 bus_params_t___7;
#line 67 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0_mc.h"
struct MC_registers {
   uint32_t mdcnfg ;
   uint32_t mdrefr ;
   uint32_t msc0 ;
   uint32_t msc1 ;
   uint32_t msc2 ;
   uint32_t mecr ;
   uint32_t __reserved1 ;
   uint32_t sxcnfg ;
   uint32_t __reserved2 ;
   uint32_t sxmrs ;
   uint32_t mcmem0 ;
   uint32_t mcmem1 ;
   uint32_t mcatt0 ;
   uint32_t mcatt1 ;
   uint32_t mcio0 ;
   uint32_t mcio1 ;
   uint32_t mdmrs ;
   uint32_t boot_def ;
   uint32_t __reserved3[4] ;
   uint32_t mdmrslp ;
   uint32_t __reserved4[2] ;
   uint32_t sa1111cr ;
};
#line 67 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0_mc.h"
typedef struct MC_registers  volatile  MC_registers_t;
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
struct __anonstruct_ncs_map_entry_788335240 {
   char *sig_name ;
   int enabled ;
   int bus_width ;
   char label_buf[81] ;
};
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
typedef struct __anonstruct_ncs_map_entry_788335240 ncs_map_entry;
#line 106 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
struct __anonstruct_bus_params_t_799151281 {
   uint32_t last_adr ;
   signal_t *ma[26] ;
   signal_t *md[32] ;
   signal_t *ncs[6] ;
   signal_t *dqm[4] ;
   signal_t *rdnwr ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *nsdcas ;
   MC_registers_t MC_registers ;
   int inited ;
   int proc ;
};
#line 106 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
typedef struct __anonstruct_bus_params_t_799151281 bus_params_t___8;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
struct __anonstruct_bus_params_t_75549627 {
   signal_t *a[32] ;
   signal_t *d[32] ;
   signal_t *cs ;
   signal_t *we ;
   signal_t *oe ;
   int alsbi ;
   int amsbi ;
   int ai ;
   int aw ;
   int dlsbi ;
   int dmsbi ;
   int di ;
   int dw ;
   int csa ;
   int wea ;
   int oea ;
   int ashift ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
typedef struct __anonstruct_bus_params_t_75549627 bus_params_t___9;
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
struct __anonstruct_bus_params_t_473953406 {
   signal_t *a[32] ;
   signal_t *d[8] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
typedef struct __anonstruct_bus_params_t_473953406 bus_params_t___10;
#line 37 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
struct __anonstruct_bus_params_t_473953406___0 {
   signal_t *a[32] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *nwe ;
   signal_t *noe ;
};
#line 37 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
typedef struct __anonstruct_bus_params_t_473953406___0 bus_params_t___11;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
struct __anonstruct_bus_params_t_514411380 {
   int boot_nfoe ;
   int boot_sdma1 ;
   uint32_t last_adr ;
   signal_t *ar[23] ;
   signal_t *nrcs0 ;
   signal_t *nwe ;
   signal_t *nfoe ;
   signal_t *d[32] ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
typedef struct __anonstruct_bus_params_t_514411380 bus_params_t___12;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
struct __anonstruct_bus_params_t_691994717___0 {
   uint32_t last_adr ;
   signal_t *ad[24] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *d[8] ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
typedef struct __anonstruct_bus_params_t_691994717___0 bus_params_t___13;
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
struct __anonstruct_bus_params_t_486360324___1 {
   signal_t *a[24] ;
   signal_t *d[32] ;
   signal_t *ncs[4] ;
   signal_t *nwe ;
   signal_t *noe ;
   signal_t *width[2] ;
};
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
typedef struct __anonstruct_bus_params_t_486360324___1 bus_params_t___14;
#line 87 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
struct __anonstruct_component_t_604853148 {
   ctype_t ctype ;
   char *cname ;
   signal_t *a[19] ;
   signal_t *d[16] ;
   signal_t *ncs ;
   signal_t *noe ;
   signal_t *nwe ;
   signal_t *nlb ;
   signal_t *nub ;
   signal_t *ncs2 ;
   signal_t *nrdy ;
};
#line 87 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
typedef struct __anonstruct_component_t_604853148 component_t___0;
#line 101 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
struct __anonstruct_bus_params_t_981666888 {
   uint32_t last_addr ;
   component_t___0 rama ;
   component_t___0 ramb ;
   component_t___0 flash ;
   signal_t *ser_txd ;
   signal_t *ser_nrts ;
   signal_t *ser_rxd ;
   signal_t *ser_ncts ;
};
#line 101 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
typedef struct __anonstruct_bus_params_t_981666888 bus_params_t___15;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
struct __anonstruct_bus_params_t_473953406___1 {
   signal_t *ex_cs[8] ;
   signal_t *ex_addr[24] ;
   signal_t *ex_data[16] ;
   signal_t *ex_wr ;
   signal_t *ex_rd ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
typedef struct __anonstruct_bus_params_t_473953406___1 bus_params_t___16;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
struct __anonstruct_bus_params_t_473953406___2 {
   signal_t *a[25] ;
   signal_t *d[32] ;
   signal_t *nRCS[4] ;
   signal_t *nRWE[4] ;
   signal_t *nROE ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
typedef struct __anonstruct_bus_params_t_473953406___2 bus_params_t___17;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
struct block_param {
   struct block_param *next ;
   uint16_t num ;
   uint32_t start ;
   uint32_t end ;
   uint16_t addr_width ;
   uint16_t data_width ;
   uint8_t ashift ;
};
#line 55 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
typedef struct block_param block_param_t;
#line 57 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
struct block_desc {
   uint16_t reg_len ;
   uint16_t instr_pos ;
   uint16_t block_pos ;
   uint16_t block_len ;
   uint16_t addr_pos ;
   uint16_t addr_len ;
   uint16_t data_pos ;
   uint16_t data_len ;
   block_param_t *blocks ;
};
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
typedef struct block_desc block_desc_t;
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
struct __anonstruct_bus_params_t_1022756341 {
   uint32_t last_addr ;
   data_register *fjmem_reg ;
   block_desc_t block_desc ;
};
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
typedef struct __anonstruct_bus_params_t_1022756341 bus_params_t___18;
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
struct __anonstruct_bus_params_t_754373501 {
   uint32_t impcode ;
   uint16_t adr_hi ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
typedef struct __anonstruct_bus_params_t_754373501 bus_params_t___19;
#line 33 "../../include/bus.h"
struct __anonstruct_buses_t_1042349786 {
   int len ;
   bus_t **buses ;
};
#line 33 "../../include/bus.h"
typedef struct __anonstruct_buses_t_1042349786 buses_t;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
struct __anonstruct_bus_params_t_843275104 {
   signal_t *ams[4] ;
   signal_t *addr[24] ;
   signal_t *abe[4] ;
   signal_t *data[32] ;
   signal_t *awe ;
   signal_t *aoe ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms[4] ;
   signal_t *swe ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
typedef struct __anonstruct_bus_params_t_843275104 bus_params_t___20;
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
struct __anonstruct_bus_params_t_611392575___1 {
   signal_t *ams[4] ;
   signal_t *addr[24] ;
   signal_t *data[16] ;
   signal_t *awe ;
   signal_t *are ;
   signal_t *aoe ;
   signal_t *dcs0 ;
   signal_t *nce ;
};
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
typedef struct __anonstruct_bus_params_t_611392575___1 bus_params_t___21;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
struct __anonstruct_bus_params_t_843275104___0 {
   signal_t *ams[4] ;
   signal_t *addr[19] ;
   signal_t *data[16] ;
   signal_t *abe[2] ;
   signal_t *awe ;
   signal_t *are ;
   signal_t *sras ;
   signal_t *scas ;
   signal_t *sms ;
   signal_t *swe ;
};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
typedef struct __anonstruct_bus_params_t_843275104___0 bus_params_t___22;
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
struct __anonstruct_bus_params_t_74745110 {
   unsigned int mode ;
   unsigned int slave ;
   uint32_t addr_mask ;
   uint32_t rwcs_rd ;
   uint32_t rwcs_wr ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
typedef struct __anonstruct_bus_params_t_74745110 bus_params_t___23;
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
struct __anonstruct_bus_params_t_473953406___3 {
   signal_t *rad[32] ;
   signal_t *nrcs[4] ;
   signal_t *nrwe ;
   signal_t *nroe ;
   signal_t *rd[32] ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
typedef struct __anonstruct_bus_params_t_473953406___3 bus_params_t___24;
#line 68 "../../include/flash/cfi.h"
struct cfi_query_identification_string {
   uint16_t pri_id_code ;
   void *pri_vendor_tbl ;
   uint16_t alt_id_code ;
   void *alt_vendor_tbl ;
};
#line 68 "../../include/flash/cfi.h"
typedef struct cfi_query_identification_string cfi_query_identification_string_t;
#line 103 "../../include/flash/cfi.h"
struct cfi_query_system_interface_information {
   uint16_t vcc_min_wev ;
   uint16_t vcc_max_wev ;
   uint16_t vpp_min_wev ;
   uint16_t vpp_max_wev ;
   uint32_t typ_single_write_timeout ;
   uint32_t typ_buffer_write_timeout ;
   uint32_t typ_block_erase_timeout ;
   uint32_t typ_chip_erase_timeout ;
   uint32_t max_single_write_timeout ;
   uint32_t max_buffer_write_timeout ;
   uint32_t max_block_erase_timeout ;
   uint32_t max_chip_erase_timeout ;
};
#line 103 "../../include/flash/cfi.h"
typedef struct cfi_query_system_interface_information cfi_query_system_interface_information_t;
#line 128
struct cfi_erase_block_region ;
#line 128 "../../include/flash/cfi.h"
typedef struct cfi_erase_block_region cfi_erase_block_region_t;
#line 130 "../../include/flash/cfi.h"
struct cfi_device_geometry {
   uint32_t device_size ;
   uint16_t device_interface ;
   uint32_t max_bytes_write ;
   uint8_t number_of_erase_regions ;
   cfi_erase_block_region_t *erase_block_regions ;
};
#line 130 "../../include/flash/cfi.h"
typedef struct cfi_device_geometry cfi_device_geometry_t;
#line 138 "../../include/flash/cfi.h"
struct cfi_erase_block_region {
   uint32_t erase_block_size ;
   uint32_t number_of_erase_blocks ;
};
#line 155 "../../include/flash/cfi.h"
struct cfi_query_structure {
   cfi_query_identification_string_t identification_string ;
   cfi_query_system_interface_information_t system_interface_info ;
   cfi_device_geometry_t device_geometry ;
};
#line 155 "../../include/flash/cfi.h"
typedef struct cfi_query_structure cfi_query_structure_t;
#line 46 "../../include/flash.h"
struct __anonstruct_cfi_chip_t_960872676 {
   int width ;
   cfi_query_structure_t cfi ;
};
#line 46 "../../include/flash.h"
typedef struct __anonstruct_cfi_chip_t_960872676 cfi_chip_t;
#line 51 "../../include/flash.h"
struct __anonstruct_cfi_array_t_656102674 {
   bus_t *bus ;
   uint32_t address ;
   int bus_width ;
   cfi_chip_t **cfi_chips ;
};
#line 51 "../../include/flash.h"
typedef struct __anonstruct_cfi_array_t_656102674 cfi_array_t;
#line 62 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
struct mtd_erase_region_info {
   uint32_t offset ;
   uint32_t erasesize ;
   uint32_t numblocks ;
};
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
struct amd_flash_info {
   int const   mfr_id ;
   int const   dev_id ;
   char const   *name ;
   long const   size ;
   uint8_t const   interface_width ;
   int const   as_method ;
   int const   numeraseregions ;
   struct mtd_erase_region_info  const  regions[4] ;
};
#line 63 "../../include/flash.h"
struct __anonstruct_flash_driver_t_660044769 {
   unsigned int bus_width ;
   char const   *name ;
   char const   *description ;
   int (*autodetect)(cfi_array_t *cfi_array ) ;
   void (*print_info)(cfi_array_t *cfi_array ) ;
   int (*erase_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*unlock_block)(cfi_array_t *cfi_array , uint32_t adr ) ;
   int (*program)(cfi_array_t *cfi_array , uint32_t adr , uint32_t data ) ;
   void (*readarray)(cfi_array_t *cfi_array ) ;
};
#line 63 "../../include/flash.h"
typedef struct __anonstruct_flash_driver_t_660044769 flash_driver_t;
#line 187 "../../include/flash/cfi.h"
struct amd_pri_extened_query_structure {
   uint8_t major_version ;
   uint8_t minor_version ;
   uint8_t address_sensitive_unlock ;
   uint8_t erase_suspend ;
   uint8_t sector_protect ;
   uint8_t sector_temporary_unprotect ;
   uint8_t sector_protect_scheme ;
   uint8_t simultaneous_operation ;
   uint8_t burst_mode_type ;
   uint8_t page_mode_type ;
   uint16_t acc_min ;
   uint16_t acc_max ;
   uint8_t top_bottom_sector_flag ;
   uint8_t program_suspend ;
   uint8_t unlock_bypass ;
   uint8_t secsi_sector_size ;
   uint8_t embedded_hwrst_timeout_max ;
   uint8_t non_embedded_hwrst_timeout_max ;
   uint8_t erase_suspend_timeout_max ;
   uint8_t program_suspend_timeout_max ;
   uint8_t bank_organization ;
   uint8_t bank_region_info[0] ;
};
#line 187 "../../include/flash/cfi.h"
typedef struct amd_pri_extened_query_structure amd_pri_extened_query_structure_t;
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_991519274 {
   unsigned long flash ;
   unsigned short algorithm ;
   unsigned short unlock_bypass ;
};
#line 94 "/usr/include/usb.h"
struct usb_endpoint_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bEndpointAddress ;
   uint8_t bmAttributes ;
   uint16_t wMaxPacketSize ;
   uint8_t bInterval ;
   uint8_t bRefresh ;
   uint8_t bSynchAddress ;
   unsigned char *extra ;
   int extralen ;
};
#line 119 "/usr/include/usb.h"
struct usb_interface_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint8_t bInterfaceNumber ;
   uint8_t bAlternateSetting ;
   uint8_t bNumEndpoints ;
   uint8_t bInterfaceClass ;
   uint8_t bInterfaceSubClass ;
   uint8_t bInterfaceProtocol ;
   uint8_t iInterface ;
   struct usb_endpoint_descriptor *endpoint ;
   unsigned char *extra ;
   int extralen ;
};
#line 137 "/usr/include/usb.h"
struct usb_interface {
   struct usb_interface_descriptor *altsetting ;
   int num_altsetting ;
};
#line 145 "/usr/include/usb.h"
struct usb_config_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t wTotalLength ;
   uint8_t bNumInterfaces ;
   uint8_t bConfigurationValue ;
   uint8_t iConfiguration ;
   uint8_t bmAttributes ;
   uint8_t MaxPower ;
   struct usb_interface *interface ;
   unsigned char *extra ;
   int extralen ;
};
#line 162 "/usr/include/usb.h"
struct usb_device_descriptor {
   uint8_t bLength ;
   uint8_t bDescriptorType ;
   uint16_t bcdUSB ;
   uint8_t bDeviceClass ;
   uint8_t bDeviceSubClass ;
   uint8_t bDeviceProtocol ;
   uint8_t bMaxPacketSize0 ;
   uint16_t idVendor ;
   uint16_t idProduct ;
   uint16_t bcdDevice ;
   uint8_t iManufacturer ;
   uint8_t iProduct ;
   uint8_t iSerialNumber ;
   uint8_t bNumConfigurations ;
} __attribute__((__packed__)) ;
#line 235
struct usb_device ;
#line 236
struct usb_bus ;
#line 248 "/usr/include/usb.h"
struct usb_device {
   struct usb_device *next ;
   struct usb_device *prev ;
   char filename[4097] ;
   struct usb_bus *bus ;
   struct usb_device_descriptor descriptor ;
   struct usb_config_descriptor *config ;
   void *dev ;
   uint8_t devnum ;
   unsigned char num_children ;
   struct usb_device **children ;
};
#line 266 "/usr/include/usb.h"
struct usb_bus {
   struct usb_bus *next ;
   struct usb_bus *prev ;
   char dirname[4097] ;
   struct usb_device *devices ;
   uint32_t location ;
   struct usb_device *root_dev ;
};
#line 277
struct usb_dev_handle ;
#line 278 "/usr/include/usb.h"
typedef struct usb_dev_handle usb_dev_handle;
#line 32 "../../include/usbconn/libusb.h"
struct __anonstruct_libusb_param_t_477425788 {
   struct usb_device *dev ;
   struct usb_dev_handle *handle ;
   void *data ;
};
#line 32 "../../include/usbconn/libusb.h"
typedef struct __anonstruct_libusb_param_t_477425788 libusb_param_t;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
struct __anonstruct_xpc_cable_params_t_1036286215 {
   int last_tdo ;
};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
typedef struct __anonstruct_xpc_cable_params_t_1036286215 xpc_cable_params_t;
#line 480 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
struct __anonstruct_xpc_ext_transfer_state_t_926405956 {
   cable_t *cable ;
   struct usb_dev_handle *xpcu ;
   int in_bits ;
   int out_bits ;
   int out_done ;
   uint8_t *out ;
   uint8_t buf[8] ;
};
#line 480 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
typedef struct __anonstruct_xpc_ext_transfer_state_t_926405956 xpc_ext_transfer_state_t;
#line 80 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
struct __anonstruct_wiggler_params_t_19145477 {
   int trst_lvl ;
   int srst_act ;
   int srst_inact ;
   int tms_act ;
   int tms_inact ;
   int tck_act ;
   int tck_inact ;
   int tdi_act ;
   int tdi_inact ;
   int tdo_act ;
   int tdo_inact ;
   int trst_act ;
   int trst_inact ;
   int unused_bits ;
};
#line 80 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
typedef struct __anonstruct_wiggler_params_t_19145477 wiggler_params_t;
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.h"
struct __anonstruct_generic_params_t_773697287 {
   int trst ;
   int sreset ;
};
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.h"
typedef struct __anonstruct_generic_params_t_773697287 generic_params_t;
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
struct port_node_t ;
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
typedef struct port_node_t port_node_t;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
struct port_node_t {
   parport_t *port ;
   port_node_t *next ;
};
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
struct __anonstruct_ppdev_params_t_990402165 {
   char *portname ;
   int fd ;
};
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
typedef struct __anonstruct_ppdev_params_t_990402165 ppdev_params_t;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
struct __anonstruct_libusb_param_t_148265704 {
   struct usb_device *dev ;
   struct usb_dev_handle *handle ;
};
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
typedef struct __anonstruct_libusb_param_t_148265704 libusb_param_t___0;
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
struct __anonstruct_jlink_usbconn_data_t_19610330 {
   char usb_in_buffer[2064] ;
   char usb_out_buffer[2064] ;
   int tap_length ;
   uint8_t tms_buffer[390] ;
   uint8_t tdi_buffer[390] ;
   int last_tdo ;
};
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
typedef struct __anonstruct_jlink_usbconn_data_t_19610330 jlink_usbconn_data_t;
#line 107 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
struct __anonstruct_direct_params_t_422959015 {
   unsigned int port ;
};
#line 107 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
typedef struct __anonstruct_direct_params_t_422959015 direct_params_t;
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/detect.c"
struct id_record {
   char name[20] ;
   char fullname[100] ;
};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.h"
struct cx_cmd ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.h"
typedef struct cx_cmd cx_cmd_t;
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.h"
struct cx_cmd {
   cx_cmd_t *next ;
   uint32_t buf_len ;
   uint32_t buf_pos ;
   uint8_t *buf ;
   uint32_t to_recv ;
};
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.h"
struct cx_cmd_root {
   cx_cmd_t *first ;
   cx_cmd_t *last ;
};
#line 48 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.h"
typedef struct cx_cmd_root cx_cmd_root_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 39 "../../include/cmd.h"
struct __anonstruct_cmd_t_148900231 {
   char *name ;
   char *desc ;
   void (*help)(void) ;
   int (*run)(chain_t *chain , char **params ) ;
};
#line 39 "../../include/cmd.h"
typedef struct __anonstruct_cmd_t_148900231 cmd_t;
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 433 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 136
extern struct _IO_FILE *stdout ;
#line 137
extern struct _IO_FILE *stderr ;
#line 199
extern int fclose(FILE *__stream ) ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 646
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 652
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 757
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 761
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 121
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 539
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 614
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 287 "vhdl_flex.c"
void vhdlrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 288
void vhdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 289
YY_BUFFER_STATE vhdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 290
void vhdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 291
void vhdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 292
void vhdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 293
void vhdlpop_buffer_state(yyscan_t yyscanner ) ;
#line 295
static void vhdlensure_buffer_stack(yyscan_t yyscanner ) ;
#line 296
static void vhdl_load_buffer_state(yyscan_t yyscanner ) ;
#line 297
static void vhdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 301
YY_BUFFER_STATE vhdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 302
YY_BUFFER_STATE vhdl_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 303
YY_BUFFER_STATE vhdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 305
void *vhdlalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 306
void *vhdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 307
void vhdlfree(void *ptr , yyscan_t yyscanner ) ;
#line 341
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) ;
#line 342
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 343
static int yy_get_next_buffer(yyscan_t yyscanner ) ;
#line 344
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) ;
#line 365 "vhdl_flex.c"
static flex_int16_t const   yy_acclist[463]  = 
#line 365
  {      (flex_int16_t const   )0,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )83, 
        (flex_int16_t const   )81,      (flex_int16_t const   )82,      (flex_int16_t const   )72,      (flex_int16_t const   )82, 
        (flex_int16_t const   )63,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )79, 
        (flex_int16_t const   )82,      (flex_int16_t const   )70,      (flex_int16_t const   )82,      (flex_int16_t const   )65, 
        (flex_int16_t const   )82,      (flex_int16_t const   )66,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )64,      (flex_int16_t const   )82,      (flex_int16_t const   )81,      (flex_int16_t const   )82, 
        (flex_int16_t const   )67,      (flex_int16_t const   )82,      (flex_int16_t const   )74,      (flex_int16_t const   )77, 
        (flex_int16_t const   )82,      (flex_int16_t const   )77,      (flex_int16_t const   )82,      (flex_int16_t const   )68, 
        (flex_int16_t const   )82,      (flex_int16_t const   )80,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75, 
        (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75, 
        (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )62, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )59,      (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )82, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )72,      (flex_int16_t const   )76, 
        (flex_int16_t const   )73,      (flex_int16_t const   )74,      (flex_int16_t const   )77,      (flex_int16_t const   )77, 
        (flex_int16_t const   )74,      (flex_int16_t const   )71,      (flex_int16_t const   )69,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )19,      (flex_int16_t const   )75,      (flex_int16_t const   )6, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )11, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )26, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )19,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )19,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )55, 
        (flex_int16_t const   )75,      (flex_int16_t const   )56,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )73, 
        (flex_int16_t const   )10,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )24,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )9,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )17,      (flex_int16_t const   )75,      (flex_int16_t const   )20,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )4,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )20,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )58,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )61,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )57,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )29,      (flex_int16_t const   )75, 
        (flex_int16_t const   )18,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )2, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )14,      (flex_int16_t const   )75,      (flex_int16_t const   )30,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )60,      (flex_int16_t const   )75,      (flex_int16_t const   )78,      (flex_int16_t const   )33, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )15,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )21,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )35, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )48,      (flex_int16_t const   )75, 
        (flex_int16_t const   )46,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )40, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )22,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )27,      (flex_int16_t const   )75,      (flex_int16_t const   )1,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )32,      (flex_int16_t const   )75, 
        (flex_int16_t const   )16,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )8, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )51, 
        (flex_int16_t const   )75,      (flex_int16_t const   )53,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )52,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )3, 
        (flex_int16_t const   )75,      (flex_int16_t const   )23,      (flex_int16_t const   )75,      (flex_int16_t const   )28, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )31,      (flex_int16_t const   )75,      (flex_int16_t const   )44, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )41, 
        (flex_int16_t const   )75,      (flex_int16_t const   )42,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )54,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )7, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )34, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )43,      (flex_int16_t const   )75, 
        (flex_int16_t const   )45,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )49, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )5,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )36,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )50,      (flex_int16_t const   )75,      (flex_int16_t const   )25,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )47,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )38, 
        (flex_int16_t const   )75,      (flex_int16_t const   )39,      (flex_int16_t const   )75,      (flex_int16_t const   )37, 
        (flex_int16_t const   )75,      (flex_int16_t const   )75,      (flex_int16_t const   )13,      (flex_int16_t const   )75, 
        (flex_int16_t const   )75,      (flex_int16_t const   )12,      (flex_int16_t const   )75};
#line 420 "vhdl_flex.c"
static flex_int16_t const   yy_accept[353]  = 
#line 420
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )14,      (flex_int16_t const   )16,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )23,      (flex_int16_t const   )25, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )34,      (flex_int16_t const   )37,      (flex_int16_t const   )39,      (flex_int16_t const   )41, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )46,      (flex_int16_t const   )48, 
        (flex_int16_t const   )50,      (flex_int16_t const   )52,      (flex_int16_t const   )54,      (flex_int16_t const   )56, 
        (flex_int16_t const   )58,      (flex_int16_t const   )60,      (flex_int16_t const   )62,      (flex_int16_t const   )64, 
        (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )70,      (flex_int16_t const   )72, 
        (flex_int16_t const   )74,      (flex_int16_t const   )76,      (flex_int16_t const   )79,      (flex_int16_t const   )81, 
        (flex_int16_t const   )83,      (flex_int16_t const   )85,      (flex_int16_t const   )87,      (flex_int16_t const   )90, 
        (flex_int16_t const   )92,      (flex_int16_t const   )94,      (flex_int16_t const   )96,      (flex_int16_t const   )98, 
        (flex_int16_t const   )100,      (flex_int16_t const   )102,      (flex_int16_t const   )104,      (flex_int16_t const   )106, 
        (flex_int16_t const   )108,      (flex_int16_t const   )112,      (flex_int16_t const   )114,      (flex_int16_t const   )115, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )117,      (flex_int16_t const   )117, 
        (flex_int16_t const   )119,      (flex_int16_t const   )120,      (flex_int16_t const   )121,      (flex_int16_t const   )122, 
        (flex_int16_t const   )123,      (flex_int16_t const   )124,      (flex_int16_t const   )125,      (flex_int16_t const   )126, 
        (flex_int16_t const   )127,      (flex_int16_t const   )128,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )139, 
        (flex_int16_t const   )141,      (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )145, 
        (flex_int16_t const   )146,      (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )149, 
        (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )152,      (flex_int16_t const   )153, 
        (flex_int16_t const   )154,      (flex_int16_t const   )155,      (flex_int16_t const   )157,      (flex_int16_t const   )158, 
        (flex_int16_t const   )159,      (flex_int16_t const   )160,      (flex_int16_t const   )162,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )165,      (flex_int16_t const   )167,      (flex_int16_t const   )168, 
        (flex_int16_t const   )169,      (flex_int16_t const   )170,      (flex_int16_t const   )171,      (flex_int16_t const   )172, 
        (flex_int16_t const   )174,      (flex_int16_t const   )175,      (flex_int16_t const   )177,      (flex_int16_t const   )179, 
        (flex_int16_t const   )180,      (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )183, 
        (flex_int16_t const   )184,      (flex_int16_t const   )184,      (flex_int16_t const   )186,      (flex_int16_t const   )187, 
        (flex_int16_t const   )188,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192, 
        (flex_int16_t const   )193,      (flex_int16_t const   )194,      (flex_int16_t const   )195,      (flex_int16_t const   )196, 
        (flex_int16_t const   )197,      (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )201, 
        (flex_int16_t const   )202,      (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )206, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )215, 
        (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )219, 
        (flex_int16_t const   )220,      (flex_int16_t const   )221,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )226,      (flex_int16_t const   )227,      (flex_int16_t const   )228, 
        (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )234, 
        (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )238,      (flex_int16_t const   )239, 
        (flex_int16_t const   )240,      (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )243, 
        (flex_int16_t const   )244,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )248, 
        (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )252,      (flex_int16_t const   )253, 
        (flex_int16_t const   )254,      (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )257, 
        (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )260,      (flex_int16_t const   )261, 
        (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )265,      (flex_int16_t const   )266, 
        (flex_int16_t const   )267,      (flex_int16_t const   )268,      (flex_int16_t const   )269,      (flex_int16_t const   )270, 
        (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )274,      (flex_int16_t const   )276, 
        (flex_int16_t const   )277,      (flex_int16_t const   )278,      (flex_int16_t const   )279,      (flex_int16_t const   )280, 
        (flex_int16_t const   )281,      (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )284, 
        (flex_int16_t const   )285,      (flex_int16_t const   )286,      (flex_int16_t const   )287,      (flex_int16_t const   )288, 
        (flex_int16_t const   )290,      (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )293, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )297, 
        (flex_int16_t const   )298,      (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )301, 
        (flex_int16_t const   )303,      (flex_int16_t const   )304,      (flex_int16_t const   )306,      (flex_int16_t const   )307, 
        (flex_int16_t const   )308,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311, 
        (flex_int16_t const   )313,      (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )316, 
        (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )320,      (flex_int16_t const   )322, 
        (flex_int16_t const   )323,      (flex_int16_t const   )325,      (flex_int16_t const   )326,      (flex_int16_t const   )327, 
        (flex_int16_t const   )328,      (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331, 
        (flex_int16_t const   )332,      (flex_int16_t const   )333,      (flex_int16_t const   )334,      (flex_int16_t const   )335, 
        (flex_int16_t const   )336,      (flex_int16_t const   )338,      (flex_int16_t const   )339,      (flex_int16_t const   )340, 
        (flex_int16_t const   )342,      (flex_int16_t const   )344,      (flex_int16_t const   )345,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )349,      (flex_int16_t const   )350, 
        (flex_int16_t const   )352,      (flex_int16_t const   )354,      (flex_int16_t const   )355,      (flex_int16_t const   )357, 
        (flex_int16_t const   )358,      (flex_int16_t const   )359,      (flex_int16_t const   )360,      (flex_int16_t const   )361, 
        (flex_int16_t const   )362,      (flex_int16_t const   )363,      (flex_int16_t const   )365,      (flex_int16_t const   )367, 
        (flex_int16_t const   )368,      (flex_int16_t const   )370,      (flex_int16_t const   )371,      (flex_int16_t const   )372, 
        (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )375,      (flex_int16_t const   )377, 
        (flex_int16_t const   )379,      (flex_int16_t const   )381,      (flex_int16_t const   )382,      (flex_int16_t const   )383, 
        (flex_int16_t const   )384,      (flex_int16_t const   )385,      (flex_int16_t const   )387,      (flex_int16_t const   )389, 
        (flex_int16_t const   )390,      (flex_int16_t const   )391,      (flex_int16_t const   )393,      (flex_int16_t const   )395, 
        (flex_int16_t const   )396,      (flex_int16_t const   )397,      (flex_int16_t const   )399,      (flex_int16_t const   )400, 
        (flex_int16_t const   )401,      (flex_int16_t const   )402,      (flex_int16_t const   )403,      (flex_int16_t const   )405, 
        (flex_int16_t const   )406,      (flex_int16_t const   )407,      (flex_int16_t const   )409,      (flex_int16_t const   )410, 
        (flex_int16_t const   )412,      (flex_int16_t const   )414,      (flex_int16_t const   )415,      (flex_int16_t const   )417, 
        (flex_int16_t const   )418,      (flex_int16_t const   )420,      (flex_int16_t const   )421,      (flex_int16_t const   )422, 
        (flex_int16_t const   )424,      (flex_int16_t const   )425,      (flex_int16_t const   )426,      (flex_int16_t const   )427, 
        (flex_int16_t const   )428,      (flex_int16_t const   )430,      (flex_int16_t const   )432,      (flex_int16_t const   )433, 
        (flex_int16_t const   )434,      (flex_int16_t const   )435,      (flex_int16_t const   )436,      (flex_int16_t const   )437, 
        (flex_int16_t const   )438,      (flex_int16_t const   )439,      (flex_int16_t const   )440,      (flex_int16_t const   )441, 
        (flex_int16_t const   )442,      (flex_int16_t const   )443,      (flex_int16_t const   )444,      (flex_int16_t const   )445, 
        (flex_int16_t const   )446,      (flex_int16_t const   )448,      (flex_int16_t const   )449,      (flex_int16_t const   )450, 
        (flex_int16_t const   )451,      (flex_int16_t const   )453,      (flex_int16_t const   )455,      (flex_int16_t const   )457, 
        (flex_int16_t const   )458,      (flex_int16_t const   )460,      (flex_int16_t const   )461,      (flex_int16_t const   )463, 
        (flex_int16_t const   )463};
#line 463 "vhdl_flex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 463
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )6, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )18,      (flex_int32_t const   )18, 
        (flex_int32_t const   )18,      (flex_int32_t const   )18,      (flex_int32_t const   )20,      (flex_int32_t const   )21, 
        (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27, 
        (flex_int32_t const   )28,      (flex_int32_t const   )29,      (flex_int32_t const   )30,      (flex_int32_t const   )31, 
        (flex_int32_t const   )32,      (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35, 
        (flex_int32_t const   )36,      (flex_int32_t const   )37,      (flex_int32_t const   )38,      (flex_int32_t const   )39, 
        (flex_int32_t const   )40,      (flex_int32_t const   )34,      (flex_int32_t const   )41,      (flex_int32_t const   )42, 
        (flex_int32_t const   )43,      (flex_int32_t const   )44,      (flex_int32_t const   )45,      (flex_int32_t const   )46, 
        (flex_int32_t const   )47,      (flex_int32_t const   )48,      (flex_int32_t const   )49,      (flex_int32_t const   )9, 
        (flex_int32_t const   )1,      (flex_int32_t const   )9,      (flex_int32_t const   )1,      (flex_int32_t const   )50, 
        (flex_int32_t const   )1,      (flex_int32_t const   )51,      (flex_int32_t const   )52,      (flex_int32_t const   )53, 
        (flex_int32_t const   )54,      (flex_int32_t const   )55,      (flex_int32_t const   )56,      (flex_int32_t const   )57, 
        (flex_int32_t const   )58,      (flex_int32_t const   )59,      (flex_int32_t const   )34,      (flex_int32_t const   )60, 
        (flex_int32_t const   )61,      (flex_int32_t const   )62,      (flex_int32_t const   )63,      (flex_int32_t const   )64, 
        (flex_int32_t const   )65,      (flex_int32_t const   )34,      (flex_int32_t const   )66,      (flex_int32_t const   )67, 
        (flex_int32_t const   )68,      (flex_int32_t const   )69,      (flex_int32_t const   )70,      (flex_int32_t const   )71, 
        (flex_int32_t const   )72,      (flex_int32_t const   )73,      (flex_int32_t const   )74,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 495 "vhdl_flex.c"
static flex_int32_t const   yy_meta[75]  = 
#line 495
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3};
#line 507 "vhdl_flex.c"
static flex_int16_t const   yy_base[355]  = 
#line 507
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )49,      (flex_int16_t const   )51,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )100,      (flex_int16_t const   )0,      (flex_int16_t const   )522, 
        (flex_int16_t const   )823,      (flex_int16_t const   )489,      (flex_int16_t const   )823,      (flex_int16_t const   )475, 
        (flex_int16_t const   )823,      (flex_int16_t const   )823,      (flex_int16_t const   )823,      (flex_int16_t const   )823, 
        (flex_int16_t const   )823,      (flex_int16_t const   )823,      (flex_int16_t const   )414,      (flex_int16_t const   )823, 
        (flex_int16_t const   )103,      (flex_int16_t const   )78,      (flex_int16_t const   )385,      (flex_int16_t const   )823, 
        (flex_int16_t const   )353,      (flex_int16_t const   )95,      (flex_int16_t const   )118,      (flex_int16_t const   )50, 
        (flex_int16_t const   )42,      (flex_int16_t const   )48,      (flex_int16_t const   )58,      (flex_int16_t const   )99, 
        (flex_int16_t const   )0,      (flex_int16_t const   )138,      (flex_int16_t const   )140,      (flex_int16_t const   )102, 
        (flex_int16_t const   )156,      (flex_int16_t const   )161,      (flex_int16_t const   )150,      (flex_int16_t const   )169, 
        (flex_int16_t const   )45,      (flex_int16_t const   )177,      (flex_int16_t const   )188,      (flex_int16_t const   )167, 
        (flex_int16_t const   )187,      (flex_int16_t const   )214,      (flex_int16_t const   )0,      (flex_int16_t const   )204, 
        (flex_int16_t const   )236,      (flex_int16_t const   )213,      (flex_int16_t const   )236,      (flex_int16_t const   )254, 
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )286,      (flex_int16_t const   )103, 
        (flex_int16_t const   )310,      (flex_int16_t const   )168,      (flex_int16_t const   )362,      (flex_int16_t const   )318, 
        (flex_int16_t const   )823,      (flex_int16_t const   )0,      (flex_int16_t const   )317,      (flex_int16_t const   )325, 
        (flex_int16_t const   )333,      (flex_int16_t const   )313,      (flex_int16_t const   )823,      (flex_int16_t const   )823, 
        (flex_int16_t const   )0,      (flex_int16_t const   )63,      (flex_int16_t const   )170,      (flex_int16_t const   )170, 
        (flex_int16_t const   )191,      (flex_int16_t const   )236,      (flex_int16_t const   )172,      (flex_int16_t const   )211, 
        (flex_int16_t const   )233,      (flex_int16_t const   )239,      (flex_int16_t const   )247,      (flex_int16_t const   )325, 
        (flex_int16_t const   )260,      (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )0, 
        (flex_int16_t const   )321,      (flex_int16_t const   )315,      (flex_int16_t const   )0,      (flex_int16_t const   )319, 
        (flex_int16_t const   )336,      (flex_int16_t const   )317,      (flex_int16_t const   )328,      (flex_int16_t const   )328, 
        (flex_int16_t const   )329,      (flex_int16_t const   )346,      (flex_int16_t const   )343,      (flex_int16_t const   )347, 
        (flex_int16_t const   )350,      (flex_int16_t const   )0,      (flex_int16_t const   )327,      (flex_int16_t const   )338, 
        (flex_int16_t const   )351,      (flex_int16_t const   )390,      (flex_int16_t const   )379,      (flex_int16_t const   )359, 
        (flex_int16_t const   )371,      (flex_int16_t const   )371,      (flex_int16_t const   )373,      (flex_int16_t const   )373, 
        (flex_int16_t const   )384,      (flex_int16_t const   )377,      (flex_int16_t const   )375,      (flex_int16_t const   )381, 
        (flex_int16_t const   )396,      (flex_int16_t const   )381,      (flex_int16_t const   )387,      (flex_int16_t const   )392, 
        (flex_int16_t const   )394,      (flex_int16_t const   )404,      (flex_int16_t const   )407,      (flex_int16_t const   )0, 
        (flex_int16_t const   )449,      (flex_int16_t const   )0,      (flex_int16_t const   )425,      (flex_int16_t const   )416, 
        (flex_int16_t const   )266,      (flex_int16_t const   )411,      (flex_int16_t const   )428,      (flex_int16_t const   )433, 
        (flex_int16_t const   )431,      (flex_int16_t const   )434,      (flex_int16_t const   )429,      (flex_int16_t const   )434, 
        (flex_int16_t const   )0,      (flex_int16_t const   )441,      (flex_int16_t const   )435,      (flex_int16_t const   )446, 
        (flex_int16_t const   )436,      (flex_int16_t const   )446,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )448,      (flex_int16_t const   )443,      (flex_int16_t const   )263,      (flex_int16_t const   )445, 
        (flex_int16_t const   )456,      (flex_int16_t const   )459,      (flex_int16_t const   )453,      (flex_int16_t const   )455, 
        (flex_int16_t const   )259,      (flex_int16_t const   )465,      (flex_int16_t const   )460,      (flex_int16_t const   )470, 
        (flex_int16_t const   )478,      (flex_int16_t const   )0,      (flex_int16_t const   )476,      (flex_int16_t const   )484, 
        (flex_int16_t const   )477,      (flex_int16_t const   )470,      (flex_int16_t const   )483,      (flex_int16_t const   )492, 
        (flex_int16_t const   )483,      (flex_int16_t const   )493,      (flex_int16_t const   )0,      (flex_int16_t const   )498, 
        (flex_int16_t const   )500,      (flex_int16_t const   )0,      (flex_int16_t const   )504,      (flex_int16_t const   )492, 
        (flex_int16_t const   )0,      (flex_int16_t const   )495,      (flex_int16_t const   )548,      (flex_int16_t const   )488, 
        (flex_int16_t const   )509,      (flex_int16_t const   )501,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )255,      (flex_int16_t const   )514,      (flex_int16_t const   )212,      (flex_int16_t const   )506, 
        (flex_int16_t const   )507,      (flex_int16_t const   )508,      (flex_int16_t const   )525,      (flex_int16_t const   )529, 
        (flex_int16_t const   )529,      (flex_int16_t const   )548,      (flex_int16_t const   )552,      (flex_int16_t const   )545, 
        (flex_int16_t const   )544,      (flex_int16_t const   )0,      (flex_int16_t const   )539,      (flex_int16_t const   )550, 
        (flex_int16_t const   )542,      (flex_int16_t const   )559,      (flex_int16_t const   )241,      (flex_int16_t const   )548, 
        (flex_int16_t const   )539,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )547, 
        (flex_int16_t const   )554,      (flex_int16_t const   )549,      (flex_int16_t const   )548,      (flex_int16_t const   )551, 
        (flex_int16_t const   )552,      (flex_int16_t const   )550,      (flex_int16_t const   )555,      (flex_int16_t const   )556, 
        (flex_int16_t const   )559,      (flex_int16_t const   )569,      (flex_int16_t const   )573,      (flex_int16_t const   )0, 
        (flex_int16_t const   )621,      (flex_int16_t const   )627,      (flex_int16_t const   )0,      (flex_int16_t const   )596, 
        (flex_int16_t const   )595,      (flex_int16_t const   )598,      (flex_int16_t const   )588,      (flex_int16_t const   )597, 
        (flex_int16_t const   )606,      (flex_int16_t const   )594,      (flex_int16_t const   )599,      (flex_int16_t const   )0, 
        (flex_int16_t const   )616,      (flex_int16_t const   )0,      (flex_int16_t const   )620,      (flex_int16_t const   )621, 
        (flex_int16_t const   )628,      (flex_int16_t const   )634,      (flex_int16_t const   )627,      (flex_int16_t const   )0, 
        (flex_int16_t const   )633,      (flex_int16_t const   )627,      (flex_int16_t const   )234,      (flex_int16_t const   )633, 
        (flex_int16_t const   )626,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )628, 
        (flex_int16_t const   )0,      (flex_int16_t const   )630,      (flex_int16_t const   )624,      (flex_int16_t const   )627, 
        (flex_int16_t const   )195,      (flex_int16_t const   )628,      (flex_int16_t const   )630,      (flex_int16_t const   )632, 
        (flex_int16_t const   )647,      (flex_int16_t const   )635,      (flex_int16_t const   )653,      (flex_int16_t const   )635, 
        (flex_int16_t const   )0,      (flex_int16_t const   )645,      (flex_int16_t const   )646,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )662,      (flex_int16_t const   )668,      (flex_int16_t const   )671, 
        (flex_int16_t const   )676,      (flex_int16_t const   )663,      (flex_int16_t const   )660,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )222,      (flex_int16_t const   )0,      (flex_int16_t const   )681, 
        (flex_int16_t const   )676,      (flex_int16_t const   )688,      (flex_int16_t const   )685,      (flex_int16_t const   )118, 
        (flex_int16_t const   )683,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )675, 
        (flex_int16_t const   )0,      (flex_int16_t const   )676,      (flex_int16_t const   )677,      (flex_int16_t const   )678, 
        (flex_int16_t const   )694,      (flex_int16_t const   )686,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )695,      (flex_int16_t const   )152,      (flex_int16_t const   )696, 
        (flex_int16_t const   )182,      (flex_int16_t const   )0,      (flex_int16_t const   )691,      (flex_int16_t const   )697, 
        (flex_int16_t const   )134,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )696, 
        (flex_int16_t const   )691,      (flex_int16_t const   )0,      (flex_int16_t const   )709,      (flex_int16_t const   )702, 
        (flex_int16_t const   )719,      (flex_int16_t const   )713,      (flex_int16_t const   )0,      (flex_int16_t const   )128, 
        (flex_int16_t const   )711,      (flex_int16_t const   )0,      (flex_int16_t const   )98,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )716,      (flex_int16_t const   )0,      (flex_int16_t const   )718, 
        (flex_int16_t const   )0,      (flex_int16_t const   )721,      (flex_int16_t const   )725,      (flex_int16_t const   )0, 
        (flex_int16_t const   )725,      (flex_int16_t const   )724,      (flex_int16_t const   )121,      (flex_int16_t const   )730, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )727,      (flex_int16_t const   )716, 
        (flex_int16_t const   )729,      (flex_int16_t const   )116,      (flex_int16_t const   )735,      (flex_int16_t const   )739, 
        (flex_int16_t const   )738,      (flex_int16_t const   )740,      (flex_int16_t const   )93,      (flex_int16_t const   )731, 
        (flex_int16_t const   )742,      (flex_int16_t const   )35,      (flex_int16_t const   )744,      (flex_int16_t const   )525, 
        (flex_int16_t const   )0,      (flex_int16_t const   )745,      (flex_int16_t const   )747,      (flex_int16_t const   )754, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )764, 
        (flex_int16_t const   )0,      (flex_int16_t const   )751,      (flex_int16_t const   )0,      (flex_int16_t const   )823, 
        (flex_int16_t const   )816,      (flex_int16_t const   )77,      (flex_int16_t const   )819};
#line 550 "vhdl_flex.c"
static flex_int16_t const   yy_def[355]  = 
#line 550
  {      (flex_int16_t const   )0,      (flex_int16_t const   )351,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )9,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )352, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )351,      (flex_int16_t const   )352, 
        (flex_int16_t const   )351,      (flex_int16_t const   )354,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )354, 
        (flex_int16_t const   )351,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )351,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353, 
        (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )353,      (flex_int16_t const   )0, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351};
#line 593 "vhdl_flex.c"
static flex_int16_t const   yy_nxt[898]  = 
#line 593
  {      (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )12,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )26,      (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )12, 
        (flex_int16_t const   )20,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )31, 
        (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35, 
        (flex_int16_t const   )36,      (flex_int16_t const   )37,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )38,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )39, 
        (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )42,      (flex_int16_t const   )43, 
        (flex_int16_t const   )44,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )45, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )20,      (flex_int16_t const   )29, 
        (flex_int16_t const   )30,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )36,      (flex_int16_t const   )37, 
        (flex_int16_t const   )36,      (flex_int16_t const   )38,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )42, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )36,      (flex_int16_t const   )36, 
        (flex_int16_t const   )45,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )46, 
        (flex_int16_t const   )47,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )80, 
        (flex_int16_t const   )72,      (flex_int16_t const   )82,      (flex_int16_t const   )48,      (flex_int16_t const   )84, 
        (flex_int16_t const   )48,      (flex_int16_t const   )342,      (flex_int16_t const   )83,      (flex_int16_t const   )104, 
        (flex_int16_t const   )49,      (flex_int16_t const   )81,      (flex_int16_t const   )49,      (flex_int16_t const   )66, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )50,      (flex_int16_t const   )125, 
        (flex_int16_t const   )50,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )46, 
        (flex_int16_t const   )47,      (flex_int16_t const   )80,      (flex_int16_t const   )82,      (flex_int16_t const   )339, 
        (flex_int16_t const   )48,      (flex_int16_t const   )84,      (flex_int16_t const   )48,      (flex_int16_t const   )83, 
        (flex_int16_t const   )104,      (flex_int16_t const   )49,      (flex_int16_t const   )81,      (flex_int16_t const   )49, 
        (flex_int16_t const   )66,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )50, 
        (flex_int16_t const   )125,      (flex_int16_t const   )50,      (flex_int16_t const   )51,      (flex_int16_t const   )52, 
        (flex_int16_t const   )85,      (flex_int16_t const   )53,      (flex_int16_t const   )334,      (flex_int16_t const   )73, 
        (flex_int16_t const   )90,      (flex_int16_t const   )54,      (flex_int16_t const   )297,      (flex_int16_t const   )298, 
        (flex_int16_t const   )74,      (flex_int16_t const   )329,      (flex_int16_t const   )75,      (flex_int16_t const   )55, 
        (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )58,      (flex_int16_t const   )121, 
        (flex_int16_t const   )59,      (flex_int16_t const   )104,      (flex_int16_t const   )91,      (flex_int16_t const   )60, 
        (flex_int16_t const   )322,      (flex_int16_t const   )61,      (flex_int16_t const   )69,      (flex_int16_t const   )76, 
        (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )85,      (flex_int16_t const   )53, 
        (flex_int16_t const   )73,      (flex_int16_t const   )77,      (flex_int16_t const   )90,      (flex_int16_t const   )54, 
        (flex_int16_t const   )78,      (flex_int16_t const   )74,      (flex_int16_t const   )79,      (flex_int16_t const   )75, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )58, 
        (flex_int16_t const   )121,      (flex_int16_t const   )59,      (flex_int16_t const   )104,      (flex_int16_t const   )91, 
        (flex_int16_t const   )60,      (flex_int16_t const   )88,      (flex_int16_t const   )61,      (flex_int16_t const   )69, 
        (flex_int16_t const   )86,      (flex_int16_t const   )76,      (flex_int16_t const   )320,      (flex_int16_t const   )89, 
        (flex_int16_t const   )87,      (flex_int16_t const   )92,      (flex_int16_t const   )77,      (flex_int16_t const   )98, 
        (flex_int16_t const   )313,      (flex_int16_t const   )78,      (flex_int16_t const   )96,      (flex_int16_t const   )79, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )97,      (flex_int16_t const   )105, 
        (flex_int16_t const   )105,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )95, 
        (flex_int16_t const   )80,      (flex_int16_t const   )122,      (flex_int16_t const   )310,      (flex_int16_t const   )88, 
        (flex_int16_t const   )131,      (flex_int16_t const   )86,      (flex_int16_t const   )308,      (flex_int16_t const   )107, 
        (flex_int16_t const   )89,      (flex_int16_t const   )87,      (flex_int16_t const   )108,      (flex_int16_t const   )92, 
        (flex_int16_t const   )101,      (flex_int16_t const   )98,      (flex_int16_t const   )102,      (flex_int16_t const   )126, 
        (flex_int16_t const   )96,      (flex_int16_t const   )127,      (flex_int16_t const   )93,      (flex_int16_t const   )94, 
        (flex_int16_t const   )97,      (flex_int16_t const   )103,      (flex_int16_t const   )99,      (flex_int16_t const   )100, 
        (flex_int16_t const   )95,      (flex_int16_t const   )106,      (flex_int16_t const   )80,      (flex_int16_t const   )122, 
        (flex_int16_t const   )105,      (flex_int16_t const   )109,      (flex_int16_t const   )131,      (flex_int16_t const   )77, 
        (flex_int16_t const   )107,      (flex_int16_t const   )87,      (flex_int16_t const   )78,      (flex_int16_t const   )108, 
        (flex_int16_t const   )79,      (flex_int16_t const   )101,      (flex_int16_t const   )128,      (flex_int16_t const   )102, 
        (flex_int16_t const   )126,      (flex_int16_t const   )112,      (flex_int16_t const   )127,      (flex_int16_t const   )292, 
        (flex_int16_t const   )110,      (flex_int16_t const   )132,      (flex_int16_t const   )103,      (flex_int16_t const   )77, 
        (flex_int16_t const   )90,      (flex_int16_t const   )276,      (flex_int16_t const   )78,      (flex_int16_t const   )106, 
        (flex_int16_t const   )79,      (flex_int16_t const   )105,      (flex_int16_t const   )109,      (flex_int16_t const   )83, 
        (flex_int16_t const   )77,      (flex_int16_t const   )269,      (flex_int16_t const   )87,      (flex_int16_t const   )78, 
        (flex_int16_t const   )238,      (flex_int16_t const   )79,      (flex_int16_t const   )111,      (flex_int16_t const   )128, 
        (flex_int16_t const   )114,      (flex_int16_t const   )113,      (flex_int16_t const   )223,      (flex_int16_t const   )112, 
        (flex_int16_t const   )129,      (flex_int16_t const   )80,      (flex_int16_t const   )110,      (flex_int16_t const   )132, 
        (flex_int16_t const   )77,      (flex_int16_t const   )133,      (flex_int16_t const   )90,      (flex_int16_t const   )78, 
        (flex_int16_t const   )107,      (flex_int16_t const   )79,      (flex_int16_t const   )115,      (flex_int16_t const   )108, 
        (flex_int16_t const   )83,      (flex_int16_t const   )134,      (flex_int16_t const   )87,      (flex_int16_t const   )130, 
        (flex_int16_t const   )110,      (flex_int16_t const   )92,      (flex_int16_t const   )96,      (flex_int16_t const   )111, 
        (flex_int16_t const   )90,      (flex_int16_t const   )114,      (flex_int16_t const   )97,      (flex_int16_t const   )113, 
        (flex_int16_t const   )93,      (flex_int16_t const   )117,      (flex_int16_t const   )129,      (flex_int16_t const   )80, 
        (flex_int16_t const   )116,      (flex_int16_t const   )135,      (flex_int16_t const   )133,      (flex_int16_t const   )118, 
        (flex_int16_t const   )138,      (flex_int16_t const   )107,      (flex_int16_t const   )111,      (flex_int16_t const   )115, 
        (flex_int16_t const   )108,      (flex_int16_t const   )119,      (flex_int16_t const   )134,      (flex_int16_t const   )87, 
        (flex_int16_t const   )130,      (flex_int16_t const   )221,      (flex_int16_t const   )110,      (flex_int16_t const   )92, 
        (flex_int16_t const   )96,      (flex_int16_t const   )198,      (flex_int16_t const   )90,      (flex_int16_t const   )120, 
        (flex_int16_t const   )97,      (flex_int16_t const   )192,      (flex_int16_t const   )93,      (flex_int16_t const   )117, 
        (flex_int16_t const   )177,      (flex_int16_t const   )116,      (flex_int16_t const   )135,      (flex_int16_t const   )98, 
        (flex_int16_t const   )118,      (flex_int16_t const   )138,      (flex_int16_t const   )64,      (flex_int16_t const   )111, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )119,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )120,      (flex_int16_t const   )66,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )98,      (flex_int16_t const   )66,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )136,      (flex_int16_t const   )99,      (flex_int16_t const   )100, 
        (flex_int16_t const   )139,      (flex_int16_t const   )105,      (flex_int16_t const   )140,      (flex_int16_t const   )141, 
        (flex_int16_t const   )69,      (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )144, 
        (flex_int16_t const   )62,      (flex_int16_t const   )145,      (flex_int16_t const   )146,      (flex_int16_t const   )149, 
        (flex_int16_t const   )137,      (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )155, 
        (flex_int16_t const   )69,      (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )152, 
        (flex_int16_t const   )154,      (flex_int16_t const   )71,      (flex_int16_t const   )156,      (flex_int16_t const   )136, 
        (flex_int16_t const   )157,      (flex_int16_t const   )139,      (flex_int16_t const   )105,      (flex_int16_t const   )140, 
        (flex_int16_t const   )141,      (flex_int16_t const   )69,      (flex_int16_t const   )142,      (flex_int16_t const   )143, 
        (flex_int16_t const   )153,      (flex_int16_t const   )144,      (flex_int16_t const   )145,      (flex_int16_t const   )146, 
        (flex_int16_t const   )149,      (flex_int16_t const   )137,      (flex_int16_t const   )147,      (flex_int16_t const   )148, 
        (flex_int16_t const   )155,      (flex_int16_t const   )69,      (flex_int16_t const   )159,      (flex_int16_t const   )150, 
        (flex_int16_t const   )151,      (flex_int16_t const   )152,      (flex_int16_t const   )154,      (flex_int16_t const   )156, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )157,      (flex_int16_t const   )158, 
        (flex_int16_t const   )70,      (flex_int16_t const   )160,      (flex_int16_t const   )140,      (flex_int16_t const   )161, 
        (flex_int16_t const   )165,      (flex_int16_t const   )153,      (flex_int16_t const   )162,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )166,      (flex_int16_t const   )167,      (flex_int16_t const   )146, 
        (flex_int16_t const   )140,      (flex_int16_t const   )161,      (flex_int16_t const   )128,      (flex_int16_t const   )159, 
        (flex_int16_t const   )168,      (flex_int16_t const   )169,      (flex_int16_t const   )65,      (flex_int16_t const   )128, 
        (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )170,      (flex_int16_t const   )171, 
        (flex_int16_t const   )172,      (flex_int16_t const   )158,      (flex_int16_t const   )160,      (flex_int16_t const   )140, 
        (flex_int16_t const   )161,      (flex_int16_t const   )105,      (flex_int16_t const   )165,      (flex_int16_t const   )162, 
        (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )166,      (flex_int16_t const   )167, 
        (flex_int16_t const   )146,      (flex_int16_t const   )140,      (flex_int16_t const   )161,      (flex_int16_t const   )128, 
        (flex_int16_t const   )173,      (flex_int16_t const   )168,      (flex_int16_t const   )175,      (flex_int16_t const   )169, 
        (flex_int16_t const   )128,      (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )176,      (flex_int16_t const   )172,      (flex_int16_t const   )178, 
        (flex_int16_t const   )179,      (flex_int16_t const   )181,      (flex_int16_t const   )105,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )180,      (flex_int16_t const   )182,      (flex_int16_t const   )183, 
        (flex_int16_t const   )184,      (flex_int16_t const   )173,      (flex_int16_t const   )185,      (flex_int16_t const   )187, 
        (flex_int16_t const   )175,      (flex_int16_t const   )186,      (flex_int16_t const   )174,      (flex_int16_t const   )64, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )176,      (flex_int16_t const   )190, 
        (flex_int16_t const   )178,      (flex_int16_t const   )191,      (flex_int16_t const   )179,      (flex_int16_t const   )181, 
        (flex_int16_t const   )193,      (flex_int16_t const   )194,      (flex_int16_t const   )195,      (flex_int16_t const   )62, 
        (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )180,      (flex_int16_t const   )182, 
        (flex_int16_t const   )183,      (flex_int16_t const   )184,      (flex_int16_t const   )199,      (flex_int16_t const   )201, 
        (flex_int16_t const   )185,      (flex_int16_t const   )187,      (flex_int16_t const   )186,      (flex_int16_t const   )200, 
        (flex_int16_t const   )174,      (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )202, 
        (flex_int16_t const   )190,      (flex_int16_t const   )203,      (flex_int16_t const   )191,      (flex_int16_t const   )204, 
        (flex_int16_t const   )207,      (flex_int16_t const   )193,      (flex_int16_t const   )206,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )183, 
        (flex_int16_t const   )205,      (flex_int16_t const   )208,      (flex_int16_t const   )351,      (flex_int16_t const   )209, 
        (flex_int16_t const   )199,      (flex_int16_t const   )201,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )200,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )351, 
        (flex_int16_t const   )214,      (flex_int16_t const   )202,      (flex_int16_t const   )215,      (flex_int16_t const   )203, 
        (flex_int16_t const   )218,      (flex_int16_t const   )204,      (flex_int16_t const   )207,      (flex_int16_t const   )206, 
        (flex_int16_t const   )344,      (flex_int16_t const   )345,      (flex_int16_t const   )219,      (flex_int16_t const   )222, 
        (flex_int16_t const   )183,      (flex_int16_t const   )205,      (flex_int16_t const   )220,      (flex_int16_t const   )208, 
        (flex_int16_t const   )209,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )226, 
        (flex_int16_t const   )210,      (flex_int16_t const   )211,      (flex_int16_t const   )227,      (flex_int16_t const   )212, 
        (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )216,      (flex_int16_t const   )215, 
        (flex_int16_t const   )216,      (flex_int16_t const   )218,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )219,      (flex_int16_t const   )222,      (flex_int16_t const   )228,      (flex_int16_t const   )220, 
        (flex_int16_t const   )229,      (flex_int16_t const   )230,      (flex_int16_t const   )224,      (flex_int16_t const   )225, 
        (flex_int16_t const   )226,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )235, 
        (flex_int16_t const   )227,      (flex_int16_t const   )233,      (flex_int16_t const   )234,      (flex_int16_t const   )236, 
        (flex_int16_t const   )237,      (flex_int16_t const   )351,      (flex_int16_t const   )239,      (flex_int16_t const   )240, 
        (flex_int16_t const   )241,      (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )244, 
        (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247,      (flex_int16_t const   )228, 
        (flex_int16_t const   )248,      (flex_int16_t const   )229,      (flex_int16_t const   )249,      (flex_int16_t const   )230, 
        (flex_int16_t const   )245,      (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )231, 
        (flex_int16_t const   )232,      (flex_int16_t const   )235,      (flex_int16_t const   )233,      (flex_int16_t const   )234, 
        (flex_int16_t const   )236,      (flex_int16_t const   )252,      (flex_int16_t const   )237,      (flex_int16_t const   )239, 
        (flex_int16_t const   )240,      (flex_int16_t const   )241,      (flex_int16_t const   )242,      (flex_int16_t const   )243, 
        (flex_int16_t const   )244,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )351,      (flex_int16_t const   )248,      (flex_int16_t const   )253,      (flex_int16_t const   )249, 
        (flex_int16_t const   )254,      (flex_int16_t const   )245,      (flex_int16_t const   )250,      (flex_int16_t const   )255, 
        (flex_int16_t const   )251,      (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )258, 
        (flex_int16_t const   )351,      (flex_int16_t const   )259,      (flex_int16_t const   )252,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )260, 
        (flex_int16_t const   )253,      (flex_int16_t const   )261,      (flex_int16_t const   )254,      (flex_int16_t const   )262, 
        (flex_int16_t const   )263,      (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )264, 
        (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )265, 
        (flex_int16_t const   )266,      (flex_int16_t const   )267,      (flex_int16_t const   )351,      (flex_int16_t const   )268, 
        (flex_int16_t const   )270,      (flex_int16_t const   )351,      (flex_int16_t const   )271,      (flex_int16_t const   )272, 
        (flex_int16_t const   )273,      (flex_int16_t const   )274,      (flex_int16_t const   )275,      (flex_int16_t const   )277, 
        (flex_int16_t const   )260,      (flex_int16_t const   )278,      (flex_int16_t const   )279,      (flex_int16_t const   )261, 
        (flex_int16_t const   )280,      (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )281, 
        (flex_int16_t const   )282,      (flex_int16_t const   )264,      (flex_int16_t const   )283,      (flex_int16_t const   )284, 
        (flex_int16_t const   )285,      (flex_int16_t const   )265,      (flex_int16_t const   )266,      (flex_int16_t const   )267, 
        (flex_int16_t const   )268,      (flex_int16_t const   )286,      (flex_int16_t const   )270,      (flex_int16_t const   )271, 
        (flex_int16_t const   )272,      (flex_int16_t const   )273,      (flex_int16_t const   )274,      (flex_int16_t const   )275, 
        (flex_int16_t const   )277,      (flex_int16_t const   )287,      (flex_int16_t const   )278,      (flex_int16_t const   )279, 
        (flex_int16_t const   )288,      (flex_int16_t const   )289,      (flex_int16_t const   )280,      (flex_int16_t const   )290, 
        (flex_int16_t const   )281,      (flex_int16_t const   )291,      (flex_int16_t const   )282,      (flex_int16_t const   )283, 
        (flex_int16_t const   )284,      (flex_int16_t const   )285,      (flex_int16_t const   )293,      (flex_int16_t const   )351, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )286, 
        (flex_int16_t const   )299,      (flex_int16_t const   )351,      (flex_int16_t const   )301,      (flex_int16_t const   )302, 
        (flex_int16_t const   )303,      (flex_int16_t const   )304,      (flex_int16_t const   )300,      (flex_int16_t const   )287, 
        (flex_int16_t const   )305,      (flex_int16_t const   )309,      (flex_int16_t const   )288,      (flex_int16_t const   )289, 
        (flex_int16_t const   )290,      (flex_int16_t const   )306,      (flex_int16_t const   )291,      (flex_int16_t const   )307, 
        (flex_int16_t const   )311,      (flex_int16_t const   )312,      (flex_int16_t const   )314,      (flex_int16_t const   )315, 
        (flex_int16_t const   )293,      (flex_int16_t const   )294,      (flex_int16_t const   )316,      (flex_int16_t const   )295, 
        (flex_int16_t const   )296,      (flex_int16_t const   )317,      (flex_int16_t const   )299,      (flex_int16_t const   )301, 
        (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )304,      (flex_int16_t const   )300, 
        (flex_int16_t const   )318,      (flex_int16_t const   )332,      (flex_int16_t const   )305,      (flex_int16_t const   )309, 
        (flex_int16_t const   )319,      (flex_int16_t const   )321,      (flex_int16_t const   )306,      (flex_int16_t const   )323, 
        (flex_int16_t const   )307,      (flex_int16_t const   )311,      (flex_int16_t const   )312,      (flex_int16_t const   )314, 
        (flex_int16_t const   )315,      (flex_int16_t const   )324,      (flex_int16_t const   )325,      (flex_int16_t const   )326, 
        (flex_int16_t const   )316,      (flex_int16_t const   )327,      (flex_int16_t const   )317,      (flex_int16_t const   )328, 
        (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )335, 
        (flex_int16_t const   )336,      (flex_int16_t const   )338,      (flex_int16_t const   )318,      (flex_int16_t const   )332, 
        (flex_int16_t const   )337,      (flex_int16_t const   )319,      (flex_int16_t const   )321,      (flex_int16_t const   )340, 
        (flex_int16_t const   )323,      (flex_int16_t const   )341,      (flex_int16_t const   )343,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )324,      (flex_int16_t const   )325, 
        (flex_int16_t const   )326,      (flex_int16_t const   )349,      (flex_int16_t const   )327,      (flex_int16_t const   )350, 
        (flex_int16_t const   )328,      (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )333, 
        (flex_int16_t const   )335,      (flex_int16_t const   )351,      (flex_int16_t const   )336,      (flex_int16_t const   )338, 
        (flex_int16_t const   )351,      (flex_int16_t const   )337,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )340,      (flex_int16_t const   )351,      (flex_int16_t const   )341,      (flex_int16_t const   )343, 
        (flex_int16_t const   )346,      (flex_int16_t const   )347,      (flex_int16_t const   )351,      (flex_int16_t const   )348, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )349, 
        (flex_int16_t const   )350,      (flex_int16_t const   )63,      (flex_int16_t const   )351,      (flex_int16_t const   )63, 
        (flex_int16_t const   )123,      (flex_int16_t const   )351,      (flex_int16_t const   )123,      (flex_int16_t const   )11, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351};
#line 696 "vhdl_flex.c"
static flex_int16_t const   yy_chk[898]  = 
#line 696
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )5, 
        (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )6,      (flex_int16_t const   )31, 
        (flex_int16_t const   )353,      (flex_int16_t const   )32,      (flex_int16_t const   )5,      (flex_int16_t const   )34, 
        (flex_int16_t const   )6,      (flex_int16_t const   )337,      (flex_int16_t const   )33,      (flex_int16_t const   )44, 
        (flex_int16_t const   )5,      (flex_int16_t const   )31,      (flex_int16_t const   )6,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )5,      (flex_int16_t const   )73, 
        (flex_int16_t const   )6,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )334, 
        (flex_int16_t const   )5,      (flex_int16_t const   )34,      (flex_int16_t const   )6,      (flex_int16_t const   )33, 
        (flex_int16_t const   )44,      (flex_int16_t const   )5,      (flex_int16_t const   )31,      (flex_int16_t const   )6, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )5, 
        (flex_int16_t const   )73,      (flex_int16_t const   )6,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )35,      (flex_int16_t const   )9,      (flex_int16_t const   )329,      (flex_int16_t const   )29, 
        (flex_int16_t const   )39,      (flex_int16_t const   )9,      (flex_int16_t const   )275,      (flex_int16_t const   )275, 
        (flex_int16_t const   )29,      (flex_int16_t const   )322,      (flex_int16_t const   )29,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )59, 
        (flex_int16_t const   )9,      (flex_int16_t const   )59,      (flex_int16_t const   )39,      (flex_int16_t const   )9, 
        (flex_int16_t const   )310,      (flex_int16_t const   )9,      (flex_int16_t const   )24,      (flex_int16_t const   )30, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )35,      (flex_int16_t const   )9, 
        (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )39,      (flex_int16_t const   )9, 
        (flex_int16_t const   )30,      (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )29, 
        (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9,      (flex_int16_t const   )9, 
        (flex_int16_t const   )59,      (flex_int16_t const   )9,      (flex_int16_t const   )59,      (flex_int16_t const   )39, 
        (flex_int16_t const   )9,      (flex_int16_t const   )38,      (flex_int16_t const   )9,      (flex_int16_t const   )24, 
        (flex_int16_t const   )37,      (flex_int16_t const   )30,      (flex_int16_t const   )307,      (flex_int16_t const   )38, 
        (flex_int16_t const   )37,      (flex_int16_t const   )40,      (flex_int16_t const   )30,      (flex_int16_t const   )42, 
        (flex_int16_t const   )296,      (flex_int16_t const   )30,      (flex_int16_t const   )41,      (flex_int16_t const   )30, 
        (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )41,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )40, 
        (flex_int16_t const   )47,      (flex_int16_t const   )61,      (flex_int16_t const   )292,      (flex_int16_t const   )38, 
        (flex_int16_t const   )78,      (flex_int16_t const   )37,      (flex_int16_t const   )290,      (flex_int16_t const   )47, 
        (flex_int16_t const   )38,      (flex_int16_t const   )37,      (flex_int16_t const   )47,      (flex_int16_t const   )40, 
        (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )74, 
        (flex_int16_t const   )41,      (flex_int16_t const   )75,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )41,      (flex_int16_t const   )43,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )40,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )61, 
        (flex_int16_t const   )45,      (flex_int16_t const   )48,      (flex_int16_t const   )78,      (flex_int16_t const   )46, 
        (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )46,      (flex_int16_t const   )47, 
        (flex_int16_t const   )46,      (flex_int16_t const   )43,      (flex_int16_t const   )76,      (flex_int16_t const   )43, 
        (flex_int16_t const   )74,      (flex_int16_t const   )51,      (flex_int16_t const   )75,      (flex_int16_t const   )269, 
        (flex_int16_t const   )49,      (flex_int16_t const   )79,      (flex_int16_t const   )43,      (flex_int16_t const   )51, 
        (flex_int16_t const   )49,      (flex_int16_t const   )248,      (flex_int16_t const   )51,      (flex_int16_t const   )46, 
        (flex_int16_t const   )51,      (flex_int16_t const   )45,      (flex_int16_t const   )48,      (flex_int16_t const   )53, 
        (flex_int16_t const   )46,      (flex_int16_t const   )238,      (flex_int16_t const   )48,      (flex_int16_t const   )46, 
        (flex_int16_t const   )198,      (flex_int16_t const   )46,      (flex_int16_t const   )49,      (flex_int16_t const   )76, 
        (flex_int16_t const   )53,      (flex_int16_t const   )52,      (flex_int16_t const   )182,      (flex_int16_t const   )51, 
        (flex_int16_t const   )77,      (flex_int16_t const   )52,      (flex_int16_t const   )49,      (flex_int16_t const   )79, 
        (flex_int16_t const   )51,      (flex_int16_t const   )80,      (flex_int16_t const   )49,      (flex_int16_t const   )51, 
        (flex_int16_t const   )52,      (flex_int16_t const   )51,      (flex_int16_t const   )54,      (flex_int16_t const   )52, 
        (flex_int16_t const   )53,      (flex_int16_t const   )81,      (flex_int16_t const   )54,      (flex_int16_t const   )77, 
        (flex_int16_t const   )55,      (flex_int16_t const   )56,      (flex_int16_t const   )57,      (flex_int16_t const   )49, 
        (flex_int16_t const   )55,      (flex_int16_t const   )53,      (flex_int16_t const   )57,      (flex_int16_t const   )52, 
        (flex_int16_t const   )56,      (flex_int16_t const   )56,      (flex_int16_t const   )77,      (flex_int16_t const   )52, 
        (flex_int16_t const   )55,      (flex_int16_t const   )82,      (flex_int16_t const   )80,      (flex_int16_t const   )56, 
        (flex_int16_t const   )84,      (flex_int16_t const   )52,      (flex_int16_t const   )55,      (flex_int16_t const   )54, 
        (flex_int16_t const   )52,      (flex_int16_t const   )57,      (flex_int16_t const   )81,      (flex_int16_t const   )54, 
        (flex_int16_t const   )77,      (flex_int16_t const   )180,      (flex_int16_t const   )55,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )152,      (flex_int16_t const   )55,      (flex_int16_t const   )58, 
        (flex_int16_t const   )57,      (flex_int16_t const   )146,      (flex_int16_t const   )56,      (flex_int16_t const   )56, 
        (flex_int16_t const   )128,      (flex_int16_t const   )55,      (flex_int16_t const   )82,      (flex_int16_t const   )58, 
        (flex_int16_t const   )56,      (flex_int16_t const   )84,      (flex_int16_t const   )63,      (flex_int16_t const   )55, 
        (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )57,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )58,      (flex_int16_t const   )58,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66,      (flex_int16_t const   )66, 
        (flex_int16_t const   )66,      (flex_int16_t const   )58,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67,      (flex_int16_t const   )67, 
        (flex_int16_t const   )67,      (flex_int16_t const   )58,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68,      (flex_int16_t const   )68, 
        (flex_int16_t const   )68,      (flex_int16_t const   )83,      (flex_int16_t const   )58,      (flex_int16_t const   )58, 
        (flex_int16_t const   )85,      (flex_int16_t const   )60,      (flex_int16_t const   )86,      (flex_int16_t const   )88, 
        (flex_int16_t const   )69,      (flex_int16_t const   )89,      (flex_int16_t const   )91,      (flex_int16_t const   )92, 
        (flex_int16_t const   )62,      (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )96, 
        (flex_int16_t const   )83,      (flex_int16_t const   )95,      (flex_int16_t const   )95,      (flex_int16_t const   )102, 
        (flex_int16_t const   )67,      (flex_int16_t const   )97,      (flex_int16_t const   )98,      (flex_int16_t const   )99, 
        (flex_int16_t const   )100,      (flex_int16_t const   )28,      (flex_int16_t const   )103,      (flex_int16_t const   )83, 
        (flex_int16_t const   )104,      (flex_int16_t const   )85,      (flex_int16_t const   )60,      (flex_int16_t const   )86, 
        (flex_int16_t const   )88,      (flex_int16_t const   )69,      (flex_int16_t const   )89,      (flex_int16_t const   )91, 
        (flex_int16_t const   )99,      (flex_int16_t const   )92,      (flex_int16_t const   )93,      (flex_int16_t const   )94, 
        (flex_int16_t const   )96,      (flex_int16_t const   )83,      (flex_int16_t const   )95,      (flex_int16_t const   )95, 
        (flex_int16_t const   )102,      (flex_int16_t const   )67,      (flex_int16_t const   )107,      (flex_int16_t const   )97, 
        (flex_int16_t const   )98,      (flex_int16_t const   )99,      (flex_int16_t const   )100,      (flex_int16_t const   )103, 
        (flex_int16_t const   )105,      (flex_int16_t const   )105,      (flex_int16_t const   )104,      (flex_int16_t const   )106, 
        (flex_int16_t const   )26,      (flex_int16_t const   )108,      (flex_int16_t const   )109,      (flex_int16_t const   )109, 
        (flex_int16_t const   )112,      (flex_int16_t const   )99,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )117, 
        (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )106,      (flex_int16_t const   )107, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )22,      (flex_int16_t const   )112, 
        (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )120, 
        (flex_int16_t const   )121,      (flex_int16_t const   )106,      (flex_int16_t const   )108,      (flex_int16_t const   )109, 
        (flex_int16_t const   )109,      (flex_int16_t const   )105,      (flex_int16_t const   )112,      (flex_int16_t const   )109, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )114, 
        (flex_int16_t const   )117,      (flex_int16_t const   )115,      (flex_int16_t const   )115,      (flex_int16_t const   )106, 
        (flex_int16_t const   )122,      (flex_int16_t const   )115,      (flex_int16_t const   )126,      (flex_int16_t const   )116, 
        (flex_int16_t const   )112,      (flex_int16_t const   )118,      (flex_int16_t const   )118,      (flex_int16_t const   )119, 
        (flex_int16_t const   )120,      (flex_int16_t const   )127,      (flex_int16_t const   )121,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )132,      (flex_int16_t const   )105,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124,      (flex_int16_t const   )124, 
        (flex_int16_t const   )124,      (flex_int16_t const   )131,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )122,      (flex_int16_t const   )137,      (flex_int16_t const   )139, 
        (flex_int16_t const   )126,      (flex_int16_t const   )138,      (flex_int16_t const   )124,      (flex_int16_t const   )15, 
        (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )127,      (flex_int16_t const   )144, 
        (flex_int16_t const   )129,      (flex_int16_t const   )145,      (flex_int16_t const   )130,      (flex_int16_t const   )132, 
        (flex_int16_t const   )147,      (flex_int16_t const   )148,      (flex_int16_t const   )149,      (flex_int16_t const   )13, 
        (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )131,      (flex_int16_t const   )133, 
        (flex_int16_t const   )134,      (flex_int16_t const   )135,      (flex_int16_t const   )153,      (flex_int16_t const   )155, 
        (flex_int16_t const   )137,      (flex_int16_t const   )139,      (flex_int16_t const   )138,      (flex_int16_t const   )154, 
        (flex_int16_t const   )124,      (flex_int16_t const   )140,      (flex_int16_t const   )141,      (flex_int16_t const   )156, 
        (flex_int16_t const   )144,      (flex_int16_t const   )158,      (flex_int16_t const   )145,      (flex_int16_t const   )159, 
        (flex_int16_t const   )162,      (flex_int16_t const   )147,      (flex_int16_t const   )161,      (flex_int16_t const   )148, 
        (flex_int16_t const   )149,      (flex_int16_t const   )150,      (flex_int16_t const   )151,      (flex_int16_t const   )160, 
        (flex_int16_t const   )160,      (flex_int16_t const   )163,      (flex_int16_t const   )11,      (flex_int16_t const   )164, 
        (flex_int16_t const   )153,      (flex_int16_t const   )155,      (flex_int16_t const   )165,      (flex_int16_t const   )167, 
        (flex_int16_t const   )154,      (flex_int16_t const   )168,      (flex_int16_t const   )170,      (flex_int16_t const   )0, 
        (flex_int16_t const   )171,      (flex_int16_t const   )156,      (flex_int16_t const   )173,      (flex_int16_t const   )158, 
        (flex_int16_t const   )175,      (flex_int16_t const   )159,      (flex_int16_t const   )162,      (flex_int16_t const   )161, 
        (flex_int16_t const   )339,      (flex_int16_t const   )339,      (flex_int16_t const   )176,      (flex_int16_t const   )181, 
        (flex_int16_t const   )160,      (flex_int16_t const   )160,      (flex_int16_t const   )177,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )183,      (flex_int16_t const   )184,      (flex_int16_t const   )185, 
        (flex_int16_t const   )165,      (flex_int16_t const   )167,      (flex_int16_t const   )186,      (flex_int16_t const   )168, 
        (flex_int16_t const   )170,      (flex_int16_t const   )171,      (flex_int16_t const   )174,      (flex_int16_t const   )173, 
        (flex_int16_t const   )174,      (flex_int16_t const   )175,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174,      (flex_int16_t const   )174, 
        (flex_int16_t const   )176,      (flex_int16_t const   )181,      (flex_int16_t const   )187,      (flex_int16_t const   )177, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )183,      (flex_int16_t const   )184, 
        (flex_int16_t const   )185,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )195, 
        (flex_int16_t const   )186,      (flex_int16_t const   )192,      (flex_int16_t const   )194,      (flex_int16_t const   )196, 
        (flex_int16_t const   )197,      (flex_int16_t const   )0,      (flex_int16_t const   )199,      (flex_int16_t const   )200, 
        (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205,      (flex_int16_t const   )206, 
        (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )187, 
        (flex_int16_t const   )210,      (flex_int16_t const   )188,      (flex_int16_t const   )211,      (flex_int16_t const   )189, 
        (flex_int16_t const   )212,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )190, 
        (flex_int16_t const   )191,      (flex_int16_t const   )195,      (flex_int16_t const   )192,      (flex_int16_t const   )194, 
        (flex_int16_t const   )196,      (flex_int16_t const   )214,      (flex_int16_t const   )197,      (flex_int16_t const   )199, 
        (flex_int16_t const   )200,      (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205, 
        (flex_int16_t const   )206,      (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209, 
        (flex_int16_t const   )0,      (flex_int16_t const   )210,      (flex_int16_t const   )219,      (flex_int16_t const   )211, 
        (flex_int16_t const   )220,      (flex_int16_t const   )212,      (flex_int16_t const   )212,      (flex_int16_t const   )221, 
        (flex_int16_t const   )213,      (flex_int16_t const   )222,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )0,      (flex_int16_t const   )225,      (flex_int16_t const   )214,      (flex_int16_t const   )216, 
        (flex_int16_t const   )216,      (flex_int16_t const   )216,      (flex_int16_t const   )216,      (flex_int16_t const   )216, 
        (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217, 
        (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )217,      (flex_int16_t const   )226, 
        (flex_int16_t const   )219,      (flex_int16_t const   )228,      (flex_int16_t const   )220,      (flex_int16_t const   )230, 
        (flex_int16_t const   )231,      (flex_int16_t const   )221,      (flex_int16_t const   )222,      (flex_int16_t const   )232, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )233, 
        (flex_int16_t const   )234,      (flex_int16_t const   )236,      (flex_int16_t const   )0,      (flex_int16_t const   )237, 
        (flex_int16_t const   )239,      (flex_int16_t const   )0,      (flex_int16_t const   )240,      (flex_int16_t const   )243, 
        (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247,      (flex_int16_t const   )249, 
        (flex_int16_t const   )226,      (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )228, 
        (flex_int16_t const   )252,      (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )253, 
        (flex_int16_t const   )254,      (flex_int16_t const   )232,      (flex_int16_t const   )255,      (flex_int16_t const   )257, 
        (flex_int16_t const   )258,      (flex_int16_t const   )233,      (flex_int16_t const   )234,      (flex_int16_t const   )236, 
        (flex_int16_t const   )237,      (flex_int16_t const   )261,      (flex_int16_t const   )239,      (flex_int16_t const   )240, 
        (flex_int16_t const   )243,      (flex_int16_t const   )245,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )249,      (flex_int16_t const   )262,      (flex_int16_t const   )250,      (flex_int16_t const   )251, 
        (flex_int16_t const   )263,      (flex_int16_t const   )264,      (flex_int16_t const   )252,      (flex_int16_t const   )265, 
        (flex_int16_t const   )253,      (flex_int16_t const   )266,      (flex_int16_t const   )254,      (flex_int16_t const   )255, 
        (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )271,      (flex_int16_t const   )0, 
        (flex_int16_t const   )272,      (flex_int16_t const   )273,      (flex_int16_t const   )274,      (flex_int16_t const   )261, 
        (flex_int16_t const   )276,      (flex_int16_t const   )0,      (flex_int16_t const   )279,      (flex_int16_t const   )281, 
        (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )276,      (flex_int16_t const   )262, 
        (flex_int16_t const   )284,      (flex_int16_t const   )291,      (flex_int16_t const   )263,      (flex_int16_t const   )264, 
        (flex_int16_t const   )265,      (flex_int16_t const   )285,      (flex_int16_t const   )266,      (flex_int16_t const   )289, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )299,      (flex_int16_t const   )300, 
        (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )302,      (flex_int16_t const   )273, 
        (flex_int16_t const   )274,      (flex_int16_t const   )303,      (flex_int16_t const   )276,      (flex_int16_t const   )279, 
        (flex_int16_t const   )281,      (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )276, 
        (flex_int16_t const   )304,      (flex_int16_t const   )327,      (flex_int16_t const   )284,      (flex_int16_t const   )291, 
        (flex_int16_t const   )305,      (flex_int16_t const   )308,      (flex_int16_t const   )285,      (flex_int16_t const   )313, 
        (flex_int16_t const   )289,      (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )299, 
        (flex_int16_t const   )300,      (flex_int16_t const   )315,      (flex_int16_t const   )317,      (flex_int16_t const   )318, 
        (flex_int16_t const   )302,      (flex_int16_t const   )320,      (flex_int16_t const   )303,      (flex_int16_t const   )321, 
        (flex_int16_t const   )323,      (flex_int16_t const   )326,      (flex_int16_t const   )328,      (flex_int16_t const   )330, 
        (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )304,      (flex_int16_t const   )327, 
        (flex_int16_t const   )332,      (flex_int16_t const   )305,      (flex_int16_t const   )308,      (flex_int16_t const   )335, 
        (flex_int16_t const   )313,      (flex_int16_t const   )336,      (flex_int16_t const   )338,      (flex_int16_t const   )341, 
        (flex_int16_t const   )342,      (flex_int16_t const   )343,      (flex_int16_t const   )315,      (flex_int16_t const   )317, 
        (flex_int16_t const   )318,      (flex_int16_t const   )347,      (flex_int16_t const   )320,      (flex_int16_t const   )349, 
        (flex_int16_t const   )321,      (flex_int16_t const   )323,      (flex_int16_t const   )326,      (flex_int16_t const   )328, 
        (flex_int16_t const   )330,      (flex_int16_t const   )0,      (flex_int16_t const   )331,      (flex_int16_t const   )333, 
        (flex_int16_t const   )0,      (flex_int16_t const   )332,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )335,      (flex_int16_t const   )0,      (flex_int16_t const   )336,      (flex_int16_t const   )338, 
        (flex_int16_t const   )341,      (flex_int16_t const   )342,      (flex_int16_t const   )0,      (flex_int16_t const   )343, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )347, 
        (flex_int16_t const   )349,      (flex_int16_t const   )352,      (flex_int16_t const   )0,      (flex_int16_t const   )352, 
        (flex_int16_t const   )354,      (flex_int16_t const   )0,      (flex_int16_t const   )354,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351,      (flex_int16_t const   )351, 
        (flex_int16_t const   )351,      (flex_int16_t const   )351};
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 41 "../../include/jtag.h"
char const   *jtag_get_data_dir(void) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_msg.h"
void bsdl_msg(int proc_mode , int type , char const   *format  , ...) ;
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/vhdl_parser.h"
void *vhdl_flex_init(FILE *f , int proc_mode ) ;
#line 32
void vhdl_flex_deinit(void *scanner ) ;
#line 33
void vhdl_flex_switch_file(void *scanner , char *filename ) ;
#line 34
int vhdl_flex_get_compile_errors(void *scanner ) ;
#line 35
int vhdl_flex_postinc_compile_errors(void *scanner ) ;
#line 36
int vhdl_flex_get_lineno(void *scanner ) ;
#line 143 "vhdl_flex.l"
static char *new_string(scan_extra_t *extra , char const   *str ) ;
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 1019 "vhdl_flex.c"
static int yy_init_globals(yyscan_t yyscanner ) ;
#line 1025
int vhdllex_init(yyscan_t *ptr_yy_globals ) ;
#line 1027
int vhdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 1032
int vhdllex_destroy(yyscan_t yyscanner ) ;
#line 1034
int vhdlget_debug(yyscan_t yyscanner ) ;
#line 1036
void vhdlset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 1038
scan_extra_t *vhdlget_extra(yyscan_t yyscanner ) ;
#line 1040
void vhdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 1042
FILE *vhdlget_in(yyscan_t yyscanner ) ;
#line 1044
void vhdlset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 1046
FILE *vhdlget_out(yyscan_t yyscanner ) ;
#line 1048
void vhdlset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 1050
int vhdlget_leng(yyscan_t yyscanner ) ;
#line 1052
char *vhdlget_text(yyscan_t yyscanner ) ;
#line 1054
int vhdlget_lineno(yyscan_t yyscanner ) ;
#line 1056
void vhdlset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 1058
YYSTYPE *vhdlget_lval(yyscan_t yyscanner ) ;
#line 1060
void vhdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1070
int vhdlwrap(yyscan_t scanner ) ;
#line 1169
int vhdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1193 "vhdl_flex.c"
int vhdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t *yyg ;
  void *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  yy_state_type *tmp___1 ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1198
  yyg = (struct yyguts_t *)yyscanner;
#line 1204
  yyg->yylval_r = yylval_param;
#line 1206
  if (! yyg->yy_init) {
#line 1208
    yyg->yy_init = 1;
#line 1215
    if (! yyg->yy_state_buf) {
      {
#line 1216
      tmp = vhdlalloc(16386UL * sizeof(yy_state_type ), yyscanner);
#line 1216
      yyg->yy_state_buf = (yy_state_type *)tmp;
      }
    }
#line 1217
    if (! yyg->yy_state_buf) {
      {
#line 1218
      yy_fatal_error("out of dynamic memory in vhdllex()", yyscanner);
      }
    }
#line 1220
    if (! yyg->yy_start) {
#line 1221
      yyg->yy_start = 1;
    }
#line 1223
    if (! yyg->yyin_r) {
#line 1224
      yyg->yyin_r = stdin;
    }
#line 1226
    if (! yyg->yyout_r) {
#line 1227
      yyg->yyout_r = stdout;
    }
#line 1229
    if (yyg->yy_buffer_stack) {
#line 1229
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 1229
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1229
    if (! tmp___0) {
      {
#line 1230
      vhdlensure_buffer_stack(yyscanner);
#line 1231
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = vhdl_create_buffer(yyg->yyin_r,
                                                                              16384,
                                                                              yyscanner);
      }
    }
    {
#line 1235
    vhdl_load_buffer_state(yyscanner);
    }
  }
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1240
    yy_cp = yyg->yy_c_buf_p;
#line 1243
    *yy_cp = yyg->yy_hold_char;
#line 1248
    yy_bp = yy_cp;
#line 1250
    yy_current_state = yyg->yy_start;
#line 1252
    yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1253
    tmp___1 = yyg->yy_state_ptr;
#line 1253
    (yyg->yy_state_ptr) ++;
#line 1253
    *tmp___1 = yy_current_state;
    yy_match: 
    {
#line 1256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1258
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
      {
#line 1259
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1259
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1259
          goto while_break___1;
        }
#line 1261
        yy_current_state = (int )yy_def[yy_current_state];
#line 1262
        if (yy_current_state >= 352) {
#line 1263
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1265
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1266
      tmp___2 = yyg->yy_state_ptr;
#line 1266
      (yyg->yy_state_ptr) ++;
#line 1266
      *tmp___2 = yy_current_state;
#line 1267
      yy_cp ++;
#line 1256
      if (! ((int const   )yy_base[yy_current_state] != 823)) {
#line 1256
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1272
    (yyg->yy_state_ptr) --;
#line 1272
    yy_current_state = *(yyg->yy_state_ptr);
#line 1273
    yyg->yy_lp = (int )yy_accept[yy_current_state];
    find_rule: 
    {
#line 1275
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1277
      if (yyg->yy_lp) {
#line 1277
        if (yyg->yy_lp < (int )yy_accept[yy_current_state + 1]) {
#line 1279
          yy_act = (int )yy_acclist[yyg->yy_lp];
#line 1281
          yyg->yy_full_match = yy_cp;
#line 1282
          goto while_break___2;
        }
      }
#line 1285
      yy_cp --;
#line 1286
      (yyg->yy_state_ptr) --;
#line 1286
      yy_current_state = *(yyg->yy_state_ptr);
#line 1287
      yyg->yy_lp = (int )yy_accept[yy_current_state];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1290
    yyg->yytext_r = yy_bp;
#line 1290
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 1290
    yyg->yy_hold_char = *yy_cp;
#line 1290
    *yy_cp = (char )'\000';
#line 1290
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1296
    if (yy_act == 1) {
#line 1296
      goto case_1;
    }
#line 243
    if (yy_act == 2) {
#line 243 "vhdl_flex.l"
      goto case_2;
    }
#line 245
    if (yy_act == 3) {
#line 245
      goto case_3;
    }
#line 246
    if (yy_act == 4) {
#line 246
      goto case_4;
    }
#line 247
    if (yy_act == 5) {
#line 247
      goto case_5;
    }
#line 248
    if (yy_act == 6) {
#line 248
      goto case_6;
    }
#line 249
    if (yy_act == 7) {
#line 249
      goto case_7;
    }
#line 250
    if (yy_act == 8) {
#line 250
      goto case_8;
    }
#line 251
    if (yy_act == 9) {
#line 251
      goto case_9;
    }
#line 254
    if (yy_act == 10) {
#line 254
      goto case_10;
    }
#line 255
    if (yy_act == 11) {
#line 255
      goto case_11;
    }
#line 256
    if (yy_act == 12) {
#line 256
      goto case_12;
    }
#line 257
    if (yy_act == 13) {
#line 257
      goto case_13;
    }
#line 258
    if (yy_act == 14) {
#line 258
      goto case_14;
    }
#line 259
    if (yy_act == 15) {
#line 259
      goto case_15;
    }
#line 260
    if (yy_act == 16) {
#line 260
      goto case_16;
    }
#line 261
    if (yy_act == 17) {
#line 261
      goto case_17;
    }
#line 262
    if (yy_act == 18) {
#line 262
      goto case_18;
    }
#line 263
    if (yy_act == 19) {
#line 263
      goto case_19;
    }
#line 264
    if (yy_act == 20) {
#line 264
      goto case_20;
    }
#line 265
    if (yy_act == 21) {
#line 265
      goto case_21;
    }
#line 266
    if (yy_act == 22) {
#line 266
      goto case_22;
    }
#line 267
    if (yy_act == 23) {
#line 267
      goto case_23;
    }
#line 268
    if (yy_act == 24) {
#line 268
      goto case_24;
    }
#line 269
    if (yy_act == 25) {
#line 269
      goto case_25;
    }
#line 270
    if (yy_act == 26) {
#line 270
      goto case_26;
    }
#line 271
    if (yy_act == 27) {
#line 271
      goto case_27;
    }
#line 272
    if (yy_act == 28) {
#line 272
      goto case_28;
    }
#line 273
    if (yy_act == 29) {
#line 273
      goto case_29;
    }
#line 274
    if (yy_act == 30) {
#line 274
      goto case_30;
    }
#line 275
    if (yy_act == 31) {
#line 275
      goto case_31;
    }
#line 276
    if (yy_act == 32) {
#line 276
      goto case_32;
    }
#line 277
    if (yy_act == 33) {
#line 277
      goto case_33;
    }
#line 278
    if (yy_act == 34) {
#line 278
      goto case_34;
    }
#line 279
    if (yy_act == 35) {
#line 279
      goto case_35;
    }
#line 280
    if (yy_act == 36) {
#line 280
      goto case_36;
    }
#line 281
    if (yy_act == 37) {
#line 281
      goto case_37;
    }
#line 282
    if (yy_act == 38) {
#line 282
      goto case_38;
    }
#line 283
    if (yy_act == 39) {
#line 283
      goto case_39;
    }
#line 284
    if (yy_act == 40) {
#line 284
      goto case_40;
    }
#line 285
    if (yy_act == 41) {
#line 285
      goto case_41;
    }
#line 286
    if (yy_act == 42) {
#line 286
      goto case_42;
    }
#line 287
    if (yy_act == 43) {
#line 287
      goto case_43;
    }
#line 288
    if (yy_act == 44) {
#line 288
      goto case_44;
    }
#line 289
    if (yy_act == 45) {
#line 289
      goto case_45;
    }
#line 290
    if (yy_act == 46) {
#line 290
      goto case_46;
    }
#line 291
    if (yy_act == 47) {
#line 291
      goto case_47;
    }
#line 292
    if (yy_act == 48) {
#line 292
      goto case_48;
    }
#line 293
    if (yy_act == 49) {
#line 293
      goto case_49;
    }
#line 294
    if (yy_act == 50) {
#line 294
      goto case_50;
    }
#line 295
    if (yy_act == 51) {
#line 295
      goto case_51;
    }
#line 296
    if (yy_act == 52) {
#line 296
      goto case_52;
    }
#line 297
    if (yy_act == 53) {
#line 297
      goto case_53;
    }
#line 298
    if (yy_act == 54) {
#line 298
      goto case_54;
    }
#line 299
    if (yy_act == 55) {
#line 299
      goto case_55;
    }
#line 300
    if (yy_act == 56) {
#line 300
      goto case_56;
    }
#line 301
    if (yy_act == 57) {
#line 301
      goto case_57;
    }
#line 302
    if (yy_act == 58) {
#line 302
      goto case_58;
    }
#line 303
    if (yy_act == 59) {
#line 303
      goto case_59;
    }
#line 304
    if (yy_act == 60) {
#line 304
      goto case_60;
    }
#line 305
    if (yy_act == 61) {
#line 305
      goto case_61;
    }
#line 306
    if (yy_act == 62) {
#line 306
      goto case_62;
    }
#line 307
    if (yy_act == 63) {
#line 307
      goto case_63;
    }
#line 308
    if (yy_act == 64) {
#line 308
      goto case_64;
    }
#line 309
    if (yy_act == 65) {
#line 309
      goto case_65;
    }
#line 310
    if (yy_act == 66) {
#line 310
      goto case_66;
    }
#line 311
    if (yy_act == 67) {
#line 311
      goto case_67;
    }
#line 312
    if (yy_act == 68) {
#line 312
      goto case_68;
    }
#line 313
    if (yy_act == 69) {
#line 313
      goto case_69;
    }
#line 314
    if (yy_act == 70) {
#line 314
      goto case_70;
    }
#line 315
    if (yy_act == 71) {
#line 315
      goto case_71;
    }
#line 316
    if (yy_act == 72) {
#line 316
      goto case_72;
    }
#line 317
    if (yy_act == 73) {
#line 317
      goto case_73;
    }
#line 318
    if (yy_act == 74) {
#line 318
      goto case_74;
    }
#line 321
    if (yy_act == 75) {
#line 321
      goto case_75;
    }
#line 323
    if (yy_act == 76) {
#line 323
      goto case_76;
    }
#line 325
    if (yy_act == 77) {
#line 325
      goto case_77;
    }
#line 328
    if (yy_act == 78) {
#line 328
      goto case_78;
    }
#line 330
    if (yy_act == 79) {
#line 330
      goto case_79;
    }
#line 331
    if (yy_act == 80) {
#line 331
      goto case_80;
    }
#line 332
    if (yy_act == 81) {
#line 332
      goto case_81;
    }
#line 343
    if (yy_act == 88) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 87) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 86) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 85) {
#line 343
      goto case_88;
    }
#line 343
    if (yy_act == 84) {
#line 343
      goto case_88;
    }
#line 344
    if (yy_act == 82) {
#line 344
      goto case_82;
    }
#line 1737
    if (yy_act == 83) {
#line 1737 "vhdl_flex.c"
      goto case_83;
    }
#line 1859
    goto switch_default;
    case_1: /* CIL Label */ 
#line 241 "vhdl_flex.l"
    return (258);
#line 242
    goto switch_break;
    case_2: /* CIL Label */ 
#line 242
    (yyg->yyextra_r)->Base = 1;
#line 243
    return (259);
#line 244
    goto switch_break;
    case_3: /* CIL Label */ 
#line 244
    (yyg->yyextra_r)->Base = 1;
#line 244
    return (260);
#line 245
    goto switch_break;
    case_4: /* CIL Label */ 
#line 245
    (yyg->yyextra_r)->Base = 1;
#line 245
    return (261);
#line 246
    goto switch_break;
    case_5: /* CIL Label */ 
#line 246
    (yyg->yyextra_r)->Base = 1;
#line 246
    return (262);
#line 247
    goto switch_break;
    case_6: /* CIL Label */ 
#line 247
    return (263);
#line 248
    goto switch_break;
    case_7: /* CIL Label */ 
#line 248
    (yyg->yyextra_r)->Base = 1;
#line 248
    return (265);
#line 249
    goto switch_break;
    case_8: /* CIL Label */ 
#line 249
    return (266);
#line 250
    goto switch_break;
    case_9: /* CIL Label */ 
#line 250
    (yyg->yyextra_r)->Base = 1;
#line 251
    yyg->yy_start = 1;
#line 252
    return (267);
#line 253
    goto switch_break;
    case_10: /* CIL Label */ 
#line 253
    return (268);
#line 254
    goto switch_break;
    case_11: /* CIL Label */ 
#line 254
    return (264);
#line 255
    goto switch_break;
    case_12: /* CIL Label */ 
#line 255
    return (269);
#line 256
    goto switch_break;
    case_13: /* CIL Label */ 
#line 256
    return (270);
#line 257
    goto switch_break;
    case_14: /* CIL Label */ 
#line 257
    return (271);
#line 258
    goto switch_break;
    case_15: /* CIL Label */ 
#line 258
    return (272);
#line 259
    goto switch_break;
    case_16: /* CIL Label */ 
#line 259
    return (273);
#line 260
    goto switch_break;
    case_17: /* CIL Label */ 
#line 260
    return (274);
#line 261
    goto switch_break;
    case_18: /* CIL Label */ 
#line 261
    return (275);
#line 262
    goto switch_break;
    case_19: /* CIL Label */ 
#line 262
    return (276);
#line 263
    goto switch_break;
    case_20: /* CIL Label */ 
#line 263
    return (277);
#line 264
    goto switch_break;
    case_21: /* CIL Label */ 
#line 264
    return (278);
#line 265
    goto switch_break;
    case_22: /* CIL Label */ 
#line 265
    return (279);
#line 266
    goto switch_break;
    case_23: /* CIL Label */ 
#line 266
    return (280);
#line 267
    goto switch_break;
    case_24: /* CIL Label */ 
#line 267
    return (281);
#line 268
    goto switch_break;
    case_25: /* CIL Label */ 
#line 268
    return (282);
#line 269
    goto switch_break;
    case_26: /* CIL Label */ 
#line 269
    return (283);
#line 270
    goto switch_break;
    case_27: /* CIL Label */ 
#line 270
    return (284);
#line 271
    goto switch_break;
    case_28: /* CIL Label */ 
#line 271
    return (285);
#line 272
    goto switch_break;
    case_29: /* CIL Label */ 
#line 272
    return (286);
#line 273
    goto switch_break;
    case_30: /* CIL Label */ 
#line 273
    return (287);
#line 274
    goto switch_break;
    case_31: /* CIL Label */ 
#line 274
    return (288);
#line 275
    goto switch_break;
    case_32: /* CIL Label */ 
#line 275
    return (289);
#line 276
    goto switch_break;
    case_33: /* CIL Label */ 
#line 276
    (yyg->yyextra_r)->Base = 1;
#line 276
    return (290);
#line 277
    goto switch_break;
    case_34: /* CIL Label */ 
#line 277
    return (291);
#line 278
    goto switch_break;
    case_35: /* CIL Label */ 
#line 278
    return (292);
#line 279
    goto switch_break;
    case_36: /* CIL Label */ 
#line 279
    yyg->yy_start = 9;
#line 279
    return (293);
#line 280
    goto switch_break;
    case_37: /* CIL Label */ 
#line 280
    return (332);
#line 281
    goto switch_break;
    case_38: /* CIL Label */ 
#line 281
    return (334);
#line 282
    goto switch_break;
    case_39: /* CIL Label */ 
#line 282
    return (335);
#line 283
    goto switch_break;
    case_40: /* CIL Label */ 
#line 283
    return (294);
#line 284
    goto switch_break;
    case_41: /* CIL Label */ 
#line 284
    return (295);
#line 285
    goto switch_break;
    case_42: /* CIL Label */ 
#line 285
    return (296);
#line 286
    goto switch_break;
    case_43: /* CIL Label */ 
#line 286
    return (298);
#line 287
    goto switch_break;
    case_44: /* CIL Label */ 
#line 287
    return (297);
#line 288
    goto switch_break;
    case_45: /* CIL Label */ 
#line 288
    return (299);
#line 289
    goto switch_break;
    case_46: /* CIL Label */ 
#line 289
    return (300);
#line 290
    goto switch_break;
    case_47: /* CIL Label */ 
#line 290
    return (333);
#line 291
    goto switch_break;
    case_48: /* CIL Label */ 
#line 291
    return (301);
#line 292
    goto switch_break;
    case_49: /* CIL Label */ 
#line 292
    return (302);
#line 293
    goto switch_break;
    case_50: /* CIL Label */ 
#line 293
    return (303);
#line 294
    goto switch_break;
    case_51: /* CIL Label */ 
#line 294
    return (304);
#line 295
    goto switch_break;
    case_52: /* CIL Label */ 
#line 295
    return (305);
#line 296
    goto switch_break;
    case_53: /* CIL Label */ 
#line 296
    return (306);
#line 297
    goto switch_break;
    case_54: /* CIL Label */ 
#line 297
    return (307);
#line 298
    goto switch_break;
    case_55: /* CIL Label */ 
#line 298
    return (308);
#line 299
    goto switch_break;
    case_56: /* CIL Label */ 
#line 299
    return (309);
#line 300
    goto switch_break;
    case_57: /* CIL Label */ 
#line 300
    return (310);
#line 301
    goto switch_break;
    case_58: /* CIL Label */ 
#line 301
    return (311);
#line 302
    goto switch_break;
    case_59: /* CIL Label */ 
#line 302
    return (312);
#line 303
    goto switch_break;
    case_60: /* CIL Label */ 
#line 303
    return (314);
#line 304
    goto switch_break;
    case_61: /* CIL Label */ 
#line 304
    return (315);
#line 305
    goto switch_break;
    case_62: /* CIL Label */ 
#line 305
    return (316);
#line 306
    goto switch_break;
    case_63: /* CIL Label */ 
#line 306
    ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno) ++;
#line 307
    goto switch_break;
    case_64: /* CIL Label */ 
#line 307
    return (324);
#line 308
    goto switch_break;
    case_65: /* CIL Label */ 
#line 308
    return (325);
#line 309
    goto switch_break;
    case_66: /* CIL Label */ 
#line 309
    return (326);
#line 310
    goto switch_break;
    case_67: /* CIL Label */ 
#line 310
    return (330);
#line 311
    goto switch_break;
    case_68: /* CIL Label */ 
#line 311
    return (327);
#line 312
    goto switch_break;
    case_69: /* CIL Label */ 
#line 312
    return (328);
#line 313
    goto switch_break;
    case_70: /* CIL Label */ 
#line 313
    (yyg->yyextra_r)->Base = 2;
#line 313
    return (318);
#line 314
    goto switch_break;
    case_71: /* CIL Label */ 
#line 314
    return (329);
#line 315
    goto switch_break;
    case_72: /* CIL Label */ ;
#line 316
    goto switch_break;
    case_73: /* CIL Label */ ;
#line 317
    goto switch_break;
    case_74: /* CIL Label */ 
#line 317
    if ((yyg->yyextra_r)->Base != 2) {
#line 317
      *yy_cp = yyg->yy_hold_char;
#line 317
      yy_cp = yyg->yy_full_match;
#line 317
      (yyg->yy_lp) ++;
#line 317
      goto find_rule;
    }
    {
#line 318
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 319
    return (313);
#line 320
    goto switch_break;
    case_75: /* CIL Label */ 
    {
#line 320
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 321
    return (317);
#line 322
    goto switch_break;
    case_76: /* CIL Label */ 
    {
#line 322
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 323
    return (319);
#line 324
    goto switch_break;
    case_77: /* CIL Label */ 
#line 324
    if ((yyg->yyextra_r)->Base != 1) {
#line 324
      *yy_cp = yyg->yy_hold_char;
#line 324
      yy_cp = yyg->yy_full_match;
#line 324
      (yyg->yy_lp) ++;
#line 324
      goto find_rule;
    }
    {
#line 325
    (yyg->yylval_r)->integer = atoi((char const   *)yyg->yytext_r);
    }
#line 326
    return (320);
#line 327
    goto switch_break;
    case_78: /* CIL Label */ 
    {
#line 327
    (yyg->yylval_r)->str = new_string(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 328
    return (321);
#line 329
    goto switch_break;
    case_79: /* CIL Label */ 
#line 329
    return (322);
#line 330
    goto switch_break;
    case_80: /* CIL Label */ 
#line 330
    return (323);
#line 331
    goto switch_break;
    case_81: /* CIL Label */ 
    {
#line 331
    bsdl_msg((yyg->yyextra_r)->proc_mode, 2, "Illegal character %c (/%03o) at line %d:\n",
             (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)), (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)),
             (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
#line 336
    ((yyg->yyextra_r)->Compile_Errors) ++;
    }
#line 337
    return (331);
#line 338
    goto switch_break;
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 339
    vhdlpop_buffer_state(yyscanner);
    }
#line 340
    if (yyg->yy_buffer_stack) {
#line 340
      tmp___3 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 340
      tmp___3 = (YY_BUFFER_STATE )((void *)0);
    }
#line 340
    if (! tmp___3) {
#line 341
      return (0);
    }
#line 343
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 343
    fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
           (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
    }
#line 344
    goto switch_break;
    case_83: /* CIL Label */ 
#line 1740 "vhdl_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 1743
    *yy_cp = yyg->yy_hold_char;
#line 1746
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1757
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1758
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 1759
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1769
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 1773
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1775
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1786
      yy_next_state = yy_try_NUL_trans(yy_current_state, yyscanner);
#line 1788
      yy_bp = yyg->yytext_r + 0;
      }
#line 1790
      if (yy_next_state) {
#line 1793
        (yyg->yy_c_buf_p) ++;
#line 1793
        yy_cp = yyg->yy_c_buf_p;
#line 1794
        yy_current_state = yy_next_state;
#line 1795
        goto yy_match;
      } else {
#line 1800
        yy_cp = yyg->yy_c_buf_p;
#line 1801
        goto yy_find_action;
      }
    } else {
      {
#line 1805
      tmp___4 = yy_get_next_buffer(yyscanner);
      }
      {
#line 1807
      if (tmp___4 == 1) {
#line 1807
        goto case_1___0;
      }
#line 1836
      if (tmp___4 == 0) {
#line 1836
        goto case_0;
      }
#line 1846
      if (tmp___4 == 2) {
#line 1846
        goto case_2___0;
      }
#line 1805
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1809
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 1811
      tmp___5 = vhdlwrap(yyscanner);
      }
#line 1811
      if (tmp___5) {
#line 1822
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 1824
        yy_act = (83 + (yyg->yy_start - 1) / 2) + 1;
#line 1825
        goto do_action;
      } else
#line 1830
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 1831
        vhdlrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 1833
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 1837
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1840
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1842
      yy_cp = yyg->yy_c_buf_p;
#line 1843
      yy_bp = yyg->yytext_r + 0;
      }
#line 1844
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1847
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 1850
      yy_current_state = yy_get_previous_state(yyscanner);
#line 1852
      yy_cp = yyg->yy_c_buf_p;
#line 1853
      yy_bp = yyg->yytext_r + 0;
      }
#line 1854
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1856
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1860
    yy_fatal_error("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1873 "vhdl_flex.c"
static int yy_get_next_buffer(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  int c ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size ;
  void *tmp___10 ;

  {
#line 1875
  yyg = (struct yyguts_t *)yyscanner;
#line 1876
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 1877
  source = yyg->yytext_r;
#line 1881
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 1882
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed", yyscanner);
    }
  }
#line 1885
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1887
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 1892
      return (1);
    } else {
#line 1900
      return (2);
    }
  }
#line 1907
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 1909
  i = 0;
  {
#line 1909
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1909
    if (! (i < number_to_move)) {
#line 1909
      goto while_break;
    }
#line 1910
    tmp = dest;
#line 1910
    dest ++;
#line 1910
    tmp___0 = source;
#line 1910
    source ++;
#line 1910
    *tmp = *tmp___0;
#line 1909
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1912
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1916
    tmp___1 = 0;
#line 1916
    yyg->yy_n_chars = tmp___1;
#line 1916
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 1920
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1923
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1923
      if (! (num_to_read <= 0)) {
#line 1923
        goto while_break___0;
      }
      {
#line 1926
      yy_fatal_error("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT",
                     yyscanner);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1931
    if (num_to_read > 8192) {
#line 1932
      num_to_read = 8192;
    }
#line 1935
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 1935
      c = '*';
#line 1935
      n = 0;
      {
#line 1935
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1935
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1935
          c = _IO_getc(yyg->yyin_r);
          }
#line 1935
          if (c != -1) {
#line 1935
            if (! (c != 10)) {
#line 1935
              goto while_break___1;
            }
          } else {
#line 1935
            goto while_break___1;
          }
        } else {
#line 1935
          goto while_break___1;
        }
#line 1935
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1935
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1935
      if (c == 10) {
#line 1935
        tmp___2 = n;
#line 1935
        n ++;
#line 1935
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
#line 1935
      if (c == -1) {
        {
#line 1935
        tmp___3 = ferror(yyg->yyin_r);
        }
#line 1935
        if (tmp___3) {
          {
#line 1935
          yy_fatal_error("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 1935
      yyg->yy_n_chars = n;
    } else {
      {
#line 1935
      tmp___4 = __errno_location();
#line 1935
      *tmp___4 = 0;
      }
      {
#line 1935
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1935
        tmp___8 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 1935
        tmp___7 = (int )tmp___8;
#line 1935
        yyg->yy_n_chars = tmp___7;
        }
#line 1935
        if (tmp___7 == 0) {
          {
#line 1935
          tmp___9 = ferror(yyg->yyin_r);
          }
#line 1935
          if (! tmp___9) {
#line 1935
            goto while_break___2;
          }
        } else {
#line 1935
          goto while_break___2;
        }
        {
#line 1935
        tmp___5 = __errno_location();
        }
#line 1935
        if (*tmp___5 != 4) {
          {
#line 1935
          yy_fatal_error("input in flex scanner failed", yyscanner);
          }
#line 1935
          goto while_break___2;
        }
        {
#line 1935
        tmp___6 = __errno_location();
#line 1935
        *tmp___6 = 0;
#line 1935
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1938
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1941
  if (yyg->yy_n_chars == 0) {
#line 1943
    if (number_to_move == 0) {
      {
#line 1945
      ret_val = 1;
#line 1946
      vhdlrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 1951
      ret_val = 2;
#line 1952
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1958
    ret_val = 0;
  }
#line 1960
  if ((yy_size_t )(yyg->yy_n_chars + number_to_move) > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1962
    new_size = (yy_size_t )((yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1));
#line 1963
    tmp___10 = vhdlrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                           new_size, yyscanner);
#line 1963
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1964
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1965
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
  }
#line 1968
  yyg->yy_n_chars += number_to_move;
#line 1969
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 1970
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 1972
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1974
  return (ret_val);
}
}
#line 1979 "vhdl_flex.c"
static yy_state_type yy_get_previous_state(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t *yyg ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 1983
  yyg = (struct yyguts_t *)yyscanner;
#line 1985
  yy_current_state = yyg->yy_start;
#line 1987
  yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1988
  tmp = yyg->yy_state_ptr;
#line 1988
  (yyg->yy_state_ptr) ++;
#line 1988
  *tmp = yy_current_state;
#line 1990
  yy_cp = yyg->yytext_r + 0;
  {
#line 1990
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1990
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 1990
      goto while_break;
    }
#line 1992
    if (*yy_cp) {
#line 1992
      tmp___0 = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1992
      tmp___0 = (flex_int32_t const   )1;
    }
#line 1992
    yy_c = (YY_CHAR )tmp___0;
    {
#line 1993
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1993
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1993
        goto while_break___0;
      }
#line 1995
      yy_current_state = (int )yy_def[yy_current_state];
#line 1996
      if (yy_current_state >= 352) {
#line 1997
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1999
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 2000
    tmp___1 = yyg->yy_state_ptr;
#line 2000
    (yyg->yy_state_ptr) ++;
#line 2000
    *tmp___1 = yy_current_state;
#line 1990
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2003
  return (yy_current_state);
}
}
#line 2011 "vhdl_flex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t *yyg ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 2014
  yyg = (struct yyguts_t *)yyscanner;
#line 2016
  yy_c = (YY_CHAR )1;
  {
#line 2017
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2017
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2017
      goto while_break;
    }
#line 2019
    yy_current_state = (int )yy_def[yy_current_state];
#line 2020
    if (yy_current_state >= 352) {
#line 2021
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2023
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 2024
  yy_is_jam = yy_current_state == 351;
#line 2025
  if (! yy_is_jam) {
#line 2026
    tmp = yyg->yy_state_ptr;
#line 2026
    (yyg->yy_state_ptr) ++;
#line 2026
    *tmp = yy_current_state;
  }
#line 2028
  if (yy_is_jam) {
#line 2028
    tmp___0 = 0;
  } else {
#line 2028
    tmp___0 = yy_current_state;
  }
#line 2028
  return (tmp___0);
}
}
#line 2149 "vhdl_flex.c"
void vhdlrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2151
  yyg = (struct yyguts_t *)yyscanner;
#line 2153
  if (yyg->yy_buffer_stack) {
#line 2153
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2153
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2153
  if (! tmp) {
    {
#line 2154
    vhdlensure_buffer_stack(yyscanner);
#line 2155
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = vhdl_create_buffer(yyg->yyin_r,
                                                                            16384,
                                                                            yyscanner);
    }
  }
#line 2159
  if (yyg->yy_buffer_stack) {
#line 2159
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2159
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2159
  vhdl_init_buffer(tmp___0, input_file, yyscanner);
#line 2160
  vhdl_load_buffer_state(yyscanner);
  }
#line 2161
  return;
}
}
#line 2167 "vhdl_flex.c"
void vhdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2169
  yyg = (struct yyguts_t *)yyscanner;
#line 2176
  vhdlensure_buffer_stack(yyscanner);
  }
#line 2177
  if (yyg->yy_buffer_stack) {
#line 2177
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2177
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2177
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2178
    return;
  }
#line 2180
  if (yyg->yy_buffer_stack) {
#line 2180
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2180
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2180
  if (tmp___0) {
#line 2183
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2184
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2185
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 2188
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2189
  vhdl_load_buffer_state(yyscanner);
#line 2196
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2197
  return;
}
}
#line 2199 "vhdl_flex.c"
static void vhdl_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *tmp ;

  {
#line 2201
  yyg = (struct yyguts_t *)yyscanner;
#line 2202
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2203
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 2203
  yyg->yy_c_buf_p = tmp;
#line 2203
  yyg->yytext_r = tmp;
#line 2204
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 2205
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 2206
  return;
}
}
#line 2214 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2218
  tmp = vhdlalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 2218
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2219
  if (! b) {
    {
#line 2220
    yy_fatal_error("out of dynamic memory in vhdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2222
  b->yy_buf_size = (yy_size_t )size;
#line 2227
  tmp___0 = vhdlalloc(b->yy_buf_size + 2UL, yyscanner);
#line 2227
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2228
  if (! b->yy_ch_buf) {
    {
#line 2229
    yy_fatal_error("out of dynamic memory in vhdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2231
  b->yy_is_our_buffer = 1;
#line 2233
  vhdl_init_buffer(b, file, yyscanner);
  }
#line 2235
  return (b);
}
}
#line 2242 "vhdl_flex.c"
void vhdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2244
  yyg = (struct yyguts_t *)yyscanner;
#line 2246
  if (! b) {
#line 2247
    return;
  }
#line 2249
  if (yyg->yy_buffer_stack) {
#line 2249
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2249
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2249
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2250
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2252
  if (b->yy_is_our_buffer) {
    {
#line 2253
    vhdlfree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 2255
  vhdlfree((void *)b, yyscanner);
  }
#line 2256
  return;
}
}
#line 2266 "vhdl_flex.c"
static void vhdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2269
  tmp = __errno_location();
#line 2269
  oerrno = *tmp;
#line 2270
  yyg = (struct yyguts_t *)yyscanner;
#line 2272
  vhdl_flush_buffer(b, yyscanner);
#line 2274
  b->yy_input_file = file;
#line 2275
  b->yy_fill_buffer = 1;
  }
#line 2281
  if (yyg->yy_buffer_stack) {
#line 2281
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2281
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2281
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2282
    b->yy_bs_lineno = 1;
#line 2283
    b->yy_bs_column = 0;
  }
#line 2286
  if (file) {
    {
#line 2286
    tmp___1 = fileno(file);
#line 2286
    tmp___2 = isatty(tmp___1);
#line 2286
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2286
    b->yy_is_interactive = 0;
  }
  {
#line 2288
  tmp___3 = __errno_location();
#line 2288
  *tmp___3 = oerrno;
  }
#line 2289
  return;
}
}
#line 2295 "vhdl_flex.c"
void vhdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2297
  yyg = (struct yyguts_t *)yyscanner;
#line 2298
  if (! b) {
#line 2299
    return;
  }
#line 2301
  b->yy_n_chars = 0;
#line 2307
  *(b->yy_ch_buf + 0) = (char)0;
#line 2308
  *(b->yy_ch_buf + 1) = (char)0;
#line 2310
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2312
  b->yy_at_bol = 1;
#line 2313
  b->yy_buffer_status = 0;
#line 2315
  if (yyg->yy_buffer_stack) {
#line 2315
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2315
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2315
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2316
    vhdl_load_buffer_state(yyscanner);
    }
  }
#line 2317
  return;
}
}
#line 2325 "vhdl_flex.c"
void vhdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2327
  yyg = (struct yyguts_t *)yyscanner;
#line 2328
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2329
    return;
  }
  {
#line 2331
  vhdlensure_buffer_stack(yyscanner);
  }
#line 2334
  if (yyg->yy_buffer_stack) {
#line 2334
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2334
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2334
  if (tmp) {
#line 2337
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2338
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2339
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2343
  if (yyg->yy_buffer_stack) {
#line 2343
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2343
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2343
  if (tmp___0) {
#line 2344
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 2345
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2348
  vhdl_load_buffer_state(yyscanner);
#line 2349
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2350
  return;
}
}
#line 2356 "vhdl_flex.c"
void vhdlpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2358
  yyg = (struct yyguts_t *)yyscanner;
#line 2359
  if (yyg->yy_buffer_stack) {
#line 2359
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2359
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2359
  if (! tmp) {
#line 2360
    return;
  }
#line 2362
  if (yyg->yy_buffer_stack) {
#line 2362
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2362
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2362
  vhdl_delete_buffer(tmp___0, yyscanner);
#line 2363
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2364
  if (yyg->yy_buffer_stack_top > 0UL) {
#line 2365
    (yyg->yy_buffer_stack_top) --;
  }
#line 2367
  if (yyg->yy_buffer_stack) {
#line 2367
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2367
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2367
  if (tmp___1) {
    {
#line 2368
    vhdl_load_buffer_state(yyscanner);
#line 2369
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2371
  return;
}
}
#line 2376 "vhdl_flex.c"
static void vhdlensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 2379
  yyg = (struct yyguts_t *)yyscanner;
#line 2381
  if (! yyg->yy_buffer_stack) {
    {
#line 2387
    num_to_alloc = 1;
#line 2388
    tmp = vhdlalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *),
                    yyscanner);
#line 2388
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2391
    if (! yyg->yy_buffer_stack) {
      {
#line 2392
      yy_fatal_error("out of dynamic memory in vhdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2394
    memset((void *)yyg->yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2396
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2397
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 2398
    return;
  }
#line 2401
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1UL) {
    {
#line 2404
    grow_size = 8;
#line 2406
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 2407
    tmp___0 = vhdlrealloc((void *)yyg->yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *),
                          yyscanner);
#line 2407
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2411
    if (! yyg->yy_buffer_stack) {
      {
#line 2412
      yy_fatal_error("out of dynamic memory in vhdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2415
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2416
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2418
  return;
}
}
#line 2426 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2430
  if (size < 2UL) {
#line 2434
    return ((YY_BUFFER_STATE )0);
  } else
#line 2430
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2434
    return ((YY_BUFFER_STATE )0);
  } else
#line 2430
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2434
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2436
  tmp = vhdlalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 2436
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2437
  if (! b) {
    {
#line 2438
    yy_fatal_error("out of dynamic memory in vhdl_scan_buffer()", yyscanner);
    }
  }
  {
#line 2440
  b->yy_buf_size = size - 2UL;
#line 2441
  tmp___0 = base;
#line 2441
  b->yy_ch_buf = tmp___0;
#line 2441
  b->yy_buf_pos = tmp___0;
#line 2442
  b->yy_is_our_buffer = 0;
#line 2443
  b->yy_input_file = (FILE *)0;
#line 2444
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2445
  b->yy_is_interactive = 0;
#line 2446
  b->yy_at_bol = 1;
#line 2447
  b->yy_fill_buffer = 0;
#line 2448
  b->yy_buffer_status = 0;
#line 2450
  vhdl_switch_to_buffer(b, yyscanner);
  }
#line 2452
  return (b);
}
}
#line 2463 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2466
  tmp = strlen(yystr);
#line 2466
  tmp___0 = vhdl_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 2466
  return (tmp___0);
}
}
#line 2476 "vhdl_flex.c"
YY_BUFFER_STATE vhdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2484
  n = (yy_size_t )(_yybytes_len + 2);
#line 2485
  tmp = vhdlalloc(n, yyscanner);
#line 2485
  buf = (char *)tmp;
  }
#line 2486
  if (! buf) {
    {
#line 2487
    yy_fatal_error("out of dynamic memory in vhdl_scan_bytes()", yyscanner);
    }
  }
#line 2489
  i = 0;
  {
#line 2489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2489
    if (! (i < _yybytes_len)) {
#line 2489
      goto while_break;
    }
#line 2490
    *(buf + i) = (char )*(yybytes + i);
#line 2489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2492
  tmp___0 = (char)0;
#line 2492
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2492
  *(buf + _yybytes_len) = tmp___0;
#line 2494
  b = vhdl_scan_buffer(buf, n, yyscanner);
  }
#line 2495
  if (! b) {
    {
#line 2496
    yy_fatal_error("bad buffer in vhdl_scan_bytes()", yyscanner);
    }
  }
#line 2501
  b->yy_is_our_buffer = 1;
#line 2503
  return (b);
}
}
#line 2510 "vhdl_flex.c"
static void yy_fatal_error(char const   *msg , yyscan_t yyscanner ) 
{ 


  {
  {
#line 2512
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2513
  exit(2);
  }
}
}
#line 2538 "vhdl_flex.c"
scan_extra_t *vhdlget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2540
  yyg = (struct yyguts_t *)yyscanner;
#line 2541
  return (yyg->yyextra_r);
}
}
#line 2547 "vhdl_flex.c"
int vhdlget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2549
  yyg = (struct yyguts_t *)yyscanner;
#line 2551
  if (yyg->yy_buffer_stack) {
#line 2551
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2551
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2551
  if (! tmp) {
#line 2552
    return (0);
  }
#line 2554
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 2560 "vhdl_flex.c"
int vhdlget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2562
  yyg = (struct yyguts_t *)yyscanner;
#line 2564
  if (yyg->yy_buffer_stack) {
#line 2564
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2564
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2564
  if (! tmp) {
#line 2565
    return (0);
  }
#line 2567
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 2573 "vhdl_flex.c"
FILE *vhdlget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2575
  yyg = (struct yyguts_t *)yyscanner;
#line 2576
  return (yyg->yyin_r);
}
}
#line 2582 "vhdl_flex.c"
FILE *vhdlget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2584
  yyg = (struct yyguts_t *)yyscanner;
#line 2585
  return (yyg->yyout_r);
}
}
#line 2591 "vhdl_flex.c"
int vhdlget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2593
  yyg = (struct yyguts_t *)yyscanner;
#line 2594
  return (yyg->yyleng_r);
}
}
#line 2601 "vhdl_flex.c"
char *vhdlget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2603
  yyg = (struct yyguts_t *)yyscanner;
#line 2604
  return (yyg->yytext_r);
}
}
#line 2611 "vhdl_flex.c"
void vhdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2613
  yyg = (struct yyguts_t *)yyscanner;
#line 2614
  yyg->yyextra_r = user_defined;
#line 2615
  return;
}
}
#line 2621 "vhdl_flex.c"
void vhdlset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2623
  yyg = (struct yyguts_t *)yyscanner;
#line 2626
  if (yyg->yy_buffer_stack) {
#line 2626
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2626
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2626
  if (! tmp) {
    {
#line 2627
    yy_fatal_error("vhdlset_lineno called with no buffer", yyscanner);
    }
  }
#line 2629
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 2630
  return;
}
}
#line 2636 "vhdl_flex.c"
void vhdlset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2638
  yyg = (struct yyguts_t *)yyscanner;
#line 2641
  if (yyg->yy_buffer_stack) {
#line 2641
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2641
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2641
  if (! tmp) {
    {
#line 2642
    yy_fatal_error("vhdlset_column called with no buffer", yyscanner);
    }
  }
#line 2644
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 2645
  return;
}
}
#line 2653 "vhdl_flex.c"
void vhdlset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2655
  yyg = (struct yyguts_t *)yyscanner;
#line 2656
  yyg->yyin_r = in_str;
#line 2657
  return;
}
}
#line 2659 "vhdl_flex.c"
void vhdlset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2661
  yyg = (struct yyguts_t *)yyscanner;
#line 2662
  yyg->yyout_r = out_str;
#line 2663
  return;
}
}
#line 2665 "vhdl_flex.c"
int vhdlget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2667
  yyg = (struct yyguts_t *)yyscanner;
#line 2668
  return (yyg->yy_flex_debug_r);
}
}
#line 2671 "vhdl_flex.c"
void vhdlset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2673
  yyg = (struct yyguts_t *)yyscanner;
#line 2674
  yyg->yy_flex_debug_r = bdebug;
#line 2675
  return;
}
}
#line 2679 "vhdl_flex.c"
YYSTYPE *vhdlget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2681
  yyg = (struct yyguts_t *)yyscanner;
#line 2682
  return (yyg->yylval_r);
}
}
#line 2685 "vhdl_flex.c"
void vhdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2687
  yyg = (struct yyguts_t *)yyscanner;
#line 2688
  yyg->yylval_r = yylval_param;
#line 2689
  return;
}
}
#line 2698 "vhdl_flex.c"
int vhdllex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2701
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2702
    tmp = __errno_location();
#line 2702
    *tmp = 22;
    }
#line 2703
    return (1);
  }
  {
#line 2706
  tmp___0 = vhdlalloc(sizeof(struct yyguts_t ), (void *)0);
#line 2706
  *ptr_yy_globals = tmp___0;
  }
#line 2708
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2709
    tmp___1 = __errno_location();
#line 2709
    *tmp___1 = 12;
    }
#line 2710
    return (1);
  }
  {
#line 2714
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 2716
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 2716
  return (tmp___2);
}
}
#line 2727 "vhdl_flex.c"
int vhdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2732
  vhdlset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 2734
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2735
    tmp = __errno_location();
#line 2735
    *tmp = 22;
    }
#line 2736
    return (1);
  }
  {
#line 2739
  tmp___0 = vhdlalloc(sizeof(struct yyguts_t ), (yyscan_t )(& dummy_yyguts));
#line 2739
  *ptr_yy_globals = tmp___0;
  }
#line 2741
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2742
    tmp___1 = __errno_location();
#line 2742
    *tmp___1 = 12;
    }
#line 2743
    return (1);
  }
  {
#line 2748
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 2750
  vhdlset_extra(yy_user_defined, *ptr_yy_globals);
#line 2752
  tmp___2 = yy_init_globals(*ptr_yy_globals);
  }
#line 2752
  return (tmp___2);
}
}
#line 2755 "vhdl_flex.c"
static int yy_init_globals(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 2757
  yyg = (struct yyguts_t *)yyscanner;
#line 2762
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2763
  yyg->yy_buffer_stack_top = (size_t )0;
#line 2764
  yyg->yy_buffer_stack_max = (size_t )0;
#line 2765
  yyg->yy_c_buf_p = (char *)0;
#line 2766
  yyg->yy_init = 0;
#line 2767
  yyg->yy_start = 0;
#line 2769
  yyg->yy_start_stack_ptr = 0;
#line 2770
  yyg->yy_start_stack_depth = 0;
#line 2771
  yyg->yy_start_stack = (int *)((void *)0);
#line 2773
  yyg->yy_state_buf = (yy_state_type *)0;
#line 2774
  yyg->yy_state_ptr = (yy_state_type *)0;
#line 2775
  yyg->yy_full_match = (char *)0;
#line 2776
  yyg->yy_lp = 0;
#line 2783
  yyg->yyin_r = (FILE *)0;
#line 2784
  yyg->yyout_r = (FILE *)0;
#line 2790
  return (0);
}
}
#line 2794 "vhdl_flex.c"
int vhdllex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2796
  yyg = (struct yyguts_t *)yyscanner;
  {
#line 2799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2799
    if (yyg->yy_buffer_stack) {
#line 2799
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2799
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2799
    if (! tmp___0) {
#line 2799
      goto while_break;
    }
#line 2800
    if (yyg->yy_buffer_stack) {
#line 2800
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2800
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2800
    vhdl_delete_buffer(tmp, yyscanner);
#line 2801
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2802
    vhdlpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2806
  vhdlfree((void *)yyg->yy_buffer_stack, yyscanner);
#line 2807
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2810
  vhdlfree((void *)yyg->yy_start_stack, yyscanner);
#line 2811
  yyg->yy_start_stack = (int *)((void *)0);
#line 2813
  vhdlfree((void *)yyg->yy_state_buf, yyscanner);
#line 2814
  yyg->yy_state_buf = (yy_state_type *)((void *)0);
#line 2818
  yy_init_globals(yyscanner);
#line 2821
  vhdlfree(yyscanner, yyscanner);
#line 2822
  yyscanner = (void *)0;
  }
#line 2823
  return (0);
}
}
#line 2850 "vhdl_flex.c"
void *vhdlalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2852
  tmp = malloc(size);
  }
#line 2852
  return (tmp);
}
}
#line 2855 "vhdl_flex.c"
void *vhdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2864
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2864
  return (tmp);
}
}
#line 2867 "vhdl_flex.c"
void vhdlfree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 2869
  free((void *)((char *)ptr));
  }
#line 2870
  return;
}
}
#line 357 "vhdl_flex.l"
void *vhdl_flex_init(FILE *f , int proc_mode ) 
{ 
  scan_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 363
  tmp = vhdllex_init(& scanner);
  }
#line 363
  if (tmp != 0) {
    {
#line 365
    bsdl_msg(proc_mode, 3, "Scanner could not be initialized\n");
    }
#line 366
    return ((void *)0);
  }
  {
#line 368
  vhdlset_in(f, scanner);
#line 370
  tmp___0 = malloc(sizeof(scan_extra_t ));
#line 370
  extra = (scan_extra_t *)tmp___0;
  }
#line 370
  if (! extra) {
    {
#line 372
    bsdl_msg(proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_flex.l", 373);
#line 374
    vhdllex_destroy(scanner);
    }
#line 375
    return ((void *)0);
  }
  {
#line 378
  extra->proc_mode = proc_mode;
#line 379
  extra->Compile_Errors = 0;
#line 380
  extra->Base = 1;
#line 382
  vhdlset_extra(extra, scanner);
  }
#line 384
  return (scanner);
}
}
#line 399 "vhdl_flex.l"
void vhdl_flex_deinit(void *scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;
  scan_extra_t *tmp___1 ;

  {
  {
#line 401
  tmp___0 = vhdlget_in(scanner);
  }
#line 401
  if (tmp___0) {
    {
#line 405
    tmp = vhdlget_in(scanner);
#line 405
    fclose(tmp);
#line 406
    vhdlset_in((FILE *)((void *)0), scanner);
    }
  }
  {
#line 408
  tmp___1 = vhdlget_extra(scanner);
#line 408
  free((void *)tmp___1);
#line 409
  vhdllex_destroy(scanner);
  }
#line 410
  return;
}
}
#line 424 "vhdl_flex.l"
int vhdlwrap(yyscan_t scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 426
  tmp___0 = vhdlget_in(scanner);
  }
#line 426
  if (tmp___0) {
    {
#line 428
    tmp = vhdlget_in(scanner);
#line 428
    fclose(tmp);
#line 429
    vhdlset_in((FILE *)((void *)0), scanner);
    }
  }
#line 431
  return (1);
}
}
#line 447 "vhdl_flex.l"
static char *new_string(scan_extra_t *extra , char const   *str ) 
{ 
  char *n_str ;
  size_t n_str_size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 452
  tmp = strlen(str);
#line 452
  n_str_size = tmp + 1UL;
#line 453
  tmp___0 = malloc(n_str_size);
#line 453
  n_str = (char *)tmp___0;
  }
#line 453
  if (n_str) {
    {
#line 455
    strncpy((char */* __restrict  */)n_str, (char const   */* __restrict  */)str,
            n_str_size - 1UL);
#line 456
    *(n_str + (n_str_size - 1UL)) = (char )'\000';
    }
  } else {
    {
#line 459
    bsdl_msg(extra->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_flex.l", 460);
    }
  }
#line 462
  return (n_str);
}
}
#line 478 "vhdl_flex.l"
void vhdl_flex_switch_file(void *scanner , char *filename ) 
{ 
  scan_extra_t *extra ;
  FILE *f ;
  char *s ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  char const   *db_path ;
  char const   *tmp___1 ;
  char *db_file ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  YY_BUFFER_STATE tmp___5 ;

  {
#line 485
  s = filename;
  {
#line 486
  while (1) {
    while_continue: /* CIL Label */ ;
#line 486
    if (! *s) {
#line 486
      goto while_break;
    }
    {
#line 488
    tmp___0 = __ctype_b_loc();
    }
#line 488
    if ((int const   )*(*tmp___0 + (int )*s) & 512) {
      {
#line 489
      tmp = toupper((int )*s);
#line 489
      *s = (char )tmp;
      }
    }
#line 490
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 493
  extra = vhdlget_extra(scanner);
#line 496
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 497
  if (! f) {
    {
#line 499
    tmp___1 = jtag_get_data_dir();
#line 499
    db_path = tmp___1;
#line 502
    tmp___2 = strlen(db_path);
#line 502
    tmp___3 = strlen((char const   *)filename);
#line 502
    tmp___4 = malloc(((((tmp___2 + 1UL) + 4UL) + 1UL) + tmp___3) + 1UL);
#line 502
    db_file = (char *)tmp___4;
    }
#line 502
    if (db_file) {
      {
#line 509
      strcpy((char */* __restrict  */)db_file, (char const   */* __restrict  */)db_path);
#line 510
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"/");
#line 511
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"bsdl");
#line 512
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)"/");
#line 513
      strcat((char */* __restrict  */)db_file, (char const   */* __restrict  */)filename);
#line 514
      f = fopen((char const   */* __restrict  */)db_file, (char const   */* __restrict  */)"r");
      }
#line 516
      if (! f) {
        {
#line 517
        bsdl_msg(extra->proc_mode, 3, "Cannot open file %s or %s.\n", filename, db_file);
        }
      }
      {
#line 519
      free((void *)db_file);
      }
#line 520
      if (! f) {
#line 521
        return;
      }
    }
  }
  {
#line 525
  tmp___5 = vhdl_create_buffer(f, 16384, scanner);
#line 525
  vhdlpush_buffer_state(tmp___5, scanner);
#line 526
  vhdlset_lineno(1, scanner);
  }
#line 527
  return;
}
}
#line 541 "vhdl_flex.l"
int vhdl_flex_get_compile_errors(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 543
  tmp = vhdlget_extra(scanner);
#line 543
  extra = tmp;
  }
#line 544
  return (extra->Compile_Errors);
}
}
#line 560 "vhdl_flex.l"
static void vhdl_flex_set_compile_errors(int n , yyscan_t scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 562
  tmp = vhdlget_extra(scanner);
#line 562
  extra = tmp;
#line 563
  extra->Compile_Errors = n;
  }
#line 564
  return;
}
}
#line 578 "vhdl_flex.l"
int vhdl_flex_postinc_compile_errors(void *scanner ) 
{ 
  int errors ;
  int tmp ;

  {
  {
#line 580
  tmp = vhdl_flex_get_compile_errors(scanner);
#line 580
  errors = tmp;
#line 582
  vhdl_flex_set_compile_errors(errors + 1, scanner);
  }
#line 583
  return (errors);
}
}
#line 598 "vhdl_flex.l"
int vhdl_flex_get_lineno(void *scanner ) 
{ 
  int tmp ;

  {
  {
#line 600
  tmp = vhdlget_lineno(scanner);
  }
#line 600
  return (tmp);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/vhdl_parser.h"
vhdl_parser_priv_t *vhdl_parser_init(FILE *f , jtag_ctrl_t *jtag_ctrl ) ;
#line 40
void vhdl_parser_deinit(vhdl_parser_priv_t *priv_data ) ;
#line 41
int vhdlparse(vhdl_parser_priv_t *priv_data ) ;
#line 155 "vhdl_bison.y"
static void Init_Text(vhdl_parser_priv_t *priv ) ;
#line 156
static void Store_Text(vhdl_parser_priv_t *priv , char *Source ) ;
#line 157
static void Print_Error(vhdl_parser_priv_t *priv_data , char const   *Errmess ) ;
#line 158
static void Give_Up_And_Quit(vhdl_parser_priv_t *priv_data ) ;
#line 161
static void vhdl_set_entity(vhdl_parser_priv_t *priv , char *entityname ) ;
#line 162
static void vhdl_port_add_name(vhdl_parser_priv_t *priv , char *name ) ;
#line 163
static void vhdl_port_add_bit(vhdl_parser_priv_t *priv ) ;
#line 164
static void vhdl_port_add_range(vhdl_parser_priv_t *priv , int low , int high ) ;
#line 165
static void vhdl_port_apply_port(vhdl_parser_priv_t *priv ) ;
#line 168
static void set_attr_decimal(vhdl_parser_priv_t *priv , char *name , int value ) ;
#line 169
static void set_attr_string(vhdl_parser_priv_t *priv , char *name , char *string ) ;
#line 173
void vhdlerror(vhdl_parser_priv_t *priv_data , char const   *error_string ) ;
#line 566 "vhdl_bison.c"
static yytype_uint8 const   yytranslate[336]  = 
#line 566 "vhdl_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80};
#line 758 "vhdl_bison.c"
static yytype_uint8 const   yyr1[146]  = 
#line 758
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )84,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )94,      (yytype_uint8 const   )94,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )95,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )103,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )111,      (yytype_uint8 const   )113,      (yytype_uint8 const   )112,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )114,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )118,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )119, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )123,      (yytype_uint8 const   )121,      (yytype_uint8 const   )124, 
        (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )125,      (yytype_uint8 const   )125, 
        (yytype_uint8 const   )126,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )130,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )135,      (yytype_uint8 const   )136,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )138,      (yytype_uint8 const   )140,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )141,      (yytype_uint8 const   )142,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )145};
#line 778 "vhdl_bison.c"
static yytype_uint8 const   yyr2[146]  = 
#line 778
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )9,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )10,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )9,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )7};
#line 800 "vhdl_bison.c"
static yytype_uint8 const   yydefact[328]  = 
#line 800
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )15,      (yytype_uint8 const   )0,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )140,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )115,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )113,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )29,      (yytype_uint8 const   )71,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )120,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )118,      (yytype_uint8 const   )114,      (yytype_uint8 const   )108,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )0,      (yytype_uint8 const   )138,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )137,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )139,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )109,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )35,      (yytype_uint8 const   )0,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )142,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )119,      (yytype_uint8 const   )0,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )128, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )110,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )143,      (yytype_uint8 const   )0,      (yytype_uint8 const   )135,      (yytype_uint8 const   )130, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )0,      (yytype_uint8 const   )127,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )66,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )0,      (yytype_uint8 const   )67,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )44,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )55,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )131,      (yytype_uint8 const   )0,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )61,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )39,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )144,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )0,      (yytype_uint8 const   )50,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )75,      (yytype_uint8 const   )0,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )54,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )60,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )77,      (yytype_uint8 const   )40,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )0,      (yytype_uint8 const   )83,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )80,      (yytype_uint8 const   )94,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )81,      (yytype_uint8 const   )78,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )107,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0,      (yytype_uint8 const   )82};
#line 838 "vhdl_bison.c"
static yytype_int16 const   yydefgoto[65]  = 
#line 838
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )3,      (yytype_int16 const   )4,      (yytype_int16 const   )9, 
        (yytype_int16 const   )15,      (yytype_int16 const   )10,      (yytype_int16 const   )18,      (yytype_int16 const   )30, 
        (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )78,      (yytype_int16 const   )88, 
        (yytype_int16 const   )105,      (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )53, 
        (yytype_int16 const   )106,      (yytype_int16 const   )119,      (yytype_int16 const   )156,      (yytype_int16 const   )157, 
        (yytype_int16 const   )196,      (yytype_int16 const   )202,      (yytype_int16 const   )222,      (yytype_int16 const   )223, 
        (yytype_int16 const   )224,      (yytype_int16 const   )215,      (yytype_int16 const   )216,      (yytype_int16 const   )169, 
        (yytype_int16 const   )170,      (yytype_int16 const   )184,      (yytype_int16 const   )45,      (yytype_int16 const   )247, 
        (yytype_int16 const   )286,      (yytype_int16 const   )274,      (yytype_int16 const   )275,      (yytype_int16 const   )292, 
        (yytype_int16 const   )293,      (yytype_int16 const   )305,      (yytype_int16 const   )316,      (yytype_int16 const   )326, 
        (yytype_int16 const   )46,      (yytype_int16 const   )83,      (yytype_int16 const   )126,      (yytype_int16 const   )141, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )64, 
        (yytype_int16 const   )43,      (yytype_int16 const   )57,      (yytype_int16 const   )58,      (yytype_int16 const   )138, 
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )175,      (yytype_int16 const   )61, 
        (yytype_int16 const   )62,      (yytype_int16 const   )85,      (yytype_int16 const   )26,      (yytype_int16 const   )98, 
        (yytype_int16 const   )36,      (yytype_int16 const   )108,      (yytype_int16 const   )109,      (yytype_int16 const   )158, 
        (yytype_int16 const   )122};
#line 852 "vhdl_bison.c"
static yytype_int16 const   yypact[328]  = 
#line 852
  {      (yytype_int16 const   )142,      (yytype_int16 const   )-159,      (yytype_int16 const   )-13,      (yytype_int16 const   )109, 
        (yytype_int16 const   )129,      (yytype_int16 const   )66,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )62,      (yytype_int16 const   )11,      (yytype_int16 const   )132,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )138,      (yytype_int16 const   )-159,      (yytype_int16 const   )96,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )97,      (yytype_int16 const   )101,      (yytype_int16 const   )98, 
        (yytype_int16 const   )93,      (yytype_int16 const   )106,      (yytype_int16 const   )-159,      (yytype_int16 const   )15, 
        (yytype_int16 const   )107,      (yytype_int16 const   )160,      (yytype_int16 const   )-159,      (yytype_int16 const   )158, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )69,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )70,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )99,      (yytype_int16 const   )-159,      (yytype_int16 const   )13,      (yytype_int16 const   )110, 
        (yytype_int16 const   )131,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )31,      (yytype_int16 const   )165,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )102,      (yytype_int16 const   )106,      (yytype_int16 const   )105,      (yytype_int16 const   )113, 
        (yytype_int16 const   )104,      (yytype_int16 const   )108,      (yytype_int16 const   )164,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )169,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )112, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )117, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )116,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )74,      (yytype_int16 const   )168, 
        (yytype_int16 const   )114,      (yytype_int16 const   )123,      (yytype_int16 const   )171,      (yytype_int16 const   )115, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )64,      (yytype_int16 const   )-159,      (yytype_int16 const   )118, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )119,      (yytype_int16 const   )-159,      (yytype_int16 const   )120, 
        (yytype_int16 const   )121,      (yytype_int16 const   )176,      (yytype_int16 const   )127,      (yytype_int16 const   )125, 
        (yytype_int16 const   )133,      (yytype_int16 const   )-159,      (yytype_int16 const   )166,      (yytype_int16 const   )94, 
        (yytype_int16 const   )116,      (yytype_int16 const   )126,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )90,      (yytype_int16 const   )128,      (yytype_int16 const   )16,      (yytype_int16 const   )75, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )167,      (yytype_int16 const   )192,      (yytype_int16 const   )193, 
        (yytype_int16 const   )92,      (yytype_int16 const   )-159,      (yytype_int16 const   )139,      (yytype_int16 const   )140, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )141,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )194,      (yytype_int16 const   )175,      (yytype_int16 const   )-159,      (yytype_int16 const   )-5, 
        (yytype_int16 const   )17,      (yytype_int16 const   )-159,      (yytype_int16 const   )21,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )199,      (yytype_int16 const   )202,      (yytype_int16 const   )75, 
        (yytype_int16 const   )143,      (yytype_int16 const   )144,      (yytype_int16 const   )95,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )147,      (yytype_int16 const   )146,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )148,      (yytype_int16 const   )-159,      (yytype_int16 const   )30,      (yytype_int16 const   )153, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )201,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )149,      (yytype_int16 const   )-159,      (yytype_int16 const   )208, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )155,      (yytype_int16 const   )-12,      (yytype_int16 const   )-7, 
        (yytype_int16 const   )89,      (yytype_int16 const   )-159,      (yytype_int16 const   )30,      (yytype_int16 const   )207, 
        (yytype_int16 const   )137,      (yytype_int16 const   )210,      (yytype_int16 const   )150,      (yytype_int16 const   )213, 
        (yytype_int16 const   )215,      (yytype_int16 const   )216,      (yytype_int16 const   )217,      (yytype_int16 const   )14, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )89,      (yytype_int16 const   )-159,      (yytype_int16 const   )20, 
        (yytype_int16 const   )75,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )156, 
        (yytype_int16 const   )134,      (yytype_int16 const   )2,      (yytype_int16 const   )191,      (yytype_int16 const   )1, 
        (yytype_int16 const   )218,      (yytype_int16 const   )219,      (yytype_int16 const   )-159,      (yytype_int16 const   )159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )91,      (yytype_int16 const   )-159,      (yytype_int16 const   )75, 
        (yytype_int16 const   )170,      (yytype_int16 const   )172,      (yytype_int16 const   )173,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )174,      (yytype_int16 const   )162,      (yytype_int16 const   )-159,      (yytype_int16 const   )19, 
        (yytype_int16 const   )163,      (yytype_int16 const   )6,      (yytype_int16 const   )177,      (yytype_int16 const   )178, 
        (yytype_int16 const   )179,      (yytype_int16 const   )190,      (yytype_int16 const   )181,      (yytype_int16 const   )180, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )182,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )198,      (yytype_int16 const   )-159,      (yytype_int16 const   )183,      (yytype_int16 const   )4, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )184,      (yytype_int16 const   )-159,      (yytype_int16 const   )185, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )186,      (yytype_int16 const   )78,      (yytype_int16 const   )79, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )188,      (yytype_int16 const   )189,      (yytype_int16 const   )-159,      (yytype_int16 const   )28, 
        (yytype_int16 const   )200,      (yytype_int16 const   )196,      (yytype_int16 const   )205,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )136,      (yytype_int16 const   )221,      (yytype_int16 const   )197,      (yytype_int16 const   )9, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )203,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )28,      (yytype_int16 const   )-159,      (yytype_int16 const   )220,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )195,      (yytype_int16 const   )204,      (yytype_int16 const   )-159,      (yytype_int16 const   )187, 
        (yytype_int16 const   )206,      (yytype_int16 const   )209,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )211,      (yytype_int16 const   )212, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )214,      (yytype_int16 const   )222,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )228,      (yytype_int16 const   )244,      (yytype_int16 const   )250,      (yytype_int16 const   )252, 
        (yytype_int16 const   )18,      (yytype_int16 const   )224,      (yytype_int16 const   )225,      (yytype_int16 const   )226, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )227,      (yytype_int16 const   )103,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )223,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )229, 
        (yytype_int16 const   )230,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )231, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )232,      (yytype_int16 const   )234,      (yytype_int16 const   )233, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )3,      (yytype_int16 const   )-159,      (yytype_int16 const   )0, 
        (yytype_int16 const   )82,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )235,      (yytype_int16 const   )3,      (yytype_int16 const   )237, 
        (yytype_int16 const   )5,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )238,      (yytype_int16 const   )29,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )239,      (yytype_int16 const   )-159};
#line 890 "vhdl_bison.c"
static yytype_int16 const   yypgoto[65]  = 
#line 890
  {      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )241,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )145,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-53,      (yytype_int16 const   )-65, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )23,      (yytype_int16 const   )-159,      (yytype_int16 const   )48,      (yytype_int16 const   )135, 
        (yytype_int16 const   )-158,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )22, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-10,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-39,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )242,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159,      (yytype_int16 const   )-62,      (yytype_int16 const   )245,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-107,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159,      (yytype_int16 const   )-159, 
        (yytype_int16 const   )-159};
#line 906 "vhdl_bison.c"
static yytype_uint16 const   yytable[311]  = 
#line 906
  {      (yytype_uint16 const   )120,      (yytype_uint16 const   )294,      (yytype_uint16 const   )198,      (yytype_uint16 const   )191, 
        (yytype_uint16 const   )290,      (yytype_uint16 const   )213,      (yytype_uint16 const   )311,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )165,      (yytype_uint16 const   )132,      (yytype_uint16 const   )218,      (yytype_uint16 const   )186, 
        (yytype_uint16 const   )13,      (yytype_uint16 const   )192,      (yytype_uint16 const   )55,      (yytype_uint16 const   )182, 
        (yytype_uint16 const   )234,      (yytype_uint16 const   )117,      (yytype_uint16 const   )186,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )213,      (yytype_uint16 const   )152,      (yytype_uint16 const   )139,      (yytype_uint16 const   )14, 
        (yytype_uint16 const   )145,      (yytype_uint16 const   )219,      (yytype_uint16 const   )163,      (yytype_uint16 const   )153, 
        (yytype_uint16 const   )273,      (yytype_uint16 const   )245,      (yytype_uint16 const   )318,      (yytype_uint16 const   )152, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )135,      (yytype_uint16 const   )136,      (yytype_uint16 const   )199, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )153,      (yytype_uint16 const   )112,      (yytype_uint16 const   )295, 
        (yytype_uint16 const   )296,      (yytype_uint16 const   )297,      (yytype_uint16 const   )298,      (yytype_uint16 const   )299, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )118,      (yytype_uint16 const   )302, 
        (yytype_uint16 const   )303,      (yytype_uint16 const   )5,      (yytype_uint16 const   )164,      (yytype_uint16 const   )140, 
        (yytype_uint16 const   )154,      (yytype_uint16 const   )155,      (yytype_uint16 const   )312,      (yytype_uint16 const   )313, 
        (yytype_uint16 const   )314,      (yytype_uint16 const   )315,      (yytype_uint16 const   )246,      (yytype_uint16 const   )84, 
        (yytype_uint16 const   )133,      (yytype_uint16 const   )134,      (yytype_uint16 const   )154,      (yytype_uint16 const   )155, 
        (yytype_uint16 const   )193,      (yytype_uint16 const   )188,      (yytype_uint16 const   )214,      (yytype_uint16 const   )194, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )221,      (yytype_uint16 const   )166,      (yytype_uint16 const   )201, 
        (yytype_uint16 const   )221,      (yytype_uint16 const   )291,      (yytype_uint16 const   )11,      (yytype_uint16 const   )56, 
        (yytype_uint16 const   )183,      (yytype_uint16 const   )33,      (yytype_uint16 const   )304,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )214,      (yytype_uint16 const   )319,      (yytype_uint16 const   )320, 
        (yytype_uint16 const   )321,      (yytype_uint16 const   )322,      (yytype_uint16 const   )323,      (yytype_uint16 const   )137, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )325,      (yytype_uint16 const   )152,      (yytype_uint16 const   )168, 
        (yytype_uint16 const   )152,      (yytype_uint16 const   )66,      (yytype_uint16 const   )34,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )153,      (yytype_uint16 const   )110,      (yytype_uint16 const   )153,      (yytype_uint16 const   )167, 
        (yytype_uint16 const   )86,      (yytype_uint16 const   )87,      (yytype_uint16 const   )22,      (yytype_uint16 const   )206, 
        (yytype_uint16 const   )272,      (yytype_uint16 const   )171,      (yytype_uint16 const   )168,      (yytype_uint16 const   )23, 
        (yytype_uint16 const   )37,      (yytype_uint16 const   )6,      (yytype_uint16 const   )34,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )111,      (yytype_uint16 const   )273,      (yytype_uint16 const   )38,      (yytype_uint16 const   )280, 
        (yytype_uint16 const   )185,      (yytype_uint16 const   )39,      (yytype_uint16 const   )114,      (yytype_uint16 const   )115, 
        (yytype_uint16 const   )168,      (yytype_uint16 const   )154,      (yytype_uint16 const   )155,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )155,      (yytype_uint16 const   )73,      (yytype_uint16 const   )74,      (yytype_uint16 const   )75, 
        (yytype_uint16 const   )76,      (yytype_uint16 const   )77,      (yytype_uint16 const   )7,      (yytype_uint16 const   )94, 
        (yytype_uint16 const   )12,      (yytype_uint16 const   )16,      (yytype_uint16 const   )8,      (yytype_uint16 const   )95, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )49,      (yytype_uint16 const   )38,      (yytype_uint16 const   )51, 
        (yytype_uint16 const   )50,      (yytype_uint16 const   )39,      (yytype_uint16 const   )52,      (yytype_uint16 const   )1, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )2,      (yytype_uint16 const   )190,      (yytype_uint16 const   )239, 
        (yytype_uint16 const   )241,      (yytype_uint16 const   )240,      (yytype_uint16 const   )242,      (yytype_uint16 const   )306, 
        (yytype_uint16 const   )19,      (yytype_uint16 const   )307,      (yytype_uint16 const   )34,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )173,      (yytype_uint16 const   )174,      (yytype_uint16 const   )20,      (yytype_uint16 const   )94, 
        (yytype_uint16 const   )125,      (yytype_uint16 const   )28,      (yytype_uint16 const   )94,      (yytype_uint16 const   )148, 
        (yytype_uint16 const   )251,      (yytype_uint16 const   )252,      (yytype_uint16 const   )44,      (yytype_uint16 const   )21, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )48,      (yytype_uint16 const   )27,      (yytype_uint16 const   )67, 
        (yytype_uint16 const   )63,      (yytype_uint16 const   )71,      (yytype_uint16 const   )54,      (yytype_uint16 const   )72, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )80,      (yytype_uint16 const   )81,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )84,      (yytype_uint16 const   )89,      (yytype_uint16 const   )90,      (yytype_uint16 const   )79, 
        (yytype_uint16 const   )82,      (yytype_uint16 const   )91,      (yytype_uint16 const   )92,      (yytype_uint16 const   )97, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )101,      (yytype_uint16 const   )93,      (yytype_uint16 const   )102, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )103,      (yytype_uint16 const   )113,      (yytype_uint16 const   )100, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )121,      (yytype_uint16 const   )104,      (yytype_uint16 const   )116, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )124,      (yytype_uint16 const   )130,      (yytype_uint16 const   )129, 
        (yytype_uint16 const   )127,      (yytype_uint16 const   )128,      (yytype_uint16 const   )131,      (yytype_uint16 const   )142, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )159,      (yytype_uint16 const   )151,      (yytype_uint16 const   )146, 
        (yytype_uint16 const   )147,      (yytype_uint16 const   )149,      (yytype_uint16 const   )150,      (yytype_uint16 const   )33, 
        (yytype_uint16 const   )161,      (yytype_uint16 const   )162,      (yytype_uint16 const   )160,      (yytype_uint16 const   )172, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )178,      (yytype_uint16 const   )177,      (yytype_uint16 const   )179, 
        (yytype_uint16 const   )180,      (yytype_uint16 const   )181,      (yytype_uint16 const   )197,      (yytype_uint16 const   )189, 
        (yytype_uint16 const   )228,      (yytype_uint16 const   )203,      (yytype_uint16 const   )204,      (yytype_uint16 const   )205, 
        (yytype_uint16 const   )212,      (yytype_uint16 const   )217,      (yytype_uint16 const   )232,      (yytype_uint16 const   )210, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )248,      (yytype_uint16 const   )208,      (yytype_uint16 const   )250, 
        (yytype_uint16 const   )209,      (yytype_uint16 const   )253,      (yytype_uint16 const   )211,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )238,      (yytype_uint16 const   )225,      (yytype_uint16 const   )226,      (yytype_uint16 const   )227, 
        (yytype_uint16 const   )230,      (yytype_uint16 const   )236,      (yytype_uint16 const   )231,      (yytype_uint16 const   )258, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )269,      (yytype_uint16 const   )237,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )244,      (yytype_uint16 const   )249,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )254,      (yytype_uint16 const   )271,      (yytype_uint16 const   )255,      (yytype_uint16 const   )235, 
        (yytype_uint16 const   )281,      (yytype_uint16 const   )256,      (yytype_uint16 const   )257,      (yytype_uint16 const   )309, 
        (yytype_uint16 const   )259,      (yytype_uint16 const   )285,      (yytype_uint16 const   )47,      (yytype_uint16 const   )262, 
        (yytype_uint16 const   )260,      (yytype_uint16 const   )264,      (yytype_uint16 const   )0,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )263,      (yytype_uint16 const   )68,      (yytype_uint16 const   )65,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )266,      (yytype_uint16 const   )276,      (yytype_uint16 const   )277, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )279,      (yytype_uint16 const   )70,      (yytype_uint16 const   )282, 
        (yytype_uint16 const   )284,      (yytype_uint16 const   )267,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )283,      (yytype_uint16 const   )288,      (yytype_uint16 const   )289, 
        (yytype_uint16 const   )308,      (yytype_uint16 const   )310,      (yytype_uint16 const   )287,      (yytype_uint16 const   )317, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )327};
#line 942 "vhdl_bison.c"
static yytype_int16 const   yycheck[311]  = 
#line 942
  {      (yytype_int16 const   )107,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )15,      (yytype_int16 const   )14,      (yytype_int16 const   )1,      (yytype_int16 const   )169, 
        (yytype_int16 const   )1,      (yytype_int16 const   )11,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )12,      (yytype_int16 const   )1,      (yytype_int16 const   )176,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )12, 
        (yytype_int16 const   )131,      (yytype_int16 const   )19,      (yytype_int16 const   )38,      (yytype_int16 const   )7, 
        (yytype_int16 const   )10,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )12,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )34, 
        (yytype_int16 const   )35,      (yytype_int16 const   )7,      (yytype_int16 const   )100,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )30,      (yytype_int16 const   )47, 
        (yytype_int16 const   )48,      (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )30, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )30,      (yytype_int16 const   )64, 
        (yytype_int16 const   )65,      (yytype_int16 const   )123,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )62,      (yytype_int16 const   )172,      (yytype_int16 const   )62,      (yytype_int16 const   )65, 
        (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )77,      (yytype_int16 const   )70, 
        (yytype_int16 const   )63,      (yytype_int16 const   )70,      (yytype_int16 const   )8,      (yytype_int16 const   )62, 
        (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )78,      (yytype_int16 const   )77, 
        (yytype_int16 const   )187,      (yytype_int16 const   )62,      (yytype_int16 const   )53,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )70, 
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )1,      (yytype_int16 const   )156, 
        (yytype_int16 const   )1,      (yytype_int16 const   )62,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )7,      (yytype_int16 const   )3,      (yytype_int16 const   )7,      (yytype_int16 const   )10, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )1,      (yytype_int16 const   )12, 
        (yytype_int16 const   )1,      (yytype_int16 const   )158,      (yytype_int16 const   )171,      (yytype_int16 const   )6, 
        (yytype_int16 const   )1,      (yytype_int16 const   )0,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )18,      (yytype_int16 const   )10,      (yytype_int16 const   )7,      (yytype_int16 const   )12, 
        (yytype_int16 const   )169,      (yytype_int16 const   )10,      (yytype_int16 const   )28,      (yytype_int16 const   )29, 
        (yytype_int16 const   )185,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )21,      (yytype_int16 const   )22,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )25,      (yytype_int16 const   )1,      (yytype_int16 const   )67, 
        (yytype_int16 const   )70,      (yytype_int16 const   )1,      (yytype_int16 const   )5,      (yytype_int16 const   )71, 
        (yytype_int16 const   )4,      (yytype_int16 const   )68,      (yytype_int16 const   )7,      (yytype_int16 const   )69, 
        (yytype_int16 const   )71,      (yytype_int16 const   )10,      (yytype_int16 const   )72,      (yytype_int16 const   )1, 
        (yytype_int16 const   )10,      (yytype_int16 const   )3,      (yytype_int16 const   )12,      (yytype_int16 const   )69, 
        (yytype_int16 const   )69,      (yytype_int16 const   )71,      (yytype_int16 const   )71,      (yytype_int16 const   )69, 
        (yytype_int16 const   )14,      (yytype_int16 const   )71,      (yytype_int16 const   )79,      (yytype_int16 const   )80, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )62,      (yytype_int16 const   )67, 
        (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )67,      (yytype_int16 const   )68, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )6,      (yytype_int16 const   )70, 
        (yytype_int16 const   )62,      (yytype_int16 const   )11,      (yytype_int16 const   )72,      (yytype_int16 const   )6, 
        (yytype_int16 const   )62,      (yytype_int16 const   )68,      (yytype_int16 const   )75,      (yytype_int16 const   )62, 
        (yytype_int16 const   )74,      (yytype_int16 const   )13,      (yytype_int16 const   )9,      (yytype_int16 const   )62, 
        (yytype_int16 const   )64,      (yytype_int16 const   )13,      (yytype_int16 const   )68,      (yytype_int16 const   )75, 
        (yytype_int16 const   )72,      (yytype_int16 const   )62,      (yytype_int16 const   )15,      (yytype_int16 const   )68, 
        (yytype_int16 const   )70,      (yytype_int16 const   )13,      (yytype_int16 const   )75,      (yytype_int16 const   )64, 
        (yytype_int16 const   )72,      (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )74, 
        (yytype_int16 const   )30,      (yytype_int16 const   )30,      (yytype_int16 const   )65,      (yytype_int16 const   )71, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )62, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )31,      (yytype_int16 const   )8, 
        (yytype_int16 const   )6,      (yytype_int16 const   )8,      (yytype_int16 const   )62,      (yytype_int16 const   )68, 
        (yytype_int16 const   )68,      (yytype_int16 const   )66,      (yytype_int16 const   )68,      (yytype_int16 const   )62, 
        (yytype_int16 const   )8,      (yytype_int16 const   )62,      (yytype_int16 const   )69,      (yytype_int16 const   )12, 
        (yytype_int16 const   )10,      (yytype_int16 const   )8,      (yytype_int16 const   )72,      (yytype_int16 const   )8, 
        (yytype_int16 const   )8,      (yytype_int16 const   )8,      (yytype_int16 const   )35,      (yytype_int16 const   )71, 
        (yytype_int16 const   )38,      (yytype_int16 const   )11,      (yytype_int16 const   )11,      (yytype_int16 const   )72, 
        (yytype_int16 const   )70,      (yytype_int16 const   )70,      (yytype_int16 const   )36,      (yytype_int16 const   )62, 
        (yytype_int16 const   )8,      (yytype_int16 const   )37,      (yytype_int16 const   )68,      (yytype_int16 const   )34, 
        (yytype_int16 const   )68,      (yytype_int16 const   )20,      (yytype_int16 const   )68,      (yytype_int16 const   )62, 
        (yytype_int16 const   )58,      (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )68, 
        (yytype_int16 const   )68,      (yytype_int16 const   )65,      (yytype_int16 const   )68,      (yytype_int16 const   )31, 
        (yytype_int16 const   )65,      (yytype_int16 const   )9,      (yytype_int16 const   )69,      (yytype_int16 const   )72, 
        (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )62,      (yytype_int16 const   )9, 
        (yytype_int16 const   )63,      (yytype_int16 const   )9,      (yytype_int16 const   )239,      (yytype_int16 const   )215, 
        (yytype_int16 const   )274,      (yytype_int16 const   )62,      (yytype_int16 const   )244,      (yytype_int16 const   )306, 
        (yytype_int16 const   )73,      (yytype_int16 const   )38,      (yytype_int16 const   )25,      (yytype_int16 const   )65, 
        (yytype_int16 const   )68,      (yytype_int16 const   )62,      (yytype_int16 const   )-1,      (yytype_int16 const   )130, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )71,      (yytype_int16 const   )45,      (yytype_int16 const   )40,      (yytype_int16 const   )71, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )71,      (yytype_int16 const   )62,      (yytype_int16 const   )62, 
        (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )49,      (yytype_int16 const   )68, 
        (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )161,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )72,      (yytype_int16 const   )68,      (yytype_int16 const   )70, 
        (yytype_int16 const   )69,      (yytype_int16 const   )68,      (yytype_int16 const   )74,      (yytype_int16 const   )69, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )71};
#line 980 "vhdl_bison.c"
static yytype_uint8 const   yystos[328]  = 
#line 980
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )62,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )84,      (yytype_uint8 const   )86,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )12,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )87,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )139,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )62,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )62,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )125,      (yytype_uint8 const   )126,      (yytype_uint8 const   )127,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )111,      (yytype_uint8 const   )121,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )68,      (yytype_uint8 const   )71,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )96,      (yytype_uint8 const   )75,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131,      (yytype_uint8 const   )133, 
        (yytype_uint8 const   )134,      (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )128,      (yytype_uint8 const   )126,      (yytype_uint8 const   )62,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )74,      (yytype_uint8 const   )89,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )25,      (yytype_uint8 const   )91,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )9,      (yytype_uint8 const   )72,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )138,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )13,      (yytype_uint8 const   )68,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )75,      (yytype_uint8 const   )67,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )68,      (yytype_uint8 const   )140,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )13,      (yytype_uint8 const   )64,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )93,      (yytype_uint8 const   )97,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )143,      (yytype_uint8 const   )3,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )68,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )1,      (yytype_uint8 const   )30,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )30,      (yytype_uint8 const   )145,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )68,      (yytype_uint8 const   )123,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )62,      (yytype_uint8 const   )8,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )65,      (yytype_uint8 const   )138,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )70,      (yytype_uint8 const   )132,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )124,      (yytype_uint8 const   )8,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )141,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )66,      (yytype_uint8 const   )68,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )7,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )144,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )8,      (yytype_uint8 const   )62,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )15,      (yytype_uint8 const   )77,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )72,      (yytype_uint8 const   )8,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )8,      (yytype_uint8 const   )1,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )110,      (yytype_uint8 const   )99,      (yytype_uint8 const   )109,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )71,      (yytype_uint8 const   )12,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )62,      (yytype_uint8 const   )65,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )35,      (yytype_uint8 const   )1,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )70,      (yytype_uint8 const   )102,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )72,      (yytype_uint8 const   )12,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )62,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )62,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )107,      (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )62,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )72,      (yytype_uint8 const   )12,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )69,      (yytype_uint8 const   )58,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )69,      (yytype_uint8 const   )71,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )1,      (yytype_uint8 const   )30,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )62,      (yytype_uint8 const   )34,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )20,      (yytype_uint8 const   )63,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )112,      (yytype_uint8 const   )31,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )10,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )115,      (yytype_uint8 const   )68,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )38,      (yytype_uint8 const   )113,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )70,      (yytype_uint8 const   )1,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )1,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )118,      (yytype_uint8 const   )69,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )117,      (yytype_uint8 const   )68,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )69,      (yytype_uint8 const   )1,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )120,      (yytype_uint8 const   )71};
#line 1508 "vhdl_bison.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , vhdl_parser_priv_t *priv_data ) 
{ 


  {
#line 1522
  if (! yymsg) {
#line 1523
    yymsg = "Deleting";
  }
  {
#line 1529
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1530
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1532
  return;
}
}
#line 1573 "vhdl_bison.c"
int vhdlparse(vhdl_parser_priv_t *priv_data ) 
{ 
  int vhdlchar ;
  YYSTYPE vhdllval ;
  int vhdlnerrs ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;

  {
#line 1597
  yytoken = 0;
#line 1615
  yyss = yyssa;
#line 1620
  yyvs = yyvsa;
#line 1627
  yystacksize = 200UL;
#line 1636
  yylen = 0;
#line 1640
  yystate = 0;
#line 1641
  yyerrstatus = 0;
#line 1642
  vhdlnerrs = 0;
#line 1643
  vhdlchar = -2;
#line 1650
  yyssp = yyss;
#line 1651
  yyvsp = yyvs;
#line 1653
  goto yysetstate;
  yynewstate: 
#line 1661
  yyssp ++;
  yysetstate: 
#line 1664
  *yyssp = (yytype_int16 )yystate;
#line 1666
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1669
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1698
    if (10000UL <= yystacksize) {
#line 1699
      goto yyexhaustedlab;
    }
#line 1700
    yystacksize *= 2UL;
#line 1701
    if (10000UL < yystacksize) {
#line 1702
      yystacksize = 10000UL;
    }
    {
#line 1705
    yyss1 = yyss;
#line 1706
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1706
    yyptr = (union yyalloc *)tmp;
    }
#line 1708
    if (! yyptr) {
#line 1709
      goto yyexhaustedlab;
    }
    {
#line 1710
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1710
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1710
      yyss = & yyptr->yyss;
#line 1710
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1710
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1710
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1711
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1711
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1711
      yyvs = & yyptr->yyvs;
#line 1711
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1711
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1711
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1714
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1715
      free((void *)yyss1);
      }
    }
#line 1720
    yyssp = (yyss + yysize) - 1;
#line 1721
    yyvsp = (yyvs + yysize) - 1;
#line 1727
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1728
      goto yyabortlab;
    }
  }
#line 1733
  goto yybackup;
  yybackup: 
#line 1744
  yyn = (int )yypact[yystate];
#line 1745
  if (yyn == -159) {
#line 1746
    goto yydefault;
  }
#line 1751
  if (vhdlchar == -2) {
    {
#line 1754
    vhdlchar = vhdllex(& vhdllval, priv_data->scanner);
    }
  }
#line 1757
  if (vhdlchar <= 0) {
#line 1759
    yytoken = 0;
#line 1759
    vhdlchar = yytoken;
  } else
#line 1764
  if ((unsigned int )vhdlchar <= 335U) {
#line 1764
    yytoken = (int )yytranslate[vhdlchar];
  } else {
#line 1764
    yytoken = 2;
  }
#line 1770
  yyn += yytoken;
#line 1771
  if (yyn < 0) {
#line 1772
    goto yydefault;
  } else
#line 1771
  if (310 < yyn) {
#line 1772
    goto yydefault;
  } else
#line 1771
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1772
    goto yydefault;
  }
#line 1773
  yyn = (int )yytable[yyn];
#line 1774
  if (yyn <= 0) {
#line 1776
    if (yyn == 0) {
#line 1777
      goto yyerrlab;
    } else
#line 1776
    if (yyn == -1) {
#line 1777
      goto yyerrlab;
    }
#line 1778
    yyn = - yyn;
#line 1779
    goto yyreduce;
  }
#line 1782
  if (yyn == 6) {
#line 1783
    goto yyacceptlab;
  }
#line 1787
  if (yyerrstatus) {
#line 1788
    yyerrstatus --;
  }
#line 1794
  if (vhdlchar != 0) {
#line 1795
    vhdlchar = -2;
  }
#line 1797
  yystate = yyn;
#line 1798
  yyvsp ++;
#line 1798
  *yyvsp = vhdllval;
#line 1800
  goto yynewstate;
  yydefault: 
#line 1807
  yyn = (int )yydefact[yystate];
#line 1808
  if (yyn == 0) {
#line 1809
    goto yyerrlab;
  }
#line 1810
  goto yyreduce;
  yyreduce: 
#line 1818
  yylen = (int )yyr2[yyn];
#line 1828
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1834
  if (yyn == 3) {
#line 1834
    goto case_3;
  }
#line 219
  if (yyn == 4) {
#line 219 "vhdl_bison.y"
    goto case_4;
  }
#line 225
  if (yyn == 6) {
#line 225
    goto case_6;
  }
#line 235
  if (yyn == 7) {
#line 235
    goto case_7;
  }
#line 238
  if (yyn == 8) {
#line 238
    goto case_8;
  }
#line 243
  if (yyn == 11) {
#line 243
    goto case_11;
  }
#line 253
  if (yyn == 14) {
#line 253
    goto case_14;
  }
#line 259
  if (yyn == 15) {
#line 259
    goto case_15;
  }
#line 262
  if (yyn == 16) {
#line 262
    goto case_16;
  }
#line 264
  if (yyn == 22) {
#line 264
    goto case_22;
  }
#line 269
  if (yyn == 24) {
#line 269
    goto case_24;
  }
#line 273
  if (yyn == 25) {
#line 273
    goto case_25;
  }
#line 275
  if (yyn == 30) {
#line 275
    goto case_30;
  }
#line 285
  if (yyn == 31) {
#line 285
    goto case_31;
  }
#line 291
  if (yyn == 32) {
#line 291
    goto case_32;
  }
#line 297
  if (yyn == 33) {
#line 297
    goto case_33;
  }
#line 301
  if (yyn == 34) {
#line 301
    goto case_34;
  }
#line 305
  if (yyn == 35) {
#line 305
    goto case_35;
  }
#line 310
  if (yyn == 38) {
#line 310
    goto case_38;
  }
#line 316
  if (yyn == 39) {
#line 316
    goto case_39;
  }
#line 318
  if (yyn == 40) {
#line 318
    goto case_40;
  }
#line 321
  if (yyn == 43) {
#line 321
    goto case_43;
  }
#line 328
  if (yyn == 44) {
#line 328
    goto case_44;
  }
#line 331
  if (yyn == 48) {
#line 331
    goto case_48;
  }
#line 339
  if (yyn == 52) {
#line 339
    goto case_52;
  }
#line 346
  if (yyn == 53) {
#line 346
    goto case_53;
  }
#line 349
  if (yyn == 55) {
#line 349
    goto case_55;
  }
#line 355
  if (yyn == 58) {
#line 355
    goto case_58;
  }
#line 361
  if (yyn == 59) {
#line 361
    goto case_59;
  }
#line 363
  if (yyn == 60) {
#line 363
    goto case_60;
  }
#line 366
  if (yyn == 61) {
#line 366
    goto case_61;
  }
#line 371
  if (yyn == 64) {
#line 371
    goto case_64;
  }
#line 377
  if (yyn == 65) {
#line 377
    goto case_65;
  }
#line 382
  if (yyn == 69) {
#line 382
    goto case_69;
  }
#line 390
  if (yyn == 70) {
#line 390
    goto case_70;
  }
#line 395
  if (yyn == 73) {
#line 395
    goto case_73;
  }
#line 401
  if (yyn == 75) {
#line 401
    goto case_75;
  }
#line 407
  if (yyn == 78) {
#line 407
    goto case_78;
  }
#line 414
  if (yyn == 79) {
#line 414
    goto case_79;
  }
#line 419
  if (yyn == 83) {
#line 419
    goto case_83;
  }
#line 430
  if (yyn == 94) {
#line 430
    goto case_94;
  }
#line 439
  if (yyn == 99) {
#line 439
    goto case_99;
  }
#line 446
  if (yyn == 107) {
#line 446
    goto case_107;
  }
#line 453
  if (yyn == 108) {
#line 453
    goto case_108;
  }
#line 459
  if (yyn == 109) {
#line 459
    goto case_109;
  }
#line 465
  if (yyn == 110) {
#line 465
    goto case_110;
  }
#line 469
  if (yyn == 111) {
#line 469
    goto case_111;
  }
#line 473
  if (yyn == 112) {
#line 473
    goto case_112;
  }
#line 476
  if (yyn == 115) {
#line 476
    goto case_115;
  }
#line 484
  if (yyn == 119) {
#line 484
    goto case_119;
  }
#line 494
  if (yyn == 126) {
#line 494
    goto case_126;
  }
#line 507
  if (yyn == 127) {
#line 507
    goto case_127;
  }
#line 515
  if (yyn == 128) {
#line 515
    goto case_128;
  }
#line 518
  if (yyn == 129) {
#line 518
    goto case_129;
  }
#line 520
  if (yyn == 130) {
#line 520
    goto case_130;
  }
#line 526
  if (yyn == 131) {
#line 526
    goto case_131;
  }
#line 534
  if (yyn == 134) {
#line 534
    goto case_134;
  }
#line 542
  if (yyn == 135) {
#line 542
    goto case_135;
  }
#line 545
  if (yyn == 136) {
#line 545
    goto case_136;
  }
#line 552
  if (yyn == 137) {
#line 552
    goto case_137;
  }
#line 557
  if (yyn == 138) {
#line 557
    goto case_138;
  }
#line 564
  if (yyn == 139) {
#line 564
    goto case_139;
  }
#line 568
  if (yyn == 140) {
#line 568
    goto case_140;
  }
#line 573
  if (yyn == 141) {
#line 573
    goto case_141;
  }
#line 577
  if (yyn == 143) {
#line 577
    goto case_143;
  }
#line 2277 "vhdl_bison.c"
  goto switch_default;
  case_3: /* CIL Label */ 
  {
#line 216 "vhdl_bison.y"
  vhdl_set_entity(priv_data, (yyvsp + -1)->str);
  }
#line 217
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 219
  Print_Error(priv_data, "Improper Entity declaration");
#line 220
  Print_Error(priv_data, "Check if source file is BSDL");
#line 221
  tmp___0 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 221
  if (tmp___0 > 15) {
    {
#line 221
    Give_Up_And_Quit(priv_data);
    }
#line 221
    goto yyabortlab;
  }
#line 221
  goto yyabortlab;
#line 223
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 230
  Print_Error(priv_data, "Syntax Error");
#line 231
  tmp___1 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 231
  if (tmp___1 > 15) {
    {
#line 231
    Give_Up_And_Quit(priv_data);
    }
#line 231
    goto yyabortlab;
  }
#line 231
  goto yyabortlab;
#line 233
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 235
  free((void *)(yyvsp + -1)->str);
  }
#line 236
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 238
  Print_Error(priv_data, "Syntax Error");
#line 239
  tmp___2 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 239
  if (tmp___2 > 15) {
    {
#line 239
    Give_Up_And_Quit(priv_data);
    }
#line 239
    goto yyabortlab;
  }
#line 239
  goto yyabortlab;
#line 241
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 248
  Print_Error(priv_data, "Improper Port declaration");
#line 249
  tmp___3 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 249
  if (tmp___3 > 15) {
    {
#line 249
    Give_Up_And_Quit(priv_data);
    }
#line 249
    goto yyabortlab;
  }
#line 249
  goto yyabortlab;
#line 251
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 256
  vhdl_port_apply_port(priv_data);
  }
#line 257
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 259
  vhdl_port_add_name(priv_data, (yyvsp + 0)->str);
  }
#line 260
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 261
  vhdl_port_add_name(priv_data, (yyvsp + 0)->str);
  }
#line 262
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 266
  vhdl_port_add_bit(priv_data);
  }
#line 267
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 270
  vhdl_port_add_range(priv_data, (yyvsp + -2)->integer, (yyvsp + 0)->integer);
  }
#line 271
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 272
  vhdl_port_add_range(priv_data, (yyvsp + 0)->integer, (yyvsp + -2)->integer);
  }
#line 273
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 280
  Print_Error(priv_data, "Error in Package declaration(s)");
#line 281
  tmp___4 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 281
  if (tmp___4 > 15) {
    {
#line 281
    Give_Up_And_Quit(priv_data);
    }
#line 281
    goto yyabortlab;
  }
#line 281
  goto yyabortlab;
#line 283
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 286
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)(yyvsp + 0)->str);
#line 287
  free((void *)(yyvsp + 0)->str);
  }
#line 289
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 291
  priv_data->Reading_Package = 1;
#line 292
  vhdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 295
  goto switch_break;
  case_33: /* CIL Label */ 
#line 297
  priv_data->Reading_Package = 0;
#line 299
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 302
  free((void *)(yyvsp + -8)->str);
#line 302
  free((void *)(yyvsp + -2)->str);
  }
#line 303
  goto switch_break;
  case_35: /* CIL Label */ 
  {
#line 305
  Print_Error(priv_data, "Error in Standard Package");
#line 306
  tmp___5 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 306
  if (tmp___5 > 15) {
    {
#line 306
    Give_Up_And_Quit(priv_data);
    }
#line 306
    goto yyabortlab;
  }
#line 306
  goto yyabortlab;
#line 308
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 313
  free((void *)(yyvsp + -3)->str);
  }
#line 314
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 315
  free((void *)(yyvsp + -3)->str);
  }
#line 316
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 318
  free((void *)(yyvsp + -1)->str);
  }
#line 319
  goto switch_break;
  case_43: /* CIL Label */ 
  {
#line 323
  Print_Error(priv_data, "Error in Standard Declarations");
#line 324
  tmp___6 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 324
  if (tmp___6 > 15) {
    {
#line 324
    Give_Up_And_Quit(priv_data);
    }
#line 324
    goto yyabortlab;
  }
#line 324
  goto yyabortlab;
#line 326
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 328
  free((void *)(yyvsp + 0)->str);
  }
#line 329
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 334
  Print_Error(priv_data, "Error in Attribute type identification");
#line 335
  tmp___7 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 335
  if (tmp___7 > 15) {
    {
#line 335
    Give_Up_And_Quit(priv_data);
    }
#line 335
    goto yyabortlab;
  }
#line 335
  goto yyabortlab;
#line 337
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 343
  free((void *)(yyvsp + 0)->str);
  }
#line 344
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 346
  free((void *)(yyvsp + 0)->str);
  }
#line 347
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 350
  Print_Error(priv_data, "Error in Type definition");
#line 351
  tmp___8 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 351
  if (tmp___8 > 15) {
    {
#line 351
    Give_Up_And_Quit(priv_data);
    }
#line 351
    goto yyabortlab;
  }
#line 351
  goto yyabortlab;
#line 353
  goto switch_break;
  case_58: /* CIL Label */ 
  {
#line 358
  free((void *)(yyvsp + 0)->str);
  }
#line 359
  goto switch_break;
  case_59: /* CIL Label */ 
  {
#line 360
  free((void *)(yyvsp + 0)->str);
  }
#line 361
  goto switch_break;
  case_60: /* CIL Label */ 
  {
#line 363
  free((void *)(yyvsp + -1)->str);
  }
#line 364
  goto switch_break;
  case_61: /* CIL Label */ 
  {
#line 366
  Print_Error(priv_data, "Error in Bit definition");
#line 367
  tmp___9 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 367
  if (tmp___9 > 15) {
    {
#line 367
    Give_Up_And_Quit(priv_data);
    }
#line 367
    goto yyabortlab;
  }
#line 367
  goto yyabortlab;
#line 369
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 374
  free((void *)(yyvsp + -3)->str);
#line 374
  free((void *)(yyvsp + -1)->str);
  }
#line 375
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 377
  Print_Error(priv_data, "Error in Record Definition");
#line 378
  tmp___10 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 378
  if (tmp___10 > 15) {
    {
#line 378
    Give_Up_And_Quit(priv_data);
    }
#line 378
    goto yyabortlab;
  }
#line 378
  goto yyabortlab;
#line 380
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 387
  free((void *)(yyvsp + -3)->str);
  }
#line 388
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 390
  Print_Error(priv_data, "Error in defered constant");
#line 391
  tmp___11 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 391
  if (tmp___11 > 15) {
    {
#line 391
    Give_Up_And_Quit(priv_data);
    }
#line 391
    goto yyabortlab;
  }
#line 391
  goto yyabortlab;
#line 393
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 398
  free((void *)(yyvsp + -4)->str);
#line 398
  free((void *)(yyvsp + 0)->str);
  }
#line 399
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 402
  Print_Error(priv_data, "Error in Package Body definition");
#line 403
  tmp___12 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 403
  if (tmp___12 > 15) {
    {
#line 403
    Give_Up_And_Quit(priv_data);
    }
#line 403
    goto yyabortlab;
  }
#line 403
  goto yyabortlab;
#line 405
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 411
  free((void *)(yyvsp + -7)->str);
  }
#line 412
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 414
  Print_Error(priv_data, "Error in Cell Constant definition");
#line 415
  tmp___13 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 415
  if (tmp___13 > 15) {
    {
#line 415
    Give_Up_And_Quit(priv_data);
    }
#line 415
    goto yyabortlab;
  }
#line 415
  goto yyabortlab;
#line 417
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 425
  Print_Error(priv_data, "Error in Cell Data Record");
#line 426
  tmp___14 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 426
  if (tmp___14 > 15) {
    {
#line 426
    Give_Up_And_Quit(priv_data);
    }
#line 426
    goto yyabortlab;
  }
#line 426
  goto yyabortlab;
#line 428
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 434
  Print_Error(priv_data, "Error in Cell_Type Function field");
#line 435
  tmp___15 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 435
  if (tmp___15 > 15) {
    {
#line 435
    Give_Up_And_Quit(priv_data);
    }
#line 435
    goto yyabortlab;
  }
#line 435
  goto yyabortlab;
#line 437
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 441
  Print_Error(priv_data, "Error in BScan_Inst Instruction field");
#line 442
  tmp___16 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 442
  if (tmp___16 > 15) {
    {
#line 442
    Give_Up_And_Quit(priv_data);
    }
#line 442
    goto yyabortlab;
  }
#line 442
  goto yyabortlab;
#line 444
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 448
  Print_Error(priv_data, "Error in Constant CAP data source field");
#line 449
  tmp___17 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 449
  if (tmp___17 > 15) {
    {
#line 449
    Give_Up_And_Quit(priv_data);
    }
#line 449
    goto yyabortlab;
  }
#line 449
  goto yyabortlab;
#line 451
  goto switch_break;
  case_108: /* CIL Label */ 
  {
#line 454
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)(yyvsp + 0)->str);
#line 455
  free((void *)(yyvsp + 0)->str);
  }
#line 457
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 459
  priv_data->Reading_Package = 1;
#line 460
  vhdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 463
  goto switch_break;
  case_110: /* CIL Label */ 
#line 465
  priv_data->Reading_Package = 0;
#line 467
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 470
  free((void *)(yyvsp + -6)->str);
#line 470
  free((void *)(yyvsp + -2)->str);
  }
#line 471
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 472
  Print_Error(priv_data, "Error in User-Defined Package declarations");
#line 473
  tmp___18 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 473
  if (tmp___18 > 15) {
    {
#line 473
    Give_Up_And_Quit(priv_data);
    }
#line 473
    goto yyabortlab;
  }
#line 473
  goto yyabortlab;
#line 474
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 479
  Print_Error(priv_data, "Unknown VHDL statement");
#line 480
  tmp___19 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 480
  if (tmp___19 > 15) {
    {
#line 480
    Give_Up_And_Quit(priv_data);
    }
#line 480
    goto yyabortlab;
  }
#line 480
  goto yyabortlab;
#line 482
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 491
  free((void *)(yyvsp + -5)->str);
  }
#line 492
  goto switch_break;
  case_126: /* CIL Label */ 
  {
#line 502
  Print_Error(priv_data, "Error in Attribute specification");
#line 503
  tmp___20 = vhdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 503
  if (tmp___20 > 15) {
    {
#line 503
    Give_Up_And_Quit(priv_data);
    }
#line 503
    goto yyabortlab;
  }
#line 503
  goto yyabortlab;
#line 505
  goto switch_break;
  case_127: /* CIL Label */ 
  {
#line 511
  free((void *)(yyvsp + -7)->str);
#line 511
  free((void *)(yyvsp + -5)->str);
  }
#line 513
  goto switch_break;
  case_128: /* CIL Label */ 
#line 515
  yyval.integer = 1;
#line 516
  goto switch_break;
  case_129: /* CIL Label */ 
#line 517
  yyval.integer = 0;
#line 518
  goto switch_break;
  case_130: /* CIL Label */ 
  {
#line 521
  set_attr_decimal(priv_data, (yyvsp + -7)->str, (yyvsp + -1)->integer);
#line 522
  free((void *)(yyvsp + -5)->str);
  }
#line 524
  goto switch_break;
  case_131: /* CIL Label */ 
  {
#line 530
  free((void *)(yyvsp + -11)->str);
#line 530
  free((void *)(yyvsp + -9)->str);
#line 530
  free((void *)(yyvsp + -4)->str);
  }
#line 532
  goto switch_break;
  case_134: /* CIL Label */ 
  {
#line 537
  tmp___21 = strdup((char const   *)priv_data->buffer);
#line 537
  set_attr_string(priv_data, (yyvsp + -7)->str, tmp___21);
#line 538
  free((void *)(yyvsp + -5)->str);
  }
#line 540
  goto switch_break;
  case_135: /* CIL Label */ 
  {
#line 542
  free((void *)(yyvsp + -7)->str);
#line 542
  free((void *)(yyvsp + -5)->str);
  }
#line 543
  goto switch_break;
  case_136: /* CIL Label */ 
  {
#line 546
  Init_Text(priv_data);
#line 547
  Store_Text(priv_data, (yyvsp + 0)->str);
#line 548
  free((void *)(yyvsp + 0)->str);
  }
#line 550
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 552
  Store_Text(priv_data, (yyvsp + 0)->str);
#line 553
  free((void *)(yyvsp + 0)->str);
  }
#line 555
  goto switch_break;
  case_138: /* CIL Label */ 
  {
#line 558
  priv_data->Reading_Package = 1;
#line 559
  vhdl_flex_switch_file(priv_data->scanner, priv_data->Package_File_Name);
  }
#line 562
  goto switch_break;
  case_139: /* CIL Label */ 
#line 564
  priv_data->Reading_Package = 0;
#line 566
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 569
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)"STD_1532_2001");
  }
#line 571
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 573
  strcpy((char */* __restrict  */)(priv_data->Package_File_Name), (char const   */* __restrict  */)"STD_1532_2002");
  }
#line 575
  goto switch_break;
  case_143: /* CIL Label */ 
#line 581
  priv_data->Reading_Package = 1;
#line 583
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2277 "vhdl_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2281
  yyvsp -= yylen;
#line 2281
  yyssp -= yylen;
#line 2282
  yylen = 0;
#line 2285
  yyvsp ++;
#line 2285
  *yyvsp = yyval;
#line 2292
  yyn = (int )yyr1[yyn];
#line 2294
  yystate = (int )((int const   )yypgoto[yyn - 81] + (int const   )*yyssp);
#line 2295
  if (0 <= yystate) {
#line 2295
    if (yystate <= 310) {
#line 2295
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2296
        yystate = (int )yytable[yystate];
      } else {
#line 2298
        yystate = (int )yydefgoto[yyn - 81];
      }
    } else {
#line 2298
      yystate = (int )yydefgoto[yyn - 81];
    }
  } else {
#line 2298
    yystate = (int )yydefgoto[yyn - 81];
  }
#line 2300
  goto yynewstate;
  yyerrlab: 
#line 2308
  if (! yyerrstatus) {
    {
#line 2310
    vhdlnerrs ++;
#line 2312
    vhdlerror(priv_data, "syntax error");
    }
  }
#line 2350
  if (yyerrstatus == 3) {
#line 2355
    if (vhdlchar <= 0) {
#line 2358
      if (vhdlchar == 0) {
#line 2359
        goto yyabortlab;
      }
    } else {
      {
#line 2363
      yydestruct("Error: discarding", yytoken, & vhdllval, priv_data);
#line 2365
      vhdlchar = -2;
      }
    }
  }
#line 2371
  goto yyerrlab1;
#line 2387
  yyvsp -= yylen;
#line 2387
  yyssp -= yylen;
#line 2388
  yylen = 0;
#line 2390
  yystate = (int )*yyssp;
#line 2391
  goto yyerrlab1;
  yyerrlab1: 
#line 2398
  yyerrstatus = 3;
  {
#line 2400
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2402
    yyn = (int )yypact[yystate];
#line 2403
    if (yyn != -159) {
#line 2405
      yyn ++;
#line 2406
      if (0 <= yyn) {
#line 2406
        if (yyn <= 310) {
#line 2406
          if ((int const   )yycheck[yyn] == 1) {
#line 2408
            yyn = (int )yytable[yyn];
#line 2409
            if (0 < yyn) {
#line 2410
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2415
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2416
      goto yyabortlab;
    }
    {
#line 2419
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, priv_data);
#line 2421
    yyvsp --;
#line 2421
    yyssp --;
#line 2422
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2426
  if (yyn == 6) {
#line 2427
    goto yyacceptlab;
  }
#line 2429
  yyvsp ++;
#line 2429
  *yyvsp = vhdllval;
#line 2435
  yystate = yyn;
#line 2436
  goto yynewstate;
  yyacceptlab: 
#line 2443
  yyresult = 0;
#line 2444
  goto yyreturn;
  yyabortlab: 
#line 2450
  yyresult = 1;
#line 2451
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2458
  vhdlerror(priv_data, "memory exhausted");
#line 2459
  yyresult = 2;
  }
  yyreturn: 
#line 2464
  if (vhdlchar != 0) {
#line 2464
    if (vhdlchar != -2) {
      {
#line 2465
      yydestruct("Cleanup: discarding lookahead", yytoken, & vhdllval, priv_data);
      }
    }
  }
#line 2469
  yyvsp -= yylen;
#line 2469
  yyssp -= yylen;
  {
#line 2471
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2471
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2471
      goto while_break___2;
    }
    {
#line 2473
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, priv_data);
#line 2475
    yyvsp --;
#line 2475
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2478
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2479
    free((void *)yyss);
    }
  }
#line 2486
  return (yyresult);
}
}
#line 601 "vhdl_bison.y"
static void Init_Text(vhdl_parser_priv_t *priv ) 
{ 
  void *tmp ;

  {
#line 603
  if (priv->len_buffer == 0UL) {
    {
#line 605
    tmp = malloc((size_t )160);
#line 605
    priv->buffer = (char *)tmp;
#line 606
    priv->len_buffer = (size_t )160;
    }
  }
#line 608
  *(priv->buffer + 0) = (char )'\000';
#line 609
  return;
}
}
#line 625 "vhdl_bison.y"
static void Store_Text(vhdl_parser_priv_t *priv , char *Source ) 
{ 
  size_t req_len ;
  char *SourceEnd ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 630
  Source ++;
#line 630
  SourceEnd = Source;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (*SourceEnd) {
#line 631
      if ((int )*SourceEnd != 34) {
#line 631
        if (! ((int )*SourceEnd != 10)) {
#line 631
          goto while_break;
        }
      } else {
#line 631
        goto while_break;
      }
    } else {
#line 631
      goto while_break;
    }
#line 632
    SourceEnd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 634
  *SourceEnd = (char )'\000';
#line 636
  tmp = strlen((char const   *)priv->buffer);
#line 636
  tmp___0 = strlen((char const   *)Source);
#line 636
  req_len = (tmp + tmp___0) + 1UL;
  }
#line 637
  if (req_len > priv->len_buffer) {
    {
#line 639
    tmp___1 = realloc((void *)priv->buffer, req_len);
#line 639
    priv->buffer = (char *)tmp___1;
#line 640
    priv->len_buffer = req_len;
    }
  }
  {
#line 642
  strcat((char */* __restrict  */)priv->buffer, (char const   */* __restrict  */)Source);
  }
#line 643
  return;
}
}
#line 645 "vhdl_bison.y"
static void Print_Error(vhdl_parser_priv_t *priv_data , char const   *Errmess ) 
{ 
  jtag_ctrl_t *jc ;
  int tmp ;
  int tmp___0 ;

  {
#line 647
  jc = priv_data->jtag_ctrl;
#line 649
  if (priv_data->Reading_Package) {
    {
#line 650
    tmp = vhdl_flex_get_lineno(priv_data->scanner);
#line 650
    bsdl_msg(jc->proc_mode, 2, "In Package %s, Line %d, %s.\n", priv_data->Package_File_Name,
             tmp, Errmess);
    }
  } else {
    {
#line 656
    tmp___0 = vhdl_flex_get_lineno(priv_data->scanner);
#line 656
    bsdl_msg(jc->proc_mode, 2, "Line %d, %s.\n", tmp___0, Errmess);
    }
  }
#line 660
  return;
}
}
#line 662 "vhdl_bison.y"
static void Give_Up_And_Quit(vhdl_parser_priv_t *priv_data ) 
{ 


  {
  {
#line 664
  Print_Error(priv_data, "Too many errors");
  }
#line 665
  return;
}
}
#line 667 "vhdl_bison.y"
void vhdlerror(vhdl_parser_priv_t *priv_data , char const   *error_string ) 
{ 


  {
#line 669
  return;
}
}
#line 684 "vhdl_bison.y"
static void vhdl_sem_init(vhdl_parser_priv_t *priv ) 
{ 


  {
#line 686
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
#line 687
  priv->tmp_port_desc.next = (struct port_desc *)((void *)0);
#line 689
  (priv->jtag_ctrl)->port_desc = (port_desc_t *)((void *)0);
#line 691
  (priv->jtag_ctrl)->vhdl_elem_first = (vhdl_elem_t *)((void *)0);
#line 692
  (priv->jtag_ctrl)->vhdl_elem_last = (vhdl_elem_t *)((void *)0);
#line 693
  return;
}
}
#line 707 "vhdl_bison.y"
static void free_string_list(string_elem_t *sl ) 
{ 


  {
#line 709
  if (sl) {
#line 711
    if (sl->string) {
      {
#line 712
      free((void *)sl->string);
      }
    }
    {
#line 713
    free_string_list(sl->next);
#line 714
    free((void *)sl);
    }
  }
#line 716
  return;
}
}
#line 731 "vhdl_bison.y"
static void free_port_list(port_desc_t *pl , int free_me ) 
{ 


  {
#line 733
  if (pl) {
    {
#line 735
    free_string_list(pl->names_list);
#line 736
    free_port_list(pl->next, 1);
    }
#line 738
    if (free_me) {
      {
#line 739
      free((void *)pl);
      }
    }
  }
#line 741
  return;
}
}
#line 755 "vhdl_bison.y"
static void free_elem_list(vhdl_elem_t *el ) 
{ 


  {
#line 757
  if (el) {
    {
#line 759
    free_elem_list(el->next);
    }
#line 761
    if (el->name) {
      {
#line 762
      free((void *)el->name);
      }
    }
#line 764
    if (el->payload) {
      {
#line 765
      free((void *)el->payload);
      }
    }
    {
#line 766
    free((void *)el);
    }
  }
#line 768
  return;
}
}
#line 783 "vhdl_bison.y"
static void vhdl_sem_deinit(vhdl_parser_priv_t *priv_data ) 
{ 
  port_desc_t *pd ;
  vhdl_elem_t *el ;

  {
  {
#line 785
  pd = (priv_data->jtag_ctrl)->port_desc;
#line 786
  el = (priv_data->jtag_ctrl)->vhdl_elem_first;
#line 789
  free_port_list(pd, 1);
#line 790
  free_port_list(& priv_data->tmp_port_desc, 0);
#line 793
  free_elem_list(el);
#line 795
  priv_data->jtag_ctrl = (jtag_ctrl_t *)((void *)0);
  }
#line 796
  return;
}
}
#line 814 "vhdl_bison.y"
vhdl_parser_priv_t *vhdl_parser_init(FILE *f , jtag_ctrl_t *jtag_ctrl ) 
{ 
  vhdl_parser_priv_t *new_priv ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 818
  tmp = malloc(sizeof(vhdl_parser_priv_t ));
#line 818
  new_priv = (vhdl_parser_priv_t *)tmp;
  }
#line 818
  if (! new_priv) {
    {
#line 820
    bsdl_msg(jtag_ctrl->proc_mode, 2, "Out of memory, %s line %i\n", "vhdl_bison.y",
             821);
    }
#line 822
    return ((vhdl_parser_priv_t *)((void *)0));
  }
  {
#line 825
  new_priv->jtag_ctrl = jtag_ctrl;
#line 827
  new_priv->Reading_Package = 0;
#line 828
  new_priv->buffer = (char *)((void *)0);
#line 829
  new_priv->len_buffer = (size_t )0;
#line 831
  tmp___0 = vhdl_flex_init(f, jtag_ctrl->proc_mode);
#line 831
  new_priv->scanner = tmp___0;
  }
#line 831
  if (! tmp___0) {
    {
#line 833
    free((void *)new_priv);
#line 834
    new_priv = (vhdl_parser_priv_t *)((void *)0);
    }
  }
  {
#line 837
  vhdl_sem_init(new_priv);
  }
#line 839
  return (new_priv);
}
}
#line 857 "vhdl_bison.y"
void vhdl_parser_deinit(vhdl_parser_priv_t *priv_data ) 
{ 


  {
#line 859
  if (priv_data->buffer) {
    {
#line 861
    free((void *)priv_data->buffer);
#line 862
    priv_data->buffer = (char *)((void *)0);
    }
  }
  {
#line 865
  vhdl_sem_deinit(priv_data);
#line 866
  vhdl_flex_deinit(priv_data->scanner);
#line 867
  free((void *)priv_data);
  }
#line 868
  return;
}
}
#line 882 "vhdl_bison.y"
static void vhdl_set_entity(vhdl_parser_priv_t *priv , char *entityname ) 
{ 


  {
#line 884
  if ((priv->jtag_ctrl)->proc_mode & (1 << 6)) {
    {
#line 886
    strncpy((char */* __restrict  */)(((priv->jtag_ctrl)->part)->part), (char const   */* __restrict  */)entityname,
            (size_t )20);
#line 887
    ((priv->jtag_ctrl)->part)->part[20] = (char )'\000';
    }
  }
  {
#line 890
  free((void *)entityname);
  }
#line 891
  return;
}
}
#line 907 "vhdl_bison.y"
static void vhdl_port_add_name(vhdl_parser_priv_t *priv , char *name ) 
{ 
  port_desc_t *pd ;
  string_elem_t *new_string___1 ;
  void *tmp ;

  {
  {
#line 909
  pd = & priv->tmp_port_desc;
#line 912
  tmp = malloc(sizeof(string_elem_t ));
#line 912
  new_string___1 = (string_elem_t *)tmp;
  }
#line 913
  if (new_string___1) {
#line 915
    new_string___1->next = pd->names_list;
#line 916
    new_string___1->string = name;
#line 918
    pd->names_list = new_string___1;
  } else {
    {
#line 921
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             922);
    }
  }
#line 923
  return;
}
}
#line 940 "vhdl_bison.y"
static void vhdl_port_add_bit(vhdl_parser_priv_t *priv ) 
{ 
  port_desc_t *pd ;

  {
#line 942
  pd = & priv->tmp_port_desc;
#line 944
  pd->is_vector = 0;
#line 945
  pd->low_idx = 0;
#line 946
  pd->high_idx = 0;
#line 947
  return;
}
}
#line 965 "vhdl_bison.y"
static void vhdl_port_add_range(vhdl_parser_priv_t *priv , int low , int high ) 
{ 
  port_desc_t *pd ;

  {
#line 967
  pd = & priv->tmp_port_desc;
#line 969
  pd->is_vector = 1;
#line 970
  pd->low_idx = low;
#line 971
  pd->high_idx = high;
#line 972
  return;
}
}
#line 987 "vhdl_bison.y"
static void vhdl_port_apply_port(vhdl_parser_priv_t *priv ) 
{ 
  port_desc_t *tmp_pd ;
  port_desc_t *pd ;
  void *tmp ;

  {
  {
#line 989
  tmp_pd = & priv->tmp_port_desc;
#line 990
  tmp = malloc(sizeof(port_desc_t ));
#line 990
  pd = (port_desc_t *)tmp;
  }
#line 992
  if (pd) {
#line 995
    pd->next = (priv->jtag_ctrl)->port_desc;
#line 996
    (priv->jtag_ctrl)->port_desc = pd;
#line 999
    pd->names_list = tmp_pd->names_list;
#line 1000
    pd->is_vector = tmp_pd->is_vector;
#line 1001
    pd->low_idx = tmp_pd->low_idx;
#line 1002
    pd->high_idx = tmp_pd->high_idx;
#line 1005
    tmp_pd->names_list = (string_elem_t *)((void *)0);
#line 1006
    tmp_pd->next = (struct port_desc *)((void *)0);
  } else {
    {
#line 1009
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             1010);
    }
  }
#line 1011
  return;
}
}
#line 1013 "vhdl_bison.y"
static void add_elem(vhdl_parser_priv_t *priv , vhdl_elem_t *el ) 
{ 
  jtag_ctrl_t *jc ;

  {
#line 1015
  jc = priv->jtag_ctrl;
#line 1017
  el->next = (struct vhdl_elem *)((void *)0);
#line 1018
  if (jc->vhdl_elem_last) {
#line 1019
    (jc->vhdl_elem_last)->next = el;
  }
#line 1020
  jc->vhdl_elem_last = el;
#line 1022
  if (! jc->vhdl_elem_first) {
#line 1023
    jc->vhdl_elem_first = el;
  }
  {
#line 1025
  el->line = vhdl_flex_get_lineno(priv->scanner);
  }
#line 1026
  return;
}
}
#line 1046 "vhdl_bison.y"
static void set_attr_decimal(vhdl_parser_priv_t *priv , char *name , int value ) 
{ 
  vhdl_elem_t *el ;
  void *tmp ;
  char *string ;
  void *tmp___0 ;

  {
  {
#line 1048
  tmp = malloc(sizeof(vhdl_elem_t ));
#line 1048
  el = (vhdl_elem_t *)tmp;
#line 1049
  tmp___0 = malloc((size_t )10);
#line 1049
  string = (char *)tmp___0;
  }
#line 1051
  if (el) {
#line 1051
    if (string) {
      {
#line 1053
      el->type = (vhdl_elem_type_t )2;
#line 1054
      el->name = name;
#line 1055
      snprintf((char */* __restrict  */)string, (size_t )10, (char const   */* __restrict  */)"%d",
               value);
#line 1056
      el->payload = string;
#line 1058
      add_elem(priv, el);
      }
    } else {
      {
#line 1061
      bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
               1062);
      }
    }
  } else {
    {
#line 1061
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             1062);
    }
  }
#line 1063
  return;
}
}
#line 1065 "vhdl_bison.y"
static void set_attr_string(vhdl_parser_priv_t *priv , char *name , char *string ) 
{ 
  vhdl_elem_t *el ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1067
  tmp = malloc(sizeof(vhdl_elem_t ));
#line 1067
  el = (vhdl_elem_t *)tmp;
#line 1070
  tmp___0 = strcasecmp((char const   *)name, "DESIGN_WARNING");
  }
#line 1070
  if (tmp___0 == 0) {
    {
#line 1076
    free((void *)name);
#line 1077
    free((void *)string);
#line 1078
    free((void *)el);
    }
#line 1079
    return;
  } else {
    {
#line 1070
    tmp___1 = strcasecmp((char const   *)name, "BOUNDARY_CELLS");
    }
#line 1070
    if (tmp___1 == 0) {
      {
#line 1076
      free((void *)name);
#line 1077
      free((void *)string);
#line 1078
      free((void *)el);
      }
#line 1079
      return;
    } else {
      {
#line 1070
      tmp___2 = strcasecmp((char const   *)name, "INSTRUCTION_SEQUENCE");
      }
#line 1070
      if (tmp___2 == 0) {
        {
#line 1076
        free((void *)name);
#line 1077
        free((void *)string);
#line 1078
        free((void *)el);
        }
#line 1079
        return;
      } else {
        {
#line 1070
        tmp___3 = strcasecmp((char const   *)name, "INSTRUCTION_USAGE");
        }
#line 1070
        if (tmp___3 == 0) {
          {
#line 1076
          free((void *)name);
#line 1077
          free((void *)string);
#line 1078
          free((void *)el);
          }
#line 1079
          return;
        } else {
          {
#line 1070
          tmp___4 = strcasecmp((char const   *)name, "ISC_DESIGN_WARNING");
          }
#line 1070
          if (tmp___4 == 0) {
            {
#line 1076
            free((void *)name);
#line 1077
            free((void *)string);
#line 1078
            free((void *)el);
            }
#line 1079
            return;
          }
        }
      }
    }
  }
#line 1082
  if (el) {
    {
#line 1084
    el->type = (vhdl_elem_type_t )1;
#line 1085
    el->name = name;
#line 1086
    el->payload = string;
#line 1088
    add_elem(priv, el);
    }
  } else {
    {
#line 1091
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "vhdl_bison.y",
             1092);
    }
  }
#line 1093
  return;
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 318 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 61 "../../include/part.h"
data_register *part_find_data_register(part_t *p , char const   *drname ) ;
#line 49 "../../include/cmd.h"
int cmd_run(chain_t *chain , char **params ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_parser.h"
int bsdl_flex_get_compile_errors(void *scanner ) ;
#line 38
void bsdl_flex_switch_buffer(void *scanner , char const   *buffer , int lineno ) ;
#line 42
bsdl_parser_priv_t *bsdl_parser_init(jtag_ctrl_t *jtag_ctrl ) ;
#line 43
void bsdl_parser_deinit(bsdl_parser_priv_t *priv_data ) ;
#line 44
int bsdlparse(bsdl_parser_priv_t *priv_data ) ;
#line 47
int bsdl_process_elements(jtag_ctrl_t *jc , char const   *idcode___0 ) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static void print_cmd(char **cmd ) 
{ 
  int idx ;
  char *elem ;

  {
#line 60
  idx = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    elem = *(cmd + idx);
#line 63
    if (! elem) {
#line 63
      goto while_break;
    }
    {
#line 64
    printf((char const   */* __restrict  */)" %s", elem);
#line 65
    idx ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 67
  printf((char const   */* __restrict  */)"\n");
  }
#line 68
  return;
}
}
#line 84 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_set_instruction_length(jtag_ctrl_t *jc ) 
{ 
  char lenstring[6] ;
  char *cmd[4] ;

  {
  {
#line 87
  cmd[0] = (char *)"instruction";
#line 87
  cmd[1] = (char *)"length";
#line 87
  cmd[2] = lenstring;
#line 87
  cmd[3] = (char *)((void *)0);
#line 92
  snprintf((char */* __restrict  */)(lenstring), (size_t )6, (char const   */* __restrict  */)"%i",
           jc->instr_len);
#line 93
  lenstring[5] = (char )'\000';
  }
#line 95
  if (jc->proc_mode & (1 << 6)) {
    {
#line 96
    cmd_run(jc->chain, cmd);
    }
  }
#line 97
  if (jc->proc_mode & (1 << 5)) {
    {
#line 98
    print_cmd(cmd);
    }
  }
#line 100
  return (1);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_emit_ports(jtag_ctrl_t *jc ) 
{ 
  port_desc_t *pd ;
  struct string_elem *name ;
  size_t str_len ;
  size_t name_len ;
  char *port_string ;
  int idx ;
  int result ;
  char *cmd[3] ;
  void *tmp ;

  {
#line 124
  pd = jc->port_desc;
#line 129
  result = 0;
#line 130
  cmd[0] = (char *)"signal";
#line 130
  cmd[1] = (char *)((void *)0);
#line 130
  cmd[2] = (char *)((void *)0);
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! pd) {
#line 134
      goto while_break;
    }
#line 136
    name = pd->names_list;
    {
#line 137
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 137
      if (! name) {
#line 137
        goto while_break___0;
      }
      {
#line 144
      name_len = strlen((char const   *)name->string);
#line 145
      str_len = (((name_len + 1UL) + 10UL) + 1UL) + 1UL;
#line 146
      tmp = malloc(str_len);
#line 146
      port_string = (char *)tmp;
      }
#line 146
      if ((unsigned long )port_string != (unsigned long )((void *)0)) {
#line 148
        cmd[1] = port_string;
#line 150
        idx = pd->low_idx;
        {
#line 150
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 150
          if (! (idx <= pd->high_idx)) {
#line 150
            goto while_break___1;
          }
#line 152
          if (pd->is_vector) {
            {
#line 153
            snprintf((char */* __restrict  */)port_string, str_len - 1UL, (char const   */* __restrict  */)"%s(%d)",
                     name->string, idx);
            }
          } else {
            {
#line 155
            strncpy((char */* __restrict  */)port_string, (char const   */* __restrict  */)name->string,
                    str_len - 1UL);
            }
          }
#line 156
          *(port_string + (str_len - 1UL)) = (char )'\000';
#line 158
          if (jc->proc_mode & (1 << 6)) {
            {
#line 159
            cmd_run(jc->chain, cmd);
            }
          }
#line 160
          if (jc->proc_mode & (1 << 5)) {
            {
#line 161
            print_cmd(cmd);
            }
          }
#line 150
          idx ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 164
        free((void *)port_string);
#line 165
        result = 1;
        }
      } else {
        {
#line 168
        bsdl_msg(jc->proc_mode, 3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c",
                 169);
        }
      }
#line 171
      name = name->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 174
    pd = pd->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (result);
}
}
#line 196 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int create_register(jtag_ctrl_t *jc , char *reg_name , size_t len ) 
{ 
  size_t str_len ;
  char *len_str ;
  unsigned long __lengthoflen_str ;
  void *tmp ;
  char *cmd[4] ;
  data_register *tmp___0 ;

  {
  {
#line 198
  str_len = (size_t )10;
#line 199
  __lengthoflen_str = str_len + 1UL;
#line 199
  tmp = __builtin_alloca(sizeof(*len_str) * __lengthoflen_str);
#line 199
  len_str = (char *)tmp;
#line 200
  cmd[0] = (char *)"register";
#line 200
  cmd[1] = reg_name;
#line 200
  cmd[2] = len_str;
#line 200
  cmd[3] = (char *)((void *)0);
#line 205
  tmp___0 = part_find_data_register(jc->part, (char const   *)reg_name);
  }
#line 205
  if (tmp___0) {
#line 206
    return (1);
  }
  {
#line 209
  snprintf((char */* __restrict  */)len_str, str_len, (char const   */* __restrict  */)"%i",
           len);
  }
#line 211
  if (jc->proc_mode & (1 << 6)) {
    {
#line 212
    cmd_run(jc->chain, cmd);
    }
  }
#line 213
  if (jc->proc_mode & (1 << 5)) {
    {
#line 214
    print_cmd(cmd);
    }
  }
#line 216
  return (1);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_process_idcode(jtag_ctrl_t *jc ) 
{ 
  size_t tmp ;

  {
#line 234
  if (jc->idcode) {
    {
#line 235
    tmp = strlen((char const   *)jc->idcode);
#line 235
    create_register(jc, (char *)"DIR", tmp);
    }
  } else {
    {
#line 237
    bsdl_msg(jc->proc_mode, 1, "No IDCODE specification found.\n");
    }
  }
#line 240
  return (1);
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_process_usercode(jtag_ctrl_t *jc ) 
{ 
  size_t tmp ;

  {
#line 259
  if (jc->usercode) {
    {
#line 260
    tmp = strlen((char const   *)jc->usercode);
#line 260
    create_register(jc, (char *)"USERCODE", tmp);
    }
  }
#line 264
  return (1);
}
}
#line 280 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_set_bsr_length(jtag_ctrl_t *jc ) 
{ 


  {
  {
#line 282
  create_register(jc, (char *)"BSR", (size_t )jc->bsr_len);
  }
#line 284
  return (1);
}
}
#line 302 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_process_cell_info(jtag_ctrl_t *jc ) 
{ 
  cell_info_t *ci ;
  size_t str_len ;
  char *bit_num_str ;
  unsigned long __lengthofbit_num_str ;
  void *tmp ;
  char *ctrl_bit_num_str ;
  unsigned long __lengthofctrl_bit_num_str ;
  void *tmp___0 ;
  char *disable_safe_value_str ;
  unsigned long __lengthofdisable_safe_value_str ;
  void *tmp___1 ;
  char *cmd[9] ;
  int tmp___3 ;

  {
  {
#line 304
  ci = jc->cell_info_first;
#line 305
  str_len = (size_t )10;
#line 306
  __lengthofbit_num_str = str_len + 1UL;
#line 306
  tmp = __builtin_alloca(sizeof(*bit_num_str) * __lengthofbit_num_str);
#line 306
  bit_num_str = (char *)tmp;
#line 307
  __lengthofctrl_bit_num_str = str_len + 1UL;
#line 307
  tmp___0 = __builtin_alloca(sizeof(*ctrl_bit_num_str) * __lengthofctrl_bit_num_str);
#line 307
  ctrl_bit_num_str = (char *)tmp___0;
#line 308
  __lengthofdisable_safe_value_str = str_len + 1UL;
#line 308
  tmp___1 = __builtin_alloca(sizeof(*disable_safe_value_str) * __lengthofdisable_safe_value_str);
#line 308
  disable_safe_value_str = (char *)tmp___1;
#line 309
  cmd[0] = (char *)"bit";
#line 309
  cmd[1] = bit_num_str;
#line 309
  cmd[2] = (char *)((void *)0);
#line 309
  cmd[3] = (char *)((void *)0);
#line 309
  cmd[4] = (char *)((void *)0);
#line 309
  cmd[5] = (char *)((void *)0);
#line 309
  cmd[6] = disable_safe_value_str;
#line 309
  cmd[7] = (char *)"Z";
#line 309
  cmd[8] = (char *)((void *)0);
  }
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! ci) {
#line 319
      goto while_break;
    }
    {
#line 322
    snprintf((char */* __restrict  */)bit_num_str, str_len, (char const   */* __restrict  */)"%i",
             ci->bit_num);
#line 323
    *(bit_num_str + str_len) = (char )'\000';
    }
    {
#line 331
    if (ci->cell_function == 282) {
#line 331
      goto case_282;
    }
#line 331
    if (ci->cell_function == 281) {
#line 331
      goto case_282;
    }
#line 331
    if (ci->cell_function == 285) {
#line 331
      goto case_282;
    }
#line 338
    if (ci->cell_function == 286) {
#line 338
      goto case_286;
    }
#line 338
    if (ci->cell_function == 280) {
#line 338
      goto case_286;
    }
#line 338
    if (ci->cell_function == 308) {
#line 338
      goto case_286;
    }
#line 343
    if (ci->cell_function == 284) {
#line 343
      goto case_284;
    }
#line 343
    if (ci->cell_function == 283) {
#line 343
      goto case_284;
    }
#line 346
    if (ci->cell_function == 287) {
#line 346
      goto case_287;
    }
#line 349
    goto switch_default;
    case_282: /* CIL Label */ 
    case_281: /* CIL Label */ 
    case_285: /* CIL Label */ 
#line 332
    cmd[2] = (char *)"O";
#line 333
    goto switch_break;
    case_286: /* CIL Label */ 
    case_280: /* CIL Label */ 
    case_308: /* CIL Label */ 
#line 339
    cmd[2] = (char *)"I";
#line 340
    goto switch_break;
    case_284: /* CIL Label */ 
    case_283: /* CIL Label */ 
#line 344
    cmd[2] = (char *)"C";
#line 345
    goto switch_break;
    case_287: /* CIL Label */ 
#line 347
    cmd[2] = (char *)"B";
#line 348
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 351
    cmd[2] = (char *)"?";
#line 352
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 355
    tmp___3 = strcasecmp((char const   *)ci->basic_safe_value, "x");
    }
#line 355
    if (tmp___3 == 0) {
#line 355
      cmd[3] = (char *)"?";
    } else {
#line 355
      cmd[3] = ci->basic_safe_value;
    }
#line 357
    cmd[4] = ci->port_name;
#line 360
    if (ci->ctrl_bit_num >= 0) {
      {
#line 363
      snprintf((char */* __restrict  */)ctrl_bit_num_str, str_len, (char const   */* __restrict  */)"%i",
               ci->ctrl_bit_num);
#line 364
      *(ctrl_bit_num_str + str_len) = (char )'\000';
#line 366
      snprintf((char */* __restrict  */)disable_safe_value_str, str_len, (char const   */* __restrict  */)"%i",
               ci->disable_safe_value);
#line 367
      *(disable_safe_value_str + str_len) = (char )'\000';
#line 368
      cmd[5] = ctrl_bit_num_str;
      }
    } else {
#line 372
      cmd[5] = (char *)((void *)0);
    }
#line 374
    if (jc->proc_mode & (1 << 6)) {
      {
#line 375
      cmd_run(jc->chain, cmd);
      }
    }
#line 376
    if (jc->proc_mode & (1 << 5)) {
      {
#line 377
      print_cmd(cmd);
      }
    }
#line 379
    ci = ci->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 382
  return (1);
}
}
#line 410 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int bsdl_process_register_access(jtag_ctrl_t *jc ) 
{ 
  ainfo_elem_t *ai ;
  instr_elem_t *cinst ;
  int is_std ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *reg_name ;
  char *instr_name ;
  instr_elem_t *tinst ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *cmd[5] ;

  {
  {
#line 421
  create_register(jc, (char *)"BYPASS", (size_t )1);
#line 425
  ai = jc->ainfo_list;
  }
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (! ai) {
#line 426
      goto while_break;
    }
    {
#line 428
    is_std = 0;
#line 430
    tmp = strcasecmp((char const   *)ai->reg, "BOUNDARY");
    }
#line 430
    if (tmp == 0) {
#line 430
      is_std = 1;
    }
    {
#line 431
    tmp___0 = strcasecmp((char const   *)ai->reg, "BYPASS");
    }
#line 431
    if (tmp___0 == 0) {
#line 431
      is_std = 1;
    }
    {
#line 432
    tmp___1 = strcasecmp((char const   *)ai->reg, "DEVICE_ID");
    }
#line 432
    if (tmp___1 == 0) {
#line 432
      is_std = 1;
    }
    {
#line 433
    tmp___2 = strcasecmp((char const   *)ai->reg, "USERCODE");
    }
#line 433
    if (tmp___2 == 0) {
#line 433
      is_std = 1;
    }
#line 435
    if (! is_std) {
      {
#line 436
      create_register(jc, ai->reg, (size_t )ai->reg_len);
      }
    }
#line 438
    ai = ai->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  cinst = jc->instr_list;
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 445
    if (! cinst) {
#line 445
      goto while_break___0;
    }
#line 447
    reg_name = (char *)((void *)0);
#line 448
    instr_name = (char *)((void *)0);
#line 451
    ai = jc->ainfo_list;
    {
#line 452
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 452
      if (ai) {
#line 452
        if (! ((unsigned long )reg_name == (unsigned long )((void *)0))) {
#line 452
          goto while_break___1;
        }
      } else {
#line 452
        goto while_break___1;
      }
#line 454
      tinst = ai->instr_list;
      {
#line 456
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 456
        if (tinst) {
#line 456
          if (! ((unsigned long )reg_name == (unsigned long )((void *)0))) {
#line 456
            goto while_break___2;
          }
        } else {
#line 456
          goto while_break___2;
        }
        {
#line 458
        tmp___5 = strcasecmp((char const   *)tinst->instr, (char const   *)cinst->instr);
        }
#line 458
        if (tmp___5 == 0) {
          {
#line 463
          tmp___4 = strcasecmp((char const   *)ai->reg, "BOUNDARY");
          }
#line 463
          if (tmp___4 == 0) {
#line 463
            reg_name = (char *)"BSR";
          } else {
            {
#line 464
            tmp___3 = strcasecmp((char const   *)ai->reg, "DEVICE_ID");
            }
#line 464
            if (tmp___3 == 0) {
#line 464
              reg_name = (char *)"DIR";
            } else {
#line 465
              reg_name = ai->reg;
            }
          }
        }
#line 468
        tinst = tinst->next;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 471
      ai = ai->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 474
    if ((unsigned long )reg_name == (unsigned long )((void *)0)) {
      {
#line 479
      tmp___14 = strcasecmp((char const   *)cinst->instr, "BYPASS");
      }
#line 479
      if (tmp___14 == 0) {
#line 479
        reg_name = (char *)"BYPASS";
      } else {
        {
#line 480
        tmp___13 = strcasecmp((char const   *)cinst->instr, "CLAMP");
        }
#line 480
        if (tmp___13 == 0) {
#line 480
          reg_name = (char *)"BYPASS";
        } else {
          {
#line 481
          tmp___12 = strcasecmp((char const   *)cinst->instr, "EXTEST");
          }
#line 481
          if (tmp___12 == 0) {
#line 481
            reg_name = (char *)"BSR";
          } else {
            {
#line 482
            tmp___11 = strcasecmp((char const   *)cinst->instr, "HIGHZ");
            }
#line 482
            if (tmp___11 == 0) {
#line 482
              reg_name = (char *)"BYPASS";
            } else {
              {
#line 483
              tmp___10 = strcasecmp((char const   *)cinst->instr, "IDCODE");
              }
#line 483
              if (tmp___10 == 0) {
#line 483
                reg_name = (char *)"DIR";
              } else {
                {
#line 484
                tmp___9 = strcasecmp((char const   *)cinst->instr, "INTEST");
                }
#line 484
                if (tmp___9 == 0) {
#line 484
                  reg_name = (char *)"BSR";
                } else {
                  {
#line 485
                  tmp___8 = strcasecmp((char const   *)cinst->instr, "PRELOAD");
                  }
#line 485
                  if (tmp___8 == 0) {
#line 485
                    reg_name = (char *)"BSR";
                  } else {
                    {
#line 486
                    tmp___7 = strcasecmp((char const   *)cinst->instr, "SAMPLE");
                    }
#line 486
                    if (tmp___7 == 0) {
#line 486
                      reg_name = (char *)"BSR";
                    } else {
                      {
#line 487
                      tmp___6 = strcasecmp((char const   *)cinst->instr, "USERCODE");
                      }
#line 487
                      if (tmp___6 == 0) {
#line 487
                        reg_name = (char *)"USERCODE";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    {
#line 490
    tmp___15 = strcasecmp((char const   *)cinst->instr, "SAMPLE");
    }
#line 490
    if (tmp___15 == 0) {
#line 491
      instr_name = (char *)"SAMPLE/PRELOAD";
    } else {
#line 493
      instr_name = cinst->instr;
    }
#line 495
    if (reg_name) {
#line 497
      cmd[0] = (char *)"instruction";
#line 497
      cmd[1] = instr_name;
#line 497
      cmd[2] = cinst->opcode;
#line 497
      cmd[3] = reg_name;
#line 497
      cmd[4] = (char *)((void *)0);
#line 503
      if (jc->proc_mode & (1 << 6)) {
        {
#line 504
        cmd_run(jc->chain, cmd);
        }
      }
#line 505
      if (jc->proc_mode & (1 << 5)) {
        {
#line 506
        print_cmd(cmd);
        }
      }
    }
#line 509
    cinst = cinst->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 512
  return (1);
}
}
#line 529 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int parse_vhdl_elem(bsdl_parser_priv_t *priv , vhdl_elem_t *elem ) 
{ 
  char *buf ;
  size_t buf_len ;
  size_t name_string_len ;
  size_t elem_string_len ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 536
  if (elem->name) {
    {
#line 536
    tmp = strlen((char const   *)elem->name);
#line 536
    name_string_len = tmp;
    }
  } else {
#line 536
    name_string_len = (size_t )0;
  }
#line 537
  if (elem->payload) {
    {
#line 537
    tmp___0 = strlen((char const   *)elem->payload);
#line 537
    elem_string_len = tmp___0;
    }
  } else {
#line 537
    elem_string_len = (size_t )0;
  }
  {
#line 540
  buf_len = ((name_string_len + 1UL) + elem_string_len) + 1UL;
#line 541
  tmp___1 = malloc(buf_len);
#line 541
  buf = (char *)tmp___1;
  }
#line 542
  if (! buf) {
    {
#line 544
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c",
             545);
    }
#line 546
    return (-1);
  }
#line 548
  *(buf + 0) = (char )'\000';
#line 550
  if (name_string_len > 0UL) {
    {
#line 551
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)elem->name,
            buf_len);
    }
  }
  {
#line 552
  strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)" ", buf_len - name_string_len);
  }
#line 554
  if (elem_string_len > 0UL) {
    {
#line 555
    strncat((char */* __restrict  */)buf, (char const   */* __restrict  */)elem->payload,
            (buf_len - name_string_len) - 1UL);
    }
  }
  {
#line 557
  *(buf + (buf_len - 1UL)) = (char )'\000';
#line 559
  priv->lineno = elem->line;
#line 562
  bsdl_flex_switch_buffer(priv->scanner, (char const   *)buf, elem->line);
#line 563
  bsdlparse(priv);
#line 565
  free((void *)buf);
#line 567
  tmp___4 = bsdl_flex_get_compile_errors(priv->scanner);
  }
#line 567
  if (tmp___4 == 0) {
#line 567
    tmp___3 = 1 << 4;
  } else {
#line 567
    tmp___3 = 0;
  }
#line 567
  return (tmp___3);
}
}
#line 584 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int build_commands(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 586
  jc = priv->jtag_ctrl;
#line 587
  result = 1;
#line 589
  tmp = bsdl_emit_ports(jc);
#line 589
  result &= tmp;
#line 591
  tmp___0 = bsdl_set_instruction_length(jc);
#line 591
  result &= tmp___0;
#line 593
  tmp___1 = bsdl_process_idcode(jc);
#line 593
  result &= tmp___1;
#line 595
  tmp___2 = bsdl_process_usercode(jc);
#line 595
  result &= tmp___2;
#line 597
  tmp___3 = bsdl_set_bsr_length(jc);
#line 597
  result &= tmp___3;
#line 599
  tmp___4 = bsdl_process_register_access(jc);
#line 599
  result &= tmp___4;
#line 601
  tmp___5 = bsdl_process_cell_info(jc);
#line 601
  result &= tmp___5;
  }
#line 603
  if (result) {
#line 603
    tmp___6 = (1 << 6) | (1 << 5);
  } else {
#line 603
    tmp___6 = 0;
  }
#line 603
  return (tmp___6);
}
}
#line 620 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
static int compare_idcode(jtag_ctrl_t *jc , char const   *idcode___0 ) 
{ 
  int idcode_match ;
  int idx ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 622
  idcode_match = 0;
#line 625
  if (idcode___0) {
    {
#line 627
    tmp___0 = strlen(idcode___0);
#line 627
    tmp___1 = strlen((char const   *)jc->idcode);
    }
#line 627
    if (tmp___0 == tmp___1) {
#line 632
      idcode_match = 1 << 7;
#line 633
      idx = 0;
      {
#line 633
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 633
        tmp = strlen(idcode___0);
        }
#line 633
        if (! ((size_t )idx < tmp)) {
#line 633
          goto while_break;
        }
#line 634
        if ((int )*(jc->idcode + idx) != 88) {
#line 635
          if ((int const   )*(idcode___0 + idx) != (int const   )*(jc->idcode + idx)) {
#line 636
            idcode_match = 0;
          }
        }
#line 633
        idx ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 638
      if (idcode_match) {
        {
#line 639
        bsdl_msg(jc->proc_mode, 0, "IDCODE matched\n");
        }
      } else {
        {
#line 642
        bsdl_msg(jc->proc_mode, 0, "IDCODE mismatch\n");
        }
      }
    }
  }
#line 647
  return (idcode_match);
}
}
#line 669 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_sem.c"
int bsdl_process_elements(jtag_ctrl_t *jc , char const   *idcode___0 ) 
{ 
  bsdl_parser_priv_t *priv ;
  vhdl_elem_t *el ;
  int result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 672
  el = jc->vhdl_elem_first;
#line 673
  result = 1 << 4;
#line 675
  priv = bsdl_parser_init(jc);
  }
#line 675
  if ((unsigned long )priv == (unsigned long )((void *)0)) {
#line 676
    return (-1);
  }
#line 678
  if (jc->proc_mode & (1 << 4)) {
    {
#line 680
    while (1) {
      while_continue: /* CIL Label */ ;
#line 680
      if (el) {
#line 680
        if (! (result & (1 << 4))) {
#line 680
          goto while_break;
        }
      } else {
#line 680
        goto while_break;
      }
      {
#line 682
      result = parse_vhdl_elem(priv, el);
#line 684
      el = el->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 687
    if (! (result & (1 << 4))) {
      {
#line 689
      bsdl_msg(jc->proc_mode, 2, "BSDL stage reported errors, aborting.\n");
#line 691
      bsdl_parser_deinit(priv);
      }
#line 692
      return (result);
    }
  }
#line 696
  if (jc->idcode) {
    {
#line 697
    bsdl_msg(jc->proc_mode, 0, "Got IDCODE: %s\n", jc->idcode);
    }
  }
#line 700
  if (jc->proc_mode & (1 << 7)) {
    {
#line 701
    tmp = compare_idcode(jc, idcode___0);
#line 701
    result |= tmp;
    }
  }
#line 703
  if (jc->proc_mode & ((1 << 6) | (1 << 5))) {
#line 705
    if (jc->proc_mode & (1 << 7)) {
#line 705
      if (result & (1 << 7)) {
        {
#line 708
        tmp___0 = build_commands(priv);
#line 708
        result |= tmp___0;
        }
      } else {
#line 705
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 705
    if (! (jc->proc_mode & (1 << 7))) {
      {
#line 708
      tmp___0 = build_commands(priv);
#line 708
      result |= tmp___0;
      }
    }
  }
#line 710
  if ((result & jc->proc_mode) == (jc->proc_mode & ((((1 << 4) | (1 << 5)) | (1 << 6)) | (1 << 7)))) {
#line 711
    if (jc->proc_mode & (1 << 7)) {
#line 712
      result = 1;
    } else {
#line 714
      result = 0;
    }
  } else {
#line 716
    result = -1;
  }
  {
#line 718
  bsdl_parser_deinit(priv);
  }
#line 720
  return (result);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 333 "/usr/include/stdio.h"
extern int vprintf(char const   * __restrict  __format , __gnuc_va_list __arg ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 225
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 42 "../../include/bsdl.h"
int bsdl_read_file(chain_t *chain , char const   *BSDL_File_Name , int proc_mode ,
                   char const   *idcode___0 ) ;
#line 43
void bsdl_set_path(chain_t *chain , char const   *pathlist ) ;
#line 44
int bsdl_scan_files(chain_t *chain , char const   *idcode___0 , int proc_mode ) ;
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl.c"
void bsdl_msg(int proc_mode , int type , char const   *format  , ...) 
{ 
  va_list lst ;

  {
  {
#line 69
  __builtin_va_start(lst, format);
  }
  {
#line 72
  if (type == 0) {
#line 72
    goto case_0;
  }
#line 77
  if (type == 1) {
#line 77
    goto case_1;
  }
#line 82
  if (type == 2) {
#line 82
    goto case_2;
  }
#line 87
  if (type == 3) {
#line 87
    goto case_3;
  }
#line 92
  goto switch_default;
  case_0: /* CIL Label */ 
#line 73
  if (! (proc_mode & 1)) {
#line 74
    return;
  }
  {
#line 75
  printf((char const   */* __restrict  */)"-N- ");
  }
#line 76
  goto switch_break;
  case_1: /* CIL Label */ 
#line 78
  if (! (proc_mode & (1 << 1))) {
#line 79
    return;
  }
  {
#line 80
  printf((char const   */* __restrict  */)"-W- ");
  }
#line 81
  goto switch_break;
  case_2: /* CIL Label */ 
#line 83
  if (! (proc_mode & (1 << 2))) {
#line 84
    return;
  }
  {
#line 85
  printf((char const   */* __restrict  */)"-E- ");
  }
#line 86
  goto switch_break;
  case_3: /* CIL Label */ 
#line 88
  if (! (proc_mode & (1 << 3))) {
#line 89
    return;
  }
  {
#line 90
  printf((char const   */* __restrict  */)"-F- ");
  }
#line 91
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 93
  printf((char const   */* __restrict  */)"-?- ");
  }
#line 94
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 96
  vprintf((char const   */* __restrict  */)format, lst);
#line 97
  __builtin_va_end(lst);
  }
#line 98
  return;
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl.c"
int bsdl_read_file(chain_t *chain , char const   *BSDL_File_Name , int proc_mode ,
                   char const   *idcode___0 ) 
{ 
  bsdl_globs_t *globs ;
  FILE *BSDL_File ;
  vhdl_parser_priv_t *vhdl_parser_priv ;
  jtag_ctrl_t jtag_ctrl ;
  int Compile_Errors ;
  int result ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 121
  globs = & chain->bsdl;
#line 125
  Compile_Errors = 1;
#line 128
  if (globs->debug) {
#line 129
    proc_mode |= (((1 << 3) | (1 << 2)) | (1 << 1)) | 1;
  }
#line 131
  jtag_ctrl.proc_mode = proc_mode;
#line 134
  if (proc_mode & (1 << 6)) {
#line 136
    if ((unsigned long )chain == (unsigned long )((void *)0)) {
      {
#line 138
      tmp = gettext("No JTAG chain available\n");
#line 138
      bsdl_msg(proc_mode, 2, (char const   *)tmp);
      }
#line 139
      return (-1);
    }
#line 141
    if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
      {
#line 143
      tmp___0 = gettext("Chain without any parts\n");
#line 143
      bsdl_msg(proc_mode, 2, (char const   *)tmp___0);
      }
#line 144
      return (-1);
    }
#line 146
    if (chain) {
#line 146
      if (! chain->parts) {
#line 147
        return (-1);
      }
    } else {
#line 147
      return (-1);
    }
#line 149
    jtag_ctrl.chain = chain;
#line 150
    jtag_ctrl.part = *((chain->parts)->parts + chain->active_part);
  } else {
#line 154
    jtag_ctrl.chain = (chain_t *)((void *)0);
#line 155
    jtag_ctrl.part = (part_t *)((void *)0);
  }
  {
#line 158
  BSDL_File = fopen((char const   */* __restrict  */)BSDL_File_Name, (char const   */* __restrict  */)"r");
#line 160
  tmp___1 = gettext("Reading file \'%s\'\n");
#line 160
  bsdl_msg(proc_mode, 0, (char const   *)tmp___1, BSDL_File_Name);
  }
#line 162
  if ((unsigned long )BSDL_File == (unsigned long )((void *)0)) {
    {
#line 163
    tmp___2 = gettext("Unable to open BSDL file \'%s\'\n");
#line 163
    bsdl_msg(proc_mode, 2, (char const   *)tmp___2, BSDL_File_Name);
    }
#line 165
    return (-1);
  }
  {
#line 168
  vhdl_parser_priv = vhdl_parser_init(BSDL_File, & jtag_ctrl);
  }
#line 168
  if (vhdl_parser_priv) {
    {
#line 170
    (vhdl_parser_priv->jtag_ctrl)->idcode = (char *)((void *)0);
#line 172
    vhdlparse(vhdl_parser_priv);
#line 174
    Compile_Errors = vhdl_flex_get_compile_errors(vhdl_parser_priv->scanner);
    }
#line 175
    if (Compile_Errors == 0) {
      {
#line 177
      tmp___3 = gettext("BSDL file \'%s\' passed VHDL stage correctly\n");
#line 177
      bsdl_msg(proc_mode, 0, (char const   *)tmp___3, BSDL_File_Name);
#line 181
      result = bsdl_process_elements(& jtag_ctrl, idcode___0);
      }
#line 183
      if (result >= 0) {
        {
#line 184
        tmp___4 = gettext("BSDL file \'%s\' passed BSDL stage correctly\n");
#line 184
        bsdl_msg(proc_mode, 0, (char const   *)tmp___4, BSDL_File_Name);
        }
      }
    } else {
      {
#line 191
      tmp___5 = gettext("BSDL file \'%s\' contains errors in VHDL stage, stopping\n");
#line 191
      bsdl_msg(proc_mode, 2, (char const   *)tmp___5, BSDL_File_Name);
      }
    }
    {
#line 197
    vhdl_parser_deinit(vhdl_parser_priv);
    }
  }
#line 200
  if (Compile_Errors == 0) {
#line 200
    tmp___6 = result;
  } else {
#line 200
    tmp___6 = -1;
  }
#line 200
  return (tmp___6);
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl.c"
void bsdl_set_path(chain_t *chain , char const   *pathlist ) 
{ 
  bsdl_globs_t *globs ;
  char *delim ;
  char *elem ;
  char *pathelem ;
  int num ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 220
  globs = & chain->bsdl;
#line 228
  if (globs->path_list) {
#line 230
    num = 0;
    {
#line 230
    while (1) {
      while_continue: /* CIL Label */ ;
#line 230
      if (! *(globs->path_list + num)) {
#line 230
        goto while_break;
      }
#line 231
      if (*(globs->path_list + num)) {
        {
#line 232
        free((void *)*(globs->path_list + num));
        }
      }
#line 230
      num ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 233
    free((void *)globs->path_list);
#line 234
    globs->path_list = (char **)((void *)0);
    }
  }
#line 238
  num = 0;
#line 238
  elem = (char *)pathlist;
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 238
    tmp___2 = strlen((char const   *)elem);
    }
#line 238
    if (! (tmp___2 > 0UL)) {
#line 238
      goto while_break___0;
    }
    {
#line 240
    delim = strchr((char const   *)elem, ';');
    }
#line 241
    if (delim - elem > 0L) {
#line 241
      goto _L;
    } else
#line 241
    if ((unsigned long )delim == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
      {
#line 243
      num ++;
#line 245
      tmp = realloc((void *)globs->path_list, (unsigned long )(num + 1) * sizeof(char *));
#line 245
      globs->path_list = (char **)tmp;
      }
#line 247
      if ((unsigned long )delim == (unsigned long )((void *)0)) {
        {
#line 248
        len = strlen((char const   *)elem);
        }
      } else {
#line 250
        len = (size_t )(delim - elem);
      }
      {
#line 251
      tmp___0 = malloc(len + 1UL);
#line 251
      pathelem = (char *)tmp___0;
#line 252
      memcpy((void */* __restrict  */)pathelem, (void const   */* __restrict  */)elem,
             len);
#line 253
      *(pathelem + len) = (char )'\000';
#line 254
      *(globs->path_list + (num - 1)) = pathelem;
#line 255
      *(globs->path_list + num) = (char *)((void *)0);
      }
    }
#line 257
    if (delim) {
#line 257
      elem = delim + 1;
    } else {
      {
#line 257
      tmp___1 = strlen((char const   *)elem);
#line 257
      elem += tmp___1;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if (globs->debug) {
#line 261
    num = 0;
    {
#line 261
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 261
      if (! ((unsigned long )*(globs->path_list + num) != (unsigned long )((void *)0))) {
#line 261
        goto while_break___1;
      }
      {
#line 262
      bsdl_msg((((1 << 3) | (1 << 2)) | (1 << 1)) | 1, 0, "%s\n", *(globs->path_list + num));
#line 261
      num ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 264
  return;
}
}
#line 287 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl.c"
int bsdl_scan_files(chain_t *chain , char const   *idcode___0 , int proc_mode ) 
{ 
  bsdl_globs_t *globs ;
  int idx ;
  int result ;
  DIR *dir ;
  struct dirent *elem ;
  char *name ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct stat buf ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
#line 289
  globs = & chain->bsdl;
#line 290
  idx = 0;
#line 291
  result = 0;
#line 294
  if ((unsigned long )globs->path_list == (unsigned long )((void *)0)) {
#line 295
    return (0);
  }
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (*(globs->path_list + idx)) {
#line 297
      if (! (result <= 0)) {
#line 297
        goto while_break;
      }
    } else {
#line 297
      goto while_break;
    }
    {
#line 301
    dir = opendir((char const   *)*(globs->path_list + idx));
    }
#line 301
    if (dir) {
      {
#line 306
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 306
        elem = readdir(dir);
        }
#line 306
        if (elem) {
#line 306
          if (! (result <= 0)) {
#line 306
            goto while_break___0;
          }
        } else {
#line 306
          goto while_break___0;
        }
        {
#line 310
        tmp = strlen((char const   *)*(globs->path_list + idx));
#line 310
        tmp___0 = strlen((char const   *)(elem->d_name));
#line 310
        tmp___1 = malloc(((tmp + tmp___0) + 1UL) + 1UL);
#line 310
        name = (char *)tmp___1;
        }
#line 312
        if (name) {
          {
#line 316
          strcpy((char */* __restrict  */)name, (char const   */* __restrict  */)*(globs->path_list + idx));
#line 317
          strcat((char */* __restrict  */)name, (char const   */* __restrict  */)"/");
#line 318
          strcat((char */* __restrict  */)name, (char const   */* __restrict  */)(elem->d_name));
#line 320
          tmp___3 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& buf));
          }
#line 320
          if (tmp___3 == 0) {
#line 322
            if (buf.st_mode & 32768U) {
              {
#line 324
              result = bsdl_read_file(chain, (char const   *)name, proc_mode, idcode___0);
              }
#line 325
              if (result == 1) {
                {
#line 326
                tmp___2 = gettext("  Filename:     %s\n");
#line 326
                printf((char const   */* __restrict  */)tmp___2, name);
                }
              }
            }
          }
          {
#line 330
          free((void *)name);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 334
      closedir(dir);
      }
    } else {
      {
#line 337
      tmp___4 = gettext("Cannot open directory %s\n");
#line 337
      bsdl_msg(proc_mode, 1, (char const   *)tmp___4, *(globs->path_list + idx));
      }
    }
#line 340
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (result);
}
}
#line 287 "bsdl_flex.c"
void bsdlrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 288
void bsdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 289
YY_BUFFER_STATE bsdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 290
void bsdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 291
void bsdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 292
void bsdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 293
void bsdlpop_buffer_state(yyscan_t yyscanner ) ;
#line 295
static void bsdlensure_buffer_stack(yyscan_t yyscanner ) ;
#line 296
static void bsdl_load_buffer_state(yyscan_t yyscanner ) ;
#line 297
static void bsdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 301
YY_BUFFER_STATE bsdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 302
YY_BUFFER_STATE bsdl_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 303
YY_BUFFER_STATE bsdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 305
void *bsdlalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 306
void *bsdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 307
void bsdlfree(void *ptr , yyscan_t yyscanner ) ;
#line 341
static yy_state_type yy_get_previous_state___0(yyscan_t yyscanner ) ;
#line 342
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 343
static int yy_get_next_buffer___0(yyscan_t yyscanner ) ;
#line 344
static void yy_fatal_error___0(char const   *msg , yyscan_t yyscanner ) ;
#line 365 "bsdl_flex.c"
static flex_int16_t const   yy_acclist___0[880]  = 
#line 365
  {      (flex_int16_t const   )0,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107, 
        (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107, 
        (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107,      (flex_int16_t const   )107, 
        (flex_int16_t const   )107,      (flex_int16_t const   )117,      (flex_int16_t const   )115,      (flex_int16_t const   )116, 
        (flex_int16_t const   )107,      (flex_int16_t const   )116,      (flex_int16_t const   )99,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )101,      (flex_int16_t const   )116,      (flex_int16_t const   )102, 
        (flex_int16_t const   )116,      (flex_int16_t const   )106,      (flex_int16_t const   )116,      (flex_int16_t const   )100, 
        (flex_int16_t const   )116,      (flex_int16_t const   )116,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )116,      (flex_int16_t const   )110, 
        (flex_int16_t const   )113,      (flex_int16_t const   )116,      (flex_int16_t const   )105,      (flex_int16_t const   )116, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )109, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )103,      (flex_int16_t const   )116, 
        (flex_int16_t const   )104,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )93,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )63,      (flex_int16_t const   )116,      (flex_int16_t const   )54,      (flex_int16_t const   )116, 
        (flex_int16_t const   )56,      (flex_int16_t const   )116,      (flex_int16_t const   )57,      (flex_int16_t const   )116, 
        (flex_int16_t const   )116,      (flex_int16_t const   )55,      (flex_int16_t const   )116,      (flex_int16_t const   )116, 
        (flex_int16_t const   )62,      (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116, 
        (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )111, 
        (flex_int16_t const   )116,      (flex_int16_t const   )111,      (flex_int16_t const   )116,      (flex_int16_t const   )60, 
        (flex_int16_t const   )116,      (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )109, 
        (flex_int16_t const   )110,      (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )110, 
        (flex_int16_t const   )113,      (flex_int16_t const   )110,      (flex_int16_t const   )109,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )109,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )110, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )59,      (flex_int16_t const   )58, 
        (flex_int16_t const   )61,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )108,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )52,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )51,      (flex_int16_t const   )111,      (flex_int16_t const   )50,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )53,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )48,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )49,      (flex_int16_t const   )111,      (flex_int16_t const   )114,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )90, 
        (flex_int16_t const   )111,      (flex_int16_t const   )88,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )82,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )96,      (flex_int16_t const   )111, 
        (flex_int16_t const   )97,      (flex_int16_t const   )111,      (flex_int16_t const   )94,      (flex_int16_t const   )111, 
        (flex_int16_t const   )95,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )72,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )74,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )42,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )98,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )70,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )73,      (flex_int16_t const   )111,      (flex_int16_t const   )75,      (flex_int16_t const   )111, 
        (flex_int16_t const   )76,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )79,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )46, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )2,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )86,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )83,      (flex_int16_t const   )111,      (flex_int16_t const   )84, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )77, 
        (flex_int16_t const   )111,      (flex_int16_t const   )78,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )44,      (flex_int16_t const   )77, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )1,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )39,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )85,      (flex_int16_t const   )111,      (flex_int16_t const   )87,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )71,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )80,      (flex_int16_t const   )111,      (flex_int16_t const   )91,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )67,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )43,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )81, 
        (flex_int16_t const   )111,      (flex_int16_t const   )92,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )47,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )65,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )31, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )45, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )5,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )32,      (flex_int16_t const   )111,      (flex_int16_t const   )66,      (flex_int16_t const   )111, 
        (flex_int16_t const   )68,      (flex_int16_t const   )111,      (flex_int16_t const   )40,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )34,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )6, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )89, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )64,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )27,      (flex_int16_t const   )111,      (flex_int16_t const   )28, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )8,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )41,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )4,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )7,      (flex_int16_t const   )111, 
        (flex_int16_t const   )9,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )17, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )19,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )26,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )38,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )16,      (flex_int16_t const   )111,      (flex_int16_t const   )23,      (flex_int16_t const   )111, 
        (flex_int16_t const   )24,      (flex_int16_t const   )111,      (flex_int16_t const   )25,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )35,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )69,      (flex_int16_t const   )111,      (flex_int16_t const   )29,      (flex_int16_t const   )111, 
        (flex_int16_t const   )3,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )18, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )14,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )37, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )20, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )10,      (flex_int16_t const   )111,      (flex_int16_t const   )11, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )33,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )21,      (flex_int16_t const   )111, 
        (flex_int16_t const   )111,      (flex_int16_t const   )12,      (flex_int16_t const   )111,      (flex_int16_t const   )13, 
        (flex_int16_t const   )111,      (flex_int16_t const   )15,      (flex_int16_t const   )111,      (flex_int16_t const   )36, 
        (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111,      (flex_int16_t const   )111, 
        (flex_int16_t const   )22,      (flex_int16_t const   )111,      (flex_int16_t const   )30,      (flex_int16_t const   )111};
#line 465 "bsdl_flex.c"
static flex_int16_t const   yy_accept___0[710]  = 
#line 465
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )2,      (flex_int16_t const   )3, 
        (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )7, 
        (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )16, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )23, 
        (flex_int16_t const   )25,      (flex_int16_t const   )27,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )35,      (flex_int16_t const   )38,      (flex_int16_t const   )40,      (flex_int16_t const   )43, 
        (flex_int16_t const   )46,      (flex_int16_t const   )49,      (flex_int16_t const   )51,      (flex_int16_t const   )53, 
        (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )59,      (flex_int16_t const   )61, 
        (flex_int16_t const   )63,      (flex_int16_t const   )66,      (flex_int16_t const   )68,      (flex_int16_t const   )70, 
        (flex_int16_t const   )73,      (flex_int16_t const   )76,      (flex_int16_t const   )78,      (flex_int16_t const   )80, 
        (flex_int16_t const   )82,      (flex_int16_t const   )84,      (flex_int16_t const   )86,      (flex_int16_t const   )89, 
        (flex_int16_t const   )92,      (flex_int16_t const   )95,      (flex_int16_t const   )98,      (flex_int16_t const   )101, 
        (flex_int16_t const   )103,      (flex_int16_t const   )105,      (flex_int16_t const   )107,      (flex_int16_t const   )109, 
        (flex_int16_t const   )111,      (flex_int16_t const   )113,      (flex_int16_t const   )116,      (flex_int16_t const   )118, 
        (flex_int16_t const   )120,      (flex_int16_t const   )122,      (flex_int16_t const   )124,      (flex_int16_t const   )125, 
        (flex_int16_t const   )127,      (flex_int16_t const   )128,      (flex_int16_t const   )130,      (flex_int16_t const   )133, 
        (flex_int16_t const   )136,      (flex_int16_t const   )139,      (flex_int16_t const   )141,      (flex_int16_t const   )143, 
        (flex_int16_t const   )145,      (flex_int16_t const   )147,      (flex_int16_t const   )149,      (flex_int16_t const   )151, 
        (flex_int16_t const   )153,      (flex_int16_t const   )155,      (flex_int16_t const   )157,      (flex_int16_t const   )159, 
        (flex_int16_t const   )161,      (flex_int16_t const   )162,      (flex_int16_t const   )163,      (flex_int16_t const   )163, 
        (flex_int16_t const   )167,      (flex_int16_t const   )169,      (flex_int16_t const   )170,      (flex_int16_t const   )171, 
        (flex_int16_t const   )173,      (flex_int16_t const   )174,      (flex_int16_t const   )175,      (flex_int16_t const   )176, 
        (flex_int16_t const   )177,      (flex_int16_t const   )178,      (flex_int16_t const   )179,      (flex_int16_t const   )180, 
        (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )183,      (flex_int16_t const   )184, 
        (flex_int16_t const   )185,      (flex_int16_t const   )187,      (flex_int16_t const   )188,      (flex_int16_t const   )189, 
        (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192,      (flex_int16_t const   )193, 
        (flex_int16_t const   )194,      (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197, 
        (flex_int16_t const   )198,      (flex_int16_t const   )199,      (flex_int16_t const   )201,      (flex_int16_t const   )202, 
        (flex_int16_t const   )203,      (flex_int16_t const   )204,      (flex_int16_t const   )205,      (flex_int16_t const   )206, 
        (flex_int16_t const   )207,      (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214, 
        (flex_int16_t const   )215,      (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )218, 
        (flex_int16_t const   )219,      (flex_int16_t const   )220,      (flex_int16_t const   )221,      (flex_int16_t const   )222, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )226, 
        (flex_int16_t const   )227,      (flex_int16_t const   )228,      (flex_int16_t const   )229,      (flex_int16_t const   )230, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )232,      (flex_int16_t const   )233, 
        (flex_int16_t const   )234,      (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )237, 
        (flex_int16_t const   )238,      (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )241, 
        (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )244,      (flex_int16_t const   )245, 
        (flex_int16_t const   )246,      (flex_int16_t const   )247,      (flex_int16_t const   )248,      (flex_int16_t const   )249, 
        (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )252,      (flex_int16_t const   )253, 
        (flex_int16_t const   )254,      (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )257, 
        (flex_int16_t const   )258,      (flex_int16_t const   )259,      (flex_int16_t const   )260,      (flex_int16_t const   )261, 
        (flex_int16_t const   )262,      (flex_int16_t const   )263,      (flex_int16_t const   )264,      (flex_int16_t const   )265, 
        (flex_int16_t const   )266,      (flex_int16_t const   )268,      (flex_int16_t const   )269,      (flex_int16_t const   )270, 
        (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )274,      (flex_int16_t const   )276, 
        (flex_int16_t const   )277,      (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )281, 
        (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )284,      (flex_int16_t const   )285, 
        (flex_int16_t const   )286,      (flex_int16_t const   )287,      (flex_int16_t const   )287,      (flex_int16_t const   )288, 
        (flex_int16_t const   )289,      (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )292, 
        (flex_int16_t const   )293,      (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )296, 
        (flex_int16_t const   )297,      (flex_int16_t const   )298,      (flex_int16_t const   )299,      (flex_int16_t const   )300, 
        (flex_int16_t const   )301,      (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )305,      (flex_int16_t const   )306,      (flex_int16_t const   )307,      (flex_int16_t const   )308, 
        (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311,      (flex_int16_t const   )312, 
        (flex_int16_t const   )313,      (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )316, 
        (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )320, 
        (flex_int16_t const   )321,      (flex_int16_t const   )322,      (flex_int16_t const   )323,      (flex_int16_t const   )324, 
        (flex_int16_t const   )325,      (flex_int16_t const   )326,      (flex_int16_t const   )328,      (flex_int16_t const   )329, 
        (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )332,      (flex_int16_t const   )333, 
        (flex_int16_t const   )334,      (flex_int16_t const   )335,      (flex_int16_t const   )336,      (flex_int16_t const   )338, 
        (flex_int16_t const   )338,      (flex_int16_t const   )339,      (flex_int16_t const   )340,      (flex_int16_t const   )341, 
        (flex_int16_t const   )342,      (flex_int16_t const   )343,      (flex_int16_t const   )344,      (flex_int16_t const   )345, 
        (flex_int16_t const   )346,      (flex_int16_t const   )347,      (flex_int16_t const   )348,      (flex_int16_t const   )349, 
        (flex_int16_t const   )350,      (flex_int16_t const   )351,      (flex_int16_t const   )352,      (flex_int16_t const   )353, 
        (flex_int16_t const   )354,      (flex_int16_t const   )355,      (flex_int16_t const   )356,      (flex_int16_t const   )357, 
        (flex_int16_t const   )358,      (flex_int16_t const   )359,      (flex_int16_t const   )361,      (flex_int16_t const   )363, 
        (flex_int16_t const   )364,      (flex_int16_t const   )366,      (flex_int16_t const   )367,      (flex_int16_t const   )368, 
        (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )372,      (flex_int16_t const   )374, 
        (flex_int16_t const   )376,      (flex_int16_t const   )378,      (flex_int16_t const   )379,      (flex_int16_t const   )380, 
        (flex_int16_t const   )382,      (flex_int16_t const   )383,      (flex_int16_t const   )384,      (flex_int16_t const   )386, 
        (flex_int16_t const   )387,      (flex_int16_t const   )388,      (flex_int16_t const   )389,      (flex_int16_t const   )390, 
        (flex_int16_t const   )391,      (flex_int16_t const   )392,      (flex_int16_t const   )393,      (flex_int16_t const   )395, 
        (flex_int16_t const   )396,      (flex_int16_t const   )397,      (flex_int16_t const   )398,      (flex_int16_t const   )399, 
        (flex_int16_t const   )400,      (flex_int16_t const   )401,      (flex_int16_t const   )402,      (flex_int16_t const   )403, 
        (flex_int16_t const   )404,      (flex_int16_t const   )405,      (flex_int16_t const   )406,      (flex_int16_t const   )407, 
        (flex_int16_t const   )408,      (flex_int16_t const   )409,      (flex_int16_t const   )410,      (flex_int16_t const   )411, 
        (flex_int16_t const   )412,      (flex_int16_t const   )413,      (flex_int16_t const   )414,      (flex_int16_t const   )415, 
        (flex_int16_t const   )416,      (flex_int16_t const   )417,      (flex_int16_t const   )418,      (flex_int16_t const   )419, 
        (flex_int16_t const   )420,      (flex_int16_t const   )421,      (flex_int16_t const   )422,      (flex_int16_t const   )423, 
        (flex_int16_t const   )424,      (flex_int16_t const   )425,      (flex_int16_t const   )426,      (flex_int16_t const   )427, 
        (flex_int16_t const   )428,      (flex_int16_t const   )429,      (flex_int16_t const   )430,      (flex_int16_t const   )431, 
        (flex_int16_t const   )432,      (flex_int16_t const   )434,      (flex_int16_t const   )435,      (flex_int16_t const   )436, 
        (flex_int16_t const   )437,      (flex_int16_t const   )439,      (flex_int16_t const   )440,      (flex_int16_t const   )442, 
        (flex_int16_t const   )444,      (flex_int16_t const   )446,      (flex_int16_t const   )447,      (flex_int16_t const   )448, 
        (flex_int16_t const   )450,      (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )453, 
        (flex_int16_t const   )454,      (flex_int16_t const   )455,      (flex_int16_t const   )456,      (flex_int16_t const   )457, 
        (flex_int16_t const   )458,      (flex_int16_t const   )459,      (flex_int16_t const   )461,      (flex_int16_t const   )462, 
        (flex_int16_t const   )463,      (flex_int16_t const   )464,      (flex_int16_t const   )465,      (flex_int16_t const   )466, 
        (flex_int16_t const   )467,      (flex_int16_t const   )468,      (flex_int16_t const   )469,      (flex_int16_t const   )470, 
        (flex_int16_t const   )471,      (flex_int16_t const   )472,      (flex_int16_t const   )473,      (flex_int16_t const   )474, 
        (flex_int16_t const   )475,      (flex_int16_t const   )476,      (flex_int16_t const   )477,      (flex_int16_t const   )478, 
        (flex_int16_t const   )479,      (flex_int16_t const   )480,      (flex_int16_t const   )481,      (flex_int16_t const   )482, 
        (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )486,      (flex_int16_t const   )487, 
        (flex_int16_t const   )488,      (flex_int16_t const   )489,      (flex_int16_t const   )491,      (flex_int16_t const   )492, 
        (flex_int16_t const   )493,      (flex_int16_t const   )495,      (flex_int16_t const   )497,      (flex_int16_t const   )498, 
        (flex_int16_t const   )499,      (flex_int16_t const   )501,      (flex_int16_t const   )503,      (flex_int16_t const   )504, 
        (flex_int16_t const   )505,      (flex_int16_t const   )506,      (flex_int16_t const   )507,      (flex_int16_t const   )508, 
        (flex_int16_t const   )509,      (flex_int16_t const   )510,      (flex_int16_t const   )513,      (flex_int16_t const   )514, 
        (flex_int16_t const   )515,      (flex_int16_t const   )516,      (flex_int16_t const   )517,      (flex_int16_t const   )518, 
        (flex_int16_t const   )519,      (flex_int16_t const   )520,      (flex_int16_t const   )521,      (flex_int16_t const   )523, 
        (flex_int16_t const   )524,      (flex_int16_t const   )525,      (flex_int16_t const   )526,      (flex_int16_t const   )527, 
        (flex_int16_t const   )528,      (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )532, 
        (flex_int16_t const   )533,      (flex_int16_t const   )534,      (flex_int16_t const   )535,      (flex_int16_t const   )536, 
        (flex_int16_t const   )537,      (flex_int16_t const   )538,      (flex_int16_t const   )539,      (flex_int16_t const   )540, 
        (flex_int16_t const   )541,      (flex_int16_t const   )542,      (flex_int16_t const   )543,      (flex_int16_t const   )544, 
        (flex_int16_t const   )546,      (flex_int16_t const   )548,      (flex_int16_t const   )549,      (flex_int16_t const   )551, 
        (flex_int16_t const   )552,      (flex_int16_t const   )554,      (flex_int16_t const   )556,      (flex_int16_t const   )557, 
        (flex_int16_t const   )558,      (flex_int16_t const   )559,      (flex_int16_t const   )560,      (flex_int16_t const   )562, 
        (flex_int16_t const   )563,      (flex_int16_t const   )564,      (flex_int16_t const   )566,      (flex_int16_t const   )567, 
        (flex_int16_t const   )568,      (flex_int16_t const   )569,      (flex_int16_t const   )570,      (flex_int16_t const   )571, 
        (flex_int16_t const   )572,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )575, 
        (flex_int16_t const   )576,      (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )579, 
        (flex_int16_t const   )580,      (flex_int16_t const   )581,      (flex_int16_t const   )582,      (flex_int16_t const   )583, 
        (flex_int16_t const   )584,      (flex_int16_t const   )585,      (flex_int16_t const   )586,      (flex_int16_t const   )587, 
        (flex_int16_t const   )588,      (flex_int16_t const   )589,      (flex_int16_t const   )590,      (flex_int16_t const   )591, 
        (flex_int16_t const   )593,      (flex_int16_t const   )595,      (flex_int16_t const   )596,      (flex_int16_t const   )597, 
        (flex_int16_t const   )598,      (flex_int16_t const   )599,      (flex_int16_t const   )600,      (flex_int16_t const   )602, 
        (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )605,      (flex_int16_t const   )606, 
        (flex_int16_t const   )607,      (flex_int16_t const   )608,      (flex_int16_t const   )609,      (flex_int16_t const   )611, 
        (flex_int16_t const   )612,      (flex_int16_t const   )613,      (flex_int16_t const   )614,      (flex_int16_t const   )615, 
        (flex_int16_t const   )616,      (flex_int16_t const   )617,      (flex_int16_t const   )618,      (flex_int16_t const   )619, 
        (flex_int16_t const   )621,      (flex_int16_t const   )622,      (flex_int16_t const   )623,      (flex_int16_t const   )624, 
        (flex_int16_t const   )625,      (flex_int16_t const   )626,      (flex_int16_t const   )627,      (flex_int16_t const   )628, 
        (flex_int16_t const   )629,      (flex_int16_t const   )630,      (flex_int16_t const   )631,      (flex_int16_t const   )632, 
        (flex_int16_t const   )633,      (flex_int16_t const   )634,      (flex_int16_t const   )635,      (flex_int16_t const   )637, 
        (flex_int16_t const   )638,      (flex_int16_t const   )639,      (flex_int16_t const   )640,      (flex_int16_t const   )641, 
        (flex_int16_t const   )642,      (flex_int16_t const   )643,      (flex_int16_t const   )644,      (flex_int16_t const   )645, 
        (flex_int16_t const   )646,      (flex_int16_t const   )647,      (flex_int16_t const   )648,      (flex_int16_t const   )649, 
        (flex_int16_t const   )650,      (flex_int16_t const   )651,      (flex_int16_t const   )652,      (flex_int16_t const   )653, 
        (flex_int16_t const   )654,      (flex_int16_t const   )655,      (flex_int16_t const   )656,      (flex_int16_t const   )657, 
        (flex_int16_t const   )658,      (flex_int16_t const   )659,      (flex_int16_t const   )660,      (flex_int16_t const   )662, 
        (flex_int16_t const   )663,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )666, 
        (flex_int16_t const   )667,      (flex_int16_t const   )668,      (flex_int16_t const   )670,      (flex_int16_t const   )672, 
        (flex_int16_t const   )674,      (flex_int16_t const   )676,      (flex_int16_t const   )677,      (flex_int16_t const   )678, 
        (flex_int16_t const   )679,      (flex_int16_t const   )680,      (flex_int16_t const   )681,      (flex_int16_t const   )682, 
        (flex_int16_t const   )683,      (flex_int16_t const   )684,      (flex_int16_t const   )685,      (flex_int16_t const   )686, 
        (flex_int16_t const   )687,      (flex_int16_t const   )688,      (flex_int16_t const   )689,      (flex_int16_t const   )691, 
        (flex_int16_t const   )692,      (flex_int16_t const   )693,      (flex_int16_t const   )694,      (flex_int16_t const   )695, 
        (flex_int16_t const   )696,      (flex_int16_t const   )697,      (flex_int16_t const   )698,      (flex_int16_t const   )699, 
        (flex_int16_t const   )701,      (flex_int16_t const   )702,      (flex_int16_t const   )703,      (flex_int16_t const   )705, 
        (flex_int16_t const   )706,      (flex_int16_t const   )707,      (flex_int16_t const   )708,      (flex_int16_t const   )709, 
        (flex_int16_t const   )710,      (flex_int16_t const   )711,      (flex_int16_t const   )712,      (flex_int16_t const   )713, 
        (flex_int16_t const   )714,      (flex_int16_t const   )715,      (flex_int16_t const   )716,      (flex_int16_t const   )717, 
        (flex_int16_t const   )718,      (flex_int16_t const   )719,      (flex_int16_t const   )720,      (flex_int16_t const   )721, 
        (flex_int16_t const   )722,      (flex_int16_t const   )723,      (flex_int16_t const   )724,      (flex_int16_t const   )725, 
        (flex_int16_t const   )726,      (flex_int16_t const   )728,      (flex_int16_t const   )729,      (flex_int16_t const   )730, 
        (flex_int16_t const   )731,      (flex_int16_t const   )732,      (flex_int16_t const   )733,      (flex_int16_t const   )735, 
        (flex_int16_t const   )737,      (flex_int16_t const   )738,      (flex_int16_t const   )740,      (flex_int16_t const   )741, 
        (flex_int16_t const   )742,      (flex_int16_t const   )744,      (flex_int16_t const   )745,      (flex_int16_t const   )746, 
        (flex_int16_t const   )747,      (flex_int16_t const   )748,      (flex_int16_t const   )749,      (flex_int16_t const   )750, 
        (flex_int16_t const   )751,      (flex_int16_t const   )752,      (flex_int16_t const   )753,      (flex_int16_t const   )754, 
        (flex_int16_t const   )755,      (flex_int16_t const   )756,      (flex_int16_t const   )757,      (flex_int16_t const   )758, 
        (flex_int16_t const   )759,      (flex_int16_t const   )760,      (flex_int16_t const   )761,      (flex_int16_t const   )762, 
        (flex_int16_t const   )763,      (flex_int16_t const   )764,      (flex_int16_t const   )765,      (flex_int16_t const   )767, 
        (flex_int16_t const   )768,      (flex_int16_t const   )769,      (flex_int16_t const   )770,      (flex_int16_t const   )772, 
        (flex_int16_t const   )774,      (flex_int16_t const   )775,      (flex_int16_t const   )777,      (flex_int16_t const   )778, 
        (flex_int16_t const   )779,      (flex_int16_t const   )780,      (flex_int16_t const   )782,      (flex_int16_t const   )783, 
        (flex_int16_t const   )784,      (flex_int16_t const   )785,      (flex_int16_t const   )786,      (flex_int16_t const   )787, 
        (flex_int16_t const   )788,      (flex_int16_t const   )789,      (flex_int16_t const   )791,      (flex_int16_t const   )792, 
        (flex_int16_t const   )794,      (flex_int16_t const   )795,      (flex_int16_t const   )796,      (flex_int16_t const   )797, 
        (flex_int16_t const   )798,      (flex_int16_t const   )799,      (flex_int16_t const   )800,      (flex_int16_t const   )802, 
        (flex_int16_t const   )804,      (flex_int16_t const   )806,      (flex_int16_t const   )808,      (flex_int16_t const   )809, 
        (flex_int16_t const   )810,      (flex_int16_t const   )811,      (flex_int16_t const   )812,      (flex_int16_t const   )813, 
        (flex_int16_t const   )814,      (flex_int16_t const   )815,      (flex_int16_t const   )816,      (flex_int16_t const   )817, 
        (flex_int16_t const   )818,      (flex_int16_t const   )819,      (flex_int16_t const   )820,      (flex_int16_t const   )821, 
        (flex_int16_t const   )823,      (flex_int16_t const   )824,      (flex_int16_t const   )826,      (flex_int16_t const   )828, 
        (flex_int16_t const   )830,      (flex_int16_t const   )831,      (flex_int16_t const   )833,      (flex_int16_t const   )834, 
        (flex_int16_t const   )835,      (flex_int16_t const   )836,      (flex_int16_t const   )837,      (flex_int16_t const   )839, 
        (flex_int16_t const   )840,      (flex_int16_t const   )841,      (flex_int16_t const   )842,      (flex_int16_t const   )843, 
        (flex_int16_t const   )845,      (flex_int16_t const   )846,      (flex_int16_t const   )847,      (flex_int16_t const   )849, 
        (flex_int16_t const   )850,      (flex_int16_t const   )851,      (flex_int16_t const   )852,      (flex_int16_t const   )853, 
        (flex_int16_t const   )855,      (flex_int16_t const   )857,      (flex_int16_t const   )858,      (flex_int16_t const   )860, 
        (flex_int16_t const   )861,      (flex_int16_t const   )862,      (flex_int16_t const   )864,      (flex_int16_t const   )865, 
        (flex_int16_t const   )867,      (flex_int16_t const   )869,      (flex_int16_t const   )871,      (flex_int16_t const   )873, 
        (flex_int16_t const   )874,      (flex_int16_t const   )875,      (flex_int16_t const   )876,      (flex_int16_t const   )878, 
        (flex_int16_t const   )880,      (flex_int16_t const   )880};
#line 547 "bsdl_flex.c"
static flex_int32_t const   yy_ec___0[256]  = 
#line 547
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )5, 
        (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9,      (flex_int32_t const   )10, 
        (flex_int32_t const   )11,      (flex_int32_t const   )12,      (flex_int32_t const   )13,      (flex_int32_t const   )1, 
        (flex_int32_t const   )14,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )20, 
        (flex_int32_t const   )20,      (flex_int32_t const   )21,      (flex_int32_t const   )22,      (flex_int32_t const   )5, 
        (flex_int32_t const   )23,      (flex_int32_t const   )24,      (flex_int32_t const   )25,      (flex_int32_t const   )26, 
        (flex_int32_t const   )1,      (flex_int32_t const   )27,      (flex_int32_t const   )28,      (flex_int32_t const   )29, 
        (flex_int32_t const   )30,      (flex_int32_t const   )31,      (flex_int32_t const   )32,      (flex_int32_t const   )33, 
        (flex_int32_t const   )34,      (flex_int32_t const   )35,      (flex_int32_t const   )36,      (flex_int32_t const   )37, 
        (flex_int32_t const   )38,      (flex_int32_t const   )39,      (flex_int32_t const   )40,      (flex_int32_t const   )41, 
        (flex_int32_t const   )42,      (flex_int32_t const   )36,      (flex_int32_t const   )43,      (flex_int32_t const   )44, 
        (flex_int32_t const   )45,      (flex_int32_t const   )46,      (flex_int32_t const   )47,      (flex_int32_t const   )48, 
        (flex_int32_t const   )49,      (flex_int32_t const   )50,      (flex_int32_t const   )51,      (flex_int32_t const   )52, 
        (flex_int32_t const   )1,      (flex_int32_t const   )53,      (flex_int32_t const   )1,      (flex_int32_t const   )54, 
        (flex_int32_t const   )1,      (flex_int32_t const   )55,      (flex_int32_t const   )56,      (flex_int32_t const   )57, 
        (flex_int32_t const   )58,      (flex_int32_t const   )59,      (flex_int32_t const   )60,      (flex_int32_t const   )61, 
        (flex_int32_t const   )62,      (flex_int32_t const   )63,      (flex_int32_t const   )36,      (flex_int32_t const   )64, 
        (flex_int32_t const   )65,      (flex_int32_t const   )66,      (flex_int32_t const   )67,      (flex_int32_t const   )68, 
        (flex_int32_t const   )69,      (flex_int32_t const   )36,      (flex_int32_t const   )70,      (flex_int32_t const   )71, 
        (flex_int32_t const   )72,      (flex_int32_t const   )73,      (flex_int32_t const   )74,      (flex_int32_t const   )75, 
        (flex_int32_t const   )76,      (flex_int32_t const   )77,      (flex_int32_t const   )78,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )79,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 579 "bsdl_flex.c"
static flex_int32_t const   yy_meta___0[80]  = 
#line 579
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )1};
#line 591 "bsdl_flex.c"
static flex_int16_t const   yy_base___0[712]  = 
#line 591
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )52,      (flex_int16_t const   )0,      (flex_int16_t const   )103, 
        (flex_int16_t const   )0,      (flex_int16_t const   )55,      (flex_int16_t const   )100,      (flex_int16_t const   )173, 
        (flex_int16_t const   )0,      (flex_int16_t const   )691,      (flex_int16_t const   )1591,      (flex_int16_t const   )688, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )624,      (flex_int16_t const   )240, 
        (flex_int16_t const   )77,      (flex_int16_t const   )1591,      (flex_int16_t const   )303,      (flex_int16_t const   )350, 
        (flex_int16_t const   )45,      (flex_int16_t const   )0,      (flex_int16_t const   )207,      (flex_int16_t const   )108, 
        (flex_int16_t const   )51,      (flex_int16_t const   )50,      (flex_int16_t const   )70,      (flex_int16_t const   )73, 
        (flex_int16_t const   )91,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )89, 
        (flex_int16_t const   )110,      (flex_int16_t const   )236,      (flex_int16_t const   )105,      (flex_int16_t const   )167, 
        (flex_int16_t const   )147,      (flex_int16_t const   )127,      (flex_int16_t const   )0,      (flex_int16_t const   )234, 
        (flex_int16_t const   )241,      (flex_int16_t const   )242,      (flex_int16_t const   )236,      (flex_int16_t const   )159, 
        (flex_int16_t const   )285,      (flex_int16_t const   )341,      (flex_int16_t const   )282,      (flex_int16_t const   )236, 
        (flex_int16_t const   )136,      (flex_int16_t const   )166,      (flex_int16_t const   )1591,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )574,      (flex_int16_t const   )559,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )541,      (flex_int16_t const   )545,      (flex_int16_t const   )304,      (flex_int16_t const   )347, 
        (flex_int16_t const   )345,      (flex_int16_t const   )384,      (flex_int16_t const   )165,      (flex_int16_t const   )398, 
        (flex_int16_t const   )351,      (flex_int16_t const   )395,      (flex_int16_t const   )395,      (flex_int16_t const   )404, 
        (flex_int16_t const   )405,      (flex_int16_t const   )399,      (flex_int16_t const   )176,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )511,      (flex_int16_t const   )0,      (flex_int16_t const   )463,      (flex_int16_t const   )0, 
        (flex_int16_t const   )278,      (flex_int16_t const   )0,      (flex_int16_t const   )324,      (flex_int16_t const   )194, 
        (flex_int16_t const   )0,      (flex_int16_t const   )241,      (flex_int16_t const   )405,      (flex_int16_t const   )370, 
        (flex_int16_t const   )282,      (flex_int16_t const   )390,      (flex_int16_t const   )339,      (flex_int16_t const   )400, 
        (flex_int16_t const   )401,      (flex_int16_t const   )416,      (flex_int16_t const   )406,      (flex_int16_t const   )438, 
        (flex_int16_t const   )471,      (flex_int16_t const   )443,      (flex_int16_t const   )446,      (flex_int16_t const   )449, 
        (flex_int16_t const   )450,      (flex_int16_t const   )459,      (flex_int16_t const   )452,      (flex_int16_t const   )453, 
        (flex_int16_t const   )461,      (flex_int16_t const   )473,      (flex_int16_t const   )456,      (flex_int16_t const   )461, 
        (flex_int16_t const   )477,      (flex_int16_t const   )465,      (flex_int16_t const   )462,      (flex_int16_t const   )475, 
        (flex_int16_t const   )480,      (flex_int16_t const   )496,      (flex_int16_t const   )479,      (flex_int16_t const   )477, 
        (flex_int16_t const   )485,      (flex_int16_t const   )496,      (flex_int16_t const   )501,      (flex_int16_t const   )1591, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1591,      (flex_int16_t const   )492,      (flex_int16_t const   )513, 
        (flex_int16_t const   )508,      (flex_int16_t const   )503,      (flex_int16_t const   )513,      (flex_int16_t const   )505, 
        (flex_int16_t const   )501,      (flex_int16_t const   )512,      (flex_int16_t const   )509,      (flex_int16_t const   )511, 
        (flex_int16_t const   )533,      (flex_int16_t const   )536,      (flex_int16_t const   )531,      (flex_int16_t const   )520, 
        (flex_int16_t const   )533,      (flex_int16_t const   )526,      (flex_int16_t const   )0,      (flex_int16_t const   )592, 
        (flex_int16_t const   )547,      (flex_int16_t const   )549,      (flex_int16_t const   )550,      (flex_int16_t const   )554, 
        (flex_int16_t const   )553,      (flex_int16_t const   )457,      (flex_int16_t const   )555,      (flex_int16_t const   )451, 
        (flex_int16_t const   )561,      (flex_int16_t const   )439,      (flex_int16_t const   )437,      (flex_int16_t const   )557, 
        (flex_int16_t const   )568,      (flex_int16_t const   )575,      (flex_int16_t const   )571,      (flex_int16_t const   )571, 
        (flex_int16_t const   )588,      (flex_int16_t const   )586,      (flex_int16_t const   )589,      (flex_int16_t const   )587, 
        (flex_int16_t const   )592,      (flex_int16_t const   )596,      (flex_int16_t const   )594,      (flex_int16_t const   )608, 
        (flex_int16_t const   )598,      (flex_int16_t const   )603,      (flex_int16_t const   )608,      (flex_int16_t const   )606, 
        (flex_int16_t const   )604,      (flex_int16_t const   )610,      (flex_int16_t const   )608,      (flex_int16_t const   )621, 
        (flex_int16_t const   )610,      (flex_int16_t const   )610,      (flex_int16_t const   )615,      (flex_int16_t const   )627, 
        (flex_int16_t const   )0,      (flex_int16_t const   )613,      (flex_int16_t const   )621,      (flex_int16_t const   )617, 
        (flex_int16_t const   )623,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )635, 
        (flex_int16_t const   )0,      (flex_int16_t const   )636,      (flex_int16_t const   )633,      (flex_int16_t const   )635, 
        (flex_int16_t const   )640,      (flex_int16_t const   )635,      (flex_int16_t const   )644,      (flex_int16_t const   )641, 
        (flex_int16_t const   )642,      (flex_int16_t const   )703,      (flex_int16_t const   )658,      (flex_int16_t const   )666, 
        (flex_int16_t const   )655,      (flex_int16_t const   )667,      (flex_int16_t const   )662,      (flex_int16_t const   )708, 
        (flex_int16_t const   )691,      (flex_int16_t const   )667,      (flex_int16_t const   )668,      (flex_int16_t const   )441, 
        (flex_int16_t const   )684,      (flex_int16_t const   )700,      (flex_int16_t const   )699,      (flex_int16_t const   )708, 
        (flex_int16_t const   )703,      (flex_int16_t const   )702,      (flex_int16_t const   )705,      (flex_int16_t const   )699, 
        (flex_int16_t const   )706,      (flex_int16_t const   )705,      (flex_int16_t const   )84,      (flex_int16_t const   )87, 
        (flex_int16_t const   )723,      (flex_int16_t const   )712,      (flex_int16_t const   )717,      (flex_int16_t const   )731, 
        (flex_int16_t const   )718,      (flex_int16_t const   )716,      (flex_int16_t const   )740,      (flex_int16_t const   )736, 
        (flex_int16_t const   )741,      (flex_int16_t const   )749,      (flex_int16_t const   )749,      (flex_int16_t const   )756, 
        (flex_int16_t const   )747,      (flex_int16_t const   )741,      (flex_int16_t const   )398,      (flex_int16_t const   )761, 
        (flex_int16_t const   )758,      (flex_int16_t const   )0,      (flex_int16_t const   )754,      (flex_int16_t const   )755, 
        (flex_int16_t const   )754,      (flex_int16_t const   )760,      (flex_int16_t const   )773,      (flex_int16_t const   )759, 
        (flex_int16_t const   )768,      (flex_int16_t const   )764,      (flex_int16_t const   )0,      (flex_int16_t const   )819, 
        (flex_int16_t const   )827,      (flex_int16_t const   )798,      (flex_int16_t const   )792,      (flex_int16_t const   )790, 
        (flex_int16_t const   )822,      (flex_int16_t const   )819,      (flex_int16_t const   )806,      (flex_int16_t const   )825, 
        (flex_int16_t const   )818,      (flex_int16_t const   )817,      (flex_int16_t const   )824,      (flex_int16_t const   )825, 
        (flex_int16_t const   )824,      (flex_int16_t const   )829,      (flex_int16_t const   )835,      (flex_int16_t const   )836, 
        (flex_int16_t const   )840,      (flex_int16_t const   )824,      (flex_int16_t const   )135,      (flex_int16_t const   )841, 
        (flex_int16_t const   )832,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )833, 
        (flex_int16_t const   )0,      (flex_int16_t const   )835,      (flex_int16_t const   )833,      (flex_int16_t const   )834, 
        (flex_int16_t const   )839,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )859,      (flex_int16_t const   )847,      (flex_int16_t const   )0, 
        (flex_int16_t const   )866,      (flex_int16_t const   )859,      (flex_int16_t const   )0,      (flex_int16_t const   )874, 
        (flex_int16_t const   )864,      (flex_int16_t const   )879,      (flex_int16_t const   )866,      (flex_int16_t const   )881, 
        (flex_int16_t const   )874,      (flex_int16_t const   )383,      (flex_int16_t const   )0,      (flex_int16_t const   )875, 
        (flex_int16_t const   )878,      (flex_int16_t const   )886,      (flex_int16_t const   )879,      (flex_int16_t const   )893, 
        (flex_int16_t const   )886,      (flex_int16_t const   )884,      (flex_int16_t const   )879,      (flex_int16_t const   )891, 
        (flex_int16_t const   )888,      (flex_int16_t const   )900,      (flex_int16_t const   )889,      (flex_int16_t const   )903, 
        (flex_int16_t const   )904,      (flex_int16_t const   )898,      (flex_int16_t const   )348,      (flex_int16_t const   )910, 
        (flex_int16_t const   )900,      (flex_int16_t const   )920,      (flex_int16_t const   )912,      (flex_int16_t const   )909, 
        (flex_int16_t const   )907,      (flex_int16_t const   )919,      (flex_int16_t const   )923,      (flex_int16_t const   )922, 
        (flex_int16_t const   )923,      (flex_int16_t const   )937,      (flex_int16_t const   )941,      (flex_int16_t const   )942, 
        (flex_int16_t const   )929,      (flex_int16_t const   )942,      (flex_int16_t const   )383,      (flex_int16_t const   )381, 
        (flex_int16_t const   )947,      (flex_int16_t const   )946,      (flex_int16_t const   )940,      (flex_int16_t const   )954, 
        (flex_int16_t const   )0,      (flex_int16_t const   )951,      (flex_int16_t const   )171,      (flex_int16_t const   )941, 
        (flex_int16_t const   )0,      (flex_int16_t const   )343,      (flex_int16_t const   )0,      (flex_int16_t const   )342, 
        (flex_int16_t const   )0,      (flex_int16_t const   )955,      (flex_int16_t const   )945,      (flex_int16_t const   )0, 
        (flex_int16_t const   )956,      (flex_int16_t const   )958,      (flex_int16_t const   )952,      (flex_int16_t const   )964, 
        (flex_int16_t const   )962,      (flex_int16_t const   )976,      (flex_int16_t const   )976,      (flex_int16_t const   )976, 
        (flex_int16_t const   )977,      (flex_int16_t const   )0,      (flex_int16_t const   )967,      (flex_int16_t const   )988, 
        (flex_int16_t const   )985,      (flex_int16_t const   )968,      (flex_int16_t const   )980,      (flex_int16_t const   )982, 
        (flex_int16_t const   )979,      (flex_int16_t const   )982,      (flex_int16_t const   )983,      (flex_int16_t const   )994, 
        (flex_int16_t const   )992,      (flex_int16_t const   )998,      (flex_int16_t const   )1006,      (flex_int16_t const   )1006, 
        (flex_int16_t const   )992,      (flex_int16_t const   )1007,      (flex_int16_t const   )338,      (flex_int16_t const   )1012, 
        (flex_int16_t const   )1000,      (flex_int16_t const   )1003,      (flex_int16_t const   )1012,      (flex_int16_t const   )333, 
        (flex_int16_t const   )1010,      (flex_int16_t const   )362,      (flex_int16_t const   )341,      (flex_int16_t const   )1014, 
        (flex_int16_t const   )1011,      (flex_int16_t const   )1013,      (flex_int16_t const   )1022,      (flex_int16_t const   )297, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1012,      (flex_int16_t const   )1028, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1033,      (flex_int16_t const   )1028, 
        (flex_int16_t const   )1025,      (flex_int16_t const   )296,      (flex_int16_t const   )1032,      (flex_int16_t const   )1039, 
        (flex_int16_t const   )1038,      (flex_int16_t const   )0,      (flex_int16_t const   )1033,      (flex_int16_t const   )1039, 
        (flex_int16_t const   )1032,      (flex_int16_t const   )1039,      (flex_int16_t const   )1041,      (flex_int16_t const   )295, 
        (flex_int16_t const   )1057,      (flex_int16_t const   )1043,      (flex_int16_t const   )0,      (flex_int16_t const   )1059, 
        (flex_int16_t const   )1058,      (flex_int16_t const   )1055,      (flex_int16_t const   )1060,      (flex_int16_t const   )1059, 
        (flex_int16_t const   )1066,      (flex_int16_t const   )1071,      (flex_int16_t const   )0,      (flex_int16_t const   )1071, 
        (flex_int16_t const   )1079,      (flex_int16_t const   )1077,      (flex_int16_t const   )1067,      (flex_int16_t const   )1067, 
        (flex_int16_t const   )294,      (flex_int16_t const   )1072,      (flex_int16_t const   )292,      (flex_int16_t const   )290, 
        (flex_int16_t const   )288,      (flex_int16_t const   )286,      (flex_int16_t const   )283,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1076,      (flex_int16_t const   )282,      (flex_int16_t const   )1089, 
        (flex_int16_t const   )251,      (flex_int16_t const   )0,      (flex_int16_t const   )1080,      (flex_int16_t const   )1089, 
        (flex_int16_t const   )1081,      (flex_int16_t const   )1077,      (flex_int16_t const   )0,      (flex_int16_t const   )1103, 
        (flex_int16_t const   )1101,      (flex_int16_t const   )0,      (flex_int16_t const   )1102,      (flex_int16_t const   )1094, 
        (flex_int16_t const   )1103,      (flex_int16_t const   )1103,      (flex_int16_t const   )236,      (flex_int16_t const   )1106, 
        (flex_int16_t const   )1101,      (flex_int16_t const   )1105,      (flex_int16_t const   )234,      (flex_int16_t const   )1106, 
        (flex_int16_t const   )1112,      (flex_int16_t const   )232,      (flex_int16_t const   )1124,      (flex_int16_t const   )1123, 
        (flex_int16_t const   )1126,      (flex_int16_t const   )1122,      (flex_int16_t const   )1116,      (flex_int16_t const   )1121, 
        (flex_int16_t const   )1119,      (flex_int16_t const   )1139,      (flex_int16_t const   )249,      (flex_int16_t const   )234, 
        (flex_int16_t const   )1154,      (flex_int16_t const   )1128,      (flex_int16_t const   )1134,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1132,      (flex_int16_t const   )1147,      (flex_int16_t const   )1149, 
        (flex_int16_t const   )1143,      (flex_int16_t const   )1150,      (flex_int16_t const   )0,      (flex_int16_t const   )1157, 
        (flex_int16_t const   )1168,      (flex_int16_t const   )1169,      (flex_int16_t const   )195,      (flex_int16_t const   )1174, 
        (flex_int16_t const   )1169,      (flex_int16_t const   )1152,      (flex_int16_t const   )0,      (flex_int16_t const   )1150, 
        (flex_int16_t const   )1168,      (flex_int16_t const   )1174,      (flex_int16_t const   )1166,      (flex_int16_t const   )1174, 
        (flex_int16_t const   )1180,      (flex_int16_t const   )1172,      (flex_int16_t const   )1176,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1180,      (flex_int16_t const   )1182,      (flex_int16_t const   )1197,      (flex_int16_t const   )180, 
        (flex_int16_t const   )213,      (flex_int16_t const   )1191,      (flex_int16_t const   )1190,      (flex_int16_t const   )1194, 
        (flex_int16_t const   )1190,      (flex_int16_t const   )1207,      (flex_int16_t const   )1209,      (flex_int16_t const   )1206, 
        (flex_int16_t const   )1203,      (flex_int16_t const   )1211,      (flex_int16_t const   )0,      (flex_int16_t const   )1197, 
        (flex_int16_t const   )1219,      (flex_int16_t const   )1220,      (flex_int16_t const   )1213,      (flex_int16_t const   )1218, 
        (flex_int16_t const   )1213,      (flex_int16_t const   )1217,      (flex_int16_t const   )1215,      (flex_int16_t const   )172, 
        (flex_int16_t const   )1216,      (flex_int16_t const   )1234,      (flex_int16_t const   )171,      (flex_int16_t const   )1214, 
        (flex_int16_t const   )170,      (flex_int16_t const   )1238,      (flex_int16_t const   )1224,      (flex_int16_t const   )1220, 
        (flex_int16_t const   )1232,      (flex_int16_t const   )1240,      (flex_int16_t const   )1247,      (flex_int16_t const   )174, 
        (flex_int16_t const   )191,      (flex_int16_t const   )1240,      (flex_int16_t const   )0,      (flex_int16_t const   )1253, 
        (flex_int16_t const   )1243,      (flex_int16_t const   )1246,      (flex_int16_t const   )1251,      (flex_int16_t const   )1242, 
        (flex_int16_t const   )1254,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1263,      (flex_int16_t const   )1263,      (flex_int16_t const   )1273, 
        (flex_int16_t const   )1262,      (flex_int16_t const   )1260,      (flex_int16_t const   )1304,      (flex_int16_t const   )1276, 
        (flex_int16_t const   )1269,      (flex_int16_t const   )1307,      (flex_int16_t const   )1269,      (flex_int16_t const   )1289, 
        (flex_int16_t const   )1267,      (flex_int16_t const   )1292,      (flex_int16_t const   )0,      (flex_int16_t const   )130, 
        (flex_int16_t const   )1276,      (flex_int16_t const   )1294,      (flex_int16_t const   )148,      (flex_int16_t const   )141, 
        (flex_int16_t const   )176,      (flex_int16_t const   )1298,      (flex_int16_t const   )1299,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1300,      (flex_int16_t const   )1304,      (flex_int16_t const   )0,      (flex_int16_t const   )1304, 
        (flex_int16_t const   )1307,      (flex_int16_t const   )1310,      (flex_int16_t const   )1311,      (flex_int16_t const   )1325, 
        (flex_int16_t const   )1329,      (flex_int16_t const   )1336,      (flex_int16_t const   )1329,      (flex_int16_t const   )1322, 
        (flex_int16_t const   )1339,      (flex_int16_t const   )1333,      (flex_int16_t const   )1335,      (flex_int16_t const   )1337, 
        (flex_int16_t const   )1353,      (flex_int16_t const   )1341,      (flex_int16_t const   )1355,      (flex_int16_t const   )1346, 
        (flex_int16_t const   )1356,      (flex_int16_t const   )1345,      (flex_int16_t const   )1344,      (flex_int16_t const   )1359, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1357,      (flex_int16_t const   )1364,      (flex_int16_t const   )1355, 
        (flex_int16_t const   )118,      (flex_int16_t const   )105,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1363,      (flex_int16_t const   )0,      (flex_int16_t const   )1356,      (flex_int16_t const   )1359, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1370,      (flex_int16_t const   )1361,      (flex_int16_t const   )1363, 
        (flex_int16_t const   )1368,      (flex_int16_t const   )1369,      (flex_int16_t const   )1371,      (flex_int16_t const   )1374, 
        (flex_int16_t const   )1392,      (flex_int16_t const   )1381,      (flex_int16_t const   )1395,      (flex_int16_t const   )1394, 
        (flex_int16_t const   )1402,      (flex_int16_t const   )1403,      (flex_int16_t const   )1410,      (flex_int16_t const   )1391, 
        (flex_int16_t const   )1401,      (flex_int16_t const   )1411,      (flex_int16_t const   )1412,      (flex_int16_t const   )1409, 
        (flex_int16_t const   )1405,      (flex_int16_t const   )1422,      (flex_int16_t const   )0,      (flex_int16_t const   )1407, 
        (flex_int16_t const   )71,      (flex_int16_t const   )99,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1408,      (flex_int16_t const   )0,      (flex_int16_t const   )1423,      (flex_int16_t const   )1424, 
        (flex_int16_t const   )1415,      (flex_int16_t const   )0,      (flex_int16_t const   )1415,      (flex_int16_t const   )1429, 
        (flex_int16_t const   )1418,      (flex_int16_t const   )1430,      (flex_int16_t const   )1426,      (flex_int16_t const   )1423, 
        (flex_int16_t const   )1433,      (flex_int16_t const   )0,      (flex_int16_t const   )1431,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1431,      (flex_int16_t const   )1446,      (flex_int16_t const   )1440,      (flex_int16_t const   )1436, 
        (flex_int16_t const   )1443,      (flex_int16_t const   )1447,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1459,      (flex_int16_t const   )1450, 
        (flex_int16_t const   )1452,      (flex_int16_t const   )1457,      (flex_int16_t const   )1452,      (flex_int16_t const   )1471, 
        (flex_int16_t const   )1470,      (flex_int16_t const   )1458,      (flex_int16_t const   )1475,      (flex_int16_t const   )1480, 
        (flex_int16_t const   )1479,      (flex_int16_t const   )1479,      (flex_int16_t const   )1469,      (flex_int16_t const   )0, 
        (flex_int16_t const   )53,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1471,      (flex_int16_t const   )0,      (flex_int16_t const   )1475,      (flex_int16_t const   )1490, 
        (flex_int16_t const   )1476,      (flex_int16_t const   )1483,      (flex_int16_t const   )0,      (flex_int16_t const   )1490, 
        (flex_int16_t const   )1495,      (flex_int16_t const   )1484,      (flex_int16_t const   )1500,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1505,      (flex_int16_t const   )1492,      (flex_int16_t const   )0,      (flex_int16_t const   )1492, 
        (flex_int16_t const   )1500,      (flex_int16_t const   )1512,      (flex_int16_t const   )1513,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1516,      (flex_int16_t const   )0,      (flex_int16_t const   )1510, 
        (flex_int16_t const   )1515,      (flex_int16_t const   )0,      (flex_int16_t const   )1522,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )1513, 
        (flex_int16_t const   )1524,      (flex_int16_t const   )1513,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )1591,      (flex_int16_t const   )1582,      (flex_int16_t const   )1586,      (flex_int16_t const   )101};
#line 674 "bsdl_flex.c"
static flex_int16_t const   yy_def___0[712]  = 
#line 674
  {      (flex_int16_t const   )0,      (flex_int16_t const   )708,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )5,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )7, 
        (flex_int16_t const   )11,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )23,      (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )27,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )710,      (flex_int16_t const   )708,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )711,      (flex_int16_t const   )708,      (flex_int16_t const   )27, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )27,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )710,      (flex_int16_t const   )708, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )709, 
        (flex_int16_t const   )0,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708};
#line 757 "bsdl_flex.c"
static flex_int16_t const   yy_nxt___0[1671]  = 
#line 757
  {      (flex_int16_t const   )0,      (flex_int16_t const   )14,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )18, 
        (flex_int16_t const   )19,      (flex_int16_t const   )20,      (flex_int16_t const   )17,      (flex_int16_t const   )21, 
        (flex_int16_t const   )22,      (flex_int16_t const   )17,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )17, 
        (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )17,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )32, 
        (flex_int16_t const   )33,      (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )36,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )37,      (flex_int16_t const   )38,      (flex_int16_t const   )17,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )33, 
        (flex_int16_t const   )34,      (flex_int16_t const   )35,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )36,      (flex_int16_t const   )29,      (flex_int16_t const   )29,      (flex_int16_t const   )17, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )96,      (flex_int16_t const   )57, 
        (flex_int16_t const   )40,      (flex_int16_t const   )651,      (flex_int16_t const   )90,      (flex_int16_t const   )41, 
        (flex_int16_t const   )652,      (flex_int16_t const   )42,      (flex_int16_t const   )41,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )97, 
        (flex_int16_t const   )43,      (flex_int16_t const   )98,      (flex_int16_t const   )277,      (flex_int16_t const   )278, 
        (flex_int16_t const   )45,      (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )46, 
        (flex_int16_t const   )85,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )685, 
        (flex_int16_t const   )39,      (flex_int16_t const   )40,      (flex_int16_t const   )96,      (flex_int16_t const   )57, 
        (flex_int16_t const   )40,      (flex_int16_t const   )90,      (flex_int16_t const   )653,      (flex_int16_t const   )41, 
        (flex_int16_t const   )42,      (flex_int16_t const   )99,      (flex_int16_t const   )41,      (flex_int16_t const   )625, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )97,      (flex_int16_t const   )43, 
        (flex_int16_t const   )101,      (flex_int16_t const   )98,      (flex_int16_t const   )708,      (flex_int16_t const   )45, 
        (flex_int16_t const   )57,      (flex_int16_t const   )40,      (flex_int16_t const   )46,      (flex_int16_t const   )47, 
        (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )41, 
        (flex_int16_t const   )105,      (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )624, 
        (flex_int16_t const   )100,      (flex_int16_t const   )43,      (flex_int16_t const   )94,      (flex_int16_t const   )95, 
        (flex_int16_t const   )99,      (flex_int16_t const   )53,      (flex_int16_t const   )54,      (flex_int16_t const   )55, 
        (flex_int16_t const   )102,      (flex_int16_t const   )56,      (flex_int16_t const   )326,      (flex_int16_t const   )103, 
        (flex_int16_t const   )101,      (flex_int16_t const   )708,      (flex_int16_t const   )327,      (flex_int16_t const   )593, 
        (flex_int16_t const   )57,      (flex_int16_t const   )40,      (flex_int16_t const   )109,      (flex_int16_t const   )47, 
        (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )50,      (flex_int16_t const   )41, 
        (flex_int16_t const   )105,      (flex_int16_t const   )51,      (flex_int16_t const   )52,      (flex_int16_t const   )100, 
        (flex_int16_t const   )43,      (flex_int16_t const   )592,      (flex_int16_t const   )94,      (flex_int16_t const   )95, 
        (flex_int16_t const   )53,      (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )102, 
        (flex_int16_t const   )56,      (flex_int16_t const   )58,      (flex_int16_t const   )103,      (flex_int16_t const   )59, 
        (flex_int16_t const   )121,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )60, 
        (flex_int16_t const   )589,      (flex_int16_t const   )61,      (flex_int16_t const   )109,      (flex_int16_t const   )384, 
        (flex_int16_t const   )385,      (flex_int16_t const   )558,      (flex_int16_t const   )559,      (flex_int16_t const   )594, 
        (flex_int16_t const   )595,      (flex_int16_t const   )108,      (flex_int16_t const   )115,      (flex_int16_t const   )106, 
        (flex_int16_t const   )62,      (flex_int16_t const   )63,      (flex_int16_t const   )64,      (flex_int16_t const   )65, 
        (flex_int16_t const   )66,      (flex_int16_t const   )122,      (flex_int16_t const   )67,      (flex_int16_t const   )141, 
        (flex_int16_t const   )68,      (flex_int16_t const   )560,      (flex_int16_t const   )131,      (flex_int16_t const   )121, 
        (flex_int16_t const   )69,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )70, 
        (flex_int16_t const   )71,      (flex_int16_t const   )107,      (flex_int16_t const   )72,      (flex_int16_t const   )73, 
        (flex_int16_t const   )74,      (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )77, 
        (flex_int16_t const   )108,      (flex_int16_t const   )78,      (flex_int16_t const   )115,      (flex_int16_t const   )106, 
        (flex_int16_t const   )551,      (flex_int16_t const   )549,      (flex_int16_t const   )546,      (flex_int16_t const   )528, 
        (flex_int16_t const   )66,      (flex_int16_t const   )122,      (flex_int16_t const   )67,      (flex_int16_t const   )141, 
        (flex_int16_t const   )68,      (flex_int16_t const   )131,      (flex_int16_t const   )527,      (flex_int16_t const   )88, 
        (flex_int16_t const   )69,      (flex_int16_t const   )91,      (flex_int16_t const   )70,      (flex_int16_t const   )71, 
        (flex_int16_t const   )107,      (flex_int16_t const   )72,      (flex_int16_t const   )73,      (flex_int16_t const   )74, 
        (flex_int16_t const   )75,      (flex_int16_t const   )76,      (flex_int16_t const   )77,      (flex_int16_t const   )92, 
        (flex_int16_t const   )78,      (flex_int16_t const   )512,      (flex_int16_t const   )496,      (flex_int16_t const   )93, 
        (flex_int16_t const   )79,      (flex_int16_t const   )82,      (flex_int16_t const   )83,      (flex_int16_t const   )83, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )84, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )88,      (flex_int16_t const   )120, 
        (flex_int16_t const   )495,      (flex_int16_t const   )91,      (flex_int16_t const   )91,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )113,      (flex_int16_t const   )92,      (flex_int16_t const   )110, 
        (flex_int16_t const   )104,      (flex_int16_t const   )88,      (flex_int16_t const   )93,      (flex_int16_t const   )112, 
        (flex_int16_t const   )93,      (flex_int16_t const   )97,      (flex_int16_t const   )90,      (flex_int16_t const   )88, 
        (flex_int16_t const   )111,      (flex_int16_t const   )114,      (flex_int16_t const   )486,      (flex_int16_t const   )144, 
        (flex_int16_t const   )483,      (flex_int16_t const   )86,      (flex_int16_t const   )479,      (flex_int16_t const   )120, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )91,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85,      (flex_int16_t const   )85, 
        (flex_int16_t const   )85,      (flex_int16_t const   )113,      (flex_int16_t const   )110,      (flex_int16_t const   )104, 
        (flex_int16_t const   )88,      (flex_int16_t const   )465,      (flex_int16_t const   )112,      (flex_int16_t const   )93, 
        (flex_int16_t const   )97,      (flex_int16_t const   )90,      (flex_int16_t const   )88,      (flex_int16_t const   )111, 
        (flex_int16_t const   )114,      (flex_int16_t const   )96,      (flex_int16_t const   )144,      (flex_int16_t const   )116, 
        (flex_int16_t const   )86,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )117,      (flex_int16_t const   )148,      (flex_int16_t const   )708, 
        (flex_int16_t const   )119,      (flex_int16_t const   )93,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )444,      (flex_int16_t const   )465,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )464,      (flex_int16_t const   )96,      (flex_int16_t const   )463,      (flex_int16_t const   )116, 
        (flex_int16_t const   )462,      (flex_int16_t const   )88,      (flex_int16_t const   )461,      (flex_int16_t const   )126, 
        (flex_int16_t const   )459,      (flex_int16_t const   )444,      (flex_int16_t const   )435,      (flex_int16_t const   )429, 
        (flex_int16_t const   )117,      (flex_int16_t const   )148,      (flex_int16_t const   )708,      (flex_int16_t const   )119, 
        (flex_int16_t const   )93,      (flex_int16_t const   )424,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )88,      (flex_int16_t const   )86,      (flex_int16_t const   )126,      (flex_int16_t const   )94, 
        (flex_int16_t const   )95,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )423, 
        (flex_int16_t const   )118,      (flex_int16_t const   )112,      (flex_int16_t const   )88,      (flex_int16_t const   )421, 
        (flex_int16_t const   )90,      (flex_int16_t const   )150,      (flex_int16_t const   )127,      (flex_int16_t const   )89, 
        (flex_int16_t const   )416,      (flex_int16_t const   )134,      (flex_int16_t const   )128,      (flex_int16_t const   )135, 
        (flex_int16_t const   )361,      (flex_int16_t const   )387,      (flex_int16_t const   )378,      (flex_int16_t const   )147, 
        (flex_int16_t const   )86,      (flex_int16_t const   )377,      (flex_int16_t const   )361,      (flex_int16_t const   )94, 
        (flex_int16_t const   )95,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87, 
        (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )87,      (flex_int16_t const   )118, 
        (flex_int16_t const   )112,      (flex_int16_t const   )88,      (flex_int16_t const   )116,      (flex_int16_t const   )90, 
        (flex_int16_t const   )150,      (flex_int16_t const   )127,      (flex_int16_t const   )89,      (flex_int16_t const   )149, 
        (flex_int16_t const   )134,      (flex_int16_t const   )128,      (flex_int16_t const   )135,      (flex_int16_t const   )129, 
        (flex_int16_t const   )130,      (flex_int16_t const   )132,      (flex_int16_t const   )137,      (flex_int16_t const   )147, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )120, 
        (flex_int16_t const   )98,      (flex_int16_t const   )133,      (flex_int16_t const   )152,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )345,      (flex_int16_t const   )136,      (flex_int16_t const   )140, 
        (flex_int16_t const   )151,      (flex_int16_t const   )119,      (flex_int16_t const   )116,      (flex_int16_t const   )121, 
        (flex_int16_t const   )145,      (flex_int16_t const   )146,      (flex_int16_t const   )153,      (flex_int16_t const   )149, 
        (flex_int16_t const   )154,      (flex_int16_t const   )97,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )295,      (flex_int16_t const   )132,      (flex_int16_t const   )137,      (flex_int16_t const   )93, 
        (flex_int16_t const   )266,      (flex_int16_t const   )94,      (flex_int16_t const   )95,      (flex_int16_t const   )120, 
        (flex_int16_t const   )98,      (flex_int16_t const   )133,      (flex_int16_t const   )152,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )136,      (flex_int16_t const   )140,      (flex_int16_t const   )151, 
        (flex_int16_t const   )119,      (flex_int16_t const   )155,      (flex_int16_t const   )121,      (flex_int16_t const   )145, 
        (flex_int16_t const   )146,      (flex_int16_t const   )156,      (flex_int16_t const   )153,      (flex_int16_t const   )154, 
        (flex_int16_t const   )97,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )157, 
        (flex_int16_t const   )145,      (flex_int16_t const   )158,      (flex_int16_t const   )161,      (flex_int16_t const   )208, 
        (flex_int16_t const   )159,      (flex_int16_t const   )207,      (flex_int16_t const   )148,      (flex_int16_t const   )160, 
        (flex_int16_t const   )162,      (flex_int16_t const   )155,      (flex_int16_t const   )163,      (flex_int16_t const   )164, 
        (flex_int16_t const   )165,      (flex_int16_t const   )156,      (flex_int16_t const   )166,      (flex_int16_t const   )167, 
        (flex_int16_t const   )168,      (flex_int16_t const   )205,      (flex_int16_t const   )88,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )203, 
        (flex_int16_t const   )169,      (flex_int16_t const   )80,      (flex_int16_t const   )157,      (flex_int16_t const   )145, 
        (flex_int16_t const   )158,      (flex_int16_t const   )175,      (flex_int16_t const   )161,      (flex_int16_t const   )159, 
        (flex_int16_t const   )100,      (flex_int16_t const   )148,      (flex_int16_t const   )160,      (flex_int16_t const   )162, 
        (flex_int16_t const   )176,      (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )177, 
        (flex_int16_t const   )165,      (flex_int16_t const   )166,      (flex_int16_t const   )167,      (flex_int16_t const   )178, 
        (flex_int16_t const   )168,      (flex_int16_t const   )88,      (flex_int16_t const   )170,      (flex_int16_t const   )179, 
        (flex_int16_t const   )171,      (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )169, 
        (flex_int16_t const   )148,      (flex_int16_t const   )173,      (flex_int16_t const   )180,      (flex_int16_t const   )181, 
        (flex_int16_t const   )175,      (flex_int16_t const   )182,      (flex_int16_t const   )184,      (flex_int16_t const   )100, 
        (flex_int16_t const   )183,      (flex_int16_t const   )125,      (flex_int16_t const   )185,      (flex_int16_t const   )176, 
        (flex_int16_t const   )186,      (flex_int16_t const   )170,      (flex_int16_t const   )187,      (flex_int16_t const   )177, 
        (flex_int16_t const   )188,      (flex_int16_t const   )148,      (flex_int16_t const   )173,      (flex_int16_t const   )178, 
        (flex_int16_t const   )193,      (flex_int16_t const   )196,      (flex_int16_t const   )179,      (flex_int16_t const   )194, 
        (flex_int16_t const   )189,      (flex_int16_t const   )191,      (flex_int16_t const   )124,      (flex_int16_t const   )148, 
        (flex_int16_t const   )173,      (flex_int16_t const   )152,      (flex_int16_t const   )180,      (flex_int16_t const   )181, 
        (flex_int16_t const   )182,      (flex_int16_t const   )184,      (flex_int16_t const   )190,      (flex_int16_t const   )195, 
        (flex_int16_t const   )183,      (flex_int16_t const   )185,      (flex_int16_t const   )192,      (flex_int16_t const   )186, 
        (flex_int16_t const   )170,      (flex_int16_t const   )187,      (flex_int16_t const   )123,      (flex_int16_t const   )188, 
        (flex_int16_t const   )148,      (flex_int16_t const   )173,      (flex_int16_t const   )81,      (flex_int16_t const   )198, 
        (flex_int16_t const   )193,      (flex_int16_t const   )196,      (flex_int16_t const   )194,      (flex_int16_t const   )199, 
        (flex_int16_t const   )189,      (flex_int16_t const   )191,      (flex_int16_t const   )200,      (flex_int16_t const   )201, 
        (flex_int16_t const   )206,      (flex_int16_t const   )152,      (flex_int16_t const   )202,      (flex_int16_t const   )204, 
        (flex_int16_t const   )209,      (flex_int16_t const   )190,      (flex_int16_t const   )195,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )192,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )198,      (flex_int16_t const   )200, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )199,      (flex_int16_t const   )214, 
        (flex_int16_t const   )216,      (flex_int16_t const   )200,      (flex_int16_t const   )201,      (flex_int16_t const   )197, 
        (flex_int16_t const   )206,      (flex_int16_t const   )202,      (flex_int16_t const   )204,      (flex_int16_t const   )209, 
        (flex_int16_t const   )215,      (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )210, 
        (flex_int16_t const   )211,      (flex_int16_t const   )219,      (flex_int16_t const   )220,      (flex_int16_t const   )221, 
        (flex_int16_t const   )81,      (flex_int16_t const   )222,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )227,      (flex_int16_t const   )200,      (flex_int16_t const   )212, 
        (flex_int16_t const   )213,      (flex_int16_t const   )226,      (flex_int16_t const   )228,      (flex_int16_t const   )214, 
        (flex_int16_t const   )216,      (flex_int16_t const   )229,      (flex_int16_t const   )232,      (flex_int16_t const   )197, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )233,      (flex_int16_t const   )215, 
        (flex_int16_t const   )217,      (flex_int16_t const   )218,      (flex_int16_t const   )234,      (flex_int16_t const   )235, 
        (flex_int16_t const   )219,      (flex_int16_t const   )220,      (flex_int16_t const   )236,      (flex_int16_t const   )221, 
        (flex_int16_t const   )222,      (flex_int16_t const   )237,      (flex_int16_t const   )223,      (flex_int16_t const   )224, 
        (flex_int16_t const   )225,      (flex_int16_t const   )227,      (flex_int16_t const   )238,      (flex_int16_t const   )242, 
        (flex_int16_t const   )226,      (flex_int16_t const   )228,      (flex_int16_t const   )239,      (flex_int16_t const   )240, 
        (flex_int16_t const   )241,      (flex_int16_t const   )229,      (flex_int16_t const   )232,      (flex_int16_t const   )230, 
        (flex_int16_t const   )231,      (flex_int16_t const   )243,      (flex_int16_t const   )233,      (flex_int16_t const   )244, 
        (flex_int16_t const   )245,      (flex_int16_t const   )234,      (flex_int16_t const   )235,      (flex_int16_t const   )246, 
        (flex_int16_t const   )249,      (flex_int16_t const   )236,      (flex_int16_t const   )80,      (flex_int16_t const   )708, 
        (flex_int16_t const   )237,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )253,      (flex_int16_t const   )238,      (flex_int16_t const   )242, 
        (flex_int16_t const   )252,      (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )241, 
        (flex_int16_t const   )250,      (flex_int16_t const   )254,      (flex_int16_t const   )264,      (flex_int16_t const   )251, 
        (flex_int16_t const   )243,      (flex_int16_t const   )708,      (flex_int16_t const   )244,      (flex_int16_t const   )245, 
        (flex_int16_t const   )265,      (flex_int16_t const   )247,      (flex_int16_t const   )246,      (flex_int16_t const   )247, 
        (flex_int16_t const   )249,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )253,      (flex_int16_t const   )263,      (flex_int16_t const   )252, 
        (flex_int16_t const   )267,      (flex_int16_t const   )268,      (flex_int16_t const   )274,      (flex_int16_t const   )250, 
        (flex_int16_t const   )254,      (flex_int16_t const   )264,      (flex_int16_t const   )251,      (flex_int16_t const   )255, 
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )265, 
        (flex_int16_t const   )259,      (flex_int16_t const   )708,      (flex_int16_t const   )269,      (flex_int16_t const   )260, 
        (flex_int16_t const   )708,      (flex_int16_t const   )270,      (flex_int16_t const   )271,      (flex_int16_t const   )272, 
        (flex_int16_t const   )273,      (flex_int16_t const   )275,      (flex_int16_t const   )261,      (flex_int16_t const   )276, 
        (flex_int16_t const   )262,      (flex_int16_t const   )281,      (flex_int16_t const   )263,      (flex_int16_t const   )267, 
        (flex_int16_t const   )282,      (flex_int16_t const   )268,      (flex_int16_t const   )274,      (flex_int16_t const   )283, 
        (flex_int16_t const   )284,      (flex_int16_t const   )708,      (flex_int16_t const   )285,      (flex_int16_t const   )255, 
        (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )258,      (flex_int16_t const   )286, 
        (flex_int16_t const   )259,      (flex_int16_t const   )269,      (flex_int16_t const   )287,      (flex_int16_t const   )260, 
        (flex_int16_t const   )270,      (flex_int16_t const   )271,      (flex_int16_t const   )272,      (flex_int16_t const   )273, 
        (flex_int16_t const   )275,      (flex_int16_t const   )261,      (flex_int16_t const   )276,      (flex_int16_t const   )262, 
        (flex_int16_t const   )288,      (flex_int16_t const   )281,      (flex_int16_t const   )289,      (flex_int16_t const   )282, 
        (flex_int16_t const   )290,      (flex_int16_t const   )292,      (flex_int16_t const   )283,      (flex_int16_t const   )291, 
        (flex_int16_t const   )284,      (flex_int16_t const   )285,      (flex_int16_t const   )293,      (flex_int16_t const   )294, 
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )286,      (flex_int16_t const   )298, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )287,      (flex_int16_t const   )301, 
        (flex_int16_t const   )302,      (flex_int16_t const   )708,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )708,      (flex_int16_t const   )305,      (flex_int16_t const   )708,      (flex_int16_t const   )288, 
        (flex_int16_t const   )708,      (flex_int16_t const   )289,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )290,      (flex_int16_t const   )292,      (flex_int16_t const   )291,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )293,      (flex_int16_t const   )294,      (flex_int16_t const   )708, 
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )298,      (flex_int16_t const   )299, 
        (flex_int16_t const   )300,      (flex_int16_t const   )306,      (flex_int16_t const   )301,      (flex_int16_t const   )307, 
        (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )308,      (flex_int16_t const   )304, 
        (flex_int16_t const   )305,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )708, 
        (flex_int16_t const   )311,      (flex_int16_t const   )306,      (flex_int16_t const   )312,      (flex_int16_t const   )307, 
        (flex_int16_t const   )313,      (flex_int16_t const   )308,      (flex_int16_t const   )314,      (flex_int16_t const   )315, 
        (flex_int16_t const   )316,      (flex_int16_t const   )708,      (flex_int16_t const   )318,      (flex_int16_t const   )317, 
        (flex_int16_t const   )319,      (flex_int16_t const   )323,      (flex_int16_t const   )321,      (flex_int16_t const   )324, 
        (flex_int16_t const   )708,      (flex_int16_t const   )325,      (flex_int16_t const   )328,      (flex_int16_t const   )708, 
        (flex_int16_t const   )320,      (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331, 
        (flex_int16_t const   )332,      (flex_int16_t const   )309,      (flex_int16_t const   )310,      (flex_int16_t const   )311, 
        (flex_int16_t const   )322,      (flex_int16_t const   )333,      (flex_int16_t const   )312,      (flex_int16_t const   )313, 
        (flex_int16_t const   )334,      (flex_int16_t const   )314,      (flex_int16_t const   )335,      (flex_int16_t const   )315, 
        (flex_int16_t const   )316,      (flex_int16_t const   )318,      (flex_int16_t const   )317,      (flex_int16_t const   )336, 
        (flex_int16_t const   )319,      (flex_int16_t const   )323,      (flex_int16_t const   )321,      (flex_int16_t const   )324, 
        (flex_int16_t const   )325,      (flex_int16_t const   )337,      (flex_int16_t const   )328,      (flex_int16_t const   )320, 
        (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )331,      (flex_int16_t const   )332, 
        (flex_int16_t const   )338,      (flex_int16_t const   )339,      (flex_int16_t const   )341,      (flex_int16_t const   )322, 
        (flex_int16_t const   )333,      (flex_int16_t const   )340,      (flex_int16_t const   )342,      (flex_int16_t const   )334, 
        (flex_int16_t const   )343,      (flex_int16_t const   )348,      (flex_int16_t const   )335,      (flex_int16_t const   )344, 
        (flex_int16_t const   )346,      (flex_int16_t const   )347,      (flex_int16_t const   )336,      (flex_int16_t const   )349, 
        (flex_int16_t const   )350,      (flex_int16_t const   )351,      (flex_int16_t const   )708,      (flex_int16_t const   )352, 
        (flex_int16_t const   )353,      (flex_int16_t const   )337,      (flex_int16_t const   )354,      (flex_int16_t const   )708, 
        (flex_int16_t const   )355,      (flex_int16_t const   )356,      (flex_int16_t const   )358,      (flex_int16_t const   )338, 
        (flex_int16_t const   )357,      (flex_int16_t const   )339,      (flex_int16_t const   )341,      (flex_int16_t const   )359, 
        (flex_int16_t const   )340,      (flex_int16_t const   )342,      (flex_int16_t const   )360,      (flex_int16_t const   )362, 
        (flex_int16_t const   )343,      (flex_int16_t const   )348,      (flex_int16_t const   )344,      (flex_int16_t const   )346, 
        (flex_int16_t const   )347,      (flex_int16_t const   )363,      (flex_int16_t const   )349,      (flex_int16_t const   )364, 
        (flex_int16_t const   )350,      (flex_int16_t const   )351,      (flex_int16_t const   )352,      (flex_int16_t const   )353, 
        (flex_int16_t const   )365,      (flex_int16_t const   )366,      (flex_int16_t const   )354,      (flex_int16_t const   )355, 
        (flex_int16_t const   )367,      (flex_int16_t const   )356,      (flex_int16_t const   )358,      (flex_int16_t const   )357, 
        (flex_int16_t const   )368,      (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )359, 
        (flex_int16_t const   )371,      (flex_int16_t const   )360,      (flex_int16_t const   )372,      (flex_int16_t const   )362, 
        (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )708,      (flex_int16_t const   )375, 
        (flex_int16_t const   )363,      (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )364, 
        (flex_int16_t const   )380,      (flex_int16_t const   )708,      (flex_int16_t const   )381,      (flex_int16_t const   )365, 
        (flex_int16_t const   )366,      (flex_int16_t const   )382,      (flex_int16_t const   )383,      (flex_int16_t const   )367, 
        (flex_int16_t const   )386,      (flex_int16_t const   )388,      (flex_int16_t const   )390,      (flex_int16_t const   )368, 
        (flex_int16_t const   )369,      (flex_int16_t const   )370,      (flex_int16_t const   )389,      (flex_int16_t const   )371, 
        (flex_int16_t const   )393,      (flex_int16_t const   )391,      (flex_int16_t const   )372,      (flex_int16_t const   )394, 
        (flex_int16_t const   )373,      (flex_int16_t const   )374,      (flex_int16_t const   )375,      (flex_int16_t const   )392, 
        (flex_int16_t const   )395,      (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )396, 
        (flex_int16_t const   )380,      (flex_int16_t const   )381,      (flex_int16_t const   )397,      (flex_int16_t const   )398, 
        (flex_int16_t const   )399,      (flex_int16_t const   )382,      (flex_int16_t const   )383,      (flex_int16_t const   )386, 
        (flex_int16_t const   )400,      (flex_int16_t const   )388,      (flex_int16_t const   )390,      (flex_int16_t const   )401, 
        (flex_int16_t const   )402,      (flex_int16_t const   )389,      (flex_int16_t const   )403,      (flex_int16_t const   )393, 
        (flex_int16_t const   )404,      (flex_int16_t const   )391,      (flex_int16_t const   )405,      (flex_int16_t const   )394, 
        (flex_int16_t const   )406,      (flex_int16_t const   )407,      (flex_int16_t const   )392,      (flex_int16_t const   )395, 
        (flex_int16_t const   )408,      (flex_int16_t const   )409,      (flex_int16_t const   )411,      (flex_int16_t const   )396, 
        (flex_int16_t const   )410,      (flex_int16_t const   )412,      (flex_int16_t const   )397,      (flex_int16_t const   )398, 
        (flex_int16_t const   )399,      (flex_int16_t const   )413,      (flex_int16_t const   )415,      (flex_int16_t const   )400, 
        (flex_int16_t const   )414,      (flex_int16_t const   )417,      (flex_int16_t const   )426,      (flex_int16_t const   )401, 
        (flex_int16_t const   )402,      (flex_int16_t const   )403,      (flex_int16_t const   )418,      (flex_int16_t const   )404, 
        (flex_int16_t const   )419,      (flex_int16_t const   )405,      (flex_int16_t const   )420,      (flex_int16_t const   )406, 
        (flex_int16_t const   )407,      (flex_int16_t const   )422,      (flex_int16_t const   )425,      (flex_int16_t const   )408, 
        (flex_int16_t const   )427,      (flex_int16_t const   )409,      (flex_int16_t const   )411,      (flex_int16_t const   )410, 
        (flex_int16_t const   )428,      (flex_int16_t const   )412,      (flex_int16_t const   )430,      (flex_int16_t const   )431, 
        (flex_int16_t const   )432,      (flex_int16_t const   )413,      (flex_int16_t const   )415,      (flex_int16_t const   )414, 
        (flex_int16_t const   )433,      (flex_int16_t const   )417,      (flex_int16_t const   )426,      (flex_int16_t const   )434, 
        (flex_int16_t const   )436,      (flex_int16_t const   )418,      (flex_int16_t const   )437,      (flex_int16_t const   )419, 
        (flex_int16_t const   )438,      (flex_int16_t const   )420,      (flex_int16_t const   )439,      (flex_int16_t const   )440, 
        (flex_int16_t const   )422,      (flex_int16_t const   )425,      (flex_int16_t const   )441,      (flex_int16_t const   )427, 
        (flex_int16_t const   )442,      (flex_int16_t const   )443,      (flex_int16_t const   )445,      (flex_int16_t const   )428, 
        (flex_int16_t const   )446,      (flex_int16_t const   )430,      (flex_int16_t const   )447,      (flex_int16_t const   )431, 
        (flex_int16_t const   )432,      (flex_int16_t const   )448,      (flex_int16_t const   )452,      (flex_int16_t const   )433, 
        (flex_int16_t const   )449,      (flex_int16_t const   )450,      (flex_int16_t const   )434,      (flex_int16_t const   )436, 
        (flex_int16_t const   )451,      (flex_int16_t const   )453,      (flex_int16_t const   )437,      (flex_int16_t const   )438, 
        (flex_int16_t const   )454,      (flex_int16_t const   )439,      (flex_int16_t const   )440,      (flex_int16_t const   )455, 
        (flex_int16_t const   )456,      (flex_int16_t const   )441,      (flex_int16_t const   )457,      (flex_int16_t const   )442, 
        (flex_int16_t const   )443,      (flex_int16_t const   )458,      (flex_int16_t const   )445,      (flex_int16_t const   )446, 
        (flex_int16_t const   )460,      (flex_int16_t const   )466,      (flex_int16_t const   )447,      (flex_int16_t const   )467, 
        (flex_int16_t const   )469,      (flex_int16_t const   )448,      (flex_int16_t const   )452,      (flex_int16_t const   )449, 
        (flex_int16_t const   )450,      (flex_int16_t const   )468,      (flex_int16_t const   )470,      (flex_int16_t const   )451, 
        (flex_int16_t const   )471,      (flex_int16_t const   )453,      (flex_int16_t const   )472,      (flex_int16_t const   )473, 
        (flex_int16_t const   )454,      (flex_int16_t const   )474,      (flex_int16_t const   )478,      (flex_int16_t const   )455, 
        (flex_int16_t const   )456,      (flex_int16_t const   )457,      (flex_int16_t const   )475,      (flex_int16_t const   )480, 
        (flex_int16_t const   )458,      (flex_int16_t const   )476,      (flex_int16_t const   )481,      (flex_int16_t const   )460, 
        (flex_int16_t const   )466,      (flex_int16_t const   )482,      (flex_int16_t const   )477,      (flex_int16_t const   )467, 
        (flex_int16_t const   )469,      (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )487, 
        (flex_int16_t const   )468,      (flex_int16_t const   )470,      (flex_int16_t const   )488,      (flex_int16_t const   )471, 
        (flex_int16_t const   )489,      (flex_int16_t const   )490,      (flex_int16_t const   )472,      (flex_int16_t const   )473, 
        (flex_int16_t const   )491,      (flex_int16_t const   )474,      (flex_int16_t const   )478,      (flex_int16_t const   )492, 
        (flex_int16_t const   )493,      (flex_int16_t const   )475,      (flex_int16_t const   )494,      (flex_int16_t const   )480, 
        (flex_int16_t const   )476,      (flex_int16_t const   )481,      (flex_int16_t const   )708,      (flex_int16_t const   )502, 
        (flex_int16_t const   )482,      (flex_int16_t const   )477,      (flex_int16_t const   )503,      (flex_int16_t const   )504, 
        (flex_int16_t const   )484,      (flex_int16_t const   )485,      (flex_int16_t const   )505,      (flex_int16_t const   )487, 
        (flex_int16_t const   )506,      (flex_int16_t const   )508,      (flex_int16_t const   )488,      (flex_int16_t const   )497, 
        (flex_int16_t const   )489,      (flex_int16_t const   )490,      (flex_int16_t const   )507,      (flex_int16_t const   )491, 
        (flex_int16_t const   )509,      (flex_int16_t const   )498,      (flex_int16_t const   )492,      (flex_int16_t const   )493, 
        (flex_int16_t const   )515,      (flex_int16_t const   )499,      (flex_int16_t const   )494,      (flex_int16_t const   )500, 
        (flex_int16_t const   )516,      (flex_int16_t const   )501,      (flex_int16_t const   )502,      (flex_int16_t const   )510, 
        (flex_int16_t const   )511,      (flex_int16_t const   )503,      (flex_int16_t const   )504,      (flex_int16_t const   )513, 
        (flex_int16_t const   )514,      (flex_int16_t const   )518,      (flex_int16_t const   )505,      (flex_int16_t const   )517, 
        (flex_int16_t const   )506,      (flex_int16_t const   )508,      (flex_int16_t const   )519,      (flex_int16_t const   )497, 
        (flex_int16_t const   )520,      (flex_int16_t const   )507,      (flex_int16_t const   )521,      (flex_int16_t const   )524, 
        (flex_int16_t const   )509,      (flex_int16_t const   )498,      (flex_int16_t const   )522,      (flex_int16_t const   )515, 
        (flex_int16_t const   )499,      (flex_int16_t const   )523,      (flex_int16_t const   )500,      (flex_int16_t const   )516, 
        (flex_int16_t const   )501,      (flex_int16_t const   )525,      (flex_int16_t const   )526,      (flex_int16_t const   )510, 
        (flex_int16_t const   )511,      (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )513, 
        (flex_int16_t const   )514,      (flex_int16_t const   )518,      (flex_int16_t const   )517,      (flex_int16_t const   )531, 
        (flex_int16_t const   )532,      (flex_int16_t const   )519,      (flex_int16_t const   )533,      (flex_int16_t const   )520, 
        (flex_int16_t const   )534,      (flex_int16_t const   )537,      (flex_int16_t const   )521,      (flex_int16_t const   )524, 
        (flex_int16_t const   )535,      (flex_int16_t const   )522,      (flex_int16_t const   )536,      (flex_int16_t const   )538, 
        (flex_int16_t const   )523,      (flex_int16_t const   )539,      (flex_int16_t const   )540,      (flex_int16_t const   )542, 
        (flex_int16_t const   )525,      (flex_int16_t const   )541,      (flex_int16_t const   )526,      (flex_int16_t const   )543, 
        (flex_int16_t const   )529,      (flex_int16_t const   )530,      (flex_int16_t const   )544,      (flex_int16_t const   )545, 
        (flex_int16_t const   )547,      (flex_int16_t const   )548,      (flex_int16_t const   )531,      (flex_int16_t const   )532, 
        (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )533,      (flex_int16_t const   )553, 
        (flex_int16_t const   )534,      (flex_int16_t const   )537,      (flex_int16_t const   )554,      (flex_int16_t const   )535, 
        (flex_int16_t const   )555,      (flex_int16_t const   )536,      (flex_int16_t const   )538,      (flex_int16_t const   )556, 
        (flex_int16_t const   )557,      (flex_int16_t const   )539,      (flex_int16_t const   )540,      (flex_int16_t const   )542, 
        (flex_int16_t const   )541,      (flex_int16_t const   )561,      (flex_int16_t const   )543,      (flex_int16_t const   )562, 
        (flex_int16_t const   )565,      (flex_int16_t const   )544,      (flex_int16_t const   )545,      (flex_int16_t const   )547, 
        (flex_int16_t const   )563,      (flex_int16_t const   )548,      (flex_int16_t const   )564,      (flex_int16_t const   )550, 
        (flex_int16_t const   )566,      (flex_int16_t const   )552,      (flex_int16_t const   )553,      (flex_int16_t const   )567, 
        (flex_int16_t const   )568,      (flex_int16_t const   )554,      (flex_int16_t const   )569,      (flex_int16_t const   )555, 
        (flex_int16_t const   )570,      (flex_int16_t const   )708,      (flex_int16_t const   )571,      (flex_int16_t const   )556, 
        (flex_int16_t const   )557,      (flex_int16_t const   )572,      (flex_int16_t const   )708,      (flex_int16_t const   )579, 
        (flex_int16_t const   )561,      (flex_int16_t const   )580,      (flex_int16_t const   )708,      (flex_int16_t const   )562, 
        (flex_int16_t const   )565,      (flex_int16_t const   )585,      (flex_int16_t const   )587,      (flex_int16_t const   )563, 
        (flex_int16_t const   )590,      (flex_int16_t const   )564,      (flex_int16_t const   )708,      (flex_int16_t const   )566, 
        (flex_int16_t const   )586,      (flex_int16_t const   )708,      (flex_int16_t const   )567,      (flex_int16_t const   )588, 
        (flex_int16_t const   )568,      (flex_int16_t const   )591,      (flex_int16_t const   )569,      (flex_int16_t const   )596, 
        (flex_int16_t const   )570,      (flex_int16_t const   )571,      (flex_int16_t const   )597,      (flex_int16_t const   )598, 
        (flex_int16_t const   )572,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )579, 
        (flex_int16_t const   )580,      (flex_int16_t const   )575,      (flex_int16_t const   )581,      (flex_int16_t const   )599, 
        (flex_int16_t const   )585,      (flex_int16_t const   )587,      (flex_int16_t const   )576,      (flex_int16_t const   )590, 
        (flex_int16_t const   )582,      (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )600, 
        (flex_int16_t const   )586,      (flex_int16_t const   )583,      (flex_int16_t const   )584,      (flex_int16_t const   )588, 
        (flex_int16_t const   )601,      (flex_int16_t const   )591,      (flex_int16_t const   )602,      (flex_int16_t const   )596, 
        (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )597,      (flex_int16_t const   )598, 
        (flex_int16_t const   )605,      (flex_int16_t const   )573,      (flex_int16_t const   )574,      (flex_int16_t const   )606, 
        (flex_int16_t const   )607,      (flex_int16_t const   )575,      (flex_int16_t const   )581,      (flex_int16_t const   )599, 
        (flex_int16_t const   )608,      (flex_int16_t const   )576,      (flex_int16_t const   )609,      (flex_int16_t const   )582, 
        (flex_int16_t const   )577,      (flex_int16_t const   )578,      (flex_int16_t const   )600,      (flex_int16_t const   )610, 
        (flex_int16_t const   )583,      (flex_int16_t const   )584,      (flex_int16_t const   )611,      (flex_int16_t const   )601, 
        (flex_int16_t const   )612,      (flex_int16_t const   )602,      (flex_int16_t const   )613,      (flex_int16_t const   )603, 
        (flex_int16_t const   )614,      (flex_int16_t const   )604,      (flex_int16_t const   )615,      (flex_int16_t const   )617, 
        (flex_int16_t const   )605,      (flex_int16_t const   )616,      (flex_int16_t const   )618,      (flex_int16_t const   )606, 
        (flex_int16_t const   )607,      (flex_int16_t const   )619,      (flex_int16_t const   )620,      (flex_int16_t const   )608, 
        (flex_int16_t const   )621,      (flex_int16_t const   )622,      (flex_int16_t const   )609,      (flex_int16_t const   )623, 
        (flex_int16_t const   )626,      (flex_int16_t const   )627,      (flex_int16_t const   )610,      (flex_int16_t const   )628, 
        (flex_int16_t const   )629,      (flex_int16_t const   )611,      (flex_int16_t const   )630,      (flex_int16_t const   )612, 
        (flex_int16_t const   )631,      (flex_int16_t const   )632,      (flex_int16_t const   )613,      (flex_int16_t const   )614, 
        (flex_int16_t const   )633,      (flex_int16_t const   )634,      (flex_int16_t const   )615,      (flex_int16_t const   )617, 
        (flex_int16_t const   )616,      (flex_int16_t const   )618,      (flex_int16_t const   )635,      (flex_int16_t const   )636, 
        (flex_int16_t const   )619,      (flex_int16_t const   )637,      (flex_int16_t const   )620,      (flex_int16_t const   )621, 
        (flex_int16_t const   )638,      (flex_int16_t const   )622,      (flex_int16_t const   )623,      (flex_int16_t const   )626, 
        (flex_int16_t const   )627,      (flex_int16_t const   )639,      (flex_int16_t const   )628,      (flex_int16_t const   )640, 
        (flex_int16_t const   )629,      (flex_int16_t const   )630,      (flex_int16_t const   )641,      (flex_int16_t const   )631, 
        (flex_int16_t const   )632,      (flex_int16_t const   )642,      (flex_int16_t const   )645,      (flex_int16_t const   )633, 
        (flex_int16_t const   )634,      (flex_int16_t const   )643,      (flex_int16_t const   )644,      (flex_int16_t const   )646, 
        (flex_int16_t const   )647,      (flex_int16_t const   )635,      (flex_int16_t const   )648,      (flex_int16_t const   )636, 
        (flex_int16_t const   )637,      (flex_int16_t const   )649,      (flex_int16_t const   )708,      (flex_int16_t const   )650, 
        (flex_int16_t const   )638,      (flex_int16_t const   )654,      (flex_int16_t const   )655,      (flex_int16_t const   )656, 
        (flex_int16_t const   )659,      (flex_int16_t const   )639,      (flex_int16_t const   )657,      (flex_int16_t const   )640, 
        (flex_int16_t const   )658,      (flex_int16_t const   )660,      (flex_int16_t const   )641,      (flex_int16_t const   )661, 
        (flex_int16_t const   )666,      (flex_int16_t const   )642,      (flex_int16_t const   )645,      (flex_int16_t const   )662, 
        (flex_int16_t const   )643,      (flex_int16_t const   )644,      (flex_int16_t const   )663,      (flex_int16_t const   )646, 
        (flex_int16_t const   )647,      (flex_int16_t const   )648,      (flex_int16_t const   )664,      (flex_int16_t const   )665, 
        (flex_int16_t const   )667,      (flex_int16_t const   )649,      (flex_int16_t const   )650,      (flex_int16_t const   )668, 
        (flex_int16_t const   )654,      (flex_int16_t const   )669,      (flex_int16_t const   )655,      (flex_int16_t const   )656, 
        (flex_int16_t const   )659,      (flex_int16_t const   )657,      (flex_int16_t const   )670,      (flex_int16_t const   )658, 
        (flex_int16_t const   )660,      (flex_int16_t const   )671,      (flex_int16_t const   )672,      (flex_int16_t const   )661, 
        (flex_int16_t const   )666,      (flex_int16_t const   )673,      (flex_int16_t const   )662,      (flex_int16_t const   )674, 
        (flex_int16_t const   )675,      (flex_int16_t const   )663,      (flex_int16_t const   )676,      (flex_int16_t const   )677, 
        (flex_int16_t const   )678,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )679, 
        (flex_int16_t const   )667,      (flex_int16_t const   )680,      (flex_int16_t const   )668,      (flex_int16_t const   )681, 
        (flex_int16_t const   )669,      (flex_int16_t const   )682,      (flex_int16_t const   )683,      (flex_int16_t const   )708, 
        (flex_int16_t const   )684,      (flex_int16_t const   )670,      (flex_int16_t const   )686,      (flex_int16_t const   )687, 
        (flex_int16_t const   )671,      (flex_int16_t const   )688,      (flex_int16_t const   )672,      (flex_int16_t const   )689, 
        (flex_int16_t const   )673,      (flex_int16_t const   )690,      (flex_int16_t const   )674,      (flex_int16_t const   )675, 
        (flex_int16_t const   )691,      (flex_int16_t const   )676,      (flex_int16_t const   )692,      (flex_int16_t const   )677, 
        (flex_int16_t const   )678,      (flex_int16_t const   )693,      (flex_int16_t const   )679,      (flex_int16_t const   )694, 
        (flex_int16_t const   )695,      (flex_int16_t const   )680,      (flex_int16_t const   )696,      (flex_int16_t const   )681, 
        (flex_int16_t const   )697,      (flex_int16_t const   )682,      (flex_int16_t const   )683,      (flex_int16_t const   )684, 
        (flex_int16_t const   )698,      (flex_int16_t const   )686,      (flex_int16_t const   )687,      (flex_int16_t const   )699, 
        (flex_int16_t const   )700,      (flex_int16_t const   )688,      (flex_int16_t const   )689,      (flex_int16_t const   )701, 
        (flex_int16_t const   )690,      (flex_int16_t const   )702,      (flex_int16_t const   )703,      (flex_int16_t const   )704, 
        (flex_int16_t const   )691,      (flex_int16_t const   )705,      (flex_int16_t const   )692,      (flex_int16_t const   )706, 
        (flex_int16_t const   )693,      (flex_int16_t const   )707,      (flex_int16_t const   )708,      (flex_int16_t const   )694, 
        (flex_int16_t const   )695,      (flex_int16_t const   )696,      (flex_int16_t const   )708,      (flex_int16_t const   )697, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )698, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )699, 
        (flex_int16_t const   )700,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )701, 
        (flex_int16_t const   )702,      (flex_int16_t const   )708,      (flex_int16_t const   )703,      (flex_int16_t const   )704, 
        (flex_int16_t const   )705,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )706, 
        (flex_int16_t const   )707,      (flex_int16_t const   )88,      (flex_int16_t const   )88,      (flex_int16_t const   )142, 
        (flex_int16_t const   )708,      (flex_int16_t const   )142,      (flex_int16_t const   )142,      (flex_int16_t const   )13, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708};
#line 944 "bsdl_flex.c"
static flex_int16_t const   yy_chk___0[1671]  = 
#line 944
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )32,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )624,      (flex_int16_t const   )28,      (flex_int16_t const   )5, 
        (flex_int16_t const   )624,      (flex_int16_t const   )5,      (flex_int16_t const   )9,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )33, 
        (flex_int16_t const   )9,      (flex_int16_t const   )34,      (flex_int16_t const   )218,      (flex_int16_t const   )218, 
        (flex_int16_t const   )5,      (flex_int16_t const   )219,      (flex_int16_t const   )219,      (flex_int16_t const   )5, 
        (flex_int16_t const   )711,      (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )668, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )32,      (flex_int16_t const   )9, 
        (flex_int16_t const   )9,      (flex_int16_t const   )28,      (flex_int16_t const   )625,      (flex_int16_t const   )5, 
        (flex_int16_t const   )5,      (flex_int16_t const   )35,      (flex_int16_t const   )9,      (flex_int16_t const   )593, 
        (flex_int16_t const   )5,      (flex_int16_t const   )5,      (flex_int16_t const   )33,      (flex_int16_t const   )9, 
        (flex_int16_t const   )39,      (flex_int16_t const   )34,      (flex_int16_t const   )24,      (flex_int16_t const   )5, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )5,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )10, 
        (flex_int16_t const   )42,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )592, 
        (flex_int16_t const   )36,      (flex_int16_t const   )10,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )35,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )40,      (flex_int16_t const   )7,      (flex_int16_t const   )266,      (flex_int16_t const   )40, 
        (flex_int16_t const   )39,      (flex_int16_t const   )24,      (flex_int16_t const   )266,      (flex_int16_t const   )559, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )45,      (flex_int16_t const   )7, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )10, 
        (flex_int16_t const   )42,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )36, 
        (flex_int16_t const   )10,      (flex_int16_t const   )558,      (flex_int16_t const   )31,      (flex_int16_t const   )31, 
        (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )7,      (flex_int16_t const   )40, 
        (flex_int16_t const   )7,      (flex_int16_t const   )11,      (flex_int16_t const   )40,      (flex_int16_t const   )11, 
        (flex_int16_t const   )56,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )11, 
        (flex_int16_t const   )555,      (flex_int16_t const   )11,      (flex_int16_t const   )45,      (flex_int16_t const   )334, 
        (flex_int16_t const   )334,      (flex_int16_t const   )527,      (flex_int16_t const   )527,      (flex_int16_t const   )560, 
        (flex_int16_t const   )560,      (flex_int16_t const   )44,      (flex_int16_t const   )51,      (flex_int16_t const   )43, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )57,      (flex_int16_t const   )11,      (flex_int16_t const   )78, 
        (flex_int16_t const   )11,      (flex_int16_t const   )528,      (flex_int16_t const   )70,      (flex_int16_t const   )56, 
        (flex_int16_t const   )11,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )43,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )44,      (flex_int16_t const   )11,      (flex_int16_t const   )51,      (flex_int16_t const   )43, 
        (flex_int16_t const   )520,      (flex_int16_t const   )518,      (flex_int16_t const   )515,      (flex_int16_t const   )496, 
        (flex_int16_t const   )11,      (flex_int16_t const   )57,      (flex_int16_t const   )11,      (flex_int16_t const   )78, 
        (flex_int16_t const   )11,      (flex_int16_t const   )70,      (flex_int16_t const   )495,      (flex_int16_t const   )87, 
        (flex_int16_t const   )11,      (flex_int16_t const   )30,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )43,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )30, 
        (flex_int16_t const   )11,      (flex_int16_t const   )478,      (flex_int16_t const   )463,      (flex_int16_t const   )30, 
        (flex_int16_t const   )11,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )87,      (flex_int16_t const   )55, 
        (flex_int16_t const   )462,      (flex_int16_t const   )30,      (flex_int16_t const   )41,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )49,      (flex_int16_t const   )30,      (flex_int16_t const   )47, 
        (flex_int16_t const   )41,      (flex_int16_t const   )50,      (flex_int16_t const   )30,      (flex_int16_t const   )48, 
        (flex_int16_t const   )41,      (flex_int16_t const   )55,      (flex_int16_t const   )48,      (flex_int16_t const   )49, 
        (flex_int16_t const   )47,      (flex_int16_t const   )50,      (flex_int16_t const   )453,      (flex_int16_t const   )89, 
        (flex_int16_t const   )450,      (flex_int16_t const   )23,      (flex_int16_t const   )446,      (flex_int16_t const   )55, 
        (flex_int16_t const   )84,      (flex_int16_t const   )84,      (flex_int16_t const   )41,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23,      (flex_int16_t const   )23, 
        (flex_int16_t const   )23,      (flex_int16_t const   )49,      (flex_int16_t const   )47,      (flex_int16_t const   )41, 
        (flex_int16_t const   )50,      (flex_int16_t const   )432,      (flex_int16_t const   )48,      (flex_int16_t const   )41, 
        (flex_int16_t const   )55,      (flex_int16_t const   )48,      (flex_int16_t const   )49,      (flex_int16_t const   )47, 
        (flex_int16_t const   )50,      (flex_int16_t const   )54,      (flex_int16_t const   )89,      (flex_int16_t const   )52, 
        (flex_int16_t const   )23,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )52,      (flex_int16_t const   )92,      (flex_int16_t const   )84, 
        (flex_int16_t const   )54,      (flex_int16_t const   )52,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )430,      (flex_int16_t const   )426,      (flex_int16_t const   )86,      (flex_int16_t const   )86, 
        (flex_int16_t const   )425,      (flex_int16_t const   )54,      (flex_int16_t const   )424,      (flex_int16_t const   )52, 
        (flex_int16_t const   )423,      (flex_int16_t const   )66,      (flex_int16_t const   )422,      (flex_int16_t const   )66, 
        (flex_int16_t const   )420,      (flex_int16_t const   )403,      (flex_int16_t const   )393,      (flex_int16_t const   )383, 
        (flex_int16_t const   )52,      (flex_int16_t const   )92,      (flex_int16_t const   )84,      (flex_int16_t const   )54, 
        (flex_int16_t const   )52,      (flex_int16_t const   )378,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )66,      (flex_int16_t const   )86,      (flex_int16_t const   )66,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )377, 
        (flex_int16_t const   )53,      (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )375, 
        (flex_int16_t const   )67,      (flex_int16_t const   )94,      (flex_int16_t const   )67,      (flex_int16_t const   )27, 
        (flex_int16_t const   )370,      (flex_int16_t const   )72,      (flex_int16_t const   )68,      (flex_int16_t const   )72, 
        (flex_int16_t const   )339,      (flex_int16_t const   )337,      (flex_int16_t const   )327,      (flex_int16_t const   )91, 
        (flex_int16_t const   )86,      (flex_int16_t const   )326,      (flex_int16_t const   )310,      (flex_int16_t const   )53, 
        (flex_int16_t const   )53,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )27,      (flex_int16_t const   )53, 
        (flex_int16_t const   )67,      (flex_int16_t const   )68,      (flex_int16_t const   )69,      (flex_int16_t const   )67, 
        (flex_int16_t const   )94,      (flex_int16_t const   )67,      (flex_int16_t const   )27,      (flex_int16_t const   )93, 
        (flex_int16_t const   )72,      (flex_int16_t const   )68,      (flex_int16_t const   )72,      (flex_int16_t const   )69, 
        (flex_int16_t const   )69,      (flex_int16_t const   )71,      (flex_int16_t const   )74,      (flex_int16_t const   )91, 
        (flex_int16_t const   )69,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )71,      (flex_int16_t const   )96,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )293,      (flex_int16_t const   )73,      (flex_int16_t const   )77, 
        (flex_int16_t const   )95,      (flex_int16_t const   )74,      (flex_int16_t const   )69,      (flex_int16_t const   )77, 
        (flex_int16_t const   )90,      (flex_int16_t const   )90,      (flex_int16_t const   )97,      (flex_int16_t const   )93, 
        (flex_int16_t const   )98,      (flex_int16_t const   )75,      (flex_int16_t const   )69,      (flex_int16_t const   )69, 
        (flex_int16_t const   )234,      (flex_int16_t const   )71,      (flex_int16_t const   )74,      (flex_int16_t const   )69, 
        (flex_int16_t const   )207,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )71,      (flex_int16_t const   )96,      (flex_int16_t const   )75, 
        (flex_int16_t const   )76,      (flex_int16_t const   )73,      (flex_int16_t const   )77,      (flex_int16_t const   )95, 
        (flex_int16_t const   )74,      (flex_int16_t const   )99,      (flex_int16_t const   )77,      (flex_int16_t const   )90, 
        (flex_int16_t const   )90,      (flex_int16_t const   )101,      (flex_int16_t const   )97,      (flex_int16_t const   )98, 
        (flex_int16_t const   )75,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82,      (flex_int16_t const   )82, 
        (flex_int16_t const   )82,      (flex_int16_t const   )100,      (flex_int16_t const   )100,      (flex_int16_t const   )102, 
        (flex_int16_t const   )103,      (flex_int16_t const   )103,      (flex_int16_t const   )105,      (flex_int16_t const   )154, 
        (flex_int16_t const   )104,      (flex_int16_t const   )153,      (flex_int16_t const   )104,      (flex_int16_t const   )104, 
        (flex_int16_t const   )106,      (flex_int16_t const   )99,      (flex_int16_t const   )107,      (flex_int16_t const   )108, 
        (flex_int16_t const   )109,      (flex_int16_t const   )101,      (flex_int16_t const   )110,      (flex_int16_t const   )111, 
        (flex_int16_t const   )112,      (flex_int16_t const   )151,      (flex_int16_t const   )113,      (flex_int16_t const   )114, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )118,      (flex_int16_t const   )149, 
        (flex_int16_t const   )113,      (flex_int16_t const   )80,      (flex_int16_t const   )102,      (flex_int16_t const   )103, 
        (flex_int16_t const   )103,      (flex_int16_t const   )119,      (flex_int16_t const   )105,      (flex_int16_t const   )104, 
        (flex_int16_t const   )100,      (flex_int16_t const   )104,      (flex_int16_t const   )104,      (flex_int16_t const   )106, 
        (flex_int16_t const   )120,      (flex_int16_t const   )107,      (flex_int16_t const   )108,      (flex_int16_t const   )121, 
        (flex_int16_t const   )109,      (flex_int16_t const   )110,      (flex_int16_t const   )111,      (flex_int16_t const   )122, 
        (flex_int16_t const   )112,      (flex_int16_t const   )113,      (flex_int16_t const   )114,      (flex_int16_t const   )126, 
        (flex_int16_t const   )115,      (flex_int16_t const   )116,      (flex_int16_t const   )118,      (flex_int16_t const   )113, 
        (flex_int16_t const   )117,      (flex_int16_t const   )117,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )119,      (flex_int16_t const   )129,      (flex_int16_t const   )131,      (flex_int16_t const   )100, 
        (flex_int16_t const   )130,      (flex_int16_t const   )65,      (flex_int16_t const   )132,      (flex_int16_t const   )120, 
        (flex_int16_t const   )133,      (flex_int16_t const   )128,      (flex_int16_t const   )134,      (flex_int16_t const   )121, 
        (flex_int16_t const   )135,      (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )122, 
        (flex_int16_t const   )138,      (flex_int16_t const   )141,      (flex_int16_t const   )126,      (flex_int16_t const   )139, 
        (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )64,      (flex_int16_t const   )117, 
        (flex_int16_t const   )117,      (flex_int16_t const   )137,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )129,      (flex_int16_t const   )131,      (flex_int16_t const   )136,      (flex_int16_t const   )140, 
        (flex_int16_t const   )130,      (flex_int16_t const   )132,      (flex_int16_t const   )137,      (flex_int16_t const   )133, 
        (flex_int16_t const   )128,      (flex_int16_t const   )134,      (flex_int16_t const   )62,      (flex_int16_t const   )135, 
        (flex_int16_t const   )130,      (flex_int16_t const   )130,      (flex_int16_t const   )61,      (flex_int16_t const   )144, 
        (flex_int16_t const   )138,      (flex_int16_t const   )141,      (flex_int16_t const   )139,      (flex_int16_t const   )145, 
        (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )146,      (flex_int16_t const   )147, 
        (flex_int16_t const   )152,      (flex_int16_t const   )137,      (flex_int16_t const   )148,      (flex_int16_t const   )150, 
        (flex_int16_t const   )155,      (flex_int16_t const   )136,      (flex_int16_t const   )140,      (flex_int16_t const   )156, 
        (flex_int16_t const   )157,      (flex_int16_t const   )137,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )143, 
        (flex_int16_t const   )143,      (flex_int16_t const   )143,      (flex_int16_t const   )144,      (flex_int16_t const   )158, 
        (flex_int16_t const   )158,      (flex_int16_t const   )159,      (flex_int16_t const   )145,      (flex_int16_t const   )160, 
        (flex_int16_t const   )162,      (flex_int16_t const   )146,      (flex_int16_t const   )147,      (flex_int16_t const   )143, 
        (flex_int16_t const   )152,      (flex_int16_t const   )148,      (flex_int16_t const   )150,      (flex_int16_t const   )155, 
        (flex_int16_t const   )161,      (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )156, 
        (flex_int16_t const   )157,      (flex_int16_t const   )165,      (flex_int16_t const   )166,      (flex_int16_t const   )167, 
        (flex_int16_t const   )22,      (flex_int16_t const   )168,      (flex_int16_t const   )169,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )173,      (flex_int16_t const   )158,      (flex_int16_t const   )158, 
        (flex_int16_t const   )159,      (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )160, 
        (flex_int16_t const   )162,      (flex_int16_t const   )175,      (flex_int16_t const   )178,      (flex_int16_t const   )143, 
        (flex_int16_t const   )176,      (flex_int16_t const   )177,      (flex_int16_t const   )179,      (flex_int16_t const   )161, 
        (flex_int16_t const   )163,      (flex_int16_t const   )164,      (flex_int16_t const   )181,      (flex_int16_t const   )182, 
        (flex_int16_t const   )165,      (flex_int16_t const   )166,      (flex_int16_t const   )183,      (flex_int16_t const   )167, 
        (flex_int16_t const   )168,      (flex_int16_t const   )184,      (flex_int16_t const   )169,      (flex_int16_t const   )170, 
        (flex_int16_t const   )171,      (flex_int16_t const   )173,      (flex_int16_t const   )187,      (flex_int16_t const   )192, 
        (flex_int16_t const   )172,      (flex_int16_t const   )174,      (flex_int16_t const   )189,      (flex_int16_t const   )190, 
        (flex_int16_t const   )191,      (flex_int16_t const   )175,      (flex_int16_t const   )178,      (flex_int16_t const   )176, 
        (flex_int16_t const   )177,      (flex_int16_t const   )193,      (flex_int16_t const   )179,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )181,      (flex_int16_t const   )182,      (flex_int16_t const   )196, 
        (flex_int16_t const   )198,      (flex_int16_t const   )183,      (flex_int16_t const   )15,      (flex_int16_t const   )13, 
        (flex_int16_t const   )184,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )201,      (flex_int16_t const   )187,      (flex_int16_t const   )192, 
        (flex_int16_t const   )200,      (flex_int16_t const   )189,      (flex_int16_t const   )190,      (flex_int16_t const   )191, 
        (flex_int16_t const   )199,      (flex_int16_t const   )202,      (flex_int16_t const   )205,      (flex_int16_t const   )199, 
        (flex_int16_t const   )193,      (flex_int16_t const   )0,      (flex_int16_t const   )194,      (flex_int16_t const   )195, 
        (flex_int16_t const   )206,      (flex_int16_t const   )197,      (flex_int16_t const   )196,      (flex_int16_t const   )197, 
        (flex_int16_t const   )198,      (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197,      (flex_int16_t const   )197, 
        (flex_int16_t const   )197,      (flex_int16_t const   )201,      (flex_int16_t const   )204,      (flex_int16_t const   )200, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )215,      (flex_int16_t const   )199, 
        (flex_int16_t const   )202,      (flex_int16_t const   )205,      (flex_int16_t const   )199,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )206, 
        (flex_int16_t const   )203,      (flex_int16_t const   )0,      (flex_int16_t const   )210,      (flex_int16_t const   )203, 
        (flex_int16_t const   )0,      (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )213, 
        (flex_int16_t const   )214,      (flex_int16_t const   )216,      (flex_int16_t const   )203,      (flex_int16_t const   )217, 
        (flex_int16_t const   )203,      (flex_int16_t const   )220,      (flex_int16_t const   )204,      (flex_int16_t const   )208, 
        (flex_int16_t const   )221,      (flex_int16_t const   )209,      (flex_int16_t const   )215,      (flex_int16_t const   )222, 
        (flex_int16_t const   )223,      (flex_int16_t const   )0,      (flex_int16_t const   )224,      (flex_int16_t const   )203, 
        (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )203,      (flex_int16_t const   )225, 
        (flex_int16_t const   )203,      (flex_int16_t const   )210,      (flex_int16_t const   )226,      (flex_int16_t const   )203, 
        (flex_int16_t const   )211,      (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214, 
        (flex_int16_t const   )216,      (flex_int16_t const   )203,      (flex_int16_t const   )217,      (flex_int16_t const   )203, 
        (flex_int16_t const   )227,      (flex_int16_t const   )220,      (flex_int16_t const   )228,      (flex_int16_t const   )221, 
        (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )222,      (flex_int16_t const   )230, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )232,      (flex_int16_t const   )233, 
        (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )225,      (flex_int16_t const   )238, 
        (flex_int16_t const   )239,      (flex_int16_t const   )240,      (flex_int16_t const   )226,      (flex_int16_t const   )241, 
        (flex_int16_t const   )242,      (flex_int16_t const   )0,      (flex_int16_t const   )243,      (flex_int16_t const   )244, 
        (flex_int16_t const   )0,      (flex_int16_t const   )245,      (flex_int16_t const   )0,      (flex_int16_t const   )227, 
        (flex_int16_t const   )0,      (flex_int16_t const   )228,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )229,      (flex_int16_t const   )231,      (flex_int16_t const   )230,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )232,      (flex_int16_t const   )233,      (flex_int16_t const   )0, 
        (flex_int16_t const   )235,      (flex_int16_t const   )236,      (flex_int16_t const   )238,      (flex_int16_t const   )239, 
        (flex_int16_t const   )240,      (flex_int16_t const   )249,      (flex_int16_t const   )241,      (flex_int16_t const   )250, 
        (flex_int16_t const   )242,      (flex_int16_t const   )243,      (flex_int16_t const   )251,      (flex_int16_t const   )244, 
        (flex_int16_t const   )245,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247, 
        (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247,      (flex_int16_t const   )247, 
        (flex_int16_t const   )247,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248,      (flex_int16_t const   )248, 
        (flex_int16_t const   )248,      (flex_int16_t const   )252,      (flex_int16_t const   )253,      (flex_int16_t const   )0, 
        (flex_int16_t const   )254,      (flex_int16_t const   )249,      (flex_int16_t const   )255,      (flex_int16_t const   )250, 
        (flex_int16_t const   )256,      (flex_int16_t const   )251,      (flex_int16_t const   )257,      (flex_int16_t const   )258, 
        (flex_int16_t const   )259,      (flex_int16_t const   )0,      (flex_int16_t const   )260,      (flex_int16_t const   )259, 
        (flex_int16_t const   )261,      (flex_int16_t const   )263,      (flex_int16_t const   )262,      (flex_int16_t const   )264, 
        (flex_int16_t const   )0,      (flex_int16_t const   )265,      (flex_int16_t const   )267,      (flex_int16_t const   )0, 
        (flex_int16_t const   )261,      (flex_int16_t const   )268,      (flex_int16_t const   )271,      (flex_int16_t const   )273, 
        (flex_int16_t const   )274,      (flex_int16_t const   )252,      (flex_int16_t const   )253,      (flex_int16_t const   )254, 
        (flex_int16_t const   )262,      (flex_int16_t const   )275,      (flex_int16_t const   )255,      (flex_int16_t const   )256, 
        (flex_int16_t const   )276,      (flex_int16_t const   )257,      (flex_int16_t const   )281,      (flex_int16_t const   )258, 
        (flex_int16_t const   )259,      (flex_int16_t const   )260,      (flex_int16_t const   )259,      (flex_int16_t const   )282, 
        (flex_int16_t const   )261,      (flex_int16_t const   )263,      (flex_int16_t const   )262,      (flex_int16_t const   )264, 
        (flex_int16_t const   )265,      (flex_int16_t const   )284,      (flex_int16_t const   )267,      (flex_int16_t const   )261, 
        (flex_int16_t const   )268,      (flex_int16_t const   )271,      (flex_int16_t const   )273,      (flex_int16_t const   )274, 
        (flex_int16_t const   )285,      (flex_int16_t const   )287,      (flex_int16_t const   )289,      (flex_int16_t const   )262, 
        (flex_int16_t const   )275,      (flex_int16_t const   )288,      (flex_int16_t const   )290,      (flex_int16_t const   )276, 
        (flex_int16_t const   )291,      (flex_int16_t const   )297,      (flex_int16_t const   )281,      (flex_int16_t const   )292, 
        (flex_int16_t const   )295,      (flex_int16_t const   )296,      (flex_int16_t const   )282,      (flex_int16_t const   )298, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )0,      (flex_int16_t const   )301, 
        (flex_int16_t const   )302,      (flex_int16_t const   )284,      (flex_int16_t const   )303,      (flex_int16_t const   )0, 
        (flex_int16_t const   )304,      (flex_int16_t const   )305,      (flex_int16_t const   )307,      (flex_int16_t const   )285, 
        (flex_int16_t const   )306,      (flex_int16_t const   )287,      (flex_int16_t const   )289,      (flex_int16_t const   )308, 
        (flex_int16_t const   )288,      (flex_int16_t const   )290,      (flex_int16_t const   )309,      (flex_int16_t const   )311, 
        (flex_int16_t const   )291,      (flex_int16_t const   )297,      (flex_int16_t const   )292,      (flex_int16_t const   )295, 
        (flex_int16_t const   )296,      (flex_int16_t const   )312,      (flex_int16_t const   )298,      (flex_int16_t const   )313, 
        (flex_int16_t const   )299,      (flex_int16_t const   )300,      (flex_int16_t const   )301,      (flex_int16_t const   )302, 
        (flex_int16_t const   )314,      (flex_int16_t const   )315,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )316,      (flex_int16_t const   )305,      (flex_int16_t const   )307,      (flex_int16_t const   )306, 
        (flex_int16_t const   )317,      (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )308, 
        (flex_int16_t const   )320,      (flex_int16_t const   )309,      (flex_int16_t const   )321,      (flex_int16_t const   )311, 
        (flex_int16_t const   )322,      (flex_int16_t const   )323,      (flex_int16_t const   )0,      (flex_int16_t const   )324, 
        (flex_int16_t const   )312,      (flex_int16_t const   )325,      (flex_int16_t const   )328,      (flex_int16_t const   )313, 
        (flex_int16_t const   )329,      (flex_int16_t const   )0,      (flex_int16_t const   )330,      (flex_int16_t const   )314, 
        (flex_int16_t const   )315,      (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )316, 
        (flex_int16_t const   )335,      (flex_int16_t const   )341,      (flex_int16_t const   )344,      (flex_int16_t const   )317, 
        (flex_int16_t const   )318,      (flex_int16_t const   )319,      (flex_int16_t const   )342,      (flex_int16_t const   )320, 
        (flex_int16_t const   )346,      (flex_int16_t const   )345,      (flex_int16_t const   )321,      (flex_int16_t const   )347, 
        (flex_int16_t const   )322,      (flex_int16_t const   )323,      (flex_int16_t const   )324,      (flex_int16_t const   )345, 
        (flex_int16_t const   )348,      (flex_int16_t const   )325,      (flex_int16_t const   )328,      (flex_int16_t const   )349, 
        (flex_int16_t const   )329,      (flex_int16_t const   )330,      (flex_int16_t const   )350,      (flex_int16_t const   )351, 
        (flex_int16_t const   )352,      (flex_int16_t const   )331,      (flex_int16_t const   )333,      (flex_int16_t const   )335, 
        (flex_int16_t const   )354,      (flex_int16_t const   )341,      (flex_int16_t const   )344,      (flex_int16_t const   )355, 
        (flex_int16_t const   )356,      (flex_int16_t const   )342,      (flex_int16_t const   )357,      (flex_int16_t const   )346, 
        (flex_int16_t const   )358,      (flex_int16_t const   )345,      (flex_int16_t const   )359,      (flex_int16_t const   )347, 
        (flex_int16_t const   )360,      (flex_int16_t const   )361,      (flex_int16_t const   )345,      (flex_int16_t const   )348, 
        (flex_int16_t const   )362,      (flex_int16_t const   )363,      (flex_int16_t const   )365,      (flex_int16_t const   )349, 
        (flex_int16_t const   )364,      (flex_int16_t const   )366,      (flex_int16_t const   )350,      (flex_int16_t const   )351, 
        (flex_int16_t const   )352,      (flex_int16_t const   )367,      (flex_int16_t const   )369,      (flex_int16_t const   )354, 
        (flex_int16_t const   )368,      (flex_int16_t const   )371,      (flex_int16_t const   )380,      (flex_int16_t const   )355, 
        (flex_int16_t const   )356,      (flex_int16_t const   )357,      (flex_int16_t const   )372,      (flex_int16_t const   )358, 
        (flex_int16_t const   )373,      (flex_int16_t const   )359,      (flex_int16_t const   )374,      (flex_int16_t const   )360, 
        (flex_int16_t const   )361,      (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )362, 
        (flex_int16_t const   )381,      (flex_int16_t const   )363,      (flex_int16_t const   )365,      (flex_int16_t const   )364, 
        (flex_int16_t const   )382,      (flex_int16_t const   )366,      (flex_int16_t const   )386,      (flex_int16_t const   )387, 
        (flex_int16_t const   )390,      (flex_int16_t const   )367,      (flex_int16_t const   )369,      (flex_int16_t const   )368, 
        (flex_int16_t const   )391,      (flex_int16_t const   )371,      (flex_int16_t const   )380,      (flex_int16_t const   )392, 
        (flex_int16_t const   )394,      (flex_int16_t const   )372,      (flex_int16_t const   )395,      (flex_int16_t const   )373, 
        (flex_int16_t const   )396,      (flex_int16_t const   )374,      (flex_int16_t const   )398,      (flex_int16_t const   )399, 
        (flex_int16_t const   )376,      (flex_int16_t const   )379,      (flex_int16_t const   )400,      (flex_int16_t const   )381, 
        (flex_int16_t const   )401,      (flex_int16_t const   )402,      (flex_int16_t const   )404,      (flex_int16_t const   )382, 
        (flex_int16_t const   )405,      (flex_int16_t const   )386,      (flex_int16_t const   )407,      (flex_int16_t const   )387, 
        (flex_int16_t const   )390,      (flex_int16_t const   )408,      (flex_int16_t const   )412,      (flex_int16_t const   )391, 
        (flex_int16_t const   )409,      (flex_int16_t const   )410,      (flex_int16_t const   )392,      (flex_int16_t const   )394, 
        (flex_int16_t const   )411,      (flex_int16_t const   )413,      (flex_int16_t const   )395,      (flex_int16_t const   )396, 
        (flex_int16_t const   )415,      (flex_int16_t const   )398,      (flex_int16_t const   )399,      (flex_int16_t const   )416, 
        (flex_int16_t const   )417,      (flex_int16_t const   )400,      (flex_int16_t const   )418,      (flex_int16_t const   )401, 
        (flex_int16_t const   )402,      (flex_int16_t const   )419,      (flex_int16_t const   )404,      (flex_int16_t const   )405, 
        (flex_int16_t const   )421,      (flex_int16_t const   )429,      (flex_int16_t const   )407,      (flex_int16_t const   )431, 
        (flex_int16_t const   )435,      (flex_int16_t const   )408,      (flex_int16_t const   )412,      (flex_int16_t const   )409, 
        (flex_int16_t const   )410,      (flex_int16_t const   )434,      (flex_int16_t const   )436,      (flex_int16_t const   )411, 
        (flex_int16_t const   )437,      (flex_int16_t const   )413,      (flex_int16_t const   )439,      (flex_int16_t const   )440, 
        (flex_int16_t const   )415,      (flex_int16_t const   )442,      (flex_int16_t const   )445,      (flex_int16_t const   )416, 
        (flex_int16_t const   )417,      (flex_int16_t const   )418,      (flex_int16_t const   )443,      (flex_int16_t const   )447, 
        (flex_int16_t const   )419,      (flex_int16_t const   )444,      (flex_int16_t const   )448,      (flex_int16_t const   )421, 
        (flex_int16_t const   )429,      (flex_int16_t const   )449,      (flex_int16_t const   )444,      (flex_int16_t const   )431, 
        (flex_int16_t const   )435,      (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )454, 
        (flex_int16_t const   )434,      (flex_int16_t const   )436,      (flex_int16_t const   )455,      (flex_int16_t const   )437, 
        (flex_int16_t const   )456,      (flex_int16_t const   )457,      (flex_int16_t const   )439,      (flex_int16_t const   )440, 
        (flex_int16_t const   )458,      (flex_int16_t const   )442,      (flex_int16_t const   )445,      (flex_int16_t const   )459, 
        (flex_int16_t const   )460,      (flex_int16_t const   )443,      (flex_int16_t const   )461,      (flex_int16_t const   )447, 
        (flex_int16_t const   )444,      (flex_int16_t const   )448,      (flex_int16_t const   )0,      (flex_int16_t const   )465, 
        (flex_int16_t const   )449,      (flex_int16_t const   )444,      (flex_int16_t const   )466,      (flex_int16_t const   )469, 
        (flex_int16_t const   )451,      (flex_int16_t const   )452,      (flex_int16_t const   )470,      (flex_int16_t const   )454, 
        (flex_int16_t const   )471,      (flex_int16_t const   )473,      (flex_int16_t const   )455,      (flex_int16_t const   )464, 
        (flex_int16_t const   )456,      (flex_int16_t const   )457,      (flex_int16_t const   )472,      (flex_int16_t const   )458, 
        (flex_int16_t const   )475,      (flex_int16_t const   )464,      (flex_int16_t const   )459,      (flex_int16_t const   )460, 
        (flex_int16_t const   )481,      (flex_int16_t const   )464,      (flex_int16_t const   )461,      (flex_int16_t const   )464, 
        (flex_int16_t const   )483,      (flex_int16_t const   )464,      (flex_int16_t const   )465,      (flex_int16_t const   )476, 
        (flex_int16_t const   )477,      (flex_int16_t const   )466,      (flex_int16_t const   )469,      (flex_int16_t const   )479, 
        (flex_int16_t const   )480,      (flex_int16_t const   )485,      (flex_int16_t const   )470,      (flex_int16_t const   )484, 
        (flex_int16_t const   )471,      (flex_int16_t const   )473,      (flex_int16_t const   )486,      (flex_int16_t const   )464, 
        (flex_int16_t const   )487,      (flex_int16_t const   )472,      (flex_int16_t const   )488,      (flex_int16_t const   )492, 
        (flex_int16_t const   )475,      (flex_int16_t const   )464,      (flex_int16_t const   )489,      (flex_int16_t const   )481, 
        (flex_int16_t const   )464,      (flex_int16_t const   )490,      (flex_int16_t const   )464,      (flex_int16_t const   )483, 
        (flex_int16_t const   )464,      (flex_int16_t const   )493,      (flex_int16_t const   )494,      (flex_int16_t const   )476, 
        (flex_int16_t const   )477,      (flex_int16_t const   )497,      (flex_int16_t const   )498,      (flex_int16_t const   )479, 
        (flex_int16_t const   )480,      (flex_int16_t const   )485,      (flex_int16_t const   )484,      (flex_int16_t const   )499, 
        (flex_int16_t const   )500,      (flex_int16_t const   )486,      (flex_int16_t const   )501,      (flex_int16_t const   )487, 
        (flex_int16_t const   )502,      (flex_int16_t const   )505,      (flex_int16_t const   )488,      (flex_int16_t const   )492, 
        (flex_int16_t const   )503,      (flex_int16_t const   )489,      (flex_int16_t const   )504,      (flex_int16_t const   )507, 
        (flex_int16_t const   )490,      (flex_int16_t const   )508,      (flex_int16_t const   )509,      (flex_int16_t const   )511, 
        (flex_int16_t const   )493,      (flex_int16_t const   )510,      (flex_int16_t const   )494,      (flex_int16_t const   )512, 
        (flex_int16_t const   )497,      (flex_int16_t const   )498,      (flex_int16_t const   )513,      (flex_int16_t const   )514, 
        (flex_int16_t const   )516,      (flex_int16_t const   )517,      (flex_int16_t const   )499,      (flex_int16_t const   )500, 
        (flex_int16_t const   )519,      (flex_int16_t const   )521,      (flex_int16_t const   )501,      (flex_int16_t const   )522, 
        (flex_int16_t const   )502,      (flex_int16_t const   )505,      (flex_int16_t const   )523,      (flex_int16_t const   )503, 
        (flex_int16_t const   )524,      (flex_int16_t const   )504,      (flex_int16_t const   )507,      (flex_int16_t const   )525, 
        (flex_int16_t const   )526,      (flex_int16_t const   )508,      (flex_int16_t const   )509,      (flex_int16_t const   )511, 
        (flex_int16_t const   )510,      (flex_int16_t const   )529,      (flex_int16_t const   )512,      (flex_int16_t const   )531, 
        (flex_int16_t const   )534,      (flex_int16_t const   )513,      (flex_int16_t const   )514,      (flex_int16_t const   )516, 
        (flex_int16_t const   )532,      (flex_int16_t const   )517,      (flex_int16_t const   )533,      (flex_int16_t const   )519, 
        (flex_int16_t const   )535,      (flex_int16_t const   )521,      (flex_int16_t const   )522,      (flex_int16_t const   )536, 
        (flex_int16_t const   )541,      (flex_int16_t const   )523,      (flex_int16_t const   )542,      (flex_int16_t const   )524, 
        (flex_int16_t const   )543,      (flex_int16_t const   )0,      (flex_int16_t const   )544,      (flex_int16_t const   )525, 
        (flex_int16_t const   )526,      (flex_int16_t const   )545,      (flex_int16_t const   )0,      (flex_int16_t const   )547, 
        (flex_int16_t const   )529,      (flex_int16_t const   )548,      (flex_int16_t const   )0,      (flex_int16_t const   )531, 
        (flex_int16_t const   )534,      (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )532, 
        (flex_int16_t const   )556,      (flex_int16_t const   )533,      (flex_int16_t const   )0,      (flex_int16_t const   )535, 
        (flex_int16_t const   )551,      (flex_int16_t const   )0,      (flex_int16_t const   )536,      (flex_int16_t const   )553, 
        (flex_int16_t const   )541,      (flex_int16_t const   )557,      (flex_int16_t const   )542,      (flex_int16_t const   )561, 
        (flex_int16_t const   )543,      (flex_int16_t const   )544,      (flex_int16_t const   )562,      (flex_int16_t const   )564, 
        (flex_int16_t const   )545,      (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )547, 
        (flex_int16_t const   )548,      (flex_int16_t const   )546,      (flex_int16_t const   )549,      (flex_int16_t const   )565, 
        (flex_int16_t const   )550,      (flex_int16_t const   )552,      (flex_int16_t const   )546,      (flex_int16_t const   )556, 
        (flex_int16_t const   )549,      (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )567, 
        (flex_int16_t const   )551,      (flex_int16_t const   )549,      (flex_int16_t const   )549,      (flex_int16_t const   )553, 
        (flex_int16_t const   )568,      (flex_int16_t const   )557,      (flex_int16_t const   )569,      (flex_int16_t const   )561, 
        (flex_int16_t const   )570,      (flex_int16_t const   )571,      (flex_int16_t const   )562,      (flex_int16_t const   )564, 
        (flex_int16_t const   )572,      (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )573, 
        (flex_int16_t const   )574,      (flex_int16_t const   )546,      (flex_int16_t const   )549,      (flex_int16_t const   )565, 
        (flex_int16_t const   )575,      (flex_int16_t const   )546,      (flex_int16_t const   )576,      (flex_int16_t const   )549, 
        (flex_int16_t const   )546,      (flex_int16_t const   )546,      (flex_int16_t const   )567,      (flex_int16_t const   )577, 
        (flex_int16_t const   )549,      (flex_int16_t const   )549,      (flex_int16_t const   )578,      (flex_int16_t const   )568, 
        (flex_int16_t const   )579,      (flex_int16_t const   )569,      (flex_int16_t const   )580,      (flex_int16_t const   )570, 
        (flex_int16_t const   )581,      (flex_int16_t const   )571,      (flex_int16_t const   )582,      (flex_int16_t const   )584, 
        (flex_int16_t const   )572,      (flex_int16_t const   )583,      (flex_int16_t const   )585,      (flex_int16_t const   )573, 
        (flex_int16_t const   )574,      (flex_int16_t const   )586,      (flex_int16_t const   )587,      (flex_int16_t const   )575, 
        (flex_int16_t const   )589,      (flex_int16_t const   )590,      (flex_int16_t const   )576,      (flex_int16_t const   )591, 
        (flex_int16_t const   )596,      (flex_int16_t const   )598,      (flex_int16_t const   )577,      (flex_int16_t const   )599, 
        (flex_int16_t const   )601,      (flex_int16_t const   )578,      (flex_int16_t const   )602,      (flex_int16_t const   )579, 
        (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )580,      (flex_int16_t const   )581, 
        (flex_int16_t const   )605,      (flex_int16_t const   )606,      (flex_int16_t const   )582,      (flex_int16_t const   )584, 
        (flex_int16_t const   )583,      (flex_int16_t const   )585,      (flex_int16_t const   )607,      (flex_int16_t const   )608, 
        (flex_int16_t const   )586,      (flex_int16_t const   )609,      (flex_int16_t const   )587,      (flex_int16_t const   )589, 
        (flex_int16_t const   )610,      (flex_int16_t const   )590,      (flex_int16_t const   )591,      (flex_int16_t const   )596, 
        (flex_int16_t const   )598,      (flex_int16_t const   )611,      (flex_int16_t const   )599,      (flex_int16_t const   )612, 
        (flex_int16_t const   )601,      (flex_int16_t const   )602,      (flex_int16_t const   )613,      (flex_int16_t const   )603, 
        (flex_int16_t const   )604,      (flex_int16_t const   )614,      (flex_int16_t const   )617,      (flex_int16_t const   )605, 
        (flex_int16_t const   )606,      (flex_int16_t const   )615,      (flex_int16_t const   )616,      (flex_int16_t const   )618, 
        (flex_int16_t const   )619,      (flex_int16_t const   )607,      (flex_int16_t const   )620,      (flex_int16_t const   )608, 
        (flex_int16_t const   )609,      (flex_int16_t const   )621,      (flex_int16_t const   )0,      (flex_int16_t const   )623, 
        (flex_int16_t const   )610,      (flex_int16_t const   )628,      (flex_int16_t const   )630,      (flex_int16_t const   )631, 
        (flex_int16_t const   )635,      (flex_int16_t const   )611,      (flex_int16_t const   )632,      (flex_int16_t const   )612, 
        (flex_int16_t const   )634,      (flex_int16_t const   )636,      (flex_int16_t const   )613,      (flex_int16_t const   )637, 
        (flex_int16_t const   )644,      (flex_int16_t const   )614,      (flex_int16_t const   )617,      (flex_int16_t const   )638, 
        (flex_int16_t const   )615,      (flex_int16_t const   )616,      (flex_int16_t const   )639,      (flex_int16_t const   )618, 
        (flex_int16_t const   )619,      (flex_int16_t const   )620,      (flex_int16_t const   )640,      (flex_int16_t const   )642, 
        (flex_int16_t const   )645,      (flex_int16_t const   )621,      (flex_int16_t const   )623,      (flex_int16_t const   )646, 
        (flex_int16_t const   )628,      (flex_int16_t const   )647,      (flex_int16_t const   )630,      (flex_int16_t const   )631, 
        (flex_int16_t const   )635,      (flex_int16_t const   )632,      (flex_int16_t const   )648,      (flex_int16_t const   )634, 
        (flex_int16_t const   )636,      (flex_int16_t const   )649,      (flex_int16_t const   )654,      (flex_int16_t const   )637, 
        (flex_int16_t const   )644,      (flex_int16_t const   )655,      (flex_int16_t const   )638,      (flex_int16_t const   )656, 
        (flex_int16_t const   )657,      (flex_int16_t const   )639,      (flex_int16_t const   )658,      (flex_int16_t const   )659, 
        (flex_int16_t const   )660,      (flex_int16_t const   )640,      (flex_int16_t const   )642,      (flex_int16_t const   )661, 
        (flex_int16_t const   )645,      (flex_int16_t const   )662,      (flex_int16_t const   )646,      (flex_int16_t const   )663, 
        (flex_int16_t const   )647,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )0, 
        (flex_int16_t const   )666,      (flex_int16_t const   )648,      (flex_int16_t const   )672,      (flex_int16_t const   )674, 
        (flex_int16_t const   )649,      (flex_int16_t const   )675,      (flex_int16_t const   )654,      (flex_int16_t const   )676, 
        (flex_int16_t const   )655,      (flex_int16_t const   )677,      (flex_int16_t const   )656,      (flex_int16_t const   )657, 
        (flex_int16_t const   )679,      (flex_int16_t const   )658,      (flex_int16_t const   )680,      (flex_int16_t const   )659, 
        (flex_int16_t const   )660,      (flex_int16_t const   )681,      (flex_int16_t const   )661,      (flex_int16_t const   )682, 
        (flex_int16_t const   )684,      (flex_int16_t const   )662,      (flex_int16_t const   )685,      (flex_int16_t const   )663, 
        (flex_int16_t const   )687,      (flex_int16_t const   )664,      (flex_int16_t const   )665,      (flex_int16_t const   )666, 
        (flex_int16_t const   )688,      (flex_int16_t const   )672,      (flex_int16_t const   )674,      (flex_int16_t const   )689, 
        (flex_int16_t const   )690,      (flex_int16_t const   )675,      (flex_int16_t const   )676,      (flex_int16_t const   )693, 
        (flex_int16_t const   )677,      (flex_int16_t const   )695,      (flex_int16_t const   )696,      (flex_int16_t const   )698, 
        (flex_int16_t const   )679,      (flex_int16_t const   )703,      (flex_int16_t const   )680,      (flex_int16_t const   )704, 
        (flex_int16_t const   )681,      (flex_int16_t const   )705,      (flex_int16_t const   )0,      (flex_int16_t const   )682, 
        (flex_int16_t const   )684,      (flex_int16_t const   )685,      (flex_int16_t const   )0,      (flex_int16_t const   )687, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )688, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )689, 
        (flex_int16_t const   )690,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )693, 
        (flex_int16_t const   )695,      (flex_int16_t const   )0,      (flex_int16_t const   )696,      (flex_int16_t const   )698, 
        (flex_int16_t const   )703,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )704, 
        (flex_int16_t const   )705,      (flex_int16_t const   )709,      (flex_int16_t const   )709,      (flex_int16_t const   )710, 
        (flex_int16_t const   )0,      (flex_int16_t const   )710,      (flex_int16_t const   )710,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708, 
        (flex_int16_t const   )708,      (flex_int16_t const   )708,      (flex_int16_t const   )708};
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/bsdl/bsdl_parser.h"
void *bsdl_flex_init(int proc_mode ) ;
#line 32
void bsdl_flex_deinit(void *scanner ) ;
#line 33
void bsdl_flex_set_bin_x(void *scanner ) ;
#line 34
void bsdl_flex_set_hex(void *scanner ) ;
#line 35
void bsdl_flex_set_decimal(void *scanner ) ;
#line 37
int bsdl_flex_postinc_compile_errors(void *scanner ) ;
#line 39
void bsdl_flex_stop_buffer(void *scanner ) ;
#line 143 "bsdl_flex.l"
static char *new_string___0(scan_extra_t *extra , char const   *str ) ;
#line 1353 "bsdl_flex.c"
static int yy_init_globals___0(yyscan_t yyscanner ) ;
#line 1359
int bsdllex_init(yyscan_t *ptr_yy_globals ) ;
#line 1361
int bsdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 1366
int bsdllex_destroy(yyscan_t yyscanner ) ;
#line 1368
int bsdlget_debug(yyscan_t yyscanner ) ;
#line 1370
void bsdlset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 1372
scan_extra_t *bsdlget_extra(yyscan_t yyscanner ) ;
#line 1374
void bsdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 1376
FILE *bsdlget_in(yyscan_t yyscanner ) ;
#line 1378
void bsdlset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 1380
FILE *bsdlget_out(yyscan_t yyscanner ) ;
#line 1382
void bsdlset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 1384
int bsdlget_leng(yyscan_t yyscanner ) ;
#line 1386
char *bsdlget_text(yyscan_t yyscanner ) ;
#line 1388
int bsdlget_lineno(yyscan_t yyscanner ) ;
#line 1390
void bsdlset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 1392
YYSTYPE *bsdlget_lval(yyscan_t yyscanner ) ;
#line 1394
void bsdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1404
int bsdlwrap(yyscan_t scanner ) ;
#line 1503
int bsdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) ;
#line 1527 "bsdl_flex.c"
int bsdllex(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t *yyg ;
  void *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  yy_state_type *tmp___1 ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp___2 ;
  YY_BUFFER_STATE tmp___3 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1532
  yyg = (struct yyguts_t *)yyscanner;
#line 1538
  yyg->yylval_r = yylval_param;
#line 1540
  if (! yyg->yy_init) {
#line 1542
    yyg->yy_init = 1;
#line 1549
    if (! yyg->yy_state_buf) {
      {
#line 1550
      tmp = bsdlalloc(16386UL * sizeof(yy_state_type ), yyscanner);
#line 1550
      yyg->yy_state_buf = (yy_state_type *)tmp;
      }
    }
#line 1551
    if (! yyg->yy_state_buf) {
      {
#line 1552
      yy_fatal_error___0("out of dynamic memory in bsdllex()", yyscanner);
      }
    }
#line 1554
    if (! yyg->yy_start) {
#line 1555
      yyg->yy_start = 1;
    }
#line 1557
    if (! yyg->yyin_r) {
#line 1558
      yyg->yyin_r = stdin;
    }
#line 1560
    if (! yyg->yyout_r) {
#line 1561
      yyg->yyout_r = stdout;
    }
#line 1563
    if (yyg->yy_buffer_stack) {
#line 1563
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 1563
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 1563
    if (! tmp___0) {
      {
#line 1564
      bsdlensure_buffer_stack(yyscanner);
#line 1565
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = bsdl_create_buffer(yyg->yyin_r,
                                                                              16384,
                                                                              yyscanner);
      }
    }
    {
#line 1569
    bsdl_load_buffer_state(yyscanner);
    }
  }
  {
#line 1572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1574
    yy_cp = yyg->yy_c_buf_p;
#line 1577
    *yy_cp = yyg->yy_hold_char;
#line 1582
    yy_bp = yy_cp;
#line 1584
    yy_current_state = yyg->yy_start;
#line 1586
    yyg->yy_state_ptr = yyg->yy_state_buf;
#line 1587
    tmp___1 = yyg->yy_state_ptr;
#line 1587
    (yyg->yy_state_ptr) ++;
#line 1587
    *tmp___1 = yy_current_state;
    yy_match: 
    {
#line 1590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1592
      yy_c = (YY_CHAR )yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
      {
#line 1593
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1593
        if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1593
          goto while_break___1;
        }
#line 1595
        yy_current_state = (int )yy_def___0[yy_current_state];
#line 1596
        if (yy_current_state >= 709) {
#line 1597
          yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1599
      yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 1600
      tmp___2 = yyg->yy_state_ptr;
#line 1600
      (yyg->yy_state_ptr) ++;
#line 1600
      *tmp___2 = yy_current_state;
#line 1601
      yy_cp ++;
#line 1590
      if (! ((int const   )yy_base___0[yy_current_state] != 1591)) {
#line 1590
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 1606
    (yyg->yy_state_ptr) --;
#line 1606
    yy_current_state = *(yyg->yy_state_ptr);
#line 1607
    yyg->yy_lp = (int )yy_accept___0[yy_current_state];
    find_rule: 
    {
#line 1609
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1611
      if (yyg->yy_lp) {
#line 1611
        if (yyg->yy_lp < (int )yy_accept___0[yy_current_state + 1]) {
#line 1613
          yy_act = (int )yy_acclist___0[yyg->yy_lp];
#line 1615
          yyg->yy_full_match = yy_cp;
#line 1616
          goto while_break___2;
        }
      }
#line 1619
      yy_cp --;
#line 1620
      (yyg->yy_state_ptr) --;
#line 1620
      yy_current_state = *(yyg->yy_state_ptr);
#line 1621
      yyg->yy_lp = (int )yy_accept___0[yy_current_state];
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1624
    yyg->yytext_r = yy_bp;
#line 1624
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 1624
    yyg->yy_hold_char = *yy_cp;
#line 1624
    *yy_cp = (char )'\000';
#line 1624
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1630
    if (yy_act == 1) {
#line 1630
      goto case_1;
    }
#line 277
    if (yy_act == 2) {
#line 277 "bsdl_flex.l"
      goto case_2;
    }
#line 278
    if (yy_act == 3) {
#line 278
      goto case_3;
    }
#line 279
    if (yy_act == 4) {
#line 279
      goto case_4;
    }
#line 280
    if (yy_act == 5) {
#line 280
      goto case_5;
    }
#line 281
    if (yy_act == 6) {
#line 281
      goto case_6;
    }
#line 282
    if (yy_act == 7) {
#line 282
      goto case_7;
    }
#line 283
    if (yy_act == 8) {
#line 283
      goto case_8;
    }
#line 284
    if (yy_act == 9) {
#line 284
      goto case_9;
    }
#line 285
    if (yy_act == 10) {
#line 285
      goto case_10;
    }
#line 286
    if (yy_act == 11) {
#line 286
      goto case_11;
    }
#line 288
    if (yy_act == 12) {
#line 288
      goto case_12;
    }
#line 290
    if (yy_act == 13) {
#line 290
      goto case_13;
    }
#line 291
    if (yy_act == 14) {
#line 291
      goto case_14;
    }
#line 292
    if (yy_act == 15) {
#line 292
      goto case_15;
    }
#line 293
    if (yy_act == 16) {
#line 293
      goto case_16;
    }
#line 295
    if (yy_act == 17) {
#line 295
      goto case_17;
    }
#line 296
    if (yy_act == 18) {
#line 296
      goto case_18;
    }
#line 298
    if (yy_act == 19) {
#line 298
      goto case_19;
    }
#line 299
    if (yy_act == 20) {
#line 299
      goto case_20;
    }
#line 300
    if (yy_act == 21) {
#line 300
      goto case_21;
    }
#line 301
    if (yy_act == 22) {
#line 301
      goto case_22;
    }
#line 302
    if (yy_act == 23) {
#line 302
      goto case_23;
    }
#line 303
    if (yy_act == 24) {
#line 303
      goto case_24;
    }
#line 304
    if (yy_act == 25) {
#line 304
      goto case_25;
    }
#line 305
    if (yy_act == 26) {
#line 305
      goto case_26;
    }
#line 306
    if (yy_act == 27) {
#line 306
      goto case_27;
    }
#line 307
    if (yy_act == 28) {
#line 307
      goto case_28;
    }
#line 308
    if (yy_act == 29) {
#line 308
      goto case_29;
    }
#line 309
    if (yy_act == 30) {
#line 309
      goto case_30;
    }
#line 310
    if (yy_act == 31) {
#line 310
      goto case_31;
    }
#line 311
    if (yy_act == 32) {
#line 311
      goto case_32;
    }
#line 312
    if (yy_act == 33) {
#line 312
      goto case_33;
    }
#line 313
    if (yy_act == 34) {
#line 313
      goto case_34;
    }
#line 314
    if (yy_act == 35) {
#line 314
      goto case_35;
    }
#line 315
    if (yy_act == 36) {
#line 315
      goto case_36;
    }
#line 316
    if (yy_act == 37) {
#line 316
      goto case_37;
    }
#line 317
    if (yy_act == 38) {
#line 317
      goto case_38;
    }
#line 318
    if (yy_act == 39) {
#line 318
      goto case_39;
    }
#line 319
    if (yy_act == 40) {
#line 319
      goto case_40;
    }
#line 320
    if (yy_act == 41) {
#line 320
      goto case_41;
    }
#line 321
    if (yy_act == 42) {
#line 321
      goto case_42;
    }
#line 322
    if (yy_act == 43) {
#line 322
      goto case_43;
    }
#line 323
    if (yy_act == 44) {
#line 323
      goto case_44;
    }
#line 324
    if (yy_act == 45) {
#line 324
      goto case_45;
    }
#line 325
    if (yy_act == 46) {
#line 325
      goto case_46;
    }
#line 326
    if (yy_act == 47) {
#line 326
      goto case_47;
    }
#line 327
    if (yy_act == 48) {
#line 327
      goto case_48;
    }
#line 328
    if (yy_act == 49) {
#line 328
      goto case_49;
    }
#line 329
    if (yy_act == 50) {
#line 329
      goto case_50;
    }
#line 330
    if (yy_act == 51) {
#line 330
      goto case_51;
    }
#line 331
    if (yy_act == 52) {
#line 331
      goto case_52;
    }
#line 332
    if (yy_act == 53) {
#line 332
      goto case_53;
    }
#line 333
    if (yy_act == 54) {
#line 333
      goto case_54;
    }
#line 334
    if (yy_act == 55) {
#line 334
      goto case_55;
    }
#line 335
    if (yy_act == 56) {
#line 335
      goto case_56;
    }
#line 336
    if (yy_act == 57) {
#line 336
      goto case_57;
    }
#line 337
    if (yy_act == 58) {
#line 337
      goto case_58;
    }
#line 338
    if (yy_act == 59) {
#line 338
      goto case_59;
    }
#line 339
    if (yy_act == 60) {
#line 339
      goto case_60;
    }
#line 340
    if (yy_act == 61) {
#line 340
      goto case_61;
    }
#line 341
    if (yy_act == 62) {
#line 341
      goto case_62;
    }
#line 342
    if (yy_act == 63) {
#line 342
      goto case_63;
    }
#line 343
    if (yy_act == 64) {
#line 343
      goto case_64;
    }
#line 344
    if (yy_act == 65) {
#line 344
      goto case_65;
    }
#line 345
    if (yy_act == 66) {
#line 345
      goto case_66;
    }
#line 346
    if (yy_act == 67) {
#line 346
      goto case_67;
    }
#line 347
    if (yy_act == 68) {
#line 347
      goto case_68;
    }
#line 348
    if (yy_act == 69) {
#line 348
      goto case_69;
    }
#line 349
    if (yy_act == 70) {
#line 349
      goto case_70;
    }
#line 350
    if (yy_act == 71) {
#line 350
      goto case_71;
    }
#line 351
    if (yy_act == 72) {
#line 351
      goto case_72;
    }
#line 352
    if (yy_act == 73) {
#line 352
      goto case_73;
    }
#line 353
    if (yy_act == 74) {
#line 353
      goto case_74;
    }
#line 354
    if (yy_act == 75) {
#line 354
      goto case_75;
    }
#line 355
    if (yy_act == 76) {
#line 355
      goto case_76;
    }
#line 356
    if (yy_act == 77) {
#line 356
      goto case_77;
    }
#line 357
    if (yy_act == 78) {
#line 357
      goto case_78;
    }
#line 358
    if (yy_act == 79) {
#line 358
      goto case_79;
    }
#line 359
    if (yy_act == 80) {
#line 359
      goto case_80;
    }
#line 360
    if (yy_act == 81) {
#line 360
      goto case_81;
    }
#line 361
    if (yy_act == 82) {
#line 361
      goto case_82;
    }
#line 362
    if (yy_act == 83) {
#line 362
      goto case_83;
    }
#line 363
    if (yy_act == 84) {
#line 363
      goto case_84;
    }
#line 364
    if (yy_act == 85) {
#line 364
      goto case_85;
    }
#line 365
    if (yy_act == 86) {
#line 365
      goto case_86;
    }
#line 366
    if (yy_act == 87) {
#line 366
      goto case_87;
    }
#line 367
    if (yy_act == 88) {
#line 367
      goto case_88;
    }
#line 368
    if (yy_act == 89) {
#line 368
      goto case_89;
    }
#line 369
    if (yy_act == 90) {
#line 369
      goto case_90;
    }
#line 370
    if (yy_act == 91) {
#line 370
      goto case_91;
    }
#line 371
    if (yy_act == 92) {
#line 371
      goto case_92;
    }
#line 372
    if (yy_act == 93) {
#line 372
      goto case_93;
    }
#line 373
    if (yy_act == 94) {
#line 373
      goto case_94;
    }
#line 374
    if (yy_act == 95) {
#line 374
      goto case_95;
    }
#line 375
    if (yy_act == 96) {
#line 375
      goto case_96;
    }
#line 376
    if (yy_act == 97) {
#line 376
      goto case_97;
    }
#line 377
    if (yy_act == 98) {
#line 377
      goto case_98;
    }
#line 378
    if (yy_act == 99) {
#line 378
      goto case_99;
    }
#line 379
    if (yy_act == 100) {
#line 379
      goto case_100;
    }
#line 380
    if (yy_act == 101) {
#line 380
      goto case_101;
    }
#line 381
    if (yy_act == 102) {
#line 381
      goto case_102;
    }
#line 382
    if (yy_act == 103) {
#line 382
      goto case_103;
    }
#line 383
    if (yy_act == 104) {
#line 383
      goto case_104;
    }
#line 384
    if (yy_act == 105) {
#line 384
      goto case_105;
    }
#line 385
    if (yy_act == 106) {
#line 385
      goto case_106;
    }
#line 386
    if (yy_act == 107) {
#line 386
      goto case_107;
    }
#line 387
    if (yy_act == 108) {
#line 387
      goto case_108;
    }
#line 388
    if (yy_act == 109) {
#line 388
      goto case_109;
    }
#line 391
    if (yy_act == 110) {
#line 391
      goto case_110;
    }
#line 394
    if (yy_act == 111) {
#line 394
      goto case_111;
    }
#line 396
    if (yy_act == 112) {
#line 396
      goto case_112;
    }
#line 399
    if (yy_act == 113) {
#line 399
      goto case_113;
    }
#line 402
    if (yy_act == 114) {
#line 402
      goto case_114;
    }
#line 404
    if (yy_act == 115) {
#line 404
      goto case_115;
    }
#line 416
    if (yy_act == 123) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 122) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 121) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 120) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 119) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 118) {
#line 416
      goto case_123;
    }
#line 416
    if (yy_act == 116) {
#line 416
      goto case_116;
    }
#line 2246
    if (yy_act == 117) {
#line 2246 "bsdl_flex.c"
      goto case_117;
    }
#line 2368
    goto switch_default;
    case_1: /* CIL Label */ 
#line 275 "bsdl_flex.l"
    (yyg->yyextra_r)->Base = 1;
#line 275
    return (258);
#line 276
    goto switch_break;
    case_2: /* CIL Label */ 
#line 276
    return (259);
#line 277
    goto switch_break;
    case_3: /* CIL Label */ 
#line 277
    return (260);
#line 278
    goto switch_break;
    case_4: /* CIL Label */ 
#line 278
    return (261);
#line 279
    goto switch_break;
    case_5: /* CIL Label */ 
#line 279
    return (262);
#line 280
    goto switch_break;
    case_6: /* CIL Label */ 
#line 280
    return (263);
#line 281
    goto switch_break;
    case_7: /* CIL Label */ 
#line 281
    return (266);
#line 282
    goto switch_break;
    case_8: /* CIL Label */ 
#line 282
    return (264);
#line 283
    goto switch_break;
    case_9: /* CIL Label */ 
#line 283
    return (265);
#line 284
    goto switch_break;
    case_10: /* CIL Label */ 
#line 284
    (yyg->yyextra_r)->Base = 1;
#line 284
    return (267);
#line 285
    goto switch_break;
    case_11: /* CIL Label */ 
#line 285
    (yyg->yyextra_r)->Base = 0;
#line 286
    return (268);
#line 287
    goto switch_break;
    case_12: /* CIL Label */ 
#line 287
    (yyg->yyextra_r)->Base = 2;
#line 288
    return (269);
#line 289
    goto switch_break;
    case_13: /* CIL Label */ 
#line 289
    return (270);
#line 290
    goto switch_break;
    case_14: /* CIL Label */ 
#line 290
    return (271);
#line 291
    goto switch_break;
    case_15: /* CIL Label */ 
#line 291
    return (272);
#line 292
    goto switch_break;
    case_16: /* CIL Label */ 
#line 292
    yyg->yy_start = 7;
#line 292
    (yyg->yyextra_r)->Base = 1;
#line 293
    return (273);
#line 294
    goto switch_break;
    case_17: /* CIL Label */ 
#line 294
    return (274);
#line 295
    goto switch_break;
    case_18: /* CIL Label */ 
#line 295
    yyg->yy_start = 5;
#line 295
    (yyg->yyextra_r)->Base = 1;
#line 296
    return (275);
#line 297
    goto switch_break;
    case_19: /* CIL Label */ 
#line 297
    (yyg->yyextra_r)->Base = 2;
#line 297
    return (276);
#line 298
    goto switch_break;
    case_20: /* CIL Label */ 
#line 298
    (yyg->yyextra_r)->Base = 2;
#line 298
    return (277);
#line 299
    goto switch_break;
    case_21: /* CIL Label */ 
#line 299
    (yyg->yyextra_r)->Base = 1;
#line 299
    return (307);
#line 300
    goto switch_break;
    case_22: /* CIL Label */ 
#line 300
    return (319);
#line 301
    goto switch_break;
    case_23: /* CIL Label */ 
#line 301
    return (320);
#line 302
    goto switch_break;
    case_24: /* CIL Label */ 
#line 302
    return (321);
#line 303
    goto switch_break;
    case_25: /* CIL Label */ 
#line 303
    return (322);
#line 304
    goto switch_break;
    case_26: /* CIL Label */ 
#line 304
    (yyg->yyextra_r)->Base = 1;
#line 304
    return (323);
#line 305
    goto switch_break;
    case_27: /* CIL Label */ 
#line 305
    return (324);
#line 306
    goto switch_break;
    case_28: /* CIL Label */ 
#line 306
    return (325);
#line 307
    goto switch_break;
    case_29: /* CIL Label */ 
#line 307
    yyg->yy_start = 11;
#line 307
    (yyg->yyextra_r)->Base = 1;
#line 307
    return (326);
#line 308
    goto switch_break;
    case_30: /* CIL Label */ 
#line 308
    (yyg->yyextra_r)->Base = 1;
#line 308
    return (327);
#line 309
    goto switch_break;
    case_31: /* CIL Label */ 
#line 309
    (yyg->yyextra_r)->Base = 1;
#line 309
    return (328);
#line 310
    goto switch_break;
    case_32: /* CIL Label */ 
#line 310
    return (329);
#line 311
    goto switch_break;
    case_33: /* CIL Label */ 
#line 311
    (yyg->yyextra_r)->Base = 2;
#line 311
    return (330);
#line 312
    goto switch_break;
    case_34: /* CIL Label */ 
#line 312
    (yyg->yyextra_r)->Base = 1;
#line 312
    return (331);
#line 313
    goto switch_break;
    case_35: /* CIL Label */ 
#line 313
    (yyg->yyextra_r)->Base = 1;
#line 313
    return (332);
#line 314
    goto switch_break;
    case_36: /* CIL Label */ 
#line 314
    (yyg->yyextra_r)->Base = 1;
#line 314
    return (333);
#line 315
    goto switch_break;
    case_37: /* CIL Label */ 
#line 315
    (yyg->yyextra_r)->Base = 1;
#line 315
    return (334);
#line 316
    goto switch_break;
    case_38: /* CIL Label */ 
#line 316
    (yyg->yyextra_r)->Base = 1;
#line 316
    return (335);
#line 317
    goto switch_break;
    case_39: /* CIL Label */ 
#line 317
    (yyg->yyextra_r)->Base = 1;
#line 317
    return (336);
#line 318
    goto switch_break;
    case_40: /* CIL Label */ 
#line 318
    return (337);
#line 319
    goto switch_break;
    case_41: /* CIL Label */ 
#line 319
    return (338);
#line 320
    goto switch_break;
    case_42: /* CIL Label */ 
#line 320
    return (339);
#line 321
    goto switch_break;
    case_43: /* CIL Label */ 
#line 321
    return (340);
#line 322
    goto switch_break;
    case_44: /* CIL Label */ 
#line 322
    return (315);
#line 323
    goto switch_break;
    case_45: /* CIL Label */ 
#line 323
    return (341);
#line 324
    goto switch_break;
    case_46: /* CIL Label */ 
#line 324
    (yyg->yyextra_r)->Base = 1;
#line 324
    return (342);
#line 325
    goto switch_break;
    case_47: /* CIL Label */ 
#line 325
    return (343);
#line 326
    goto switch_break;
    case_48: /* CIL Label */ 
#line 326
    return (344);
#line 327
    goto switch_break;
    case_49: /* CIL Label */ 
#line 327
    return (350);
#line 328
    goto switch_break;
    case_50: /* CIL Label */ 
#line 328
    return (345);
#line 329
    goto switch_break;
    case_51: /* CIL Label */ 
#line 329
    return (346);
#line 330
    goto switch_break;
    case_52: /* CIL Label */ 
#line 330
    return (360);
#line 331
    goto switch_break;
    case_53: /* CIL Label */ 
#line 331
    return (361);
#line 332
    goto switch_break;
    case_54: /* CIL Label */ 
#line 332
    return (347);
#line 333
    goto switch_break;
    case_55: /* CIL Label */ 
#line 333
    return (348);
#line 334
    goto switch_break;
    case_56: /* CIL Label */ 
#line 334
    return (352);
#line 335
    goto switch_break;
    case_57: /* CIL Label */ 
#line 335
    return (353);
#line 336
    goto switch_break;
    case_58: /* CIL Label */ 
#line 336
    return (354);
#line 337
    goto switch_break;
    case_59: /* CIL Label */ 
#line 337
    return (355);
#line 338
    goto switch_break;
    case_60: /* CIL Label */ 
#line 338
    return (356);
#line 339
    goto switch_break;
    case_61: /* CIL Label */ 
#line 339
    return (359);
#line 340
    goto switch_break;
    case_62: /* CIL Label */ 
#line 340
    return (357);
#line 341
    goto switch_break;
    case_63: /* CIL Label */ 
#line 341
    return (358);
#line 342
    goto switch_break;
    case_64: /* CIL Label */ 
#line 342
    (yyg->yyextra_r)->Base = 1;
#line 342
    return (362);
#line 343
    goto switch_break;
    case_65: /* CIL Label */ 
#line 343
    (yyg->yyextra_r)->Base = 1;
#line 343
    return (363);
#line 344
    goto switch_break;
    case_66: /* CIL Label */ 
#line 344
    return (364);
#line 345
    goto switch_break;
    case_67: /* CIL Label */ 
#line 345
    return (365);
#line 346
    goto switch_break;
    case_68: /* CIL Label */ 
#line 346
    return (366);
#line 347
    goto switch_break;
    case_69: /* CIL Label */ 
#line 347
    return (367);
#line 348
    goto switch_break;
    case_70: /* CIL Label */ 
#line 348
    return (309);
#line 349
    goto switch_break;
    case_71: /* CIL Label */ 
#line 349
    return (278);
#line 350
    goto switch_break;
    case_72: /* CIL Label */ 
#line 350
    return (310);
#line 351
    goto switch_break;
    case_73: /* CIL Label */ 
#line 351
    return (311);
#line 352
    goto switch_break;
    case_74: /* CIL Label */ 
#line 352
    return (312);
#line 353
    goto switch_break;
    case_75: /* CIL Label */ 
#line 353
    return (313);
#line 354
    goto switch_break;
    case_76: /* CIL Label */ 
#line 354
    return (314);
#line 355
    goto switch_break;
    case_77: /* CIL Label */ 
#line 355
    return (315);
#line 356
    goto switch_break;
    case_78: /* CIL Label */ 
#line 356
    return (316);
#line 357
    goto switch_break;
    case_79: /* CIL Label */ 
#line 357
    return (317);
#line 358
    goto switch_break;
    case_80: /* CIL Label */ 
#line 358
    return (318);
#line 359
    goto switch_break;
    case_81: /* CIL Label */ 
#line 359
    return (279);
#line 360
    goto switch_break;
    case_82: /* CIL Label */ 
#line 360
    return (280);
#line 361
    goto switch_break;
    case_83: /* CIL Label */ 
#line 361
    return (281);
#line 362
    goto switch_break;
    case_84: /* CIL Label */ 
#line 362
    return (282);
#line 363
    goto switch_break;
    case_85: /* CIL Label */ 
#line 363
    return (284);
#line 364
    goto switch_break;
    case_86: /* CIL Label */ 
#line 364
    return (283);
#line 365
    goto switch_break;
    case_87: /* CIL Label */ 
#line 365
    return (285);
#line 366
    goto switch_break;
    case_88: /* CIL Label */ 
#line 366
    return (286);
#line 367
    goto switch_break;
    case_89: /* CIL Label */ 
#line 367
    return (308);
#line 368
    goto switch_break;
    case_90: /* CIL Label */ 
#line 368
    return (287);
#line 369
    goto switch_break;
    case_91: /* CIL Label */ 
#line 369
    return (288);
#line 370
    goto switch_break;
    case_92: /* CIL Label */ 
#line 370
    return (289);
#line 371
    goto switch_break;
    case_93: /* CIL Label */ 
#line 371
    return (290);
#line 372
    goto switch_break;
    case_94: /* CIL Label */ 
#line 372
    return (291);
#line 373
    goto switch_break;
    case_95: /* CIL Label */ 
#line 373
    return (292);
#line 374
    goto switch_break;
    case_96: /* CIL Label */ 
#line 374
    return (294);
#line 375
    goto switch_break;
    case_97: /* CIL Label */ 
#line 375
    return (295);
#line 376
    goto switch_break;
    case_98: /* CIL Label */ 
#line 376
    return (296);
#line 377
    goto switch_break;
    case_99: /* CIL Label */ 
#line 377
    ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno) ++;
#line 378
    goto switch_break;
    case_100: /* CIL Label */ 
#line 378
    return (300);
#line 379
    goto switch_break;
    case_101: /* CIL Label */ 
#line 379
    return (301);
#line 380
    goto switch_break;
    case_102: /* CIL Label */ 
#line 380
    return (302);
#line 381
    goto switch_break;
    case_103: /* CIL Label */ 
#line 381
    return (303);
#line 382
    goto switch_break;
    case_104: /* CIL Label */ 
#line 382
    return (304);
#line 383
    goto switch_break;
    case_105: /* CIL Label */ 
#line 383
    return (305);
#line 384
    goto switch_break;
    case_106: /* CIL Label */ 
#line 384
    return (306);
#line 385
    goto switch_break;
    case_107: /* CIL Label */ ;
#line 386
    goto switch_break;
    case_108: /* CIL Label */ ;
#line 387
    goto switch_break;
    case_109: /* CIL Label */ 
#line 387
    if ((yyg->yyextra_r)->Base != 2) {
#line 387
      *yy_cp = yyg->yy_hold_char;
#line 387
      yy_cp = yyg->yy_full_match;
#line 387
      (yyg->yy_lp) ++;
#line 387
      goto find_rule;
    }
    {
#line 388
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 389
    return (299);
#line 390
    goto switch_break;
    case_110: /* CIL Label */ 
#line 390
    if ((yyg->yyextra_r)->Base != 3) {
#line 390
      *yy_cp = yyg->yy_hold_char;
#line 390
      yy_cp = yyg->yy_full_match;
#line 390
      (yyg->yy_lp) ++;
#line 390
      goto find_rule;
    }
    {
#line 391
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 392
    return (349);
#line 393
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 393
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 394
    return (293);
#line 395
    goto switch_break;
    case_112: /* CIL Label */ 
#line 395
    if ((yyg->yyextra_r)->Base != 0) {
#line 395
      *yy_cp = yyg->yy_hold_char;
#line 395
      yy_cp = yyg->yy_full_match;
#line 395
      (yyg->yy_lp) ++;
#line 395
      goto find_rule;
    }
    {
#line 396
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 397
    return (298);
#line 398
    goto switch_break;
    case_113: /* CIL Label */ 
#line 398
    if ((yyg->yyextra_r)->Base != 1) {
#line 398
      *yy_cp = yyg->yy_hold_char;
#line 398
      yy_cp = yyg->yy_full_match;
#line 398
      (yyg->yy_lp) ++;
#line 398
      goto find_rule;
    }
    {
#line 399
    (yyg->yylval_r)->integer = atoi((char const   *)yyg->yytext_r);
    }
#line 400
    return (297);
#line 401
    goto switch_break;
    case_114: /* CIL Label */ 
    {
#line 401
    (yyg->yylval_r)->str = new_string___0(yyg->yyextra_r, (char const   *)yyg->yytext_r);
    }
#line 402
    return (351);
#line 403
    goto switch_break;
    case_115: /* CIL Label */ 
    {
#line 403
    bsdl_msg((yyg->yyextra_r)->proc_mode, 2, "Illegal character %c (/%03o) at line %d:\n",
             (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)), (int )*(yyg->yytext_r + (yyg->yyleng_r - 1)),
             (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
#line 408
    ((yyg->yyextra_r)->Compile_Errors) ++;
    }
#line 409
    return (368);
#line 410
    goto switch_break;
    case_123: /* CIL Label */ 
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    {
#line 411
    bsdlpop_buffer_state(yyscanner);
    }
#line 412
    if (yyg->yy_buffer_stack) {
#line 412
      tmp___3 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 412
      tmp___3 = (YY_BUFFER_STATE )((void *)0);
    }
#line 412
    if (! tmp___3) {
#line 413
      return (0);
    }
#line 415
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 415
    fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
           (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
    }
#line 416
    goto switch_break;
    case_117: /* CIL Label */ 
#line 2249 "bsdl_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 2252
    *yy_cp = yyg->yy_hold_char;
#line 2255
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 2266
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2267
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 2268
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 2278
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 2282
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 2284
      yy_current_state = yy_get_previous_state___0(yyscanner);
#line 2295
      yy_next_state = yy_try_NUL_trans___0(yy_current_state, yyscanner);
#line 2297
      yy_bp = yyg->yytext_r + 0;
      }
#line 2299
      if (yy_next_state) {
#line 2302
        (yyg->yy_c_buf_p) ++;
#line 2302
        yy_cp = yyg->yy_c_buf_p;
#line 2303
        yy_current_state = yy_next_state;
#line 2304
        goto yy_match;
      } else {
#line 2309
        yy_cp = yyg->yy_c_buf_p;
#line 2310
        goto yy_find_action;
      }
    } else {
      {
#line 2314
      tmp___4 = yy_get_next_buffer___0(yyscanner);
      }
      {
#line 2316
      if (tmp___4 == 1) {
#line 2316
        goto case_1___0;
      }
#line 2345
      if (tmp___4 == 0) {
#line 2345
        goto case_0;
      }
#line 2355
      if (tmp___4 == 2) {
#line 2355
        goto case_2___0;
      }
#line 2314
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 2318
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 2320
      tmp___5 = bsdlwrap(yyscanner);
      }
#line 2320
      if (tmp___5) {
#line 2331
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 2333
        yy_act = (117 + (yyg->yy_start - 1) / 2) + 1;
#line 2334
        goto do_action;
      } else
#line 2339
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 2340
        bsdlrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 2342
      goto switch_break___0;
      case_0: /* CIL Label */ 
      {
#line 2346
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 2349
      yy_current_state = yy_get_previous_state___0(yyscanner);
#line 2351
      yy_cp = yyg->yy_c_buf_p;
#line 2352
      yy_bp = yyg->yytext_r + 0;
      }
#line 2353
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 2356
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 2359
      yy_current_state = yy_get_previous_state___0(yyscanner);
#line 2361
      yy_cp = yyg->yy_c_buf_p;
#line 2362
      yy_bp = yyg->yytext_r + 0;
      }
#line 2363
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 2365
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 2369
    yy_fatal_error___0("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2382 "bsdl_flex.c"
static int yy_get_next_buffer___0(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  int c ;
  int n ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size ;
  void *tmp___10 ;

  {
#line 2384
  yyg = (struct yyguts_t *)yyscanner;
#line 2385
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 2386
  source = yyg->yytext_r;
#line 2390
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 2391
    yy_fatal_error___0("fatal flex scanner internal error--end of buffer missed",
                       yyscanner);
    }
  }
#line 2394
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 2396
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 2401
      return (1);
    } else {
#line 2409
      return (2);
    }
  }
#line 2416
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 2418
  i = 0;
  {
#line 2418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2418
    if (! (i < number_to_move)) {
#line 2418
      goto while_break;
    }
#line 2419
    tmp = dest;
#line 2419
    dest ++;
#line 2419
    tmp___0 = source;
#line 2419
    source ++;
#line 2419
    *tmp = *tmp___0;
#line 2418
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2421
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 2425
    tmp___1 = 0;
#line 2425
    yyg->yy_n_chars = tmp___1;
#line 2425
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 2429
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 2432
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2432
      if (! (num_to_read <= 0)) {
#line 2432
        goto while_break___0;
      }
      {
#line 2435
      yy_fatal_error___0("input buffer overflow, can\'t enlarge buffer because scanner uses REJECT",
                         yyscanner);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2440
    if (num_to_read > 8192) {
#line 2441
      num_to_read = 8192;
    }
#line 2444
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 2444
      c = '*';
#line 2444
      n = 0;
      {
#line 2444
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2444
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 2444
          c = _IO_getc(yyg->yyin_r);
          }
#line 2444
          if (c != -1) {
#line 2444
            if (! (c != 10)) {
#line 2444
              goto while_break___1;
            }
          } else {
#line 2444
            goto while_break___1;
          }
        } else {
#line 2444
          goto while_break___1;
        }
#line 2444
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 2444
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2444
      if (c == 10) {
#line 2444
        tmp___2 = n;
#line 2444
        n ++;
#line 2444
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___2) = (char )c;
      }
#line 2444
      if (c == -1) {
        {
#line 2444
        tmp___3 = ferror(yyg->yyin_r);
        }
#line 2444
        if (tmp___3) {
          {
#line 2444
          yy_fatal_error___0("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 2444
      yyg->yy_n_chars = n;
    } else {
      {
#line 2444
      tmp___4 = __errno_location();
#line 2444
      *tmp___4 = 0;
      }
      {
#line 2444
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 2444
        tmp___8 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 2444
        tmp___7 = (int )tmp___8;
#line 2444
        yyg->yy_n_chars = tmp___7;
        }
#line 2444
        if (tmp___7 == 0) {
          {
#line 2444
          tmp___9 = ferror(yyg->yyin_r);
          }
#line 2444
          if (! tmp___9) {
#line 2444
            goto while_break___2;
          }
        } else {
#line 2444
          goto while_break___2;
        }
        {
#line 2444
        tmp___5 = __errno_location();
        }
#line 2444
        if (*tmp___5 != 4) {
          {
#line 2444
          yy_fatal_error___0("input in flex scanner failed", yyscanner);
          }
#line 2444
          goto while_break___2;
        }
        {
#line 2444
        tmp___6 = __errno_location();
#line 2444
        *tmp___6 = 0;
#line 2444
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 2447
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2450
  if (yyg->yy_n_chars == 0) {
#line 2452
    if (number_to_move == 0) {
      {
#line 2454
      ret_val = 1;
#line 2455
      bsdlrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 2460
      ret_val = 2;
#line 2461
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 2467
    ret_val = 0;
  }
#line 2469
  if ((yy_size_t )(yyg->yy_n_chars + number_to_move) > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 2471
    new_size = (yy_size_t )((yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1));
#line 2472
    tmp___10 = bsdlrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                           new_size, yyscanner);
#line 2472
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 2473
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 2474
      yy_fatal_error___0("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
  }
#line 2477
  yyg->yy_n_chars += number_to_move;
#line 2478
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 2479
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 2481
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 2483
  return (ret_val);
}
}
#line 2488 "bsdl_flex.c"
static yy_state_type yy_get_previous_state___0(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t *yyg ;
  yy_state_type *tmp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp___0 ;
  yy_state_type *tmp___1 ;

  {
#line 2492
  yyg = (struct yyguts_t *)yyscanner;
#line 2494
  yy_current_state = yyg->yy_start;
#line 2496
  yyg->yy_state_ptr = yyg->yy_state_buf;
#line 2497
  tmp = yyg->yy_state_ptr;
#line 2497
  (yyg->yy_state_ptr) ++;
#line 2497
  *tmp = yy_current_state;
#line 2499
  yy_cp = yyg->yytext_r + 0;
  {
#line 2499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2499
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 2499
      goto while_break;
    }
#line 2501
    if (*yy_cp) {
#line 2501
      tmp___0 = yy_ec___0[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 2501
      tmp___0 = (flex_int32_t const   )1;
    }
#line 2501
    yy_c = (YY_CHAR )tmp___0;
    {
#line 2502
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2502
      if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2502
        goto while_break___0;
      }
#line 2504
      yy_current_state = (int )yy_def___0[yy_current_state];
#line 2505
      if (yy_current_state >= 709) {
#line 2506
        yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2508
    yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 2509
    tmp___1 = yyg->yy_state_ptr;
#line 2509
    (yyg->yy_state_ptr) ++;
#line 2509
    *tmp___1 = yy_current_state;
#line 2499
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2512
  return (yy_current_state);
}
}
#line 2520 "bsdl_flex.c"
static yy_state_type yy_try_NUL_trans___0(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t *yyg ;
  register YY_CHAR yy_c ;
  yy_state_type *tmp ;
  int tmp___0 ;

  {
#line 2523
  yyg = (struct yyguts_t *)yyscanner;
#line 2525
  yy_c = (YY_CHAR )1;
  {
#line 2526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2526
    if (! ((int const   )yy_chk___0[(int const   )yy_base___0[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 2526
      goto while_break;
    }
#line 2528
    yy_current_state = (int )yy_def___0[yy_current_state];
#line 2529
    if (yy_current_state >= 709) {
#line 2530
      yy_c = (YY_CHAR )yy_meta___0[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2532
  yy_current_state = (yy_state_type )yy_nxt___0[(unsigned int )yy_base___0[yy_current_state] + (unsigned int )yy_c];
#line 2533
  yy_is_jam = yy_current_state == 708;
#line 2534
  if (! yy_is_jam) {
#line 2535
    tmp = yyg->yy_state_ptr;
#line 2535
    (yyg->yy_state_ptr) ++;
#line 2535
    *tmp = yy_current_state;
  }
#line 2537
  if (yy_is_jam) {
#line 2537
    tmp___0 = 0;
  } else {
#line 2537
    tmp___0 = yy_current_state;
  }
#line 2537
  return (tmp___0);
}
}
#line 2658 "bsdl_flex.c"
void bsdlrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2660
  yyg = (struct yyguts_t *)yyscanner;
#line 2662
  if (yyg->yy_buffer_stack) {
#line 2662
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2662
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2662
  if (! tmp) {
    {
#line 2663
    bsdlensure_buffer_stack(yyscanner);
#line 2664
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = bsdl_create_buffer(yyg->yyin_r,
                                                                            16384,
                                                                            yyscanner);
    }
  }
#line 2668
  if (yyg->yy_buffer_stack) {
#line 2668
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2668
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2668
  bsdl_init_buffer(tmp___0, input_file, yyscanner);
#line 2669
  bsdl_load_buffer_state(yyscanner);
  }
#line 2670
  return;
}
}
#line 2676 "bsdl_flex.c"
void bsdl_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2678
  yyg = (struct yyguts_t *)yyscanner;
#line 2685
  bsdlensure_buffer_stack(yyscanner);
  }
#line 2686
  if (yyg->yy_buffer_stack) {
#line 2686
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2686
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2686
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 2687
    return;
  }
#line 2689
  if (yyg->yy_buffer_stack) {
#line 2689
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2689
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2689
  if (tmp___0) {
#line 2692
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2693
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2694
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 2697
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2698
  bsdl_load_buffer_state(yyscanner);
#line 2705
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2706
  return;
}
}
#line 2708 "bsdl_flex.c"
static void bsdl_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  char *tmp ;

  {
#line 2710
  yyg = (struct yyguts_t *)yyscanner;
#line 2711
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 2712
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 2712
  yyg->yy_c_buf_p = tmp;
#line 2712
  yyg->yytext_r = tmp;
#line 2713
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 2714
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 2715
  return;
}
}
#line 2723 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2727
  tmp = bsdlalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 2727
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2728
  if (! b) {
    {
#line 2729
    yy_fatal_error___0("out of dynamic memory in bsdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2731
  b->yy_buf_size = (yy_size_t )size;
#line 2736
  tmp___0 = bsdlalloc(b->yy_buf_size + 2UL, yyscanner);
#line 2736
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 2737
  if (! b->yy_ch_buf) {
    {
#line 2738
    yy_fatal_error___0("out of dynamic memory in bsdl_create_buffer()", yyscanner);
    }
  }
  {
#line 2740
  b->yy_is_our_buffer = 1;
#line 2742
  bsdl_init_buffer(b, file, yyscanner);
  }
#line 2744
  return (b);
}
}
#line 2751 "bsdl_flex.c"
void bsdl_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2753
  yyg = (struct yyguts_t *)yyscanner;
#line 2755
  if (! b) {
#line 2756
    return;
  }
#line 2758
  if (yyg->yy_buffer_stack) {
#line 2758
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2758
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2758
  if ((unsigned long )b == (unsigned long )tmp) {
#line 2759
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 2761
  if (b->yy_is_our_buffer) {
    {
#line 2762
    bsdlfree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 2764
  bsdlfree((void *)b, yyscanner);
  }
#line 2765
  return;
}
}
#line 2775 "bsdl_flex.c"
static void bsdl_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 2778
  tmp = __errno_location();
#line 2778
  oerrno = *tmp;
#line 2779
  yyg = (struct yyguts_t *)yyscanner;
#line 2781
  bsdl_flush_buffer(b, yyscanner);
#line 2783
  b->yy_input_file = file;
#line 2784
  b->yy_fill_buffer = 1;
  }
#line 2790
  if (yyg->yy_buffer_stack) {
#line 2790
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2790
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2790
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 2791
    b->yy_bs_lineno = 1;
#line 2792
    b->yy_bs_column = 0;
  }
#line 2795
  if (file) {
    {
#line 2795
    tmp___1 = fileno(file);
#line 2795
    tmp___2 = isatty(tmp___1);
#line 2795
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 2795
    b->yy_is_interactive = 0;
  }
  {
#line 2797
  tmp___3 = __errno_location();
#line 2797
  *tmp___3 = oerrno;
  }
#line 2798
  return;
}
}
#line 2804 "bsdl_flex.c"
void bsdl_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 2806
  yyg = (struct yyguts_t *)yyscanner;
#line 2807
  if (! b) {
#line 2808
    return;
  }
#line 2810
  b->yy_n_chars = 0;
#line 2816
  *(b->yy_ch_buf + 0) = (char)0;
#line 2817
  *(b->yy_ch_buf + 1) = (char)0;
#line 2819
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2821
  b->yy_at_bol = 1;
#line 2822
  b->yy_buffer_status = 0;
#line 2824
  if (yyg->yy_buffer_stack) {
#line 2824
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2824
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2824
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2825
    bsdl_load_buffer_state(yyscanner);
    }
  }
#line 2826
  return;
}
}
#line 2834 "bsdl_flex.c"
void bsdlpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2836
  yyg = (struct yyguts_t *)yyscanner;
#line 2837
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2838
    return;
  }
  {
#line 2840
  bsdlensure_buffer_stack(yyscanner);
  }
#line 2843
  if (yyg->yy_buffer_stack) {
#line 2843
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2843
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2843
  if (tmp) {
#line 2846
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 2847
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 2848
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 2852
  if (yyg->yy_buffer_stack) {
#line 2852
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2852
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2852
  if (tmp___0) {
#line 2853
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 2854
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 2857
  bsdl_load_buffer_state(yyscanner);
#line 2858
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 2859
  return;
}
}
#line 2865 "bsdl_flex.c"
void bsdlpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2867
  yyg = (struct yyguts_t *)yyscanner;
#line 2868
  if (yyg->yy_buffer_stack) {
#line 2868
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2868
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2868
  if (! tmp) {
#line 2869
    return;
  }
#line 2871
  if (yyg->yy_buffer_stack) {
#line 2871
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2871
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2871
  bsdl_delete_buffer(tmp___0, yyscanner);
#line 2872
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2873
  if (yyg->yy_buffer_stack_top > 0UL) {
#line 2874
    (yyg->yy_buffer_stack_top) --;
  }
#line 2876
  if (yyg->yy_buffer_stack) {
#line 2876
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 2876
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2876
  if (tmp___1) {
    {
#line 2877
    bsdl_load_buffer_state(yyscanner);
#line 2878
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2880
  return;
}
}
#line 2885 "bsdl_flex.c"
static void bsdlensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 2888
  yyg = (struct yyguts_t *)yyscanner;
#line 2890
  if (! yyg->yy_buffer_stack) {
    {
#line 2896
    num_to_alloc = 1;
#line 2897
    tmp = bsdlalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *),
                    yyscanner);
#line 2897
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2900
    if (! yyg->yy_buffer_stack) {
      {
#line 2901
      yy_fatal_error___0("out of dynamic memory in bsdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2903
    memset((void *)yyg->yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2905
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2906
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 2907
    return;
  }
#line 2910
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1UL) {
    {
#line 2913
    grow_size = 8;
#line 2915
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 2916
    tmp___0 = bsdlrealloc((void *)yyg->yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *),
                          yyscanner);
#line 2916
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2920
    if (! yyg->yy_buffer_stack) {
      {
#line 2921
      yy_fatal_error___0("out of dynamic memory in bsdlensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 2924
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2925
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2927
  return;
}
}
#line 2935 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2939
  if (size < 2UL) {
#line 2943
    return ((YY_BUFFER_STATE )0);
  } else
#line 2939
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2943
    return ((YY_BUFFER_STATE )0);
  } else
#line 2939
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2943
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2945
  tmp = bsdlalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 2945
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2946
  if (! b) {
    {
#line 2947
    yy_fatal_error___0("out of dynamic memory in bsdl_scan_buffer()", yyscanner);
    }
  }
  {
#line 2949
  b->yy_buf_size = size - 2UL;
#line 2950
  tmp___0 = base;
#line 2950
  b->yy_ch_buf = tmp___0;
#line 2950
  b->yy_buf_pos = tmp___0;
#line 2951
  b->yy_is_our_buffer = 0;
#line 2952
  b->yy_input_file = (FILE *)0;
#line 2953
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2954
  b->yy_is_interactive = 0;
#line 2955
  b->yy_at_bol = 1;
#line 2956
  b->yy_fill_buffer = 0;
#line 2957
  b->yy_buffer_status = 0;
#line 2959
  bsdl_switch_to_buffer(b, yyscanner);
  }
#line 2961
  return (b);
}
}
#line 2972 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2975
  tmp = strlen(yystr);
#line 2975
  tmp___0 = bsdl_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 2975
  return (tmp___0);
}
}
#line 2985 "bsdl_flex.c"
YY_BUFFER_STATE bsdl_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2993
  n = (yy_size_t )(_yybytes_len + 2);
#line 2994
  tmp = bsdlalloc(n, yyscanner);
#line 2994
  buf = (char *)tmp;
  }
#line 2995
  if (! buf) {
    {
#line 2996
    yy_fatal_error___0("out of dynamic memory in bsdl_scan_bytes()", yyscanner);
    }
  }
#line 2998
  i = 0;
  {
#line 2998
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2998
    if (! (i < _yybytes_len)) {
#line 2998
      goto while_break;
    }
#line 2999
    *(buf + i) = (char )*(yybytes + i);
#line 2998
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3001
  tmp___0 = (char)0;
#line 3001
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 3001
  *(buf + _yybytes_len) = tmp___0;
#line 3003
  b = bsdl_scan_buffer(buf, n, yyscanner);
  }
#line 3004
  if (! b) {
    {
#line 3005
    yy_fatal_error___0("bad buffer in bsdl_scan_bytes()", yyscanner);
    }
  }
#line 3010
  b->yy_is_our_buffer = 1;
#line 3012
  return (b);
}
}
#line 3019 "bsdl_flex.c"
static void yy_fatal_error___0(char const   *msg , yyscan_t yyscanner ) 
{ 


  {
  {
#line 3021
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 3022
  exit(2);
  }
}
}
#line 3047 "bsdl_flex.c"
scan_extra_t *bsdlget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3049
  yyg = (struct yyguts_t *)yyscanner;
#line 3050
  return (yyg->yyextra_r);
}
}
#line 3056 "bsdl_flex.c"
int bsdlget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 3058
  yyg = (struct yyguts_t *)yyscanner;
#line 3060
  if (yyg->yy_buffer_stack) {
#line 3060
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3060
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3060
  if (! tmp) {
#line 3061
    return (0);
  }
#line 3063
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 3069 "bsdl_flex.c"
int bsdlget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 3071
  yyg = (struct yyguts_t *)yyscanner;
#line 3073
  if (yyg->yy_buffer_stack) {
#line 3073
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3073
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3073
  if (! tmp) {
#line 3074
    return (0);
  }
#line 3076
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 3082 "bsdl_flex.c"
FILE *bsdlget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3084
  yyg = (struct yyguts_t *)yyscanner;
#line 3085
  return (yyg->yyin_r);
}
}
#line 3091 "bsdl_flex.c"
FILE *bsdlget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3093
  yyg = (struct yyguts_t *)yyscanner;
#line 3094
  return (yyg->yyout_r);
}
}
#line 3100 "bsdl_flex.c"
int bsdlget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3102
  yyg = (struct yyguts_t *)yyscanner;
#line 3103
  return (yyg->yyleng_r);
}
}
#line 3110 "bsdl_flex.c"
char *bsdlget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3112
  yyg = (struct yyguts_t *)yyscanner;
#line 3113
  return (yyg->yytext_r);
}
}
#line 3120 "bsdl_flex.c"
void bsdlset_extra(scan_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3122
  yyg = (struct yyguts_t *)yyscanner;
#line 3123
  yyg->yyextra_r = user_defined;
#line 3124
  return;
}
}
#line 3130 "bsdl_flex.c"
void bsdlset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 3132
  yyg = (struct yyguts_t *)yyscanner;
#line 3135
  if (yyg->yy_buffer_stack) {
#line 3135
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3135
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3135
  if (! tmp) {
    {
#line 3136
    yy_fatal_error___0("bsdlset_lineno called with no buffer", yyscanner);
    }
  }
#line 3138
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 3139
  return;
}
}
#line 3145 "bsdl_flex.c"
void bsdlset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 3147
  yyg = (struct yyguts_t *)yyscanner;
#line 3150
  if (yyg->yy_buffer_stack) {
#line 3150
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 3150
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 3150
  if (! tmp) {
    {
#line 3151
    yy_fatal_error___0("bsdlset_column called with no buffer", yyscanner);
    }
  }
#line 3153
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 3154
  return;
}
}
#line 3162 "bsdl_flex.c"
void bsdlset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3164
  yyg = (struct yyguts_t *)yyscanner;
#line 3165
  yyg->yyin_r = in_str;
#line 3166
  return;
}
}
#line 3168 "bsdl_flex.c"
void bsdlset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3170
  yyg = (struct yyguts_t *)yyscanner;
#line 3171
  yyg->yyout_r = out_str;
#line 3172
  return;
}
}
#line 3174 "bsdl_flex.c"
int bsdlget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3176
  yyg = (struct yyguts_t *)yyscanner;
#line 3177
  return (yyg->yy_flex_debug_r);
}
}
#line 3180 "bsdl_flex.c"
void bsdlset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3182
  yyg = (struct yyguts_t *)yyscanner;
#line 3183
  yyg->yy_flex_debug_r = bdebug;
#line 3184
  return;
}
}
#line 3188 "bsdl_flex.c"
YYSTYPE *bsdlget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3190
  yyg = (struct yyguts_t *)yyscanner;
#line 3191
  return (yyg->yylval_r);
}
}
#line 3194 "bsdl_flex.c"
void bsdlset_lval(YYSTYPE *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3196
  yyg = (struct yyguts_t *)yyscanner;
#line 3197
  yyg->yylval_r = yylval_param;
#line 3198
  return;
}
}
#line 3207 "bsdl_flex.c"
int bsdllex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 3210
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3211
    tmp = __errno_location();
#line 3211
    *tmp = 22;
    }
#line 3212
    return (1);
  }
  {
#line 3215
  tmp___0 = bsdlalloc(sizeof(struct yyguts_t ), (void *)0);
#line 3215
  *ptr_yy_globals = tmp___0;
  }
#line 3217
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3218
    tmp___1 = __errno_location();
#line 3218
    *tmp___1 = 12;
    }
#line 3219
    return (1);
  }
  {
#line 3223
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 3225
  tmp___2 = yy_init_globals___0(*ptr_yy_globals);
  }
#line 3225
  return (tmp___2);
}
}
#line 3236 "bsdl_flex.c"
int bsdllex_init_extra(scan_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3241
  bsdlset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 3243
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3244
    tmp = __errno_location();
#line 3244
    *tmp = 22;
    }
#line 3245
    return (1);
  }
  {
#line 3248
  tmp___0 = bsdlalloc(sizeof(struct yyguts_t ), (yyscan_t )(& dummy_yyguts));
#line 3248
  *ptr_yy_globals = tmp___0;
  }
#line 3250
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 3251
    tmp___1 = __errno_location();
#line 3251
    *tmp___1 = 12;
    }
#line 3252
    return (1);
  }
  {
#line 3257
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t ));
#line 3259
  bsdlset_extra(yy_user_defined, *ptr_yy_globals);
#line 3261
  tmp___2 = yy_init_globals___0(*ptr_yy_globals);
  }
#line 3261
  return (tmp___2);
}
}
#line 3264 "bsdl_flex.c"
static int yy_init_globals___0(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;

  {
#line 3266
  yyg = (struct yyguts_t *)yyscanner;
#line 3271
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 3272
  yyg->yy_buffer_stack_top = (size_t )0;
#line 3273
  yyg->yy_buffer_stack_max = (size_t )0;
#line 3274
  yyg->yy_c_buf_p = (char *)0;
#line 3275
  yyg->yy_init = 0;
#line 3276
  yyg->yy_start = 0;
#line 3278
  yyg->yy_start_stack_ptr = 0;
#line 3279
  yyg->yy_start_stack_depth = 0;
#line 3280
  yyg->yy_start_stack = (int *)((void *)0);
#line 3282
  yyg->yy_state_buf = (yy_state_type *)0;
#line 3283
  yyg->yy_state_ptr = (yy_state_type *)0;
#line 3284
  yyg->yy_full_match = (char *)0;
#line 3285
  yyg->yy_lp = 0;
#line 3292
  yyg->yyin_r = (FILE *)0;
#line 3293
  yyg->yyout_r = (FILE *)0;
#line 3299
  return (0);
}
}
#line 3303 "bsdl_flex.c"
int bsdllex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 3305
  yyg = (struct yyguts_t *)yyscanner;
  {
#line 3308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3308
    if (yyg->yy_buffer_stack) {
#line 3308
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 3308
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 3308
    if (! tmp___0) {
#line 3308
      goto while_break;
    }
#line 3309
    if (yyg->yy_buffer_stack) {
#line 3309
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 3309
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 3309
    bsdl_delete_buffer(tmp, yyscanner);
#line 3310
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 3311
    bsdlpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3315
  bsdlfree((void *)yyg->yy_buffer_stack, yyscanner);
#line 3316
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 3319
  bsdlfree((void *)yyg->yy_start_stack, yyscanner);
#line 3320
  yyg->yy_start_stack = (int *)((void *)0);
#line 3322
  bsdlfree((void *)yyg->yy_state_buf, yyscanner);
#line 3323
  yyg->yy_state_buf = (yy_state_type *)((void *)0);
#line 3327
  yy_init_globals___0(yyscanner);
#line 3330
  bsdlfree(yyscanner, yyscanner);
#line 3331
  yyscanner = (void *)0;
  }
#line 3332
  return (0);
}
}
#line 3359 "bsdl_flex.c"
void *bsdlalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 3361
  tmp = malloc(size);
  }
#line 3361
  return (tmp);
}
}
#line 3364 "bsdl_flex.c"
void *bsdlrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 3373
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 3373
  return (tmp);
}
}
#line 3376 "bsdl_flex.c"
void bsdlfree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 3378
  free((void *)((char *)ptr));
  }
#line 3379
  return;
}
}
#line 428 "bsdl_flex.l"
void *bsdl_flex_init(int proc_mode ) 
{ 
  scan_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  void *tmp___0 ;

  {
  {
#line 434
  tmp = bsdllex_init(& scanner);
  }
#line 434
  if (tmp != 0) {
    {
#line 436
    bsdl_msg(proc_mode, 3, "Scanner could not be initialized\n");
    }
#line 438
    return ((void *)0);
  }
  {
#line 441
  tmp___0 = malloc(sizeof(scan_extra_t ));
#line 441
  extra = (scan_extra_t *)tmp___0;
  }
#line 441
  if (! extra) {
    {
#line 442
    bsdl_msg(proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_flex.l", 443);
#line 444
    bsdllex_destroy(scanner);
    }
#line 445
    return ((void *)0);
  }
  {
#line 448
  extra->proc_mode = proc_mode;
#line 449
  extra->Compile_Errors = 0;
#line 450
  extra->Base = 1;
#line 452
  bsdlset_extra(extra, scanner);
  }
#line 454
  return (scanner);
}
}
#line 469 "bsdl_flex.l"
void bsdl_flex_deinit(void *scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;
  scan_extra_t *tmp___1 ;

  {
  {
#line 471
  tmp___0 = bsdlget_in(scanner);
  }
#line 471
  if (tmp___0) {
    {
#line 475
    tmp = bsdlget_in(scanner);
#line 475
    fclose(tmp);
#line 476
    bsdlset_in((FILE *)((void *)0), scanner);
    }
  }
  {
#line 478
  tmp___1 = bsdlget_extra(scanner);
#line 478
  free((void *)tmp___1);
#line 479
  bsdllex_destroy(scanner);
  }
#line 480
  return;
}
}
#line 494 "bsdl_flex.l"
int bsdlwrap(yyscan_t scanner ) 
{ 
  FILE *tmp ;
  FILE *tmp___0 ;

  {
  {
#line 496
  tmp___0 = bsdlget_in(scanner);
  }
#line 496
  if (tmp___0) {
    {
#line 497
    tmp = bsdlget_in(scanner);
#line 497
    fclose(tmp);
#line 498
    bsdlset_in((FILE *)((void *)0), scanner);
    }
  }
#line 500
  return (1);
}
}
#line 516 "bsdl_flex.l"
static char *new_string___0(scan_extra_t *extra , char const   *str ) 
{ 
  char *n_str ;
  size_t n_str_size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 521
  tmp = strlen(str);
#line 521
  n_str_size = tmp + 1UL;
#line 522
  tmp___0 = malloc(n_str_size);
#line 522
  n_str = (char *)tmp___0;
  }
#line 522
  if (n_str) {
    {
#line 524
    strncpy((char */* __restrict  */)n_str, (char const   */* __restrict  */)str,
            n_str_size - 1UL);
#line 525
    *(n_str + (n_str_size - 1UL)) = (char )'\000';
    }
  } else {
    {
#line 528
    bsdl_msg(extra->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_flex.l", 529);
    }
  }
#line 531
  return (n_str);
}
}
#line 548 "bsdl_flex.l"
void bsdl_flex_switch_buffer(void *scanner , char const   *buffer , int lineno ) 
{ 
  struct yyguts_t *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 552
  yyg = (struct yyguts_t *)scanner;
#line 560
  if (yyg->yy_buffer_stack) {
#line 560
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 560
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 560
  bsdlpush_buffer_state(tmp, scanner);
#line 561
  bsdl_scan_string(buffer, scanner);
#line 562
  bsdlset_lineno(lineno, scanner);
  }
#line 563
  return;
}
}
#line 577 "bsdl_flex.l"
void bsdl_flex_stop_buffer(void *scanner ) 
{ 


  {
  {
#line 579
  bsdlpop_buffer_state(scanner);
  }
#line 582
  return;
}
}
#line 596 "bsdl_flex.l"
int bsdl_flex_get_compile_errors(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 598
  tmp = bsdlget_extra(scanner);
#line 598
  extra = tmp;
  }
#line 599
  return (extra->Compile_Errors);
}
}
#line 615 "bsdl_flex.l"
static void bsdl_flex_set_compile_errors(int n , yyscan_t scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 617
  tmp = bsdlget_extra(scanner);
#line 617
  extra = tmp;
#line 618
  extra->Compile_Errors = n;
  }
#line 619
  return;
}
}
#line 633 "bsdl_flex.l"
int bsdl_flex_postinc_compile_errors(void *scanner ) 
{ 
  int errors ;
  int tmp ;

  {
  {
#line 635
  tmp = bsdl_flex_get_compile_errors(scanner);
#line 635
  errors = tmp;
#line 637
  bsdl_flex_set_compile_errors(errors + 1, scanner);
  }
#line 638
  return (errors);
}
}
#line 653 "bsdl_flex.l"
void bsdl_flex_set_bin_x(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 655
  tmp = bsdlget_extra(scanner);
#line 655
  extra = tmp;
#line 656
  extra->Base = 2;
  }
#line 657
  return;
}
}
#line 671 "bsdl_flex.l"
void bsdl_flex_set_hex(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 673
  tmp = bsdlget_extra(scanner);
#line 673
  extra = tmp;
#line 674
  extra->Base = 3;
  }
#line 675
  return;
}
}
#line 689 "bsdl_flex.l"
void bsdl_flex_set_decimal(void *scanner ) 
{ 
  scan_extra_t *extra ;
  scan_extra_t *tmp ;

  {
  {
#line 691
  tmp = bsdlget_extra(scanner);
#line 691
  extra = tmp;
#line 692
  extra->Base = 1;
  }
#line 693
  return;
}
}
#line 155 "bsdl_bison.y"
static void Print_Error___0(bsdl_parser_priv_t *priv_data , char const   *Errmess ) ;
#line 156
static void Print_Warning(bsdl_parser_priv_t *priv_data , char const   *Warnmess ) ;
#line 157
static void Give_Up_And_Quit___0(bsdl_parser_priv_t *priv_data ) ;
#line 160
static void add_instruction(bsdl_parser_priv_t *priv , char *instr , char *opcode ) ;
#line 161
static void ac_set_register(bsdl_parser_priv_t *priv , char *reg , int reg_len ) ;
#line 162
static void ac_add_instruction(bsdl_parser_priv_t *priv , char *instr ) ;
#line 163
static void ac_apply_assoc(bsdl_parser_priv_t *priv ) ;
#line 164
static void prt_add_name(bsdl_parser_priv_t *priv , char *name ) ;
#line 165
static void prt_add_bit(bsdl_parser_priv_t *priv ) ;
#line 166
static void prt_add_range(bsdl_parser_priv_t *priv , int low , int high ) ;
#line 167
static void ci_no_disable(bsdl_parser_priv_t *priv ) ;
#line 168
static void ci_set_cell_spec_disable(bsdl_parser_priv_t *priv , int ctrl_bit_num ,
                                     int safe_value , int disable_value ) ;
#line 169
static void ci_set_cell_spec(bsdl_parser_priv_t *priv , int function , char *safe_value ) ;
#line 170
static void ci_append_cell_info(bsdl_parser_priv_t *priv , int bit_num ) ;
#line 172
void bsdlerror(bsdl_parser_priv_t *priv_data , char const   *error_string ) ;
#line 631 "bsdl_bison.c"
static yytype_uint8 const   yytranslate___0[369]  = 
#line 631 "bsdl_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )113};
#line 917 "bsdl_bison.c"
static yytype_uint8 const   yyr1___0[286]  = 
#line 917
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )114,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115,      (yytype_uint8 const   )115, 
        (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )117,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )119,      (yytype_uint8 const   )119,      (yytype_uint8 const   )120,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )121,      (yytype_uint8 const   )121,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )127,      (yytype_uint8 const   )128,      (yytype_uint8 const   )129,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )129,      (yytype_uint8 const   )130,      (yytype_uint8 const   )131,      (yytype_uint8 const   )131, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )136,      (yytype_uint8 const   )137,      (yytype_uint8 const   )137,      (yytype_uint8 const   )137, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )139,      (yytype_uint8 const   )140,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )142,      (yytype_uint8 const   )143,      (yytype_uint8 const   )144, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )145,      (yytype_uint8 const   )145,      (yytype_uint8 const   )145, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )145,      (yytype_uint8 const   )146,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147, 
        (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )147,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )149,      (yytype_uint8 const   )150,      (yytype_uint8 const   )151,      (yytype_uint8 const   )151, 
        (yytype_uint8 const   )151,      (yytype_uint8 const   )152,      (yytype_uint8 const   )153,      (yytype_uint8 const   )153, 
        (yytype_uint8 const   )154,      (yytype_uint8 const   )155,      (yytype_uint8 const   )155,      (yytype_uint8 const   )155, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156,      (yytype_uint8 const   )156, 
        (yytype_uint8 const   )156,      (yytype_uint8 const   )157,      (yytype_uint8 const   )157,      (yytype_uint8 const   )158, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )159,      (yytype_uint8 const   )159,      (yytype_uint8 const   )159, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )159,      (yytype_uint8 const   )160,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )161,      (yytype_uint8 const   )163,      (yytype_uint8 const   )163,      (yytype_uint8 const   )164, 
        (yytype_uint8 const   )164,      (yytype_uint8 const   )164,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165,      (yytype_uint8 const   )165, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )166,      (yytype_uint8 const   )167,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )168,      (yytype_uint8 const   )168,      (yytype_uint8 const   )169,      (yytype_uint8 const   )170, 
        (yytype_uint8 const   )170,      (yytype_uint8 const   )170,      (yytype_uint8 const   )171,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )172,      (yytype_uint8 const   )173,      (yytype_uint8 const   )173,      (yytype_uint8 const   )174, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )176,      (yytype_uint8 const   )176,      (yytype_uint8 const   )177, 
        (yytype_uint8 const   )178,      (yytype_uint8 const   )179,      (yytype_uint8 const   )180,      (yytype_uint8 const   )181, 
        (yytype_uint8 const   )181,      (yytype_uint8 const   )182,      (yytype_uint8 const   )182,      (yytype_uint8 const   )183, 
        (yytype_uint8 const   )184,      (yytype_uint8 const   )184,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )185,      (yytype_uint8 const   )186,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )186,      (yytype_uint8 const   )186,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )187,      (yytype_uint8 const   )187,      (yytype_uint8 const   )188, 
        (yytype_uint8 const   )188,      (yytype_uint8 const   )188,      (yytype_uint8 const   )188,      (yytype_uint8 const   )188, 
        (yytype_uint8 const   )189,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191,      (yytype_uint8 const   )192, 
        (yytype_uint8 const   )192,      (yytype_uint8 const   )193,      (yytype_uint8 const   )193,      (yytype_uint8 const   )194, 
        (yytype_uint8 const   )195,      (yytype_uint8 const   )195,      (yytype_uint8 const   )196,      (yytype_uint8 const   )197, 
        (yytype_uint8 const   )197,      (yytype_uint8 const   )198,      (yytype_uint8 const   )198,      (yytype_uint8 const   )198, 
        (yytype_uint8 const   )198,      (yytype_uint8 const   )199,      (yytype_uint8 const   )199,      (yytype_uint8 const   )200, 
        (yytype_uint8 const   )201,      (yytype_uint8 const   )200,      (yytype_uint8 const   )202,      (yytype_uint8 const   )202, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )203,      (yytype_uint8 const   )203,      (yytype_uint8 const   )203, 
        (yytype_uint8 const   )205,      (yytype_uint8 const   )204,      (yytype_uint8 const   )204,      (yytype_uint8 const   )206, 
        (yytype_uint8 const   )206,      (yytype_uint8 const   )207,      (yytype_uint8 const   )207,      (yytype_uint8 const   )208, 
        (yytype_uint8 const   )208,      (yytype_uint8 const   )210,      (yytype_uint8 const   )209,      (yytype_uint8 const   )211, 
        (yytype_uint8 const   )211,      (yytype_uint8 const   )211,      (yytype_uint8 const   )211,      (yytype_uint8 const   )212, 
        (yytype_uint8 const   )212,      (yytype_uint8 const   )213,      (yytype_uint8 const   )213,      (yytype_uint8 const   )213, 
        (yytype_uint8 const   )213,      (yytype_uint8 const   )214,      (yytype_uint8 const   )214,      (yytype_uint8 const   )214, 
        (yytype_uint8 const   )214,      (yytype_uint8 const   )215,      (yytype_uint8 const   )215,      (yytype_uint8 const   )215, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )216,      (yytype_uint8 const   )216,      (yytype_uint8 const   )217, 
        (yytype_uint8 const   )218,      (yytype_uint8 const   )219,      (yytype_uint8 const   )219,      (yytype_uint8 const   )219, 
        (yytype_uint8 const   )219,      (yytype_uint8 const   )220,      (yytype_uint8 const   )221,      (yytype_uint8 const   )222, 
        (yytype_uint8 const   )223,      (yytype_uint8 const   )224,      (yytype_uint8 const   )225,      (yytype_uint8 const   )226, 
        (yytype_uint8 const   )227,      (yytype_uint8 const   )227,      (yytype_uint8 const   )228,      (yytype_uint8 const   )228, 
        (yytype_uint8 const   )228,      (yytype_uint8 const   )229,      (yytype_uint8 const   )229,      (yytype_uint8 const   )230, 
        (yytype_uint8 const   )231,      (yytype_uint8 const   )231,      (yytype_uint8 const   )232,      (yytype_uint8 const   )232, 
        (yytype_uint8 const   )232,      (yytype_uint8 const   )232,      (yytype_uint8 const   )232,      (yytype_uint8 const   )233, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )234,      (yytype_uint8 const   )235,      (yytype_uint8 const   )235,      (yytype_uint8 const   )236, 
        (yytype_uint8 const   )237,      (yytype_uint8 const   )237};
#line 951 "bsdl_bison.c"
static yytype_uint8 const   yyr2___0[286]  = 
#line 951
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3};
#line 987 "bsdl_bison.c"
static yytype_uint16 const   yydefact___0[441]  = 
#line 987
  {      (yytype_uint16 const   )0,      (yytype_uint16 const   )23,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )145,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )2,      (yytype_uint16 const   )3,      (yytype_uint16 const   )4, 
        (yytype_uint16 const   )5,      (yytype_uint16 const   )6,      (yytype_uint16 const   )7,      (yytype_uint16 const   )8, 
        (yytype_uint16 const   )9,      (yytype_uint16 const   )10,      (yytype_uint16 const   )11,      (yytype_uint16 const   )12, 
        (yytype_uint16 const   )13,      (yytype_uint16 const   )14,      (yytype_uint16 const   )15,      (yytype_uint16 const   )16, 
        (yytype_uint16 const   )17,      (yytype_uint16 const   )18,      (yytype_uint16 const   )19,      (yytype_uint16 const   )20, 
        (yytype_uint16 const   )21,      (yytype_uint16 const   )22,      (yytype_uint16 const   )122,      (yytype_uint16 const   )123, 
        (yytype_uint16 const   )124,      (yytype_uint16 const   )125,      (yytype_uint16 const   )126,      (yytype_uint16 const   )127, 
        (yytype_uint16 const   )128,      (yytype_uint16 const   )129,      (yytype_uint16 const   )130,      (yytype_uint16 const   )131, 
        (yytype_uint16 const   )24,      (yytype_uint16 const   )0,      (yytype_uint16 const   )25,      (yytype_uint16 const   )35, 
        (yytype_uint16 const   )36,      (yytype_uint16 const   )37,      (yytype_uint16 const   )38,      (yytype_uint16 const   )39, 
        (yytype_uint16 const   )40,      (yytype_uint16 const   )44,      (yytype_uint16 const   )0,      (yytype_uint16 const   )41, 
        (yytype_uint16 const   )42,      (yytype_uint16 const   )49,      (yytype_uint16 const   )50,      (yytype_uint16 const   )51, 
        (yytype_uint16 const   )55,      (yytype_uint16 const   )56,      (yytype_uint16 const   )52,      (yytype_uint16 const   )53, 
        (yytype_uint16 const   )65,      (yytype_uint16 const   )69,      (yytype_uint16 const   )0,      (yytype_uint16 const   )66, 
        (yytype_uint16 const   )67,      (yytype_uint16 const   )68,      (yytype_uint16 const   )59,      (yytype_uint16 const   )60, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )63,      (yytype_uint16 const   )84,      (yytype_uint16 const   )88, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )85,      (yytype_uint16 const   )86,      (yytype_uint16 const   )57, 
        (yytype_uint16 const   )58,      (yytype_uint16 const   )0,      (yytype_uint16 const   )114,      (yytype_uint16 const   )119, 
        (yytype_uint16 const   )120,      (yytype_uint16 const   )121,      (yytype_uint16 const   )132,      (yytype_uint16 const   )133, 
        (yytype_uint16 const   )137,      (yytype_uint16 const   )136,      (yytype_uint16 const   )135,      (yytype_uint16 const   )134, 
        (yytype_uint16 const   )141,      (yytype_uint16 const   )142,      (yytype_uint16 const   )138,      (yytype_uint16 const   )139, 
        (yytype_uint16 const   )146,      (yytype_uint16 const   )0,      (yytype_uint16 const   )147,      (yytype_uint16 const   )150, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )148,      (yytype_uint16 const   )0,      (yytype_uint16 const   )169, 
        (yytype_uint16 const   )170,      (yytype_uint16 const   )159,      (yytype_uint16 const   )160,      (yytype_uint16 const   )162, 
        (yytype_uint16 const   )260,      (yytype_uint16 const   )0,      (yytype_uint16 const   )255,      (yytype_uint16 const   )256, 
        (yytype_uint16 const   )270,      (yytype_uint16 const   )0,      (yytype_uint16 const   )263,      (yytype_uint16 const   )264, 
        (yytype_uint16 const   )284,      (yytype_uint16 const   )283,      (yytype_uint16 const   )1,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )32,      (yytype_uint16 const   )34,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )30,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )156,      (yytype_uint16 const   )155,      (yytype_uint16 const   )151,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )174,      (yytype_uint16 const   )176,      (yytype_uint16 const   )171, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )163,      (yytype_uint16 const   )166,      (yytype_uint16 const   )168,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )26, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )27,      (yytype_uint16 const   )28,      (yytype_uint16 const   )48, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )46,      (yytype_uint16 const   )43,      (yytype_uint16 const   )54, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )61,      (yytype_uint16 const   )82,      (yytype_uint16 const   )72, 
        (yytype_uint16 const   )73,      (yytype_uint16 const   )74,      (yytype_uint16 const   )75,      (yytype_uint16 const   )76, 
        (yytype_uint16 const   )77,      (yytype_uint16 const   )78,      (yytype_uint16 const   )79,      (yytype_uint16 const   )80, 
        (yytype_uint16 const   )81,      (yytype_uint16 const   )0,      (yytype_uint16 const   )83,      (yytype_uint16 const   )70, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )90,      (yytype_uint16 const   )87, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )115,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )140,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )183,      (yytype_uint16 const   )180,      (yytype_uint16 const   )179, 
        (yytype_uint16 const   )181,      (yytype_uint16 const   )0,      (yytype_uint16 const   )175,      (yytype_uint16 const   )172, 
        (yytype_uint16 const   )161,      (yytype_uint16 const   )0,      (yytype_uint16 const   )192,      (yytype_uint16 const   )184, 
        (yytype_uint16 const   )187,      (yytype_uint16 const   )190,      (yytype_uint16 const   )189,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )186,      (yytype_uint16 const   )164,      (yytype_uint16 const   )167,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )257,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )265,      (yytype_uint16 const   )285, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )45,      (yytype_uint16 const   )64, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )62,      (yytype_uint16 const   )0,      (yytype_uint16 const   )89, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )31,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )143,      (yytype_uint16 const   )152,      (yytype_uint16 const   )0,      (yytype_uint16 const   )178, 
        (yytype_uint16 const   )177,      (yytype_uint16 const   )173,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )188,      (yytype_uint16 const   )185,      (yytype_uint16 const   )165, 
        (yytype_uint16 const   )261,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )273, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )271,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )29,      (yytype_uint16 const   )47,      (yytype_uint16 const   )71, 
        (yytype_uint16 const   )93,      (yytype_uint16 const   )95,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )91,      (yytype_uint16 const   )33,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )203,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )201,      (yytype_uint16 const   )0,      (yytype_uint16 const   )193,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )258,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )278,      (yytype_uint16 const   )281,      (yytype_uint16 const   )282,      (yytype_uint16 const   )274, 
        (yytype_uint16 const   )280,      (yytype_uint16 const   )0,      (yytype_uint16 const   )266,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )117,      (yytype_uint16 const   )0,      (yytype_uint16 const   )153, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )204,      (yytype_uint16 const   )241,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )237,      (yytype_uint16 const   )240,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )197,      (yytype_uint16 const   )0,      (yytype_uint16 const   )219, 
        (yytype_uint16 const   )194,      (yytype_uint16 const   )0,      (yytype_uint16 const   )262,      (yytype_uint16 const   )259, 
        (yytype_uint16 const   )279,      (yytype_uint16 const   )275,      (yytype_uint16 const   )276,      (yytype_uint16 const   )272, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )267,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )97,      (yytype_uint16 const   )98,      (yytype_uint16 const   )99, 
        (yytype_uint16 const   )100,      (yytype_uint16 const   )101,      (yytype_uint16 const   )102,      (yytype_uint16 const   )103, 
        (yytype_uint16 const   )104,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )116,      (yytype_uint16 const   )0,      (yytype_uint16 const   )149,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )243,      (yytype_uint16 const   )238,      (yytype_uint16 const   )0,      (yytype_uint16 const   )202, 
        (yytype_uint16 const   )198,      (yytype_uint16 const   )0,      (yytype_uint16 const   )221,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )199,      (yytype_uint16 const   )0,      (yytype_uint16 const   )195,      (yytype_uint16 const   )277, 
        (yytype_uint16 const   )269,      (yytype_uint16 const   )94,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )118,      (yytype_uint16 const   )0,      (yytype_uint16 const   )157,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )206,      (yytype_uint16 const   )250,      (yytype_uint16 const   )252, 
        (yytype_uint16 const   )205,      (yytype_uint16 const   )208,      (yytype_uint16 const   )210,      (yytype_uint16 const   )211, 
        (yytype_uint16 const   )207,      (yytype_uint16 const   )209,      (yytype_uint16 const   )217,      (yytype_uint16 const   )218, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )242,      (yytype_uint16 const   )200,      (yytype_uint16 const   )229, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )191,      (yytype_uint16 const   )196,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )106,      (yytype_uint16 const   )92,      (yytype_uint16 const   )108,      (yytype_uint16 const   )109, 
        (yytype_uint16 const   )110,      (yytype_uint16 const   )111,      (yytype_uint16 const   )112,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )0,      (yytype_uint16 const   )244,      (yytype_uint16 const   )212, 
        (yytype_uint16 const   )245,      (yytype_uint16 const   )246,      (yytype_uint16 const   )247,      (yytype_uint16 const   )248, 
        (yytype_uint16 const   )249,      (yytype_uint16 const   )214,      (yytype_uint16 const   )0,      (yytype_uint16 const   )215, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )251,      (yytype_uint16 const   )232,      (yytype_uint16 const   )222, 
        (yytype_uint16 const   )223,      (yytype_uint16 const   )227,      (yytype_uint16 const   )230,      (yytype_uint16 const   )158, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )216,      (yytype_uint16 const   )239,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )224,      (yytype_uint16 const   )226,      (yytype_uint16 const   )233,      (yytype_uint16 const   )228, 
        (yytype_uint16 const   )231,      (yytype_uint16 const   )213,      (yytype_uint16 const   )253,      (yytype_uint16 const   )254, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )225,      (yytype_uint16 const   )236,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )235};
#line 1037 "bsdl_bison.c"
static yytype_int16 const   yydefgoto___0[124]  = 
#line 1037
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )34, 
        (yytype_int16 const   )66,      (yytype_int16 const   )181,      (yytype_int16 const   )151,      (yytype_int16 const   )152, 
        (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37,      (yytype_int16 const   )38, 
        (yytype_int16 const   )39,      (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )75, 
        (yytype_int16 const   )76,      (yytype_int16 const   )184,      (yytype_int16 const   )185,      (yytype_int16 const   )42, 
        (yytype_int16 const   )43,      (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )82, 
        (yytype_int16 const   )83,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )48, 
        (yytype_int16 const   )90,      (yytype_int16 const   )91,      (yytype_int16 const   )92,      (yytype_int16 const   )93, 
        (yytype_int16 const   )201,      (yytype_int16 const   )202,      (yytype_int16 const   )203,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )205, 
        (yytype_int16 const   )206,      (yytype_int16 const   )282,      (yytype_int16 const   )349,      (yytype_int16 const   )397, 
        (yytype_int16 const   )284,      (yytype_int16 const   )404,      (yytype_int16 const   )51,      (yytype_int16 const   )102, 
        (yytype_int16 const   )255,      (yytype_int16 const   )314,      (yytype_int16 const   )52,      (yytype_int16 const   )53, 
        (yytype_int16 const   )54,      (yytype_int16 const   )55,      (yytype_int16 const   )111,      (yytype_int16 const   )56, 
        (yytype_int16 const   )114,      (yytype_int16 const   )319,      (yytype_int16 const   )57,      (yytype_int16 const   )117, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )121,      (yytype_int16 const   )122, 
        (yytype_int16 const   )214,      (yytype_int16 const   )288,      (yytype_int16 const   )354,      (yytype_int16 const   )158, 
        (yytype_int16 const   )375,      (yytype_int16 const   )60,      (yytype_int16 const   )125,      (yytype_int16 const   )126, 
        (yytype_int16 const   )127,      (yytype_int16 const   )163,      (yytype_int16 const   )221,      (yytype_int16 const   )168, 
        (yytype_int16 const   )169,      (yytype_int16 const   )170,      (yytype_int16 const   )227,      (yytype_int16 const   )228, 
        (yytype_int16 const   )229,      (yytype_int16 const   )264,      (yytype_int16 const   )296,      (yytype_int16 const   )365, 
        (yytype_int16 const   )230,      (yytype_int16 const   )291,      (yytype_int16 const   )292,      (yytype_int16 const   )355, 
        (yytype_int16 const   )380,      (yytype_int16 const   )381,      (yytype_int16 const   )382,      (yytype_int16 const   )424, 
        (yytype_int16 const   )383,      (yytype_int16 const   )384,      (yytype_int16 const   )326,      (yytype_int16 const   )327, 
        (yytype_int16 const   )391,      (yytype_int16 const   )419,      (yytype_int16 const   )420,      (yytype_int16 const   )421, 
        (yytype_int16 const   )431,      (yytype_int16 const   )293,      (yytype_int16 const   )320,      (yytype_int16 const   )321, 
        (yytype_int16 const   )385,      (yytype_int16 const   )414,      (yytype_int16 const   )415,      (yytype_int16 const   )386, 
        (yytype_int16 const   )422,      (yytype_int16 const   )387,      (yytype_int16 const   )428,      (yytype_int16 const   )429, 
        (yytype_int16 const   )61,      (yytype_int16 const   )130,      (yytype_int16 const   )131,      (yytype_int16 const   )269, 
        (yytype_int16 const   )62,      (yytype_int16 const   )134,      (yytype_int16 const   )135,      (yytype_int16 const   )272, 
        (yytype_int16 const   )273,      (yytype_int16 const   )304,      (yytype_int16 const   )63,      (yytype_int16 const   )137};
#line 1057 "bsdl_bison.c"
static yytype_int16 const   yypact___0[441]  = 
#line 1057
  {      (yytype_int16 const   )1,      (yytype_int16 const   )-326,      (yytype_int16 const   )125,      (yytype_int16 const   )97, 
        (yytype_int16 const   )96,      (yytype_int16 const   )138,      (yytype_int16 const   )142,      (yytype_int16 const   )150, 
        (yytype_int16 const   )155,      (yytype_int16 const   )180,      (yytype_int16 const   )66,      (yytype_int16 const   )183, 
        (yytype_int16 const   )186,      (yytype_int16 const   )190,      (yytype_int16 const   )69,      (yytype_int16 const   )87, 
        (yytype_int16 const   )187,      (yytype_int16 const   )29,      (yytype_int16 const   )188,      (yytype_int16 const   )189, 
        (yytype_int16 const   )184,      (yytype_int16 const   )-24,      (yytype_int16 const   )74,      (yytype_int16 const   )28, 
        (yytype_int16 const   )101,      (yytype_int16 const   )193,      (yytype_int16 const   )191,      (yytype_int16 const   )2, 
        (yytype_int16 const   )111,      (yytype_int16 const   )114,      (yytype_int16 const   )115,      (yytype_int16 const   )196, 
        (yytype_int16 const   )236,      (yytype_int16 const   )-326,      (yytype_int16 const   )192,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )194,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )195,      (yytype_int16 const   )197, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )198,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )199,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )200,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )202,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )203,      (yytype_int16 const   )201,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )20,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )204,      (yytype_int16 const   )206,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )166,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-4,      (yytype_int16 const   )-326,      (yytype_int16 const   )207,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )17,      (yytype_int16 const   )208,      (yytype_int16 const   )-326,      (yytype_int16 const   )60, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )3,      (yytype_int16 const   )209,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-15,      (yytype_int16 const   )210,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )211,      (yytype_int16 const   )-326,      (yytype_int16 const   )97, 
        (yytype_int16 const   )91,      (yytype_int16 const   )214,      (yytype_int16 const   )220,      (yytype_int16 const   )221, 
        (yytype_int16 const   )218,      (yytype_int16 const   )87,      (yytype_int16 const   )113,      (yytype_int16 const   )223, 
        (yytype_int16 const   )222,      (yytype_int16 const   )216,      (yytype_int16 const   )-326,      (yytype_int16 const   )72, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )224,      (yytype_int16 const   )225,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )205, 
        (yytype_int16 const   )43,      (yytype_int16 const   )182,      (yytype_int16 const   )-326,      (yytype_int16 const   )185, 
        (yytype_int16 const   )111,      (yytype_int16 const   )-14,      (yytype_int16 const   )226,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )151,      (yytype_int16 const   )181,      (yytype_int16 const   )-326,      (yytype_int16 const   )227, 
        (yytype_int16 const   )146,      (yytype_int16 const   )114,      (yytype_int16 const   )228,      (yytype_int16 const   )177, 
        (yytype_int16 const   )-58,      (yytype_int16 const   )115,      (yytype_int16 const   )233,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )20,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )136,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )229,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )156,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )230,      (yytype_int16 const   )232,      (yytype_int16 const   )231,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )235,      (yytype_int16 const   )20,      (yytype_int16 const   )-326,      (yytype_int16 const   )234, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-4,      (yytype_int16 const   )237,      (yytype_int16 const   )238, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )239,      (yytype_int16 const   )-326,      (yytype_int16 const   )212, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )113,      (yytype_int16 const   )213,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-14, 
        (yytype_int16 const   )-14,      (yytype_int16 const   )181,      (yytype_int16 const   )-326,      (yytype_int16 const   )242, 
        (yytype_int16 const   )241,      (yytype_int16 const   )-326,      (yytype_int16 const   )246,      (yytype_int16 const   )243, 
        (yytype_int16 const   )244,      (yytype_int16 const   )179,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )157,      (yytype_int16 const   )214,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )113,      (yytype_int16 const   )-326,      (yytype_int16 const   )-1,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )249,      (yytype_int16 const   )245,      (yytype_int16 const   )-326,      (yytype_int16 const   )247, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )215,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-8,      (yytype_int16 const   )254, 
        (yytype_int16 const   )217,      (yytype_int16 const   )-326,      (yytype_int16 const   )-14,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )160,      (yytype_int16 const   )242,      (yytype_int16 const   )-21, 
        (yytype_int16 const   )161,      (yytype_int16 const   )-326,      (yytype_int16 const   )246,      (yytype_int16 const   )246, 
        (yytype_int16 const   )251,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )252,      (yytype_int16 const   )-326,      (yytype_int16 const   )255,      (yytype_int16 const   )256, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )258,      (yytype_int16 const   )-4, 
        (yytype_int16 const   )259,      (yytype_int16 const   )257,      (yytype_int16 const   )-12,      (yytype_int16 const   )-9, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-2,      (yytype_int16 const   )-326,      (yytype_int16 const   )263, 
        (yytype_int16 const   )253,      (yytype_int16 const   )242,      (yytype_int16 const   )-326,      (yytype_int16 const   )164, 
        (yytype_int16 const   )-50,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )68, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )246,      (yytype_int16 const   )-326,      (yytype_int16 const   )165, 
        (yytype_int16 const   )168,      (yytype_int16 const   )246,      (yytype_int16 const   )264,      (yytype_int16 const   )132, 
        (yytype_int16 const   )267,      (yytype_int16 const   )-326,      (yytype_int16 const   )169,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )240,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )268, 
        (yytype_int16 const   )248,      (yytype_int16 const   )266,      (yytype_int16 const   )270,      (yytype_int16 const   )10, 
        (yytype_int16 const   )265,      (yytype_int16 const   )-326,      (yytype_int16 const   )172,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )271,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-50,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )173,      (yytype_int16 const   )269, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )273,      (yytype_int16 const   )274,      (yytype_int16 const   )277, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-3,      (yytype_int16 const   )-326,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )272,      (yytype_int16 const   )250,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )176,      (yytype_int16 const   )-326,      (yytype_int16 const   )281, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )119,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )98,      (yytype_int16 const   )159, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )260,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )275,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )89,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-12,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-48, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )282,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )283,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )261,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )276,      (yytype_int16 const   )278,      (yytype_int16 const   )30,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )262,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )120, 
        (yytype_int16 const   )280,      (yytype_int16 const   )-326,      (yytype_int16 const   )-48,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )279,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )30, 
        (yytype_int16 const   )-326};
#line 1107 "bsdl_bison.c"
static yytype_int16 const   yypgoto___0[124]  = 
#line 1107
  {      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )149,      (yytype_int16 const   )-326,      (yytype_int16 const   )134,      (yytype_int16 const   )-116, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )219,      (yytype_int16 const   )-326,      (yytype_int16 const   )82,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )284,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )285,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )103,      (yytype_int16 const   )83,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )286,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-23,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-207, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )170, 
        (yytype_int16 const   )-202,      (yytype_int16 const   )-129,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )167,      (yytype_int16 const   )-142,      (yytype_int16 const   )-139,      (yytype_int16 const   )-168, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-211,      (yytype_int16 const   )-326,      (yytype_int16 const   )11,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-325,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-53,      (yytype_int16 const   )13,      (yytype_int16 const   )-26, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )48,      (yytype_int16 const   )-47,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326, 
        (yytype_int16 const   )-90,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )-86, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )171,      (yytype_int16 const   )73, 
        (yytype_int16 const   )-326,      (yytype_int16 const   )-326,      (yytype_int16 const   )174,      (yytype_int16 const   )-154, 
        (yytype_int16 const   )40,      (yytype_int16 const   )-177,      (yytype_int16 const   )-326,      (yytype_int16 const   )-326};
#line 1129 "bsdl_bison.c"
static yytype_uint16 const   yytable___0[435]  = 
#line 1129
  {      (yytype_uint16 const   )172,      (yytype_uint16 const   )115,      (yytype_uint16 const   )1,      (yytype_uint16 const   )119, 
        (yytype_uint16 const   )176,      (yytype_uint16 const   )2,      (yytype_uint16 const   )257,      (yytype_uint16 const   )3, 
        (yytype_uint16 const   )4,      (yytype_uint16 const   )5,      (yytype_uint16 const   )6,      (yytype_uint16 const   )7, 
        (yytype_uint16 const   )8,      (yytype_uint16 const   )9,      (yytype_uint16 const   )10,      (yytype_uint16 const   )11, 
        (yytype_uint16 const   )12,      (yytype_uint16 const   )13,      (yytype_uint16 const   )14,      (yytype_uint16 const   )15, 
        (yytype_uint16 const   )16,      (yytype_uint16 const   )17,      (yytype_uint16 const   )18,      (yytype_uint16 const   )19, 
        (yytype_uint16 const   )182,      (yytype_uint16 const   )160,      (yytype_uint16 const   )113,      (yytype_uint16 const   )234, 
        (yytype_uint16 const   )232,      (yytype_uint16 const   )108,      (yytype_uint16 const   )95,      (yytype_uint16 const   )160, 
        (yytype_uint16 const   )225,      (yytype_uint16 const   )268,      (yytype_uint16 const   )289,      (yytype_uint16 const   )240, 
        (yytype_uint16 const   )322,      (yytype_uint16 const   )280,      (yytype_uint16 const   )156,      (yytype_uint16 const   )373, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )103,      (yytype_uint16 const   )104,      (yytype_uint16 const   )105, 
        (yytype_uint16 const   )376,      (yytype_uint16 const   )325,      (yytype_uint16 const   )377,      (yytype_uint16 const   )157, 
        (yytype_uint16 const   )374,      (yytype_uint16 const   )160,      (yytype_uint16 const   )281,      (yytype_uint16 const   )241, 
        (yytype_uint16 const   )324,      (yytype_uint16 const   )20,      (yytype_uint16 const   )378,      (yytype_uint16 const   )417, 
        (yytype_uint16 const   )379,      (yytype_uint16 const   )360,      (yytype_uint16 const   )149,      (yytype_uint16 const   )265, 
        (yytype_uint16 const   )301,      (yytype_uint16 const   )302,      (yytype_uint16 const   )150,      (yytype_uint16 const   )160, 
        (yytype_uint16 const   )265,      (yytype_uint16 const   )21,      (yytype_uint16 const   )418,      (yytype_uint16 const   )73, 
        (yytype_uint16 const   )268,      (yytype_uint16 const   )22,      (yytype_uint16 const   )80,      (yytype_uint16 const   )96, 
        (yytype_uint16 const   )23,      (yytype_uint16 const   )24,      (yytype_uint16 const   )25,      (yytype_uint16 const   )226, 
        (yytype_uint16 const   )26,      (yytype_uint16 const   )27,      (yytype_uint16 const   )174,      (yytype_uint16 const   )120, 
        (yytype_uint16 const   )315,      (yytype_uint16 const   )215,      (yytype_uint16 const   )28,      (yytype_uint16 const   )109, 
        (yytype_uint16 const   )318,      (yytype_uint16 const   )110,      (yytype_uint16 const   )290,      (yytype_uint16 const   )290, 
        (yytype_uint16 const   )300,      (yytype_uint16 const   )301,      (yytype_uint16 const   )302,      (yytype_uint16 const   )267, 
        (yytype_uint16 const   )266,      (yytype_uint16 const   )254,      (yytype_uint16 const   )175,      (yytype_uint16 const   )330, 
        (yytype_uint16 const   )171,      (yytype_uint16 const   )432,      (yytype_uint16 const   )265,      (yytype_uint16 const   )161, 
        (yytype_uint16 const   )162,      (yytype_uint16 const   )216,      (yytype_uint16 const   )112,      (yytype_uint16 const   )217, 
        (yytype_uint16 const   )74,      (yytype_uint16 const   )438,      (yytype_uint16 const   )218,      (yytype_uint16 const   )81, 
        (yytype_uint16 const   )29,      (yytype_uint16 const   )30,      (yytype_uint16 const   )84,      (yytype_uint16 const   )85, 
        (yytype_uint16 const   )123,      (yytype_uint16 const   )31,      (yytype_uint16 const   )440,      (yytype_uint16 const   )128, 
        (yytype_uint16 const   )132,      (yytype_uint16 const   )209,      (yytype_uint16 const   )366,      (yytype_uint16 const   )210, 
        (yytype_uint16 const   )307,      (yytype_uint16 const   )308,      (yytype_uint16 const   )376,      (yytype_uint16 const   )332, 
        (yytype_uint16 const   )377,      (yytype_uint16 const   )86,      (yytype_uint16 const   )334,      (yytype_uint16 const   )219, 
        (yytype_uint16 const   )220,      (yytype_uint16 const   )149,      (yytype_uint16 const   )64,      (yytype_uint16 const   )212, 
        (yytype_uint16 const   )378,      (yytype_uint16 const   )150,      (yytype_uint16 const   )379,      (yytype_uint16 const   )65, 
        (yytype_uint16 const   )395,      (yytype_uint16 const   )180,      (yytype_uint16 const   )67,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )396,      (yytype_uint16 const   )87,      (yytype_uint16 const   )303,      (yytype_uint16 const   )106, 
        (yytype_uint16 const   )107,      (yytype_uint16 const   )88,      (yytype_uint16 const   )165,      (yytype_uint16 const   )166, 
        (yytype_uint16 const   )167,      (yytype_uint16 const   )124,      (yytype_uint16 const   )89,      (yytype_uint16 const   )190, 
        (yytype_uint16 const   )129,      (yytype_uint16 const   )133,      (yytype_uint16 const   )394,      (yytype_uint16 const   )338, 
        (yytype_uint16 const   )367,      (yytype_uint16 const   )340,      (yytype_uint16 const   )341,      (yytype_uint16 const   )342, 
        (yytype_uint16 const   )343,      (yytype_uint16 const   )344,      (yytype_uint16 const   )345,      (yytype_uint16 const   )346, 
        (yytype_uint16 const   )347,      (yytype_uint16 const   )225,      (yytype_uint16 const   )393,      (yytype_uint16 const   )191, 
        (yytype_uint16 const   )192,      (yytype_uint16 const   )193,      (yytype_uint16 const   )194,      (yytype_uint16 const   )195, 
        (yytype_uint16 const   )196,      (yytype_uint16 const   )197,      (yytype_uint16 const   )198,      (yytype_uint16 const   )199, 
        (yytype_uint16 const   )200,      (yytype_uint16 const   )333,      (yytype_uint16 const   )301,      (yytype_uint16 const   )302, 
        (yytype_uint16 const   )68,      (yytype_uint16 const   )245,      (yytype_uint16 const   )407,      (yytype_uint16 const   )246, 
        (yytype_uint16 const   )69,      (yytype_uint16 const   )348,      (yytype_uint16 const   )408,      (yytype_uint16 const   )409, 
        (yytype_uint16 const   )410,      (yytype_uint16 const   )411,      (yytype_uint16 const   )412,      (yytype_uint16 const   )378, 
        (yytype_uint16 const   )70,      (yytype_uint16 const   )379,      (yytype_uint16 const   )398,      (yytype_uint16 const   )399, 
        (yytype_uint16 const   )400,      (yytype_uint16 const   )71,      (yytype_uint16 const   )401,      (yytype_uint16 const   )402, 
        (yytype_uint16 const   )403,      (yytype_uint16 const   )248,      (yytype_uint16 const   )209,      (yytype_uint16 const   )249, 
        (yytype_uint16 const   )277,      (yytype_uint16 const   )297,      (yytype_uint16 const   )305,      (yytype_uint16 const   )298, 
        (yytype_uint16 const   )306,      (yytype_uint16 const   )297,      (yytype_uint16 const   )305,      (yytype_uint16 const   )331, 
        (yytype_uint16 const   )336,      (yytype_uint16 const   )305,      (yytype_uint16 const   )351,      (yytype_uint16 const   )337, 
        (yytype_uint16 const   )352,      (yytype_uint16 const   )363,      (yytype_uint16 const   )305,      (yytype_uint16 const   )364, 
        (yytype_uint16 const   )368,      (yytype_uint16 const   )363,      (yytype_uint16 const   )72,      (yytype_uint16 const   )390, 
        (yytype_uint16 const   )78,      (yytype_uint16 const   )434,      (yytype_uint16 const   )435,      (yytype_uint16 const   )77, 
        (yytype_uint16 const   )79,      (yytype_uint16 const   )94,      (yytype_uint16 const   )101,      (yytype_uint16 const   )116, 
        (yytype_uint16 const   )99,      (yytype_uint16 const   )100,      (yytype_uint16 const   )136,      (yytype_uint16 const   )118, 
        (yytype_uint16 const   )138,      (yytype_uint16 const   )139,      (yytype_uint16 const   )166,      (yytype_uint16 const   )236, 
        (yytype_uint16 const   )155,      (yytype_uint16 const   )141,      (yytype_uint16 const   )142,      (yytype_uint16 const   )143, 
        (yytype_uint16 const   )140,      (yytype_uint16 const   )145,      (yytype_uint16 const   )148,      (yytype_uint16 const   )144, 
        (yytype_uint16 const   )146,      (yytype_uint16 const   )147,      (yytype_uint16 const   )153,      (yytype_uint16 const   )154, 
        (yytype_uint16 const   )159,      (yytype_uint16 const   )164,      (yytype_uint16 const   )173,      (yytype_uint16 const   )177, 
        (yytype_uint16 const   )178,      (yytype_uint16 const   )183,      (yytype_uint16 const   )74,      (yytype_uint16 const   )81, 
        (yytype_uint16 const   )188,      (yytype_uint16 const   )204,      (yytype_uint16 const   )208,      (yytype_uint16 const   )113, 
        (yytype_uint16 const   )96,      (yytype_uint16 const   )222,      (yytype_uint16 const   )211,      (yytype_uint16 const   )223, 
        (yytype_uint16 const   )231,      (yytype_uint16 const   )167,      (yytype_uint16 const   )239,      (yytype_uint16 const   )243, 
        (yytype_uint16 const   )276,      (yytype_uint16 const   )235,      (yytype_uint16 const   )238,      (yytype_uint16 const   )250, 
        (yytype_uint16 const   )252,      (yytype_uint16 const   )253,      (yytype_uint16 const   )247,      (yytype_uint16 const   )251, 
        (yytype_uint16 const   )124,      (yytype_uint16 const   )256,      (yytype_uint16 const   )258,      (yytype_uint16 const   )213, 
        (yytype_uint16 const   )271,      (yytype_uint16 const   )259,      (yytype_uint16 const   )260,      (yytype_uint16 const   )270, 
        (yytype_uint16 const   )179,      (yytype_uint16 const   )274,      (yytype_uint16 const   )275,      (yytype_uint16 const   )283, 
        (yytype_uint16 const   )285,      (yytype_uint16 const   )286,      (yytype_uint16 const   )287,      (yytype_uint16 const   )261, 
        (yytype_uint16 const   )294,      (yytype_uint16 const   )309,      (yytype_uint16 const   )310,      (yytype_uint16 const   )329, 
        (yytype_uint16 const   )311,      (yytype_uint16 const   )312,      (yytype_uint16 const   )313,      (yytype_uint16 const   )263, 
        (yytype_uint16 const   )316,      (yytype_uint16 const   )328,      (yytype_uint16 const   )339,      (yytype_uint16 const   )317, 
        (yytype_uint16 const   )295,      (yytype_uint16 const   )350,      (yytype_uint16 const   )356,      (yytype_uint16 const   )358, 
        (yytype_uint16 const   )289,      (yytype_uint16 const   )406,      (yytype_uint16 const   )244,      (yytype_uint16 const   )362, 
        (yytype_uint16 const   )369,      (yytype_uint16 const   )225,      (yytype_uint16 const   )370,      (yytype_uint16 const   )371, 
        (yytype_uint16 const   )353,      (yytype_uint16 const   )372,      (yytype_uint16 const   )388,      (yytype_uint16 const   )324, 
        (yytype_uint16 const   )423,      (yytype_uint16 const   )425,      (yytype_uint16 const   )427,      (yytype_uint16 const   )278, 
        (yytype_uint16 const   )262,      (yytype_uint16 const   )430,      (yytype_uint16 const   )436,      (yytype_uint16 const   )279, 
        (yytype_uint16 const   )413,      (yytype_uint16 const   )359,      (yytype_uint16 const   )224,      (yytype_uint16 const   )233, 
        (yytype_uint16 const   )361,      (yytype_uint16 const   )392,      (yytype_uint16 const   )357,      (yytype_uint16 const   )323, 
        (yytype_uint16 const   )439,      (yytype_uint16 const   )416,      (yytype_uint16 const   )437,      (yytype_uint16 const   )299, 
        (yytype_uint16 const   )237,      (yytype_uint16 const   )335,      (yytype_uint16 const   )389,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )242, 
        (yytype_uint16 const   )426,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )433,      (yytype_uint16 const   )0,      (yytype_uint16 const   )405,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )186,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )435,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )187, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )189,      (yytype_uint16 const   )0, 
        (yytype_uint16 const   )0,      (yytype_uint16 const   )0,      (yytype_uint16 const   )207};
#line 1177 "bsdl_bison.c"
static yytype_int16 const   yycheck___0[435]  = 
#line 1177
  {      (yytype_int16 const   )129,      (yytype_int16 const   )24,      (yytype_int16 const   )1,      (yytype_int16 const   )1, 
        (yytype_int16 const   )133,      (yytype_int16 const   )4,      (yytype_int16 const   )213,      (yytype_int16 const   )6, 
        (yytype_int16 const   )7,      (yytype_int16 const   )8,      (yytype_int16 const   )9,      (yytype_int16 const   )10, 
        (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13,      (yytype_int16 const   )14, 
        (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )17,      (yytype_int16 const   )18, 
        (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )21,      (yytype_int16 const   )22, 
        (yytype_int16 const   )140,      (yytype_int16 const   )46,      (yytype_int16 const   )38,      (yytype_int16 const   )169, 
        (yytype_int16 const   )167,      (yytype_int16 const   )1,      (yytype_int16 const   )1,      (yytype_int16 const   )46, 
        (yytype_int16 const   )46,      (yytype_int16 const   )235,      (yytype_int16 const   )42,      (yytype_int16 const   )93, 
        (yytype_int16 const   )45,      (yytype_int16 const   )38,      (yytype_int16 const   )42,      (yytype_int16 const   )42, 
        (yytype_int16 const   )42,      (yytype_int16 const   )65,      (yytype_int16 const   )66,      (yytype_int16 const   )67, 
        (yytype_int16 const   )92,      (yytype_int16 const   )47,      (yytype_int16 const   )94,      (yytype_int16 const   )51, 
        (yytype_int16 const   )51,      (yytype_int16 const   )46,      (yytype_int16 const   )51,      (yytype_int16 const   )109, 
        (yytype_int16 const   )42,      (yytype_int16 const   )52,      (yytype_int16 const   )102,      (yytype_int16 const   )103, 
        (yytype_int16 const   )104,      (yytype_int16 const   )47,      (yytype_int16 const   )38,      (yytype_int16 const   )227, 
        (yytype_int16 const   )110,      (yytype_int16 const   )111,      (yytype_int16 const   )42,      (yytype_int16 const   )46, 
        (yytype_int16 const   )232,      (yytype_int16 const   )64,      (yytype_int16 const   )391,      (yytype_int16 const   )1, 
        (yytype_int16 const   )270,      (yytype_int16 const   )68,      (yytype_int16 const   )1,      (yytype_int16 const   )42, 
        (yytype_int16 const   )71,      (yytype_int16 const   )72,      (yytype_int16 const   )73,      (yytype_int16 const   )89, 
        (yytype_int16 const   )75,      (yytype_int16 const   )76,      (yytype_int16 const   )93,      (yytype_int16 const   )77, 
        (yytype_int16 const   )287,      (yytype_int16 const   )38,      (yytype_int16 const   )81,      (yytype_int16 const   )55, 
        (yytype_int16 const   )96,      (yytype_int16 const   )57,      (yytype_int16 const   )95,      (yytype_int16 const   )95, 
        (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )111,      (yytype_int16 const   )233, 
        (yytype_int16 const   )231,      (yytype_int16 const   )209,      (yytype_int16 const   )109,      (yytype_int16 const   )297, 
        (yytype_int16 const   )93,      (yytype_int16 const   )422,      (yytype_int16 const   )266,      (yytype_int16 const   )82, 
        (yytype_int16 const   )83,      (yytype_int16 const   )58,      (yytype_int16 const   )1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )38,      (yytype_int16 const   )430,      (yytype_int16 const   )63,      (yytype_int16 const   )38, 
        (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )23,      (yytype_int16 const   )24, 
        (yytype_int16 const   )1,      (yytype_int16 const   )112,      (yytype_int16 const   )439,      (yytype_int16 const   )1, 
        (yytype_int16 const   )1,      (yytype_int16 const   )45,      (yytype_int16 const   )329,      (yytype_int16 const   )47, 
        (yytype_int16 const   )274,      (yytype_int16 const   )275,      (yytype_int16 const   )92,      (yytype_int16 const   )300, 
        (yytype_int16 const   )94,      (yytype_int16 const   )38,      (yytype_int16 const   )303,      (yytype_int16 const   )84, 
        (yytype_int16 const   )85,      (yytype_int16 const   )38,      (yytype_int16 const   )5,      (yytype_int16 const   )154, 
        (yytype_int16 const   )102,      (yytype_int16 const   )42,      (yytype_int16 const   )104,      (yytype_int16 const   )38, 
        (yytype_int16 const   )38,      (yytype_int16 const   )46,      (yytype_int16 const   )42,      (yytype_int16 const   )38, 
        (yytype_int16 const   )42,      (yytype_int16 const   )54,      (yytype_int16 const   )271,      (yytype_int16 const   )69, 
        (yytype_int16 const   )70,      (yytype_int16 const   )58,      (yytype_int16 const   )86,      (yytype_int16 const   )87, 
        (yytype_int16 const   )88,      (yytype_int16 const   )38,      (yytype_int16 const   )63,      (yytype_int16 const   )38, 
        (yytype_int16 const   )38,      (yytype_int16 const   )38,      (yytype_int16 const   )365,      (yytype_int16 const   )309, 
        (yytype_int16 const   )333,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27, 
        (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )46,      (yytype_int16 const   )47,      (yytype_int16 const   )54, 
        (yytype_int16 const   )55,      (yytype_int16 const   )56,      (yytype_int16 const   )57,      (yytype_int16 const   )58, 
        (yytype_int16 const   )59,      (yytype_int16 const   )60,      (yytype_int16 const   )61,      (yytype_int16 const   )62, 
        (yytype_int16 const   )63,      (yytype_int16 const   )109,      (yytype_int16 const   )110,      (yytype_int16 const   )111, 
        (yytype_int16 const   )42,      (yytype_int16 const   )45,      (yytype_int16 const   )93,      (yytype_int16 const   )47, 
        (yytype_int16 const   )42,      (yytype_int16 const   )53,      (yytype_int16 const   )97,      (yytype_int16 const   )98, 
        (yytype_int16 const   )99,      (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102, 
        (yytype_int16 const   )42,      (yytype_int16 const   )104,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )42,      (yytype_int16 const   )39,      (yytype_int16 const   )40, 
        (yytype_int16 const   )41,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )47, 
        (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )42,      (yytype_int16 const   )47, 
        (yytype_int16 const   )38,      (yytype_int16 const   )105,      (yytype_int16 const   )106,      (yytype_int16 const   )44, 
        (yytype_int16 const   )38,      (yytype_int16 const   )42,      (yytype_int16 const   )46,      (yytype_int16 const   )38, 
        (yytype_int16 const   )44,      (yytype_int16 const   )44,      (yytype_int16 const   )38,      (yytype_int16 const   )44, 
        (yytype_int16 const   )0,      (yytype_int16 const   )45,      (yytype_int16 const   )87,      (yytype_int16 const   )93, 
        (yytype_int16 const   )74,      (yytype_int16 const   )46,      (yytype_int16 const   )45,      (yytype_int16 const   )45, 
        (yytype_int16 const   )50,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )48, 
        (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )45, 
        (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )45, 
        (yytype_int16 const   )45,      (yytype_int16 const   )43,      (yytype_int16 const   )38,      (yytype_int16 const   )38, 
        (yytype_int16 const   )42,      (yytype_int16 const   )38,      (yytype_int16 const   )46,      (yytype_int16 const   )38, 
        (yytype_int16 const   )42,      (yytype_int16 const   )83,      (yytype_int16 const   )42,      (yytype_int16 const   )82, 
        (yytype_int16 const   )42,      (yytype_int16 const   )88,      (yytype_int16 const   )93,      (yytype_int16 const   )38, 
        (yytype_int16 const   )93,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )45, 
        (yytype_int16 const   )45,      (yytype_int16 const   )42,      (yytype_int16 const   )49,      (yytype_int16 const   )47, 
        (yytype_int16 const   )38,      (yytype_int16 const   )47,      (yytype_int16 const   )45,      (yytype_int16 const   )78, 
        (yytype_int16 const   )38,      (yytype_int16 const   )47,      (yytype_int16 const   )47,      (yytype_int16 const   )46, 
        (yytype_int16 const   )139,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )42, 
        (yytype_int16 const   )47,      (yytype_int16 const   )46,      (yytype_int16 const   )79,      (yytype_int16 const   )83, 
        (yytype_int16 const   )42,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )46, 
        (yytype_int16 const   )45,      (yytype_int16 const   )45,      (yytype_int16 const   )44,      (yytype_int16 const   )90, 
        (yytype_int16 const   )45,      (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )50, 
        (yytype_int16 const   )91,      (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )45, 
        (yytype_int16 const   )42,      (yytype_int16 const   )38,      (yytype_int16 const   )180,      (yytype_int16 const   )50, 
        (yytype_int16 const   )47,      (yytype_int16 const   )46,      (yytype_int16 const   )45,      (yytype_int16 const   )45, 
        (yytype_int16 const   )80,      (yytype_int16 const   )44,      (yytype_int16 const   )50,      (yytype_int16 const   )42, 
        (yytype_int16 const   )42,      (yytype_int16 const   )42,      (yytype_int16 const   )50,      (yytype_int16 const   )245, 
        (yytype_int16 const   )225,      (yytype_int16 const   )51,      (yytype_int16 const   )50,      (yytype_int16 const   )248, 
        (yytype_int16 const   )385,      (yytype_int16 const   )322,      (yytype_int16 const   )164,      (yytype_int16 const   )168, 
        (yytype_int16 const   )323,      (yytype_int16 const   )363,      (yytype_int16 const   )90,      (yytype_int16 const   )291, 
        (yytype_int16 const   )430,      (yytype_int16 const   )388,      (yytype_int16 const   )428,      (yytype_int16 const   )270, 
        (yytype_int16 const   )173,      (yytype_int16 const   )305,      (yytype_int16 const   )96,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )177, 
        (yytype_int16 const   )91,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )94,      (yytype_int16 const   )-1,      (yytype_int16 const   )98,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )142,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )106,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )143, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )145,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )148};
#line 1227 "bsdl_bison.c"
static yytype_uint8 const   yystos___0[441]  = 
#line 1227
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )4,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )64,      (yytype_uint8 const   )68,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )107,      (yytype_uint8 const   )108,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )117,      (yytype_uint8 const   )122, 
        (yytype_uint8 const   )123,      (yytype_uint8 const   )124,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )127,      (yytype_uint8 const   )128,      (yytype_uint8 const   )133,      (yytype_uint8 const   )134, 
        (yytype_uint8 const   )135,      (yytype_uint8 const   )136,      (yytype_uint8 const   )139,      (yytype_uint8 const   )140, 
        (yytype_uint8 const   )141,      (yytype_uint8 const   )149,      (yytype_uint8 const   )150,      (yytype_uint8 const   )160, 
        (yytype_uint8 const   )164,      (yytype_uint8 const   )165,      (yytype_uint8 const   )166,      (yytype_uint8 const   )167, 
        (yytype_uint8 const   )169,      (yytype_uint8 const   )172,      (yytype_uint8 const   )174,      (yytype_uint8 const   )175, 
        (yytype_uint8 const   )183,      (yytype_uint8 const   )226,      (yytype_uint8 const   )230,      (yytype_uint8 const   )236, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )38,      (yytype_uint8 const   )118,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )129, 
        (yytype_uint8 const   )130,      (yytype_uint8 const   )44,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )137,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )38,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )63,      (yytype_uint8 const   )142,      (yytype_uint8 const   )143, 
        (yytype_uint8 const   )144,      (yytype_uint8 const   )145,      (yytype_uint8 const   )42,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )151,      (yytype_uint8 const   )152,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )46,      (yytype_uint8 const   )161,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )55,      (yytype_uint8 const   )57,      (yytype_uint8 const   )168, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )170,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )173,      (yytype_uint8 const   )44,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )176,      (yytype_uint8 const   )177,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )184,      (yytype_uint8 const   )185,      (yytype_uint8 const   )186, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )227,      (yytype_uint8 const   )228, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )38,      (yytype_uint8 const   )231,      (yytype_uint8 const   )232, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )237,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )46,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )38,      (yytype_uint8 const   )42,      (yytype_uint8 const   )120, 
        (yytype_uint8 const   )121,      (yytype_uint8 const   )46,      (yytype_uint8 const   )45,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )51,      (yytype_uint8 const   )181,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )187, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )189,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )187,      (yytype_uint8 const   )45,      (yytype_uint8 const   )93,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )187,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )119,      (yytype_uint8 const   )121,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )131,      (yytype_uint8 const   )132,      (yytype_uint8 const   )130,      (yytype_uint8 const   )138, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )143,      (yytype_uint8 const   )38,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )146,      (yytype_uint8 const   )147,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )153,      (yytype_uint8 const   )154,      (yytype_uint8 const   )152, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )171,      (yytype_uint8 const   )78,      (yytype_uint8 const   )178,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )60,      (yytype_uint8 const   )63,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )188,      (yytype_uint8 const   )83,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )185,      (yytype_uint8 const   )46,      (yytype_uint8 const   )89,      (yytype_uint8 const   )192, 
        (yytype_uint8 const   )193,      (yytype_uint8 const   )194,      (yytype_uint8 const   )198,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )192,      (yytype_uint8 const   )190,      (yytype_uint8 const   )191,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )228,      (yytype_uint8 const   )46,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )109,      (yytype_uint8 const   )232,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )42,      (yytype_uint8 const   )121,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )181,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )83,      (yytype_uint8 const   )147,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )195,      (yytype_uint8 const   )193,      (yytype_uint8 const   )192,      (yytype_uint8 const   )191, 
        (yytype_uint8 const   )186,      (yytype_uint8 const   )229,      (yytype_uint8 const   )46,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )234,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )47,      (yytype_uint8 const   )132,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )51,      (yytype_uint8 const   )155,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )158,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )179,      (yytype_uint8 const   )42,      (yytype_uint8 const   )95,      (yytype_uint8 const   )199, 
        (yytype_uint8 const   )200,      (yytype_uint8 const   )215,      (yytype_uint8 const   )42,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )196,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )229, 
        (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111,      (yytype_uint8 const   )187, 
        (yytype_uint8 const   )235,      (yytype_uint8 const   )45,      (yytype_uint8 const   )47,      (yytype_uint8 const   )233, 
        (yytype_uint8 const   )233,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )44,      (yytype_uint8 const   )163,      (yytype_uint8 const   )181, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )50,      (yytype_uint8 const   )96,      (yytype_uint8 const   )171, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )217,      (yytype_uint8 const   )45,      (yytype_uint8 const   )215, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )47,      (yytype_uint8 const   )208,      (yytype_uint8 const   )209, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )46,      (yytype_uint8 const   )186,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )235,      (yytype_uint8 const   )109,      (yytype_uint8 const   )235,      (yytype_uint8 const   )234, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )233,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )156,      (yytype_uint8 const   )42,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )80,      (yytype_uint8 const   )180,      (yytype_uint8 const   )201, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )90,      (yytype_uint8 const   )45,      (yytype_uint8 const   )200, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )208,      (yytype_uint8 const   )50,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )197,      (yytype_uint8 const   )198,      (yytype_uint8 const   )235, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )47,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )42,      (yytype_uint8 const   )51,      (yytype_uint8 const   )182, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )94,      (yytype_uint8 const   )102,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )203,      (yytype_uint8 const   )204,      (yytype_uint8 const   )206, 
        (yytype_uint8 const   )207,      (yytype_uint8 const   )218,      (yytype_uint8 const   )221,      (yytype_uint8 const   )223, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )96,      (yytype_uint8 const   )47,      (yytype_uint8 const   )210, 
        (yytype_uint8 const   )209,      (yytype_uint8 const   )47,      (yytype_uint8 const   )198,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )157,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )159,      (yytype_uint8 const   )98,      (yytype_uint8 const   )38,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )207,      (yytype_uint8 const   )219,      (yytype_uint8 const   )220, 
        (yytype_uint8 const   )216,      (yytype_uint8 const   )103,      (yytype_uint8 const   )202,      (yytype_uint8 const   )211, 
        (yytype_uint8 const   )212,      (yytype_uint8 const   )213,      (yytype_uint8 const   )222,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )205,      (yytype_uint8 const   )42,      (yytype_uint8 const   )91,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )224,      (yytype_uint8 const   )225,      (yytype_uint8 const   )51,      (yytype_uint8 const   )214, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )94,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )225,      (yytype_uint8 const   )202,      (yytype_uint8 const   )222, 
        (yytype_uint8 const   )202};
#line 1767 "bsdl_bison.c"
static void yydestruct___0(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ,
                           bsdl_parser_priv_t *priv_data ) 
{ 


  {
#line 1781
  if (! yymsg) {
#line 1782
    yymsg = "Deleting";
  }
  {
#line 1788
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1789
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1791
  return;
}
}
#line 1832 "bsdl_bison.c"
int bsdlparse(bsdl_parser_priv_t *priv_data ) 
{ 
  int bsdlchar ;
  YYSTYPE bsdllval ;
  int bsdlnerrs ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1856
  yytoken = 0;
#line 1874
  yyss = yyssa;
#line 1879
  yyvs = yyvsa;
#line 1886
  yystacksize = 200UL;
#line 1895
  yylen = 0;
#line 1899
  yystate = 0;
#line 1900
  yyerrstatus = 0;
#line 1901
  bsdlnerrs = 0;
#line 1902
  bsdlchar = -2;
#line 1909
  yyssp = yyss;
#line 1910
  yyvsp = yyvs;
#line 1912
  goto yysetstate;
  yynewstate: 
#line 1920
  yyssp ++;
  yysetstate: 
#line 1923
  *yyssp = (yytype_int16 )yystate;
#line 1925
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1928
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1957
    if (10000UL <= yystacksize) {
#line 1958
      goto yyexhaustedlab;
    }
#line 1959
    yystacksize *= 2UL;
#line 1960
    if (10000UL < yystacksize) {
#line 1961
      yystacksize = 10000UL;
    }
    {
#line 1964
    yyss1 = yyss;
#line 1965
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1965
    yyptr = (union yyalloc *)tmp;
    }
#line 1967
    if (! yyptr) {
#line 1968
      goto yyexhaustedlab;
    }
    {
#line 1969
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1969
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1969
      yyss = & yyptr->yyss;
#line 1969
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1969
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1969
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1970
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1970
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1970
      yyvs = & yyptr->yyvs;
#line 1970
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1970
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1970
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1973
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1974
      free((void *)yyss1);
      }
    }
#line 1979
    yyssp = (yyss + yysize) - 1;
#line 1980
    yyvsp = (yyvs + yysize) - 1;
#line 1986
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1987
      goto yyabortlab;
    }
  }
#line 1992
  goto yybackup;
  yybackup: 
#line 2003
  yyn = (int )yypact___0[yystate];
#line 2004
  if (yyn == -326) {
#line 2005
    goto yydefault;
  }
#line 2010
  if (bsdlchar == -2) {
    {
#line 2013
    bsdlchar = bsdllex(& bsdllval, priv_data->scanner);
    }
  }
#line 2016
  if (bsdlchar <= 0) {
#line 2018
    yytoken = 0;
#line 2018
    bsdlchar = yytoken;
  } else
#line 2023
  if ((unsigned int )bsdlchar <= 368U) {
#line 2023
    yytoken = (int )yytranslate___0[bsdlchar];
  } else {
#line 2023
    yytoken = 2;
  }
#line 2029
  yyn += yytoken;
#line 2030
  if (yyn < 0) {
#line 2031
    goto yydefault;
  } else
#line 2030
  if (434 < yyn) {
#line 2031
    goto yydefault;
  } else
#line 2030
  if ((int const   )yycheck___0[yyn] != (int const   )yytoken) {
#line 2031
    goto yydefault;
  }
#line 2032
  yyn = (int )yytable___0[yyn];
#line 2033
  if (yyn <= 0) {
#line 2035
    if (yyn == 0) {
#line 2036
      goto yyerrlab;
    } else
#line 2035
    if (yyn == -1) {
#line 2036
      goto yyerrlab;
    }
#line 2037
    yyn = - yyn;
#line 2038
    goto yyreduce;
  }
#line 2041
  if (yyn == 138) {
#line 2042
    goto yyacceptlab;
  }
#line 2046
  if (yyerrstatus) {
#line 2047
    yyerrstatus --;
  }
#line 2053
  if (bsdlchar != 0) {
#line 2054
    bsdlchar = -2;
  }
#line 2056
  yystate = yyn;
#line 2057
  yyvsp ++;
#line 2057
  *yyvsp = bsdllval;
#line 2059
  goto yynewstate;
  yydefault: 
#line 2066
  yyn = (int )yydefact___0[yystate];
#line 2067
  if (yyn == 0) {
#line 2068
    goto yyerrlab;
  }
#line 2069
  goto yyreduce;
  yyreduce: 
#line 2077
  yylen = (int )yyr2___0[yyn];
#line 2087
  yyval = *(yyvsp + (1 - yylen));
  {
#line 2093
  if (yyn == 23) {
#line 2093
    goto case_23;
  }
#line 263
  if (yyn == 27) {
#line 263 "bsdl_bison.y"
    goto case_27;
  }
#line 275
  if (yyn == 32) {
#line 275
    goto case_32;
  }
#line 284
  if (yyn == 33) {
#line 284
    goto case_33;
  }
#line 286
  if (yyn == 40) {
#line 286
    goto case_40;
  }
#line 312
  if (yyn == 44) {
#line 312
    goto case_44;
  }
#line 326
  if (yyn == 45) {
#line 326
    goto case_45;
  }
#line 329
  if (yyn == 46) {
#line 329
    goto case_46;
  }
#line 332
  if (yyn == 47) {
#line 332
    goto case_47;
  }
#line 339
  if (yyn == 48) {
#line 339
    goto case_48;
  }
#line 342
  if (yyn == 49) {
#line 342
    goto case_49;
  }
#line 347
  if (yyn == 50) {
#line 347
    goto case_50;
  }
#line 352
  if (yyn == 51) {
#line 352
    goto case_51;
  }
#line 357
  if (yyn == 55) {
#line 357
    goto case_55;
  }
#line 370
  if (yyn == 56) {
#line 370
    goto case_56;
  }
#line 373
  if (yyn == 57) {
#line 373
    goto case_57;
  }
#line 378
  if (yyn == 58) {
#line 378
    goto case_58;
  }
#line 383
  if (yyn == 62) {
#line 383
    goto case_62;
  }
#line 393
  if (yyn == 63) {
#line 393
    goto case_63;
  }
#line 396
  if (yyn == 64) {
#line 396
    goto case_64;
  }
#line 398
  if (yyn == 65) {
#line 398
    goto case_65;
  }
#line 401
  if (yyn == 66) {
#line 401
    goto case_66;
  }
#line 403
  if (yyn == 67) {
#line 403
    goto case_67;
  }
#line 405
  if (yyn == 68) {
#line 405
    goto case_68;
  }
#line 407
  if (yyn == 69) {
#line 407
    goto case_69;
  }
#line 409
  if (yyn == 72) {
#line 409
    goto case_72;
  }
#line 415
  if (yyn == 73) {
#line 415
    goto case_73;
  }
#line 417
  if (yyn == 74) {
#line 417
    goto case_74;
  }
#line 419
  if (yyn == 75) {
#line 419
    goto case_75;
  }
#line 421
  if (yyn == 76) {
#line 421
    goto case_76;
  }
#line 423
  if (yyn == 77) {
#line 423
    goto case_77;
  }
#line 425
  if (yyn == 78) {
#line 425
    goto case_78;
  }
#line 427
  if (yyn == 79) {
#line 427
    goto case_79;
  }
#line 429
  if (yyn == 80) {
#line 429
    goto case_80;
  }
#line 431
  if (yyn == 81) {
#line 431
    goto case_81;
  }
#line 433
  if (yyn == 82) {
#line 433
    goto case_82;
  }
#line 435
  if (yyn == 83) {
#line 435
    goto case_83;
  }
#line 438
  if (yyn == 84) {
#line 438
    goto case_84;
  }
#line 444
  if (yyn == 88) {
#line 444
    goto case_88;
  }
#line 454
  if (yyn == 89) {
#line 454
    goto case_89;
  }
#line 457
  if (yyn == 90) {
#line 457
    goto case_90;
  }
#line 460
  if (yyn == 92) {
#line 460
    goto case_92;
  }
#line 468
  if (yyn == 93) {
#line 468
    goto case_93;
  }
#line 474
  if (yyn == 94) {
#line 474
    goto case_94;
  }
#line 479
  if (yyn == 95) {
#line 479
    goto case_95;
  }
#line 484
  if (yyn == 96) {
#line 484
    goto case_96;
  }
#line 487
  if (yyn == 97) {
#line 487
    goto case_97;
  }
#line 489
  if (yyn == 98) {
#line 489
    goto case_98;
  }
#line 491
  if (yyn == 99) {
#line 491
    goto case_99;
  }
#line 493
  if (yyn == 100) {
#line 493
    goto case_100;
  }
#line 495
  if (yyn == 101) {
#line 495
    goto case_101;
  }
#line 497
  if (yyn == 102) {
#line 497
    goto case_102;
  }
#line 499
  if (yyn == 103) {
#line 499
    goto case_103;
  }
#line 501
  if (yyn == 104) {
#line 501
    goto case_104;
  }
#line 503
  if (yyn == 105) {
#line 503
    goto case_105;
  }
#line 506
  if (yyn == 106) {
#line 506
    goto case_106;
  }
#line 514
  if (yyn == 107) {
#line 514
    goto case_107;
  }
#line 517
  if (yyn == 108) {
#line 517
    goto case_108;
  }
#line 520
  if (yyn == 109) {
#line 520
    goto case_109;
  }
#line 522
  if (yyn == 110) {
#line 522
    goto case_110;
  }
#line 524
  if (yyn == 111) {
#line 524
    goto case_111;
  }
#line 526
  if (yyn == 112) {
#line 526
    goto case_112;
  }
#line 528
  if (yyn == 113) {
#line 528
    goto case_113;
  }
#line 530
  if (yyn == 115) {
#line 530
    goto case_115;
  }
#line 537
  if (yyn == 117) {
#line 537
    goto case_117;
  }
#line 541
  if (yyn == 118) {
#line 541
    goto case_118;
  }
#line 543
  if (yyn == 119) {
#line 543
    goto case_119;
  }
#line 548
  if (yyn == 120) {
#line 548
    goto case_120;
  }
#line 550
  if (yyn == 121) {
#line 550
    goto case_121;
  }
#line 552
  if (yyn == 137) {
#line 552
    goto case_137;
  }
#line 580
  if (yyn == 141) {
#line 580
    goto case_141;
  }
#line 592
  if (yyn == 142) {
#line 592
    goto case_142;
  }
#line 595
  if (yyn == 143) {
#line 595
    goto case_143;
  }
#line 597
  if (yyn == 146) {
#line 597
    goto case_146;
  }
#line 604
  if (yyn == 147) {
#line 604
    goto case_147;
  }
#line 608
  if (yyn == 150) {
#line 608
    goto case_150;
  }
#line 619
  if (yyn == 169) {
#line 619
    goto case_169;
  }
#line 653
  if (yyn == 170) {
#line 653
    goto case_170;
  }
#line 656
  if (yyn == 171) {
#line 656
    goto case_171;
  }
#line 658
  if (yyn == 172) {
#line 658
    goto case_172;
  }
#line 660
  if (yyn == 173) {
#line 660
    goto case_173;
  }
#line 662
  if (yyn == 174) {
#line 662
    goto case_174;
  }
#line 664
  if (yyn == 175) {
#line 664
    goto case_175;
  }
#line 666
  if (yyn == 176) {
#line 666
    goto case_176;
  }
#line 668
  if (yyn == 178) {
#line 668
    goto case_178;
  }
#line 672
  if (yyn == 197) {
#line 672
    goto case_197;
  }
#line 699
  if (yyn == 198) {
#line 699
    goto case_198;
  }
#line 701
  if (yyn == 199) {
#line 701
    goto case_199;
  }
#line 703
  if (yyn == 200) {
#line 703
    goto case_200;
  }
#line 705
  if (yyn == 204) {
#line 705
    goto case_204;
  }
#line 712
  if (yyn == 205) {
#line 712
    goto case_205;
  }
#line 714
  if (yyn == 206) {
#line 714
    goto case_206;
  }
#line 717
  if (yyn == 212) {
#line 717
    goto case_212;
  }
#line 726
  if (yyn == 213) {
#line 726
    goto case_213;
  }
#line 731
  if (yyn == 221) {
#line 731
    goto case_221;
  }
#line 744
  if (yyn == 222) {
#line 744
    goto case_222;
  }
#line 746
  if (yyn == 241) {
#line 746
    goto case_241;
  }
#line 772
  if (yyn == 242) {
#line 772
    goto case_242;
  }
#line 774
  if (yyn == 244) {
#line 774
    goto case_244;
  }
#line 779
  if (yyn == 245) {
#line 779
    goto case_245;
  }
#line 782
  if (yyn == 246) {
#line 782
    goto case_246;
  }
#line 784
  if (yyn == 247) {
#line 784
    goto case_247;
  }
#line 786
  if (yyn == 248) {
#line 786
    goto case_248;
  }
#line 788
  if (yyn == 258) {
#line 788
    goto case_258;
  }
#line 809
  if (yyn == 259) {
#line 809
    goto case_259;
  }
#line 811
  if (yyn == 260) {
#line 811
    goto case_260;
  }
#line 817
  if (yyn == 266) {
#line 817
    goto case_266;
  }
#line 829
  if (yyn == 267) {
#line 829
    goto case_267;
  }
#line 831
  if (yyn == 268) {
#line 831
    goto case_268;
  }
#line 833
  if (yyn == 269) {
#line 833
    goto case_269;
  }
#line 835
  if (yyn == 270) {
#line 835
    goto case_270;
  }
#line 841
  if (yyn == 273) {
#line 841
    goto case_273;
  }
#line 847
  if (yyn == 274) {
#line 847
    goto case_274;
  }
#line 849
  if (yyn == 275) {
#line 849
    goto case_275;
  }
#line 851
  if (yyn == 276) {
#line 851
    goto case_276;
  }
#line 853
  if (yyn == 277) {
#line 853
    goto case_277;
  }
#line 855
  if (yyn == 278) {
#line 855
    goto case_278;
  }
#line 857
  if (yyn == 279) {
#line 857
    goto case_279;
  }
#line 859
  if (yyn == 280) {
#line 859
    goto case_280;
  }
#line 861
  if (yyn == 284) {
#line 861
    goto case_284;
  }
#line 869
  if (yyn == 285) {
#line 869
    goto case_285;
  }
#line 2765 "bsdl_bison.c"
  goto switch_default;
  case_23: /* CIL Label */ 
  {
#line 257 "bsdl_bison.y"
  Print_Error___0(priv_data, "Unsupported BSDL construct found");
#line 258
  tmp___0 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 258
  if (tmp___0 > 0) {
    {
#line 258
    Give_Up_And_Quit___0(priv_data);
    }
#line 258
    goto yyabortlab;
  }
#line 259
  goto yyabortlab;
#line 261
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 272
  free((void *)(yyvsp + -2)->str);
  }
#line 273
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 281
  free((void *)(yyvsp + 0)->str);
  }
#line 282
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 283
  free((void *)(yyvsp + -3)->str);
  }
#line 284
  goto switch_break;
  case_40: /* CIL Label */ 
#line 309
  (priv_data->jtag_ctrl)->instr_len = (yyvsp + 0)->integer;
#line 310
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 319
  Print_Error___0(priv_data, "Error in Instruction_Opcode attribute statement");
#line 321
  tmp___1 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 321
  if (tmp___1 > 0) {
    {
#line 321
    Give_Up_And_Quit___0(priv_data);
    }
#line 321
    goto yyabortlab;
  }
#line 322
  goto yyabortlab;
#line 324
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 326
  add_instruction(priv_data, (yyvsp + -3)->str, (yyvsp + -1)->str);
  }
#line 327
  goto switch_break;
  case_46: /* CIL Label */ 
#line 329
  yyval.str = (yyvsp + 0)->str;
#line 330
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 332
  Print_Warning(priv_data, "Multiple opcode patterns are not supported, first pattern will be used");
#line 334
  yyval.str = (yyvsp + -2)->str;
#line 335
  free((void *)(yyvsp + 0)->str);
  }
#line 337
  goto switch_break;
  case_48: /* CIL Label */ 
#line 339
  yyval.str = (yyvsp + 0)->str;
#line 340
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 344
  free((void *)(yyvsp + 0)->str);
  }
#line 345
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 349
  free((void *)(yyvsp + 0)->str);
  }
#line 350
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 354
  free((void *)(yyvsp + 0)->str);
  }
#line 355
  goto switch_break;
  case_55: /* CIL Label */ 
  {
#line 364
  Print_Error___0(priv_data, "Error in Opcode List");
#line 365
  tmp___2 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 365
  if (tmp___2 > 0) {
    {
#line 365
    Give_Up_And_Quit___0(priv_data);
    }
#line 365
    goto yyabortlab;
  }
#line 366
  goto yyabortlab;
#line 368
  goto switch_break;
  case_56: /* CIL Label */ 
  {
#line 370
  free((void *)(yyvsp + 0)->str);
  }
#line 371
  goto switch_break;
  case_57: /* CIL Label */ 
#line 375
  (priv_data->jtag_ctrl)->idcode = (yyvsp + 0)->str;
#line 376
  goto switch_break;
  case_58: /* CIL Label */ 
#line 380
  (priv_data->jtag_ctrl)->usercode = (yyvsp + 0)->str;
#line 381
  goto switch_break;
  case_62: /* CIL Label */ 
  {
#line 390
  ac_apply_assoc(priv_data);
  }
#line 391
  goto switch_break;
  case_63: /* CIL Label */ 
  {
#line 393
  ac_set_register(priv_data, (yyvsp + 0)->str, 0);
  }
#line 394
  goto switch_break;
  case_64: /* CIL Label */ 
  {
#line 395
  ac_set_register(priv_data, (yyvsp + -3)->str, (yyvsp + -1)->integer);
  }
#line 396
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 398
  yyval.str = strdup("BOUNDARY");
  }
#line 399
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 400
  yyval.str = strdup("BYPASS");
  }
#line 401
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 402
  yyval.str = strdup("IDCODE");
  }
#line 403
  goto switch_break;
  case_68: /* CIL Label */ 
  {
#line 404
  yyval.str = strdup("USERCODE");
  }
#line 405
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 406
  yyval.str = strdup("DEVICE_ID");
  }
#line 407
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 412
  yyval.str = strdup("BYPASS");
  }
#line 413
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 414
  yyval.str = strdup("CLAMP");
  }
#line 415
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 416
  yyval.str = strdup("EXTEST");
  }
#line 417
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 418
  yyval.str = strdup("HIGHZ");
  }
#line 419
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 420
  yyval.str = strdup("IDCODE");
  }
#line 421
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 422
  yyval.str = strdup("INTEST");
  }
#line 423
  goto switch_break;
  case_78: /* CIL Label */ 
  {
#line 424
  yyval.str = strdup("PRELOAD");
  }
#line 425
  goto switch_break;
  case_79: /* CIL Label */ 
  {
#line 426
  yyval.str = strdup("RUNBIST");
  }
#line 427
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 428
  yyval.str = strdup("SAMPLE");
  }
#line 429
  goto switch_break;
  case_81: /* CIL Label */ 
  {
#line 430
  yyval.str = strdup("USERCODE");
  }
#line 431
  goto switch_break;
  case_82: /* CIL Label */ 
#line 432
  yyval.str = (yyvsp + 0)->str;
#line 433
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 435
  ac_add_instruction(priv_data, (yyvsp + 0)->str);
  }
#line 436
  goto switch_break;
  case_84: /* CIL Label */ 
#line 441
  (priv_data->jtag_ctrl)->bsr_len = (yyvsp + 0)->integer;
#line 442
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 450
  Print_Error___0(priv_data, "Error in Boundary Cell description");
#line 451
  tmp___3 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 451
  if (tmp___3 > 0) {
    {
#line 451
    Give_Up_And_Quit___0(priv_data);
    }
#line 451
    goto yyabortlab;
  }
#line 451
  goto yyabortlab;
#line 452
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 454
  ci_append_cell_info(priv_data, (yyvsp + -3)->integer);
  }
#line 455
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 457
  ci_no_disable(priv_data);
  }
#line 458
  goto switch_break;
  case_92: /* CIL Label */ 
  {
#line 463
  free((void *)(yyvsp + -6)->str);
#line 464
  ci_set_cell_spec(priv_data, (yyvsp + -2)->integer, (yyvsp + 0)->str);
  }
#line 466
  goto switch_break;
  case_93: /* CIL Label */ 
  {
#line 469
  prt_add_name(priv_data, (yyvsp + 0)->str);
#line 470
  prt_add_bit(priv_data);
  }
#line 472
  goto switch_break;
  case_94: /* CIL Label */ 
  {
#line 474
  prt_add_name(priv_data, (yyvsp + -3)->str);
#line 475
  prt_add_range(priv_data, (yyvsp + -1)->integer, (yyvsp + -1)->integer);
  }
#line 477
  goto switch_break;
  case_95: /* CIL Label */ 
  {
#line 479
  tmp___4 = strdup("*");
#line 479
  prt_add_name(priv_data, tmp___4);
#line 480
  prt_add_bit(priv_data);
  }
#line 482
  goto switch_break;
  case_96: /* CIL Label */ 
#line 484
  yyval.integer = 280;
#line 485
  goto switch_break;
  case_97: /* CIL Label */ 
#line 486
  yyval.integer = 281;
#line 487
  goto switch_break;
  case_98: /* CIL Label */ 
#line 488
  yyval.integer = 282;
#line 489
  goto switch_break;
  case_99: /* CIL Label */ 
#line 490
  yyval.integer = 283;
#line 491
  goto switch_break;
  case_100: /* CIL Label */ 
#line 492
  yyval.integer = 284;
#line 493
  goto switch_break;
  case_101: /* CIL Label */ 
#line 494
  yyval.integer = 285;
#line 495
  goto switch_break;
  case_102: /* CIL Label */ 
#line 496
  yyval.integer = 286;
#line 497
  goto switch_break;
  case_103: /* CIL Label */ 
#line 498
  yyval.integer = 287;
#line 499
  goto switch_break;
  case_104: /* CIL Label */ 
#line 500
  yyval.integer = 308;
#line 501
  goto switch_break;
  case_105: /* CIL Label */ 
#line 503
  yyval.str = (yyvsp + 0)->str;
#line 504
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 507
  tmp___6 = malloc((size_t )2);
#line 507
  tmp___5 = (char *)tmp___6;
#line 508
  snprintf((char */* __restrict  */)tmp___5, (size_t )2, (char const   */* __restrict  */)"%i",
           (yyvsp + 0)->integer);
#line 509
  *(tmp___5 + 1) = (char )'\000';
#line 510
  yyval.str = tmp___5;
  }
#line 512
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 514
  ci_set_cell_spec_disable(priv_data, (yyvsp + -4)->integer, (yyvsp + -2)->integer,
                           (yyvsp + 0)->integer);
  }
#line 515
  goto switch_break;
  case_108: /* CIL Label */ 
#line 517
  yyval.integer = 290;
#line 518
  goto switch_break;
  case_109: /* CIL Label */ 
#line 519
  yyval.integer = 291;
#line 520
  goto switch_break;
  case_110: /* CIL Label */ 
#line 521
  yyval.integer = 292;
#line 522
  goto switch_break;
  case_111: /* CIL Label */ 
#line 523
  yyval.integer = 294;
#line 524
  goto switch_break;
  case_112: /* CIL Label */ 
#line 525
  yyval.integer = 295;
#line 526
  goto switch_break;
  case_113: /* CIL Label */ 
#line 527
  yyval.integer = 296;
#line 528
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 534
  bsdl_flex_set_bin_x(priv_data->scanner);
  }
#line 535
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 538
  free((void *)(yyvsp + 0)->str);
  }
#line 539
  goto switch_break;
  case_118: /* CIL Label */ 
  {
#line 540
  free((void *)(yyvsp + 0)->str);
  }
#line 541
  goto switch_break;
  case_119: /* CIL Label */ 
#line 545
  (priv_data->jtag_ctrl)->conformance = (bsdl_conformance_t )0;
#line 546
  goto switch_break;
  case_120: /* CIL Label */ 
#line 547
  (priv_data->jtag_ctrl)->conformance = (bsdl_conformance_t )1;
#line 548
  goto switch_break;
  case_121: /* CIL Label */ 
#line 549
  (priv_data->jtag_ctrl)->conformance = (bsdl_conformance_t )2;
#line 550
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 574
  Print_Error___0(priv_data, "Error in ISC_Pin_Behavior Definition");
#line 575
  tmp___7 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 575
  if (tmp___7 > 0) {
    {
#line 575
    Give_Up_And_Quit___0(priv_data);
    }
#line 575
    goto yyabortlab;
  }
#line 576
  goto yyabortlab;
#line 578
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 586
  Print_Error___0(priv_data, "Error in ISC_Fixed_System_Pins Definition");
#line 587
  tmp___8 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 587
  if (tmp___8 > 0) {
    {
#line 587
    Give_Up_And_Quit___0(priv_data);
    }
#line 587
    goto yyabortlab;
  }
#line 588
  goto yyabortlab;
#line 590
  goto switch_break;
  case_142: /* CIL Label */ 
  {
#line 592
  free((void *)(yyvsp + 0)->str);
  }
#line 593
  goto switch_break;
  case_143: /* CIL Label */ 
  {
#line 594
  free((void *)(yyvsp + -3)->str);
  }
#line 595
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 601
  free((void *)(yyvsp + 0)->str);
  }
#line 602
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 605
  free((void *)(yyvsp + 0)->str);
  }
#line 606
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 613
  Print_Error___0(priv_data, "Error in ISC_Security Definition");
#line 614
  tmp___9 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 614
  if (tmp___9 > 0) {
    {
#line 614
    Give_Up_And_Quit___0(priv_data);
    }
#line 614
    goto yyabortlab;
  }
#line 615
  goto yyabortlab;
#line 617
  goto switch_break;
  case_169: /* CIL Label */ 
  {
#line 647
  Print_Error___0(priv_data, "Error in ISC_Flow Definition");
#line 648
  tmp___10 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 648
  if (tmp___10 > 0) {
    {
#line 648
    Give_Up_And_Quit___0(priv_data);
    }
#line 648
    goto yyabortlab;
  }
#line 649
  goto yyabortlab;
#line 651
  goto switch_break;
  case_170: /* CIL Label */ 
  {
#line 653
  free((void *)(yyvsp + 0)->str);
  }
#line 654
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 655
  free((void *)(yyvsp + -1)->str);
  }
#line 656
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 657
  free((void *)(yyvsp + -2)->str);
  }
#line 658
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 659
  free((void *)(yyvsp + -3)->str);
  }
#line 660
  goto switch_break;
  case_174: /* CIL Label */ 
  {
#line 661
  free((void *)(yyvsp + -1)->str);
  }
#line 662
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 663
  free((void *)(yyvsp + -2)->str);
  }
#line 664
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 665
  free((void *)(yyvsp + -1)->str);
  }
#line 666
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 669
  free((void *)(yyvsp + -1)->str);
  }
#line 670
  goto switch_break;
  case_197: /* CIL Label */ 
  {
#line 696
  free((void *)(yyvsp + -2)->str);
  }
#line 697
  goto switch_break;
  case_198: /* CIL Label */ 
  {
#line 698
  free((void *)(yyvsp + -3)->str);
  }
#line 699
  goto switch_break;
  case_199: /* CIL Label */ 
  {
#line 700
  free((void *)(yyvsp + -3)->str);
  }
#line 701
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 702
  free((void *)(yyvsp + -4)->str);
  }
#line 703
  goto switch_break;
  case_204: /* CIL Label */ 
  {
#line 709
  bsdl_flex_set_hex(priv_data->scanner);
  }
#line 710
  goto switch_break;
  case_205: /* CIL Label */ 
  {
#line 711
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 712
  goto switch_break;
  case_206: /* CIL Label */ 
  {
#line 714
  free((void *)(yyvsp + 0)->str);
  }
#line 715
  goto switch_break;
  case_212: /* CIL Label */ 
  {
#line 723
  bsdl_flex_set_hex(priv_data->scanner);
  }
#line 724
  goto switch_break;
  case_213: /* CIL Label */ 
  {
#line 726
  free((void *)(yyvsp + 0)->str);
#line 727
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 729
  goto switch_break;
  case_221: /* CIL Label */ 
  {
#line 741
  bsdl_flex_set_hex(priv_data->scanner);
  }
#line 742
  goto switch_break;
  case_222: /* CIL Label */ 
  {
#line 743
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 744
  goto switch_break;
  case_241: /* CIL Label */ 
  {
#line 769
  free((void *)(yyvsp + 0)->str);
  }
#line 770
  goto switch_break;
  case_242: /* CIL Label */ 
  {
#line 771
  free((void *)(yyvsp + 0)->str);
  }
#line 772
  goto switch_break;
  case_244: /* CIL Label */ 
  {
#line 776
  free((void *)(yyvsp + 0)->str);
  }
#line 777
  goto switch_break;
  case_245: /* CIL Label */ 
  {
#line 779
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 780
  goto switch_break;
  case_246: /* CIL Label */ 
  {
#line 781
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 782
  goto switch_break;
  case_247: /* CIL Label */ 
  {
#line 783
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 784
  goto switch_break;
  case_248: /* CIL Label */ 
  {
#line 785
  bsdl_flex_set_decimal(priv_data->scanner);
  }
#line 786
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 806
  free((void *)(yyvsp + -4)->str);
  }
#line 807
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 808
  free((void *)(yyvsp + -5)->str);
  }
#line 809
  goto switch_break;
  case_260: /* CIL Label */ 
  {
#line 811
  Print_Error___0(priv_data, "Error in ISC_Procedure Definition");
#line 812
  tmp___11 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 812
  if (tmp___11 > 0) {
    {
#line 812
    Give_Up_And_Quit___0(priv_data);
    }
#line 812
    goto yyabortlab;
  }
#line 813
  goto yyabortlab;
#line 815
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 826
  free((void *)(yyvsp + -4)->str);
  }
#line 827
  goto switch_break;
  case_267: /* CIL Label */ 
  {
#line 828
  free((void *)(yyvsp + -5)->str);
  }
#line 829
  goto switch_break;
  case_268: /* CIL Label */ 
  {
#line 830
  free((void *)(yyvsp + -5)->str);
  }
#line 831
  goto switch_break;
  case_269: /* CIL Label */ 
  {
#line 832
  free((void *)(yyvsp + -6)->str);
  }
#line 833
  goto switch_break;
  case_270: /* CIL Label */ 
  {
#line 835
  Print_Error___0(priv_data, "Error in ISC_Action Definition");
#line 836
  tmp___12 = bsdl_flex_postinc_compile_errors(priv_data->scanner);
  }
#line 836
  if (tmp___12 > 0) {
    {
#line 836
    Give_Up_And_Quit___0(priv_data);
    }
#line 836
    goto yyabortlab;
  }
#line 837
  goto yyabortlab;
#line 839
  goto switch_break;
  case_273: /* CIL Label */ 
  {
#line 844
  free((void *)(yyvsp + 0)->str);
  }
#line 845
  goto switch_break;
  case_274: /* CIL Label */ 
  {
#line 846
  free((void *)(yyvsp + -1)->str);
  }
#line 847
  goto switch_break;
  case_275: /* CIL Label */ 
  {
#line 848
  free((void *)(yyvsp + -2)->str);
  }
#line 849
  goto switch_break;
  case_276: /* CIL Label */ 
  {
#line 850
  free((void *)(yyvsp + -2)->str);
  }
#line 851
  goto switch_break;
  case_277: /* CIL Label */ 
  {
#line 852
  free((void *)(yyvsp + -3)->str);
  }
#line 853
  goto switch_break;
  case_278: /* CIL Label */ 
  {
#line 854
  free((void *)(yyvsp + -1)->str);
  }
#line 855
  goto switch_break;
  case_279: /* CIL Label */ 
  {
#line 856
  free((void *)(yyvsp + -2)->str);
  }
#line 857
  goto switch_break;
  case_280: /* CIL Label */ 
  {
#line 858
  free((void *)(yyvsp + -1)->str);
  }
#line 859
  goto switch_break;
  case_284: /* CIL Label */ 
  {
#line 866
  free((void *)(yyvsp + 0)->str);
  }
#line 867
  goto switch_break;
  case_285: /* CIL Label */ 
  {
#line 868
  free((void *)(yyvsp + 0)->str);
  }
#line 869
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2765 "bsdl_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2769
  yyvsp -= yylen;
#line 2769
  yyssp -= yylen;
#line 2770
  yylen = 0;
#line 2773
  yyvsp ++;
#line 2773
  *yyvsp = yyval;
#line 2780
  yyn = (int )yyr1___0[yyn];
#line 2782
  yystate = (int )((int const   )yypgoto___0[yyn - 114] + (int const   )*yyssp);
#line 2783
  if (0 <= yystate) {
#line 2783
    if (yystate <= 434) {
#line 2783
      if ((int const   )yycheck___0[yystate] == (int const   )*yyssp) {
#line 2784
        yystate = (int )yytable___0[yystate];
      } else {
#line 2786
        yystate = (int )yydefgoto___0[yyn - 114];
      }
    } else {
#line 2786
      yystate = (int )yydefgoto___0[yyn - 114];
    }
  } else {
#line 2786
    yystate = (int )yydefgoto___0[yyn - 114];
  }
#line 2788
  goto yynewstate;
  yyerrlab: 
#line 2796
  if (! yyerrstatus) {
    {
#line 2798
    bsdlnerrs ++;
#line 2800
    bsdlerror(priv_data, "syntax error");
    }
  }
#line 2838
  if (yyerrstatus == 3) {
#line 2843
    if (bsdlchar <= 0) {
#line 2846
      if (bsdlchar == 0) {
#line 2847
        goto yyabortlab;
      }
    } else {
      {
#line 2851
      yydestruct___0("Error: discarding", yytoken, & bsdllval, priv_data);
#line 2853
      bsdlchar = -2;
      }
    }
  }
#line 2859
  goto yyerrlab1;
#line 2875
  yyvsp -= yylen;
#line 2875
  yyssp -= yylen;
#line 2876
  yylen = 0;
#line 2878
  yystate = (int )*yyssp;
#line 2879
  goto yyerrlab1;
  yyerrlab1: 
#line 2886
  yyerrstatus = 3;
  {
#line 2888
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2890
    yyn = (int )yypact___0[yystate];
#line 2891
    if (yyn != -326) {
#line 2893
      yyn ++;
#line 2894
      if (0 <= yyn) {
#line 2894
        if (yyn <= 434) {
#line 2894
          if ((int const   )yycheck___0[yyn] == 1) {
#line 2896
            yyn = (int )yytable___0[yyn];
#line 2897
            if (0 < yyn) {
#line 2898
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2903
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2904
      goto yyabortlab;
    }
    {
#line 2907
    yydestruct___0("Error: popping", (int )yystos___0[yystate], yyvsp, priv_data);
#line 2909
    yyvsp --;
#line 2909
    yyssp --;
#line 2910
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2914
  if (yyn == 138) {
#line 2915
    goto yyacceptlab;
  }
#line 2917
  yyvsp ++;
#line 2917
  *yyvsp = bsdllval;
#line 2923
  yystate = yyn;
#line 2924
  goto yynewstate;
  yyacceptlab: 
#line 2931
  yyresult = 0;
#line 2932
  goto yyreturn;
  yyabortlab: 
#line 2938
  yyresult = 1;
#line 2939
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2946
  bsdlerror(priv_data, "memory exhausted");
#line 2947
  yyresult = 2;
  }
  yyreturn: 
#line 2952
  if (bsdlchar != 0) {
#line 2952
    if (bsdlchar != -2) {
      {
#line 2953
      yydestruct___0("Cleanup: discarding lookahead", yytoken, & bsdllval, priv_data);
      }
    }
  }
#line 2957
  yyvsp -= yylen;
#line 2957
  yyssp -= yylen;
  {
#line 2959
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2959
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2959
      goto while_break___2;
    }
    {
#line 2961
    yydestruct___0("Cleanup: popping", (int )yystos___0[*yyssp], yyvsp, priv_data);
#line 2963
    yyvsp --;
#line 2963
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2966
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2967
    free((void *)yyss);
    }
  }
#line 2974
  return (yyresult);
}
}
#line 872 "bsdl_bison.y"
static void Print_Error___0(bsdl_parser_priv_t *priv_data , char const   *Errmess ) 
{ 


  {
  {
#line 874
  bsdl_msg((priv_data->jtag_ctrl)->proc_mode, 2, "Line %d, %s.\n", priv_data->lineno,
           Errmess);
  }
#line 878
  return;
}
}
#line 880 "bsdl_bison.y"
static void Print_Warning(bsdl_parser_priv_t *priv_data , char const   *Warnmess ) 
{ 


  {
  {
#line 882
  bsdl_msg((priv_data->jtag_ctrl)->proc_mode, 1, "Line %d, %s.\n", priv_data->lineno,
           Warnmess);
  }
#line 886
  return;
}
}
#line 888 "bsdl_bison.y"
static void Give_Up_And_Quit___0(bsdl_parser_priv_t *priv_data ) 
{ 


  {
  {
#line 891
  bsdl_flex_stop_buffer(priv_data->scanner);
  }
#line 892
  return;
}
}
#line 894 "bsdl_bison.y"
void bsdlerror(bsdl_parser_priv_t *priv_data , char const   *error_string ) 
{ 


  {
#line 896
  return;
}
}
#line 911 "bsdl_bison.y"
static void bsdl_sem_init(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;

  {
#line 913
  jc = priv->jtag_ctrl;
#line 915
  jc->instr_len = -1;
#line 916
  jc->bsr_len = -1;
#line 917
  jc->conformance = (bsdl_conformance_t )3;
#line 918
  jc->idcode = (char *)((void *)0);
#line 919
  jc->usercode = (char *)((void *)0);
#line 921
  jc->instr_list = (instr_elem_t *)((void *)0);
#line 923
  priv->ainfo.next = (struct ainfo_elem *)((void *)0);
#line 924
  priv->ainfo.reg = (char *)((void *)0);
#line 925
  priv->ainfo.instr_list = (instr_elem_t *)((void *)0);
#line 926
  jc->ainfo_list = (ainfo_elem_t *)((void *)0);
#line 928
  priv->tmp_cell_info.next = (struct cell_info *)((void *)0);
#line 929
  priv->tmp_cell_info.port_name = (char *)((void *)0);
#line 930
  priv->tmp_cell_info.basic_safe_value = (char *)((void *)0);
#line 931
  jc->cell_info_first = (cell_info_t *)((void *)0);
#line 932
  jc->cell_info_last = (cell_info_t *)((void *)0);
#line 934
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
#line 935
  priv->tmp_port_desc.next = (struct port_desc *)((void *)0);
#line 936
  return;
}
}
#line 950 "bsdl_bison.y"
static void free_instr_list(instr_elem_t *il ) 
{ 


  {
#line 952
  if (il) {
#line 954
    if (il->instr) {
      {
#line 955
      free((void *)il->instr);
      }
    }
#line 956
    if (il->opcode) {
      {
#line 957
      free((void *)il->opcode);
      }
    }
    {
#line 958
    free_instr_list(il->next);
#line 959
    free((void *)il);
    }
  }
#line 961
  return;
}
}
#line 976 "bsdl_bison.y"
static void free_ainfo_list(ainfo_elem_t *ai , int free_me ) 
{ 


  {
#line 978
  if (ai) {
#line 980
    if (ai->reg) {
      {
#line 981
      free((void *)ai->reg);
      }
    }
    {
#line 983
    free_instr_list(ai->instr_list);
#line 984
    free_ainfo_list(ai->next, 1);
    }
#line 986
    if (free_me) {
      {
#line 987
      free((void *)ai);
      }
    }
  }
#line 989
  return;
}
}
#line 1003 "bsdl_bison.y"
static void free_string_list___0(string_elem_t *sl ) 
{ 


  {
#line 1005
  if (sl) {
#line 1007
    if (sl->string) {
      {
#line 1008
      free((void *)sl->string);
      }
    }
    {
#line 1009
    free_string_list___0(sl->next);
#line 1010
    free((void *)sl);
    }
  }
#line 1012
  return;
}
}
#line 1028 "bsdl_bison.y"
static void free_ci_list(cell_info_t *ci , int free_me ) 
{ 


  {
#line 1030
  if (ci) {
    {
#line 1032
    free_ci_list(ci->next, 1);
    }
#line 1034
    if (ci->port_name) {
      {
#line 1035
      free((void *)ci->port_name);
      }
    }
#line 1037
    if (ci->basic_safe_value) {
      {
#line 1038
      free((void *)ci->basic_safe_value);
      }
    }
#line 1040
    if (free_me) {
      {
#line 1041
      free((void *)ci);
      }
    }
  }
#line 1043
  return;
}
}
#line 1058 "bsdl_bison.y"
static void bsdl_sem_deinit(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;
  cell_info_t *tmp ;

  {
#line 1060
  jc = priv->jtag_ctrl;
#line 1062
  if (jc->idcode) {
    {
#line 1064
    free((void *)jc->idcode);
#line 1065
    jc->idcode = (char *)((void *)0);
    }
  }
#line 1068
  if (jc->usercode) {
    {
#line 1070
    free((void *)jc->usercode);
#line 1071
    jc->usercode = (char *)((void *)0);
    }
  }
  {
#line 1075
  free_ci_list(jc->cell_info_first, 1);
#line 1076
  tmp = (cell_info_t *)((void *)0);
#line 1076
  jc->cell_info_last = tmp;
#line 1076
  jc->cell_info_first = tmp;
#line 1077
  free_ci_list(& priv->tmp_cell_info, 0);
#line 1080
  free_instr_list(jc->instr_list);
#line 1081
  jc->instr_list = (instr_elem_t *)((void *)0);
#line 1084
  free_ainfo_list(jc->ainfo_list, 1);
#line 1085
  jc->ainfo_list = (ainfo_elem_t *)((void *)0);
#line 1086
  free_ainfo_list(& priv->ainfo, 0);
#line 1089
  free_string_list___0(priv->tmp_port_desc.names_list);
#line 1090
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
  }
#line 1091
  return;
}
}
#line 1108 "bsdl_bison.y"
bsdl_parser_priv_t *bsdl_parser_init(jtag_ctrl_t *jtag_ctrl ) 
{ 
  bsdl_parser_priv_t *new_priv ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1112
  tmp = malloc(sizeof(bsdl_parser_priv_t ));
#line 1112
  new_priv = (bsdl_parser_priv_t *)tmp;
  }
#line 1112
  if (! new_priv) {
    {
#line 1113
    bsdl_msg(jtag_ctrl->proc_mode, 2, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1114);
    }
#line 1115
    return ((bsdl_parser_priv_t *)((void *)0));
  }
  {
#line 1118
  new_priv->jtag_ctrl = jtag_ctrl;
#line 1120
  tmp___0 = bsdl_flex_init(jtag_ctrl->proc_mode);
#line 1120
  new_priv->scanner = tmp___0;
  }
#line 1120
  if (! tmp___0) {
    {
#line 1121
    free((void *)new_priv);
#line 1122
    new_priv = (bsdl_parser_priv_t *)((void *)0);
    }
  }
  {
#line 1125
  bsdl_sem_init(new_priv);
  }
#line 1127
  return (new_priv);
}
}
#line 1145 "bsdl_bison.y"
void bsdl_parser_deinit(bsdl_parser_priv_t *priv_data ) 
{ 


  {
  {
#line 1147
  bsdl_sem_deinit(priv_data);
#line 1148
  bsdl_flex_deinit(priv_data->scanner);
#line 1149
  free((void *)priv_data);
  }
#line 1150
  return;
}
}
#line 1167 "bsdl_bison.y"
static void add_instruction(bsdl_parser_priv_t *priv , char *instr , char *opcode ) 
{ 
  instr_elem_t *new_instr ;
  void *tmp ;

  {
  {
#line 1171
  tmp = malloc(sizeof(instr_elem_t ));
#line 1171
  new_instr = (instr_elem_t *)tmp;
  }
#line 1172
  if (new_instr) {
#line 1174
    new_instr->next = (priv->jtag_ctrl)->instr_list;
#line 1175
    new_instr->instr = instr;
#line 1176
    new_instr->opcode = opcode;
#line 1178
    (priv->jtag_ctrl)->instr_list = new_instr;
  } else {
    {
#line 1181
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1182);
    }
  }
#line 1183
  return;
}
}
#line 1201 "bsdl_bison.y"
static void ac_set_register(bsdl_parser_priv_t *priv , char *reg , int reg_len ) 
{ 
  ainfo_elem_t *tmp_ai ;

  {
#line 1203
  tmp_ai = & priv->ainfo;
#line 1205
  tmp_ai->reg = reg;
#line 1206
  tmp_ai->reg_len = reg_len;
#line 1207
  return;
}
}
#line 1225 "bsdl_bison.y"
static void ac_add_instruction(bsdl_parser_priv_t *priv , char *instr ) 
{ 
  ainfo_elem_t *tmp_ai ;
  instr_elem_t *new_instr ;
  void *tmp ;

  {
  {
#line 1227
  tmp_ai = & priv->ainfo;
#line 1230
  tmp = malloc(sizeof(instr_elem_t ));
#line 1230
  new_instr = (instr_elem_t *)tmp;
  }
#line 1231
  if (new_instr) {
#line 1233
    new_instr->next = tmp_ai->instr_list;
#line 1234
    new_instr->instr = instr;
#line 1235
    new_instr->opcode = (char *)((void *)0);
#line 1237
    tmp_ai->instr_list = new_instr;
  } else {
    {
#line 1240
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1241);
    }
  }
#line 1242
  return;
}
}
#line 1258 "bsdl_bison.y"
static void ac_apply_assoc(bsdl_parser_priv_t *priv ) 
{ 
  jtag_ctrl_t *jc ;
  ainfo_elem_t *tmp_ai ;
  ainfo_elem_t *new_ai ;
  void *tmp ;

  {
  {
#line 1260
  jc = priv->jtag_ctrl;
#line 1261
  tmp_ai = & priv->ainfo;
#line 1264
  tmp = malloc(sizeof(ainfo_elem_t ));
#line 1264
  new_ai = (ainfo_elem_t *)tmp;
  }
#line 1265
  if (new_ai) {
#line 1267
    new_ai->next = jc->ainfo_list;
#line 1268
    new_ai->reg = tmp_ai->reg;
#line 1269
    new_ai->reg_len = tmp_ai->reg_len;
#line 1270
    new_ai->instr_list = tmp_ai->instr_list;
#line 1272
    jc->ainfo_list = new_ai;
  } else {
    {
#line 1275
    bsdl_msg(jc->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y", 1276);
    }
  }
#line 1279
  tmp_ai->reg = (char *)((void *)0);
#line 1280
  tmp_ai->reg_len = 0;
#line 1281
  tmp_ai->instr_list = (instr_elem_t *)((void *)0);
#line 1282
  return;
}
}
#line 1299 "bsdl_bison.y"
static void prt_add_name(bsdl_parser_priv_t *priv , char *name ) 
{ 
  port_desc_t *pd ;
  string_elem_t *new_string___1 ;
  void *tmp ;

  {
  {
#line 1301
  pd = & priv->tmp_port_desc;
#line 1304
  tmp = malloc(sizeof(string_elem_t ));
#line 1304
  new_string___1 = (string_elem_t *)tmp;
  }
#line 1305
  if (new_string___1) {
#line 1307
    new_string___1->next = pd->names_list;
#line 1308
    new_string___1->string = name;
#line 1310
    pd->names_list = new_string___1;
  } else {
    {
#line 1313
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1314);
    }
  }
#line 1315
  return;
}
}
#line 1332 "bsdl_bison.y"
static void prt_add_bit(bsdl_parser_priv_t *priv ) 
{ 
  port_desc_t *pd ;

  {
#line 1334
  pd = & priv->tmp_port_desc;
#line 1336
  pd->is_vector = 0;
#line 1337
  pd->low_idx = 0;
#line 1338
  pd->high_idx = 0;
#line 1339
  return;
}
}
#line 1357 "bsdl_bison.y"
static void prt_add_range(bsdl_parser_priv_t *priv , int low , int high ) 
{ 
  port_desc_t *pd ;

  {
#line 1359
  pd = & priv->tmp_port_desc;
#line 1361
  pd->is_vector = 1;
#line 1362
  pd->low_idx = low;
#line 1363
  pd->high_idx = high;
#line 1364
  return;
}
}
#line 1379 "bsdl_bison.y"
static void ci_no_disable(bsdl_parser_priv_t *priv ) 
{ 


  {
#line 1381
  priv->tmp_cell_info.ctrl_bit_num = -1;
#line 1382
  return;
}
}
#line 1402 "bsdl_bison.y"
static void ci_set_cell_spec_disable(bsdl_parser_priv_t *priv , int ctrl_bit_num ,
                                     int safe_value , int disable_value ) 
{ 
  cell_info_t *ci ;

  {
#line 1405
  ci = & priv->tmp_cell_info;
#line 1407
  ci->ctrl_bit_num = ctrl_bit_num;
#line 1408
  ci->disable_safe_value = safe_value;
#line 1410
  return;
}
}
#line 1431 "bsdl_bison.y"
static void ci_set_cell_spec(bsdl_parser_priv_t *priv , int function , char *safe_value ) 
{ 
  cell_info_t *ci ;
  port_desc_t *pd ;
  string_elem_t *name ;
  char *port_string ;
  size_t str_len ;
  size_t name_len ;
  void *tmp ;

  {
  {
#line 1434
  ci = & priv->tmp_cell_info;
#line 1435
  pd = & priv->tmp_port_desc;
#line 1436
  name = priv->tmp_port_desc.names_list;
#line 1440
  ci->cell_function = function;
#line 1441
  ci->basic_safe_value = safe_value;
#line 1449
  name_len = strlen((char const   *)name->string);
#line 1450
  str_len = (((name_len + 1UL) + 10UL) + 1UL) + 1UL;
#line 1451
  tmp = malloc(str_len);
#line 1451
  port_string = (char *)tmp;
  }
#line 1451
  if ((unsigned long )port_string != (unsigned long )((void *)0)) {
#line 1453
    if (pd->is_vector) {
      {
#line 1454
      snprintf((char */* __restrict  */)port_string, str_len - 1UL, (char const   */* __restrict  */)"%s(%d)",
               name->string, pd->low_idx);
      }
    } else {
      {
#line 1456
      strncpy((char */* __restrict  */)port_string, (char const   */* __restrict  */)name->string,
              str_len - 1UL);
      }
    }
#line 1457
    *(port_string + (str_len - 1UL)) = (char )'\000';
#line 1459
    ci->port_name = port_string;
  } else {
    {
#line 1463
    bsdl_msg((priv->jtag_ctrl)->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y",
             1464);
#line 1465
    ci->port_name = (char *)((void *)0);
    }
  }
  {
#line 1468
  free_string_list___0(priv->tmp_port_desc.names_list);
#line 1469
  priv->tmp_port_desc.names_list = (string_elem_t *)((void *)0);
  }
#line 1470
  return;
}
}
#line 1486 "bsdl_bison.y"
static void ci_append_cell_info(bsdl_parser_priv_t *priv , int bit_num ) 
{ 
  cell_info_t *tmp_ci ;
  cell_info_t *ci ;
  jtag_ctrl_t *jc ;
  void *tmp ;

  {
  {
#line 1488
  tmp_ci = & priv->tmp_cell_info;
#line 1490
  jc = priv->jtag_ctrl;
#line 1492
  tmp = malloc(sizeof(cell_info_t ));
#line 1492
  ci = (cell_info_t *)tmp;
  }
#line 1493
  if (ci) {
#line 1495
    ci->next = (struct cell_info *)((void *)0);
#line 1496
    if (jc->cell_info_last) {
#line 1497
      (jc->cell_info_last)->next = ci;
    } else {
#line 1499
      jc->cell_info_first = ci;
    }
#line 1500
    jc->cell_info_last = ci;
#line 1502
    ci->bit_num = bit_num;
#line 1503
    ci->port_name = tmp_ci->port_name;
#line 1504
    ci->cell_function = tmp_ci->cell_function;
#line 1505
    ci->basic_safe_value = tmp_ci->basic_safe_value;
#line 1506
    ci->ctrl_bit_num = tmp_ci->ctrl_bit_num;
#line 1507
    ci->disable_safe_value = tmp_ci->disable_safe_value;
#line 1509
    tmp_ci->port_name = (char *)((void *)0);
#line 1510
    tmp_ci->basic_safe_value = (char *)((void *)0);
  } else {
    {
#line 1513
    bsdl_msg(jc->proc_mode, 3, "Out of memory, %s line %i\n", "bsdl_bison.y", 1514);
    }
  }
#line 1515
  return;
}
}
#line 541 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 477 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 694
extern void rewind(FILE *__stream ) ;
#line 775
extern void perror(char const   *__s ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 159 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 165
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 196 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 240
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 455 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __useconds_t ( __attribute__((__leaf__)) ualarm)(__useconds_t __value ,
                                                                                      __useconds_t __interval ) ;
#line 35 "../../include/register.h"
tap_register *register_alloc(int len ) ;
#line 37
void register_free(tap_register *tr ) ;
#line 39
char const   *register_get_string(tap_register const   *tr ) ;
#line 41
tap_register *register_init(tap_register *tr , char const   *value ) ;
#line 60 "../../include/part.h"
instruction *part_find_instruction(part_t *p , char const   *iname ) ;
#line 63
void part_set_instruction(part_t *p , char const   *iname ) ;
#line 132 "../../include/cable.h"
int cable_set_trst(cable_t *cable , int trst ) ;
#line 141
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 142
uint32_t cable_get_frequency(cable_t *cable ) ;
#line 52 "../../include/chain.h"
void chain_clock(chain_t *chain , int tms , int tdi , int n ) ;
#line 57
void chain_shift_instructions_mode(chain_t *chain , int capture_output , int capture ,
                                   int exit___0 ) ;
#line 59
void chain_shift_data_registers_mode(chain_t *chain , int capture_output , int capture ,
                                     int exit___0 ) ;
#line 59 "../../include/state.h"
int tap_state(chain_t *chain ) ;
#line 62
int tap_state_reset(chain_t *chain ) ;
#line 116 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
int svf_bison_init(parser_priv_t *priv_data , FILE *f , int num_lines , int print_progress ) ;
#line 117
void svf_bison_deinit(parser_priv_t *priv_data ) ;
#line 119
void svf_endxr(parser_priv_t *priv , enum generic_irdr_coding ir_dr , int state ) ;
#line 120
void svf_frequency(chain_t *chain , double freq ) ;
#line 121
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 122
int svf_runtest(chain_t *chain , parser_priv_t *priv , struct runtest *params ) ;
#line 123
int svf_state(chain_t *chain , parser_priv_t *priv , struct path_states *path_states ,
              int stable_state ) ;
#line 124
int svf_sxr(chain_t *chain , parser_priv_t *priv , enum generic_irdr_coding ir_dr ,
            struct ths_params *params , struct YYLTYPE *loc ) ;
#line 125
int svf_trst(chain_t *chain , parser_priv_t *priv , int trst_mode ) ;
#line 126
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svfparse(parser_priv_t *priv_data , chain_t *chain ) ;
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static void svf_force_reset_state(chain_t *chain ) 
{ 


  {
  {
#line 69
  chain_clock(chain, 1, 0, 5);
#line 70
  tap_state_reset(chain);
  }
#line 71
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static void svf_goto_state(chain_t *chain , int new_state ) 
{ 
  int current_state ;

  {
  {
#line 91
  current_state = tap_state(chain);
  }
#line 94
  if (new_state == 1 << 7) {
#line 95
    new_state = (1 << 7) | (1 << 3);
  }
#line 98
  if (current_state == new_state) {
#line 99
    return;
  }
  {
#line 102
  if (current_state == ((1 << 7) | (1 << 3))) {
#line 102
    goto case_exp;
  }
#line 106
  if (current_state == 1 << 3) {
#line 106
    goto case_exp___0;
  }
#line 111
  if (current_state == 1 << 1) {
#line 111
    goto case_exp___1;
  }
#line 111
  if (current_state == 1) {
#line 111
    goto case_exp___1;
  }
#line 123
  if (current_state == ((1 | (1 << 2)) | (1 << 4))) {
#line 123
    goto case_exp___2;
  }
#line 132
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 132
    goto case_exp___3;
  }
#line 142
  if (current_state == ((1 << 1) | (1 << 2))) {
#line 142
    goto case_exp___4;
  }
#line 142
  if (current_state == (1 | (1 << 2))) {
#line 142
    goto case_exp___4;
  }
#line 147
  if (current_state == ((1 | (1 << 5)) | (1 << 6))) {
#line 147
    goto case_exp___6;
  }
#line 156
  if (current_state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 156
    goto case_exp___7;
  }
#line 166
  if (current_state == ((1 << 1) | (1 << 6))) {
#line 166
    goto case_exp___8;
  }
#line 166
  if (current_state == (1 | (1 << 6))) {
#line 166
    goto case_exp___8;
  }
#line 171
  if (current_state == ((1 | (1 << 2)) | (1 << 5))) {
#line 171
    goto case_exp___10;
  }
#line 180
  if (current_state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 180
    goto case_exp___11;
  }
#line 190
  if (current_state == ((1 << 1) | (1 << 3))) {
#line 190
    goto case_exp___12;
  }
#line 190
  if (current_state == (1 | (1 << 3))) {
#line 190
    goto case_exp___12;
  }
#line 199
  goto switch_default;
  case_exp: /* CIL Label */ 
  {
#line 103
  chain_clock(chain, 0, 0, 1);
  }
#line 104
  goto switch_break;
  case_exp___0: /* CIL Label */ 
  {
#line 107
  chain_clock(chain, 1, 0, 1);
  }
#line 108
  goto switch_break;
  case_exp___1: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 112
  if (new_state == ((1 << 7) | (1 << 3))) {
    {
#line 117
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 112
  if (new_state == 1 << 3) {
    {
#line 117
    chain_clock(chain, 1, 0, 1);
    }
  } else
#line 112
  if (current_state & 1) {
#line 112
    if (new_state & (1 << 1)) {
      {
#line 117
      chain_clock(chain, 1, 0, 1);
      }
    } else {
#line 112
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 112
  if (current_state & (1 << 1)) {
#line 112
    if (new_state & 1) {
      {
#line 117
      chain_clock(chain, 1, 0, 1);
      }
    } else {
      {
#line 120
      chain_clock(chain, 0, 0, 1);
      }
    }
  } else {
    {
#line 120
    chain_clock(chain, 0, 0, 1);
    }
  }
#line 121
  goto switch_break;
  case_exp___2: /* CIL Label */ 
#line 124
  if (new_state == (1 | (1 << 2))) {
    {
#line 126
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 129
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 130
  goto switch_break;
  case_exp___3: /* CIL Label */ 
#line 133
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 135
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 138
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 139
  goto switch_break;
  case_exp___4: /* CIL Label */ 
  case_exp___5: /* CIL Label */ 
  {
#line 144
  chain_clock(chain, 1, 0, 1);
  }
#line 145
  goto switch_break;
  case_exp___6: /* CIL Label */ 
#line 148
  if (new_state == (1 | (1 << 6))) {
    {
#line 150
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 153
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 154
  goto switch_break;
  case_exp___7: /* CIL Label */ 
#line 157
  if (new_state == ((1 << 1) | (1 << 6))) {
    {
#line 159
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 162
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 163
  goto switch_break;
  case_exp___8: /* CIL Label */ 
  case_exp___9: /* CIL Label */ 
  {
#line 168
  chain_clock(chain, 1, 0, 1);
  }
#line 169
  goto switch_break;
  case_exp___10: /* CIL Label */ 
#line 172
  if (new_state == (1 | (1 << 2))) {
    {
#line 174
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 177
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 178
  goto switch_break;
  case_exp___11: /* CIL Label */ 
#line 181
  if (new_state == ((1 << 1) | (1 << 2))) {
    {
#line 183
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 186
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 187
  goto switch_break;
  case_exp___12: /* CIL Label */ 
  case_exp___13: /* CIL Label */ 
#line 191
  if (new_state == 1 << 3) {
    {
#line 193
    chain_clock(chain, 0, 0, 1);
    }
  } else {
    {
#line 196
    chain_clock(chain, 1, 0, 1);
    }
  }
#line 197
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 200
  svf_force_reset_state(chain);
  }
#line 201
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 205
  svf_goto_state(chain, new_state);
  }
#line 206
  return;
}
}
#line 221 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static int svf_map_state(int state ) 
{ 
  int jtag_state ;

  {
  {
#line 227
  if (state == 268) {
#line 227
    goto case_268;
  }
#line 230
  if (state == 269) {
#line 230
    goto case_269;
  }
#line 233
  if (state == 311) {
#line 233
    goto case_311;
  }
#line 236
  if (state == 314) {
#line 236
    goto case_314;
  }
#line 239
  if (state == 309) {
#line 239
    goto case_309;
  }
#line 242
  if (state == 312) {
#line 242
    goto case_312;
  }
#line 245
  if (state == 308) {
#line 245
    goto case_308;
  }
#line 248
  if (state == 313) {
#line 248
    goto case_313;
  }
#line 251
  if (state == 310) {
#line 251
    goto case_310;
  }
#line 255
  if (state == 304) {
#line 255
    goto case_304;
  }
#line 258
  if (state == 307) {
#line 258
    goto case_307;
  }
#line 261
  if (state == 302) {
#line 261
    goto case_302;
  }
#line 264
  if (state == 305) {
#line 264
    goto case_305;
  }
#line 267
  if (state == 301) {
#line 267
    goto case_301;
  }
#line 270
  if (state == 306) {
#line 270
    goto case_306;
  }
#line 273
  if (state == 303) {
#line 273
    goto case_303;
  }
#line 277
  goto switch_default;
  case_268: /* CIL Label */ 
#line 228
  jtag_state = (1 << 7) | (1 << 3);
#line 229
  goto switch_break;
  case_269: /* CIL Label */ 
#line 231
  jtag_state = 1 << 3;
#line 232
  goto switch_break;
  case_311: /* CIL Label */ 
#line 234
  jtag_state = 1;
#line 235
  goto switch_break;
  case_314: /* CIL Label */ 
#line 237
  jtag_state = (1 | (1 << 2)) | (1 << 4);
#line 238
  goto switch_break;
  case_309: /* CIL Label */ 
#line 240
  jtag_state = 1 | (1 << 2);
#line 241
  goto switch_break;
  case_312: /* CIL Label */ 
#line 243
  jtag_state = (1 | (1 << 5)) | (1 << 6);
#line 244
  goto switch_break;
  case_308: /* CIL Label */ 
#line 246
  jtag_state = 1 | (1 << 6);
#line 247
  goto switch_break;
  case_313: /* CIL Label */ 
#line 249
  jtag_state = (1 | (1 << 2)) | (1 << 5);
#line 250
  goto switch_break;
  case_310: /* CIL Label */ 
#line 252
  jtag_state = 1 | (1 << 3);
#line 253
  goto switch_break;
  case_304: /* CIL Label */ 
#line 256
  jtag_state = 1 << 1;
#line 257
  goto switch_break;
  case_307: /* CIL Label */ 
#line 259
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 260
  goto switch_break;
  case_302: /* CIL Label */ 
#line 262
  jtag_state = (1 << 1) | (1 << 2);
#line 263
  goto switch_break;
  case_305: /* CIL Label */ 
#line 265
  jtag_state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 266
  goto switch_break;
  case_301: /* CIL Label */ 
#line 268
  jtag_state = (1 << 1) | (1 << 6);
#line 269
  goto switch_break;
  case_306: /* CIL Label */ 
#line 271
  jtag_state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 272
  goto switch_break;
  case_303: /* CIL Label */ 
#line 274
  jtag_state = (1 << 1) | (1 << 3);
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 278
  jtag_state = 1 << 7;
#line 279
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 282
  return (jtag_state);
}
}
#line 297 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static int svf_hex2dec(char nibble ) 
{ 
  int lower ;

  {
#line 302
  if ((int )nibble >= 48) {
#line 302
    if ((int )nibble <= 57) {
#line 303
      return ((int )nibble - 48);
    }
  }
  {
#line 305
  lower = tolower((int )nibble);
  }
#line 306
  if (lower >= 97) {
#line 306
    if (lower <= 102) {
#line 307
      return ((lower - 97) + 10);
    }
  }
#line 309
  return (0);
}
}
#line 338 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static char *svf_build_bit_string(char *hex_string , int len ) 
{ 
  char *bit_string ;
  char *bit_string_pos ;
  int nibble ;
  char *hex_string_pos ;
  int hex_string_idx ;
  char *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 346
  tmp___0 = calloc((size_t )(len + 1), sizeof(char ));
#line 346
  bit_string = (char *)tmp___0;
  }
#line 346
  if (! bit_string) {
    {
#line 347
    tmp = gettext("out of memory");
#line 347
    printf((char const   */* __restrict  */)tmp);
    }
#line 348
    return ((char *)((void *)0));
  }
  {
#line 352
  tmp___1 = strlen((char const   *)hex_string);
#line 352
  hex_string_idx = (int )tmp___1;
#line 353
  hex_string_pos = hex_string + hex_string_idx;
#line 354
  nibble = 3;
#line 355
  bit_string_pos = bit_string + len;
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    bit_string_pos --;
#line 358
    if (nibble == 3) {
#line 359
      nibble = 0;
#line 360
      hex_string_pos --;
#line 361
      hex_string_idx --;
    } else {
#line 363
      nibble ++;
    }
#line 365
    if (hex_string_idx >= 0) {
#line 365
      tmp___4 = (int )*hex_string_pos;
    } else {
#line 365
      tmp___4 = '0';
    }
    {
#line 365
    tmp___5 = svf_hex2dec((char )tmp___4);
    }
#line 365
    if (tmp___5 & (1 << nibble)) {
#line 365
      *bit_string_pos = (char )'1';
    } else {
#line 365
      *bit_string_pos = (char )'0';
    }
#line 356
    if (! ((unsigned long )bit_string_pos != (unsigned long )bit_string)) {
#line 356
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  *(bit_string + len) = (char )'\000';
#line 370
  return (bit_string);
}
}
#line 388 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static int svf_copy_hex_to_register(char *hex_string , tap_register *reg ) 
{ 
  char *bit_string ;

  {
  {
#line 393
  bit_string = svf_build_bit_string(hex_string, reg->len);
  }
#line 393
  if (! bit_string) {
#line 394
    return (0);
  }
  {
#line 396
  register_init(reg, (char const   *)bit_string);
#line 399
  free((void *)bit_string);
  }
#line 401
  return (1);
}
}
#line 423 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static int svf_compare_tdo(parser_priv_t *priv , char *tdo , char *mask , tap_register *reg ,
                           YYLTYPE *loc ) 
{ 
  char *tdo_bit ;
  char *mask_bit ;
  int pos ;
  int mismatch ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 427
  result = 1;
#line 429
  tdo_bit = svf_build_bit_string(tdo, reg->len);
  }
#line 429
  if (! tdo_bit) {
#line 430
    return (0);
  }
  {
#line 431
  mask_bit = svf_build_bit_string(mask, reg->len);
  }
#line 431
  if (! mask_bit) {
    {
#line 432
    free((void *)tdo_bit);
    }
#line 433
    return (0);
  }
  {
#line 437
  register_get_string((tap_register const   *)reg);
#line 439
  mismatch = -1;
#line 440
  pos = 0;
  }
  {
#line 440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 440
    if (! (pos < reg->len)) {
#line 440
      goto while_break;
    }
    {
#line 441
    tmp = svf_hex2dec(*(tdo_bit + pos));
#line 441
    tmp___0 = svf_hex2dec(*(mask_bit + pos));
    }
#line 441
    if ((tmp ^ (int )*(reg->string + pos)) & tmp___0) {
#line 442
      mismatch = pos;
    }
#line 440
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  if (mismatch >= 0) {
    {
#line 445
    tmp___1 = gettext("Error %s: mismatch at position %d for TDO\n");
#line 445
    printf((char const   */* __restrict  */)tmp___1, "svf", mismatch);
    }
#line 446
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 447
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 453
    if (priv->svf_stop_on_mismatch) {
#line 454
      result = 0;
    }
  }
  {
#line 457
  free((void *)mask_bit);
#line 458
  free((void *)tdo_bit);
  }
#line 460
  return (result);
}
}
#line 478 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static void svf_remember_param(char **rem , char *new ) 
{ 


  {
#line 481
  if (new) {
#line 482
    if (*rem) {
      {
#line 483
      free((void *)*rem);
      }
    }
#line 485
    *rem = new;
  }
#line 487
  return;
}
}
#line 505 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static int svf_all_care(char **string , double number ) 
{ 
  char *ptr ;
  int num ;
  int result ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 511
  result = 1;
#line 513
  num = (int )number;
#line 514
  if (num % 4 == 0) {
#line 514
    num /= 4;
  } else {
#line 514
    num = num / 4 + 1;
  }
  {
#line 517
  tmp___0 = calloc((size_t )(num + 1), sizeof(char ));
#line 517
  ptr = (char *)tmp___0;
  }
#line 517
  if (! ptr) {
    {
#line 518
    tmp = gettext("out of memory");
#line 518
    printf((char const   */* __restrict  */)tmp);
    }
#line 519
    return (0);
  }
  {
#line 521
  memset((void *)ptr, 'F', (size_t )num);
#line 522
  *(ptr + num) = (char )'\000';
#line 524
  svf_remember_param(string, ptr);
  }
#line 528
  return (result);
}
}
#line 541 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
void svf_endxr(parser_priv_t *priv , enum generic_irdr_coding ir_dr , int state ) 
{ 


  {
  {
#line 545
  if ((unsigned int )ir_dr == 0U) {
#line 545
    goto case_0;
  }
#line 548
  if ((unsigned int )ir_dr == 1U) {
#line 548
    goto case_1;
  }
#line 544
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 546
  priv->endir = svf_map_state(state);
  }
#line 547
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 549
  priv->enddr = svf_map_state(state);
  }
#line 550
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 552
  return;
}
}
#line 563 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
void svf_frequency(chain_t *chain , double freq ) 
{ 


  {
  {
#line 566
  cable_set_frequency(chain->cable, (uint32_t )freq);
  }
#line 567
  return;
}
}
#line 586 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svf_hxr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 589
  if (params->number != 0.0) {
#line 590
    if ((unsigned int )ir_dr == 0U) {
#line 590
      tmp = "HIR";
    } else {
#line 590
      tmp = "HDR";
    }
    {
#line 590
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 590
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 593
  return (1);
}
}
#line 597 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static int max_time_reached  ;
#line 598 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
static void sigalrm_handler(int signal___0 ) 
{ 


  {
#line 600
  max_time_reached = 1;
#line 601
  return;
}
}
#line 616 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svf_runtest(chain_t *chain , parser_priv_t *priv , struct runtest *params ) 
{ 
  uint32_t run_count ;
  uint32_t frequency ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t min_time_run_count ;
  double tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  struct sigaction sa ;
  unsigned int max_time ;
  int tmp___6 ;
  double tmp___7 ;
  uint32_t tmp___8 ;
  struct sigaction sa___0 ;
  int tmp___9 ;

  {
#line 622
  if (params->run_count > 0U) {
#line 622
    if (params->run_clk != 298) {
      {
#line 623
      tmp = gettext("Error %s: only TCK is supported for RUNTEST.\n");
#line 623
      printf((char const   */* __restrict  */)tmp, "svf");
      }
#line 624
      return (0);
    }
  }
#line 626
  if (params->max_time > 0.0) {
#line 626
    if (params->max_time < params->min_time) {
      {
#line 627
      tmp___0 = gettext("Error %s: maximum time must be larger or equal to minimum time.\n");
#line 627
      printf((char const   */* __restrict  */)tmp___0, "svf");
      }
#line 629
      return (0);
    }
  }
#line 631
  if (params->max_time > 0.0) {
#line 632
    if (! priv->issued_runtest_maxtime) {
      {
#line 633
      tmp___1 = gettext("Warning %s: maximum time for RUNTEST not guaranteed.\n");
#line 633
      printf((char const   */* __restrict  */)tmp___1, "svf");
#line 634
      tmp___2 = gettext(" This message is only displayed once.\n");
#line 634
      printf((char const   */* __restrict  */)tmp___2);
#line 635
      priv->issued_runtest_maxtime = 1;
      }
    }
  }
#line 639
  if (params->run_state != 0) {
    {
#line 640
    priv->runtest_run_state = svf_map_state(params->run_state);
    }
#line 642
    if (params->end_state == 0) {
      {
#line 643
      priv->runtest_end_state = svf_map_state(params->run_state);
      }
    }
  }
#line 645
  if (params->end_state != 0) {
    {
#line 646
    priv->runtest_end_state = svf_map_state(params->end_state);
    }
  }
#line 649
  run_count = params->run_count;
#line 650
  if (params->min_time > 0.0) {
    {
#line 651
    frequency = cable_get_frequency(chain->cable);
    }
#line 652
    if (frequency > 0U) {
      {
#line 653
      tmp___3 = ceil(params->min_time * (double )frequency);
#line 653
      min_time_run_count = (uint32_t )tmp___3;
      }
#line 654
      if (min_time_run_count > run_count) {
#line 655
        run_count = min_time_run_count;
      }
    } else {
      {
#line 658
      tmp___4 = gettext("Error %s: Maximum cable clock frequency required for RUNTEST.\n");
#line 658
      printf((char const   */* __restrict  */)tmp___4, "svf");
#line 659
      tmp___5 = gettext("  Set the cable frequency with \'FREQUENCY <Hz>\'.\n");
#line 659
      printf((char const   */* __restrict  */)tmp___5);
      }
#line 660
      return (0);
    }
  }
  {
#line 664
  svf_goto_state(chain, priv->runtest_run_state);
  }
#line 681
  if (params->max_time > 0.0) {
    {
#line 685
    sa.__sigaction_handler.sa_handler = & sigalrm_handler;
#line 686
    sa.sa_flags = (-0x7FFFFFFF-1);
#line 687
    sigemptyset(& sa.sa_mask);
#line 688
    tmp___6 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
    }
#line 688
    if (tmp___6 != 0) {
      {
#line 689
      perror("sigaction");
#line 690
      exit(1);
      }
    }
    {
#line 693
    tmp___7 = floor(params->max_time / (double )1000000);
#line 693
    max_time = (unsigned int )tmp___7;
    }
#line 694
    if (max_time == 0U) {
#line 695
      max_time = 1U;
    }
    {
#line 697
    ualarm(max_time, (__useconds_t )0);
    }
  }
#line 700
  if (params->max_time > 0.0) {
    {
#line 701
    while (1) {
      while_continue: /* CIL Label */ ;
#line 701
      tmp___8 = run_count;
#line 701
      run_count --;
#line 701
      if (tmp___8 > 0U) {
#line 701
        if (! (! max_time_reached)) {
#line 701
          goto while_break;
        }
      } else {
#line 701
        goto while_break;
      }
      {
#line 702
      chain_clock(chain, 0, 0, 1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 705
    chain_clock(chain, 0, 0, (int )run_count);
    }
  }
  {
#line 707
  svf_goto_state(chain, priv->runtest_end_state);
  }
#line 710
  if (params->max_time > 0.0) {
    {
#line 712
    sa___0.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 713
    sa___0.sa_flags = 0;
#line 714
    sigemptyset(& sa___0.sa_mask);
#line 715
    tmp___9 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa___0),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 715
    if (tmp___9 != 0) {
      {
#line 716
      perror("sigaction");
#line 717
      exit(1);
      }
    }
  }
#line 722
  return (1);
}
}
#line 741 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svf_state(chain_t *chain , parser_priv_t *priv , struct path_states *path_states ,
              int stable_state ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 747
  priv->svf_state_executed = 1;
#line 749
  i = 0;
  {
#line 749
  while (1) {
    while_continue: /* CIL Label */ ;
#line 749
    if (! (i < path_states->num_states)) {
#line 749
      goto while_break;
    }
    {
#line 750
    tmp = svf_map_state(path_states->states[i]);
#line 750
    svf_goto_state(chain, tmp);
#line 749
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 752
  if (stable_state) {
    {
#line 753
    tmp___0 = svf_map_state(stable_state);
#line 753
    svf_goto_state(chain, tmp___0);
    }
  }
#line 755
  return (1);
}
}
#line 772 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svf_sxr(chain_t *chain , parser_priv_t *priv , enum generic_irdr_coding ir_dr ,
            struct ths_params *params , struct YYLTYPE *loc ) 
{ 
  sxr_t *sxr_params ;
  int len ;
  int result ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  tap_register *tmp___7 ;
  tap_register *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 777
  result = 1;
#line 779
  if ((unsigned int )ir_dr == 0U) {
#line 779
    sxr_params = & priv->sir_params;
  } else {
#line 779
    sxr_params = & priv->sdr_params;
  }
  {
#line 782
  svf_remember_param(& sxr_params->params.tdi, params->tdi);
#line 784
  sxr_params->params.tdo = params->tdo;
#line 786
  svf_remember_param(& sxr_params->params.mask, params->mask);
#line 788
  svf_remember_param(& sxr_params->params.smask, params->smask);
  }
#line 792
  if (sxr_params->params.number != params->number) {
#line 793
    sxr_params->no_tdi = 1;
#line 794
    sxr_params->no_tdo = 1;
#line 796
    if (! params->mask) {
      {
#line 797
      tmp = svf_all_care(& sxr_params->params.mask, params->number);
      }
#line 797
      if (! tmp) {
#line 798
        result = 0;
      }
    }
#line 799
    if (! params->smask) {
      {
#line 800
      tmp___0 = svf_all_care(& sxr_params->params.smask, params->number);
      }
#line 800
      if (! tmp___0) {
#line 801
        result = 0;
      }
    }
  }
#line 804
  sxr_params->params.number = params->number;
#line 807
  if (sxr_params->no_tdi) {
#line 808
    if (! params->tdi) {
#line 809
      if ((unsigned int )ir_dr == 0U) {
#line 809
        tmp___1 = "SIR";
      } else {
#line 809
        tmp___1 = "SDR";
      }
      {
#line 809
      tmp___2 = gettext("Error %s: first %s command after length change must have a TDI value.\n");
#line 809
      printf((char const   */* __restrict  */)tmp___2, "svf", tmp___1);
#line 811
      result = 0;
      }
    }
#line 813
    sxr_params->no_tdi = 0;
  }
#line 817
  if (! result) {
#line 818
    return (0);
  }
#line 821
  params->tdi = (char *)((void *)0);
#line 822
  params->mask = (char *)((void *)0);
#line 823
  params->smask = (char *)((void *)0);
#line 829
  len = (int )sxr_params->params.number;
  {
#line 831
  if ((unsigned int )ir_dr == 0U) {
#line 831
    goto case_0;
  }
#line 847
  if ((unsigned int )ir_dr == 1U) {
#line 847
    goto case_1;
  }
#line 830
  goto switch_break;
  case_0: /* CIL Label */ 
#line 833
  if (((priv->ir)->value)->len != len) {
    {
#line 834
    tmp___3 = gettext("Error %s: SIR command length inconsistent.\n");
#line 834
    printf((char const   */* __restrict  */)tmp___3, "svf");
    }
#line 836
    if ((unsigned long )loc != (unsigned long )((void *)0)) {
      {
#line 837
      printf((char const   */* __restrict  */)" in input file between line %d col %d and line %d col %d\n",
             loc->first_line + 1, loc->first_column + 1, loc->last_line + 1, loc->last_column + 1);
      }
    }
#line 843
    return (0);
  }
#line 845
  goto switch_break;
  case_1: /* CIL Label */ 
#line 849
  if (((priv->dr)->in)->len != len) {
    {
#line 851
    register_free((priv->dr)->in);
#line 852
    (priv->dr)->in = (tap_register *)((void *)0);
#line 853
    register_free((priv->dr)->out);
#line 854
    (priv->dr)->out = (tap_register *)((void *)0);
#line 856
    tmp___5 = register_alloc(len);
#line 856
    (priv->dr)->in = tmp___5;
    }
#line 856
    if (! tmp___5) {
      {
#line 857
      tmp___4 = gettext("out of memory");
#line 857
      printf((char const   */* __restrict  */)tmp___4);
      }
#line 858
      return (0);
    }
    {
#line 860
    tmp___7 = register_alloc(len);
#line 860
    (priv->dr)->out = tmp___7;
    }
#line 860
    if (! tmp___7) {
      {
#line 861
      tmp___6 = gettext("out of memory");
#line 861
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 862
      return (0);
    }
  }
#line 865
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 870
  if ((unsigned int )ir_dr == 0U) {
#line 870
    tmp___8 = (priv->ir)->value;
  } else {
#line 870
    tmp___8 = (priv->dr)->in;
  }
  {
#line 870
  tmp___9 = svf_copy_hex_to_register(sxr_params->params.tdi, tmp___8);
  }
#line 870
  if (! tmp___9) {
#line 873
    return (0);
  }
  {
#line 878
  if ((unsigned int )ir_dr == 0U) {
#line 878
    goto case_0___0;
  }
#line 890
  if ((unsigned int )ir_dr == 1U) {
#line 890
    goto case_1___0;
  }
#line 877
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
  {
#line 879
  svf_goto_state(chain, (1 << 1) | (1 << 2));
  }
#line 880
  if (sxr_params->params.tdo) {
#line 880
    tmp___10 = 1;
  } else {
#line 880
    tmp___10 = 0;
  }
  {
#line 880
  chain_shift_instructions_mode(chain, tmp___10, 0, 2);
#line 884
  svf_goto_state(chain, priv->endir);
  }
#line 886
  if (sxr_params->params.tdo) {
    {
#line 887
    result = svf_compare_tdo(priv, sxr_params->params.tdo, sxr_params->params.mask,
                             (priv->ir)->out, loc);
    }
  }
#line 888
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
  {
#line 891
  svf_goto_state(chain, 1 | (1 << 2));
  }
#line 892
  if (sxr_params->params.tdo) {
#line 892
    tmp___11 = 1;
  } else {
#line 892
    tmp___11 = 0;
  }
  {
#line 892
  chain_shift_data_registers_mode(chain, tmp___11, 0, 2);
#line 896
  svf_goto_state(chain, priv->enddr);
  }
#line 898
  if (sxr_params->params.tdo) {
    {
#line 899
    result = svf_compare_tdo(priv, sxr_params->params.tdo, sxr_params->params.mask,
                             (priv->dr)->out, loc);
    }
  }
#line 900
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 903
  return (result);
}
}
#line 924 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svf_trst(chain_t *chain , parser_priv_t *priv , int trst_mode ) 
{ 
  int trst_cable ;
  char *unimplemented_mode ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 927
  trst_cable = -1;
#line 930
  if (priv->svf_trst_absent) {
    {
#line 931
    tmp = gettext("Error %s: no further TRST command allowed after mode ABSENT\n");
#line 931
    printf((char const   */* __restrict  */)tmp, "svf");
    }
#line 933
    return (0);
  }
  {
#line 937
  if (trst_mode == 275) {
#line 937
    goto case_275;
  }
#line 940
  if (trst_mode == 276) {
#line 940
    goto case_276;
  }
#line 943
  if (trst_mode == 277) {
#line 943
    goto case_277;
  }
#line 946
  if (trst_mode == 278) {
#line 946
    goto case_278;
  }
#line 961
  goto switch_default;
  case_275: /* CIL Label */ 
#line 938
  trst_cable = 0;
#line 939
  goto switch_break;
  case_276: /* CIL Label */ 
#line 941
  trst_cable = 1;
#line 942
  goto switch_break;
  case_277: /* CIL Label */ 
#line 944
  unimplemented_mode = (char *)"Z";
#line 945
  goto switch_break;
  case_278: /* CIL Label */ 
#line 947
  unimplemented_mode = (char *)"ABSENT";
#line 948
  priv->svf_trst_absent = 1;
#line 950
  if (priv->svf_state_executed) {
    {
#line 951
    tmp___0 = gettext("Error %s: TRST ABSENT must not be issued after a STATE command\n");
#line 951
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 953
    return (0);
  }
#line 955
  if (priv->sir_params.params.number > 0.0) {
    {
#line 957
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 957
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  } else
#line 955
  if (priv->sdr_params.params.number > 0.0) {
    {
#line 957
    tmp___1 = gettext("Error %s: TRST ABSENT must not be issued after an SIR or SDR command\n");
#line 957
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
  }
#line 960
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 962
  unimplemented_mode = (char *)"UNKNOWN";
#line 963
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 966
  if (trst_cable < 0) {
    {
#line 967
    tmp___2 = gettext("Warning %s: unimplemented mode \'%s\' for TRST\n");
#line 967
    printf((char const   */* __restrict  */)tmp___2, "svf", unimplemented_mode);
    }
  } else {
    {
#line 970
    cable_set_trst(chain->cable, trst_cable);
    }
  }
#line 972
  return (1);
}
}
#line 992 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
int svf_txr(enum generic_irdr_coding ir_dr , struct ths_params *params ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
#line 995
  if (params->number != 0.0) {
#line 996
    if ((unsigned int )ir_dr == 0U) {
#line 996
      tmp = "TIR";
    } else {
#line 996
      tmp = "TDR";
    }
    {
#line 996
    tmp___0 = gettext("Warning %s: command %s not implemented\n");
#line 996
    printf((char const   */* __restrict  */)tmp___0, "svf", tmp);
    }
  }
#line 999
  return (1);
}
}
#line 1023 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.c"
void svf_run(chain_t *chain , FILE *SVF_FILE , int stop_on_mismatch , int print_progress ) 
{ 
  sxr_t sxr_default ;
  parser_priv_t priv ;
  int c ;
  int num_lines ;
  uint32_t old_frequency ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *register_cmd[4] ;
  int tmp___2 ;
  char *tmp___3 ;
  char *instruction_cmd[5] ;
  char *instruction_string ;
  int len ;
  int result ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  uint32_t tmp___7 ;

  {
  {
#line 1026
  sxr_default.params.number = 0.0;
#line 1026
  sxr_default.params.tdi = (char *)((void *)0);
#line 1026
  sxr_default.params.tdo = (char *)((void *)0);
#line 1026
  sxr_default.params.mask = (char *)((void *)0);
#line 1026
  sxr_default.params.smask = (char *)((void *)0);
#line 1026
  sxr_default.no_tdi = 1;
#line 1026
  sxr_default.no_tdo = 1;
#line 1029
  c = ~ -1;
#line 1031
  tmp = cable_get_frequency(chain->cable);
#line 1031
  old_frequency = tmp;
#line 1035
  rewind(SVF_FILE);
#line 1036
  num_lines = 0;
  }
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if (! (-1 != c)) {
#line 1037
      goto while_break;
    }
    {
#line 1038
    c = fgetc(SVF_FILE);
    }
#line 1039
    if (10 == c) {
#line 1040
      num_lines ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1042
  rewind(SVF_FILE);
  }
#line 1043
  if (0 == num_lines) {
#line 1045
    num_lines ++;
  }
#line 1051
  if ((unsigned long )chain == (unsigned long )((void *)0)) {
    {
#line 1052
    tmp___0 = gettext("Error %s: no JTAG chain available\n");
#line 1052
    printf((char const   */* __restrict  */)tmp___0, "svf");
    }
#line 1053
    return;
  }
#line 1055
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
    {
#line 1056
    tmp___1 = gettext("Error %s: chain without any parts\n");
#line 1056
    printf((char const   */* __restrict  */)tmp___1, "svf");
    }
#line 1057
    return;
  }
  {
#line 1059
  priv.part = *((chain->parts)->parts + chain->active_part);
#line 1062
  priv.dr = part_find_data_register(priv.part, "SDR");
  }
#line 1062
  if (! priv.dr) {
    {
#line 1063
    register_cmd[0] = (char *)"register";
#line 1063
    register_cmd[1] = (char *)"SDR";
#line 1063
    register_cmd[2] = (char *)"32";
#line 1063
    register_cmd[3] = (char *)((void *)0);
#line 1068
    tmp___2 = cmd_run(chain, register_cmd);
    }
#line 1068
    if (tmp___2 < 1) {
#line 1069
      return;
    }
    {
#line 1071
    priv.dr = part_find_data_register(priv.part, "SDR");
    }
#line 1071
    if (! priv.dr) {
      {
#line 1072
      tmp___3 = gettext("Error %s: could not establish SDR register\n");
#line 1072
      printf((char const   */* __restrict  */)tmp___3, "svf");
      }
#line 1073
      return;
    }
  }
  {
#line 1078
  priv.ir = part_find_instruction(priv.part, "SIR");
  }
#line 1078
  if (! priv.ir) {
#line 1079
    instruction_cmd[0] = (char *)"instruction";
#line 1079
    instruction_cmd[1] = (char *)"SIR";
#line 1079
    instruction_cmd[2] = (char *)"";
#line 1079
    instruction_cmd[3] = (char *)"SDR";
#line 1079
    instruction_cmd[4] = (char *)((void *)0);
#line 1087
    len = (priv.part)->instruction_length;
#line 1088
    if (len > 0) {
      {
#line 1089
      tmp___4 = calloc((size_t )(len + 1), sizeof(char ));
#line 1089
      instruction_string = (char *)tmp___4;
      }
#line 1089
      if ((unsigned long )instruction_string != (unsigned long )((void *)0)) {
        {
#line 1090
        memset((void *)instruction_string, '1', (size_t )len);
#line 1091
        *(instruction_string + len) = (char )'\000';
#line 1092
        instruction_cmd[2] = instruction_string;
#line 1094
        result = cmd_run(chain, instruction_cmd);
#line 1096
        free((void *)instruction_string);
        }
#line 1098
        if (result < 1) {
#line 1099
          return;
        }
      }
    }
    {
#line 1103
    priv.ir = part_find_instruction(priv.part, "SIR");
    }
#line 1103
    if (! priv.ir) {
      {
#line 1104
      tmp___5 = gettext("Error %s: could not establish SIR instruction\n");
#line 1104
      printf((char const   */* __restrict  */)tmp___5, "svf");
      }
#line 1105
      return;
    }
  }
  {
#line 1110
  priv.svf_stop_on_mismatch = stop_on_mismatch;
#line 1112
  priv.sdr_params = sxr_default;
#line 1112
  priv.sir_params = priv.sdr_params;
#line 1114
  priv.enddr = 1 << 3;
#line 1114
  priv.endir = priv.enddr;
#line 1116
  priv.runtest_end_state = 1 << 3;
#line 1116
  priv.runtest_run_state = priv.runtest_end_state;
#line 1118
  priv.svf_trst_absent = 0;
#line 1119
  priv.svf_state_executed = 0;
#line 1122
  priv.issued_runtest_maxtime = 0;
#line 1126
  part_set_instruction(priv.part, "SIR");
#line 1128
  tmp___6 = svf_bison_init(& priv, SVF_FILE, num_lines, print_progress);
  }
#line 1128
  if (tmp___6) {
    {
#line 1129
    svfparse(& priv, chain);
#line 1130
    svf_bison_deinit(& priv);
    }
  }
#line 1135
  if (priv.sir_params.params.tdi) {
    {
#line 1136
    free((void *)priv.sir_params.params.tdi);
    }
  }
#line 1137
  if (priv.sir_params.params.mask) {
    {
#line 1138
    free((void *)priv.sir_params.params.mask);
    }
  }
#line 1139
  if (priv.sir_params.params.smask) {
    {
#line 1140
    free((void *)priv.sir_params.params.smask);
    }
  }
#line 1142
  if (priv.sdr_params.params.tdi) {
    {
#line 1143
    free((void *)priv.sdr_params.params.tdi);
    }
  }
#line 1144
  if (priv.sdr_params.params.mask) {
    {
#line 1145
    free((void *)priv.sdr_params.params.mask);
    }
  }
#line 1146
  if (priv.sdr_params.params.smask) {
    {
#line 1147
    free((void *)priv.sdr_params.params.smask);
    }
  }
  {
#line 1150
  tmp___7 = cable_get_frequency(chain->cable);
  }
#line 1150
  if (old_frequency != tmp___7) {
    {
#line 1151
    cable_set_frequency(chain->cable, old_frequency);
    }
  }
#line 1152
  return;
}
}
#line 117 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 287 "svf_flex.c"
void svfrestart(FILE *input_file , yyscan_t yyscanner ) ;
#line 288
void svf_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 289
YY_BUFFER_STATE svf_create_buffer(FILE *file , int size , yyscan_t yyscanner ) ;
#line 290
void svf_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 291
void svf_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) ;
#line 292
void svfpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) ;
#line 293
void svfpop_buffer_state(yyscan_t yyscanner ) ;
#line 295
static void svfensure_buffer_stack(yyscan_t yyscanner ) ;
#line 296
static void svf_load_buffer_state(yyscan_t yyscanner ) ;
#line 297
static void svf_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) ;
#line 301
YY_BUFFER_STATE svf_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) ;
#line 302
YY_BUFFER_STATE svf_scan_string(char const   *yystr , yyscan_t yyscanner ) ;
#line 303
YY_BUFFER_STATE svf_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) ;
#line 305
void *svfalloc(yy_size_t size , yyscan_t yyscanner ) ;
#line 306
void *svfrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) ;
#line 307
void svffree(void *ptr , yyscan_t yyscanner ) ;
#line 341
static yy_state_type yy_get_previous_state___1(yyscan_t yyscanner ) ;
#line 342
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state , yyscan_t yyscanner ) ;
#line 343
static int yy_get_next_buffer___1(yyscan_t yyscanner ) ;
#line 344
static void yy_fatal_error___1(char const   *msg , yyscan_t yyscanner ) ;
#line 365 "svf_flex.c"
static flex_int16_t const   yy_accept___1[43]  = 
#line 365
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )12,      (flex_int16_t const   )10,      (flex_int16_t const   )5, 
        (flex_int16_t const   )8,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )7, 
        (flex_int16_t const   )10,      (flex_int16_t const   )2,      (flex_int16_t const   )9,      (flex_int16_t const   )1, 
        (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )6,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )2, 
        (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )4, 
        (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )2,      (flex_int16_t const   )0, 
        (flex_int16_t const   )2,      (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )3,      (flex_int16_t const   )0};
#line 374 "svf_flex.c"
static flex_int32_t const   yy_ec___1[256]  = 
#line 374
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )2,      (flex_int32_t const   )4,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )1,      (flex_int32_t const   )7, 
        (flex_int32_t const   )1,      (flex_int32_t const   )7,      (flex_int32_t const   )8,      (flex_int32_t const   )9, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )10, 
        (flex_int32_t const   )10,      (flex_int32_t const   )10,      (flex_int32_t const   )1,      (flex_int32_t const   )11, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )17, 
        (flex_int32_t const   )1,      (flex_int32_t const   )12,      (flex_int32_t const   )12,      (flex_int32_t const   )12, 
        (flex_int32_t const   )13,      (flex_int32_t const   )14,      (flex_int32_t const   )12,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )15, 
        (flex_int32_t const   )16,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 406 "svf_flex.c"
static flex_int32_t const   yy_meta___1[18]  = 
#line 406
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )3, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )5,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )5,      (flex_int32_t const   )7, 
        (flex_int32_t const   )8,      (flex_int32_t const   )7};
#line 412 "svf_flex.c"
static flex_int16_t const   yy_base___1[49]  = 
#line 412
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )83, 
        (flex_int16_t const   )82,      (flex_int16_t const   )86,      (flex_int16_t const   )89,      (flex_int16_t const   )83, 
        (flex_int16_t const   )89,      (flex_int16_t const   )0,      (flex_int16_t const   )81,      (flex_int16_t const   )89, 
        (flex_int16_t const   )72,      (flex_int16_t const   )10,      (flex_int16_t const   )89,      (flex_int16_t const   )9, 
        (flex_int16_t const   )25,      (flex_int16_t const   )66,      (flex_int16_t const   )0,      (flex_int16_t const   )19, 
        (flex_int16_t const   )57,      (flex_int16_t const   )0,      (flex_int16_t const   )41,      (flex_int16_t const   )0, 
        (flex_int16_t const   )22,      (flex_int16_t const   )0,      (flex_int16_t const   )13,      (flex_int16_t const   )34, 
        (flex_int16_t const   )43,      (flex_int16_t const   )40,      (flex_int16_t const   )0,      (flex_int16_t const   )89, 
        (flex_int16_t const   )32,      (flex_int16_t const   )0,      (flex_int16_t const   )33,      (flex_int16_t const   )23, 
        (flex_int16_t const   )21,      (flex_int16_t const   )0,      (flex_int16_t const   )89,      (flex_int16_t const   )20, 
        (flex_int16_t const   )42,      (flex_int16_t const   )89,      (flex_int16_t const   )89,      (flex_int16_t const   )48, 
        (flex_int16_t const   )55,      (flex_int16_t const   )57,      (flex_int16_t const   )65,      (flex_int16_t const   )69, 
        (flex_int16_t const   )76};
#line 421 "svf_flex.c"
static flex_int16_t const   yy_def___1[49]  = 
#line 421
  {      (flex_int16_t const   )0,      (flex_int16_t const   )42,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )45, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )44, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )13, 
        (flex_int16_t const   )42,      (flex_int16_t const   )47,      (flex_int16_t const   )45,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )48,      (flex_int16_t const   )19,      (flex_int16_t const   )42, 
        (flex_int16_t const   )19,      (flex_int16_t const   )46,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )27,      (flex_int16_t const   )42,      (flex_int16_t const   )27, 
        (flex_int16_t const   )48,      (flex_int16_t const   )42,      (flex_int16_t const   )0,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42};
#line 430 "svf_flex.c"
static flex_int16_t const   yy_nxt___1[107]  = 
#line 430
  {      (flex_int16_t const   )0,      (flex_int16_t const   )6,      (flex_int16_t const   )7,      (flex_int16_t const   )8, 
        (flex_int16_t const   )9,      (flex_int16_t const   )10,      (flex_int16_t const   )11,      (flex_int16_t const   )6, 
        (flex_int16_t const   )6,      (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14, 
        (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )15,      (flex_int16_t const   )6,      (flex_int16_t const   )22,      (flex_int16_t const   )25, 
        (flex_int16_t const   )23,      (flex_int16_t const   )30,      (flex_int16_t const   )39,      (flex_int16_t const   )25, 
        (flex_int16_t const   )24,      (flex_int16_t const   )31,      (flex_int16_t const   )25,      (flex_int16_t const   )27, 
        (flex_int16_t const   )28,      (flex_int16_t const   )35,      (flex_int16_t const   )25,      (flex_int16_t const   )36, 
        (flex_int16_t const   )36,      (flex_int16_t const   )36,      (flex_int16_t const   )32,      (flex_int16_t const   )20, 
        (flex_int16_t const   )37,      (flex_int16_t const   )20,      (flex_int16_t const   )28,      (flex_int16_t const   )20, 
        (flex_int16_t const   )38,      (flex_int16_t const   )29,      (flex_int16_t const   )40,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )39,      (flex_int16_t const   )41,      (flex_int16_t const   )24, 
        (flex_int16_t const   )41,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )34, 
        (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18,      (flex_int16_t const   )18, 
        (flex_int16_t const   )18,      (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )32, 
        (flex_int16_t const   )20,      (flex_int16_t const   )20,      (flex_int16_t const   )26,      (flex_int16_t const   )26, 
        (flex_int16_t const   )26,      (flex_int16_t const   )26,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )17,      (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )33, 
        (flex_int16_t const   )33,      (flex_int16_t const   )33,      (flex_int16_t const   )25,      (flex_int16_t const   )25, 
        (flex_int16_t const   )25,      (flex_int16_t const   )25,      (flex_int16_t const   )29,      (flex_int16_t const   )29, 
        (flex_int16_t const   )29,      (flex_int16_t const   )21,      (flex_int16_t const   )29,      (flex_int16_t const   )19, 
        (flex_int16_t const   )29,      (flex_int16_t const   )17,      (flex_int16_t const   )42,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )5,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 446 "svf_flex.c"
static flex_int16_t const   yy_chk___1[107]  = 
#line 446
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )13,      (flex_int16_t const   )15, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )39,      (flex_int16_t const   )26, 
        (flex_int16_t const   )13,      (flex_int16_t const   )19,      (flex_int16_t const   )15,      (flex_int16_t const   )16, 
        (flex_int16_t const   )16,      (flex_int16_t const   )24,      (flex_int16_t const   )26,      (flex_int16_t const   )36, 
        (flex_int16_t const   )24,      (flex_int16_t const   )35,      (flex_int16_t const   )32,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )16,      (flex_int16_t const   )16, 
        (flex_int16_t const   )27,      (flex_int16_t const   )16,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )34, 
        (flex_int16_t const   )40,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )22, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )20, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )17,      (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )46,      (flex_int16_t const   )46,      (flex_int16_t const   )47,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )47,      (flex_int16_t const   )48,      (flex_int16_t const   )48, 
        (flex_int16_t const   )48,      (flex_int16_t const   )12,      (flex_int16_t const   )48,      (flex_int16_t const   )10, 
        (flex_int16_t const   )48,      (flex_int16_t const   )7,      (flex_int16_t const   )5,      (flex_int16_t const   )4, 
        (flex_int16_t const   )3,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42};
#line 113 "/home/khheo/project/benchmark/urjtag-0.9/src/svf/svf.h"
void *svf_flex_init(FILE *f , int num_lines , int print_progress ) ;
#line 114
void svf_flex_deinit(void *scanner ) ;
#line 43 "svf_flex.l"
static int map_keyw_ident(YYSTYPE___0 *mylval , char *str ) ;
#line 44
static void align_string(char *str ) ;
#line 46
static void fix_yylloc(YYLTYPE *mylloc , char *str ) ;
#line 47
static void fix_yylloc_nl(YYLTYPE *mylloc , char *str , scanner_extra_t *extra ) ;
#line 49 "svf_flex.l"
int svfwrap(yyscan_t scanner ) 
{ 


  {
#line 51
  return (1);
}
}
#line 575 "svf_flex.c"
static int yy_init_globals___1(yyscan_t yyscanner ) ;
#line 583
int svflex_init(yyscan_t *ptr_yy_globals ) ;
#line 585
int svflex_init_extra(scanner_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) ;
#line 590
int svflex_destroy(yyscan_t yyscanner ) ;
#line 592
int svfget_debug(yyscan_t yyscanner ) ;
#line 594
void svfset_debug(int bdebug , yyscan_t yyscanner ) ;
#line 596
scanner_extra_t *svfget_extra(yyscan_t yyscanner ) ;
#line 598
void svfset_extra(scanner_extra_t *user_defined , yyscan_t yyscanner ) ;
#line 600
FILE *svfget_in(yyscan_t yyscanner ) ;
#line 602
void svfset_in(FILE *in_str , yyscan_t yyscanner ) ;
#line 604
FILE *svfget_out(yyscan_t yyscanner ) ;
#line 606
void svfset_out(FILE *out_str , yyscan_t yyscanner ) ;
#line 608
int svfget_leng(yyscan_t yyscanner ) ;
#line 610
char *svfget_text(yyscan_t yyscanner ) ;
#line 612
int svfget_lineno(yyscan_t yyscanner ) ;
#line 614
void svfset_lineno(int line_number , yyscan_t yyscanner ) ;
#line 616
YYSTYPE___0 *svfget_lval(yyscan_t yyscanner ) ;
#line 618
void svfset_lval(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) ;
#line 620
YYLTYPE *svfget_lloc(yyscan_t yyscanner ) ;
#line 622
void svfset_lloc(YYLTYPE *yylloc_param , yyscan_t yyscanner ) ;
#line 731
int svflex(YYSTYPE___0 *yylval_param , YYLTYPE *yylloc_param , yyscan_t yyscanner ) ;
#line 755 "svf_flex.c"
int svflex(YYSTYPE___0 *yylval_param , YYLTYPE *yylloc_param , yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  struct yyguts_t___0 *yyg ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  YY_BUFFER_STATE tmp___2 ;
  register YY_CHAR yy_c ;
  int keyw ;
  char *cstring ;
  scanner_extra_t *tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *cstring___0 ;
  scanner_extra_t *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 760
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 768
  yyg->yylval_r = yylval_param;
#line 770
  yyg->yylloc_r = yylloc_param;
#line 772
  if (! yyg->yy_init) {
#line 774
    yyg->yy_init = 1;
#line 777
    tmp___1 = 0;
#line 777
    (yyg->yylloc_r)->last_column = tmp___1;
#line 777
    tmp___0 = tmp___1;
#line 777
    (yyg->yylloc_r)->first_column = tmp___0;
#line 777
    tmp = tmp___0;
#line 777
    (yyg->yylloc_r)->last_line = tmp;
#line 777
    (yyg->yylloc_r)->first_line = tmp;
#line 780
    if (! yyg->yy_start) {
#line 781
      yyg->yy_start = 1;
    }
#line 783
    if (! yyg->yyin_r) {
#line 784
      yyg->yyin_r = stdin;
    }
#line 786
    if (! yyg->yyout_r) {
#line 787
      yyg->yyout_r = stdout;
    }
#line 789
    if (yyg->yy_buffer_stack) {
#line 789
      tmp___2 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 789
      tmp___2 = (YY_BUFFER_STATE )((void *)0);
    }
#line 789
    if (! tmp___2) {
      {
#line 790
      svfensure_buffer_stack(yyscanner);
#line 791
      *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = svf_create_buffer(yyg->yyin_r,
                                                                             16384,
                                                                             yyscanner);
      }
    }
    {
#line 795
    svf_load_buffer_state(yyscanner);
    }
  }
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    yy_cp = yyg->yy_c_buf_p;
#line 803
    *yy_cp = yyg->yy_hold_char;
#line 808
    yy_bp = yy_cp;
#line 810
    yy_current_state = yyg->yy_start;
    yy_match: 
    {
#line 812
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 814
      yy_c = (YY_CHAR )yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
#line 815
      if (yy_accept___1[yy_current_state]) {
#line 817
        yyg->yy_last_accepting_state = yy_current_state;
#line 818
        yyg->yy_last_accepting_cpos = yy_cp;
      }
      {
#line 820
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 820
        if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 820
          goto while_break___1;
        }
#line 822
        yy_current_state = (int )yy_def___1[yy_current_state];
#line 823
        if (yy_current_state >= 43) {
#line 824
          yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 826
      yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 827
      yy_cp ++;
#line 812
      if (! ((int const   )yy_base___1[yy_current_state] != 89)) {
#line 812
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    yy_find_action: 
#line 832
    yy_act = (int )yy_accept___1[yy_current_state];
#line 833
    if (yy_act == 0) {
#line 835
      yy_cp = yyg->yy_last_accepting_cpos;
#line 836
      yy_current_state = yyg->yy_last_accepting_state;
#line 837
      yy_act = (int )yy_accept___1[yy_current_state];
    }
#line 840
    yyg->yytext_r = yy_bp;
#line 840
    yyg->yyleng_r = (int )((size_t )(yy_cp - yy_bp));
#line 840
    yyg->yy_hold_char = *yy_cp;
#line 840
    *yy_cp = (char )'\000';
#line 840
    yyg->yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 846
    if (yy_act == 0) {
#line 846
      goto case_0;
    }
#line 853
    if (yy_act == 1) {
#line 853
      goto case_1;
    }
#line 88
    if (yy_act == 2) {
#line 88 "svf_flex.l"
      goto case_2;
    }
#line 98
    if (yy_act == 3) {
#line 98
      goto case_3;
    }
#line 117
    if (yy_act == 4) {
#line 117
      goto case_4;
    }
#line 131
    if (yy_act == 5) {
#line 131
      goto case_5;
    }
#line 137
    if (yy_act == 6) {
#line 137
      goto case_6;
    }
#line 143
    if (yy_act == 7) {
#line 143
      goto case_7;
    }
#line 150
    if (yy_act == 8) {
#line 150
      goto case_8;
    }
#line 159
    if (yy_act == 9) {
#line 159
      goto case_9;
    }
#line 171
    if (yy_act == 14) {
#line 171
      goto case_14;
    }
#line 171
    if (yy_act == 13) {
#line 171
      goto case_14;
    }
#line 176
    if (yy_act == 10) {
#line 176
      goto case_10;
    }
#line 184
    if (yy_act == 11) {
#line 184
      goto case_11;
    }
#line 997
    if (yy_act == 12) {
#line 997 "svf_flex.c"
      goto case_12;
    }
#line 1119
    goto switch_default;
    case_0: /* CIL Label */ 
#line 848
    *yy_cp = yyg->yy_hold_char;
#line 849
    yy_cp = yyg->yy_last_accepting_cpos;
#line 850
    yy_current_state = yyg->yy_last_accepting_state;
#line 851
    goto yy_find_action;
    case_1: /* CIL Label */ 
    {
#line 77 "svf_flex.l"
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
#line 78
    keyw = map_keyw_ident(yyg->yylval_r, yyg->yytext_r);
    }
#line 81
    if (keyw == 285) {
#line 82
      yyg->yy_start = 3;
    }
#line 85
    return (keyw);
#line 87
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 92
    (yyg->yylval_r)->dvalue = strtod((char const   */* __restrict  */)yyg->yytext_r,
                                     (char **/* __restrict  */)((char **)((void *)0)));
#line 93
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 95
    return (259);
#line 97
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 108
    tmp___3 = svfget_extra(yyscanner);
#line 108
    fix_yylloc_nl(yyg->yylloc_r, yyg->yytext_r, tmp___3);
#line 109
    align_string(yyg->yytext_r);
#line 111
    tmp___4 = strlen((char const   *)yyg->yytext_r);
#line 111
    tmp___5 = calloc(tmp___4 + 1UL, sizeof(char ));
#line 111
    cstring = (char *)tmp___5;
#line 112
    strcpy((char */* __restrict  */)cstring, (char const   */* __restrict  */)yyg->yytext_r);
#line 113
    (yyg->yylval_r)->cvalue = cstring;
    }
#line 114
    return (261);
#line 116
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 122
    tmp___6 = svfget_extra(yyscanner);
#line 122
    fix_yylloc_nl(yyg->yylloc_r, yyg->yytext_r, tmp___6);
#line 123
    align_string(yyg->yytext_r);
#line 125
    tmp___7 = strlen((char const   *)yyg->yytext_r);
#line 125
    tmp___8 = calloc(tmp___7 + 1UL, sizeof(char ));
#line 125
    cstring___0 = (char *)tmp___8;
#line 126
    strcpy((char */* __restrict  */)cstring___0, (char const   */* __restrict  */)yyg->yytext_r);
#line 127
    (yyg->yylval_r)->cvalue = cstring___0;
    }
#line 128
    return (260);
#line 130
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 134
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 136
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 140
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 142
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 146
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 147
    return ((int )*(yyg->yytext_r + 0));
#line 149
    goto switch_break;
    case_8: /* CIL Label */ 
#line 153
    (yyg->yylloc_r)->first_line = (yyg->yylloc_r)->last_line;
#line 154
    (yyg->yylloc_r)->first_column = (yyg->yylloc_r)->last_column;
#line 155
    ((yyg->yylloc_r)->last_line) ++;
#line 156
    (yyg->yylloc_r)->last_column = 0;
#line 158
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 164
    yyg->yy_start = 1;
#line 166
    fix_yylloc(yyg->yylloc_r, yyg->yytext_r);
    }
#line 167
    return ((int )*(yyg->yytext_r + 0));
#line 169
    goto switch_break;
    case_14: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 173
    return (-1);
#line 175
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 180
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: \"%s\" is not a legal SVF language token\n",
            yyg->yytext_r);
    }
#line 183
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 184
    fwrite((void const   */* __restrict  */)yyg->yytext_r, (size_t )yyg->yyleng_r,
           (size_t )1, (FILE */* __restrict  */)yyg->yyout_r);
    }
#line 185
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1000 "svf_flex.c"
    yy_amount_of_matched_text = (int )(yy_cp - yyg->yytext_r) - 1;
#line 1003
    *yy_cp = yyg->yy_hold_char;
#line 1006
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1017
      yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1018
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file = yyg->yyin_r;
#line 1019
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1029
    if ((unsigned long )yyg->yy_c_buf_p <= (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars)) {
      {
#line 1033
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1035
      yy_current_state = yy_get_previous_state___1(yyscanner);
#line 1046
      yy_next_state = yy_try_NUL_trans___1(yy_current_state, yyscanner);
#line 1048
      yy_bp = yyg->yytext_r + 0;
      }
#line 1050
      if (yy_next_state) {
#line 1053
        (yyg->yy_c_buf_p) ++;
#line 1053
        yy_cp = yyg->yy_c_buf_p;
#line 1054
        yy_current_state = yy_next_state;
#line 1055
        goto yy_match;
      } else {
#line 1060
        yy_cp = yyg->yy_c_buf_p;
#line 1061
        goto yy_find_action;
      }
    } else {
      {
#line 1065
      tmp___9 = yy_get_next_buffer___1(yyscanner);
      }
      {
#line 1067
      if (tmp___9 == 1) {
#line 1067
        goto case_1___0;
      }
#line 1096
      if (tmp___9 == 0) {
#line 1096
        goto case_0___0;
      }
#line 1106
      if (tmp___9 == 2) {
#line 1106
        goto case_2___0;
      }
#line 1065
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1069
      yyg->yy_did_buffer_switch_on_eof = 0;
#line 1071
      tmp___10 = svfwrap(yyscanner);
      }
#line 1071
      if (tmp___10) {
#line 1082
        yyg->yy_c_buf_p = yyg->yytext_r + 0;
#line 1084
        yy_act = (12 + (yyg->yy_start - 1) / 2) + 1;
#line 1085
        goto do_action;
      } else
#line 1090
      if (! yyg->yy_did_buffer_switch_on_eof) {
        {
#line 1091
        svfrestart(yyg->yyin_r, yyscanner);
        }
      }
#line 1093
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1097
      yyg->yy_c_buf_p = yyg->yytext_r + yy_amount_of_matched_text;
#line 1100
      yy_current_state = yy_get_previous_state___1(yyscanner);
#line 1102
      yy_cp = yyg->yy_c_buf_p;
#line 1103
      yy_bp = yyg->yytext_r + 0;
      }
#line 1104
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1107
      yyg->yy_c_buf_p = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars;
#line 1110
      yy_current_state = yy_get_previous_state___1(yyscanner);
#line 1112
      yy_cp = yyg->yy_c_buf_p;
#line 1113
      yy_bp = yyg->yytext_r + 0;
      }
#line 1114
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1116
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1120
    yy_fatal_error___1("fatal flex scanner internal error--no action found", yyscanner);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1133 "svf_flex.c"
static int yy_get_next_buffer___1(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___2 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___3 ;
  int c ;
  int n ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  yy_size_t new_size___0 ;
  void *tmp___12 ;

  {
#line 1135
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1136
  dest = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf;
#line 1137
  source = yyg->yytext_r;
#line 1141
  if ((unsigned long )yyg->yy_c_buf_p > (unsigned long )((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1))) {
    {
#line 1142
    yy_fatal_error___1("fatal flex scanner internal error--end of buffer missed",
                       yyscanner);
    }
  }
#line 1145
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1147
    if (yyg->yy_c_buf_p - yyg->yytext_r == 1L) {
#line 1152
      return (1);
    } else {
#line 1160
      return (2);
    }
  }
#line 1167
  number_to_move = (int )(yyg->yy_c_buf_p - yyg->yytext_r) - 1;
#line 1169
  i = 0;
  {
#line 1169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1169
    if (! (i < number_to_move)) {
#line 1169
      goto while_break;
    }
#line 1170
    tmp = dest;
#line 1170
    dest ++;
#line 1170
    tmp___0 = source;
#line 1170
    source ++;
#line 1170
    *tmp = *tmp___0;
#line 1169
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1172
  if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1176
    tmp___1 = 0;
#line 1176
    yyg->yy_n_chars = tmp___1;
#line 1176
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = tmp___1;
  } else {
#line 1180
    num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1183
      if (! (num_to_read <= 0)) {
#line 1183
        goto while_break___0;
      }
#line 1187
      if (yyg->yy_buffer_stack) {
#line 1187
        tmp___2 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
      } else {
#line 1187
        tmp___2 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1187
      b = tmp___2;
#line 1189
      yy_c_buf_p_offset = (int )(yyg->yy_c_buf_p - b->yy_ch_buf);
#line 1192
      if (b->yy_is_our_buffer) {
#line 1194
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1196
        if (new_size <= 0) {
#line 1197
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1199
          b->yy_buf_size *= 2UL;
        }
        {
#line 1201
        tmp___3 = svfrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL, yyscanner);
#line 1201
        b->yy_ch_buf = (char *)tmp___3;
        }
      } else {
#line 1207
        b->yy_ch_buf = (char *)0;
      }
#line 1209
      if (! b->yy_ch_buf) {
        {
#line 1210
        yy_fatal_error___1("fatal error - scanner input buffer overflow", yyscanner);
        }
      }
#line 1213
      yyg->yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1215
      num_to_read = (int )(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1220
    if (num_to_read > 8192) {
#line 1221
      num_to_read = 8192;
    }
#line 1224
    if ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_is_interactive) {
#line 1224
      c = '*';
#line 1224
      n = 0;
      {
#line 1224
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1224
        if ((size_t )n < (size_t )num_to_read) {
          {
#line 1224
          c = _IO_getc(yyg->yyin_r);
          }
#line 1224
          if (c != -1) {
#line 1224
            if (! (c != 10)) {
#line 1224
              goto while_break___1;
            }
          } else {
#line 1224
            goto while_break___1;
          }
        } else {
#line 1224
          goto while_break___1;
        }
#line 1224
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1224
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1224
      if (c == 10) {
#line 1224
        tmp___4 = n;
#line 1224
        n ++;
#line 1224
        *(((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___4) = (char )c;
      }
#line 1224
      if (c == -1) {
        {
#line 1224
        tmp___5 = ferror(yyg->yyin_r);
        }
#line 1224
        if (tmp___5) {
          {
#line 1224
          yy_fatal_error___1("input in flex scanner failed", yyscanner);
          }
        }
      }
#line 1224
      yyg->yy_n_chars = n;
    } else {
      {
#line 1224
      tmp___6 = __errno_location();
#line 1224
      *tmp___6 = 0;
      }
      {
#line 1224
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1224
        tmp___10 = fread((void */* __restrict  */)((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                         (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyg->yyin_r);
#line 1224
        tmp___9 = (int )tmp___10;
#line 1224
        yyg->yy_n_chars = tmp___9;
        }
#line 1224
        if (tmp___9 == 0) {
          {
#line 1224
          tmp___11 = ferror(yyg->yyin_r);
          }
#line 1224
          if (! tmp___11) {
#line 1224
            goto while_break___2;
          }
        } else {
#line 1224
          goto while_break___2;
        }
        {
#line 1224
        tmp___7 = __errno_location();
        }
#line 1224
        if (*tmp___7 != 4) {
          {
#line 1224
          yy_fatal_error___1("input in flex scanner failed", yyscanner);
          }
#line 1224
          goto while_break___2;
        }
        {
#line 1224
        tmp___8 = __errno_location();
#line 1224
        *tmp___8 = 0;
#line 1224
        clearerr(yyg->yyin_r);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1227
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1230
  if (yyg->yy_n_chars == 0) {
#line 1232
    if (number_to_move == 0) {
      {
#line 1234
      ret_val = 1;
#line 1235
      svfrestart(yyg->yyin_r, yyscanner);
      }
    } else {
#line 1240
      ret_val = 2;
#line 1241
      (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1247
    ret_val = 0;
  }
#line 1249
  if ((yy_size_t )(yyg->yy_n_chars + number_to_move) > (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1251
    new_size___0 = (yy_size_t )((yyg->yy_n_chars + number_to_move) + (yyg->yy_n_chars >> 1));
#line 1252
    tmp___12 = svfrealloc((void *)(*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf,
                          new_size___0, yyscanner);
#line 1252
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___12;
    }
#line 1253
    if (! (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1254
      yy_fatal_error___1("out of dynamic memory in yy_get_next_buffer()", yyscanner);
      }
    }
  }
#line 1257
  yyg->yy_n_chars += number_to_move;
#line 1258
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + yyg->yy_n_chars) = (char)0;
#line 1259
  *((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + (yyg->yy_n_chars + 1)) = (char)0;
#line 1261
  yyg->yytext_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1263
  return (ret_val);
}
}
#line 1268 "svf_flex.c"
static yy_state_type yy_get_previous_state___1(yyscan_t yyscanner ) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  struct yyguts_t___0 *yyg ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1272
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1274
  yy_current_state = yyg->yy_start;
#line 1276
  yy_cp = yyg->yytext_r + 0;
  {
#line 1276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1276
    if (! ((unsigned long )yy_cp < (unsigned long )yyg->yy_c_buf_p)) {
#line 1276
      goto while_break;
    }
#line 1278
    if (*yy_cp) {
#line 1278
      tmp = yy_ec___1[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1278
      tmp = (flex_int32_t const   )1;
    }
#line 1278
    yy_c = (YY_CHAR )tmp;
#line 1279
    if (yy_accept___1[yy_current_state]) {
#line 1281
      yyg->yy_last_accepting_state = yy_current_state;
#line 1282
      yyg->yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1284
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1284
      if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1284
        goto while_break___0;
      }
#line 1286
      yy_current_state = (int )yy_def___1[yy_current_state];
#line 1287
      if (yy_current_state >= 43) {
#line 1288
        yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1290
    yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1276
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1293
  return (yy_current_state);
}
}
#line 1301 "svf_flex.c"
static yy_state_type yy_try_NUL_trans___1(yy_state_type yy_current_state , yyscan_t yyscanner ) 
{ 
  register int yy_is_jam ;
  struct yyguts_t___0 *yyg ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1304
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1305
  yy_cp = yyg->yy_c_buf_p;
#line 1307
  yy_c = (YY_CHAR )1;
#line 1308
  if (yy_accept___1[yy_current_state]) {
#line 1310
    yyg->yy_last_accepting_state = yy_current_state;
#line 1311
    yyg->yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1313
    if (! ((int const   )yy_chk___1[(int const   )yy_base___1[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1313
      goto while_break;
    }
#line 1315
    yy_current_state = (int )yy_def___1[yy_current_state];
#line 1316
    if (yy_current_state >= 43) {
#line 1317
      yy_c = (YY_CHAR )yy_meta___1[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1319
  yy_current_state = (yy_state_type )yy_nxt___1[(unsigned int )yy_base___1[yy_current_state] + (unsigned int )yy_c];
#line 1320
  yy_is_jam = yy_current_state == 42;
#line 1322
  if (yy_is_jam) {
#line 1322
    tmp = 0;
  } else {
#line 1322
    tmp = yy_current_state;
  }
#line 1322
  return (tmp);
}
}
#line 1443 "svf_flex.c"
void svfrestart(FILE *input_file , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1445
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1447
  if (yyg->yy_buffer_stack) {
#line 1447
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1447
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1447
  if (! tmp) {
    {
#line 1448
    svfensure_buffer_stack(yyscanner);
#line 1449
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = svf_create_buffer(yyg->yyin_r,
                                                                           16384,
                                                                           yyscanner);
    }
  }
#line 1453
  if (yyg->yy_buffer_stack) {
#line 1453
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1453
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1453
  svf_init_buffer(tmp___0, input_file, yyscanner);
#line 1454
  svf_load_buffer_state(yyscanner);
  }
#line 1455
  return;
}
}
#line 1461 "svf_flex.c"
void svf_switch_to_buffer(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1463
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1470
  svfensure_buffer_stack(yyscanner);
  }
#line 1471
  if (yyg->yy_buffer_stack) {
#line 1471
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1471
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1471
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1472
    return;
  }
#line 1474
  if (yyg->yy_buffer_stack) {
#line 1474
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1474
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1474
  if (tmp___0) {
#line 1477
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 1478
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 1479
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
  {
#line 1482
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 1483
  svf_load_buffer_state(yyscanner);
#line 1490
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 1491
  return;
}
}
#line 1493 "svf_flex.c"
static void svf_load_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  char *tmp ;

  {
#line 1495
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1496
  yyg->yy_n_chars = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars;
#line 1497
  tmp = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos;
#line 1497
  yyg->yy_c_buf_p = tmp;
#line 1497
  yyg->yytext_r = tmp;
#line 1498
  yyg->yyin_r = (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_input_file;
#line 1499
  yyg->yy_hold_char = *(yyg->yy_c_buf_p);
#line 1500
  return;
}
}
#line 1508 "svf_flex.c"
YY_BUFFER_STATE svf_create_buffer(FILE *file , int size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1512
  tmp = svfalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 1512
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1513
  if (! b) {
    {
#line 1514
    yy_fatal_error___1("out of dynamic memory in svf_create_buffer()", yyscanner);
    }
  }
  {
#line 1516
  b->yy_buf_size = (yy_size_t )size;
#line 1521
  tmp___0 = svfalloc(b->yy_buf_size + 2UL, yyscanner);
#line 1521
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1522
  if (! b->yy_ch_buf) {
    {
#line 1523
    yy_fatal_error___1("out of dynamic memory in svf_create_buffer()", yyscanner);
    }
  }
  {
#line 1525
  b->yy_is_our_buffer = 1;
#line 1527
  svf_init_buffer(b, file, yyscanner);
  }
#line 1529
  return (b);
}
}
#line 1536 "svf_flex.c"
void svf_delete_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1538
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1540
  if (! b) {
#line 1541
    return;
  }
#line 1543
  if (yyg->yy_buffer_stack) {
#line 1543
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1543
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1543
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1544
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1546
  if (b->yy_is_our_buffer) {
    {
#line 1547
    svffree((void *)b->yy_ch_buf, yyscanner);
    }
  }
  {
#line 1549
  svffree((void *)b, yyscanner);
  }
#line 1550
  return;
}
}
#line 1560 "svf_flex.c"
static void svf_init_buffer(YY_BUFFER_STATE b , FILE *file , yyscan_t yyscanner ) 
{ 
  int oerrno ;
  int *tmp ;
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 1563
  tmp = __errno_location();
#line 1563
  oerrno = *tmp;
#line 1564
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1566
  svf_flush_buffer(b, yyscanner);
#line 1568
  b->yy_input_file = file;
#line 1569
  b->yy_fill_buffer = 1;
  }
#line 1575
  if (yyg->yy_buffer_stack) {
#line 1575
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1575
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1575
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1576
    b->yy_bs_lineno = 1;
#line 1577
    b->yy_bs_column = 0;
  }
#line 1580
  if (file) {
    {
#line 1580
    tmp___1 = fileno(file);
#line 1580
    tmp___2 = isatty(tmp___1);
#line 1580
    b->yy_is_interactive = tmp___2 > 0;
    }
  } else {
#line 1580
    b->yy_is_interactive = 0;
  }
  {
#line 1582
  tmp___3 = __errno_location();
#line 1582
  *tmp___3 = oerrno;
  }
#line 1583
  return;
}
}
#line 1589 "svf_flex.c"
void svf_flush_buffer(YY_BUFFER_STATE b , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1591
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1592
  if (! b) {
#line 1593
    return;
  }
#line 1595
  b->yy_n_chars = 0;
#line 1601
  *(b->yy_ch_buf + 0) = (char)0;
#line 1602
  *(b->yy_ch_buf + 1) = (char)0;
#line 1604
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 1606
  b->yy_at_bol = 1;
#line 1607
  b->yy_buffer_status = 0;
#line 1609
  if (yyg->yy_buffer_stack) {
#line 1609
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1609
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1609
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 1610
    svf_load_buffer_state(yyscanner);
    }
  }
#line 1611
  return;
}
}
#line 1619 "svf_flex.c"
void svfpush_buffer_state(YY_BUFFER_STATE new_buffer , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1621
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1622
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 1623
    return;
  }
  {
#line 1625
  svfensure_buffer_stack(yyscanner);
  }
#line 1628
  if (yyg->yy_buffer_stack) {
#line 1628
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1628
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1628
  if (tmp) {
#line 1631
    *(yyg->yy_c_buf_p) = yyg->yy_hold_char;
#line 1632
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_buf_pos = yyg->yy_c_buf_p;
#line 1633
    (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_n_chars = yyg->yy_n_chars;
  }
#line 1637
  if (yyg->yy_buffer_stack) {
#line 1637
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1637
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1637
  if (tmp___0) {
#line 1638
    (yyg->yy_buffer_stack_top) ++;
  }
  {
#line 1639
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = new_buffer;
#line 1642
  svf_load_buffer_state(yyscanner);
#line 1643
  yyg->yy_did_buffer_switch_on_eof = 1;
  }
#line 1644
  return;
}
}
#line 1650 "svf_flex.c"
void svfpop_buffer_state(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 1652
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1653
  if (yyg->yy_buffer_stack) {
#line 1653
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1653
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1653
  if (! tmp) {
#line 1654
    return;
  }
#line 1656
  if (yyg->yy_buffer_stack) {
#line 1656
    tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1656
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1656
  svf_delete_buffer(tmp___0, yyscanner);
#line 1657
  *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 1658
  if (yyg->yy_buffer_stack_top > 0UL) {
#line 1659
    (yyg->yy_buffer_stack_top) --;
  }
#line 1661
  if (yyg->yy_buffer_stack) {
#line 1661
    tmp___1 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1661
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1661
  if (tmp___1) {
    {
#line 1662
    svf_load_buffer_state(yyscanner);
#line 1663
    yyg->yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 1665
  return;
}
}
#line 1670 "svf_flex.c"
static void svfensure_buffer_stack(yyscan_t yyscanner ) 
{ 
  int num_to_alloc ;
  struct yyguts_t___0 *yyg ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 1673
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1675
  if (! yyg->yy_buffer_stack) {
    {
#line 1681
    num_to_alloc = 1;
#line 1682
    tmp = svfalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *),
                   yyscanner);
#line 1682
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 1685
    if (! yyg->yy_buffer_stack) {
      {
#line 1686
      yy_fatal_error___1("out of dynamic memory in svfensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 1688
    memset((void *)yyg->yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 1690
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
#line 1691
    yyg->yy_buffer_stack_top = (size_t )0;
    }
#line 1692
    return;
  }
#line 1695
  if (yyg->yy_buffer_stack_top >= yyg->yy_buffer_stack_max - 1UL) {
    {
#line 1698
    grow_size = 8;
#line 1700
    num_to_alloc = (int )(yyg->yy_buffer_stack_max + (size_t )grow_size);
#line 1701
    tmp___0 = svfrealloc((void *)yyg->yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *),
                         yyscanner);
#line 1701
    yyg->yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 1705
    if (! yyg->yy_buffer_stack) {
      {
#line 1706
      yy_fatal_error___1("out of dynamic memory in svfensure_buffer_stack()", yyscanner);
      }
    }
    {
#line 1709
    memset((void *)(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 1710
    yyg->yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 1712
  return;
}
}
#line 1720 "svf_flex.c"
YY_BUFFER_STATE svf_scan_buffer(char *base , yy_size_t size , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1724
  if (size < 2UL) {
#line 1728
    return ((YY_BUFFER_STATE )0);
  } else
#line 1724
  if ((int )*(base + (size - 2UL)) != 0) {
#line 1728
    return ((YY_BUFFER_STATE )0);
  } else
#line 1724
  if ((int )*(base + (size - 1UL)) != 0) {
#line 1728
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 1730
  tmp = svfalloc(sizeof(struct yy_buffer_state ), yyscanner);
#line 1730
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1731
  if (! b) {
    {
#line 1732
    yy_fatal_error___1("out of dynamic memory in svf_scan_buffer()", yyscanner);
    }
  }
  {
#line 1734
  b->yy_buf_size = size - 2UL;
#line 1735
  tmp___0 = base;
#line 1735
  b->yy_ch_buf = tmp___0;
#line 1735
  b->yy_buf_pos = tmp___0;
#line 1736
  b->yy_is_our_buffer = 0;
#line 1737
  b->yy_input_file = (FILE *)0;
#line 1738
  b->yy_n_chars = (int )b->yy_buf_size;
#line 1739
  b->yy_is_interactive = 0;
#line 1740
  b->yy_at_bol = 1;
#line 1741
  b->yy_fill_buffer = 0;
#line 1742
  b->yy_buffer_status = 0;
#line 1744
  svf_switch_to_buffer(b, yyscanner);
  }
#line 1746
  return (b);
}
}
#line 1757 "svf_flex.c"
YY_BUFFER_STATE svf_scan_string(char const   *yystr , yyscan_t yyscanner ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1760
  tmp = strlen(yystr);
#line 1760
  tmp___0 = svf_scan_bytes(yystr, (int )tmp, yyscanner);
  }
#line 1760
  return (tmp___0);
}
}
#line 1770 "svf_flex.c"
YY_BUFFER_STATE svf_scan_bytes(char const   *yybytes , int _yybytes_len , yyscan_t yyscanner ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 1778
  n = (yy_size_t )(_yybytes_len + 2);
#line 1779
  tmp = svfalloc(n, yyscanner);
#line 1779
  buf = (char *)tmp;
  }
#line 1780
  if (! buf) {
    {
#line 1781
    yy_fatal_error___1("out of dynamic memory in svf_scan_bytes()", yyscanner);
    }
  }
#line 1783
  i = 0;
  {
#line 1783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1783
    if (! (i < _yybytes_len)) {
#line 1783
      goto while_break;
    }
#line 1784
    *(buf + i) = (char )*(yybytes + i);
#line 1783
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1786
  tmp___0 = (char)0;
#line 1786
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 1786
  *(buf + _yybytes_len) = tmp___0;
#line 1788
  b = svf_scan_buffer(buf, n, yyscanner);
  }
#line 1789
  if (! b) {
    {
#line 1790
    yy_fatal_error___1("bad buffer in svf_scan_bytes()", yyscanner);
    }
  }
#line 1795
  b->yy_is_our_buffer = 1;
#line 1797
  return (b);
}
}
#line 1804 "svf_flex.c"
static void yy_fatal_error___1(char const   *msg , yyscan_t yyscanner ) 
{ 


  {
  {
#line 1806
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 1807
  exit(2);
  }
}
}
#line 1832 "svf_flex.c"
scanner_extra_t *svfget_extra(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1834
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1835
  return (yyg->yyextra_r);
}
}
#line 1841 "svf_flex.c"
int svfget_lineno(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1843
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1845
  if (yyg->yy_buffer_stack) {
#line 1845
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1845
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1845
  if (! tmp) {
#line 1846
    return (0);
  }
#line 1848
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno);
}
}
#line 1854 "svf_flex.c"
int svfget_column(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1856
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1858
  if (yyg->yy_buffer_stack) {
#line 1858
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1858
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1858
  if (! tmp) {
#line 1859
    return (0);
  }
#line 1861
  return ((*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column);
}
}
#line 1867 "svf_flex.c"
FILE *svfget_in(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1869
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1870
  return (yyg->yyin_r);
}
}
#line 1876 "svf_flex.c"
FILE *svfget_out(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1878
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1879
  return (yyg->yyout_r);
}
}
#line 1885 "svf_flex.c"
int svfget_leng(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1887
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1888
  return (yyg->yyleng_r);
}
}
#line 1895 "svf_flex.c"
char *svfget_text(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1897
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1898
  return (yyg->yytext_r);
}
}
#line 1905 "svf_flex.c"
void svfset_extra(scanner_extra_t *user_defined , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1907
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1908
  yyg->yyextra_r = user_defined;
#line 1909
  return;
}
}
#line 1915 "svf_flex.c"
void svfset_lineno(int line_number , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1917
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1920
  if (yyg->yy_buffer_stack) {
#line 1920
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1920
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1920
  if (! tmp) {
    {
#line 1921
    yy_fatal_error___1("svfset_lineno called with no buffer", yyscanner);
    }
  }
#line 1923
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_lineno = line_number;
#line 1924
  return;
}
}
#line 1930 "svf_flex.c"
void svfset_column(int column_no , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;

  {
#line 1932
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1935
  if (yyg->yy_buffer_stack) {
#line 1935
    tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
  } else {
#line 1935
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1935
  if (! tmp) {
    {
#line 1936
    yy_fatal_error___1("svfset_column called with no buffer", yyscanner);
    }
  }
#line 1938
  (*(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top))->yy_bs_column = column_no;
#line 1939
  return;
}
}
#line 1947 "svf_flex.c"
void svfset_in(FILE *in_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1949
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1950
  yyg->yyin_r = in_str;
#line 1951
  return;
}
}
#line 1953 "svf_flex.c"
void svfset_out(FILE *out_str , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1955
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1956
  yyg->yyout_r = out_str;
#line 1957
  return;
}
}
#line 1959 "svf_flex.c"
int svfget_debug(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1961
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1962
  return (yyg->yy_flex_debug_r);
}
}
#line 1965 "svf_flex.c"
void svfset_debug(int bdebug , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1967
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1968
  yyg->yy_flex_debug_r = bdebug;
#line 1969
  return;
}
}
#line 1973 "svf_flex.c"
YYSTYPE___0 *svfget_lval(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1975
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1976
  return (yyg->yylval_r);
}
}
#line 1979 "svf_flex.c"
void svfset_lval(YYSTYPE___0 *yylval_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1981
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1982
  yyg->yylval_r = yylval_param;
#line 1983
  return;
}
}
#line 1985 "svf_flex.c"
YYLTYPE *svfget_lloc(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1987
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1988
  return (yyg->yylloc_r);
}
}
#line 1991 "svf_flex.c"
void svfset_lloc(YYLTYPE *yylloc_param , yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 1993
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 1994
  yyg->yylloc_r = yylloc_param;
#line 1995
  return;
}
}
#line 2004 "svf_flex.c"
int svflex_init(yyscan_t *ptr_yy_globals ) 
{ 
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 2007
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2008
    tmp = __errno_location();
#line 2008
    *tmp = 22;
    }
#line 2009
    return (1);
  }
  {
#line 2012
  tmp___0 = svfalloc(sizeof(struct yyguts_t___0 ), (void *)0);
#line 2012
  *ptr_yy_globals = tmp___0;
  }
#line 2014
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2015
    tmp___1 = __errno_location();
#line 2015
    *tmp___1 = 12;
    }
#line 2016
    return (1);
  }
  {
#line 2020
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t___0 ));
#line 2022
  tmp___2 = yy_init_globals___1(*ptr_yy_globals);
  }
#line 2022
  return (tmp___2);
}
}
#line 2033 "svf_flex.c"
int svflex_init_extra(scanner_extra_t *yy_user_defined , yyscan_t *ptr_yy_globals ) 
{ 
  struct yyguts_t___0 dummy_yyguts ;
  int *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2038
  svfset_extra(yy_user_defined, (yyscan_t )(& dummy_yyguts));
  }
#line 2040
  if ((unsigned long )ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2041
    tmp = __errno_location();
#line 2041
    *tmp = 22;
    }
#line 2042
    return (1);
  }
  {
#line 2045
  tmp___0 = svfalloc(sizeof(struct yyguts_t___0 ), (yyscan_t )(& dummy_yyguts));
#line 2045
  *ptr_yy_globals = tmp___0;
  }
#line 2047
  if ((unsigned long )*ptr_yy_globals == (unsigned long )((void *)0)) {
    {
#line 2048
    tmp___1 = __errno_location();
#line 2048
    *tmp___1 = 12;
    }
#line 2049
    return (1);
  }
  {
#line 2054
  memset(*ptr_yy_globals, 0, sizeof(struct yyguts_t___0 ));
#line 2056
  svfset_extra(yy_user_defined, *ptr_yy_globals);
#line 2058
  tmp___2 = yy_init_globals___1(*ptr_yy_globals);
  }
#line 2058
  return (tmp___2);
}
}
#line 2061 "svf_flex.c"
static int yy_init_globals___1(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;

  {
#line 2063
  yyg = (struct yyguts_t___0 *)yyscanner;
#line 2068
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2069
  yyg->yy_buffer_stack_top = (size_t )0;
#line 2070
  yyg->yy_buffer_stack_max = (size_t )0;
#line 2071
  yyg->yy_c_buf_p = (char *)0;
#line 2072
  yyg->yy_init = 0;
#line 2073
  yyg->yy_start = 0;
#line 2075
  yyg->yy_start_stack_ptr = 0;
#line 2076
  yyg->yy_start_stack_depth = 0;
#line 2077
  yyg->yy_start_stack = (int *)((void *)0);
#line 2084
  yyg->yyin_r = (FILE *)0;
#line 2085
  yyg->yyout_r = (FILE *)0;
#line 2091
  return (0);
}
}
#line 2095 "svf_flex.c"
int svflex_destroy(yyscan_t yyscanner ) 
{ 
  struct yyguts_t___0 *yyg ;
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2097
  yyg = (struct yyguts_t___0 *)yyscanner;
  {
#line 2100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2100
    if (yyg->yy_buffer_stack) {
#line 2100
      tmp___0 = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2100
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2100
    if (! tmp___0) {
#line 2100
      goto while_break;
    }
#line 2101
    if (yyg->yy_buffer_stack) {
#line 2101
      tmp = *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top);
    } else {
#line 2101
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2101
    svf_delete_buffer(tmp, yyscanner);
#line 2102
    *(yyg->yy_buffer_stack + yyg->yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2103
    svfpop_buffer_state(yyscanner);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2107
  svffree((void *)yyg->yy_buffer_stack, yyscanner);
#line 2108
  yyg->yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2111
  svffree((void *)yyg->yy_start_stack, yyscanner);
#line 2112
  yyg->yy_start_stack = (int *)((void *)0);
#line 2116
  yy_init_globals___1(yyscanner);
#line 2119
  svffree(yyscanner, yyscanner);
#line 2120
  yyscanner = (void *)0;
  }
#line 2121
  return (0);
}
}
#line 2148 "svf_flex.c"
void *svfalloc(yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2150
  tmp = malloc(size);
  }
#line 2150
  return (tmp);
}
}
#line 2153 "svf_flex.c"
void *svfrealloc(void *ptr , yy_size_t size , yyscan_t yyscanner ) 
{ 
  void *tmp ;

  {
  {
#line 2162
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2162
  return (tmp);
}
}
#line 2165 "svf_flex.c"
void svffree(void *ptr , yyscan_t yyscanner ) 
{ 


  {
  {
#line 2167
  free((void *)((char *)ptr));
  }
#line 2168
  return;
}
}
#line 191 "svf_flex.l"
static struct rwtable rwtable[53]  = 
#line 191 "svf_flex.l"
  {      {(char *)"ABSENT", 278}, 
        {(char *)"D", 293}, 
        {(char *)"DRCAPTURE", 314}, 
        {(char *)"DREXIT1", 312}, 
        {(char *)"DREXIT2", 313}, 
        {(char *)"DRPAUSE", 308}, 
        {(char *)"DRSELECT", 311}, 
        {(char *)"DRSHIFT", 309}, 
        {(char *)"DRUPDATE", 310}, 
        {(char *)"EMPTY", 262}, 
        {(char *)"ENDDR", 263}, 
        {(char *)"ENDIR", 264}, 
        {(char *)"ENDSTATE", 300}, 
        {(char *)"FREQUENCY", 265}, 
        {(char *)"H", 290}, 
        {(char *)"HDR", 279}, 
        {(char *)"HIR", 280}, 
        {(char *)"HZ", 266}, 
        {(char *)"IDLE", 269}, 
        {(char *)"IN", 287}, 
        {(char *)"INOUT", 289}, 
        {(char *)"IRCAPTURE", 307}, 
        {(char *)"IREXIT1", 305}, 
        {(char *)"IREXIT2", 306}, 
        {(char *)"IRPAUSE", 301}, 
        {(char *)"IRSELECT", 304}, 
        {(char *)"IRSHIFT", 302}, 
        {(char *)"IRUPDATE", 303}, 
        {(char *)"L", 291}, 
        {(char *)"MASK", 272}, 
        {(char *)"MAXIMUM", 296}, 
        {(char *)"OFF", 276}, 
        {(char *)"ON", 275}, 
        {(char *)"OUT", 288}, 
        {(char *)"PIO", 285}, 
        {(char *)"PIOMAP", 286}, 
        {(char *)"RESET", 268}, 
        {(char *)"RUNTEST", 295}, 
        {(char *)"SCK", 299}, 
        {(char *)"SDR", 281}, 
        {(char *)"SEC", 297}, 
        {(char *)"SIR", 282}, 
        {(char *)"SMASK", 273}, 
        {(char *)"STATE", 267}, 
        {(char *)"TCK", 298}, 
        {(char *)"TDI", 270}, 
        {(char *)"TDO", 271}, 
        {(char *)"TDR", 283}, 
        {(char *)"TIR", 284}, 
        {(char *)"TRST", 274}, 
        {(char *)"U", 292}, 
        {(char *)"X", 294}, 
        {(char *)"Z", 277}};
#line 253 "svf_flex.l"
static int map_keyw_ident(YYSTYPE___0 *mylval , char *str ) 
{ 
  int idx ;
  int rw ;
  int tmp ;

  {
#line 257
  rw = 258;
#line 259
  mylval->cvalue = str;
#line 261
  idx = 0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! ((unsigned long )idx <= sizeof(rwtable) / sizeof(rwtable[0]) - 1UL)) {
#line 261
      goto while_break;
    }
    {
#line 262
    tmp = strcasecmp((char const   *)rwtable[idx].rw_name, (char const   *)str);
    }
#line 262
    if (tmp == 0) {
#line 264
      rw = rwtable[idx].rw_yylex;
#line 265
      mylval->token = rw;
    }
#line 261
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (rw);
}
}
#line 273 "svf_flex.l"
static void align_string(char *str ) 
{ 
  int src ;
  int dst ;
  int len ;
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 278
  dst = 0;
#line 279
  tmp = strlen((char const   *)str);
#line 279
  len = (int )tmp;
#line 281
  src = 0;
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (src < len)) {
#line 281
      goto while_break;
    }
    {
#line 282
    tmp___1 = __ctype_b_loc();
    }
#line 282
    if ((int const   )*(*tmp___1 + (int )*(str + src)) & 4096) {
#line 283
      tmp___0 = dst;
#line 283
      dst ++;
#line 283
      *(str + tmp___0) = *(str + src);
    }
#line 281
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 285
  *(str + dst) = (char )'\000';
#line 286
  return;
}
}
#line 289 "svf_flex.l"
static void fix_yylloc(YYLTYPE *mylloc , char *str ) 
{ 
  size_t tmp ;

  {
  {
#line 292
  mylloc->first_line = mylloc->last_line;
#line 293
  mylloc->first_column = mylloc->last_column;
#line 294
  tmp = strlen((char const   *)str);
#line 294
  mylloc->last_column = (int )((size_t )mylloc->last_column + tmp);
  }
#line 295
  return;
}
}
#line 298 "svf_flex.l"
static void fix_yylloc_nl(YYLTYPE *mylloc , char *str , scanner_extra_t *extra ) 
{ 
  char *p ;
  char *tmp ;

  {
#line 303
  mylloc->first_line = mylloc->last_line;
#line 304
  mylloc->first_column = mylloc->last_column;
#line 305
  p = str;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! *p) {
#line 305
      goto while_break;
    }
#line 306
    if ((int )*p == 10) {
#line 307
      mylloc->last_column = 0;
#line 308
      (mylloc->last_line) ++;
#line 309
      if (extra->print_progress) {
        {
#line 310
        printf((char const   */* __restrict  */)"\r");
#line 311
        tmp = gettext("Parsing %6d/%d (%3.0d%%)");
#line 311
        printf((char const   */* __restrict  */)tmp, mylloc->last_line, extra->num_lines,
               (mylloc->last_line * 100 + 1) / extra->num_lines);
        }
      }
    } else {
#line 316
      (mylloc->last_column) ++;
    }
#line 305
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return;
}
}
#line 322 "svf_flex.l"
void *svf_flex_init(FILE *f , int num_lines , int print_progress ) 
{ 
  scanner_extra_t *extra ;
  yyscan_t scanner ;
  int tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 328
  tmp = svflex_init(& scanner);
  }
#line 328
  if (tmp != 0) {
#line 329
    return ((void *)0);
  }
  {
#line 331
  svfset_in(f, scanner);
#line 333
  tmp___1 = malloc(sizeof(scanner_extra_t ));
#line 333
  extra = (scanner_extra_t *)tmp___1;
  }
#line 333
  if (! extra) {
    {
#line 334
    tmp___0 = gettext("Out of memory, %s line %i\n");
#line 334
    printf((char const   */* __restrict  */)tmp___0, "svf_flex.l", 334);
#line 335
    svflex_destroy(scanner);
    }
#line 336
    return ((void *)0);
  }
  {
#line 339
  extra->num_lines = num_lines;
#line 340
  extra->print_progress = print_progress;
#line 342
  svfset_extra(extra, scanner);
  }
#line 344
  return (scanner);
}
}
#line 348 "svf_flex.l"
void svf_flex_deinit(void *scanner ) 
{ 
  scanner_extra_t *extra ;
  scanner_extra_t *tmp ;

  {
  {
#line 350
  tmp = svfget_extra(scanner);
#line 350
  extra = tmp;
  }
#line 351
  if (extra->print_progress) {
    {
#line 352
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 353
  free((void *)extra);
#line 354
  svflex_destroy(scanner);
  }
#line 355
  return;
}
}
#line 47 "svf_bison.y"
void svferror(YYLTYPE *locp , parser_priv_t *priv_data , chain_t *chain , char const   *error_string ) ;
#line 49
static void svf_free_ths_params(struct ths_params *params ) ;
#line 512 "svf_bison.c"
static yytype_uint8 const   yytranslate___1[315]  = 
#line 512 "svf_bison.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59};
#line 603 "svf_bison.c"
static char const   * const  yytname[81]  = 
#line 603
  {      (char const   */* const  */)"SVF_EOF",      (char const   */* const  */)"error",      (char const   */* const  */)"$undefined",      (char const   */* const  */)"IDENTIFIER", 
        (char const   */* const  */)"NUMBER",      (char const   */* const  */)"HEXA_NUM",      (char const   */* const  */)"VECTOR_STRING",      (char const   */* const  */)"EMPTY", 
        (char const   */* const  */)"ENDDR",      (char const   */* const  */)"ENDIR",      (char const   */* const  */)"FREQUENCY",      (char const   */* const  */)"HZ", 
        (char const   */* const  */)"STATE",      (char const   */* const  */)"RESET",      (char const   */* const  */)"IDLE",      (char const   */* const  */)"TDI", 
        (char const   */* const  */)"TDO",      (char const   */* const  */)"MASK",      (char const   */* const  */)"SMASK",      (char const   */* const  */)"TRST", 
        (char const   */* const  */)"ON",      (char const   */* const  */)"OFF",      (char const   */* const  */)"Z",      (char const   */* const  */)"ABSENT", 
        (char const   */* const  */)"HDR",      (char const   */* const  */)"HIR",      (char const   */* const  */)"SDR",      (char const   */* const  */)"SIR", 
        (char const   */* const  */)"TDR",      (char const   */* const  */)"TIR",      (char const   */* const  */)"PIO",      (char const   */* const  */)"PIOMAP", 
        (char const   */* const  */)"IN",      (char const   */* const  */)"OUT",      (char const   */* const  */)"INOUT",      (char const   */* const  */)"H", 
        (char const   */* const  */)"L",      (char const   */* const  */)"U",      (char const   */* const  */)"D",      (char const   */* const  */)"X", 
        (char const   */* const  */)"RUNTEST",      (char const   */* const  */)"MAXIMUM",      (char const   */* const  */)"SEC",      (char const   */* const  */)"TCK", 
        (char const   */* const  */)"SCK",      (char const   */* const  */)"ENDSTATE",      (char const   */* const  */)"IRPAUSE",      (char const   */* const  */)"IRSHIFT", 
        (char const   */* const  */)"IRUPDATE",      (char const   */* const  */)"IRSELECT",      (char const   */* const  */)"IREXIT1",      (char const   */* const  */)"IREXIT2", 
        (char const   */* const  */)"IRCAPTURE",      (char const   */* const  */)"DRPAUSE",      (char const   */* const  */)"DRSHIFT",      (char const   */* const  */)"DRUPDATE", 
        (char const   */* const  */)"DRSELECT",      (char const   */* const  */)"DREXIT1",      (char const   */* const  */)"DREXIT2",      (char const   */* const  */)"DRCAPTURE", 
        (char const   */* const  */)"\';\'",      (char const   */* const  */)"\'(\'",      (char const   */* const  */)"\')\'",      (char const   */* const  */)"$accept", 
        (char const   */* const  */)"line",      (char const   */* const  */)"svf_statement",      (char const   */* const  */)"ths_param_list",      (char const   */* const  */)"ths_opt_param", 
        (char const   */* const  */)"stable_state",      (char const   */* const  */)"runtest_run_state_opt",      (char const   */* const  */)"runtest_clk_count",      (char const   */* const  */)"runtest_time_opt", 
        (char const   */* const  */)"runtest_time",      (char const   */* const  */)"runtest_max_time_opt",      (char const   */* const  */)"runtest_end_state_opt",      (char const   */* const  */)"all_states", 
        (char const   */* const  */)"path_states",      (char const   */* const  */)"piomap_rec",      (char const   */* const  */)"trst_mode",      (char const   */* const  */)"direction", 
        (char const   */* const  */)0};
#line 637 "svf_bison.c"
static yytype_uint8 const   yyr1___1[69]  = 
#line 637
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )70,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )74,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )75, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )78,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )79, 
        (yytype_uint8 const   )79};
#line 649 "svf_bison.c"
static yytype_uint8 const   yyr2___1[69]  = 
#line 649
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1};
#line 663 "svf_bison.c"
static yytype_uint8 const   yydefact___1[119]  = 
#line 663
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )30,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )0,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )54,      (yytype_uint8 const   )50,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )17,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )60,      (yytype_uint8 const   )38,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )0,      (yytype_uint8 const   )41,      (yytype_uint8 const   )14, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )11,      (yytype_uint8 const   )61,      (yytype_uint8 const   )39};
#line 680 "svf_bison.c"
static yytype_int8 const   yydefgoto___1[17]  = 
#line 680
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )19,      (yytype_int8 const   )66, 
        (yytype_int8 const   )87,      (yytype_int8 const   )24,      (yytype_int8 const   )43,      (yytype_int8 const   )78, 
        (yytype_int8 const   )98,      (yytype_int8 const   )79,      (yytype_int8 const   )108,      (yytype_int8 const   )101, 
        (yytype_int8 const   )64,      (yytype_int8 const   )28,      (yytype_int8 const   )106,      (yytype_int8 const   )33, 
        (yytype_int8 const   )76};
#line 689 "svf_bison.c"
static yytype_int16 const   yypact___1[119]  = 
#line 689
  {      (yytype_int16 const   )55,      (yytype_int16 const   )4,      (yytype_int16 const   )88,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )46,      (yytype_int16 const   )46,      (yytype_int16 const   )-3, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )31,      (yytype_int16 const   )17,      (yytype_int16 const   )45, 
        (yytype_int16 const   )57,      (yytype_int16 const   )62,      (yytype_int16 const   )71,      (yytype_int16 const   )73, 
        (yytype_int16 const   )67,      (yytype_int16 const   )26,      (yytype_int16 const   )46,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )18,      (yytype_int16 const   )29,      (yytype_int16 const   )79,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-11,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )33,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )44,      (yytype_int16 const   )-23,      (yytype_int16 const   )-24,      (yytype_int16 const   )87, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )48,      (yytype_int16 const   )49, 
        (yytype_int16 const   )50,      (yytype_int16 const   )51,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )65,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )66, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-10,      (yytype_int16 const   )-2, 
        (yytype_int16 const   )2,      (yytype_int16 const   )8,      (yytype_int16 const   )12,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )102,      (yytype_int16 const   )27,      (yytype_int16 const   )123,      (yytype_int16 const   )61, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )124,      (yytype_int16 const   )125, 
        (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )93,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )94,      (yytype_int16 const   )61,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )46,      (yytype_int16 const   )75,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )69,      (yytype_int16 const   )133, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )78,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )80,      (yytype_int16 const   )136,      (yytype_int16 const   )99,      (yytype_int16 const   )-24, 
        (yytype_int16 const   )-24,      (yytype_int16 const   )-24,      (yytype_int16 const   )-24};
#line 706 "svf_bison.c"
static yytype_int8 const   yypgoto___1[17]  = 
#line 706
  {      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )85, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-6,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )64,      (yytype_int8 const   )-24,      (yytype_int8 const   )47, 
        (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24,      (yytype_int8 const   )-24, 
        (yytype_int8 const   )37};
#line 717 "svf_bison.c"
static yytype_int8 const   yytable___1[146]  = 
#line 717
  {      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )47,      (yytype_int8 const   )48, 
        (yytype_int8 const   )3,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )42,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )82,      (yytype_int8 const   )83,      (yytype_int8 const   )84, 
        (yytype_int8 const   )85,      (yytype_int8 const   )34,      (yytype_int8 const   )63,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )82, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )85,      (yytype_int8 const   )49, 
        (yytype_int8 const   )50,      (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53, 
        (yytype_int8 const   )54,      (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57, 
        (yytype_int8 const   )58,      (yytype_int8 const   )59,      (yytype_int8 const   )60,      (yytype_int8 const   )61, 
        (yytype_int8 const   )62,      (yytype_int8 const   )35,      (yytype_int8 const   )86,      (yytype_int8 const   )29, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )1,      (yytype_int8 const   )27,      (yytype_int8 const   )88,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )36,      (yytype_int8 const   )89,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )37,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )90,      (yytype_int8 const   )94,      (yytype_int8 const   )95,      (yytype_int8 const   )96, 
        (yytype_int8 const   )91,      (yytype_int8 const   )40,      (yytype_int8 const   )-2,      (yytype_int8 const   )38, 
        (yytype_int8 const   )92,      (yytype_int8 const   )39,      (yytype_int8 const   )44,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )-2,      (yytype_int8 const   )41, 
        (yytype_int8 const   )4,      (yytype_int8 const   )45,      (yytype_int8 const   )46,      (yytype_int8 const   )77, 
        (yytype_int8 const   )22,      (yytype_int8 const   )65,      (yytype_int8 const   )110,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )23, 
        (yytype_int8 const   )8,      (yytype_int8 const   )73,      (yytype_int8 const   )74,      (yytype_int8 const   )75, 
        (yytype_int8 const   )72,      (yytype_int8 const   )93,      (yytype_int8 const   )100,      (yytype_int8 const   )9, 
        (yytype_int8 const   )80,      (yytype_int8 const   )-27,      (yytype_int8 const   )-28,      (yytype_int8 const   )-30, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )67,      (yytype_int8 const   )68,      (yytype_int8 const   )69,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-29,      (yytype_int8 const   )81,      (yytype_int8 const   )97, 
        (yytype_int8 const   )18,      (yytype_int8 const   )102,      (yytype_int8 const   )103,      (yytype_int8 const   )112, 
        (yytype_int8 const   )104,      (yytype_int8 const   )105,      (yytype_int8 const   )107,      (yytype_int8 const   )111, 
        (yytype_int8 const   )94,      (yytype_int8 const   )114,      (yytype_int8 const   )115,      (yytype_int8 const   )117, 
        (yytype_int8 const   )116,      (yytype_int8 const   )118,      (yytype_int8 const   )99,      (yytype_int8 const   )113, 
        (yytype_int8 const   )0,      (yytype_int8 const   )109};
#line 736 "svf_bison.c"
static yytype_int8 const   yycheck___1[146]  = 
#line 736
  {      (yytype_int8 const   )6,      (yytype_int8 const   )4,      (yytype_int8 const   )13,      (yytype_int8 const   )14, 
        (yytype_int8 const   )0,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )15,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )4,      (yytype_int8 const   )28,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )17,      (yytype_int8 const   )18,      (yytype_int8 const   )46, 
        (yytype_int8 const   )47,      (yytype_int8 const   )48,      (yytype_int8 const   )49,      (yytype_int8 const   )50, 
        (yytype_int8 const   )51,      (yytype_int8 const   )52,      (yytype_int8 const   )53,      (yytype_int8 const   )54, 
        (yytype_int8 const   )55,      (yytype_int8 const   )56,      (yytype_int8 const   )57,      (yytype_int8 const   )58, 
        (yytype_int8 const   )59,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )23,      (yytype_int8 const   )0, 
        (yytype_int8 const   )1,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4,      (yytype_int8 const   )12, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )60,      (yytype_int8 const   )6,      (yytype_int8 const   )19,      (yytype_int8 const   )4, 
        (yytype_int8 const   )60,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )24, 
        (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27,      (yytype_int8 const   )28, 
        (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )61, 
        (yytype_int8 const   )0,      (yytype_int8 const   )60,      (yytype_int8 const   )11,      (yytype_int8 const   )4, 
        (yytype_int8 const   )46,      (yytype_int8 const   )60,      (yytype_int8 const   )100,      (yytype_int8 const   )40, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )53, 
        (yytype_int8 const   )12,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )60,      (yytype_int8 const   )3,      (yytype_int8 const   )45,      (yytype_int8 const   )19, 
        (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )60, 
        (yytype_int8 const   )24,      (yytype_int8 const   )25,      (yytype_int8 const   )26,      (yytype_int8 const   )27, 
        (yytype_int8 const   )28,      (yytype_int8 const   )29,      (yytype_int8 const   )30,      (yytype_int8 const   )31, 
        (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37,      (yytype_int8 const   )38, 
        (yytype_int8 const   )39,      (yytype_int8 const   )60,      (yytype_int8 const   )60,      (yytype_int8 const   )4, 
        (yytype_int8 const   )40,      (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )62, 
        (yytype_int8 const   )5,      (yytype_int8 const   )5,      (yytype_int8 const   )41,      (yytype_int8 const   )60, 
        (yytype_int8 const   )42,      (yytype_int8 const   )4,      (yytype_int8 const   )60,      (yytype_int8 const   )3, 
        (yytype_int8 const   )60,      (yytype_int8 const   )42,      (yytype_int8 const   )78,      (yytype_int8 const   )106, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )98};
#line 757 "svf_bison.c"
static yytype_uint8 const   yystos___1[119]  = 
#line 757
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )64,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )40,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )53, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )68,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )76,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )78,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )61,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )11,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )60,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )70,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )60,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )74,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )5,      (yytype_uint8 const   )77,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )74,      (yytype_uint8 const   )68,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )79,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )3,      (yytype_uint8 const   )42};
#line 1065 "svf_bison.c"
static unsigned long yystrlen(char const   *yystr ) 
{ 
  unsigned long yylen ;

  {
#line 1074
  yylen = 0UL;
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1074
    if (! *(yystr + yylen)) {
#line 1074
      goto while_break;
    }
#line 1075
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1074
    yylen ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1076
  return (yylen);
}
}
#line 1089 "svf_bison.c"
static char *yystpcpy(char *yydest , char const   *yysrc ) 
{ 
  char *yyd ;
  char const   *yys ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1098
  yyd = yydest;
#line 1099
  yys = yysrc;
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1101
    tmp = yyd;
#line 1101
    yyd ++;
#line 1101
    tmp___1 = yys;
#line 1101
    yys ++;
#line 1101
    tmp___0 = (char )*tmp___1;
#line 1101
    *tmp = tmp___0;
#line 1101
    if (! ((int )tmp___0 != 0)) {
#line 1101
      goto while_break;
    }
#line 1102
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1104
  return (yyd - 1);
}
}
#line 1117 "svf_bison.c"
static unsigned long yytnamerr(char *yyres , char const   *yystr ) 
{ 
  unsigned long yyn ;
  char const   *yyp ;
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 1120
  if ((int const   )*yystr == 34) {
#line 1122
    yyn = 0UL;
#line 1123
    yyp = yystr;
    {
#line 1125
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1126
      yyp ++;
      {
#line 1129
      if ((int const   )*yyp == 44) {
#line 1129
        goto case_44;
      }
#line 1129
      if ((int const   )*yyp == 39) {
#line 1129
        goto case_44;
      }
#line 1132
      if ((int const   )*yyp == 92) {
#line 1132
        goto case_92;
      }
#line 1142
      if ((int const   )*yyp == 34) {
#line 1142
        goto case_34;
      }
#line 1136
      goto switch_default;
      case_44: /* CIL Label */ 
      case_39: /* CIL Label */ 
#line 1130
      goto do_not_strip_quotes;
      case_92: /* CIL Label */ 
#line 1133
      yyp ++;
#line 1133
      if ((int const   )*yyp != 92) {
#line 1134
        goto do_not_strip_quotes;
      }
      switch_default: /* CIL Label */ 
#line 1137
      if (yyres) {
#line 1138
        *(yyres + yyn) = (char )*yyp;
      }
#line 1139
      yyn ++;
#line 1140
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1143
      if (yyres) {
#line 1144
        *(yyres + yyn) = (char )'\000';
      }
#line 1145
      return (yyn);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    do_not_strip_quotes: ;
  }
#line 1150
  if (! yyres) {
    {
#line 1151
    tmp = yystrlen(yystr);
    }
#line 1151
    return (tmp);
  }
  {
#line 1153
  tmp___0 = yystpcpy(yyres, yystr);
  }
#line 1153
  return ((unsigned long )(tmp___0 - yyres));
}
}
#line 1193
static unsigned long yysyntax_error(char *yyresult , int yystate , int svfchar ) ;
#line 1193 "svf_bison.c"
static char const   yyunexpected[28]  = 
#line 1193
  {      (char const   )'s',      (char const   )'y',      (char const   )'n',      (char const   )'t', 
        (char const   )'a',      (char const   )'x',      (char const   )' ',      (char const   )'e', 
        (char const   )'r',      (char const   )'r',      (char const   )'o',      (char const   )'r', 
        (char const   )',',      (char const   )' ',      (char const   )'u',      (char const   )'n', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'e', 
        (char const   )'c',      (char const   )'t',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1194 "svf_bison.c"
static char const   yyexpecting[15]  = 
#line 1194
  {      (char const   )',',      (char const   )' ',      (char const   )'e',      (char const   )'x', 
        (char const   )'p',      (char const   )'e',      (char const   )'c',      (char const   )'t', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1195 "svf_bison.c"
static char const   yyor[7]  = {      (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'%',      (char const   )'s',      (char const   )'\000'};
#line 1164 "svf_bison.c"
static unsigned long yysyntax_error(char *yyresult , int yystate , int svfchar ) 
{ 
  int yyn ;
  int yytype ;
  int tmp ;
  unsigned long yysize0 ;
  unsigned long tmp___0 ;
  unsigned long yysize ;
  unsigned long yysize1 ;
  int yysize_overflow ;
  char const   *yyarg[5] ;
  int yyx ;
  char *yyfmt ;
  char const   *yyf ;
  char yyformat[((sizeof(yyunexpected) + sizeof(yyexpecting)) - 1UL) + 3UL * (sizeof(yyor) - 1UL)] ;
  char const   *yyprefix ;
  int yyxbegin ;
  int tmp___1 ;
  int yychecklim ;
  int yyxend ;
  int tmp___2 ;
  int yycount ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  char *yyp ;
  int yyi ;
  int tmp___6 ;
  unsigned long tmp___7 ;
  char tmp___8 ;

  {
#line 1167
  yyn = (int )yypact___1[yystate];
#line 1169
  if (-24 < yyn) {
#line 1169
    if (yyn <= 145) {
#line 1173
      if ((unsigned int )svfchar <= 314U) {
#line 1173
        tmp = (int const   )yytranslate___1[svfchar];
      } else {
#line 1173
        tmp = (int const   )2;
      }
      {
#line 1173
      yytype = (int )tmp;
#line 1174
      tmp___0 = yytnamerr((char *)0, (char const   *)yytname[yytype]);
#line 1174
      yysize0 = tmp___0;
#line 1175
      yysize = yysize0;
#line 1177
      yysize_overflow = 0;
#line 1200
      yyprefix = yyexpecting;
      }
#line 1204
      if (yyn < 0) {
#line 1204
        tmp___1 = - yyn;
      } else {
#line 1204
        tmp___1 = 0;
      }
#line 1204
      yyxbegin = tmp___1;
#line 1207
      yychecklim = (145 - yyn) + 1;
#line 1208
      if (yychecklim < 63) {
#line 1208
        tmp___2 = yychecklim;
      } else {
#line 1208
        tmp___2 = 63;
      }
      {
#line 1208
      yyxend = tmp___2;
#line 1209
      yycount = 1;
#line 1211
      yyarg[0] = (char const   *)yytname[yytype];
#line 1212
      yyfmt = yystpcpy(yyformat, yyunexpected);
#line 1214
      yyx = yyxbegin;
      }
      {
#line 1214
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1214
        if (! (yyx < yyxend)) {
#line 1214
          goto while_break;
        }
#line 1215
        if ((int const   )yycheck___1[yyx + yyn] == (int const   )yyx) {
#line 1215
          if (yyx != 1) {
#line 1217
            if (yycount == 5) {
#line 1219
              yycount = 1;
#line 1220
              yysize = yysize0;
#line 1221
              yyformat[sizeof(yyunexpected) - 1UL] = (char )'\000';
#line 1222
              goto while_break;
            }
            {
#line 1224
            tmp___3 = yycount;
#line 1224
            yycount ++;
#line 1224
            yyarg[tmp___3] = (char const   *)yytname[yyx];
#line 1225
            tmp___4 = yytnamerr((char *)0, (char const   *)yytname[yyx]);
#line 1225
            yysize1 = yysize + tmp___4;
#line 1226
            yysize_overflow |= yysize1 < yysize;
#line 1227
            yysize = yysize1;
#line 1228
            yyfmt = yystpcpy(yyfmt, yyprefix);
#line 1229
            yyprefix = yyor;
            }
          }
        }
#line 1214
        yyx ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1232
      yyf = (char const   *)(yyformat);
#line 1233
      tmp___5 = yystrlen(yyf);
#line 1233
      yysize1 = yysize + tmp___5;
#line 1234
      yysize_overflow |= yysize1 < yysize;
#line 1235
      yysize = yysize1;
      }
#line 1237
      if (yysize_overflow) {
#line 1238
        return (0xffffffffffffffffUL);
      }
#line 1240
      if (yyresult) {
#line 1245
        yyp = yyresult;
#line 1246
        yyi = 0;
        {
#line 1247
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1247
          tmp___8 = (char )*yyf;
#line 1247
          *yyp = tmp___8;
#line 1247
          if (! ((int )tmp___8 != 0)) {
#line 1247
            goto while_break___0;
          }
#line 1249
          if ((int )*yyp == 37) {
#line 1249
            if ((int const   )*(yyf + 1) == 115) {
#line 1249
              if (yyi < yycount) {
                {
#line 1251
                tmp___6 = yyi;
#line 1251
                yyi ++;
#line 1251
                tmp___7 = yytnamerr(yyp, yyarg[tmp___6]);
#line 1251
                yyp += tmp___7;
#line 1252
                yyf += 2;
                }
              } else {
#line 1256
                yyp ++;
#line 1257
                yyf ++;
              }
            } else {
#line 1256
              yyp ++;
#line 1257
              yyf ++;
            }
          } else {
#line 1256
            yyp ++;
#line 1257
            yyf ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 1261
      return (yysize);
    } else {
#line 1170
      return (0UL);
    }
  } else {
#line 1170
    return (0UL);
  }
}
}
#line 1274 "svf_bison.c"
static void yydestruct___1(char const   *yymsg , int yytype , YYSTYPE___0 *yyvaluep ,
                           YYLTYPE *yylocationp , parser_priv_t *priv_data , chain_t *chain ) 
{ 


  {
#line 1292
  if (! yymsg) {
#line 1293
    yymsg = "Deleting";
  }
  {
#line 1299
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1300
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1302
  return;
}
}
#line 1343 "svf_bison.c"
int svfparse(parser_priv_t *priv_data , chain_t *chain ) 
{ 
  int svfchar ;
  YYSTYPE___0 svflval ;
  int svfnerrs ;
  YYLTYPE svflloc ;
  int yystate ;
  int yyn ;
  int yyresult ;
  int yyerrstatus ;
  int yytoken ;
  char yymsgbuf[128] ;
  char *yymsg ;
  unsigned long yymsg_alloc ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE___0 yyvsa[200] ;
  YYSTYPE___0 *yyvs ;
  YYSTYPE___0 *yyvsp ;
  YYLTYPE yylsa[200] ;
  YYLTYPE *yyls ;
  YYLTYPE *yylsp ;
  YYLTYPE yyerror_range[2] ;
  unsigned long yystacksize ;
  YYSTYPE___0 yyval ;
  YYLTYPE yyloc ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc___0 *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  unsigned long yynewbytes___1 ;
  struct ths_params *p ;
  struct ths_params *p___0 ;
  struct runtest *rt ;
  int tmp___0 ;
  struct runtest *rt___0 ;
  int tmp___1 ;
  struct ths_params *p___1 ;
  int result ;
  struct ths_params *p___2 ;
  int result___0 ;
  int tmp___2 ;
  struct ths_params *p___3 ;
  int result___1 ;
  struct ths_params *p___4 ;
  int result___2 ;
  int tmp___3 ;
  struct path_states *ps ;
  unsigned long yysize___0 ;
  unsigned long tmp___4 ;
  unsigned long yyalloc ;
  void *tmp___5 ;

  {
#line 1370
  yytoken = 0;
#line 1374
  yymsg = yymsgbuf;
#line 1375
  yymsg_alloc = sizeof(yymsgbuf);
#line 1388
  yyss = yyssa;
#line 1393
  yyvs = yyvsa;
#line 1398
  yyls = yylsa;
#line 1405
  yystacksize = 200UL;
#line 1414
  yylen = 0;
#line 1418
  yystate = 0;
#line 1419
  yyerrstatus = 0;
#line 1420
  svfnerrs = 0;
#line 1421
  svfchar = -2;
#line 1428
  yyssp = yyss;
#line 1429
  yyvsp = yyvs;
#line 1430
  yylsp = yyls;
#line 1433
  svflloc.last_line = 1;
#line 1433
  svflloc.first_line = svflloc.last_line;
#line 1434
  svflloc.last_column = 0;
#line 1434
  svflloc.first_column = svflloc.last_column;
#line 1437
  goto yysetstate;
  yynewstate: 
#line 1445
  yyssp ++;
  yysetstate: 
#line 1448
  *yyssp = (yytype_int16 )yystate;
#line 1450
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1453
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1482
    if (10000UL <= yystacksize) {
#line 1483
      goto yyexhaustedlab;
    }
#line 1484
    yystacksize *= 2UL;
#line 1485
    if (10000UL < yystacksize) {
#line 1486
      yystacksize = 10000UL;
    }
    {
#line 1489
    yyss1 = yyss;
#line 1490
    tmp = malloc(yystacksize * ((sizeof(yytype_int16 ) + sizeof(YYSTYPE___0 )) + sizeof(YYLTYPE )) + 2UL * (sizeof(union yyalloc___0 ) - 1UL));
#line 1490
    yyptr = (union yyalloc___0 *)tmp;
    }
#line 1492
    if (! yyptr) {
#line 1493
      goto yyexhaustedlab;
    }
    {
#line 1494
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1494
      __builtin_memcpy((void *)(& yyptr->yyss), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1494
      yyss = & yyptr->yyss;
#line 1494
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1494
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1494
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1495
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1495
      __builtin_memcpy((void *)(& yyptr->yyvs), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1495
      yyvs = & yyptr->yyvs;
#line 1495
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1495
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1495
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1496
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1496
      __builtin_memcpy((void *)(& yyptr->yyls), (void const   *)yyls, yysize * sizeof(*yyls));
#line 1496
      yyls = & yyptr->yyls;
#line 1496
      yynewbytes___1 = yystacksize * sizeof(*yyls) + (sizeof(union yyalloc___0 ) - 1UL);
#line 1496
      yyptr += yynewbytes___1 / sizeof(*yyptr);
      }
#line 1496
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1498
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1499
      free((void *)yyss1);
      }
    }
#line 1504
    yyssp = (yyss + yysize) - 1;
#line 1505
    yyvsp = (yyvs + yysize) - 1;
#line 1506
    yylsp = (yyls + yysize) - 1;
#line 1511
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1512
      goto yyabortlab;
    }
  }
#line 1517
  goto yybackup;
  yybackup: 
#line 1528
  yyn = (int )yypact___1[yystate];
#line 1529
  if (yyn == -24) {
#line 1530
    goto yydefault;
  }
#line 1535
  if (svfchar == -2) {
    {
#line 1538
    svfchar = svflex(& svflval, & svflloc, priv_data->scanner);
    }
  }
#line 1541
  if (svfchar <= 0) {
#line 1543
    yytoken = 0;
#line 1543
    svfchar = yytoken;
  } else
#line 1548
  if ((unsigned int )svfchar <= 314U) {
#line 1548
    yytoken = (int )yytranslate___1[svfchar];
  } else {
#line 1548
    yytoken = 2;
  }
#line 1554
  yyn += yytoken;
#line 1555
  if (yyn < 0) {
#line 1556
    goto yydefault;
  } else
#line 1555
  if (145 < yyn) {
#line 1556
    goto yydefault;
  } else
#line 1555
  if ((int const   )yycheck___1[yyn] != (int const   )yytoken) {
#line 1556
    goto yydefault;
  }
#line 1557
  yyn = (int )yytable___1[yyn];
#line 1558
  if (yyn <= 0) {
#line 1560
    if (yyn == 0) {
#line 1561
      goto yyerrlab;
    } else
#line 1560
    if (yyn == -31) {
#line 1561
      goto yyerrlab;
    }
#line 1562
    yyn = - yyn;
#line 1563
    goto yyreduce;
  }
#line 1566
  if (yyn == 4) {
#line 1567
    goto yyacceptlab;
  }
#line 1571
  if (yyerrstatus) {
#line 1572
    yyerrstatus --;
  }
#line 1578
  if (svfchar != 0) {
#line 1579
    svfchar = -2;
  }
#line 1581
  yystate = yyn;
#line 1582
  yyvsp ++;
#line 1582
  *yyvsp = svflval;
#line 1583
  yylsp ++;
#line 1583
  *yylsp = svflloc;
#line 1584
  goto yynewstate;
  yydefault: 
#line 1591
  yyn = (int )yydefact___1[yystate];
#line 1592
  if (yyn == 0) {
#line 1593
    goto yyerrlab;
  }
#line 1594
  goto yyreduce;
  yyreduce: 
#line 1602
  yylen = (int )yyr2___1[yyn];
#line 1612
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1615
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1615
    if (yylen) {
#line 1615
      yyloc.first_line = ((yylsp - yylen) + 1)->first_line;
#line 1615
      yyloc.first_column = ((yylsp - yylen) + 1)->first_column;
#line 1615
      yyloc.last_line = ((yylsp - yylen) + yylen)->last_line;
#line 1615
      yyloc.last_column = ((yylsp - yylen) + yylen)->last_column;
    } else {
#line 1615
      yyloc.last_line = ((yylsp - yylen) + 0)->last_line;
#line 1615
      yyloc.first_line = yyloc.last_line;
#line 1615
      yyloc.last_column = ((yylsp - yylen) + 0)->last_column;
#line 1615
      yyloc.first_column = yyloc.last_column;
    }
#line 1615
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1619
  if (yyn == 5) {
#line 1619
    goto case_5;
  }
#line 105
  if (yyn == 6) {
#line 105 "svf_bison.y"
    goto case_6;
  }
#line 110
  if (yyn == 7) {
#line 110
    goto case_7;
  }
#line 115
  if (yyn == 8) {
#line 115
    goto case_8;
  }
#line 120
  if (yyn == 9) {
#line 120
    goto case_9;
  }
#line 129
  if (yyn == 10) {
#line 129
    goto case_10;
  }
#line 138
  if (yyn == 11) {
#line 138
    goto case_11;
  }
#line 145
  if (yyn == 12) {
#line 145
    goto case_12;
  }
#line 153
  if (yyn == 13) {
#line 153
    goto case_13;
  }
#line 168
  if (yyn == 14) {
#line 168
    goto case_14;
  }
#line 183
  if (yyn == 15) {
#line 183
    goto case_15;
  }
#line 198
  if (yyn == 16) {
#line 198
    goto case_16;
  }
#line 213
  if (yyn == 17) {
#line 213
    goto case_17;
  }
#line 221
  if (yyn == 18) {
#line 221
    goto case_18;
  }
#line 236
  if (yyn == 19) {
#line 236
    goto case_19;
  }
#line 251
  if (yyn == 20) {
#line 251
    goto case_20;
  }
#line 259
  if (yyn == 23) {
#line 259
    goto case_23;
  }
#line 272
  if (yyn == 24) {
#line 272
    goto case_24;
  }
#line 277
  if (yyn == 25) {
#line 277
    goto case_25;
  }
#line 282
  if (yyn == 26) {
#line 282
    goto case_26;
  }
#line 287
  if (yyn == 31) {
#line 287
    goto case_31;
  }
#line 298
  if (yyn == 32) {
#line 298
    goto case_32;
  }
#line 302
  if (yyn == 33) {
#line 302
    goto case_33;
  }
#line 310
  if (yyn == 34) {
#line 310
    goto case_34;
  }
#line 316
  if (yyn == 35) {
#line 316
    goto case_35;
  }
#line 324
  if (yyn == 37) {
#line 324
    goto case_37;
  }
#line 333
  if (yyn == 39) {
#line 333
    goto case_39;
  }
#line 341
  if (yyn == 40) {
#line 341
    goto case_40;
  }
#line 345
  if (yyn == 41) {
#line 345
    goto case_41;
  }
#line 349
  if (yyn == 58) {
#line 349
    goto case_58;
  }
#line 375
  if (yyn == 59) {
#line 375
    goto case_59;
  }
#line 1924 "svf_bison.c"
  goto switch_default;
  case_5: /* CIL Label */ 
  {
#line 101 "svf_bison.y"
  svf_endxr(priv_data, (enum generic_irdr_coding )0, (yyvsp + -1)->token);
  }
#line 103
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 106
  svf_endxr(priv_data, (enum generic_irdr_coding )1, (yyvsp + -1)->token);
  }
#line 108
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 111
  svf_frequency(chain, 0.0);
  }
#line 113
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 116
  svf_frequency(chain, (yyvsp + -2)->dvalue);
  }
#line 118
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 121
  p = & priv_data->parser_params.ths_params;
#line 123
  p->number = (yyvsp + -2)->dvalue;
#line 124
  svf_hxr((enum generic_irdr_coding )1, p);
#line 125
  svf_free_ths_params(p);
  }
#line 127
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 130
  p___0 = & priv_data->parser_params.ths_params;
#line 132
  p___0->number = (yyvsp + -2)->dvalue;
#line 133
  svf_hxr((enum generic_irdr_coding )0, p___0);
#line 134
  svf_free_ths_params(p___0);
  }
#line 136
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"PIOMAP not implemented\n");
#line 140
  svferror(& yyloc, priv_data, chain, "PIOMAP");
  }
#line 141
  goto yyerrorlab;
#line 143
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 146
  free((void *)(yyvsp + -1)->cvalue);
#line 147
  printf((char const   */* __restrict  */)"PIO not implemented\n");
#line 148
  svferror(& yyloc, priv_data, chain, "PIO");
  }
#line 149
  goto yyerrorlab;
#line 151
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 154
  rt = & priv_data->parser_params.runtest;
#line 156
  rt->run_state = (yyvsp + -4)->token;
#line 157
  rt->run_count = (uint32_t )(yyvsp + -3)->tdval.dvalue;
#line 158
  rt->run_clk = (yyvsp + -3)->tdval.token;
#line 159
  rt->end_state = (yyvsp + -1)->token;
#line 161
  tmp___0 = svf_runtest(chain, priv_data, rt);
  }
#line 161
  if (! tmp___0) {
    {
#line 162
    svferror(& yyloc, priv_data, chain, "RUNTEST");
    }
#line 163
    goto yyerrorlab;
  }
#line 166
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 169
  rt___0 = & priv_data->parser_params.runtest;
#line 171
  rt___0->run_state = (yyvsp + -3)->token;
#line 172
  rt___0->run_count = (uint32_t )0;
#line 173
  rt___0->run_clk = 0;
#line 174
  rt___0->end_state = (yyvsp + -1)->token;
#line 176
  tmp___1 = svf_runtest(chain, priv_data, rt___0);
  }
#line 176
  if (! tmp___1) {
    {
#line 177
    svferror(& yyloc, priv_data, chain, "RUNTEST");
    }
#line 178
    goto yyerrorlab;
  }
#line 181
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 184
  p___1 = & priv_data->parser_params.ths_params;
#line 187
  p___1->number = (yyvsp + -2)->dvalue;
#line 188
  result = svf_sxr(chain, priv_data, (enum generic_irdr_coding )1, p___1, & yyloc);
#line 189
  svf_free_ths_params(p___1);
  }
#line 191
  if (! result) {
    {
#line 192
    svferror(& yyloc, priv_data, chain, "SDR");
    }
#line 193
    goto yyerrorlab;
  }
#line 196
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 199
  p___2 = & priv_data->parser_params.ths_params;
#line 202
  p___2->number = (yyvsp + -2)->dvalue;
#line 203
  result___0 = svf_sxr(chain, priv_data, (enum generic_irdr_coding )0, p___2, & yyloc);
#line 204
  svf_free_ths_params(p___2);
  }
#line 206
  if (! result___0) {
    {
#line 207
    svferror(& yyloc, priv_data, chain, "SIR");
    }
#line 208
    goto yyerrorlab;
  }
#line 211
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 214
  tmp___2 = svf_state(chain, priv_data, & priv_data->parser_params.path_states, (yyvsp + -1)->token);
  }
#line 214
  if (! tmp___2) {
    {
#line 215
    svferror(& yyloc, priv_data, chain, "STATE");
    }
#line 216
    goto yyerrorlab;
  }
#line 219
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 222
  p___3 = & priv_data->parser_params.ths_params;
#line 225
  p___3->number = (yyvsp + -2)->dvalue;
#line 226
  result___1 = svf_txr((enum generic_irdr_coding )1, p___3);
#line 227
  svf_free_ths_params(p___3);
  }
#line 229
  if (! result___1) {
    {
#line 230
    svferror(& yyloc, priv_data, chain, "TDR");
    }
#line 231
    goto yyerrorlab;
  }
#line 234
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 237
  p___4 = & priv_data->parser_params.ths_params;
#line 240
  p___4->number = (yyvsp + -2)->dvalue;
#line 241
  result___2 = svf_txr((enum generic_irdr_coding )0, p___4);
#line 242
  svf_free_ths_params(p___4);
  }
#line 244
  if (! result___2) {
    {
#line 245
    svferror(& yyloc, priv_data, chain, "TIR");
    }
#line 246
    goto yyerrorlab;
  }
#line 249
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 252
  tmp___3 = svf_trst(chain, priv_data, (yyvsp + -1)->token);
  }
#line 252
  if (! tmp___3) {
    {
#line 253
    svferror(& yyloc, priv_data, chain, "TRST");
    }
#line 254
    goto yyerrorlab;
  }
#line 257
  goto switch_break;
  case_23: /* CIL Label */ 
#line 268
  priv_data->parser_params.ths_params.tdi = (yyvsp + 0)->cvalue;
#line 270
  goto switch_break;
  case_24: /* CIL Label */ 
#line 273
  priv_data->parser_params.ths_params.tdo = (yyvsp + 0)->cvalue;
#line 275
  goto switch_break;
  case_25: /* CIL Label */ 
#line 278
  priv_data->parser_params.ths_params.mask = (yyvsp + 0)->cvalue;
#line 280
  goto switch_break;
  case_26: /* CIL Label */ 
#line 283
  priv_data->parser_params.ths_params.smask = (yyvsp + 0)->cvalue;
#line 285
  goto switch_break;
  case_31: /* CIL Label */ 
#line 295
  yyval.token = 0;
#line 296
  goto switch_break;
  case_32: /* CIL Label */ 
#line 298
  yyval.token = (yyvsp + 0)->token;
#line 300
  goto switch_break;
  case_33: /* CIL Label */ 
#line 305
  yyval.tdval.token = (yyvsp + 0)->token;
#line 306
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 308
  goto switch_break;
  case_34: /* CIL Label */ 
#line 311
  yyval.tdval.token = (yyvsp + 0)->token;
#line 312
  yyval.tdval.dvalue = (yyvsp + -1)->dvalue;
#line 314
  goto switch_break;
  case_35: /* CIL Label */ 
#line 319
  priv_data->parser_params.runtest.min_time = 0.0;
#line 320
  priv_data->parser_params.runtest.max_time = 0.0;
#line 322
  goto switch_break;
  case_37: /* CIL Label */ 
#line 329
  priv_data->parser_params.runtest.min_time = (yyvsp + -2)->dvalue;
#line 331
  goto switch_break;
  case_39: /* CIL Label */ 
#line 337
  priv_data->parser_params.runtest.max_time = (yyvsp + -1)->dvalue;
#line 339
  goto switch_break;
  case_40: /* CIL Label */ 
#line 342
  yyval.token = 0;
#line 343
  goto switch_break;
  case_41: /* CIL Label */ 
#line 345
  yyval.token = (yyvsp + 0)->token;
#line 347
  goto switch_break;
  case_58: /* CIL Label */ 
#line 371
  priv_data->parser_params.path_states.num_states = 0;
#line 373
  goto switch_break;
  case_59: /* CIL Label */ 
#line 376
  ps = & priv_data->parser_params.path_states;
#line 378
  if (ps->num_states < 64) {
#line 379
    ps->states[ps->num_states] = (yyvsp + 0)->token;
#line 380
    (ps->num_states) ++;
  } else {
    {
#line 382
    printf((char const   */* __restrict  */)"Error %s: maximum number of %d path states reached.\n",
           "svf", 64);
    }
  }
#line 385
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1924 "svf_bison.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1928
  yyvsp -= yylen;
#line 1928
  yyssp -= yylen;
#line 1928
  yylsp -= yylen;
#line 1929
  yylen = 0;
#line 1932
  yyvsp ++;
#line 1932
  *yyvsp = yyval;
#line 1933
  yylsp ++;
#line 1933
  *yylsp = yyloc;
#line 1939
  yyn = (int )yyr1___1[yyn];
#line 1941
  yystate = (int )((int const   )yypgoto___1[yyn - 63] + (int const   )*yyssp);
#line 1942
  if (0 <= yystate) {
#line 1942
    if (yystate <= 145) {
#line 1942
      if ((int const   )yycheck___1[yystate] == (int const   )*yyssp) {
#line 1943
        yystate = (int )yytable___1[yystate];
      } else {
#line 1945
        yystate = (int )yydefgoto___1[yyn - 63];
      }
    } else {
#line 1945
      yystate = (int )yydefgoto___1[yyn - 63];
    }
  } else {
#line 1945
    yystate = (int )yydefgoto___1[yyn - 63];
  }
#line 1947
  goto yynewstate;
  yyerrlab: 
#line 1955
  if (! yyerrstatus) {
    {
#line 1957
    svfnerrs ++;
#line 1962
    tmp___4 = yysyntax_error((char *)0, yystate, svfchar);
#line 1962
    yysize___0 = tmp___4;
    }
#line 1963
    if (yymsg_alloc < yysize___0) {
#line 1963
      if (yymsg_alloc < 0xffffffffffffffffUL) {
#line 1965
        yyalloc = 2UL * yysize___0;
#line 1966
        if (yysize___0 <= yyalloc) {
#line 1966
          if (! (yyalloc <= 0xffffffffffffffffUL)) {
#line 1967
            yyalloc = 0xffffffffffffffffUL;
          }
        } else {
#line 1967
          yyalloc = 0xffffffffffffffffUL;
        }
#line 1968
        if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
          {
#line 1969
          free((void *)yymsg);
          }
        }
        {
#line 1970
        tmp___5 = malloc(yyalloc);
#line 1970
        yymsg = (char *)tmp___5;
        }
#line 1971
        if (yymsg) {
#line 1972
          yymsg_alloc = yyalloc;
        } else {
#line 1975
          yymsg = yymsgbuf;
#line 1976
          yymsg_alloc = sizeof(yymsgbuf);
        }
      }
    }
#line 1980
    if (0UL < yysize___0) {
#line 1980
      if (yysize___0 <= yymsg_alloc) {
        {
#line 1982
        yysyntax_error(yymsg, yystate, svfchar);
#line 1983
        svferror(& svflloc, priv_data, chain, (char const   *)yymsg);
        }
      } else {
#line 1980
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1987
      svferror(& svflloc, priv_data, chain, "syntax error");
      }
#line 1988
      if (yysize___0 != 0UL) {
#line 1989
        goto yyexhaustedlab;
      }
    }
  }
#line 1995
  yyerror_range[0] = svflloc;
#line 1997
  if (yyerrstatus == 3) {
#line 2002
    if (svfchar <= 0) {
#line 2005
      if (svfchar == 0) {
#line 2006
        goto yyabortlab;
      }
    } else {
      {
#line 2010
      yydestruct___1("Error: discarding", yytoken, & svflval, & svflloc, priv_data,
                     chain);
#line 2012
      svfchar = -2;
      }
    }
  }
#line 2018
  goto yyerrlab1;
  yyerrorlab: 
#line 2032
  yyerror_range[0] = *(yylsp + (1 - yylen));
#line 2035
  yyvsp -= yylen;
#line 2035
  yyssp -= yylen;
#line 2035
  yylsp -= yylen;
#line 2036
  yylen = 0;
#line 2038
  yystate = (int )*yyssp;
#line 2039
  goto yyerrlab1;
  yyerrlab1: 
#line 2046
  yyerrstatus = 3;
  {
#line 2048
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2050
    yyn = (int )yypact___1[yystate];
#line 2051
    if (yyn != -24) {
#line 2053
      yyn ++;
#line 2054
      if (0 <= yyn) {
#line 2054
        if (yyn <= 145) {
#line 2054
          if ((int const   )yycheck___1[yyn] == 1) {
#line 2056
            yyn = (int )yytable___1[yyn];
#line 2057
            if (0 < yyn) {
#line 2058
              goto while_break___3;
            }
          }
        }
      }
    }
#line 2063
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2064
      goto yyabortlab;
    }
    {
#line 2066
    yyerror_range[0] = *yylsp;
#line 2067
    yydestruct___1("Error: popping", (int )yystos___1[yystate], yyvsp, yylsp, priv_data,
                   chain);
#line 2069
    yyvsp --;
#line 2069
    yyssp --;
#line 2069
    yylsp --;
#line 2070
    yystate = (int )*yyssp;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2074
  if (yyn == 4) {
#line 2075
    goto yyacceptlab;
  }
#line 2077
  yyvsp ++;
#line 2077
  *yyvsp = svflval;
#line 2079
  yyerror_range[1] = svflloc;
  {
#line 2082
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2082
    yyloc.first_line = ((yyerror_range - 1) + 1)->first_line;
#line 2082
    yyloc.first_column = ((yyerror_range - 1) + 1)->first_column;
#line 2082
    yyloc.last_line = ((yyerror_range - 1) + 2)->last_line;
#line 2082
    yyloc.last_column = ((yyerror_range - 1) + 2)->last_column;
#line 2082
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2083
  yylsp ++;
#line 2083
  *yylsp = yyloc;
#line 2088
  yystate = yyn;
#line 2089
  goto yynewstate;
  yyacceptlab: 
#line 2096
  yyresult = 0;
#line 2097
  goto yyreturn;
  yyabortlab: 
#line 2103
  yyresult = 1;
#line 2104
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2111
  svferror(& svflloc, priv_data, chain, "memory exhausted");
#line 2112
  yyresult = 2;
  }
  yyreturn: 
#line 2117
  if (svfchar != 0) {
#line 2117
    if (svfchar != -2) {
      {
#line 2118
      yydestruct___1("Cleanup: discarding lookahead", yytoken, & svflval, & svflloc,
                     priv_data, chain);
      }
    }
  }
#line 2122
  yyvsp -= yylen;
#line 2122
  yyssp -= yylen;
#line 2122
  yylsp -= yylen;
  {
#line 2124
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2124
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2124
      goto while_break___5;
    }
    {
#line 2126
    yydestruct___1("Cleanup: popping", (int )yystos___1[*yyssp], yyvsp, yylsp, priv_data,
                   chain);
#line 2128
    yyvsp --;
#line 2128
    yyssp --;
#line 2128
    yylsp --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 2131
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2132
    free((void *)yyss);
    }
  }
#line 2135
  if ((unsigned long )yymsg != (unsigned long )(yymsgbuf)) {
    {
#line 2136
    free((void *)yymsg);
    }
  }
#line 2139
  return (yyresult);
}
}
#line 408 "svf_bison.y"
void svferror(YYLTYPE *locp , parser_priv_t *priv_data , chain_t *chain , char const   *error_string ) 
{ 


  {
  {
#line 411
  printf((char const   */* __restrict  */)"Error occured for SVF command %s.\n", error_string);
  }
#line 412
  return;
}
}
#line 415 "svf_bison.y"
static void svf_free_ths_params(struct ths_params *params ) 
{ 


  {
#line 418
  params->number = 0.0;
#line 420
  if (params->tdi) {
    {
#line 421
    free((void *)params->tdi);
#line 422
    params->tdi = (char *)((void *)0);
    }
  }
#line 424
  if (params->tdo) {
    {
#line 425
    free((void *)params->tdo);
#line 426
    params->tdo = (char *)((void *)0);
    }
  }
#line 428
  if (params->mask) {
    {
#line 429
    free((void *)params->mask);
#line 430
    params->mask = (char *)((void *)0);
    }
  }
#line 432
  if (params->smask) {
    {
#line 433
    free((void *)params->smask);
#line 434
    params->smask = (char *)((void *)0);
    }
  }
#line 436
  return;
}
}
#line 439 "svf_bison.y"
int svf_bison_init(parser_priv_t *priv_data , FILE *f , int num_lines , int print_progress ) 
{ 
  struct svf_parser_params params ;
  void *tmp ;

  {
  {
#line 442
  params.ths_params.number = 0.0;
#line 442
  params.ths_params.tdi = (char *)((void *)0);
#line 442
  params.ths_params.tdo = (char *)((void *)0);
#line 442
  params.ths_params.mask = (char *)((void *)0);
#line 442
  params.ths_params.smask = (char *)((void *)0);
#line 442
  params.path_states.states[0] = 0;
#line 442
  params.path_states.states[1] = 0;
#line 442
  params.path_states.states[2] = 0;
#line 442
  params.path_states.states[3] = 0;
#line 442
  params.path_states.states[4] = 0;
#line 442
  params.path_states.states[5] = 0;
#line 442
  params.path_states.states[6] = 0;
#line 442
  params.path_states.states[7] = 0;
#line 442
  params.path_states.states[8] = 0;
#line 442
  params.path_states.states[9] = 0;
#line 442
  params.path_states.states[10] = 0;
#line 442
  params.path_states.states[11] = 0;
#line 442
  params.path_states.states[12] = 0;
#line 442
  params.path_states.states[13] = 0;
#line 442
  params.path_states.states[14] = 0;
#line 442
  params.path_states.states[15] = 0;
#line 442
  params.path_states.states[16] = 0;
#line 442
  params.path_states.states[17] = 0;
#line 442
  params.path_states.states[18] = 0;
#line 442
  params.path_states.states[19] = 0;
#line 442
  params.path_states.states[20] = 0;
#line 442
  params.path_states.states[21] = 0;
#line 442
  params.path_states.states[22] = 0;
#line 442
  params.path_states.states[23] = 0;
#line 442
  params.path_states.states[24] = 0;
#line 442
  params.path_states.states[25] = 0;
#line 442
  params.path_states.states[26] = 0;
#line 442
  params.path_states.states[27] = 0;
#line 442
  params.path_states.states[28] = 0;
#line 442
  params.path_states.states[29] = 0;
#line 442
  params.path_states.states[30] = 0;
#line 442
  params.path_states.states[31] = 0;
#line 442
  params.path_states.states[32] = 0;
#line 442
  params.path_states.states[33] = 0;
#line 442
  params.path_states.states[34] = 0;
#line 442
  params.path_states.states[35] = 0;
#line 442
  params.path_states.states[36] = 0;
#line 442
  params.path_states.states[37] = 0;
#line 442
  params.path_states.states[38] = 0;
#line 442
  params.path_states.states[39] = 0;
#line 442
  params.path_states.states[40] = 0;
#line 442
  params.path_states.states[41] = 0;
#line 442
  params.path_states.states[42] = 0;
#line 442
  params.path_states.states[43] = 0;
#line 442
  params.path_states.states[44] = 0;
#line 442
  params.path_states.states[45] = 0;
#line 442
  params.path_states.states[46] = 0;
#line 442
  params.path_states.states[47] = 0;
#line 442
  params.path_states.states[48] = 0;
#line 442
  params.path_states.states[49] = 0;
#line 442
  params.path_states.states[50] = 0;
#line 442
  params.path_states.states[51] = 0;
#line 442
  params.path_states.states[52] = 0;
#line 442
  params.path_states.states[53] = 0;
#line 442
  params.path_states.states[54] = 0;
#line 442
  params.path_states.states[55] = 0;
#line 442
  params.path_states.states[56] = 0;
#line 442
  params.path_states.states[57] = 0;
#line 442
  params.path_states.states[58] = 0;
#line 442
  params.path_states.states[59] = 0;
#line 442
  params.path_states.states[60] = 0;
#line 442
  params.path_states.states[61] = 0;
#line 442
  params.path_states.states[62] = 0;
#line 442
  params.path_states.states[63] = 0;
#line 442
  params.path_states.num_states = 0;
#line 442
  params.runtest.run_state = 0;
#line 442
  params.runtest.run_count = (uint32_t )0.0;
#line 442
  params.runtest.run_clk = 0;
#line 442
  params.runtest.min_time = (double )0;
#line 442
  params.runtest.max_time = (double )0;
#line 442
  params.runtest.end_state = 0;
#line 448
  priv_data->parser_params = params;
#line 450
  tmp = svf_flex_init(f, num_lines, print_progress);
#line 450
  priv_data->scanner = tmp;
  }
#line 450
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 451
    return (0);
  } else {
#line 453
    return (1);
  }
}
}
#line 457 "svf_bison.y"
void svf_bison_deinit(parser_priv_t *priv_data ) 
{ 


  {
  {
#line 460
  svf_flex_deinit(priv_data->scanner);
  }
#line 461
  return;
}
}
#line 64 "../../include/part.h"
void part_set_signal(part_t *p , signal_t *s , int out , int val ) ;
#line 65
int part_get_signal(part_t *p , signal_t *s ) ;
#line 56 "../../include/chain.h"
void chain_shift_instructions(chain_t *chain ) ;
#line 58
void chain_shift_data_registers(chain_t *chain , int capture_output ) ;
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  zefant_xs3_bus ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.h"
int generic_bus_attach_sig(part_t *part , signal_t **sig , char *id ) ;
#line 32
void generic_bus_free(bus_t *bus___0 ) ;
#line 34
void generic_bus_prepare_extest(bus_t *bus___0 ) ;
#line 35
uint32_t generic_bus_read(bus_t *bus___0 , uint32_t adr ) ;
#line 154 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static bus_t *zefant_xs3_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  int failed ;
  component_t *comp ;
  int idx ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  int tmp___128 ;

  {
  {
#line 159
  failed = 0;
#line 163
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 163
  bus___0 = (bus_t *)tmp;
  }
#line 164
  if (! bus___0) {
#line 165
    return ((bus_t *)((void *)0));
  }
  {
#line 167
  bus___0->driver = driver;
#line 168
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t ));
  }
#line 169
  if (! bus___0->params) {
    {
#line 170
    free((void *)bus___0);
    }
#line 171
    return ((bus_t *)((void *)0));
  }
  {
#line 174
  bus___0->chain = chain;
#line 175
  part = *((chain->parts)->parts + chain->active_part);
#line 175
  bus___0->part = part;
#line 180
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 181
  comp->ctype = (ctype_t )1;
#line 182
  comp->cname = (char *)"FLASH";
#line 184
  tmp___0 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO_V9");
#line 184
  failed |= tmp___0;
#line 185
  tmp___1 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO_U10");
#line 185
  failed |= tmp___1;
#line 186
  tmp___2 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO_V10");
#line 186
  failed |= tmp___2;
#line 187
  tmp___3 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO_W10");
#line 187
  failed |= tmp___3;
#line 188
  tmp___4 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO_Y10");
#line 188
  failed |= tmp___4;
#line 189
  tmp___5 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO_W8");
#line 189
  failed |= tmp___5;
#line 190
  tmp___6 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO_W9");
#line 190
  failed |= tmp___6;
#line 191
  tmp___7 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO_V8");
#line 191
  failed |= tmp___7;
#line 192
  tmp___8 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO_V6");
#line 192
  failed |= tmp___8;
#line 193
  tmp___9 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO_AA8");
#line 193
  failed |= tmp___9;
#line 194
  tmp___10 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO_AB8");
#line 194
  failed |= tmp___10;
#line 195
  tmp___11 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO_U7");
#line 195
  failed |= tmp___11;
#line 196
  tmp___12 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO_V7");
#line 196
  failed |= tmp___12;
#line 197
  tmp___13 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO_U6");
#line 197
  failed |= tmp___13;
#line 198
  tmp___14 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO_Y6");
#line 198
  failed |= tmp___14;
#line 199
  tmp___15 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO_AB11");
#line 199
  failed |= tmp___15;
#line 200
  tmp___16 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO_AB10");
#line 200
  failed |= tmp___16;
#line 201
  tmp___17 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO_AA10");
#line 201
  failed |= tmp___17;
#line 202
  tmp___18 = generic_bus_attach_sig(part, & comp->a[18], (char *)"IO_W6");
#line 202
  failed |= tmp___18;
#line 203
  tmp___19 = generic_bus_attach_sig(part, & comp->a[19], (char *)"IO_AA6");
#line 203
  failed |= tmp___19;
#line 204
  tmp___20 = generic_bus_attach_sig(part, & comp->a[20], (char *)"IO_U11");
#line 204
  failed |= tmp___20;
#line 205
  tmp___21 = generic_bus_attach_sig(part, & comp->a[21], (char *)"IO_Y13");
#line 205
  failed |= tmp___21;
#line 206
  tmp___22 = generic_bus_attach_sig(part, & comp->a[22], (char *)"IO_AB13");
#line 206
  failed |= tmp___22;
#line 207
  tmp___23 = generic_bus_attach_sig(part, & comp->a[23], (char *)"IO_U13");
#line 207
  failed |= tmp___23;
#line 208
  tmp___24 = generic_bus_attach_sig(part, & comp->a[24], (char *)"IO_AA13");
#line 208
  failed |= tmp___24;
#line 210
  tmp___25 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO_AA14");
#line 210
  failed |= tmp___25;
#line 211
  tmp___26 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO_AB14");
#line 211
  failed |= tmp___26;
#line 212
  tmp___27 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO_U12");
#line 212
  failed |= tmp___27;
#line 213
  tmp___28 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO_V12");
#line 213
  failed |= tmp___28;
#line 214
  tmp___29 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO_W11");
#line 214
  failed |= tmp___29;
#line 215
  tmp___30 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO_V11");
#line 215
  failed |= tmp___30;
#line 216
  tmp___31 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO_AB9");
#line 216
  failed |= tmp___31;
#line 217
  tmp___32 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO_AA9");
#line 217
  failed |= tmp___32;
#line 218
  tmp___33 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO_U16");
#line 218
  failed |= tmp___33;
#line 219
  tmp___34 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO_AB15");
#line 219
  failed |= tmp___34;
#line 220
  tmp___35 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO_AA15");
#line 220
  failed |= tmp___35;
#line 221
  tmp___36 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO_W14");
#line 221
  failed |= tmp___36;
#line 222
  tmp___37 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO_V14");
#line 222
  failed |= tmp___37;
#line 223
  tmp___38 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO_U14");
#line 223
  failed |= tmp___38;
#line 224
  tmp___39 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO_W13");
#line 224
  failed |= tmp___39;
#line 225
  tmp___40 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO_V13");
#line 225
  failed |= tmp___40;
#line 227
  tmp___41 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO_Y17");
#line 227
  failed |= tmp___41;
#line 228
  tmp___42 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO_AA17");
#line 228
  failed |= tmp___42;
#line 229
  tmp___43 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_U17");
#line 229
  failed |= tmp___43;
#line 230
  comp->nlb = (signal_t *)((void *)0);
#line 231
  comp->nub = (signal_t *)((void *)0);
#line 233
  tmp___44 = generic_bus_attach_sig(part, & comp->nrp, (char *)"IO_V16");
#line 233
  failed |= tmp___44;
#line 234
  tmp___45 = generic_bus_attach_sig(part, & comp->nbyte, (char *)"IO_Y16");
#line 234
  failed |= tmp___45;
#line 235
  tmp___46 = generic_bus_attach_sig(part, & comp->sts, (char *)"IO_W16");
#line 235
  failed |= tmp___46;
#line 237
  comp->si = (signal_t *)((void *)0);
#line 238
  comp->so = (signal_t *)((void *)0);
#line 239
  comp->sck = (signal_t *)((void *)0);
#line 244
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 245
  comp->ctype = (ctype_t )0;
#line 246
  comp->cname = (char *)"RAM0";
#line 248
  tmp___47 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO_AA4");
#line 248
  failed |= tmp___47;
#line 249
  tmp___48 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO_AB4");
#line 249
  failed |= tmp___48;
#line 250
  tmp___49 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO_W5");
#line 250
  failed |= tmp___49;
#line 251
  tmp___50 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO_Y3");
#line 251
  failed |= tmp___50;
#line 252
  tmp___51 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO_Y1");
#line 252
  failed |= tmp___51;
#line 253
  tmp___52 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO_M1");
#line 253
  failed |= tmp___52;
#line 254
  tmp___53 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO_N2");
#line 254
  failed |= tmp___53;
#line 255
  tmp___54 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO_L2");
#line 255
  failed |= tmp___54;
#line 256
  tmp___55 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO_L1");
#line 256
  failed |= tmp___55;
#line 257
  tmp___56 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO_K1");
#line 257
  failed |= tmp___56;
#line 258
  tmp___57 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO_K3");
#line 258
  failed |= tmp___57;
#line 259
  tmp___58 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO_L6");
#line 259
  failed |= tmp___58;
#line 260
  tmp___59 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO_L4");
#line 260
  failed |= tmp___59;
#line 261
  tmp___60 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO_L3");
#line 261
  failed |= tmp___60;
#line 262
  tmp___61 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO_K4");
#line 262
  failed |= tmp___61;
#line 263
  tmp___62 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO_AB5");
#line 263
  failed |= tmp___62;
#line 264
  tmp___63 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO_AA5");
#line 264
  failed |= tmp___63;
#line 265
  tmp___64 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO_Y5");
#line 265
  failed |= tmp___64;
#line 266
  comp->a[18] = (signal_t *)((void *)0);
#line 267
  comp->a[19] = (signal_t *)((void *)0);
#line 268
  comp->a[20] = (signal_t *)((void *)0);
#line 269
  comp->a[21] = (signal_t *)((void *)0);
#line 270
  comp->a[22] = (signal_t *)((void *)0);
#line 271
  comp->a[23] = (signal_t *)((void *)0);
#line 272
  comp->a[24] = (signal_t *)((void *)0);
#line 274
  tmp___65 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO_W1");
#line 274
  failed |= tmp___65;
#line 275
  tmp___66 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO_V5");
#line 275
  failed |= tmp___66;
#line 276
  tmp___67 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO_V3");
#line 276
  failed |= tmp___67;
#line 277
  tmp___68 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO_V1");
#line 277
  failed |= tmp___68;
#line 278
  tmp___69 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO_N1");
#line 278
  failed |= tmp___69;
#line 279
  tmp___70 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO_N3");
#line 279
  failed |= tmp___70;
#line 280
  tmp___71 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO_M2");
#line 280
  failed |= tmp___71;
#line 281
  tmp___72 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO_M5");
#line 281
  failed |= tmp___72;
#line 282
  tmp___73 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO_M4");
#line 282
  failed |= tmp___73;
#line 283
  tmp___74 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO_M6");
#line 283
  failed |= tmp___74;
#line 284
  tmp___75 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO_L5");
#line 284
  failed |= tmp___75;
#line 285
  tmp___76 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO_N4");
#line 285
  failed |= tmp___76;
#line 286
  tmp___77 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO_T6");
#line 286
  failed |= tmp___77;
#line 287
  tmp___78 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO_V2");
#line 287
  failed |= tmp___78;
#line 288
  tmp___79 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO_V4");
#line 288
  failed |= tmp___79;
#line 289
  tmp___80 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO_U5");
#line 289
  failed |= tmp___80;
#line 291
  tmp___81 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_W3");
#line 291
  failed |= tmp___81;
#line 292
  tmp___82 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO_Y2");
#line 292
  failed |= tmp___82;
#line 293
  tmp___83 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO_M3");
#line 293
  failed |= tmp___83;
#line 294
  tmp___84 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO_W2");
#line 294
  failed |= tmp___84;
#line 295
  tmp___85 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO_W4");
#line 295
  failed |= tmp___85;
#line 296
  comp->nrp = (signal_t *)((void *)0);
#line 297
  comp->nbyte = (signal_t *)((void *)0);
#line 298
  comp->sts = (signal_t *)((void *)0);
#line 300
  comp->si = (signal_t *)((void *)0);
#line 301
  comp->so = (signal_t *)((void *)0);
#line 302
  comp->sck = (signal_t *)((void *)0);
#line 307
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 308
  comp->ctype = (ctype_t )0;
#line 309
  comp->cname = (char *)"RAM1";
#line 311
  tmp___86 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO_H5");
#line 311
  failed |= tmp___86;
#line 312
  tmp___87 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO_F5");
#line 312
  failed |= tmp___87;
#line 313
  tmp___88 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO_F2");
#line 313
  failed |= tmp___88;
#line 314
  tmp___89 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO_D1");
#line 314
  failed |= tmp___89;
#line 315
  tmp___90 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO_E1");
#line 315
  failed |= tmp___90;
#line 316
  tmp___91 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO_F10");
#line 316
  failed |= tmp___91;
#line 317
  tmp___92 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO_C7");
#line 317
  failed |= tmp___92;
#line 318
  tmp___93 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO_C10");
#line 318
  failed |= tmp___93;
#line 319
  tmp___94 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO_A10");
#line 319
  failed |= tmp___94;
#line 320
  tmp___95 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO_B10");
#line 320
  failed |= tmp___95;
#line 321
  tmp___96 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO_F11");
#line 321
  failed |= tmp___96;
#line 322
  tmp___97 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO_A9");
#line 322
  failed |= tmp___97;
#line 323
  tmp___98 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO_B9");
#line 323
  failed |= tmp___98;
#line 324
  tmp___99 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO_B8");
#line 324
  failed |= tmp___99;
#line 325
  tmp___100 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO_F9");
#line 325
  failed |= tmp___100;
#line 326
  tmp___101 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO_F4");
#line 326
  failed |= tmp___101;
#line 327
  tmp___102 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO_G6");
#line 327
  failed |= tmp___102;
#line 328
  tmp___103 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO_G5");
#line 328
  failed |= tmp___103;
#line 329
  comp->a[18] = (signal_t *)((void *)0);
#line 330
  comp->a[19] = (signal_t *)((void *)0);
#line 331
  comp->a[20] = (signal_t *)((void *)0);
#line 332
  comp->a[21] = (signal_t *)((void *)0);
#line 333
  comp->a[22] = (signal_t *)((void *)0);
#line 334
  comp->a[23] = (signal_t *)((void *)0);
#line 335
  comp->a[24] = (signal_t *)((void *)0);
#line 337
  tmp___104 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO_C1");
#line 337
  failed |= tmp___104;
#line 338
  tmp___105 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO_E2");
#line 338
  failed |= tmp___105;
#line 339
  tmp___106 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO_C2");
#line 339
  failed |= tmp___106;
#line 340
  tmp___107 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO_C3");
#line 340
  failed |= tmp___107;
#line 341
  tmp___108 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO_B5");
#line 341
  failed |= tmp___108;
#line 342
  tmp___109 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO_A5");
#line 342
  failed |= tmp___109;
#line 343
  tmp___110 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO_B6");
#line 343
  failed |= tmp___110;
#line 344
  tmp___111 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO_D7");
#line 344
  failed |= tmp___111;
#line 345
  tmp___112 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO_D9");
#line 345
  failed |= tmp___112;
#line 346
  tmp___113 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO_E9");
#line 346
  failed |= tmp___113;
#line 347
  tmp___114 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO_F7");
#line 347
  failed |= tmp___114;
#line 348
  tmp___115 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO_E7");
#line 348
  failed |= tmp___115;
#line 349
  tmp___116 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO_D5");
#line 349
  failed |= tmp___116;
#line 350
  tmp___117 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO_C4");
#line 350
  failed |= tmp___117;
#line 351
  tmp___118 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO_D3");
#line 351
  failed |= tmp___118;
#line 352
  tmp___119 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO_D4");
#line 352
  failed |= tmp___119;
#line 354
  tmp___120 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_D2");
#line 354
  failed |= tmp___120;
#line 355
  tmp___121 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO_F3");
#line 355
  failed |= tmp___121;
#line 356
  tmp___122 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO_E10");
#line 356
  failed |= tmp___122;
#line 357
  tmp___123 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO_E4");
#line 357
  failed |= tmp___123;
#line 358
  tmp___124 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO_E3");
#line 358
  failed |= tmp___124;
#line 359
  comp->nrp = (signal_t *)((void *)0);
#line 360
  comp->nbyte = (signal_t *)((void *)0);
#line 361
  comp->sts = (signal_t *)((void *)0);
#line 363
  comp->si = (signal_t *)((void *)0);
#line 364
  comp->so = (signal_t *)((void *)0);
#line 365
  comp->sck = (signal_t *)((void *)0);
#line 370
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 371
  comp->ctype = (ctype_t )2;
#line 372
  comp->cname = (char *)"EEPROM";
#line 374
  tmp___125 = generic_bus_attach_sig(part, & comp->si, (char *)"IO_H19");
#line 374
  failed |= tmp___125;
#line 375
  tmp___126 = generic_bus_attach_sig(part, & comp->so, (char *)"IO_J21");
#line 375
  failed |= tmp___126;
#line 376
  tmp___127 = generic_bus_attach_sig(part, & comp->sck, (char *)"IO_H21");
#line 376
  failed |= tmp___127;
#line 377
  tmp___128 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO_K22");
#line 377
  failed |= tmp___128;
#line 379
  idx = 0;
  }
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (idx < 25)) {
#line 379
      goto while_break;
    }
#line 380
    comp->a[idx] = (signal_t *)((void *)0);
#line 379
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  idx = 0;
  {
#line 381
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 381
    if (! (idx < 16)) {
#line 381
      goto while_break___0;
    }
#line 382
    comp->d[idx] = (signal_t *)((void *)0);
#line 381
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 383
  comp->noe = (signal_t *)((void *)0);
#line 384
  comp->nwe = (signal_t *)((void *)0);
#line 385
  comp->nlb = (signal_t *)((void *)0);
#line 386
  comp->nub = (signal_t *)((void *)0);
#line 387
  comp->nrp = (signal_t *)((void *)0);
#line 388
  comp->nbyte = (signal_t *)((void *)0);
#line 389
  comp->sts = (signal_t *)((void *)0);
#line 395
  ((bus_params_t *)bus___0->params)->eeprom_status = ((bus_params_t *)bus___0->params)->eeprom;
#line 396
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 397
  comp->ctype = (ctype_t )3;
#line 398
  comp->cname = (char *)"EEPROM Status";
#line 401
  if (failed) {
    {
#line 402
    free(bus___0->params);
#line 403
    free((void *)bus___0);
    }
#line 404
    return ((bus_t *)((void *)0));
  }
#line 407
  return (bus___0);
}
}
#line 414 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 419
  i = 0;
  {
#line 419
  while (1) {
    while_continue: /* CIL Label */ ;
#line 419
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 419
      goto while_break;
    }
#line 420
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 421
      goto while_break;
    }
#line 419
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 422
  tmp = gettext("Simple Solutions Zefant-XS3 Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 422
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 423
  return;
}
}
#line 425 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void setup_address(bus_t *bus___0 , uint32_t a , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 429
  p = bus___0->part;
#line 432
  ((bus_params_t *)bus___0->params)->last_addr = a;
  {
#line 435
  if ((unsigned int )comp->ctype == 1U) {
#line 435
    goto case_1;
  }
#line 440
  if ((unsigned int )comp->ctype == 0U) {
#line 440
    goto case_0;
  }
#line 447
  if ((unsigned int )comp->ctype == 3U) {
#line 447
    goto case_3;
  }
#line 447
  if ((unsigned int )comp->ctype == 2U) {
#line 447
    goto case_3;
  }
#line 450
  goto switch_default;
  case_1: /* CIL Label */ 
#line 436
  addr_width = 25;
#line 439
  goto switch_break;
  case_0: /* CIL Label */ 
#line 441
  addr_width = 18;
#line 444
  a >>= 1;
#line 445
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 448
  addr_width = 16;
#line 449
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 451
  addr_width = 0;
#line 452
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 455
  i = 0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! (i < addr_width)) {
#line 455
      goto while_break;
    }
    {
#line 456
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 455
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  return;
}
}
#line 459 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static int detect_data_width(component_t *comp ) 
{ 
  int width ;

  {
  {
#line 465
  if ((unsigned int )comp->ctype == 0U) {
#line 465
    goto case_0;
  }
#line 468
  if ((unsigned int )comp->ctype == 1U) {
#line 468
    goto case_1;
  }
#line 472
  if ((unsigned int )comp->ctype == 3U) {
#line 472
    goto case_3;
  }
#line 472
  if ((unsigned int )comp->ctype == 2U) {
#line 472
    goto case_3;
  }
#line 475
  goto switch_default;
  case_0: /* CIL Label */ 
#line 466
  width = 16;
#line 467
  goto switch_break;
  case_1: /* CIL Label */ 
#line 469
  width = 16;
#line 470
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 473
  width = 8;
#line 474
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 476
  width = 0;
#line 477
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 480
  return (width);
}
}
#line 483 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void set_data_in(bus_t *bus___0 , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 487
  p = bus___0->part;
#line 490
  width = detect_data_width(comp);
#line 492
  i = 0;
  }
  {
#line 492
  while (1) {
    while_continue: /* CIL Label */ ;
#line 492
    if (! (i < width)) {
#line 492
      goto while_break;
    }
    {
#line 493
    part_set_signal(p, comp->d[i], 0, 0);
#line 492
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 494
  return;
}
}
#line 496 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void setup_data(bus_t *bus___0 , uint32_t d , component_t *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 500
  p = bus___0->part;
#line 503
  width = detect_data_width(comp);
#line 505
  i = 0;
  }
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! (i < width)) {
#line 505
      goto while_break;
    }
    {
#line 506
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 505
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  return;
}
}
#line 509 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static uint8_t eeprom_shift_byte(chain_t *chain , part_t *p , component_t *comp ,
                                 uint8_t byte ) 
{ 
  int pos ;
  uint8_t so_data ;
  int tmp ;

  {
#line 513
  so_data = (uint8_t )0;
#line 515
  pos = 7;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (! (pos >= 0)) {
#line 515
      goto while_break;
    }
    {
#line 517
    part_set_signal(p, comp->sck, 1, 0);
#line 519
    part_set_signal(p, comp->si, 1, ((int )byte >> pos) & 1);
#line 521
    chain_shift_data_registers(chain, 1);
#line 524
    part_set_signal(p, comp->sck, 1, 1);
#line 526
    chain_shift_data_registers(chain, 1);
#line 529
    tmp = part_get_signal(p, comp->so);
#line 529
    so_data = (uint8_t )((int )so_data | (int )((uint8_t )(tmp << pos)));
#line 515
    pos --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  return (so_data);
}
}
#line 535 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void eeprom_disable_device(chain_t *chain , part_t *p , component_t *comp ) 
{ 


  {
  {
#line 539
  part_set_signal(p, comp->sck, 1, 0);
#line 540
  chain_shift_data_registers(chain, 0);
#line 543
  part_set_signal(p, comp->ncs, 1, 1);
#line 544
  chain_shift_data_registers(chain, 0);
  }
#line 545
  return;
}
}
#line 551 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static int zefant_xs3_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  component_t *comp ;

  {
  {
#line 554
  p = bus___0->part;
#line 555
  chain = bus___0->chain;
#line 561
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 562
  chain_shift_instructions(chain);
#line 565
  comp = & ((bus_params_t *)bus___0->params)->flash;
#line 566
  setup_data(bus___0, (uint32_t )0, comp);
#line 567
  part_set_signal(p, comp->ncs, 1, 1);
#line 568
  part_set_signal(p, comp->nwe, 1, 1);
#line 569
  part_set_signal(p, comp->noe, 1, 1);
#line 570
  part_set_signal(p, comp->nrp, 1, 1);
#line 571
  part_set_signal(p, comp->nbyte, 1, 1);
#line 572
  part_set_signal(p, comp->sts, 0, 0);
#line 575
  comp = & ((bus_params_t *)bus___0->params)->ram0;
#line 576
  setup_data(bus___0, (uint32_t )0, comp);
#line 577
  part_set_signal(p, comp->ncs, 1, 1);
#line 578
  part_set_signal(p, comp->nwe, 1, 1);
#line 579
  part_set_signal(p, comp->noe, 1, 1);
#line 580
  part_set_signal(p, comp->nlb, 1, 1);
#line 581
  part_set_signal(p, comp->nub, 1, 1);
#line 584
  comp = & ((bus_params_t *)bus___0->params)->ram1;
#line 585
  setup_data(bus___0, (uint32_t )0, comp);
#line 586
  part_set_signal(p, comp->ncs, 1, 1);
#line 587
  part_set_signal(p, comp->nwe, 1, 1);
#line 588
  part_set_signal(p, comp->noe, 1, 1);
#line 589
  part_set_signal(p, comp->nlb, 1, 1);
#line 590
  part_set_signal(p, comp->nub, 1, 1);
#line 593
  comp = & ((bus_params_t *)bus___0->params)->eeprom;
#line 594
  part_set_signal(p, comp->si, 1, 0);
#line 595
  part_set_signal(p, comp->so, 0, 0);
#line 596
  part_set_signal(p, comp->sck, 1, 0);
#line 597
  part_set_signal(p, comp->ncs, 1, 1);
#line 600
  comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
#line 601
  part_set_signal(p, comp->si, 1, 0);
#line 602
  part_set_signal(p, comp->so, 0, 0);
#line 603
  part_set_signal(p, comp->sck, 1, 0);
#line 604
  part_set_signal(p, comp->ncs, 1, 1);
#line 606
  chain_shift_data_registers(chain, 0);
#line 608
  bus___0->initialized = 1;
  }
#line 610
  return (0);
}
}
#line 613 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static int comp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t **comp ) 
{ 


  {
#line 616
  if (adr < (uint32_t )(1 << 25)) {
#line 617
    area->description = "FLASH Component";
#line 618
    area->start = (uint32_t )0;
#line 619
    area->length = (uint64_t )(1 << 25);
#line 620
    area->width = 16U;
#line 621
    *comp = & ((bus_params_t *)bus___0->params)->flash;
  } else
#line 622
  if (adr < (uint32_t )((1 << 25) + (1 << 19))) {
#line 623
    area->description = "SO-DIMM RAM0 Component";
#line 624
    area->start = (uint32_t )(1 << 25);
#line 625
    area->length = (uint64_t )(1 << 19);
#line 626
    area->width = 16U;
#line 627
    *comp = & ((bus_params_t *)bus___0->params)->ram0;
  } else
#line 628
  if (adr < (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19))) {
#line 629
    area->description = "SO-DIMM RAM1 Component";
#line 630
    area->start = (uint32_t )((1 << 25) + (1 << 19));
#line 631
    area->length = (uint64_t )(1 << 19);
#line 632
    area->width = 16U;
#line 633
    *comp = & ((bus_params_t *)bus___0->params)->ram1;
  } else
#line 634
  if (adr < (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16))) {
#line 635
    area->description = "EEPROM Component";
#line 636
    area->start = (uint32_t )(((1 << 25) + (1 << 19)) + (1 << 19));
#line 637
    area->length = (uint64_t )(1 << 16);
#line 638
    area->width = 8U;
#line 639
    *comp = & ((bus_params_t *)bus___0->params)->eeprom;
  } else
#line 640
  if (adr < (uint32_t )(((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16)) + 3)) {
#line 641
    area->description = "EEPROM Component Status";
#line 642
    area->start = (uint32_t )((((1 << 25) + (1 << 19)) + (1 << 19)) + (1 << 16));
#line 643
    area->length = (uint64_t )(1 << 16);
#line 644
    area->width = 8U;
#line 645
    *comp = & ((bus_params_t *)bus___0->params)->eeprom_status;
  } else {
#line 647
    area->description = "Dummy";
#line 648
    area->start = (uint32_t )(((1 << 25) + 2 * (1 << 19)) + 2 * (1 << 16));
#line 649
    area->length = 4294967296UL;
#line 650
    area->width = 0U;
#line 651
    *comp = (component_t *)((void *)0);
  }
#line 654
  return (0);
}
}
#line 661 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static int zefant_xs3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  component_t *comp ;
  int tmp ;

  {
  {
#line 666
  tmp = comp_bus_area(bus___0, adr, area, & comp);
  }
#line 666
  return (tmp);
}
}
#line 673 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 676
  p = bus___0->part;
#line 677
  chain = bus___0->chain;
#line 680
  cmd = (uint8_t )3;
#line 682
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 683
  if (! comp) {
    {
#line 684
    tmp = gettext("Address out of range\n");
#line 684
    printf((char const   */* __restrict  */)tmp);
#line 685
    ((bus_params_t *)bus___0->params)->last_addr = adr;
    }
#line 686
    return;
  }
  {
#line 692
  if ((unsigned int )comp->ctype == 0U) {
#line 692
    goto case_0;
  }
#line 692
  if ((unsigned int )comp->ctype == 1U) {
#line 692
    goto case_0;
  }
#line 708
  if ((unsigned int )comp->ctype == 3U) {
#line 708
    goto case_3;
  }
#line 711
  if ((unsigned int )comp->ctype == 2U) {
#line 711
    goto case_2;
  }
#line 728
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 693
  part_set_signal(p, comp->ncs, 1, 0);
#line 694
  part_set_signal(p, comp->nwe, 1, 1);
#line 695
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 696
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 697
    part_set_signal(p, comp->nlb, 1, 0);
#line 698
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 701
  setup_address(bus___0, adr, comp);
#line 702
  set_data_in(bus___0, comp);
#line 704
  chain_shift_data_registers(chain, 0);
  }
#line 706
  goto switch_break;
  case_3: /* CIL Label */ 
#line 709
  cmd = (uint8_t )5;
  case_2: /* CIL Label */ 
  {
#line 713
  part_set_signal(p, comp->ncs, 1, 0);
#line 716
  eeprom_shift_byte(chain, p, comp, cmd);
  }
#line 718
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 720
    eeprom_shift_byte(chain, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 722
    eeprom_shift_byte(chain, p, comp, (uint8_t )(adr & 255U));
    }
  }
#line 725
  ((bus_params_t *)bus___0->params)->last_addr = adr;
#line 726
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 729
  tmp___0 = gettext("Component type not supported\n");
#line 729
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 730
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 733
  return;
}
}
#line 739 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 742
  p = bus___0->part;
#line 743
  chain = bus___0->chain;
#line 745
  d = (uint32_t )0;
#line 749
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 750
  if (! comp) {
    {
#line 751
    tmp = gettext("Address out of range\n");
#line 751
    printf((char const   */* __restrict  */)tmp);
#line 752
    ((bus_params_t *)bus___0->params)->last_addr = adr;
    }
#line 753
    return ((uint32_t )0);
  }
  {
#line 759
  if ((unsigned int )comp->ctype == 0U) {
#line 759
    goto case_0;
  }
#line 759
  if ((unsigned int )comp->ctype == 1U) {
#line 759
    goto case_0;
  }
#line 769
  if ((unsigned int )comp->ctype == 2U) {
#line 769
    goto case_2;
  }
#line 769
  if ((unsigned int )comp->ctype == 3U) {
#line 769
    goto case_2;
  }
#line 774
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 760
  setup_address(bus___0, adr, comp);
#line 761
  chain_shift_data_registers(chain, 1);
#line 763
  i = 0;
  }
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! ((unsigned int )i < area.width)) {
#line 763
      goto while_break;
    }
    {
#line 764
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 764
    d |= (uint32_t )(tmp___0 << i);
#line 763
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 766
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 771
  tmp___1 = eeprom_shift_byte(chain, p, comp, (uint8_t )0);
#line 771
  d = (uint32_t )tmp___1;
  }
#line 772
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 775
  tmp___2 = gettext("Component type not supported\n");
#line 775
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 776
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 779
  return (d);
}
}
#line 786 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static uint32_t zefant_xs3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t *comp ;
  char *tmp ;
  int tmp___0 ;
  uint8_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 789
  p = bus___0->part;
#line 790
  chain = bus___0->chain;
#line 792
  d = (uint32_t )0;
#line 797
  comp_bus_area(bus___0, ((bus_params_t *)bus___0->params)->last_addr, & area, & comp);
  }
#line 798
  if (! comp) {
    {
#line 799
    tmp = gettext("Address out of range\n");
#line 799
    printf((char const   */* __restrict  */)tmp);
    }
#line 800
    return ((uint32_t )0);
  }
  {
#line 806
  if ((unsigned int )comp->ctype == 0U) {
#line 806
    goto case_0;
  }
#line 806
  if ((unsigned int )comp->ctype == 1U) {
#line 806
    goto case_0;
  }
#line 821
  if ((unsigned int )comp->ctype == 2U) {
#line 821
    goto case_2;
  }
#line 821
  if ((unsigned int )comp->ctype == 3U) {
#line 821
    goto case_2;
  }
#line 828
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 807
  part_set_signal(p, comp->ncs, 1, 1);
#line 808
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 809
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 810
    part_set_signal(p, comp->nlb, 1, 1);
#line 811
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 813
  chain_shift_data_registers(chain, 1);
#line 815
  i = 0;
  }
  {
#line 815
  while (1) {
    while_continue: /* CIL Label */ ;
#line 815
    if (! ((unsigned int )i < area.width)) {
#line 815
      goto while_break;
    }
    {
#line 816
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 816
    d |= (uint32_t )(tmp___0 << i);
#line 815
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 818
  goto switch_break;
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 823
  tmp___1 = eeprom_shift_byte(chain, p, comp, (uint8_t )0);
#line 823
  d = (uint32_t )tmp___1;
#line 824
  eeprom_disable_device(chain, p, comp);
  }
#line 826
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 829
  tmp___2 = gettext("Component type not supported\n");
#line 829
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 830
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 833
  return (d);
}
}
#line 840 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
static void zefant_xs3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area ;
  component_t *comp ;
  uint8_t cmd ;
  char *tmp ;
  uint8_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 843
  p = bus___0->part;
#line 844
  chain = bus___0->chain;
#line 847
  cmd = (uint8_t )2;
#line 849
  comp_bus_area(bus___0, adr, & area, & comp);
  }
#line 850
  if (! comp) {
    {
#line 851
    tmp = gettext("Address out of range\n");
#line 851
    printf((char const   */* __restrict  */)tmp);
    }
#line 852
    return;
  }
  {
#line 857
  if ((unsigned int )comp->ctype == 0U) {
#line 857
    goto case_0;
  }
#line 857
  if ((unsigned int )comp->ctype == 1U) {
#line 857
    goto case_0;
  }
#line 883
  if ((unsigned int )comp->ctype == 3U) {
#line 883
    goto case_3;
  }
#line 886
  if ((unsigned int )comp->ctype == 2U) {
#line 886
    goto case_2;
  }
#line 937
  goto switch_default;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 858
  part_set_signal(p, comp->ncs, 1, 0);
#line 859
  part_set_signal(p, comp->nwe, 1, 1);
#line 860
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 861
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 862
    part_set_signal(p, comp->nlb, 1, 0);
#line 863
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 866
  setup_address(bus___0, adr, comp);
#line 867
  setup_data(bus___0, data, comp);
#line 869
  chain_shift_data_registers(chain, 0);
#line 871
  part_set_signal(p, comp->nwe, 1, 0);
#line 872
  chain_shift_data_registers(chain, 0);
#line 873
  part_set_signal(p, comp->nwe, 1, 1);
#line 874
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 875
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 876
    part_set_signal(p, comp->nlb, 1, 1);
#line 877
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 879
  chain_shift_data_registers(chain, 0);
  }
#line 881
  goto switch_break;
  case_3: /* CIL Label */ 
#line 884
  cmd = (uint8_t )1;
  case_2: /* CIL Label */ 
  {
#line 891
  part_set_signal(p, comp->ncs, 1, 0);
  }
  {
#line 894
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 895
    eeprom_shift_byte(chain, p, comp, (uint8_t )5);
#line 894
    tmp___0 = eeprom_shift_byte(chain, p, comp, (uint8_t )0);
    }
#line 894
    if (! ((int )tmp___0 & 1)) {
#line 894
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 898
  eeprom_disable_device(chain, p, comp);
#line 905
  part_set_signal(p, comp->ncs, 1, 0);
#line 908
  eeprom_shift_byte(chain, p, comp, (uint8_t )6);
#line 910
  eeprom_disable_device(chain, p, comp);
#line 917
  part_set_signal(p, comp->ncs, 1, 0);
#line 921
  eeprom_shift_byte(chain, p, comp, cmd);
  }
#line 923
  if ((unsigned int )comp->ctype == 2U) {
    {
#line 925
    eeprom_shift_byte(chain, p, comp, (uint8_t )((adr >> 8) & 255U));
#line 927
    eeprom_shift_byte(chain, p, comp, (uint8_t )(adr & 255U));
    }
  }
  {
#line 931
  eeprom_shift_byte(chain, p, comp, (uint8_t )(data & 255U));
#line 933
  eeprom_disable_device(chain, p, comp);
  }
#line 935
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 938
  tmp___1 = gettext("Component type not supported\n");
#line 938
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 939
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 941
  return;
}
}
#line 943 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/zefant-xs3.c"
struct bus_driver  const  zefant_xs3_bus  = 
#line 943
     {"zefant-xs3", "Simple Solutions Zefant-XS3 Board compatible bus driver via BSR",
    & zefant_xs3_bus_new, & generic_bus_free, & zefant_xs3_bus_printinfo, & generic_bus_prepare_extest,
    & zefant_xs3_bus_area, & zefant_xs3_bus_read_start, & zefant_xs3_bus_read_next,
    & zefant_xs3_bus_read_end, & generic_bus_read, & zefant_xs3_bus_write, & zefant_xs3_bus_init};
#line 204 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 759
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 38 "../../include/jtag.h"
int big_endian ;
#line 54
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/writemem.c"
void writemem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  int bidx ;
  uint8_t b[4096] ;
  bus_area_t area ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;

  {
#line 41
  bc = 0;
#line 42
  bidx = 0;
#line 48
  if (! bus___0) {
    {
#line 49
    tmp = gettext("Error: Missing bus driver!\n");
#line 49
    printf((char const   */* __restrict  */)tmp);
    }
#line 50
    return;
  }
  {
#line 53
  (*((bus___0->driver)->prepare))(bus___0);
#line 55
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area);
  }
#line 55
  if (tmp___1 != 0) {
    {
#line 56
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 56
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 57
    return;
  }
#line 59
  step = area.width / 8U;
#line 61
  if (step == 0U) {
    {
#line 62
    tmp___2 = gettext("Unknown bus width!\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return;
  }
  {
#line 66
  addr &= ~ (step - 1U);
#line 67
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 69
  tmp___3 = gettext("address: 0x%08X\n");
#line 69
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 70
  tmp___4 = gettext("length:  0x%08X\n");
#line 70
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 72
  if (len == 0U) {
    {
#line 73
    tmp___5 = gettext("length is 0.\n");
#line 73
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 74
    return;
  }
  {
#line 77
  a = addr;
#line 78
  end = (uint64_t )(a + len);
#line 79
  tmp___6 = gettext("writing:\n");
#line 79
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((uint64_t )a < end)) {
#line 81
      goto while_break;
    }
#line 86
    if ((uint32_t )bc < step) {
      {
#line 87
      tmp___7 = gettext("addr: 0x%08X");
#line 87
      printf((char const   */* __restrict  */)tmp___7, a);
#line 88
      printf((char const   */* __restrict  */)"\r");
#line 89
      fflush(stdout);
      }
#line 90
      if (bc != 0) {
        {
#line 91
        tmp___8 = gettext("Data not on word boundary, NOT SUPPORTED!");
#line 91
        printf((char const   */* __restrict  */)tmp___8);
        }
      }
      {
#line 92
      tmp___11 = feof(f);
      }
#line 92
      if (tmp___11) {
        {
#line 93
        tmp___9 = gettext("Unexpected end of file!\n");
#line 93
        printf((char const   */* __restrict  */)tmp___9);
#line 94
        tmp___10 = gettext("Addr: 0x%08X\n");
#line 94
        printf((char const   */* __restrict  */)tmp___10, a);
        }
#line 95
        goto while_break;
      }
      {
#line 97
      tmp___12 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )4096, (FILE */* __restrict  */)f);
#line 97
      bc = (int )tmp___12;
      }
#line 98
      if (! bc) {
        {
#line 99
        tmp___13 = gettext("Short read: bc=0x%X\n");
#line 99
        printf((char const   */* __restrict  */)tmp___13, bc);
        }
      }
#line 101
      bidx = 0;
    }
#line 106
    data = (uint32_t )0;
#line 107
    j = (int )step;
    {
#line 107
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 107
      if (! (j > 0)) {
#line 107
        goto while_break___0;
      }
#line 108
      if (big_endian) {
#line 109
        tmp___14 = bidx;
#line 109
        bidx ++;
#line 109
        data |= (unsigned int )b[tmp___14];
#line 110
        data <<= 8;
#line 111
        bc --;
      } else {
#line 113
        tmp___15 = bidx;
#line 113
        bidx ++;
#line 113
        data |= (unsigned int )((int )b[tmp___15] << (step - (uint32_t )j) * 8U);
#line 114
        bc --;
      }
#line 107
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 118
    (*((bus___0->driver)->write))(bus___0, a, data);
#line 81
    a += step;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp___16 = gettext("\nDone.\n");
#line 122
  printf((char const   */* __restrict  */)tmp___16);
  }
#line 123
  return;
}
}
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 60 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  tx4925_bus ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.h"
int generic_bus_no_init(bus_t *bus___0 ) ;
#line 72 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static bus_t *tx4925_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 79
  failed = 0;
#line 81
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 81
  bus___0 = (bus_t *)tmp;
  }
#line 82
  if (! bus___0) {
#line 83
    return ((bus_t *)((void *)0));
  }
  {
#line 85
  bus___0->driver = driver;
#line 86
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___0 ));
  }
#line 87
  if (! bus___0->params) {
    {
#line 88
    free((void *)bus___0);
    }
#line 89
    return ((bus_t *)((void *)0));
  }
  {
#line 92
  bus___0->chain = chain;
#line 93
  part = *((chain->parts)->parts + chain->active_part);
#line 93
  bus___0->part = part;
#line 95
  tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->oe,
                                   (char *)"OE");
#line 95
  failed |= tmp___0;
#line 97
  tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->swe,
                                   (char *)"SWE");
#line 97
  failed |= tmp___1;
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < 4)) {
#line 99
      goto while_break;
    }
    {
#line 100
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ROMCE_%d",
            i);
#line 101
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->romce[i],
                                     buff);
#line 101
    failed |= tmp___2;
#line 99
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (i < 4)) {
#line 104
      goto while_break___0;
    }
    {
#line 105
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDCS_%d",
            i);
#line 106
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->sdcs[i],
                                     buff);
#line 106
    failed |= tmp___3;
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 109
  i = 0;
  {
#line 109
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 109
    if (! (i < 20)) {
#line 109
      goto while_break___1;
    }
    {
#line 110
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR_%d",
            i);
#line 111
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->addr[i],
                                     buff);
#line 111
    failed |= tmp___4;
#line 109
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 114
    if (! (i < 16)) {
#line 114
      goto while_break___2;
    }
    {
#line 115
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA_%d",
            i);
#line 116
    tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___0 *)bus___0->params)->data[i],
                                     buff);
#line 116
    failed |= tmp___5;
#line 114
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 119
  if (failed) {
    {
#line 120
    free(bus___0->params);
#line 121
    free((void *)bus___0);
    }
#line 122
    return ((bus_t *)((void *)0));
  }
#line 125
  return (bus___0);
}
}
#line 132 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void tx4925_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 137
      goto while_break;
    }
#line 138
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 139
      goto while_break;
    }
#line 137
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 140
  tmp = gettext("Toshiba TX4925 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 140
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 141
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static int tx4925_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 150
  area->description = (char const   *)((void *)0);
#line 151
  area->start = 0U;
#line 152
  area->length = 4294967296UL;
#line 153
  area->width = 16U;
#line 155
  return (0);
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void select_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 161
  p = bus___0->part;
#line 163
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 0);
#line 164
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 165
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 166
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 167
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 170
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 171
  return;
}
}
#line 173 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void unselect_flash(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 176
  p = bus___0->part;
#line 178
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[0], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[1], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[2], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->romce[3], 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[0], 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[1], 1, 1);
#line 184
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[2], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->sdcs[3], 1, 1);
  }
#line 186
  return;
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void setup_address___0(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  int addr_shift ;

  {
#line 192
  p = bus___0->part;
#line 193
  addr_shift = 1;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 20)) {
#line 195
      goto while_break;
    }
    {
#line 196
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->addr[i], 1, (int )((a >> (i + addr_shift)) & 1U));
#line 195
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 199 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void set_data_in___0(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 203
  p = bus___0->part;
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < 16)) {
#line 205
      goto while_break;
    }
    {
#line 206
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 0, 0);
#line 205
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void setup_data___0(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 213
  p = bus___0->part;
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 16)) {
#line 215
      goto while_break;
    }
    {
#line 216
    part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void tx4925_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 226
  p = bus___0->part;
#line 227
  chain = bus___0->chain;
#line 229
  select_flash(bus___0);
#line 230
  setup_address___0(bus___0, adr);
#line 231
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 0);
#line 232
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 234
  set_data_in___0(bus___0);
#line 236
  chain_shift_data_registers(chain, 0);
  }
#line 237
  return;
}
}
#line 243 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 246
  p = bus___0->part;
#line 247
  chain = bus___0->chain;
#line 249
  d = (uint32_t )0;
#line 251
  setup_address___0(bus___0, adr);
#line 252
  chain_shift_data_registers(chain, 1);
#line 254
  i = 0;
  }
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    if (! (i < 16)) {
#line 254
      goto while_break;
    }
    {
#line 255
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 255
    d |= (uint32_t )(tmp << i);
#line 254
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  return (d);
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static uint32_t tx4925_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 267
  p = bus___0->part;
#line 268
  chain = bus___0->chain;
#line 270
  d = (uint32_t )0;
#line 272
  unselect_flash(bus___0);
#line 273
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 276
  chain_shift_data_registers(chain, 1);
#line 278
  i = 0;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < 16)) {
#line 278
      goto while_break;
    }
    {
#line 279
    tmp = part_get_signal(p, ((bus_params_t___0 *)bus___0->params)->data[i]);
#line 279
    d |= (uint32_t )(tmp << i);
#line 278
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (d);
}
}
#line 288 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
static void tx4925_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 291
  p = bus___0->part;
#line 292
  chain = bus___0->chain;
#line 294
  select_flash(bus___0);
#line 295
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->oe, 1, 1);
#line 297
  setup_address___0(bus___0, adr);
#line 298
  setup_data___0(bus___0, data);
#line 300
  chain_shift_data_registers(chain, 0);
#line 302
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 0);
#line 303
  chain_shift_data_registers(chain, 0);
#line 304
  part_set_signal(p, ((bus_params_t___0 *)bus___0->params)->swe, 1, 1);
#line 305
  unselect_flash(bus___0);
#line 306
  chain_shift_data_registers(chain, 0);
  }
#line 307
  return;
}
}
#line 309 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/tx4925.c"
struct bus_driver  const  tx4925_bus  = 
#line 309
     {"tx4925", "Toshiba TX4925 compatible bus driver via BSR", & tx4925_bus_new, & generic_bus_free,
    & tx4925_bus_printinfo, & generic_bus_prepare_extest, & tx4925_bus_area, & tx4925_bus_read_start,
    & tx4925_bus_read_next, & tx4925_bus_read_end, & generic_bus_read, & tx4925_bus_write,
    & generic_bus_no_init};
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  slsup3_bus ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
int databusio[16]  = 
#line 42 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
  {      94,      96,      98,      100, 
        102,      104,      106,      113, 
        95,      97,      99,      101, 
        103,      105,      107,      114};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
int addrbusio[20]  = 
#line 43
  {      93,      88,      87,      86, 
        85,      84,      83,      63, 
        64,      65,      66,      67, 
        68,      74,      75,      76, 
        77,      82,      81,      78};
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static bus_t *slsup3_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 98
  failed = 0;
#line 100
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 100
  bus___0 = (bus_t *)tmp;
  }
#line 101
  if (! bus___0) {
#line 102
    return ((bus_t *)((void *)0));
  }
  {
#line 104
  bus___0->driver = driver;
#line 105
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___1 ));
  }
#line 106
  if (! bus___0->params) {
    {
#line 107
    free((void *)bus___0);
    }
#line 108
    return ((bus_t *)((void *)0));
  }
#line 111
  bus___0->chain = chain;
#line 112
  part = *((chain->parts)->parts + chain->active_part);
#line 112
  bus___0->part = part;
#line 114
  i = 0;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 114
    if (! (i < 20)) {
#line 114
      goto while_break;
    }
    {
#line 115
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            addrbusio[i]);
#line 116
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->ad[i],
                                     buff);
#line 116
    failed |= tmp___0;
#line 114
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  i = 0;
  {
#line 119
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 119
    if (! (i < 16)) {
#line 119
      goto while_break___0;
    }
    {
#line 120
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO%d",
            databusio[i]);
#line 121
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->dq[i],
                                     buff);
#line 121
    failed |= tmp___1;
#line 119
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 124
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->noe,
                                   (char *)"IO118");
#line 124
  failed |= tmp___2;
#line 126
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nsrce,
                                   (char *)"IO116");
#line 126
  failed |= tmp___3;
#line 128
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nsdce,
                                   (char *)"IO119");
#line 128
  failed |= tmp___4;
#line 130
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nflce,
                                   (char *)"IO117");
#line 130
  failed |= tmp___5;
#line 132
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nflbyte,
                                   (char *)"IO115");
#line 132
  failed |= tmp___6;
#line 134
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nflby,
                                   (char *)"IO80");
#line 134
  failed |= tmp___7;
#line 136
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->nwe,
                                   (char *)"IO79");
#line 136
  failed |= tmp___8;
#line 138
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->sdclk,
                                   (char *)"IO11");
#line 138
  failed |= tmp___9;
#line 140
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->lcde,
                                    (char *)"IO50");
#line 140
  failed |= tmp___10;
#line 142
  tmp___11 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->lcdrs,
                                    (char *)"IO108");
#line 142
  failed |= tmp___11;
#line 144
  tmp___12 = generic_bus_attach_sig(part, & ((bus_params_t___1 *)bus___0->params)->lcdrw,
                                    (char *)"IO73");
#line 144
  failed |= tmp___12;
  }
#line 146
  if (failed) {
    {
#line 147
    free(bus___0->params);
#line 148
    free((void *)bus___0);
    }
#line 149
    return ((bus_t *)((void *)0));
  }
#line 152
  return (bus___0);
}
}
#line 159 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static void slsup3_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 164
      goto while_break;
    }
#line 165
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 166
      goto while_break;
    }
#line 164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 167
  tmp = gettext("SLS UP3 bus driver via BSR (JTAG part No. %d)\n");
#line 167
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 168
  return;
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static int slsup3_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 177
  if (adr >= 0U) {
#line 177
    if ((unsigned long )adr < 2097152UL) {
#line 178
      area->description = "Flash Memory (2 MByte) byte mode";
#line 179
      area->start = 0U;
#line 180
      area->length = 2097152UL;
#line 181
      area->width = 8U;
#line 183
      return (0);
    }
  }
#line 186
  if (adr >= 2097152U) {
#line 186
    if (adr < 2228224U) {
#line 187
      area->description = "SRAM 128KByte (64K x 16)";
#line 188
      area->start = (uint32_t )2097152;
#line 189
      area->length = (uint64_t )131072;
#line 190
      area->width = 16U;
#line 192
      return (0);
    }
  }
#line 195
  if (adr >= 3145728U) {
#line 195
    if (adr < 4194304U) {
#line 196
      area->description = "LCD Display (RS select by A0)";
#line 197
      area->start = (uint32_t )3145728;
#line 198
      area->length = (uint64_t )1048576;
#line 199
      area->width = 8U;
#line 201
      return (0);
    }
  }
#line 204
  area->description = (char const   *)((void *)0);
#line 205
  area->start = 4194304U;
#line 206
  area->length = 4290772992UL;
#line 207
  area->width = 0U;
#line 209
  return (0);
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static void setup_address___1(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 216
  p = bus___0->part;
#line 219
  slsup3_bus_area(bus___0, a, & area);
  }
#line 220
  if (area.width > 16U) {
#line 221
    return;
  }
  {
#line 223
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrs, 1, (int )(a & 1U));
  }
#line 226
  if (a >= 0U) {
#line 226
    if ((unsigned long )a < 2097152UL) {
#line 227
      i = 0;
      {
#line 227
      while (1) {
        while_continue: /* CIL Label */ ;
#line 227
        if (! (i < 20)) {
#line 227
          goto while_break;
        }
        {
#line 228
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (i + 1)) & 1U));
#line 227
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 229
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 0);
#line 230
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[15], 1, (int )(a & 1U));
      }
    } else {
      {
#line 232
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
      }
    }
  } else {
    {
#line 232
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
    }
  }
#line 235
  if (a >= 2097152U) {
#line 235
    if (a < 2228224U) {
      {
#line 236
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 0);
#line 237
      i = 0;
      }
      {
#line 237
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 237
        if (! (i < 20)) {
#line 237
          goto while_break___0;
        }
        {
#line 238
        part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->ad[i], 1, (int )((a >> (((unsigned int )i + area.width / 8U) - 1U)) & 1U));
#line 237
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 240
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
      }
    }
  } else {
    {
#line 240
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
    }
  }
#line 243
  return;
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static void set_data_in___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 249
  p = bus___0->part;
#line 252
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 253
  if (area.width > 16U) {
#line 254
    return;
  }
#line 256
  i = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((unsigned int )i < area.width)) {
#line 256
      goto while_break;
    }
    {
#line 257
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 0, 0);
#line 256
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  return;
}
}
#line 260 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static void setup_data___1(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 264
  p = bus___0->part;
#line 267
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 268
  if (area.width > 16U) {
#line 269
    return;
  }
#line 271
  i = 0;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if (! ((unsigned int )i < area.width)) {
#line 271
      goto while_break;
    }
    {
#line 272
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i], 1, (int )((d >> i) & 1U));
#line 271
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static uint32_t get_data(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 280
  d = (uint32_t )0;
#line 281
  p = bus___0->part;
#line 283
  slsup3_bus_area(bus___0, adr, & area);
  }
#line 284
  if (area.width > 16U) {
#line 285
    return ((uint32_t )0);
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! ((unsigned int )i < area.width)) {
#line 287
      goto while_break;
    }
    {
#line 288
    tmp = part_get_signal(p, ((bus_params_t___1 *)bus___0->params)->dq[i]);
#line 288
    d |= (uint32_t )(tmp << i);
#line 287
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return (d);
}
}
#line 297 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static void slsup3_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 300
  p = bus___0->part;
#line 302
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
#line 304
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 305
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 0);
#line 306
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 307
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 308
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 309
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 310
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 311
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 312
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 1);
#line 314
  setup_address___1(bus___0, adr);
  }
#line 316
  if (adr >= 3145728U) {
#line 316
    if (adr < 4194304U) {
      {
#line 317
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 318
      chain_shift_data_registers(bus___0->chain, 0);
#line 319
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 322
  set_data_in___1(bus___0, adr);
#line 324
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 326
  return;
}
}
#line 332 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  part_t *p ;

  {
  {
#line 337
  p = bus___0->part;
#line 339
  setup_address___1(bus___0, adr);
  }
#line 341
  if (adr >= 3145728U) {
#line 341
    if (adr < 4194304U) {
      {
#line 342
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 343
      chain_shift_data_registers(bus___0->chain, 0);
#line 344
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 347
  chain_shift_data_registers(bus___0->chain, 1);
#line 349
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
#line 351
  ((bus_params_t___1 *)bus___0->params)->last_adr = adr;
  }
#line 353
  return (d);
}
}
#line 360 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static uint32_t slsup3_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t d ;

  {
#line 363
  p = bus___0->part;
#line 366
  if (((bus_params_t___1 *)bus___0->params)->last_adr >= 3145728U) {
#line 366
    if (((bus_params_t___1 *)bus___0->params)->last_adr < 4194304U) {
      {
#line 367
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 368
      chain_shift_data_registers(bus___0->chain, 0);
#line 369
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
      }
    }
  }
  {
#line 372
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 374
  chain_shift_data_registers(bus___0->chain, 1);
#line 376
  d = get_data(bus___0, ((bus_params_t___1 *)bus___0->params)->last_adr);
  }
#line 378
  return (d);
}
}
#line 385 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
static void slsup3_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 388
  p = bus___0->part;
#line 389
  chain = bus___0->chain;
#line 391
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsdce, 1, 1);
#line 392
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->noe, 1, 1);
#line 393
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nsrce, 1, 1);
#line 394
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflce, 1, 1);
#line 395
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nflbyte, 1, 0);
#line 396
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 397
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->sdclk, 1, 0);
#line 398
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 399
  part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcdrw, 1, 0);
#line 401
  setup_address___1(bus___0, adr);
#line 402
  setup_data___1(bus___0, adr, data);
  }
#line 404
  if (adr >= 3145728U) {
#line 404
    if (adr < 4194304U) {
      {
#line 405
      chain_shift_data_registers(chain, 0);
#line 406
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 1);
#line 407
      chain_shift_data_registers(bus___0->chain, 0);
#line 408
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->lcde, 1, 0);
#line 409
      chain_shift_data_registers(bus___0->chain, 0);
      }
    } else {
      {
#line 412
      chain_shift_data_registers(chain, 0);
#line 414
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 415
      chain_shift_data_registers(chain, 0);
#line 416
      part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 417
      chain_shift_data_registers(chain, 0);
      }
    }
  } else {
    {
#line 412
    chain_shift_data_registers(chain, 0);
#line 414
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 0);
#line 415
    chain_shift_data_registers(chain, 0);
#line 416
    part_set_signal(p, ((bus_params_t___1 *)bus___0->params)->nwe, 1, 1);
#line 417
    chain_shift_data_registers(chain, 0);
    }
  }
#line 419
  return;
}
}
#line 421 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/slsup3.c"
struct bus_driver  const  slsup3_bus  = 
#line 421
     {"slsup3", "SLS UP3 compatible bus driver via BSR", & slsup3_bus_new, & generic_bus_free,
    & slsup3_bus_printinfo, & generic_bus_prepare_extest, & slsup3_bus_area, & slsup3_bus_read_start,
    & slsup3_bus_read_next, & slsup3_bus_read_end, & generic_bus_read, & slsup3_bus_write,
    & generic_bus_no_init};
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  sharc_21065L_bus ;
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static bus_t *sharc_21065L_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                   char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 71
  failed = 0;
#line 73
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 73
  bus___0 = (bus_t *)tmp;
  }
#line 74
  if (! bus___0) {
#line 75
    return ((bus_t *)((void *)0));
  }
  {
#line 77
  bus___0->driver = driver;
#line 78
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___2 ));
  }
#line 79
  if (! bus___0->params) {
    {
#line 80
    free((void *)bus___0);
    }
#line 81
    return ((bus_t *)((void *)0));
  }
#line 84
  bus___0->chain = chain;
#line 85
  part = *((chain->parts)->parts + chain->active_part);
#line 85
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 19)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->ma[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 8)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->md[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 97
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->bms,
                                   (char *)"BMS_B");
#line 97
  failed |= tmp___2;
#line 99
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->nwe,
                                   (char *)"WR_B");
#line 99
  failed |= tmp___3;
#line 101
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___2 *)bus___0->params)->noe,
                                   (char *)"RD_B");
#line 101
  failed |= tmp___4;
  }
#line 103
  if (failed) {
    {
#line 104
    free(bus___0->params);
#line 105
    free((void *)bus___0);
    }
#line 106
    return ((bus_t *)((void *)0));
  }
#line 109
  return (bus___0);
}
}
#line 116 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static void sharc_21065L_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 120
  i = 0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 120
      goto while_break;
    }
#line 121
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 122
      goto while_break;
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 123
  tmp = gettext("Analog Device\'s SHARC 21065L compatible bus driver via BSR (JTAG part No. %d)\n");
#line 123
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 124
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static int sharc_21065L_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 134
  if (adr < 524288U) {
#line 135
    area->description = "Boot Memory Select";
#line 136
    area->start = 0U;
#line 137
    area->length = 524288UL;
#line 138
    area->width = 8U;
#line 140
    return (0);
  }
#line 143
  area->description = (char const   *)((void *)0);
#line 144
  area->start = 4294967295U;
#line 145
  area->length = 524288UL;
#line 146
  area->width = 0U;
#line 147
  return (0);
}
}
#line 150 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static void setup_address___2(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 154
  p = bus___0->part;
#line 156
  i = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < 19)) {
#line 156
      goto while_break;
    }
    {
#line 157
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 156
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  return;
}
}
#line 160 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static void set_data_in___2(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 164
  p = bus___0->part;
#line 167
  sharc_21065L_bus_area(bus___0, adr, & area);
#line 169
  i = 0;
  }
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (! ((unsigned int )i < area.width)) {
#line 169
      goto while_break;
    }
    {
#line 170
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 0, 0);
#line 169
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static void setup_data___2(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 178
  p = bus___0->part;
#line 181
  sharc_21065L_bus_area(bus___0, adr, & area);
#line 183
  i = 0;
  }
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! ((unsigned int )i < area.width)) {
#line 183
      goto while_break;
    }
    {
#line 184
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 183
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 191 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static void sharc_21065L_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  part_t *p ;

  {
#line 194
  chain = bus___0->chain;
#line 195
  p = bus___0->part;
#line 197
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 198
  if (adr >= 524288U) {
#line 199
    return;
  }
  {
#line 202
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 203
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 0);
#line 206
  setup_address___2(bus___0, adr);
#line 207
  set_data_in___2(bus___0, adr);
#line 209
  chain_shift_data_registers(chain, 0);
  }
#line 210
  return;
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t d ;
  int i ;
  bus_area_t area ;
  int tmp ;

  {
#line 219
  p = bus___0->part;
#line 220
  chain = bus___0->chain;
#line 224
  ((bus_params_t___2 *)bus___0->params)->last_adr = adr;
#line 226
  if (adr < 524288U) {
    {
#line 230
    sharc_21065L_bus_area(bus___0, adr, & area);
#line 233
    setup_address___2(bus___0, adr);
#line 234
    chain_shift_data_registers(chain, 1);
#line 236
    d = (uint32_t )0;
#line 237
    i = 0;
    }
    {
#line 237
    while (1) {
      while_continue: /* CIL Label */ ;
#line 237
      if (! ((unsigned int )i < area.width)) {
#line 237
        goto while_break;
      }
      {
#line 238
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 238
      d |= (uint32_t )(tmp << i);
#line 237
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 240
    return (d);
  }
#line 242
  return ((uint32_t )0);
}
}
#line 249 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static uint32_t sharc_21065L_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
#line 252
  p = bus___0->part;
#line 253
  chain = bus___0->chain;
#line 255
  if (((bus_params_t___2 *)bus___0->params)->last_adr < 524288U) {
    {
#line 257
    d = (uint32_t )0;
#line 260
    sharc_21065L_bus_area(bus___0, ((bus_params_t___2 *)bus___0->params)->last_adr,
                          & area);
#line 263
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 1);
#line 264
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 265
    part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 267
    chain_shift_data_registers(chain, 1);
#line 269
    i = 0;
    }
    {
#line 269
    while (1) {
      while_continue: /* CIL Label */ ;
#line 269
      if (! ((unsigned int )i < area.width)) {
#line 269
        goto while_break;
      }
      {
#line 270
      tmp = part_get_signal(p, ((bus_params_t___2 *)bus___0->params)->md[i]);
#line 270
      d |= (uint32_t )(tmp << i);
#line 269
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 272
    return (d);
  }
#line 275
  return ((uint32_t )0);
}
}
#line 282 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
static void sharc_21065L_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
#line 285
  p = bus___0->part;
#line 286
  chain = bus___0->chain;
#line 288
  if (adr >= 524288U) {
#line 289
    return;
  }
  {
#line 292
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->bms, 1, 0);
#line 293
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 294
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->noe, 1, 1);
#line 296
  setup_address___2(bus___0, adr);
#line 297
  setup_data___2(bus___0, adr, data);
#line 299
  chain_shift_data_registers(chain, 0);
#line 301
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 0);
#line 302
  chain_shift_data_registers(chain, 0);
#line 303
  part_set_signal(p, ((bus_params_t___2 *)bus___0->params)->nwe, 1, 1);
#line 304
  chain_shift_data_registers(chain, 0);
  }
#line 305
  return;
}
}
#line 307 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sharc21065l.c"
struct bus_driver  const  sharc_21065L_bus  = 
#line 307
     {"SHARC_21065L", "SHARC_21065L compatible bus driver via BSR", & sharc_21065L_bus_new,
    & generic_bus_free, & sharc_21065L_bus_printinfo, & generic_bus_prepare_extest,
    & sharc_21065L_bus_area, & sharc_21065L_bus_read_start, & sharc_21065L_bus_read_next,
    & sharc_21065L_bus_read_end, & generic_bus_read, & sharc_21065L_bus_write, & generic_bus_no_init};
#line 57 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  sh7751r_bus ;
#line 62 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static bus_t *sh7751r_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 69
  failed = 0;
#line 71
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 71
  bus___0 = (bus_t *)tmp;
  }
#line 72
  if (! bus___0) {
#line 73
    return ((bus_t *)((void *)0));
  }
  {
#line 75
  bus___0->driver = driver;
#line 76
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___3 ));
  }
#line 77
  if (! bus___0->params) {
    {
#line 78
    free((void *)bus___0);
    }
#line 79
    return ((bus_t *)((void *)0));
  }
#line 82
  bus___0->chain = chain;
#line 83
  part = *((chain->parts)->parts + chain->active_part);
#line 83
  bus___0->part = part;
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! (i < 26)) {
#line 85
      goto while_break;
    }
    {
#line 86
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 87
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->a[i],
                                     buff);
#line 87
    failed |= tmp___0;
#line 85
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  i = 0;
  {
#line 90
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 90
    if (! (i < 32)) {
#line 90
      goto while_break___0;
    }
    {
#line 91
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 92
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->d[i],
                                     buff);
#line 92
    failed |= tmp___1;
#line 90
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 95
  i = 0;
  {
#line 95
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 95
    if (! (i < 7)) {
#line 95
      goto while_break___1;
    }
    {
#line 96
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 97
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->cs[i],
                                     buff);
#line 97
    failed |= tmp___2;
#line 95
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 100
  i = 0;
  {
#line 100
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 100
    if (! (i < 4)) {
#line 100
      goto while_break___2;
    }
    {
#line 101
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 102
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->we[i],
                                     buff);
#line 102
    failed |= tmp___3;
#line 100
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 105
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->rdwr,
                                   (char *)"RD_WR");
#line 105
  failed |= tmp___4;
#line 107
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___3 *)bus___0->params)->rd,
                                   (char *)"RD_CASS_FRAME");
#line 107
  failed |= tmp___5;
  }
#line 109
  if (failed) {
    {
#line 110
    free(bus___0->params);
#line 111
    free((void *)bus___0);
    }
#line 112
    return ((bus_t *)((void *)0));
  }
#line 115
  return (bus___0);
}
}
#line 122 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static void sh7751r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 127
  i = 0;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 127
      goto while_break;
    }
#line 128
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 129
      goto while_break;
    }
#line 127
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp = gettext("Hitachi SH7751R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 130
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 131
  return;
}
}
#line 137 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static int sh7751r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 140
  area->description = (char const   *)((void *)0);
#line 141
  area->start = 0U;
#line 142
  area->length = 4294967296UL;
#line 143
  area->width = 16U;
#line 145
  return (0);
}
}
#line 148 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static void setup_address___3(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 152
  p = bus___0->part;
#line 154
  i = 0;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < 26)) {
#line 154
      goto while_break;
    }
    {
#line 155
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 154
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  return;
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static void set_data_in___3(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 162
  p = bus___0->part;
#line 164
  i = 0;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! (i < 32)) {
#line 164
      goto while_break;
    }
    {
#line 165
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 0, 0);
#line 164
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return;
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static void setup_data___3(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 172
  p = bus___0->part;
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! (i < 32)) {
#line 174
      goto while_break;
    }
    {
#line 175
    part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 182 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static void sh7751r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 185
  p = bus___0->part;
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < 8)) {
#line 189
      goto while_break;
    }
#line 190
    cs[i] = 1;
#line 189
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 191
  cs[(adr & 469762048U) >> 26] = 0;
#line 193
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 194
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 195
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 196
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 197
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 198
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 199
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 200
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 202
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 203
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 0);
#line 207
  setup_address___3(bus___0, adr);
#line 208
  set_data_in___3(bus___0);
#line 209
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 210
  return;
}
}
#line 216 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 219
  p = bus___0->part;
#line 221
  d = (uint32_t )0;
#line 223
  setup_address___3(bus___0, adr);
#line 224
  chain_shift_data_registers(bus___0->chain, 1);
#line 226
  i = 0;
  }
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < 32)) {
#line 226
      goto while_break;
    }
    {
#line 227
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 227
    d |= (uint32_t )(tmp << i);
#line 226
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return (d);
}
}
#line 236 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static uint32_t sh7751r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
#line 239
  p = bus___0->part;
#line 242
  d = (uint32_t )0;
#line 244
  i = 0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < 8)) {
#line 244
      goto while_break;
    }
#line 245
    cs[i] = 1;
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 247
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 248
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 249
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 250
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 251
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 252
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 253
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 255
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 256
  chain_shift_data_registers(bus___0->chain, 1);
#line 258
  i = 0;
  }
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 258
    if (! (i < 32)) {
#line 258
      goto while_break___0;
    }
    {
#line 259
    tmp = part_get_signal(p, ((bus_params_t___3 *)bus___0->params)->d[i]);
#line 259
    d |= (uint32_t )(tmp << i);
#line 258
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 261
  return (d);
}
}
#line 268 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
static void sh7751r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 271
  chain = bus___0->chain;
#line 272
  p = bus___0->part;
#line 276
  i = 0;
  {
#line 276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 276
    if (! (i < 8)) {
#line 276
      goto while_break;
    }
#line 277
    cs[i] = 1;
#line 276
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  cs[(adr & 469762048U) >> 26] = 0;
#line 280
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[0], 1, cs[0]);
#line 281
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[1], 1, cs[1]);
#line 282
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[2], 1, cs[2]);
#line 283
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[3], 1, cs[3]);
#line 284
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[4], 1, cs[4]);
#line 285
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[5], 1, cs[5]);
#line 286
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->cs[6], 1, cs[6]);
#line 288
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rdwr, 1, 0);
#line 289
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 290
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 291
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 292
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 293
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->rd, 1, 1);
#line 295
  setup_address___3(bus___0, adr);
#line 296
  setup_data___3(bus___0, data);
#line 297
  chain_shift_data_registers(chain, 0);
#line 299
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 0);
#line 300
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 0);
#line 301
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 0);
#line 302
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 0);
#line 304
  chain_shift_data_registers(chain, 0);
#line 306
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[0], 1, 1);
#line 307
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[1], 1, 1);
#line 308
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[2], 1, 1);
#line 309
  part_set_signal(p, ((bus_params_t___3 *)bus___0->params)->we[3], 1, 1);
#line 311
  chain_shift_data_registers(chain, 0);
  }
#line 312
  return;
}
}
#line 314 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7751r.c"
struct bus_driver  const  sh7751r_bus  = 
#line 314
     {"sh7751r", "Hitachi SH7751R compatible bus driver via BSR", & sh7751r_bus_new,
    & generic_bus_free, & sh7751r_bus_printinfo, & generic_bus_prepare_extest, & sh7751r_bus_area,
    & sh7751r_bus_read_start, & sh7751r_bus_read_next, & sh7751r_bus_read_end, & generic_bus_read,
    & sh7751r_bus_write, & generic_bus_no_init};
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  sh7750r_bus ;
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static bus_t *sh7750r_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 71
  failed = 0;
#line 73
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 73
  bus___0 = (bus_t *)tmp;
  }
#line 74
  if (! bus___0) {
#line 75
    return ((bus_t *)((void *)0));
  }
  {
#line 77
  bus___0->driver = driver;
#line 78
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___4 ));
  }
#line 79
  if (! bus___0->params) {
    {
#line 80
    free((void *)bus___0);
    }
#line 81
    return ((bus_t *)((void *)0));
  }
#line 84
  bus___0->chain = chain;
#line 85
  part = *((chain->parts)->parts + chain->active_part);
#line 85
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 26)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->a[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 32)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->d[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (i < 7)) {
#line 97
      goto while_break___1;
    }
    {
#line 98
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 99
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->cs[i],
                                     buff);
#line 99
    failed |= tmp___2;
#line 97
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 102
    if (! (i < 8)) {
#line 102
      goto while_break___2;
    }
    {
#line 103
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 104
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->we[i],
                                     buff);
#line 104
    failed |= tmp___3;
#line 102
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 107
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rdwr,
                                   (char *)"RDWR");
#line 107
  failed |= tmp___4;
#line 109
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rd,
                                   (char *)"RD");
#line 109
  failed |= tmp___5;
#line 111
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rdwr2,
                                   (char *)"RDWR2");
#line 111
  failed |= tmp___6;
#line 113
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___4 *)bus___0->params)->rd2,
                                   (char *)"RD2");
#line 113
  failed |= tmp___7;
  }
#line 115
  if (failed) {
    {
#line 116
    free(bus___0->params);
#line 117
    free((void *)bus___0);
    }
#line 118
    return ((bus_t *)((void *)0));
  }
#line 121
  return (bus___0);
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static void sh7750r_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 133
      goto while_break;
    }
#line 134
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 135
      goto while_break;
    }
#line 133
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 136
  tmp = gettext("Hitachi SH7750R compatible bus driver via BSR (JTAG part No. %d)\n");
#line 136
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 137
  return;
}
}
#line 143 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static int sh7750r_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 146
  area->description = (char const   *)((void *)0);
#line 147
  area->start = 0U;
#line 148
  area->length = 4294967296UL;
#line 149
  area->width = 32U;
#line 151
  return (0);
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static void setup_address___4(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 158
  p = bus___0->part;
#line 160
  i = 0;
  {
#line 160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 160
    if (! (i < 26)) {
#line 160
      goto while_break;
    }
    {
#line 161
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 160
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return;
}
}
#line 164 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static void set_data_in___4(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 168
  p = bus___0->part;
#line 170
  i = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (! (i < 32)) {
#line 170
      goto while_break;
    }
    {
#line 171
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 0, 0);
#line 170
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 172
  return;
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static void setup_data___4(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 178
  p = bus___0->part;
#line 180
  i = 0;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < 32)) {
#line 180
      goto while_break;
    }
    {
#line 181
    part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 180
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static void sh7750r_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 191
  p = bus___0->part;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 8)) {
#line 195
      goto while_break;
    }
#line 196
    cs[i] = 1;
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 197
  cs[(adr & 469762048U) >> 26] = 0;
#line 199
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 200
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 201
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 202
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 203
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 204
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 205
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 206
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 1);
#line 207
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 1);
#line 208
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 209
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 210
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 211
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 212
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 0);
#line 213
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 0);
#line 215
  setup_address___4(bus___0, adr);
#line 216
  set_data_in___4(bus___0);
#line 217
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 218
  return;
}
}
#line 224 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 227
  p = bus___0->part;
#line 229
  d = (uint32_t )0;
#line 231
  setup_address___4(bus___0, adr);
#line 232
  chain_shift_data_registers(bus___0->chain, 1);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < 32)) {
#line 234
      goto while_break;
    }
    {
#line 235
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 235
    d |= (uint32_t )(tmp << i);
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (d);
}
}
#line 244 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static uint32_t sh7750r_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
#line 247
  p = bus___0->part;
#line 250
  d = (uint32_t )0;
#line 252
  i = 0;
  {
#line 252
  while (1) {
    while_continue: /* CIL Label */ ;
#line 252
    if (! (i < 8)) {
#line 252
      goto while_break;
    }
#line 253
    cs[i] = 1;
#line 252
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 255
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 256
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 257
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 258
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 259
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 260
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 261
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 263
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 264
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 265
  chain_shift_data_registers(bus___0->chain, 1);
#line 267
  i = 0;
  }
  {
#line 267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (i < 32)) {
#line 267
      goto while_break___0;
    }
    {
#line 268
    tmp = part_get_signal(p, ((bus_params_t___4 *)bus___0->params)->d[i]);
#line 268
    d |= (uint32_t )(tmp << i);
#line 267
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 270
  return (d);
}
}
#line 277 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
static void sh7750r_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 280
  chain = bus___0->chain;
#line 281
  p = bus___0->part;
#line 285
  i = 0;
  {
#line 285
  while (1) {
    while_continue: /* CIL Label */ ;
#line 285
    if (! (i < 8)) {
#line 285
      goto while_break;
    }
#line 286
    cs[i] = 1;
#line 285
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 287
  cs[(adr & 469762048U) >> 26] = 0;
#line 289
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[0], 1, cs[0]);
#line 290
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[1], 1, cs[1]);
#line 291
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[2], 1, cs[2]);
#line 292
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[3], 1, cs[3]);
#line 293
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[4], 1, cs[4]);
#line 294
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[5], 1, cs[5]);
#line 295
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->cs[6], 1, cs[6]);
#line 297
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr, 1, 0);
#line 298
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rdwr2, 1, 0);
#line 299
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 300
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 301
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 302
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 303
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd, 1, 1);
#line 304
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->rd2, 1, 1);
#line 306
  setup_address___4(bus___0, adr);
#line 307
  setup_data___4(bus___0, data);
#line 309
  chain_shift_data_registers(chain, 0);
#line 311
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 0);
#line 312
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 0);
#line 313
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 0);
#line 314
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 0);
#line 316
  chain_shift_data_registers(chain, 0);
#line 318
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[0], 1, 1);
#line 319
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[1], 1, 1);
#line 320
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[2], 1, 1);
#line 321
  part_set_signal(p, ((bus_params_t___4 *)bus___0->params)->we[3], 1, 1);
#line 323
  chain_shift_data_registers(chain, 0);
  }
#line 324
  return;
}
}
#line 326 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7750r.c"
struct bus_driver  const  sh7750r_bus  = 
#line 326
     {"sh7750r", "Hitachi SH7750R compatible bus driver via BSR", & sh7750r_bus_new,
    & generic_bus_free, & sh7750r_bus_printinfo, & generic_bus_prepare_extest, & sh7750r_bus_area,
    & sh7750r_bus_read_start, & sh7750r_bus_read_next, & sh7750r_bus_read_end, & generic_bus_read,
    & sh7750r_bus_write, & generic_bus_no_init};
#line 55 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  sh7727_bus ;
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static bus_t *sh7727_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 71
  failed = 0;
#line 73
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 73
  bus___0 = (bus_t *)tmp;
  }
#line 74
  if (! bus___0) {
#line 75
    return ((bus_t *)((void *)0));
  }
  {
#line 77
  bus___0->driver = driver;
#line 78
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___5 ));
  }
#line 79
  if (! bus___0->params) {
    {
#line 80
    free((void *)bus___0);
    }
#line 81
    return ((bus_t *)((void *)0));
  }
#line 84
  bus___0->chain = chain;
#line 85
  part = *((chain->parts)->parts + chain->active_part);
#line 85
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 26)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->a[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 32)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->d[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 97
    if (! (i < 7)) {
#line 97
      goto while_break___1;
    }
#line 98
    if (i == 1) {
#line 99
      goto __Cont;
    }
    {
#line 100
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"CS%d",
            i);
#line 101
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->cs[i],
                                     buff);
#line 101
    failed |= tmp___2;
    }
    __Cont: /* CIL Label */ 
#line 97
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  i = 0;
  {
#line 104
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 104
    if (! (i < 4)) {
#line 104
      goto while_break___2;
    }
    {
#line 105
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WE%d",
            i);
#line 106
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->we[i],
                                     buff);
#line 106
    failed |= tmp___3;
#line 104
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 109
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->rdwr,
                                   (char *)"RDWR");
#line 109
  failed |= tmp___4;
#line 111
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->rd,
                                   (char *)"RD");
#line 111
  failed |= tmp___5;
#line 113
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->md3,
                                   (char *)"MD3");
#line 113
  failed |= tmp___6;
#line 115
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___5 *)bus___0->params)->md4,
                                   (char *)"MD4");
#line 115
  failed |= tmp___7;
  }
#line 117
  if (failed) {
    {
#line 118
    free(bus___0->params);
#line 119
    free((void *)bus___0);
    }
#line 120
    return ((bus_t *)((void *)0));
  }
#line 123
  return (bus___0);
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static void sh7727_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 135
  i = 0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 135
      goto while_break;
    }
#line 136
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 137
      goto while_break;
    }
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp = gettext("Hitachi SH7727 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 138
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 139
  return;
}
}
#line 145 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static int sh7727_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 148
  p = bus___0->part;
#line 150
  area->description = (char const   *)((void *)0);
#line 151
  area->start = 0U;
#line 152
  area->length = 4294967296UL;
#line 154
  tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md4);
#line 154
  tmp___0 = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->md3);
  }
  {
#line 155
  if (((tmp << 1) | tmp___0) == 1) {
#line 155
    goto case_1;
  }
#line 158
  if (((tmp << 1) | tmp___0) == 2) {
#line 158
    goto case_2;
  }
#line 161
  if (((tmp << 1) | tmp___0) == 3) {
#line 161
    goto case_3;
  }
#line 164
  goto switch_default;
  case_1: /* CIL Label */ 
#line 156
  area->width = 8U;
#line 157
  return (0);
  case_2: /* CIL Label */ 
#line 159
  area->width = 16U;
#line 160
  return (0);
  case_3: /* CIL Label */ 
#line 162
  area->width = 32U;
#line 163
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 165
  tmp___1 = gettext("Error: Invalid bus width (MD3 = MD4 = 0)!\n");
#line 165
  printf((char const   */* __restrict  */)tmp___1);
#line 166
  area->width = 0U;
  }
#line 167
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static void setup_address___5(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 175
  p = bus___0->part;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 26)) {
#line 177
      goto while_break;
    }
    {
#line 178
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 177
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static void set_data_in___5(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 185
  p = bus___0->part;
#line 188
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 190
  i = 0;
  }
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! ((unsigned int )i < area.width)) {
#line 190
      goto while_break;
    }
    {
#line 191
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 0, 0);
#line 190
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static void setup_data___5(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 198
  p = bus___0->part;
#line 201
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 203
  i = 0;
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (! ((unsigned int )i < area.width)) {
#line 203
      goto while_break;
    }
    {
#line 204
    part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 203
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 211 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static void sh7727_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 214
  p = bus___0->part;
#line 218
  i = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 8)) {
#line 218
      goto while_break;
    }
#line 219
    cs[i] = 1;
#line 218
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  cs[(adr & 469762048U) >> 26] = 0;
#line 222
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 223
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 224
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 225
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 226
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 227
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 228
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 1);
#line 229
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 231
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 232
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 233
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 0);
#line 235
  setup_address___5(bus___0, adr);
#line 236
  set_data_in___5(bus___0);
#line 238
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 239
  return;
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 248
  p = bus___0->part;
#line 250
  d = (uint32_t )0;
#line 253
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 255
  setup_address___5(bus___0, adr);
#line 256
  chain_shift_data_registers(bus___0->chain, 1);
#line 258
  i = 0;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! ((unsigned int )i < area.width)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 259
    d |= (uint32_t )(tmp << i);
#line 258
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (d);
}
}
#line 268 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static uint32_t sh7727_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 271
  p = bus___0->part;
#line 273
  d = (uint32_t )0;
#line 276
  sh7727_bus_area(bus___0, (uint32_t )0, & area);
#line 278
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, 1);
#line 279
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, 1);
#line 280
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, 1);
#line 281
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, 1);
#line 282
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, 1);
#line 283
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 286
  chain_shift_data_registers(bus___0->chain, 1);
#line 288
  i = 0;
  }
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if (! ((unsigned int )i < area.width)) {
#line 288
      goto while_break;
    }
    {
#line 289
    tmp = part_get_signal(p, ((bus_params_t___5 *)bus___0->params)->d[i]);
#line 289
    d |= (uint32_t )(tmp << i);
#line 288
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return (d);
}
}
#line 298 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
static void sh7727_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  part_t *p ;
  int cs[8] ;
  int i ;

  {
#line 301
  chain = bus___0->chain;
#line 302
  p = bus___0->part;
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
#line 306
    if (! (i < 8)) {
#line 306
      goto while_break;
    }
#line 307
    cs[i] = 1;
#line 306
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  cs[(adr & 469762048U) >> 26] = 0;
#line 310
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[0], 1, cs[0]);
#line 311
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[2], 1, cs[2]);
#line 312
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[3], 1, cs[3]);
#line 313
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[4], 1, cs[4]);
#line 314
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[5], 1, cs[5]);
#line 315
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->cs[6], 1, cs[6]);
#line 317
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rdwr, 1, 0);
#line 318
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 319
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 320
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 321
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 322
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->rd, 1, 1);
#line 324
  setup_address___5(bus___0, adr);
#line 325
  setup_data___5(bus___0, data);
#line 327
  chain_shift_data_registers(chain, 0);
#line 329
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 0);
#line 330
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 0);
#line 331
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 0);
#line 332
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 0);
#line 334
  chain_shift_data_registers(chain, 0);
#line 336
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[0], 1, 1);
#line 337
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[1], 1, 1);
#line 338
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[2], 1, 1);
#line 339
  part_set_signal(p, ((bus_params_t___5 *)bus___0->params)->we[3], 1, 1);
#line 341
  chain_shift_data_registers(chain, 0);
  }
#line 342
  return;
}
}
#line 344 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sh7727.c"
struct bus_driver  const  sh7727_bus  = 
#line 344
     {"sh7727", "Hitachi SH7727 compatible bus driver via BSR", & sh7727_bus_new, & generic_bus_free,
    & sh7727_bus_printinfo, & generic_bus_prepare_extest, & sh7727_bus_area, & sh7727_bus_read_start,
    & sh7727_bus_read_next, & sh7727_bus_read_end, & generic_bus_read, & sh7727_bus_write,
    & generic_bus_no_init};
#line 62 "../../include/part.h"
signal_t *part_find_signal(part_t *p , char const   *signalname ) ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  sa1110_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static bus_t *sa1110_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 70
  failed = 0;
#line 72
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 72
  bus___0 = (bus_t *)tmp;
  }
#line 73
  if (! bus___0) {
#line 74
    return ((bus_t *)((void *)0));
  }
  {
#line 76
  bus___0->driver = driver;
#line 77
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___6 ));
  }
#line 78
  if (! bus___0->params) {
    {
#line 79
    free((void *)bus___0);
    }
#line 80
    return ((bus_t *)((void *)0));
  }
#line 83
  bus___0->chain = chain;
#line 84
  part = *((chain->parts)->parts + chain->active_part);
#line 84
  bus___0->part = part;
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 26)) {
#line 86
      goto while_break;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 88
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->a[i],
                                     buff);
#line 88
    failed |= tmp___0;
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < 32)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 93
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->d[i],
                                     buff);
#line 93
    failed |= tmp___1;
#line 91
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (i < 6)) {
#line 96
      goto while_break___1;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 98
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->ncs[i],
                                     buff);
#line 98
    failed |= tmp___2;
#line 96
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 101
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->rd_nwr,
                                   (char *)"RD_nWR");
#line 101
  failed |= tmp___3;
#line 103
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->nwe,
                                   (char *)"nWE");
#line 103
  failed |= tmp___4;
#line 105
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___6 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 105
  failed |= tmp___5;
  }
#line 107
  if (failed) {
    {
#line 108
    free(bus___0->params);
#line 109
    free((void *)bus___0);
    }
#line 110
    return ((bus_t *)((void *)0));
  }
#line 113
  return (bus___0);
}
}
#line 120 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static void sa1110_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 125
  i = 0;
  {
#line 125
  while (1) {
    while_continue: /* CIL Label */ ;
#line 125
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 125
      goto while_break;
    }
#line 126
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 127
      goto while_break;
    }
#line 125
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  tmp = gettext("Intel SA-1110 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 128
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 129
  return;
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static int sa1110_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 138
  area->description = (char const   *)((void *)0);
#line 139
  area->start = 0U;
#line 140
  area->length = 4294967296UL;
#line 141
  tmp___1 = part_find_signal(bus___0->part, "ROM_SEL");
#line 141
  tmp___2 = part_get_signal(bus___0->part, tmp___1);
  }
#line 141
  if (tmp___2) {
#line 141
    area->width = 32U;
  } else {
#line 141
    area->width = 16U;
  }
#line 143
  return (0);
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static void setup_address___6(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 150
  p = bus___0->part;
#line 152
  i = 0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < 26)) {
#line 152
      goto while_break;
    }
    {
#line 153
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 152
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  return;
}
}
#line 156 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static void set_data_in___6(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 160
  p = bus___0->part;
#line 163
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 165
  i = 0;
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! ((unsigned int )i < area.width)) {
#line 165
      goto while_break;
    }
    {
#line 166
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 0, 0);
#line 165
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return;
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static void setup_data___6(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 173
  p = bus___0->part;
#line 176
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 178
  i = 0;
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! ((unsigned int )i < area.width)) {
#line 178
      goto while_break;
    }
    {
#line 179
    part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 178
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  return;
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static void sa1110_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 190
  p = bus___0->part;
#line 191
  chain = bus___0->chain;
#line 193
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 194
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 195
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 196
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 197
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 198
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 199
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 1);
#line 200
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 0);
#line 203
  setup_address___6(bus___0, adr);
#line 204
  set_data_in___6(bus___0);
#line 206
  chain_shift_data_registers(chain, 0);
  }
#line 207
  return;
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 217
  p = bus___0->part;
#line 218
  chain = bus___0->chain;
#line 220
  d = (uint32_t )0;
#line 223
  sa1110_bus_area(bus___0, adr, & area);
#line 225
  setup_address___6(bus___0, adr);
#line 226
  chain_shift_data_registers(chain, 1);
#line 228
  i = 0;
  }
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
#line 228
    if (! ((unsigned int )i < area.width)) {
#line 228
      goto while_break;
    }
    {
#line 229
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 229
    d |= (uint32_t )(tmp << i);
#line 228
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return (d);
}
}
#line 238 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static uint32_t sa1110_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 242
  p = bus___0->part;
#line 243
  chain = bus___0->chain;
#line 245
  d = (uint32_t )0;
#line 248
  sa1110_bus_area(bus___0, (uint32_t )0, & area);
#line 250
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 251
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 252
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 253
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 254
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 255
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 256
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 257
  chain_shift_data_registers(chain, 1);
#line 259
  i = 0;
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! ((unsigned int )i < area.width)) {
#line 259
      goto while_break;
    }
    {
#line 260
    tmp = part_get_signal(p, ((bus_params_t___6 *)bus___0->params)->d[i]);
#line 260
    d |= (uint32_t )(tmp << i);
#line 259
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (d);
}
}
#line 269 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
static void sa1110_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 273
  p = bus___0->part;
#line 274
  chain = bus___0->chain;
#line 276
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 277
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, adr >> 27 != 1U);
#line 278
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, adr >> 27 != 2U);
#line 279
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, adr >> 27 != 3U);
#line 280
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, adr >> 27 != 8U);
#line 281
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, adr >> 27 != 9U);
#line 282
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->rd_nwr, 1, 0);
#line 283
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 284
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->noe, 1, 1);
#line 286
  setup_address___6(bus___0, adr);
#line 287
  setup_data___6(bus___0, data);
#line 289
  chain_shift_data_registers(chain, 0);
#line 291
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 0);
#line 292
  chain_shift_data_registers(chain, 0);
#line 293
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->nwe, 1, 1);
#line 294
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[0], 1, 1);
#line 295
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[1], 1, 1);
#line 296
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[2], 1, 1);
#line 297
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[3], 1, 1);
#line 298
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[4], 1, 1);
#line 299
  part_set_signal(p, ((bus_params_t___6 *)bus___0->params)->ncs[5], 1, 1);
#line 300
  chain_shift_data_registers(chain, 0);
  }
#line 301
  return;
}
}
#line 303 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/sa1110.c"
struct bus_driver  const  sa1110_bus  = 
#line 303
     {"sa1110", "Intel SA-1110 compatible bus driver via BSR", & sa1110_bus_new, & generic_bus_free,
    & sa1110_bus_printinfo, & generic_bus_prepare_extest, & sa1110_bus_area, & sa1110_bus_read_start,
    & sa1110_bus_read_next, & sa1110_bus_read_end, & generic_bus_read, & sa1110_bus_write,
    & generic_bus_no_init};
#line 53 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  s3c4510_bus ;
#line 103 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static bus_t *s3c4510_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 110
  failed = 0;
#line 112
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 112
  bus___0 = (bus_t *)tmp;
  }
#line 113
  if (! bus___0) {
#line 114
    return ((bus_t *)((void *)0));
  }
  {
#line 116
  bus___0->driver = driver;
#line 117
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___7 ));
  }
#line 118
  if (! bus___0->params) {
    {
#line 119
    free((void *)bus___0);
    }
#line 120
    return ((bus_t *)((void *)0));
  }
#line 124
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = 16;
#line 125
  bus___0->chain = chain;
#line 126
  part = *((chain->parts)->parts + chain->active_part);
#line 126
  bus___0->part = part;
#line 128
  i = 0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < 22)) {
#line 128
      goto while_break;
    }
    {
#line 129
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i);
#line 130
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->a[i],
                                     buff);
#line 130
    failed |= tmp___0;
#line 128
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  i = 0;
  {
#line 133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 133
    if (! (i < 32)) {
#line 133
      goto while_break___0;
    }
    {
#line 134
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"XDATA%d",
            i);
#line 135
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->d[i],
                                     buff);
#line 135
    failed |= tmp___1;
#line 133
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  i = 0;
  {
#line 138
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 138
    if (! (i < 6)) {
#line 138
      goto while_break___1;
    }
    {
#line 139
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 140
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->nrcs[i],
                                     buff);
#line 140
    failed |= tmp___2;
#line 138
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 143
  i = 0;
  {
#line 143
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 143
    if (! (i < 4)) {
#line 143
      goto while_break___2;
    }
    {
#line 144
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nECS%d",
            i);
#line 145
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->necs[i],
                                     buff);
#line 145
    failed |= tmp___3;
#line 143
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 148
    if (! (i < 4)) {
#line 148
      goto while_break___3;
    }
    {
#line 149
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRAS%d",
            i);
#line 150
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->nsdcs[i],
                                     buff);
#line 150
    failed |= tmp___4;
#line 148
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 153
    if (! (i < 4)) {
#line 153
      goto while_break___4;
    }
    {
#line 154
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nWBE%d",
            i);
#line 155
    tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->nwbe[i],
                                     buff);
#line 155
    failed |= tmp___5;
#line 153
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 158
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___7 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 158
  failed |= tmp___6;
  }
#line 160
  if (failed) {
    {
#line 161
    free(bus___0->params);
#line 162
    free((void *)bus___0);
    }
#line 163
    return ((bus_t *)((void *)0));
  }
#line 166
  return (bus___0);
}
}
#line 173 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void s3c4510_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 178
  i = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 178
      goto while_break;
    }
#line 179
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 180
      goto while_break;
    }
#line 178
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  tmp = gettext("Samsung S3C4510B compatibile bus driver via BSR (JTAG part No. %d) RCS0=%ubit\n");
#line 181
  printf((char const   */* __restrict  */)tmp, i, ((bus_params_t___7 *)bus___0->params)->dbuswidth);
  }
#line 182
  return;
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static int s3c4510_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 191
  p = bus___0->part;
#line 192
  chain = bus___0->chain;
#line 194
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 195
  chain_shift_instructions(chain);
#line 196
  chain_shift_data_registers(chain, 0);
#line 198
  bus___0->initialized = 1;
  }
#line 200
  return (0);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static int s3c4510_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  int b0size0 ;
  int b0size1 ;
  signal_t *tmp ;
  signal_t *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 212
  area->description = (char const   *)((void *)0);
#line 213
  area->start = 0U;
#line 214
  area->length = 4294967296UL;
#line 217
  tmp = part_find_signal(bus___0->part, "B0SIZE0");
#line 217
  b0size0 = part_get_signal(bus___0->part, tmp);
#line 218
  tmp___0 = part_find_signal(bus___0->part, "B0SIZE1");
#line 218
  b0size1 = part_get_signal(bus___0->part, tmp___0);
  }
  {
#line 221
  if (((b0size1 << 1) | b0size0) == 1) {
#line 221
    goto case_1;
  }
#line 224
  if (((b0size1 << 1) | b0size0) == 2) {
#line 224
    goto case_2;
  }
#line 227
  if (((b0size1 << 1) | b0size0) == 3) {
#line 227
    goto case_3;
  }
#line 230
  goto switch_default;
  case_1: /* CIL Label */ 
#line 222
  tmp___1 = 8;
#line 222
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___1;
#line 222
  area->width = (unsigned int )tmp___1;
#line 223
  return (0);
  case_2: /* CIL Label */ 
#line 225
  tmp___2 = 16;
#line 225
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___2;
#line 225
  area->width = (unsigned int )tmp___2;
#line 226
  return (0);
  case_3: /* CIL Label */ 
#line 228
  tmp___3 = 32;
#line 228
  ((bus_params_t___7 *)bus___0->params)->dbuswidth = tmp___3;
#line 228
  area->width = (unsigned int )tmp___3;
#line 229
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 231
  printf((char const   */* __restrict  */)"B0SIZE[1:0]: Unknown\n");
#line 232
  area->width = 0U;
  }
#line 233
  return (-1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void s3c4510_bus_setup_ctrl(bus_t *bus___0 , int mode ) 
{ 
  int k ;
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 240
  p = bus___0->part;
#line 242
  k = 0;
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 242
    if (! (k < 6)) {
#line 242
      goto while_break;
    }
#line 243
    if (mode & (1 << k)) {
#line 243
      tmp = 1;
    } else {
#line 243
      tmp = 0;
    }
    {
#line 243
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nrcs[k], 1, tmp);
#line 242
    k ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  k = 0;
  {
#line 245
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 245
    if (! (k < 4)) {
#line 245
      goto while_break___0;
    }
    {
#line 246
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->necs[k], 1, 1);
#line 245
    k ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 248
  k = 0;
  {
#line 248
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 248
    if (! (k < 4)) {
#line 248
      goto while_break___1;
    }
    {
#line 249
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nsdcs[k], 1, 1);
#line 248
    k ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 251
  k = 0;
  {
#line 251
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 251
    if (! (k < 4)) {
#line 251
      goto while_break___2;
    }
#line 252
    if (mode & (1 << (k + 8))) {
#line 252
      tmp___0 = 1;
    } else {
#line 252
      tmp___0 = 0;
    }
    {
#line 252
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->nwbe[k], 1, tmp___0);
#line 251
    k ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 254
  if (mode & (1 << 16)) {
#line 254
    tmp___1 = 1;
  } else {
#line 254
    tmp___1 = 0;
  }
  {
#line 254
  part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->noe, 1, tmp___1);
  }
#line 255
  return;
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void setup_address___7(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  int so ;
  part_t *p ;

  {
#line 261
  p = bus___0->part;
  {
#line 265
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 265
    goto case_32;
  }
#line 266
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 266
    goto case_16;
  }
#line 267
  goto switch_default;
  case_32: /* CIL Label */ 
#line 265
  so = 2;
#line 265
  goto switch_break;
  case_16: /* CIL Label */ 
#line 266
  so = 1;
#line 266
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 267
  so = 0;
#line 267
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 270
  i = 0;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (i < 22)) {
#line 270
      goto while_break;
    }
    {
#line 271
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->a[i], 1, (int )((a >> (i + so)) & 1U));
#line 270
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  return;
}
}
#line 274 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void set_data_in___7(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 278
  p = bus___0->part;
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 280
      goto while_break;
    }
    {
#line 281
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 0, 0);
#line 280
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return;
}
}
#line 284 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void setup_data___7(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 288
  p = bus___0->part;
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 290
      goto while_break;
    }
    {
#line 291
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 290
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  i = ((bus_params_t___7 *)bus___0->params)->dbuswidth;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (i < 32)) {
#line 293
      goto while_break___0;
    }
    {
#line 294
    part_set_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i], 1, 0);
#line 293
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 301 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void s3c4510_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;

  {
  {
#line 305
  chain = bus___0->chain;
#line 307
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 308
  setup_address___7(bus___0, adr);
#line 309
  set_data_in___7(bus___0);
#line 310
  chain_shift_data_registers(chain, 0);
  }
#line 311
  return;
}
}
#line 317 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 321
  p = bus___0->part;
#line 322
  chain = bus___0->chain;
#line 324
  d = (uint32_t )0;
#line 326
  s3c4510_bus_setup_ctrl(bus___0, 65534);
#line 327
  setup_address___7(bus___0, adr);
#line 328
  set_data_in___7(bus___0);
#line 329
  chain_shift_data_registers(chain, 1);
#line 331
  i = 0;
  }
  {
#line 331
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 331
      goto while_break;
    }
    {
#line 332
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 332
    d |= (uint32_t )(tmp << i);
#line 331
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  return (d);
}
}
#line 341 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static uint32_t s3c4510_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 345
  p = bus___0->part;
#line 346
  chain = bus___0->chain;
#line 348
  d = (uint32_t )0;
#line 350
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 351
  chain_shift_data_registers(chain, 1);
#line 353
  i = 0;
  }
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (! (i < ((bus_params_t___7 *)bus___0->params)->dbuswidth)) {
#line 353
      goto while_break;
    }
    {
#line 354
    tmp = part_get_signal(p, ((bus_params_t___7 *)bus___0->params)->d[i]);
#line 354
    d |= (uint32_t )(tmp << i);
#line 353
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (d);
}
}
#line 365 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
static void s3c4510_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;

  {
  {
#line 369
  chain = bus___0->chain;
#line 371
  s3c4510_bus_setup_ctrl(bus___0, 131070);
#line 372
  setup_address___7(bus___0, adr);
#line 373
  setup_data___7(bus___0, data);
#line 375
  chain_shift_data_registers(chain, 0);
  }
  {
#line 383
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 16) {
#line 383
    goto case_16;
  }
#line 387
  if (((bus_params_t___7 *)bus___0->params)->dbuswidth == 32) {
#line 387
    goto case_32;
  }
#line 379
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 381
  s3c4510_bus_setup_ctrl(bus___0, 130814);
  }
#line 382
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 384
  s3c4510_bus_setup_ctrl(bus___0, 130302);
  }
#line 385
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 388
  s3c4510_bus_setup_ctrl(bus___0, 127230);
  }
#line 389
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 392
  setup_address___7(bus___0, adr);
#line 393
  setup_data___7(bus___0, data);
#line 395
  chain_shift_data_registers(chain, 0);
#line 397
  s3c4510_bus_setup_ctrl(bus___0, 131071);
#line 398
  chain_shift_data_registers(chain, 0);
  }
#line 401
  return;
}
}
#line 403 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/s3c4510x.c"
struct bus_driver  const  s3c4510_bus  = 
#line 403
     {"s3c4510x", "Samsung S3C4510B compatible bus driver via BSR", & s3c4510_bus_new,
    & generic_bus_free, & s3c4510_bus_printinfo, & generic_bus_prepare_extest, & s3c4510_bus_area,
    & s3c4510_bus_read_start, & s3c4510_bus_read_next, & s3c4510_bus_read_end, & generic_bus_read,
    & s3c4510_bus_write, & s3c4510_bus_init};
#line 53 "../../include/jtag.h"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) ;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/readmem.c"
void readmem(bus_t *bus___0 , FILE *f , uint32_t addr , uint32_t len ) 
{ 
  uint32_t step ;
  uint32_t a ;
  int bc ;
  uint8_t b[4096] ;
  bus_area_t area ;
  uint64_t end ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  uint32_t data ;
  int j ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 48
  bc = 0;
#line 54
  if (! bus___0) {
    {
#line 55
    tmp = gettext("Error: Missing bus driver!\n");
#line 55
    printf((char const   */* __restrict  */)tmp);
    }
#line 56
    return;
  }
  {
#line 59
  (*((bus___0->driver)->prepare))(bus___0);
#line 61
  tmp___1 = (*((bus___0->driver)->area))(bus___0, addr, & area);
  }
#line 61
  if (tmp___1 != 0) {
    {
#line 62
    tmp___0 = gettext("Error: Bus width detection failed\n");
#line 62
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 63
    return;
  }
#line 65
  step = area.width / 8U;
#line 67
  if (step == 0U) {
    {
#line 68
    tmp___2 = gettext("Unknown bus width!\n");
#line 68
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 69
    return;
  }
  {
#line 72
  addr &= ~ (step - 1U);
#line 73
  len = ((len + step) - 1U) & ~ (step - 1U);
#line 75
  tmp___3 = gettext("address: 0x%08X\n");
#line 75
  printf((char const   */* __restrict  */)tmp___3, addr);
#line 76
  tmp___4 = gettext("length:  0x%08X\n");
#line 76
  printf((char const   */* __restrict  */)tmp___4, len);
  }
#line 78
  if (len == 0U) {
    {
#line 79
    tmp___5 = gettext("length is 0.\n");
#line 79
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 80
    return;
  }
  {
#line 83
  a = addr;
#line 84
  end = (uint64_t )(a + len);
#line 85
  tmp___6 = gettext("reading:\n");
#line 85
  printf((char const   */* __restrict  */)tmp___6);
#line 86
  (*((bus___0->driver)->read_start))(bus___0, addr);
#line 87
  a += step;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! ((uint64_t )a <= end)) {
#line 87
      goto while_break;
    }
#line 91
    if (a < addr + len) {
      {
#line 92
      data = (*((bus___0->driver)->read_next))(bus___0, a);
      }
    } else {
      {
#line 94
      data = (*((bus___0->driver)->read_end))(bus___0);
      }
    }
#line 96
    j = (int )step;
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 96
      if (! (j > 0)) {
#line 96
        goto while_break___0;
      }
#line 97
      if (big_endian) {
#line 98
        tmp___7 = bc;
#line 98
        bc ++;
#line 98
        b[tmp___7] = (uint8_t )((data >> (j - 1) * 8) & 255U);
      } else {
#line 100
        tmp___8 = bc;
#line 100
        bc ++;
#line 100
        b[tmp___8] = (uint8_t )(data & 255U);
#line 101
        data >>= 8;
      }
#line 96
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 104
    if (bc >= 4096) {
#line 104
      goto _L;
    } else
#line 104
    if ((uint64_t )a >= end) {
      _L: /* CIL Label */ 
      {
#line 105
      tmp___9 = gettext("addr: 0x%08X");
#line 105
      printf((char const   */* __restrict  */)tmp___9, a);
#line 106
      printf((char const   */* __restrict  */)"\r");
#line 107
      fflush(stdout);
#line 108
      fwrite((void const   */* __restrict  */)(b), (size_t )bc, (size_t )1, (FILE */* __restrict  */)f);
#line 109
      bc = 0;
      }
    }
#line 87
    a += step;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 113
  tmp___10 = gettext("\nDone.\n");
#line 113
  printf((char const   */* __restrict  */)tmp___10);
  }
#line 114
  return;
}
}
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 51 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  pxa2x0_bus ;
#line 52
struct bus_driver  const  pxa27x_bus ;
#line 84 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static ncs_map_entry pxa25x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)((void *)0), 0, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static ncs_map_entry pxa27x_ncs_map[6]  = {      {(char *)"nCS[0]", 1, 0, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                               (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[15]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[78]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[79]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[80]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}, 
        {(char *)"GPIO[33]", 1, 16, {(char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0, (char)0, (char)0, (char)0,
                                  (char)0, (char)0, (char)0}}};
#line 140 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static bus_t *pxa2xx_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  part_t *part ;
  bus_t *bus___0 ;
  ncs_map_entry *ncs_map ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 145
  ncs_map = (ncs_map_entry *)((void *)0);
#line 148
  failed = 0;
#line 150
  if (! chain) {
#line 151
    return ((bus_t *)((void *)0));
  } else
#line 150
  if (! chain->parts) {
#line 151
    return ((bus_t *)((void *)0));
  } else
#line 150
  if ((chain->parts)->len <= chain->active_part) {
#line 151
    return ((bus_t *)((void *)0));
  } else
#line 150
  if (chain->active_part < 0) {
#line 151
    return ((bus_t *)((void *)0));
  }
  {
#line 153
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 153
  bus___0 = (bus_t *)tmp;
  }
#line 154
  if (! bus___0) {
#line 155
    return ((bus_t *)((void *)0));
  }
  {
#line 157
  bus___0->driver = driver;
#line 158
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___8 ));
  }
#line 159
  if (! bus___0->params) {
    {
#line 160
    free((void *)bus___0);
    }
#line 161
    return ((bus_t *)((void *)0));
  }
  {
#line 164
  bus___0->chain = chain;
#line 165
  part = *((chain->parts)->parts + chain->active_part);
#line 165
  bus___0->part = part;
#line 166
  tmp___1 = strcmp((char const   *)driver->name, "pxa2x0");
  }
#line 166
  if (tmp___1 == 0) {
#line 167
    ((bus_params_t___8 *)bus___0->params)->proc = 1;
  } else {
    {
#line 168
    tmp___0 = strcmp((char const   *)driver->name, "pxa27x");
    }
#line 168
    if (tmp___0 == 0) {
#line 169
      ((bus_params_t___8 *)bus___0->params)->proc = 2;
    } else {
      {
#line 171
      free(bus___0->params);
#line 172
      free((void *)bus___0);
      }
#line 173
      return ((bus_t *)((void *)0));
    }
  }
#line 176
  i = 0;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (i < 26)) {
#line 176
      goto while_break;
    }
    {
#line 177
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MA[%d]",
            i);
#line 178
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->ma[i],
                                     buff);
#line 178
    failed |= tmp___2;
#line 176
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  i = 0;
  {
#line 181
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 181
    if (! (i < 32)) {
#line 181
      goto while_break___0;
    }
    {
#line 182
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MD[%d]",
            i);
#line 183
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->md[i],
                                     buff);
#line 183
    failed |= tmp___3;
#line 181
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 186
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
#line 187
    ncs_map = pxa25x_ncs_map;
  } else
#line 189
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
#line 190
    ncs_map = pxa27x_ncs_map;
  } else {
    {
#line 194
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d: unknown PROC\n",
           "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c", 194);
#line 195
    ncs_map = pxa25x_ncs_map;
    }
  }
#line 197
  i = 0;
  {
#line 197
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 197
    if (! (i < 6)) {
#line 197
      goto while_break___1;
    }
#line 198
    if ((ncs_map + i)->enabled > 0) {
      {
#line 199
      tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->ncs[i],
                                       (ncs_map + i)->sig_name);
#line 199
      failed |= tmp___4;
      }
    } else {
#line 203
      ((bus_params_t___8 *)bus___0->params)->ncs[i] = (signal_t *)((void *)0);
    }
#line 197
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 207
  i = 0;
  {
#line 207
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 207
    if (! (i < 4)) {
#line 207
      goto while_break___2;
    }
    {
#line 208
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DQM[%d]",
            i);
#line 209
    tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->dqm[i],
                                     buff);
#line 209
    failed |= tmp___5;
#line 207
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 212
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->rdnwr,
                                   (char *)"RDnWR");
#line 212
  failed |= tmp___6;
#line 214
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->nwe,
                                   (char *)"nWE");
#line 214
  failed |= tmp___7;
#line 216
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 216
  failed |= tmp___8;
#line 218
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___8 *)bus___0->params)->nsdcas,
                                   (char *)"nSDCAS");
#line 218
  failed |= tmp___9;
  }
#line 220
  if (failed) {
    {
#line 221
    free(bus___0->params);
#line 222
    free((void *)bus___0);
    }
#line 223
    return ((bus_t *)((void *)0));
  }
#line 226
  return (bus___0);
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static void pxa2xx_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 238
      goto while_break;
    }
#line 239
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 240
      goto while_break;
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 241
  tmp = gettext("%s (JTAG part No. %d)\n");
#line 241
  printf((char const   */* __restrict  */)tmp, (bus___0->driver)->description, i);
  }
#line 242
  return;
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static int pxa2xx_bus_init(bus_t *bus___0 ) 
{ 
  chain_t *chain ;
  part_t *p ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  signal_t *tmp___3 ;
  int tmp___4 ;
  signal_t *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 251
  chain = bus___0->chain;
#line 252
  p = bus___0->part;
#line 254
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 255
  chain_shift_instructions(chain);
#line 256
  chain_shift_data_registers(chain, 1);
  }
#line 258
  if (((bus_params_t___8 *)bus___0->params)->proc == 1) {
    {
#line 260
    tmp = part_find_signal(p, "BOOT_SEL[2]");
#line 260
    tmp___0 = part_get_signal(p, tmp);
#line 260
    tmp___1 = part_find_signal(p, "BOOT_SEL[1]");
#line 260
    tmp___2 = part_get_signal(p, tmp___1);
#line 260
    tmp___3 = part_find_signal(p, "BOOT_SEL[0]");
#line 260
    tmp___4 = part_get_signal(p, tmp___3);
#line 260
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | ((((tmp___0 << 2) | (tmp___2 << 1)) | tmp___4) & ((2 << 2) - 1)));
    }
  } else
#line 265
  if (((bus_params_t___8 *)bus___0->params)->proc == 2) {
    {
#line 267
    tmp___5 = part_find_signal(p, "BOOT_SEL");
#line 267
    tmp___6 = part_get_signal(p, tmp___5);
#line 267
    ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def = (uint32_t volatile   )((1 << 3) | (tmp___6 & ((2 << 2) - 1)));
    }
  } else {
    {
#line 271
    printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
           "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c", 271);
    }
  }
  {
#line 273
  part_set_instruction(p, "BYPASS");
#line 274
  chain_shift_instructions(chain);
#line 276
  bus___0->initialized = 1;
  }
#line 278
  return (0);
}
}
#line 285 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static int pxa2xx_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;

  {
#line 292
  if (adr < 67108864U) {
#line 293
    area->description = "Static Chip Select 0";
#line 294
    area->start = 0U;
#line 295
    area->length = 67108864UL;
#line 297
    if (pxa25x_ncs_map[0].bus_width > 0) {
#line 299
      area->width = (unsigned int )pxa25x_ncs_map[0].bus_width;
    } else {
      {
#line 305
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 305
        goto case_0;
      }
#line 308
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 308
        goto case_1;
      }
#line 312
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 312
        goto case_3;
      }
#line 312
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 312
        goto case_3;
      }
#line 318
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 318
        goto case_7;
      }
#line 318
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 318
        goto case_7;
      }
#line 318
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 318
        goto case_7;
      }
#line 318
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 318
        goto case_7;
      }
#line 321
      goto switch_default;
      case_0: /* CIL Label */ 
#line 306
      area->width = 32U;
#line 307
      goto switch_break;
      case_1: /* CIL Label */ 
#line 309
      area->width = 16U;
#line 310
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 313
      area->width = 0U;
#line 314
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 319
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 320
      return (-1);
      switch_default: /* CIL Label */ 
      {
#line 322
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c", 322);
      }
#line 323
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 326
    return (0);
  }
#line 330
  ncs_index = 1;
#line 330
  tmp_addr = (uint32_t )67108864;
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (ncs_index <= 5)) {
#line 330
      goto while_break;
    }
#line 332
    if (adr >= tmp_addr) {
#line 332
      if (adr < tmp_addr + 67108864U) {
#line 333
        if (pxa25x_ncs_map[ncs_index].enabled) {
#line 333
          tmp = "";
        } else {
#line 333
          tmp = "(disabled)";
        }
        {
#line 333
        sprintf((char */* __restrict  */)(pxa25x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa25x_ncs_map[ncs_index].sig_name, tmp);
#line 336
        area->description = (char const   *)(pxa25x_ncs_map[ncs_index].label_buf);
#line 337
        area->start = tmp_addr;
#line 338
        area->length = 67108864UL;
#line 339
        area->width = (unsigned int )pxa25x_ncs_map[ncs_index].bus_width;
        }
#line 341
        return (0);
      }
    }
#line 330
    ncs_index ++;
#line 330
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  if (adr < 1207959552U) {
#line 346
    area->description = (char const   *)((void *)0);
#line 347
    area->start = 402653184U;
#line 348
    area->length = 805306368UL;
#line 349
    area->width = 0U;
#line 351
    return (0);
  }
#line 354
  if (adr < 1275068416U) {
#line 355
    area->description = "Memory Mapped registers (Memory Ctl)";
#line 356
    area->start = 1207959552U;
#line 357
    area->length = 67108864UL;
#line 358
    area->width = 32U;
#line 360
    return (0);
  }
#line 363
  area->description = (char const   *)((void *)0);
#line 364
  area->start = 1275068416U;
#line 365
  area->length = 3019898880UL;
#line 366
  area->width = 0U;
#line 368
  return (0);
}
}
#line 375 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static int pxa27x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  uint32_t tmp_addr ;
  int ncs_index ;
  char const   *tmp ;

  {
#line 382
  if (adr < 67108864U) {
#line 383
    area->description = "Static Chip Select 0";
#line 384
    area->start = 0U;
#line 385
    area->length = 67108864UL;
#line 387
    if (pxa27x_ncs_map[0].bus_width > 0) {
#line 389
      area->width = (unsigned int )pxa27x_ncs_map[0].bus_width;
    } else {
      {
#line 395
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )0) {
#line 395
        goto case_0;
      }
#line 398
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )1) {
#line 398
        goto case_1;
      }
#line 402
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )3) {
#line 402
        goto case_3;
      }
#line 402
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )2) {
#line 402
        goto case_3;
      }
#line 408
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )7) {
#line 408
        goto case_7;
      }
#line 408
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )6) {
#line 408
        goto case_7;
      }
#line 408
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )5) {
#line 408
        goto case_7;
      }
#line 408
      if ((((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1)) == (unsigned int volatile   )4) {
#line 408
        goto case_7;
      }
#line 411
      goto switch_default;
      case_0: /* CIL Label */ 
#line 396
      area->width = 32U;
#line 397
      goto switch_break;
      case_1: /* CIL Label */ 
#line 399
      area->width = 16U;
#line 400
      goto switch_break;
      case_3: /* CIL Label */ 
      case_2: /* CIL Label */ 
#line 403
      area->width = 0U;
#line 404
      goto switch_break;
      case_7: /* CIL Label */ 
      case_6: /* CIL Label */ 
      case_5: /* CIL Label */ 
      case_4: /* CIL Label */ 
      {
#line 409
      printf((char const   */* __restrict  */)"TODO - BOOT_SEL: %d\n", ((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def & (unsigned int volatile   )((2 << 2) - 1));
      }
#line 410
      return (-1);
      switch_default: /* CIL Label */ 
      {
#line 412
      printf((char const   */* __restrict  */)"BUG in the code, file %s, line %d.\n",
             "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c", 412);
      }
#line 413
      return (-1);
      switch_break: /* CIL Label */ ;
      }
    }
#line 416
    return (0);
  }
#line 420
  ncs_index = 1;
#line 420
  tmp_addr = (uint32_t )67108864;
  {
#line 420
  while (1) {
    while_continue: /* CIL Label */ ;
#line 420
    if (! (ncs_index <= 5)) {
#line 420
      goto while_break;
    }
#line 423
    if (adr >= tmp_addr) {
#line 423
      if (adr < tmp_addr + 67108864U) {
#line 425
        if (pxa27x_ncs_map[ncs_index].enabled) {
#line 425
          tmp = "";
        } else {
#line 425
          tmp = "(disabled)";
        }
        {
#line 425
        sprintf((char */* __restrict  */)(pxa27x_ncs_map[ncs_index].label_buf), (char const   */* __restrict  */)"Static Chip Select %d = %s %s",
                ncs_index, pxa27x_ncs_map[ncs_index].sig_name, tmp);
#line 428
        area->description = (char const   *)(pxa27x_ncs_map[ncs_index].label_buf);
#line 429
        area->start = tmp_addr;
#line 430
        area->length = 67108864UL;
#line 431
        area->width = (unsigned int )pxa27x_ncs_map[ncs_index].bus_width;
        }
#line 433
        return (0);
      }
    }
#line 420
    ncs_index ++;
#line 420
    tmp_addr += 67108864U;
  }
  while_break: /* CIL Label */ ;
  }
#line 438
  if (adr < 1073741824U) {
#line 439
    area->description = (char const   *)((void *)0);
#line 440
    area->start = 402653184U;
#line 441
    area->length = 671088640UL;
#line 442
    area->width = 0U;
#line 444
    return (0);
  }
#line 447
  if (adr < 1610612736U) {
#line 448
    area->description = "PXA270 internal address space (cfg, SRAM)";
#line 449
    area->start = 1073741824U;
#line 450
    area->length = 536870912UL;
#line 451
    area->width = 32U;
#line 453
    return (0);
  }
#line 456
  if (adr < 2684354560U) {
#line 457
    area->description = (char const   *)((void *)0);
#line 458
    area->start = 1610612736U;
#line 459
    area->length = 1073741824UL;
#line 460
    area->width = 0U;
#line 462
    return (0);
  }
#line 465
  if (adr < 2952790016U) {
#line 466
    area->description = "PXA270 SDRAM space (4x 64MB)";
#line 467
    area->start = 2684354560U;
#line 468
    area->length = 268435456UL;
#line 469
    area->width = 32U;
#line 471
    return (0);
  }
#line 474
  area->description = (char const   *)((void *)0);
#line 475
  area->start = 2952790016U;
#line 476
  area->length = 1342177280UL;
#line 477
  area->width = 0U;
#line 479
  return (0);
}
}
#line 482 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static void setup_address___8(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 486
  p = bus___0->part;
#line 488
  i = 0;
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! (i < 26)) {
#line 488
      goto while_break;
    }
    {
#line 489
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ma[i], 1, (int )((a >> i) & 1U));
#line 488
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 490
  return;
}
}
#line 492 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static void set_data_in___8(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 496
  p = bus___0->part;
#line 499
  (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 501
  i = 0;
  }
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! ((unsigned int )i < area.width)) {
#line 501
      goto while_break;
    }
    {
#line 502
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 0, 0);
#line 501
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  return;
}
}
#line 505 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static void setup_data___8(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 509
  p = bus___0->part;
#line 512
  (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 514
  i = 0;
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! ((unsigned int )i < area.width)) {
#line 514
      goto while_break;
    }
    {
#line 515
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i], 1, (int )((d >> i) & 1U));
#line 514
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 516
  return;
}
}
#line 522 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static void pxa2xx_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  int cs_index ;
  chain_t *chain ;
  part_t *p ;

  {
#line 525
  cs_index = 0;
#line 527
  chain = bus___0->chain;
#line 528
  p = bus___0->part;
#line 530
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 531
  if (adr >= 402653184U) {
#line 532
    return;
  }
#line 534
  cs_index = (int )(adr >> 26);
#line 535
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 536
    return;
  }
  {
#line 539
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 540
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 541
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 542
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 543
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 544
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 1);
#line 545
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 546
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 0);
#line 547
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 549
  setup_address___8(bus___0, adr);
#line 550
  set_data_in___8(bus___0, adr);
#line 552
  chain_shift_data_registers(chain, 0);
  }
#line 553
  return;
}
}
#line 559 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t d ;
  uint32_t old_last_adr ;
  int i ;
  bus_area_t area ;
  int tmp ;

  {
#line 562
  p = bus___0->part;
#line 563
  chain = bus___0->chain;
#line 565
  old_last_adr = ((bus_params_t___8 *)bus___0->params)->last_adr;
#line 567
  ((bus_params_t___8 *)bus___0->params)->last_adr = adr;
#line 569
  if (adr < 402653184U) {
#line 573
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[adr >> 26] == (unsigned long )((void *)0)) {
#line 574
      return ((uint32_t )0);
    }
    {
#line 576
    (*((bus___0->driver)->area))(bus___0, adr, & area);
#line 579
    setup_address___8(bus___0, adr);
#line 580
    chain_shift_data_registers(chain, 1);
#line 582
    d = (uint32_t )0;
#line 583
    i = 0;
    }
    {
#line 583
    while (1) {
      while_continue: /* CIL Label */ ;
#line 583
      if (! ((unsigned int )i < area.width)) {
#line 583
        goto while_break;
      }
      {
#line 584
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 584
      d |= (uint32_t )(tmp << i);
#line 583
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 586
    return (d);
  }
#line 590
  if (adr < 1207959552U) {
#line 591
    return ((uint32_t )0);
  }
#line 593
  if (adr < 1275068416U) {
#line 594
    if (old_last_adr == 1207959620U) {
#line 595
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 597
    return ((uint32_t )0);
  }
#line 600
  return ((uint32_t )0);
}
}
#line 607 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static uint32_t pxa2xx_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
#line 610
  p = bus___0->part;
#line 611
  chain = bus___0->chain;
#line 613
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 402653184U) {
#line 615
    d = (uint32_t )0;
#line 618
    if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[((bus_params_t___8 *)bus___0->params)->last_adr >> 26] == (unsigned long )((void *)0)) {
#line 619
      return ((uint32_t )0);
    }
    {
#line 621
    (*((bus___0->driver)->area))(bus___0, ((bus_params_t___8 *)bus___0->params)->last_adr,
                                 & area);
#line 624
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[0], 1, 1);
#line 625
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 626
    part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 1);
#line 628
    chain_shift_data_registers(chain, 1);
#line 630
    i = 0;
    }
    {
#line 630
    while (1) {
      while_continue: /* CIL Label */ ;
#line 630
      if (! ((unsigned int )i < area.width)) {
#line 630
        goto while_break;
      }
      {
#line 631
      tmp = part_get_signal(p, ((bus_params_t___8 *)bus___0->params)->md[i]);
#line 631
      d |= (uint32_t )(tmp << i);
#line 630
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 633
    return (d);
  }
#line 637
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1207959552U) {
#line 638
    return ((uint32_t )0);
  }
#line 640
  if (((bus_params_t___8 *)bus___0->params)->last_adr < 1275068416U) {
#line 641
    if (((bus_params_t___8 *)bus___0->params)->last_adr == 1207959620U) {
#line 642
      return ((uint32_t )((bus_params_t___8 *)bus___0->params)->MC_registers.boot_def);
    }
#line 644
    return ((uint32_t )0);
  }
#line 647
  return ((uint32_t )0);
}
}
#line 654 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
static void pxa2xx_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  int cs_index ;
  part_t *p ;
  chain_t *chain ;

  {
#line 657
  cs_index = 0;
#line 660
  p = bus___0->part;
#line 661
  chain = bus___0->chain;
#line 663
  if (adr >= 402653184U) {
#line 664
    return;
  }
#line 666
  cs_index = (int )(adr >> 26);
#line 667
  if ((unsigned long )((bus_params_t___8 *)bus___0->params)->ncs[cs_index] == (unsigned long )((void *)0)) {
#line 668
    return;
  }
  {
#line 670
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->ncs[cs_index], 1, 0);
#line 671
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[0], 1, 0);
#line 672
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[1], 1, 0);
#line 673
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[2], 1, 0);
#line 674
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->dqm[3], 1, 0);
#line 675
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->rdnwr, 1, 0);
#line 676
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 677
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->noe, 1, 1);
#line 678
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nsdcas, 1, 0);
#line 680
  setup_address___8(bus___0, adr);
#line 681
  setup_data___8(bus___0, adr, data);
#line 683
  chain_shift_data_registers(chain, 0);
#line 685
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 0);
#line 686
  chain_shift_data_registers(chain, 0);
#line 687
  part_set_signal(p, ((bus_params_t___8 *)bus___0->params)->nwe, 1, 1);
#line 688
  chain_shift_data_registers(chain, 0);
  }
#line 689
  return;
}
}
#line 691 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
struct bus_driver  const  pxa2x0_bus  = 
#line 691
     {"pxa2x0", "Intel PXA2x0 compatible bus driver via BSR", & pxa2xx_bus_new, & generic_bus_free,
    & pxa2xx_bus_printinfo, & generic_bus_prepare_extest, & pxa2xx_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & generic_bus_read, & pxa2xx_bus_write,
    & pxa2xx_bus_init};
#line 707 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/pxa2x0.c"
struct bus_driver  const  pxa27x_bus  = 
#line 707
     {"pxa27x", "Intel PXA27x compatible bus driver via BSR", & pxa2xx_bus_new, & generic_bus_free,
    & pxa2xx_bus_printinfo, & generic_bus_prepare_extest, & pxa27x_bus_area, & pxa2xx_bus_read_start,
    & pxa2xx_bus_read_next, & pxa2xx_bus_read_end, & generic_bus_read, & pxa2xx_bus_write,
    & pxa2xx_bus_init};
#line 329 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 385 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 50 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  prototype_bus ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void prototype_bus_signal_parse(char *str , char *fmt , int *inst ) 
{ 
  char pre[16] ;
  char suf[16] ;
  int tmp ;

  {
  {
#line 75
  tmp = sscanf((char const   */* __restrict  */)str, (char const   */* __restrict  */)"%[^0-9]%d%s",
               pre, inst, suf);
  }
  {
#line 76
  if (tmp == 1) {
#line 76
    goto case_1;
  }
#line 79
  if (tmp == 2) {
#line 79
    goto case_2;
  }
#line 82
  if (tmp == 3) {
#line 82
    goto case_3;
  }
#line 75
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 77
  strcpy((char */* __restrict  */)fmt, (char const   */* __restrict  */)str);
  }
#line 78
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 80
  sprintf((char */* __restrict  */)fmt, (char const   */* __restrict  */)"%s%s", pre,
          "%d");
  }
#line 81
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 83
  sprintf((char */* __restrict  */)fmt, (char const   */* __restrict  */)"%s%s%s",
          pre, "%d", suf);
  }
  switch_break: /* CIL Label */ ;
  }
#line 85
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static bus_t *prototype_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  signal_t *sig ;
  char buff[16] ;
  char fmt[16] ;
  char afmt[16] ;
  char dfmt[16] ;
  char param[16] ;
  char value[16] ;
  int i ;
  int j ;
  int inst ;
  int max ;
  int min ;
  int failed ;
  int ashift ;
  void *tmp ;
  signal_t *tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int nbytes ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;

  {
  {
#line 98
  failed = 0;
#line 99
  ashift = -1;
#line 101
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 101
  bus___0 = (bus_t *)tmp;
  }
#line 102
  if (! bus___0) {
#line 103
    return ((bus_t *)((void *)0));
  }
  {
#line 105
  bus___0->driver = driver;
#line 106
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___9 ));
  }
#line 107
  if (! bus___0->params) {
    {
#line 108
    free((void *)bus___0);
    }
#line 109
    return ((bus_t *)((void *)0));
  }
#line 112
  bus___0->chain = chain;
#line 113
  bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 115
  tmp___1 = (signal_t *)((void *)0);
#line 115
  ((bus_params_t___9 *)bus___0->params)->we = tmp___1;
#line 115
  tmp___0 = tmp___1;
#line 115
  ((bus_params_t___9 *)bus___0->params)->oe = tmp___0;
#line 115
  ((bus_params_t___9 *)bus___0->params)->cs = tmp___0;
#line 116
  tmp___4 = -1;
#line 116
  ((bus_params_t___9 *)bus___0->params)->dmsbi = tmp___4;
#line 116
  tmp___3 = tmp___4;
#line 116
  ((bus_params_t___9 *)bus___0->params)->dlsbi = tmp___3;
#line 116
  tmp___2 = tmp___3;
#line 116
  ((bus_params_t___9 *)bus___0->params)->amsbi = tmp___2;
#line 116
  ((bus_params_t___9 *)bus___0->params)->alsbi = tmp___2;
#line 117
  i = 2;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! *(cmd_params___0 + i)) {
#line 117
      goto while_break;
    }
    {
#line 118
    tmp___5 = strstr((char const   *)*(cmd_params___0 + i), "=");
    }
#line 118
    if (! tmp___5) {
#line 118
      goto __Cont;
    }
    {
#line 119
    sscanf((char const   */* __restrict  */)*(cmd_params___0 + i), (char const   */* __restrict  */)"%[^=]%*c%s",
           param, value);
#line 121
    tmp___11 = strcmp("amode", (char const   *)(param));
    }
#line 121
    if (! tmp___11) {
      {
#line 122
      tmp___10 = strcmp("x8", (char const   *)(value));
      }
#line 122
      if (tmp___10) {
        {
#line 124
        tmp___9 = strcmp("x16", (char const   *)(value));
        }
#line 124
        if (tmp___9) {
          {
#line 126
          tmp___8 = strcmp("x32", (char const   *)(value));
          }
#line 126
          if (tmp___8) {
            {
#line 128
            tmp___7 = strcmp("auto", (char const   *)(value));
            }
#line 128
            if (tmp___7) {
              {
#line 129
              tmp___6 = gettext("value %s not defined for parameter %s\n");
#line 129
              printf((char const   */* __restrict  */)tmp___6, value, param);
              }
            }
          } else {
#line 127
            ashift = 2;
          }
        } else {
#line 125
          ashift = 1;
        }
      } else {
#line 123
        ashift = 0;
      }
#line 130
      goto __Cont;
    }
    {
#line 133
    prototype_bus_signal_parse(value, fmt, & inst);
    }
#line 134
    if (inst > 31) {
#line 134
      goto __Cont;
    }
    {
#line 136
    sig = part_find_signal(bus___0->part, (char const   *)(value));
    }
#line 137
    if (! sig) {
      {
#line 138
      tmp___12 = gettext("signal \'%s\' is not found\n");
#line 138
      printf((char const   */* __restrict  */)tmp___12, value);
#line 139
      failed = 1;
      }
    } else {
      {
#line 140
      tmp___23 = strcmp("alsb", (char const   *)(param));
      }
#line 140
      if (tmp___23) {
        {
#line 144
        tmp___22 = strcmp("amsb", (char const   *)(param));
        }
#line 144
        if (tmp___22) {
          {
#line 148
          tmp___21 = strcmp("dlsb", (char const   *)(param));
          }
#line 148
          if (tmp___21) {
            {
#line 152
            tmp___20 = strcmp("dmsb", (char const   *)(param));
            }
#line 152
            if (tmp___20) {
              {
#line 156
              tmp___18 = strcmp("cs", (char const   *)(param));
              }
#line 156
              if (tmp___18) {
                {
#line 156
                tmp___19 = strcmp("ncs", (char const   *)(param));
                }
#line 156
                if (tmp___19) {
                  {
#line 159
                  tmp___16 = strcmp("oe", (char const   *)(param));
                  }
#line 159
                  if (tmp___16) {
                    {
#line 159
                    tmp___17 = strcmp("noe", (char const   *)(param));
                    }
#line 159
                    if (tmp___17) {
                      {
#line 162
                      tmp___14 = strcmp("we", (char const   *)(param));
                      }
#line 162
                      if (tmp___14) {
                        {
#line 162
                        tmp___15 = strcmp("nwe", (char const   *)(param));
                        }
#line 162
                        if (tmp___15) {
                          {
#line 166
                          tmp___13 = gettext("parameter %s is unknown\n");
#line 166
                          printf((char const   */* __restrict  */)tmp___13, param);
#line 167
                          failed = 1;
                          }
                        } else {
#line 162
                          goto _L;
                        }
                      } else {
                        _L: /* CIL Label */ 
#line 163
                        ((bus_params_t___9 *)bus___0->params)->we = sig;
#line 164
                        if ((int )param[0] == 110) {
#line 164
                          ((bus_params_t___9 *)bus___0->params)->wea = 0;
                        } else {
#line 164
                          ((bus_params_t___9 *)bus___0->params)->wea = 1;
                        }
                      }
                    } else {
#line 159
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
#line 160
                    ((bus_params_t___9 *)bus___0->params)->oe = sig;
#line 161
                    if ((int )param[0] == 110) {
#line 161
                      ((bus_params_t___9 *)bus___0->params)->oea = 0;
                    } else {
#line 161
                      ((bus_params_t___9 *)bus___0->params)->oea = 1;
                    }
                  }
                } else {
#line 156
                  goto _L___1;
                }
              } else {
                _L___1: /* CIL Label */ 
#line 157
                ((bus_params_t___9 *)bus___0->params)->cs = sig;
#line 158
                if ((int )param[0] == 110) {
#line 158
                  ((bus_params_t___9 *)bus___0->params)->csa = 0;
                } else {
#line 158
                  ((bus_params_t___9 *)bus___0->params)->csa = 1;
                }
              }
            } else {
              {
#line 153
              ((bus_params_t___9 *)bus___0->params)->dmsbi = inst;
#line 154
              ((bus_params_t___9 *)bus___0->params)->d[inst] = sig;
#line 155
              strcpy((char */* __restrict  */)(dfmt), (char const   */* __restrict  */)(fmt));
              }
            }
          } else {
            {
#line 149
            ((bus_params_t___9 *)bus___0->params)->dlsbi = inst;
#line 150
            ((bus_params_t___9 *)bus___0->params)->d[inst] = sig;
#line 151
            strcpy((char */* __restrict  */)(dfmt), (char const   */* __restrict  */)(fmt));
            }
          }
        } else {
          {
#line 145
          ((bus_params_t___9 *)bus___0->params)->amsbi = inst;
#line 146
          ((bus_params_t___9 *)bus___0->params)->a[inst] = sig;
#line 147
          strcpy((char */* __restrict  */)(afmt), (char const   */* __restrict  */)(fmt));
          }
        }
      } else {
        {
#line 141
        ((bus_params_t___9 *)bus___0->params)->alsbi = inst;
#line 142
        ((bus_params_t___9 *)bus___0->params)->a[inst] = sig;
#line 143
        strcpy((char */* __restrict  */)(afmt), (char const   */* __restrict  */)(fmt));
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  if (((bus_params_t___9 *)bus___0->params)->alsbi >= 0) {
#line 171
    goto _L___3;
  } else
#line 171
  if (((bus_params_t___9 *)bus___0->params)->amsbi >= 0) {
    _L___3: /* CIL Label */ 
#line 172
    if (((bus_params_t___9 *)bus___0->params)->alsbi == -1) {
#line 172
      goto _L___2;
    } else
#line 172
    if (((bus_params_t___9 *)bus___0->params)->amsbi == -1) {
      _L___2: /* CIL Label */ 
#line 173
      min = 0;
      {
#line 173
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 173
        if (! (min <= 31)) {
#line 173
          goto while_break___0;
        }
        {
#line 174
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
                min);
#line 175
        ((bus_params_t___9 *)bus___0->params)->a[min] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 176
        if (((bus_params_t___9 *)bus___0->params)->a[min]) {
#line 176
          goto while_break___0;
        }
#line 173
        min ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 178
      max = 31;
      {
#line 178
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 178
        if (! (max >= 0)) {
#line 178
          goto while_break___1;
        }
        {
#line 179
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
                max);
#line 180
        ((bus_params_t___9 *)bus___0->params)->a[max] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 181
        if (((bus_params_t___9 *)bus___0->params)->a[max]) {
#line 181
          goto while_break___1;
        }
#line 178
        max --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 183
      if (((bus_params_t___9 *)bus___0->params)->alsbi == -1) {
#line 184
        if (max - ((bus_params_t___9 *)bus___0->params)->amsbi < ((bus_params_t___9 *)bus___0->params)->amsbi - min) {
#line 184
          ((bus_params_t___9 *)bus___0->params)->alsbi = min;
        } else {
#line 184
          ((bus_params_t___9 *)bus___0->params)->alsbi = max;
        }
      } else
#line 186
      if (max - ((bus_params_t___9 *)bus___0->params)->alsbi < ((bus_params_t___9 *)bus___0->params)->alsbi - min) {
#line 186
        ((bus_params_t___9 *)bus___0->params)->amsbi = min;
      } else {
#line 186
        ((bus_params_t___9 *)bus___0->params)->amsbi = max;
      }
    }
#line 188
    if (((bus_params_t___9 *)bus___0->params)->amsbi > ((bus_params_t___9 *)bus___0->params)->alsbi) {
#line 188
      ((bus_params_t___9 *)bus___0->params)->ai = 1;
    } else {
#line 188
      ((bus_params_t___9 *)bus___0->params)->ai = -1;
    }
#line 189
    if (((bus_params_t___9 *)bus___0->params)->amsbi > ((bus_params_t___9 *)bus___0->params)->alsbi) {
#line 189
      tmp___24 = ((bus_params_t___9 *)bus___0->params)->amsbi - ((bus_params_t___9 *)bus___0->params)->alsbi;
    } else {
#line 189
      tmp___24 = ((bus_params_t___9 *)bus___0->params)->alsbi - ((bus_params_t___9 *)bus___0->params)->amsbi;
    }
#line 189
    ((bus_params_t___9 *)bus___0->params)->aw = tmp___24 + 1;
#line 190
    i = 0;
#line 190
    j = ((bus_params_t___9 *)bus___0->params)->alsbi;
    {
#line 190
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 190
      if (! (i < ((bus_params_t___9 *)bus___0->params)->aw)) {
#line 190
        goto while_break___2;
      }
      {
#line 191
      sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(afmt),
              j);
#line 192
      ((bus_params_t___9 *)bus___0->params)->a[j] = part_find_signal(bus___0->part,
                                                                     (char const   *)(buff));
#line 190
      i ++;
#line 190
      j += ((bus_params_t___9 *)bus___0->params)->ai;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 195
    tmp___25 = gettext("parameters alsb=<signal> and/or amsb=<signal> are not defined\n");
#line 195
    printf((char const   */* __restrict  */)tmp___25);
#line 196
    failed = 1;
    }
  }
#line 199
  if (((bus_params_t___9 *)bus___0->params)->dlsbi >= 0) {
#line 199
    goto _L___5;
  } else
#line 199
  if (((bus_params_t___9 *)bus___0->params)->dmsbi >= 0) {
    _L___5: /* CIL Label */ 
#line 200
    if (((bus_params_t___9 *)bus___0->params)->dlsbi == -1) {
#line 200
      goto _L___4;
    } else
#line 200
    if (((bus_params_t___9 *)bus___0->params)->dmsbi == -1) {
      _L___4: /* CIL Label */ 
#line 201
      min = 0;
      {
#line 201
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 201
        if (! (min <= 31)) {
#line 201
          goto while_break___3;
        }
        {
#line 202
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
                min);
#line 203
        ((bus_params_t___9 *)bus___0->params)->d[min] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 204
        if (((bus_params_t___9 *)bus___0->params)->d[min]) {
#line 204
          goto while_break___3;
        }
#line 201
        min ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 206
      max = 31;
      {
#line 206
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 206
        if (! (max >= 0)) {
#line 206
          goto while_break___4;
        }
        {
#line 207
        sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
                max);
#line 208
        ((bus_params_t___9 *)bus___0->params)->d[max] = part_find_signal(bus___0->part,
                                                                         (char const   *)(buff));
        }
#line 209
        if (((bus_params_t___9 *)bus___0->params)->d[max]) {
#line 209
          goto while_break___4;
        }
#line 206
        max --;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 211
      if (((bus_params_t___9 *)bus___0->params)->dlsbi == -1) {
#line 212
        if (max - ((bus_params_t___9 *)bus___0->params)->dmsbi < ((bus_params_t___9 *)bus___0->params)->dmsbi - min) {
#line 212
          ((bus_params_t___9 *)bus___0->params)->dlsbi = min;
        } else {
#line 212
          ((bus_params_t___9 *)bus___0->params)->dlsbi = max;
        }
      } else
#line 214
      if (max - ((bus_params_t___9 *)bus___0->params)->dlsbi < ((bus_params_t___9 *)bus___0->params)->dlsbi - min) {
#line 214
        ((bus_params_t___9 *)bus___0->params)->dmsbi = min;
      } else {
#line 214
        ((bus_params_t___9 *)bus___0->params)->dmsbi = max;
      }
    }
#line 216
    if (((bus_params_t___9 *)bus___0->params)->dmsbi > ((bus_params_t___9 *)bus___0->params)->dlsbi) {
#line 216
      ((bus_params_t___9 *)bus___0->params)->di = 1;
    } else {
#line 216
      ((bus_params_t___9 *)bus___0->params)->di = -1;
    }
#line 217
    if (((bus_params_t___9 *)bus___0->params)->dmsbi > ((bus_params_t___9 *)bus___0->params)->dlsbi) {
#line 217
      tmp___26 = ((bus_params_t___9 *)bus___0->params)->dmsbi - ((bus_params_t___9 *)bus___0->params)->dlsbi;
    } else {
#line 217
      tmp___26 = ((bus_params_t___9 *)bus___0->params)->dlsbi - ((bus_params_t___9 *)bus___0->params)->dmsbi;
    }
#line 217
    ((bus_params_t___9 *)bus___0->params)->dw = tmp___26 + 1;
#line 218
    i = 0;
#line 218
    j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
    {
#line 218
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 218
      if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 218
        goto while_break___5;
      }
      {
#line 219
      sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)(dfmt),
              j);
#line 220
      ((bus_params_t___9 *)bus___0->params)->d[j] = part_find_signal(bus___0->part,
                                                                     (char const   *)(buff));
#line 218
      i ++;
#line 218
      j += ((bus_params_t___9 *)bus___0->params)->di;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 225
    if (ashift < 0) {
#line 230
      nbytes = ((bus_params_t___9 *)bus___0->params)->dw / 8;
#line 231
      if (((bus_params_t___9 *)bus___0->params)->dw % 8 > 0) {
#line 232
        nbytes ++;
      }
#line 234
      ashift = 0;
      {
#line 235
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 235
        if (! (nbytes != 1)) {
#line 235
          goto while_break___6;
        }
#line 236
        nbytes >>= 1;
#line 237
        ashift ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 239
      ((bus_params_t___9 *)bus___0->params)->ashift = ashift;
    }
  } else {
    {
#line 243
    tmp___27 = gettext("parameters dlsb=<signal> and/or dmsb=<signal> are not defined\n");
#line 243
    printf((char const   */* __restrict  */)tmp___27);
#line 244
    failed = 1;
    }
  }
#line 247
  if (! ((bus_params_t___9 *)bus___0->params)->cs) {
    {
#line 248
    tmp___28 = gettext("parameter cs=<signal> or ncs=<signal> is not defined\n");
#line 248
    printf((char const   */* __restrict  */)tmp___28);
#line 249
    failed = 1;
    }
  }
#line 252
  if (! ((bus_params_t___9 *)bus___0->params)->oe) {
    {
#line 253
    tmp___29 = gettext("parameter oe=<signal> or noe=<signal> is not defined\n");
#line 253
    printf((char const   */* __restrict  */)tmp___29);
#line 254
    failed = 1;
    }
  }
#line 257
  if (! ((bus_params_t___9 *)bus___0->params)->we) {
    {
#line 258
    tmp___30 = gettext("parameter we=<signal> or nwe=<signal> is not defined\n");
#line 258
    printf((char const   */* __restrict  */)tmp___30);
#line 259
    failed = 1;
    }
  }
#line 262
  if (failed) {
    {
#line 263
    free(bus___0->params);
#line 264
    free((void *)bus___0);
    }
#line 265
    return ((bus_t *)((void *)0));
  }
#line 268
  return (bus___0);
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void prototype_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 280
  i = 0;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 280
      goto while_break;
    }
#line 281
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 282
      goto while_break;
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  tmp = gettext("Configurable prototype bus driver via BSR (JTAG part No. %d)\n");
#line 283
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 284
  return;
}
}
#line 290 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static int prototype_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 293
  area->description = (char const   *)((void *)0);
#line 294
  area->start = 0U;
#line 295
  area->length = 4294967296UL;
#line 296
  area->width = (unsigned int )((bus_params_t___9 *)bus___0->params)->dw;
#line 298
  return (0);
}
}
#line 301 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void setup_address___9(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  int j ;
  part_t *p ;

  {
#line 305
  p = bus___0->part;
#line 307
  a >>= ((bus_params_t___9 *)bus___0->params)->ashift;
#line 309
  i = 0;
#line 309
  j = ((bus_params_t___9 *)bus___0->params)->alsbi;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < ((bus_params_t___9 *)bus___0->params)->aw)) {
#line 309
      goto while_break;
    }
    {
#line 310
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->a[j], 1, (int )((a >> i) & 1U));
#line 309
    i ++;
#line 309
    j += ((bus_params_t___9 *)bus___0->params)->ai;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  return;
}
}
#line 313 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void set_data_in___9(bus_t *bus___0 ) 
{ 
  int i ;
  int j ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 317
  p = bus___0->part;
#line 320
  prototype_bus_area(bus___0, (uint32_t )0, & area);
#line 322
  i = 0;
#line 322
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 322
      goto while_break;
    }
    {
#line 323
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j], 0, 0);
#line 322
    i ++;
#line 322
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 324
  return;
}
}
#line 326 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void setup_data___9(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  int j ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 330
  p = bus___0->part;
#line 333
  prototype_bus_area(bus___0, (uint32_t )0, & area);
#line 335
  i = 0;
#line 335
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 335
  while (1) {
    while_continue: /* CIL Label */ ;
#line 335
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 335
      goto while_break;
    }
    {
#line 336
    part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j], 1, (int )((d >> i) & 1U));
#line 335
    i ++;
#line 335
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  return;
}
}
#line 343 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void prototype_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int tmp ;

  {
  {
#line 346
  p = bus___0->part;
#line 347
  chain = bus___0->chain;
#line 349
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, ((bus_params_t___9 *)bus___0->params)->csa);
  }
#line 350
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 350
    tmp = 0;
  } else {
#line 350
    tmp = 1;
  }
  {
#line 350
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp);
#line 351
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, ((bus_params_t___9 *)bus___0->params)->oea);
#line 353
  setup_address___9(bus___0, adr);
#line 354
  set_data_in___9(bus___0);
#line 356
  chain_shift_data_registers(chain, 0);
  }
#line 357
  return;
}
}
#line 363 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static uint32_t prototype_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  int j ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 366
  p = bus___0->part;
#line 367
  chain = bus___0->chain;
#line 369
  d = (uint32_t )0;
#line 372
  prototype_bus_area(bus___0, adr, & area);
#line 374
  setup_address___9(bus___0, adr);
#line 375
  chain_shift_data_registers(chain, 1);
#line 377
  i = 0;
#line 377
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 377
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 377
      goto while_break;
    }
    {
#line 378
    tmp = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j]);
#line 378
    d |= (uint32_t )(tmp << i);
#line 377
    i ++;
#line 377
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return (d);
}
}
#line 387 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static uint32_t prototype_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  int j ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 390
  p = bus___0->part;
#line 391
  chain = bus___0->chain;
#line 393
  d = (uint32_t )0;
#line 396
  prototype_bus_area(bus___0, (uint32_t )0, & area);
  }
#line 398
  if (((bus_params_t___9 *)bus___0->params)->csa) {
#line 398
    tmp = 0;
  } else {
#line 398
    tmp = 1;
  }
  {
#line 398
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, tmp);
  }
#line 399
  if (((bus_params_t___9 *)bus___0->params)->oea) {
#line 399
    tmp___0 = 0;
  } else {
#line 399
    tmp___0 = 1;
  }
  {
#line 399
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, tmp___0);
#line 400
  chain_shift_data_registers(chain, 1);
#line 402
  i = 0;
#line 402
  j = ((bus_params_t___9 *)bus___0->params)->dlsbi;
  }
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! (i < ((bus_params_t___9 *)bus___0->params)->dw)) {
#line 402
      goto while_break;
    }
    {
#line 403
    tmp___1 = part_get_signal(p, ((bus_params_t___9 *)bus___0->params)->d[j]);
#line 403
    d |= (uint32_t )(tmp___1 << i);
#line 402
    i ++;
#line 402
    j += ((bus_params_t___9 *)bus___0->params)->di;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return (d);
}
}
#line 412 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
static void prototype_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 415
  p = bus___0->part;
#line 416
  chain = bus___0->chain;
#line 418
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, ((bus_params_t___9 *)bus___0->params)->csa);
  }
#line 419
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 419
    tmp = 0;
  } else {
#line 419
    tmp = 1;
  }
  {
#line 419
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp);
  }
#line 420
  if (((bus_params_t___9 *)bus___0->params)->oea) {
#line 420
    tmp___0 = 0;
  } else {
#line 420
    tmp___0 = 1;
  }
  {
#line 420
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->oe, 1, tmp___0);
#line 422
  setup_address___9(bus___0, adr);
#line 423
  setup_data___9(bus___0, data);
#line 425
  chain_shift_data_registers(chain, 0);
#line 427
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, ((bus_params_t___9 *)bus___0->params)->wea);
#line 428
  chain_shift_data_registers(chain, 0);
  }
#line 429
  if (((bus_params_t___9 *)bus___0->params)->wea) {
#line 429
    tmp___1 = 0;
  } else {
#line 429
    tmp___1 = 1;
  }
  {
#line 429
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->we, 1, tmp___1);
  }
#line 430
  if (((bus_params_t___9 *)bus___0->params)->csa) {
#line 430
    tmp___2 = 0;
  } else {
#line 430
    tmp___2 = 1;
  }
  {
#line 430
  part_set_signal(p, ((bus_params_t___9 *)bus___0->params)->cs, 1, tmp___2);
#line 431
  chain_shift_data_registers(chain, 0);
  }
#line 432
  return;
}
}
#line 434 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/prototype.c"
struct bus_driver  const  prototype_bus  = 
#line 434
     {"prototype", "Configurable prototype bus driver via BSR, requires parameters:\n           amsb=<addr MSB> alsb=<addr LSB> dmsb=<data MSB> dlsb=<data LSB>\n           ncs=<CS#>|cs=<CS> noe=<OE#>|oe=<OE> nwe=<WE#>|we=<WE> [amode=auto|x8|x16|x32]",
    & prototype_bus_new, & generic_bus_free, & prototype_bus_printinfo, & generic_bus_prepare_extest,
    & prototype_bus_area, & prototype_bus_read_start, & prototype_bus_read_next, & prototype_bus_read_end,
    & generic_bus_read, & prototype_bus_write, & generic_bus_no_init};
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  ppc440gx_ebc8_bus ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static bus_t *ppc440gx_ebc8_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                    char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 65
  failed = 0;
#line 67
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 67
  bus___0 = (bus_t *)tmp;
  }
#line 68
  if (! bus___0) {
#line 69
    return ((bus_t *)((void *)0));
  }
  {
#line 71
  bus___0->driver = driver;
#line 72
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___10 ));
  }
#line 73
  if (! bus___0->params) {
    {
#line 74
    free((void *)bus___0);
    }
#line 75
    return ((bus_t *)((void *)0));
  }
#line 78
  bus___0->chain = chain;
#line 79
  part = *((chain->parts)->parts + chain->active_part);
#line 79
  bus___0->part = part;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 32)) {
#line 81
      goto while_break;
    }
    {
#line 82
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCADR%d",
            i);
#line 83
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->a[i],
                                     buff);
#line 83
    failed |= tmp___0;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < 8)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EBCDATA%d",
            i);
#line 88
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->d[i],
                                     buff);
#line 88
    failed |= tmp___1;
#line 86
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 91
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->ncs,
                                   (char *)"EBCCS0_N");
#line 91
  failed |= tmp___2;
#line 93
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->nwe,
                                   (char *)"EBCWE_N");
#line 93
  failed |= tmp___3;
#line 95
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->noe,
                                   (char *)"EBCOE_N");
#line 95
  failed |= tmp___4;
  }
#line 97
  if (failed) {
    {
#line 98
    free(bus___0->params);
#line 99
    free((void *)bus___0);
    }
#line 100
    return ((bus_t *)((void *)0));
  }
#line 103
  return (bus___0);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 115
  i = 0;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 115
      goto while_break;
    }
#line 116
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 117
      goto while_break;
    }
#line 115
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 118
  tmp = gettext("IBM PowerPC 440GX 8-bit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 118
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 119
  return;
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static int ppc440gx_ebc8_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 128
  area->description = (char const   *)((void *)0);
#line 129
  area->start = 0U;
#line 130
  area->length = 4294967296UL;
#line 131
  area->width = 8U;
#line 133
  return (0);
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static void setup_address___10(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 140
  p = bus___0->part;
#line 142
  i = 0;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (i < 32)) {
#line 142
      goto while_break;
    }
    {
#line 143
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 142
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static void set_data_in___10(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 150
  p = bus___0->part;
#line 153
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 155
  i = 0;
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! ((unsigned int )i < area.width)) {
#line 155
      goto while_break;
    }
    {
#line 156
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[i], 0, 0);
#line 155
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static void setup_data___10(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 163
  p = bus___0->part;
#line 166
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 168
  i = 0;
  }
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((unsigned int )i < area.width)) {
#line 168
      goto while_break;
    }
    {
#line 169
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i], 1, (int )((d >> i) & 1U));
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 176 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 179
  p = bus___0->part;
#line 180
  chain = bus___0->chain;
#line 182
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 183
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 184
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 0);
#line 186
  setup_address___10(bus___0, adr);
#line 187
  set_data_in___10(bus___0);
#line 189
  chain_shift_data_registers(chain, 0);
  }
#line 190
  return;
}
}
#line 196 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 199
  p = bus___0->part;
#line 200
  chain = bus___0->chain;
#line 202
  d = (uint32_t )0;
#line 205
  ppc440gx_ebc8_bus_area(bus___0, adr, & area);
#line 207
  setup_address___10(bus___0, adr);
#line 208
  chain_shift_data_registers(chain, 1);
#line 210
  i = 0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned int )i < area.width)) {
#line 210
      goto while_break;
    }
    {
#line 211
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i]);
#line 211
    d |= (uint32_t )(tmp << i);
#line 210
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (d);
}
}
#line 220 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static uint32_t ppc440gx_ebc8_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 223
  p = bus___0->part;
#line 224
  chain = bus___0->chain;
#line 226
  d = (uint32_t )0;
#line 229
  ppc440gx_ebc8_bus_area(bus___0, (uint32_t )0, & area);
#line 231
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 232
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 233
  chain_shift_data_registers(chain, 1);
#line 235
  i = 0;
  }
  {
#line 235
  while (1) {
    while_continue: /* CIL Label */ ;
#line 235
    if (! ((unsigned int )i < area.width)) {
#line 235
      goto while_break;
    }
    {
#line 236
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7 - i]);
#line 236
    d |= (uint32_t )(tmp << i);
#line 235
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 238
  return (d);
}
}
#line 245 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
static void ppc440gx_ebc8_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 248
  p = bus___0->part;
#line 249
  chain = bus___0->chain;
#line 251
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 252
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 253
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 255
  setup_address___10(bus___0, adr);
#line 256
  setup_data___10(bus___0, data);
#line 258
  chain_shift_data_registers(chain, 0);
#line 260
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 0);
#line 261
  chain_shift_data_registers(chain, 0);
#line 262
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 263
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 264
  chain_shift_data_registers(chain, 0);
  }
#line 265
  return;
}
}
#line 267 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc440gx_ebc8.c"
struct bus_driver  const  ppc440gx_ebc8_bus  = 
#line 267
     {"ppc440gx_ebc8", "IBM PowerPC 440GX 8-bit EBC compatible bus driver via BSR",
    & ppc440gx_ebc8_bus_new, & generic_bus_free, & ppc440gx_ebc8_bus_printinfo, & generic_bus_prepare_extest,
    & ppc440gx_ebc8_bus_area, & ppc440gx_ebc8_bus_read_start, & ppc440gx_ebc8_bus_read_next,
    & ppc440gx_ebc8_bus_read_end, & generic_bus_read, & ppc440gx_ebc8_bus_write, & generic_bus_no_init};
#line 48 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  ppc405ep_bus ;
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static bus_t *ppc405ep_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 63
  failed = 0;
#line 65
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 65
  bus___0 = (bus_t *)tmp;
  }
#line 66
  if (! bus___0) {
#line 67
    return ((bus_t *)((void *)0));
  }
  {
#line 69
  bus___0->driver = driver;
#line 70
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___11 ));
  }
#line 71
  if (! bus___0->params) {
    {
#line 72
    free((void *)bus___0);
    }
#line 73
    return ((bus_t *)((void *)0));
  }
#line 76
  bus___0->chain = chain;
#line 77
  part = *((chain->parts)->parts + chain->active_part);
#line 77
  bus___0->part = part;
#line 79
  i = 6;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (i < 32)) {
#line 79
      goto while_break;
    }
    {
#line 80
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerAddr%d",
            i);
#line 81
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->a[i],
                                     buff);
#line 81
    failed |= tmp___0;
#line 79
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (i < 16)) {
#line 84
      goto while_break___0;
    }
    {
#line 85
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PerData%d",
            i);
#line 86
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->d[i],
                                     buff);
#line 86
    failed |= tmp___1;
#line 84
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 89
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->ncs,
                                   (char *)"PerCS0");
#line 89
  failed |= tmp___2;
#line 91
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->nwe,
                                   (char *)"PerWBE1");
#line 91
  failed |= tmp___3;
#line 93
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___11 *)bus___0->params)->noe,
                                   (char *)"PerOE");
#line 93
  failed |= tmp___4;
  }
#line 95
  if (failed) {
    {
#line 96
    free(bus___0->params);
#line 97
    free((void *)bus___0);
    }
#line 98
    return ((bus_t *)((void *)0));
  }
#line 101
  return (bus___0);
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static void ppc405ep_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 113
  i = 0;
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 113
      goto while_break;
    }
#line 114
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 115
      goto while_break;
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 116
  tmp = gettext("IBM PowerPC 405EP compatible bus driver via BSR (JTAG part No. %d)\n");
#line 116
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 117
  return;
}
}
#line 123 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static int ppc405ep_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 126
  area->description = (char const   *)((void *)0);
#line 127
  area->start = 0U;
#line 128
  area->length = 4294967296UL;
#line 129
  area->width = 16U;
#line 131
  return (0);
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static void setup_address___11(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 138
  p = bus___0->part;
#line 140
  i = 6;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < 32)) {
#line 140
      goto while_break;
    }
    {
#line 141
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->a[i], 1, (int )((a >> (31 - i)) & 1U));
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  return;
}
}
#line 144 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static void set_data_in___11(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 148
  p = bus___0->part;
#line 151
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 153
  i = 0;
  }
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! ((unsigned int )i < area.width)) {
#line 153
      goto while_break;
    }
    {
#line 154
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[i], 0, 0);
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 157 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static void setup_data___11(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 161
  p = bus___0->part;
#line 164
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned int )i < area.width)) {
#line 166
      goto while_break;
    }
    {
#line 167
    part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i], 1, (int )((d >> i) & 1U));
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return;
}
}
#line 174 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static void ppc405ep_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 177
  p = bus___0->part;
#line 178
  chain = bus___0->chain;
#line 180
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 0);
#line 181
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 0);
#line 184
  setup_address___11(bus___0, adr);
#line 185
  set_data_in___11(bus___0);
#line 187
  chain_shift_data_registers(chain, 0);
  }
#line 188
  return;
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 197
  p = bus___0->part;
#line 198
  chain = bus___0->chain;
#line 200
  d = (uint32_t )0;
#line 203
  ppc405ep_bus_area(bus___0, adr, & area);
#line 205
  setup_address___11(bus___0, adr);
#line 206
  chain_shift_data_registers(chain, 1);
#line 208
  i = 0;
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((unsigned int )i < area.width)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i]);
#line 209
    d |= (uint32_t )(tmp << i);
#line 208
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (d);
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static uint32_t ppc405ep_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 221
  p = bus___0->part;
#line 222
  chain = bus___0->chain;
#line 224
  d = (uint32_t )0;
#line 227
  ppc405ep_bus_area(bus___0, (uint32_t )0, & area);
#line 229
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 1);
#line 231
  chain_shift_data_registers(chain, 1);
#line 233
  i = 0;
  }
  {
#line 233
  while (1) {
    while_continue: /* CIL Label */ ;
#line 233
    if (! ((unsigned int )i < area.width)) {
#line 233
      goto while_break;
    }
    {
#line 234
    tmp = part_get_signal(p, ((bus_params_t___11 *)bus___0->params)->d[15 - i]);
#line 234
    d |= (uint32_t )(tmp << i);
#line 233
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return (d);
}
}
#line 243 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
static void ppc405ep_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 246
  p = bus___0->part;
#line 247
  chain = bus___0->chain;
#line 249
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 0);
#line 250
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 251
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->noe, 1, 1);
#line 253
  setup_address___11(bus___0, adr);
#line 254
  setup_data___11(bus___0, data);
#line 256
  chain_shift_data_registers(chain, 0);
#line 258
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 0);
#line 259
  chain_shift_data_registers(chain, 0);
#line 260
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->nwe, 1, 1);
#line 261
  part_set_signal(p, ((bus_params_t___11 *)bus___0->params)->ncs, 1, 1);
#line 262
  chain_shift_data_registers(chain, 0);
  }
#line 263
  return;
}
}
#line 265 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ppc405ep.c"
struct bus_driver  const  ppc405ep_bus  = 
#line 265
     {"ppc405ep", "IBM PowerPC 405EP compatible bus driver via BSR", & ppc405ep_bus_new,
    & generic_bus_free, & ppc405ep_bus_printinfo, & generic_bus_prepare_extest, & ppc405ep_bus_area,
    & ppc405ep_bus_read_start, & ppc405ep_bus_read_next, & ppc405ep_bus_read_end,
    & generic_bus_read, & ppc405ep_bus_write, & generic_bus_no_init};
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  mpc824x_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
int BUS_WIDTH  =    8;
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
char REVBITS  =    (char)0;
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
char dbgAddr  =    (char)0;
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
char dbgData  =    (char)0;
#line 73 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static bus_t *mpc824x_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  signal_t *s_nfoe ;
  signal_t *s_sdma1 ;
  char param[16] ;
  char value[16] ;
  char dfltWidth ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 80
  failed = 0;
#line 86
  dfltWidth = (char)1;
#line 88
  dbgAddr = (char)0;
#line 89
  dbgData = (char)0;
#line 90
  REVBITS = (char)0;
#line 92
  i = 2;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! *(cmd_params___0 + i)) {
#line 92
      goto while_break;
    }
    {
#line 93
    tmp___10 = strstr((char const   *)*(cmd_params___0 + i), "=");
    }
#line 93
    if (tmp___10) {
      {
#line 94
      sscanf((char const   */* __restrict  */)*(cmd_params___0 + i), (char const   */* __restrict  */)"%[^=]%*c%s",
             param, value);
#line 96
      tmp___4 = strcmp("width", (char const   *)(param));
      }
#line 96
      if (! tmp___4) {
        {
#line 97
        tmp___3 = strcmp("8", (char const   *)(value));
        }
#line 97
        if (tmp___3) {
          {
#line 100
          tmp___2 = strcmp("32", (char const   *)(value));
          }
#line 100
          if (tmp___2) {
            {
#line 104
            tmp___1 = strcmp("64", (char const   *)(value));
            }
#line 104
            if (tmp___1) {
              {
#line 111
              tmp___0 = gettext("   Only 8,32 and 64 bus width are supported for Banks 0 and 1\n");
#line 111
              printf((char const   */* __restrict  */)tmp___0);
              }
#line 112
              return ((bus_t *)((void *)0));
            } else {
              {
#line 106
              BUS_WIDTH = 32;
#line 107
              tmp = gettext("   Bus width 64 exists in mpc824x, but not supported by UrJTAG currently\n");
#line 107
              printf((char const   */* __restrict  */)tmp);
#line 108
              dfltWidth = (char)1;
              }
            }
          } else {
#line 101
            BUS_WIDTH = 32;
#line 102
            dfltWidth = (char)0;
          }
        } else {
#line 98
          BUS_WIDTH = 8;
#line 99
          dfltWidth = (char)0;
        }
      }
    } else {
      {
#line 116
      tmp___5 = strcmp("revbits", (char const   *)*(cmd_params___0 + i));
      }
#line 116
      if (! tmp___5) {
#line 117
        REVBITS = (char)1;
      }
      {
#line 119
      tmp___7 = strcmp("help", (char const   *)*(cmd_params___0 + i));
      }
#line 119
      if (! tmp___7) {
        {
#line 120
        tmp___6 = gettext("Usage: initbus mpc824x [width=WIDTH] [revbits] [dbgAddr] [dbgData]\n\n   WIDTH      data bus width - 8, 32, 64 (default 8)\n   revbits    reverse bits in data bus (default - no)\n   dbgAddr    display address bus state (default - no)\n   dbgData    display data bus state (default - no)\n");
#line 120
        printf((char const   */* __restrict  */)tmp___6);
        }
#line 125
        return ((bus_t *)((void *)0));
      }
      {
#line 128
      tmp___8 = strcmp("dbgAddr", (char const   *)*(cmd_params___0 + i));
      }
#line 128
      if (! tmp___8) {
#line 129
        dbgAddr = (char)1;
      }
      {
#line 132
      tmp___9 = strcmp("dbgData", (char const   *)*(cmd_params___0 + i));
      }
#line 132
      if (! tmp___9) {
#line 133
        dbgData = (char)1;
      }
    }
#line 92
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  if (dfltWidth) {
    {
#line 140
    tmp___11 = gettext("   Using default bus width %d\n");
#line 140
    printf((char const   */* __restrict  */)tmp___11, BUS_WIDTH);
    }
  }
  {
#line 144
  tmp___12 = calloc((size_t )1, sizeof(bus_t ));
#line 144
  bus___0 = (bus_t *)tmp___12;
  }
#line 145
  if (! bus___0) {
#line 146
    return ((bus_t *)((void *)0));
  }
  {
#line 148
  bus___0->driver = driver;
#line 149
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___12 ));
  }
#line 150
  if (! bus___0->params) {
    {
#line 151
    free((void *)bus___0);
    }
#line 152
    return ((bus_t *)((void *)0));
  }
  {
#line 155
  bus___0->chain = chain;
#line 156
  part = *((chain->parts)->parts + chain->active_part);
#line 156
  bus___0->part = part;
#line 158
  s_nfoe = part_find_signal(part, "nFOE");
#line 159
  s_sdma1 = part_find_signal(part, "SDMA1");
#line 160
  part_set_signal(part, s_nfoe, 0, 0);
#line 161
  part_set_signal(part, s_sdma1, 0, 0);
#line 163
  part_set_instruction(part, "SAMPLE/PRELOAD");
#line 164
  chain_shift_instructions(chain);
#line 165
  chain_shift_data_registers(chain, 0);
#line 166
  part_set_instruction(part, "EXTEST");
#line 167
  chain_shift_instructions(chain);
#line 168
  chain_shift_data_registers(chain, 1);
#line 170
  ((bus_params_t___12 *)bus___0->params)->boot_nfoe = part_get_signal(part, s_nfoe);
#line 171
  ((bus_params_t___12 *)bus___0->params)->boot_sdma1 = part_get_signal(part, s_sdma1);
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 174
    if (! (i <= 10)) {
#line 174
      goto while_break___0;
    }
    {
#line 175
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SDMA%d",
            i);
#line 176
    tmp___13 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[i],
                                      buff);
#line 176
    failed |= tmp___13;
#line 174
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 179
  tmp___14 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[11],
                                    (char *)"SDBA0");
#line 179
  failed |= tmp___14;
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 181
    if (! (i < 8)) {
#line 181
      goto while_break___1;
    }
    {
#line 182
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PAR%d",
            i);
#line 183
    tmp___15 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[19 - i],
                                      buff);
#line 183
    failed |= tmp___15;
#line 181
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 186
  tmp___16 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[20],
                                    (char *)"SDBA1");
#line 186
  failed |= tmp___16;
#line 188
  tmp___17 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[21],
                                    (char *)"SDMA11");
#line 188
  failed |= tmp___17;
#line 190
  tmp___18 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->ar[22],
                                    (char *)"SDMA12");
#line 190
  failed |= tmp___18;
#line 192
  tmp___19 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->nrcs0,
                                    (char *)"nRCS0");
#line 192
  failed |= tmp___19;
#line 194
  tmp___20 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->nwe,
                                    (char *)"nWE");
#line 194
  failed |= tmp___20;
#line 196
  tmp___21 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->nfoe,
                                    (char *)"nFOE");
#line 196
  failed |= tmp___21;
#line 209
  i = 0;
  }
  {
#line 209
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 209
    if (! (i < 32)) {
#line 209
      goto while_break___2;
    }
    {
#line 210
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"MDH%d",
            31 - i);
#line 211
    tmp___22 = generic_bus_attach_sig(part, & ((bus_params_t___12 *)bus___0->params)->d[i],
                                      buff);
#line 211
    failed |= tmp___22;
#line 209
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 214
  if (failed) {
    {
#line 215
    free(bus___0->params);
#line 216
    free((void *)bus___0);
    }
#line 217
    return ((bus_t *)((void *)0));
  }
#line 220
  return (bus___0);
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static void mpc824x_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 232
  i = 0;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 232
      goto while_break;
    }
#line 233
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 234
      goto while_break;
    }
#line 232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  tmp = gettext("Motorola MPC824x compatible bus driver via BSR (JTAG part No. %d)\n");
#line 235
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 236
  return;
}
}
#line 242 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static int mpc824x_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 246
  if (adr < 4278190080U) {
#line 247
    area->description = (char const   *)((void *)0);
#line 248
    area->start = 0U;
#line 249
    area->length = 4278190080UL;
#line 250
    area->width = 0U;
#line 252
    return (0);
  }
#line 255
  if (adr < 4286578688U) {
#line 256
    area->description = "Base ROM Interface (Bank 1)";
#line 257
    area->start = 4278190080U;
#line 258
    area->length = 8388608UL;
#line 259
    area->width = 0U;
#line 261
    return (0);
  }
#line 264
  if (((bus_params_t___12 *)bus___0->params)->boot_sdma1 == 0) {
#line 265
    area->description = "Base ROM Interface (Bank 0)";
#line 266
    area->start = 4286578688U;
#line 267
    area->length = 8388608UL;
#line 268
    area->width = (unsigned int )BUS_WIDTH;
#line 270
    return (0);
  }
#line 274
  if (adr < 4290772992U) {
#line 275
    area->description = (char const   *)((void *)0);
#line 276
    area->start = 4286578688U;
#line 277
    area->length = 4194304UL;
#line 278
    area->width = (unsigned int )BUS_WIDTH;
#line 280
    return (0);
  }
#line 283
  area->description = "Base ROM Interface (Bank 0)";
#line 284
  area->start = 4290772992U;
#line 285
  area->length = 4194304UL;
#line 286
  area->width = (unsigned int )BUS_WIDTH;
#line 288
  return (0);
}
}
#line 291 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static void setup_address___12(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;
  int j ;
  int k ;
  char *tmp ;

  {
#line 295
  p = bus___0->part;
  {
#line 298
  if (BUS_WIDTH == 8) {
#line 298
    goto case_8;
  }
#line 301
  if (BUS_WIDTH == 32) {
#line 301
    goto case_32;
  }
#line 305
  if (BUS_WIDTH == 64) {
#line 305
    goto case_64;
  }
#line 297
  goto switch_break;
  case_8: /* CIL Label */ 
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < 23)) {
#line 299
      goto while_break;
    }
    {
#line 300
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> i) & 1U));
#line 299
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  case_32: /* CIL Label */ 
#line 302
  i = 0;
  {
#line 302
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 302
    if (! (i < 21)) {
#line 302
      goto while_break___0;
    }
    {
#line 303
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> (i + 2)) & 1U));
#line 302
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 304
  goto switch_break;
  case_64: /* CIL Label */ 
#line 306
  i = 0;
  {
#line 306
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 306
    if (! (i < 20)) {
#line 306
      goto while_break___1;
    }
    {
#line 307
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->ar[i], 1, (int )((a >> (i + 3)) & 1U));
#line 306
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 311
  if (dbgAddr) {
    {
#line 314
    if (BUS_WIDTH == 8) {
#line 314
      goto case_8___0;
    }
#line 315
    if (BUS_WIDTH == 32) {
#line 315
      goto case_32___0;
    }
#line 316
    if (BUS_WIDTH == 64) {
#line 316
      goto case_64___0;
    }
#line 313
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
#line 314
    k = 23;
#line 314
    goto switch_break___0;
    case_32___0: /* CIL Label */ 
#line 315
    k = 21;
#line 315
    goto switch_break___0;
    case_64___0: /* CIL Label */ 
#line 316
    k = 20;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 319
    tmp = gettext("Addr    [%2d:0]: %06X   ");
#line 319
    printf((char const   */* __restrict  */)tmp, k, a);
#line 320
    i = 0;
    }
    {
#line 320
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 320
      if (! (i < 3)) {
#line 320
        goto while_break___2;
      }
#line 321
      j = 0;
      {
#line 321
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 321
        if (! (j < 8)) {
#line 321
          goto while_break___3;
        }
#line 322
        if (i * 8 + j >= 23 - k) {
          {
#line 323
          printf((char const   */* __restrict  */)"%1d", (a >> (23 - (i * 8 + j))) & 1U);
          }
        } else {
          {
#line 325
          printf((char const   */* __restrict  */)" ");
          }
        }
#line 321
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 326
      printf((char const   */* __restrict  */)" ");
#line 320
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 328
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 331
  return;
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static void set_data_in___12(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 337
  p = bus___0->part;
#line 340
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 341
  if (area.width > 64U) {
#line 342
    return;
  }
#line 344
  i = 0;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned int )i < area.width)) {
#line 344
      goto while_break;
    }
    {
#line 345
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 0, 0);
#line 344
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 346
  return;
}
}
#line 348 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static void setup_data___12(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;
  int tmp ;
  char *tmp___0 ;
  int j ;
  int bytes ;

  {
  {
#line 352
  p = bus___0->part;
#line 355
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 356
  if (area.width > 64U) {
#line 357
    return;
  }
#line 359
  i = 0;
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! ((unsigned int )i < area.width)) {
#line 359
      goto while_break;
    }
#line 360
    if ((int )REVBITS == 1) {
#line 360
      tmp = (BUS_WIDTH - 1) - i;
    } else {
#line 360
      tmp = i;
    }
    {
#line 360
    part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i], 1, (int )((d >> tmp) & 1U));
#line 359
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  if (dbgData) {
    {
#line 364
    tmp___0 = gettext("Data WR [%d:0]: %08X   ");
#line 364
    printf((char const   */* __restrict  */)tmp___0, area.width - 1U, d);
#line 366
    bytes = 0;
    }
#line 367
    if (BUS_WIDTH == 8) {
#line 367
      bytes = 1;
    } else
#line 368
    if (BUS_WIDTH == 32) {
#line 368
      bytes = 4;
    } else
#line 369
    if (BUS_WIDTH == 64) {
#line 369
      bytes = 4;
    }
#line 371
    i = 0;
    {
#line 371
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 371
      if (! (i < bytes)) {
#line 371
        goto while_break___0;
      }
#line 372
      j = 0;
      {
#line 372
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 372
        if (! (j < 8)) {
#line 372
          goto while_break___1;
        }
#line 373
        if (REVBITS) {
          {
#line 374
          printf((char const   */* __restrict  */)"%1d", (d >> ((BUS_WIDTH - 1) - (i * 8 + j))) & 1U);
          }
        } else {
          {
#line 376
          printf((char const   */* __restrict  */)"%1d", (d >> (i * 8 + j)) & 1U);
          }
        }
#line 372
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 377
      printf((char const   */* __restrict  */)" ");
#line 371
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 379
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 382
  return;
}
}
#line 384 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static uint32_t get_data___0(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int j ;
  int bytes ;

  {
  {
#line 389
  d = (uint32_t )0;
#line 390
  p = bus___0->part;
#line 392
  mpc824x_bus_area(bus___0, adr, & area);
  }
#line 393
  if (area.width > 64U) {
#line 394
    return ((uint32_t )0);
  }
#line 396
  i = 0;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! ((unsigned int )i < area.width)) {
#line 396
      goto while_break;
    }
    {
#line 397
    tmp = part_get_signal(p, ((bus_params_t___12 *)bus___0->params)->d[i]);
    }
#line 397
    if ((int )REVBITS == 1) {
#line 397
      tmp___0 = (BUS_WIDTH - 1) - i;
    } else {
#line 397
      tmp___0 = i;
    }
#line 397
    d |= (uint32_t )(tmp << tmp___0);
#line 396
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  if (dbgData) {
    {
#line 401
    tmp___1 = gettext("Data RD [%d:0]: %08X   ");
#line 401
    printf((char const   */* __restrict  */)tmp___1, area.width - 1U, d);
#line 403
    bytes = 0;
    }
#line 404
    if (BUS_WIDTH == 8) {
#line 404
      bytes = 1;
    } else
#line 405
    if (BUS_WIDTH == 32) {
#line 405
      bytes = 4;
    } else
#line 406
    if (BUS_WIDTH == 64) {
#line 406
      bytes = 4;
    }
#line 408
    i = 0;
    {
#line 408
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 408
      if (! (i < bytes)) {
#line 408
        goto while_break___0;
      }
#line 409
      j = 0;
      {
#line 409
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 409
        if (! (j < 8)) {
#line 409
          goto while_break___1;
        }
#line 410
        if (REVBITS) {
          {
#line 411
          printf((char const   */* __restrict  */)"%1d", (d >> ((BUS_WIDTH - 1) - (i * 8 + j))) & 1U);
          }
        } else {
          {
#line 413
          printf((char const   */* __restrict  */)"%1d", (d >> (i * 8 + j)) & 1U);
          }
        }
#line 409
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 414
      printf((char const   */* __restrict  */)" ");
#line 408
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 416
    printf((char const   */* __restrict  */)"\n");
    }
  }
#line 419
  return (d);
}
}
#line 426 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static void mpc824x_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 429
  p = bus___0->part;
#line 431
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
#line 434
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 0);
#line 435
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 436
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 0);
#line 438
  setup_address___12(bus___0, adr);
#line 439
  set_data_in___12(bus___0, adr);
#line 441
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 442
  return;
}
}
#line 448 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 453
  setup_address___12(bus___0, adr);
#line 454
  chain_shift_data_registers(bus___0->chain, 1);
#line 456
  d = get_data___0(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
#line 457
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
  }
#line 458
  return (d);
}
}
#line 465 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static uint32_t mpc824x_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 468
  p = bus___0->part;
#line 470
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 1);
#line 471
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 1);
#line 473
  chain_shift_data_registers(bus___0->chain, 1);
#line 475
  tmp = get_data___0(bus___0, ((bus_params_t___12 *)bus___0->params)->last_adr);
  }
#line 475
  return (tmp);
}
}
#line 482 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
static void mpc824x_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;

  {
  {
#line 485
  p = bus___0->part;
#line 487
  ((bus_params_t___12 *)bus___0->params)->last_adr = adr;
#line 491
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 0);
#line 492
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 493
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nfoe, 1, 1);
#line 495
  setup_address___12(bus___0, adr);
#line 497
  setup_data___12(bus___0, adr, data);
#line 499
  chain_shift_data_registers(bus___0->chain, 0);
#line 501
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 0);
#line 502
  chain_shift_data_registers(bus___0->chain, 0);
#line 503
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nwe, 1, 1);
#line 504
  part_set_signal(p, ((bus_params_t___12 *)bus___0->params)->nrcs0, 1, 1);
#line 505
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 509
  return;
}
}
#line 511 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc824x.c"
struct bus_driver  const  mpc824x_bus  = 
#line 511
     {"mpc824x", "Motorola MPC824x compatible bus driver via BSR", & mpc824x_bus_new,
    & generic_bus_free, & mpc824x_bus_printinfo, & generic_bus_prepare_extest, & mpc824x_bus_area,
    & mpc824x_bus_read_start, & mpc824x_bus_read_next, & mpc824x_bus_read_end, & generic_bus_read,
    & mpc824x_bus_write, & generic_bus_no_init};
#line 46 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  mpc5200_bus ;
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static bus_t *mpc5200_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 70
  failed = 0;
#line 72
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 72
  bus___0 = (bus_t *)tmp;
  }
#line 73
  if (! bus___0) {
#line 74
    return ((bus_t *)((void *)0));
  }
  {
#line 76
  bus___0->driver = driver;
#line 77
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___13 ));
  }
#line 78
  if (! bus___0->params) {
    {
#line 79
    free((void *)bus___0);
    }
#line 80
    return ((bus_t *)((void *)0));
  }
#line 83
  bus___0->chain = chain;
#line 84
  part = *((chain->parts)->parts + chain->active_part);
#line 84
  bus___0->part = part;
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < 24)) {
#line 87
      goto while_break;
    }
    {
#line 88
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i);
#line 89
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->ad[i],
                                     buff);
#line 89
    failed |= tmp___0;
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  i = 0;
  {
#line 92
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 92
    if (! (i < 4)) {
#line 92
      goto while_break___0;
    }
    {
#line 93
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"LP_CS%d_B",
            i);
#line 94
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->ncs[i],
                                     buff);
#line 94
    failed |= tmp___1;
#line 92
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 97
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->nwe,
                                   (char *)"LP_RW");
#line 97
  failed |= tmp___2;
#line 99
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->noe,
                                   (char *)"LP_OE");
#line 99
  failed |= tmp___3;
#line 101
  i = 0;
  }
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 8)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EXT_AD_%d",
            i + 24);
#line 103
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___13 *)bus___0->params)->d[i],
                                     buff);
#line 103
    failed |= tmp___4;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  if (failed) {
    {
#line 107
    free(bus___0->params);
#line 108
    free((void *)bus___0);
    }
#line 109
    return ((bus_t *)((void *)0));
  }
#line 112
  return (bus___0);
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static void mpc5200_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 124
  i = 0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 124
      goto while_break;
    }
#line 125
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 126
      goto while_break;
    }
#line 124
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp = gettext("Freescale MPC5200 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 127
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 128
  return;
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static int mpc5200_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 137
  if (adr < 16777216U) {
#line 139
    area->description = "LocalPlus Bus";
#line 140
    area->start = 0U;
#line 141
    area->length = 16777216UL;
#line 142
    area->width = 8U;
#line 143
    return (0);
  }
#line 146
  area->description = (char const   *)((void *)0);
#line 147
  area->start = (uint32_t )16777216;
#line 148
  area->length = (uint64_t )4278190080U;
#line 149
  area->width = 0U;
#line 150
  return (0);
}
}
#line 153 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static void setup_address___13(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 157
  p = bus___0->part;
#line 159
  i = 0;
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i < 24)) {
#line 159
      goto while_break;
    }
    {
#line 160
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ad[i], 1, (int )((a >> i) & 1U));
#line 159
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return;
}
}
#line 163 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static void set_data_in___13(bus_t *bus___0 , uint32_t adr ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 167
  p = bus___0->part;
#line 170
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 171
  if (area.width > 8U) {
#line 172
    return;
  }
#line 174
  i = 0;
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned int )i < area.width)) {
#line 174
      goto while_break;
    }
    {
#line 175
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i], 0, 0);
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static void setup_data___13(bus_t *bus___0 , uint32_t adr , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 182
  p = bus___0->part;
#line 185
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 186
  if (area.width > 8U) {
#line 187
    return;
  }
#line 189
  i = 0;
  {
#line 189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 189
    if (! ((unsigned int )i < area.width)) {
#line 189
      goto while_break;
    }
    {
#line 190
    part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 189
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 191
  return;
}
}
#line 193 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static uint32_t get_data___1(bus_t *bus___0 , uint32_t adr ) 
{ 
  bus_area_t area ;
  int i ;
  uint32_t d ;
  part_t *p ;
  int tmp ;

  {
  {
#line 198
  d = (uint32_t )0;
#line 199
  p = bus___0->part;
#line 201
  mpc5200_bus_area(bus___0, adr, & area);
  }
#line 202
  if (area.width > 8U) {
#line 203
    return ((uint32_t )0);
  }
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((unsigned int )i < area.width)) {
#line 205
      goto while_break;
    }
    {
#line 206
    tmp = part_get_signal(p, ((bus_params_t___13 *)bus___0->params)->d[i]);
#line 206
    d |= (uint32_t )(tmp << i);
#line 205
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return (d);
}
}
#line 215 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static void mpc5200_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;

  {
  {
#line 218
  p = bus___0->part;
#line 220
  ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
#line 223
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 0);
#line 224
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[1], 1, 1);
#line 225
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[2], 1, 1);
#line 226
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[3], 1, 1);
#line 227
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 228
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 0);
#line 230
  setup_address___13(bus___0, adr);
#line 231
  set_data_in___13(bus___0, adr);
#line 233
  chain_shift_data_registers(bus___0->chain, 0);
  }
#line 234
  return;
}
}
#line 240 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;

  {
  {
#line 245
  setup_address___13(bus___0, adr);
#line 246
  chain_shift_data_registers(bus___0->chain, 1);
#line 248
  d = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
#line 249
  ((bus_params_t___13 *)bus___0->params)->last_adr = adr;
  }
#line 250
  return (d);
}
}
#line 257 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static uint32_t mpc5200_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  uint32_t tmp ;

  {
  {
#line 260
  p = bus___0->part;
#line 262
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 1);
#line 263
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 265
  chain_shift_data_registers(bus___0->chain, 1);
#line 267
  tmp = get_data___1(bus___0, ((bus_params_t___13 *)bus___0->params)->last_adr);
  }
#line 267
  return (tmp);
}
}
#line 274 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
static void mpc5200_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 278
  p = bus___0->part;
#line 279
  chain = bus___0->chain;
#line 281
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[0], 1, 0);
#line 282
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[1], 1, 1);
#line 283
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[2], 1, 1);
#line 284
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->ncs[3], 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->noe, 1, 1);
#line 288
  setup_address___13(bus___0, adr);
#line 289
  setup_data___13(bus___0, adr, data);
#line 291
  chain_shift_data_registers(chain, 0);
#line 293
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 0);
#line 294
  chain_shift_data_registers(chain, 0);
#line 295
  part_set_signal(p, ((bus_params_t___13 *)bus___0->params)->nwe, 1, 1);
#line 296
  chain_shift_data_registers(chain, 0);
  }
#line 297
  return;
}
}
#line 299 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/mpc5200.c"
struct bus_driver  const  mpc5200_bus  = 
#line 299
     {"mpc5200", "Freescale MPC5200 compatible bus driver via BSR", & mpc5200_bus_new,
    & generic_bus_free, & mpc5200_bus_printinfo, & generic_bus_prepare_extest, & mpc5200_bus_area,
    & mpc5200_bus_read_start, & mpc5200_bus_read_next, & mpc5200_bus_read_end, & generic_bus_read,
    & mpc5200_bus_write, & generic_bus_no_init};
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  lh7a400_bus ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static bus_t *lh7a400_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 81
  failed = 0;
#line 83
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 83
  bus___0 = (bus_t *)tmp;
  }
#line 84
  if (! bus___0) {
#line 85
    return ((bus_t *)((void *)0));
  }
  {
#line 87
  bus___0->driver = driver;
#line 88
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___14 ));
  }
#line 89
  if (! bus___0->params) {
    {
#line 90
    free((void *)bus___0);
    }
#line 91
    return ((bus_t *)((void *)0));
  }
#line 94
  bus___0->chain = chain;
#line 95
  part = *((chain->parts)->parts + chain->active_part);
#line 95
  bus___0->part = part;
#line 97
  i = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < 24)) {
#line 97
      goto while_break;
    }
    {
#line 98
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"A%d",
            i);
#line 99
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->a[i],
                                     buff);
#line 99
    failed |= tmp___0;
#line 97
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  i = 0;
  {
#line 102
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 102
    if (! (i < 32)) {
#line 102
      goto while_break___0;
    }
    {
#line 103
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"D%d",
            i);
#line 104
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->d[i],
                                     buff);
#line 104
    failed |= tmp___1;
#line 102
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 107
    if (! (i < 4)) {
#line 107
      goto while_break___1;
    }
    {
#line 108
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nCS%d",
            i);
#line 109
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->ncs[i],
                                     buff);
#line 109
    failed |= tmp___2;
#line 107
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 112
  i = 0;
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! (i < 2)) {
#line 112
      goto while_break___2;
    }
    {
#line 113
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"WIDTH%d",
            i);
#line 114
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->width[i],
                                     buff);
#line 114
    failed |= tmp___3;
#line 112
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 117
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->nwe,
                                   (char *)"nWE0");
#line 117
  failed |= tmp___4;
#line 119
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___14 *)bus___0->params)->noe,
                                   (char *)"nOE");
#line 119
  failed |= tmp___5;
  }
#line 121
  if (failed) {
    {
#line 122
    free(bus___0->params);
#line 123
    free((void *)bus___0);
    }
#line 124
    return ((bus_t *)((void *)0));
  }
#line 127
  return (bus___0);
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static void lh7a400_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 139
      goto while_break;
    }
#line 140
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 141
      goto while_break;
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp = gettext("Sharp LH7A400 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 142
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 143
  return;
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static int lh7a400_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  unsigned int width ;
  signal_t *tmp ;
  int tmp___0 ;
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 154
  area->description = (char const   *)((void *)0);
#line 155
  area->start = 0U;
#line 156
  area->length = 268435456UL;
#line 159
  tmp = part_find_signal(bus___0->part, "WIDTH0");
#line 159
  tmp___0 = part_get_signal(bus___0->part, tmp);
#line 159
  width = (unsigned int )tmp___0;
#line 160
  tmp___1 = part_find_signal(bus___0->part, "WIDTH1");
#line 160
  tmp___2 = part_get_signal(bus___0->part, tmp___1);
#line 160
  width |= (unsigned int )(tmp___2 << 1);
  }
#line 162
  if (width < 0U) {
#line 163
    return (-1);
  }
  {
#line 166
  if (width == 0U) {
#line 166
    goto case_0;
  }
#line 169
  if (width == 1U) {
#line 169
    goto case_1;
  }
#line 173
  if (width == 3U) {
#line 173
    goto case_3;
  }
#line 173
  if (width == 2U) {
#line 173
    goto case_3;
  }
#line 165
  goto switch_break;
  case_0: /* CIL Label */ 
#line 167
  area->width = 8U;
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
#line 170
  area->width = 16U;
#line 171
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 174
  area->width = 32U;
  switch_break: /* CIL Label */ ;
  }
#line 177
  return (0);
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static void setup_address___14(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 184
  p = bus___0->part;
#line 186
  i = 0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! (i < 24)) {
#line 186
      goto while_break;
    }
    {
#line 187
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 186
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return;
}
}
#line 190 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static void set_data_in___14(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 194
  p = bus___0->part;
#line 197
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! ((unsigned int )i < area.width)) {
#line 199
      goto while_break;
    }
    {
#line 200
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i], 0, 0);
#line 199
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static void setup_data___14(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 208
  p = bus___0->part;
#line 211
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 213
  i = 0;
  }
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((unsigned int )i < area.width)) {
#line 213
      goto while_break;
    }
    {
#line 214
    part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 213
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 221 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static void lh7a400_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 225
  p = bus___0->part;
#line 226
  chain = bus___0->chain;
#line 228
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 229
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 230
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 0);
#line 232
  setup_address___14(bus___0, adr);
#line 233
  set_data_in___14(bus___0);
#line 235
  chain_shift_data_registers(chain, 0);
  }
#line 236
  return;
}
}
#line 242 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 246
  p = bus___0->part;
#line 247
  chain = bus___0->chain;
#line 249
  d = (uint32_t )0;
#line 252
  lh7a400_bus_area(bus___0, adr, & area);
#line 254
  setup_address___14(bus___0, adr);
#line 255
  chain_shift_data_registers(chain, 1);
#line 257
  i = 0;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! ((unsigned int )i < area.width)) {
#line 257
      goto while_break;
    }
    {
#line 258
    tmp = part_get_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i]);
#line 258
    d |= (uint32_t )(tmp << i);
#line 257
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (d);
}
}
#line 267 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static uint32_t lh7a400_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 271
  p = bus___0->part;
#line 272
  chain = bus___0->chain;
#line 274
  d = (uint32_t )0;
#line 277
  lh7a400_bus_area(bus___0, (uint32_t )0, & area);
#line 279
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, 1);
#line 280
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 1);
#line 282
  chain_shift_data_registers(chain, 1);
#line 284
  i = 0;
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! ((unsigned int )i < area.width)) {
#line 284
      goto while_break;
    }
    {
#line 285
    tmp = part_get_signal(p, ((bus_params_t___14 *)bus___0->params)->d[i]);
#line 285
    d |= (uint32_t )(tmp << i);
#line 284
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  return (d);
}
}
#line 294 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
static void lh7a400_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 298
  p = bus___0->part;
#line 299
  chain = bus___0->chain;
#line 301
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, adr >> 27 != 0U);
#line 302
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 303
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->noe, 1, 1);
#line 305
  setup_address___14(bus___0, adr);
#line 306
  setup_data___14(bus___0, data);
#line 308
  chain_shift_data_registers(chain, 0);
#line 310
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 0);
#line 311
  chain_shift_data_registers(chain, 0);
#line 313
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->nwe, 1, 1);
#line 314
  part_set_signal(p, ((bus_params_t___14 *)bus___0->params)->ncs[0], 1, 1);
#line 315
  chain_shift_data_registers(chain, 0);
  }
#line 316
  return;
}
}
#line 318 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/lh7a400.c"
struct bus_driver  const  lh7a400_bus  = 
#line 318
     {"lh7a400", "Sharp LH7A400 compatible bus driver via BSR (flash access only!)",
    & lh7a400_bus_new, & generic_bus_free, & lh7a400_bus_printinfo, & generic_bus_prepare_extest,
    & lh7a400_bus_area, & lh7a400_bus_read_start, & lh7a400_bus_read_next, & lh7a400_bus_read_end,
    & generic_bus_read, & lh7a400_bus_write, & generic_bus_no_init};
#line 44 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  jopcyc_bus ;
#line 136 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static bus_t *jopcyc_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  int failed ;
  component_t___0 *comp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;

  {
  {
#line 141
  failed = 0;
#line 144
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 144
  bus___0 = (bus_t *)tmp;
  }
#line 145
  if (! bus___0) {
#line 146
    return ((bus_t *)((void *)0));
  }
  {
#line 148
  bus___0->driver = driver;
#line 149
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___15 ));
  }
#line 150
  if (! bus___0->params) {
    {
#line 151
    free((void *)bus___0);
    }
#line 152
    return ((bus_t *)((void *)0));
  }
  {
#line 155
  bus___0->chain = chain;
#line 156
  part = *((chain->parts)->parts + chain->active_part);
#line 156
  bus___0->part = part;
#line 161
  comp = & ((bus_params_t___15 *)bus___0->params)->rama;
#line 162
  comp->ctype = (ctype_t )0;
#line 163
  comp->cname = (char *)"RAMA";
#line 165
  tmp___0 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO64");
#line 165
  failed |= tmp___0;
#line 166
  tmp___1 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO66");
#line 166
  failed |= tmp___1;
#line 167
  tmp___2 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO68");
#line 167
  failed |= tmp___2;
#line 168
  tmp___3 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO74");
#line 168
  failed |= tmp___3;
#line 169
  tmp___4 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO76");
#line 169
  failed |= tmp___4;
#line 170
  tmp___5 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO107");
#line 170
  failed |= tmp___5;
#line 171
  tmp___6 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO113");
#line 171
  failed |= tmp___6;
#line 172
  tmp___7 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO115");
#line 172
  failed |= tmp___7;
#line 173
  tmp___8 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO117");
#line 173
  failed |= tmp___8;
#line 174
  tmp___9 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO119");
#line 174
  failed |= tmp___9;
#line 175
  tmp___10 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO118");
#line 175
  failed |= tmp___10;
#line 176
  tmp___11 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO116");
#line 176
  failed |= tmp___11;
#line 177
  tmp___12 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO114");
#line 177
  failed |= tmp___12;
#line 178
  tmp___13 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO108");
#line 178
  failed |= tmp___13;
#line 179
  tmp___14 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO106");
#line 179
  failed |= tmp___14;
#line 180
  tmp___15 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO67");
#line 180
  failed |= tmp___15;
#line 181
  tmp___16 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO65");
#line 181
  failed |= tmp___16;
#line 182
  tmp___17 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO63");
#line 182
  failed |= tmp___17;
#line 183
  comp->a[18] = (signal_t *)((void *)0);
#line 185
  tmp___18 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO82");
#line 185
  failed |= tmp___18;
#line 186
  tmp___19 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO84");
#line 186
  failed |= tmp___19;
#line 187
  tmp___20 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO86");
#line 187
  failed |= tmp___20;
#line 188
  tmp___21 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO88");
#line 188
  failed |= tmp___21;
#line 189
  tmp___22 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO94");
#line 189
  failed |= tmp___22;
#line 190
  tmp___23 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO98");
#line 190
  failed |= tmp___23;
#line 191
  tmp___24 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO100");
#line 191
  failed |= tmp___24;
#line 192
  tmp___25 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO104");
#line 192
  failed |= tmp___25;
#line 193
  tmp___26 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO101");
#line 193
  failed |= tmp___26;
#line 194
  tmp___27 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO99");
#line 194
  failed |= tmp___27;
#line 195
  tmp___28 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO95");
#line 195
  failed |= tmp___28;
#line 196
  tmp___29 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO93");
#line 196
  failed |= tmp___29;
#line 197
  tmp___30 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO87");
#line 197
  failed |= tmp___30;
#line 198
  tmp___31 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO85");
#line 198
  failed |= tmp___31;
#line 199
  tmp___32 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO83");
#line 199
  failed |= tmp___32;
#line 200
  tmp___33 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO79");
#line 200
  failed |= tmp___33;
#line 202
  tmp___34 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO78");
#line 202
  failed |= tmp___34;
#line 203
  tmp___35 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO73");
#line 203
  failed |= tmp___35;
#line 204
  tmp___36 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO105");
#line 204
  failed |= tmp___36;
#line 205
  tmp___37 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO77");
#line 205
  failed |= tmp___37;
#line 206
  tmp___38 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO75");
#line 206
  failed |= tmp___38;
#line 207
  comp->ncs2 = (signal_t *)((void *)0);
#line 208
  comp->nrdy = (signal_t *)((void *)0);
#line 213
  comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
#line 214
  comp->ctype = (ctype_t )0;
#line 215
  comp->cname = (char *)"RAMB";
#line 217
  tmp___39 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO237");
#line 217
  failed |= tmp___39;
#line 218
  tmp___40 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO235");
#line 218
  failed |= tmp___40;
#line 219
  tmp___41 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO233");
#line 219
  failed |= tmp___41;
#line 220
  tmp___42 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO227");
#line 220
  failed |= tmp___42;
#line 221
  tmp___43 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO225");
#line 221
  failed |= tmp___43;
#line 222
  tmp___44 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO194");
#line 222
  failed |= tmp___44;
#line 223
  tmp___45 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO188");
#line 223
  failed |= tmp___45;
#line 224
  tmp___46 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO186");
#line 224
  failed |= tmp___46;
#line 225
  tmp___47 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO184");
#line 225
  failed |= tmp___47;
#line 226
  tmp___48 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO182");
#line 226
  failed |= tmp___48;
#line 227
  tmp___49 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO183");
#line 227
  failed |= tmp___49;
#line 228
  tmp___50 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO185");
#line 228
  failed |= tmp___50;
#line 229
  tmp___51 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO187");
#line 229
  failed |= tmp___51;
#line 230
  tmp___52 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO193");
#line 230
  failed |= tmp___52;
#line 231
  tmp___53 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO195");
#line 231
  failed |= tmp___53;
#line 232
  tmp___54 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO234");
#line 232
  failed |= tmp___54;
#line 233
  tmp___55 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO236");
#line 233
  failed |= tmp___55;
#line 234
  tmp___56 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO238");
#line 234
  failed |= tmp___56;
#line 235
  comp->a[18] = (signal_t *)((void *)0);
#line 237
  tmp___57 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO219");
#line 237
  failed |= tmp___57;
#line 238
  tmp___58 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO217");
#line 238
  failed |= tmp___58;
#line 239
  tmp___59 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO215");
#line 239
  failed |= tmp___59;
#line 240
  tmp___60 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO213");
#line 240
  failed |= tmp___60;
#line 241
  tmp___61 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO207");
#line 241
  failed |= tmp___61;
#line 242
  tmp___62 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO203");
#line 242
  failed |= tmp___62;
#line 243
  tmp___63 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO201");
#line 243
  failed |= tmp___63;
#line 244
  tmp___64 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO197");
#line 244
  failed |= tmp___64;
#line 245
  tmp___65 = generic_bus_attach_sig(part, & comp->d[8], (char *)"IO200");
#line 245
  failed |= tmp___65;
#line 246
  tmp___66 = generic_bus_attach_sig(part, & comp->d[9], (char *)"IO202");
#line 246
  failed |= tmp___66;
#line 247
  tmp___67 = generic_bus_attach_sig(part, & comp->d[10], (char *)"IO206");
#line 247
  failed |= tmp___67;
#line 248
  tmp___68 = generic_bus_attach_sig(part, & comp->d[11], (char *)"IO208");
#line 248
  failed |= tmp___68;
#line 249
  tmp___69 = generic_bus_attach_sig(part, & comp->d[12], (char *)"IO214");
#line 249
  failed |= tmp___69;
#line 250
  tmp___70 = generic_bus_attach_sig(part, & comp->d[13], (char *)"IO216");
#line 250
  failed |= tmp___70;
#line 251
  tmp___71 = generic_bus_attach_sig(part, & comp->d[14], (char *)"IO218");
#line 251
  failed |= tmp___71;
#line 252
  tmp___72 = generic_bus_attach_sig(part, & comp->d[15], (char *)"IO222");
#line 252
  failed |= tmp___72;
#line 254
  tmp___73 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO223");
#line 254
  failed |= tmp___73;
#line 255
  tmp___74 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO228");
#line 255
  failed |= tmp___74;
#line 256
  tmp___75 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO196");
#line 256
  failed |= tmp___75;
#line 257
  tmp___76 = generic_bus_attach_sig(part, & comp->nlb, (char *)"IO224");
#line 257
  failed |= tmp___76;
#line 258
  tmp___77 = generic_bus_attach_sig(part, & comp->nub, (char *)"IO226");
#line 258
  failed |= tmp___77;
#line 259
  comp->ncs2 = (signal_t *)((void *)0);
#line 260
  comp->nrdy = (signal_t *)((void *)0);
#line 265
  comp = & ((bus_params_t___15 *)bus___0->params)->flash;
#line 266
  comp->ctype = (ctype_t )1;
#line 267
  comp->cname = (char *)"FLASH";
#line 269
  tmp___78 = generic_bus_attach_sig(part, & comp->a[0], (char *)"IO47");
#line 269
  failed |= tmp___78;
#line 270
  tmp___79 = generic_bus_attach_sig(part, & comp->a[1], (char *)"IO48");
#line 270
  failed |= tmp___79;
#line 271
  tmp___80 = generic_bus_attach_sig(part, & comp->a[2], (char *)"IO49");
#line 271
  failed |= tmp___80;
#line 272
  tmp___81 = generic_bus_attach_sig(part, & comp->a[3], (char *)"IO50");
#line 272
  failed |= tmp___81;
#line 273
  tmp___82 = generic_bus_attach_sig(part, & comp->a[4], (char *)"IO125");
#line 273
  failed |= tmp___82;
#line 274
  tmp___83 = generic_bus_attach_sig(part, & comp->a[5], (char *)"IO127");
#line 274
  failed |= tmp___83;
#line 275
  tmp___84 = generic_bus_attach_sig(part, & comp->a[6], (char *)"IO131");
#line 275
  failed |= tmp___84;
#line 276
  tmp___85 = generic_bus_attach_sig(part, & comp->a[7], (char *)"IO133");
#line 276
  failed |= tmp___85;
#line 277
  tmp___86 = generic_bus_attach_sig(part, & comp->a[8], (char *)"IO158");
#line 277
  failed |= tmp___86;
#line 278
  tmp___87 = generic_bus_attach_sig(part, & comp->a[9], (char *)"IO16");
#line 278
  failed |= tmp___87;
#line 279
  tmp___88 = generic_bus_attach_sig(part, & comp->a[10], (char *)"IO20");
#line 279
  failed |= tmp___88;
#line 280
  tmp___89 = generic_bus_attach_sig(part, & comp->a[11], (char *)"IO14");
#line 280
  failed |= tmp___89;
#line 281
  tmp___90 = generic_bus_attach_sig(part, & comp->a[12], (char *)"IO135");
#line 281
  failed |= tmp___90;
#line 282
  tmp___91 = generic_bus_attach_sig(part, & comp->a[13], (char *)"IO156");
#line 282
  failed |= tmp___91;
#line 283
  tmp___92 = generic_bus_attach_sig(part, & comp->a[14], (char *)"IO144");
#line 283
  failed |= tmp___92;
#line 284
  tmp___93 = generic_bus_attach_sig(part, & comp->a[15], (char *)"IO137");
#line 284
  failed |= tmp___93;
#line 285
  tmp___94 = generic_bus_attach_sig(part, & comp->a[16], (char *)"IO139");
#line 285
  failed |= tmp___94;
#line 286
  tmp___95 = generic_bus_attach_sig(part, & comp->a[17], (char *)"IO143");
#line 286
  failed |= tmp___95;
#line 287
  tmp___96 = generic_bus_attach_sig(part, & comp->a[18], (char *)"IO141");
#line 287
  failed |= tmp___96;
#line 289
  tmp___97 = generic_bus_attach_sig(part, & comp->d[0], (char *)"IO46");
#line 289
  failed |= tmp___97;
#line 290
  tmp___98 = generic_bus_attach_sig(part, & comp->d[1], (char *)"IO45");
#line 290
  failed |= tmp___98;
#line 291
  tmp___99 = generic_bus_attach_sig(part, & comp->d[2], (char *)"IO44");
#line 291
  failed |= tmp___99;
#line 292
  tmp___100 = generic_bus_attach_sig(part, & comp->d[3], (char *)"IO165");
#line 292
  failed |= tmp___100;
#line 293
  tmp___101 = generic_bus_attach_sig(part, & comp->d[4], (char *)"IO164");
#line 293
  failed |= tmp___101;
#line 294
  tmp___102 = generic_bus_attach_sig(part, & comp->d[5], (char *)"IO17");
#line 294
  failed |= tmp___102;
#line 295
  tmp___103 = generic_bus_attach_sig(part, & comp->d[6], (char *)"IO18");
#line 295
  failed |= tmp___103;
#line 296
  tmp___104 = generic_bus_attach_sig(part, & comp->d[7], (char *)"IO19");
#line 296
  failed |= tmp___104;
#line 297
  comp->d[8] = (signal_t *)((void *)0);
#line 298
  comp->d[9] = (signal_t *)((void *)0);
#line 299
  comp->d[10] = (signal_t *)((void *)0);
#line 300
  comp->d[11] = (signal_t *)((void *)0);
#line 301
  comp->d[12] = (signal_t *)((void *)0);
#line 302
  comp->d[13] = (signal_t *)((void *)0);
#line 303
  comp->d[14] = (signal_t *)((void *)0);
#line 304
  comp->d[15] = (signal_t *)((void *)0);
#line 306
  tmp___105 = generic_bus_attach_sig(part, & comp->nwe, (char *)"IO15");
#line 306
  failed |= tmp___105;
#line 307
  tmp___106 = generic_bus_attach_sig(part, & comp->noe, (char *)"IO24");
#line 307
  failed |= tmp___106;
#line 308
  tmp___107 = generic_bus_attach_sig(part, & comp->ncs, (char *)"IO37");
#line 308
  failed |= tmp___107;
#line 309
  tmp___108 = generic_bus_attach_sig(part, & comp->ncs2, (char *)"IO23");
#line 309
  failed |= tmp___108;
#line 314
  comp->nrdy = (signal_t *)((void *)0);
#line 316
  comp->nlb = (signal_t *)((void *)0);
#line 317
  comp->nub = (signal_t *)((void *)0);
#line 322
  tmp___109 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_rxd,
                                     (char *)"CLK2");
#line 322
  failed |= tmp___109;
#line 323
  tmp___110 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_nrts,
                                     (char *)"IO177");
#line 323
  failed |= tmp___110;
#line 324
  tmp___111 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_txd,
                                     (char *)"IO178");
#line 324
  failed |= tmp___111;
#line 325
  tmp___112 = generic_bus_attach_sig(part, & ((bus_params_t___15 *)bus___0->params)->ser_ncts,
                                     (char *)"CLK0");
#line 325
  failed |= tmp___112;
  }
#line 327
  if (failed) {
    {
#line 328
    free(bus___0->params);
#line 329
    free((void *)bus___0);
    }
#line 330
    return ((bus_t *)((void *)0));
  }
#line 333
  return (bus___0);
}
}
#line 340 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static void jopcyc_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 345
  i = 0;
  {
#line 345
  while (1) {
    while_continue: /* CIL Label */ ;
#line 345
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 345
      goto while_break;
    }
#line 346
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 347
      goto while_break;
    }
#line 345
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 348
  tmp = gettext("JOP.design Cyclone Board compatible bus driver via BSR (JTAG part No. %d)\n");
#line 348
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 349
  return;
}
}
#line 351 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static void setup_address___15(bus_t *bus___0 , uint32_t a , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int addr_width ;

  {
#line 355
  p = bus___0->part;
#line 358
  ((bus_params_t___15 *)bus___0->params)->last_addr = a;
  {
#line 361
  if ((unsigned int )comp->ctype == 0U) {
#line 361
    goto case_0;
  }
#line 367
  if ((unsigned int )comp->ctype == 1U) {
#line 367
    goto case_1;
  }
#line 370
  goto switch_default;
  case_0: /* CIL Label */ 
#line 362
  addr_width = 18;
#line 365
  a >>= 1;
#line 366
  goto switch_break;
  case_1: /* CIL Label */ 
#line 368
  addr_width = 19;
#line 369
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 371
  addr_width = 0;
#line 372
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 375
  i = 0;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! (i < addr_width)) {
#line 375
      goto while_break;
    }
    {
#line 376
    part_set_signal(p, comp->a[i], 1, (int )((a >> i) & 1U));
#line 375
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 377
  return;
}
}
#line 379 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static int detect_data_width___0(component_t___0 *comp ) 
{ 
  int width ;

  {
  {
#line 385
  if ((unsigned int )comp->ctype == 0U) {
#line 385
    goto case_0;
  }
#line 388
  if ((unsigned int )comp->ctype == 1U) {
#line 388
    goto case_1;
  }
#line 391
  goto switch_default;
  case_0: /* CIL Label */ 
#line 386
  width = 16;
#line 387
  goto switch_break;
  case_1: /* CIL Label */ 
#line 389
  width = 8;
#line 390
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 392
  width = 0;
#line 393
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 396
  return (width);
}
}
#line 399 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static void set_data_in___15(bus_t *bus___0 , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 403
  p = bus___0->part;
#line 406
  width = detect_data_width___0(comp);
#line 408
  i = 0;
  }
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
#line 408
    if (! (i < width)) {
#line 408
      goto while_break;
    }
    {
#line 409
    part_set_signal(p, comp->d[i], 0, 0);
#line 408
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return;
}
}
#line 412 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static void setup_data___15(bus_t *bus___0 , uint32_t d , component_t___0 *comp ) 
{ 
  int i ;
  part_t *p ;
  int width ;

  {
  {
#line 416
  p = bus___0->part;
#line 419
  width = detect_data_width___0(comp);
#line 421
  i = 0;
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (i < width)) {
#line 421
      goto while_break;
    }
    {
#line 422
    part_set_signal(p, comp->d[i], 1, (int )((d >> i) & 1U));
#line 421
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 423
  return;
}
}
#line 429 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static int jopcyc_bus_init(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  component_t___0 *comp ;

  {
  {
#line 432
  p = bus___0->part;
#line 433
  chain = bus___0->chain;
#line 439
  part_set_instruction(p, "SAMPLE/PRELOAD");
#line 440
  chain_shift_instructions(chain);
#line 443
  comp = & ((bus_params_t___15 *)bus___0->params)->rama;
#line 444
  set_data_in___15(bus___0, comp);
#line 445
  part_set_signal(p, comp->ncs, 1, 1);
#line 446
  part_set_signal(p, comp->nwe, 1, 1);
#line 447
  part_set_signal(p, comp->noe, 1, 1);
#line 448
  part_set_signal(p, comp->nlb, 1, 1);
#line 449
  part_set_signal(p, comp->nub, 1, 1);
#line 452
  comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
#line 453
  set_data_in___15(bus___0, comp);
#line 454
  part_set_signal(p, comp->ncs, 1, 1);
#line 455
  part_set_signal(p, comp->nwe, 1, 1);
#line 456
  part_set_signal(p, comp->noe, 1, 1);
#line 457
  part_set_signal(p, comp->nlb, 1, 1);
#line 458
  part_set_signal(p, comp->nub, 1, 1);
#line 461
  comp = & ((bus_params_t___15 *)bus___0->params)->flash;
#line 462
  set_data_in___15(bus___0, comp);
#line 463
  part_set_signal(p, comp->ncs, 1, 1);
#line 464
  part_set_signal(p, comp->nwe, 1, 1);
#line 465
  part_set_signal(p, comp->noe, 1, 1);
#line 466
  part_set_signal(p, comp->ncs2, 1, 1);
#line 467
  part_set_signal(p, comp->nrdy, 0, 0);
#line 470
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_rxd, 0, 0);
#line 471
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_nrts, 1, 1);
#line 472
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_txd, 1, 1);
#line 473
  part_set_signal(p, ((bus_params_t___15 *)bus___0->params)->ser_ncts, 0, 0);
#line 475
  chain_shift_data_registers(chain, 0);
#line 477
  bus___0->initialized = 1;
  }
#line 479
  return (0);
}
}
#line 482 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static int comp_bus_area___0(bus_t *bus___0 , uint32_t adr , bus_area_t *area , component_t___0 **comp ) 
{ 


  {
#line 485
  if (adr < (uint32_t )(1 << 19)) {
#line 486
    area->description = "RAMA Component";
#line 487
    area->start = (uint32_t )0;
#line 488
    area->length = (uint64_t )(1 << 19);
#line 489
    area->width = 16U;
#line 490
    *comp = & ((bus_params_t___15 *)bus___0->params)->rama;
  } else
#line 491
  if (adr < (uint32_t )(2 * (1 << 19))) {
#line 492
    area->description = "RAMB Component";
#line 493
    area->start = (uint32_t )(1 << 19);
#line 494
    area->length = (uint64_t )(1 << 19);
#line 495
    area->width = 16U;
#line 496
    *comp = & ((bus_params_t___15 *)bus___0->params)->ramb;
  } else
#line 497
  if (adr < (uint32_t )(2 * (1 << 19) + (1 << 19))) {
#line 498
    area->description = "FLASH Component";
#line 499
    area->start = (uint32_t )(2 * (1 << 19));
#line 500
    area->length = (uint64_t )(1 << 19);
#line 501
    area->width = 8U;
#line 502
    *comp = & ((bus_params_t___15 *)bus___0->params)->flash;
  } else {
#line 504
    area->description = "Dummy";
#line 505
    area->start = (uint32_t )(2 * (1 << 19) + (1 << 19));
#line 506
    area->length = 4294967296UL;
#line 507
    area->width = 0U;
#line 508
    *comp = (component_t___0 *)((void *)0);
  }
#line 511
  return (0);
}
}
#line 518 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static int jopcyc_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  component_t___0 *comp ;
  int tmp ;

  {
  {
#line 523
  tmp = comp_bus_area___0(bus___0, adr, area, & comp);
  }
#line 523
  return (tmp);
}
}
#line 530 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static void jopcyc_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;

  {
  {
#line 533
  p = bus___0->part;
#line 534
  chain = bus___0->chain;
#line 538
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 539
  if (! comp) {
    {
#line 540
    tmp = gettext("Address out of range\n");
#line 540
    printf((char const   */* __restrict  */)tmp);
#line 541
    ((bus_params_t___15 *)bus___0->params)->last_addr = adr;
    }
#line 542
    return;
  }
  {
#line 545
  part_set_signal(p, comp->ncs, 1, 0);
#line 546
  part_set_signal(p, comp->nwe, 1, 1);
#line 547
  part_set_signal(p, comp->noe, 1, 0);
  }
#line 548
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 549
    part_set_signal(p, comp->nlb, 1, 0);
#line 550
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 553
  setup_address___15(bus___0, adr, comp);
#line 554
  set_data_in___15(bus___0, comp);
#line 556
  chain_shift_data_registers(chain, 0);
  }
#line 557
  return;
}
}
#line 563 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 566
  p = bus___0->part;
#line 567
  chain = bus___0->chain;
#line 569
  d = (uint32_t )0;
#line 573
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 574
  if (! comp) {
    {
#line 575
    tmp = gettext("Address out of range\n");
#line 575
    printf((char const   */* __restrict  */)tmp);
#line 576
    ((bus_params_t___15 *)bus___0->params)->last_addr = adr;
    }
#line 577
    return ((uint32_t )0);
  }
  {
#line 580
  setup_address___15(bus___0, adr, comp);
#line 581
  chain_shift_data_registers(chain, 1);
#line 583
  i = 0;
  }
  {
#line 583
  while (1) {
    while_continue: /* CIL Label */ ;
#line 583
    if (! ((unsigned int )i < area.width)) {
#line 583
      goto while_break;
    }
    {
#line 584
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 584
    d |= (uint32_t )(tmp___0 << i);
#line 583
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 586
  return (d);
}
}
#line 593 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static uint32_t jopcyc_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 596
  p = bus___0->part;
#line 597
  chain = bus___0->chain;
#line 599
  d = (uint32_t )0;
#line 604
  comp_bus_area___0(bus___0, ((bus_params_t___15 *)bus___0->params)->last_addr, & area,
                    & comp);
  }
#line 605
  if (! comp) {
    {
#line 606
    tmp = gettext("Address out of range\n");
#line 606
    printf((char const   */* __restrict  */)tmp);
    }
#line 607
    return ((uint32_t )0);
  }
  {
#line 610
  part_set_signal(p, comp->ncs, 1, 1);
#line 611
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 612
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 613
    part_set_signal(p, comp->nlb, 1, 1);
#line 614
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 616
  chain_shift_data_registers(chain, 1);
#line 618
  i = 0;
  }
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! ((unsigned int )i < area.width)) {
#line 618
      goto while_break;
    }
    {
#line 619
    tmp___0 = part_get_signal(p, comp->d[i]);
#line 619
    d |= (uint32_t )(tmp___0 << i);
#line 618
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 621
  return (d);
}
}
#line 628 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
static void jopcyc_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;
  bus_area_t area ;
  component_t___0 *comp ;
  char *tmp ;

  {
  {
#line 631
  p = bus___0->part;
#line 632
  chain = bus___0->chain;
#line 636
  comp_bus_area___0(bus___0, adr, & area, & comp);
  }
#line 637
  if (! comp) {
    {
#line 638
    tmp = gettext("Address out of range\n");
#line 638
    printf((char const   */* __restrict  */)tmp);
    }
#line 639
    return;
  }
  {
#line 642
  part_set_signal(p, comp->ncs, 1, 0);
#line 643
  part_set_signal(p, comp->nwe, 1, 1);
#line 644
  part_set_signal(p, comp->noe, 1, 1);
  }
#line 645
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 646
    part_set_signal(p, comp->nlb, 1, 0);
#line 647
    part_set_signal(p, comp->nub, 1, 0);
    }
  }
  {
#line 650
  setup_address___15(bus___0, adr, comp);
#line 651
  setup_data___15(bus___0, data, comp);
#line 653
  chain_shift_data_registers(chain, 0);
#line 655
  part_set_signal(p, comp->nwe, 1, 0);
#line 656
  chain_shift_data_registers(chain, 0);
#line 657
  part_set_signal(p, comp->nwe, 1, 1);
#line 658
  part_set_signal(p, comp->ncs, 1, 1);
  }
#line 659
  if ((unsigned int )comp->ctype == 0U) {
    {
#line 660
    part_set_signal(p, comp->nlb, 1, 1);
#line 661
    part_set_signal(p, comp->nub, 1, 1);
    }
  }
  {
#line 663
  chain_shift_data_registers(chain, 0);
  }
#line 664
  return;
}
}
#line 666 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/jopcyc.c"
struct bus_driver  const  jopcyc_bus  = 
#line 666
     {"jopcyc", "JOP.design Cyclone Board compatible bus driver via BSR", & jopcyc_bus_new,
    & generic_bus_free, & jopcyc_bus_printinfo, & generic_bus_prepare_extest, & jopcyc_bus_area,
    & jopcyc_bus_read_start, & jopcyc_bus_read_next, & jopcyc_bus_read_end, & generic_bus_read,
    & jopcyc_bus_write, & jopcyc_bus_init};
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  ixp425_bus ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static bus_t *ixp425_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 65
  failed = 0;
#line 67
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 67
  bus___0 = (bus_t *)tmp;
  }
#line 68
  if (! bus___0) {
#line 69
    return ((bus_t *)((void *)0));
  }
  {
#line 71
  bus___0->driver = driver;
#line 72
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___16 ));
  }
#line 73
  if (! bus___0->params) {
    {
#line 74
    free((void *)bus___0);
    }
#line 75
    return ((bus_t *)((void *)0));
  }
#line 78
  bus___0->chain = chain;
#line 79
  part = *((chain->parts)->parts + chain->active_part);
#line 79
  bus___0->part = part;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 8)) {
#line 81
      goto while_break;
    }
    {
#line 82
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_CS[%d]",
            i);
#line 83
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_cs[i],
                                     buff);
#line 83
    failed |= tmp___0;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < 24)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_ADDR[%d]",
            i);
#line 88
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_addr[i],
                                     buff);
#line 88
    failed |= tmp___1;
#line 86
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 91
    if (! (i < 16)) {
#line 91
      goto while_break___1;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"EX_DATA[%d]",
            i);
#line 93
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_data[i],
                                     buff);
#line 93
    failed |= tmp___2;
#line 91
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 96
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_wr,
                                   (char *)"EX_WR");
#line 96
  failed |= tmp___3;
#line 98
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___16 *)bus___0->params)->ex_rd,
                                   (char *)"EX_RD");
#line 98
  failed |= tmp___4;
  }
#line 100
  if (failed) {
    {
#line 101
    free(bus___0->params);
#line 102
    free((void *)bus___0);
    }
#line 103
    return ((bus_t *)((void *)0));
  }
#line 106
  return (bus___0);
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void ixp425_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 118
      goto while_break;
    }
#line 119
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 120
      goto while_break;
    }
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  tmp = gettext("Intel IXP425 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 121
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 122
  return;
}
}
#line 128 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static int ixp425_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 131
  area->description = (char const   *)((void *)0);
#line 132
  area->start = 0U;
#line 133
  area->length = 4294967296UL;
#line 134
  area->width = 16U;
#line 136
  return (0);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void select_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 142
  p = bus___0->part;
#line 144
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[0], 1, 0);
#line 145
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[1], 1, 1);
#line 146
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[2], 1, 1);
#line 147
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[3], 1, 1);
#line 148
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[4], 1, 1);
#line 149
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[5], 1, 1);
#line 150
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[6], 1, 1);
#line 151
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void unselect_flash___0(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 157
  p = bus___0->part;
#line 159
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[0], 1, 1);
#line 160
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[1], 1, 1);
#line 161
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[2], 1, 1);
#line 162
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[3], 1, 1);
#line 163
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[4], 1, 1);
#line 164
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[5], 1, 1);
#line 165
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[6], 1, 1);
#line 166
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_cs[7], 1, 1);
  }
#line 167
  return;
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void setup_address___16(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 173
  p = bus___0->part;
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue: /* CIL Label */ ;
#line 175
    if (! (i < 24)) {
#line 175
      goto while_break;
    }
    {
#line 176
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_addr[i], 1, (int )((a >> i) & 1U));
#line 175
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void set_data_in___16(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 183
  p = bus___0->part;
#line 185
  i = 0;
  {
#line 185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 185
    if (! (i < 16)) {
#line 185
      goto while_break;
    }
    {
#line 186
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i], 0, 0);
#line 185
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void setup_data___16(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 193
  p = bus___0->part;
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < 16)) {
#line 195
      goto while_break;
    }
    {
#line 196
    part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i], 1, (int )((d >> i) & 1U));
#line 195
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 203 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void ixp425_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 206
  p = bus___0->part;
#line 207
  chain = bus___0->chain;
#line 209
  select_flash___0(bus___0);
#line 210
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 0);
#line 211
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 213
  setup_address___16(bus___0, adr);
#line 214
  set_data_in___16(bus___0);
#line 216
  chain_shift_data_registers(chain, 0);
  }
#line 217
  return;
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 226
  p = bus___0->part;
#line 227
  chain = bus___0->chain;
#line 229
  d = (uint32_t )0;
#line 231
  setup_address___16(bus___0, adr);
#line 232
  chain_shift_data_registers(chain, 1);
#line 234
  i = 0;
  }
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < 16)) {
#line 234
      goto while_break;
    }
    {
#line 235
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i]);
#line 235
    d |= (uint32_t )(tmp << i);
#line 234
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (d);
}
}
#line 244 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static uint32_t ixp425_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 247
  p = bus___0->part;
#line 248
  chain = bus___0->chain;
#line 250
  d = (uint32_t )0;
#line 252
  unselect_flash___0(bus___0);
#line 253
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 1);
#line 254
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 256
  chain_shift_data_registers(chain, 1);
#line 258
  i = 0;
  }
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! (i < 16)) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = part_get_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_data[i]);
#line 259
    d |= (uint32_t )(tmp << i);
#line 258
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (d);
}
}
#line 268 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
static void ixp425_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 271
  p = bus___0->part;
#line 272
  chain = bus___0->chain;
#line 274
  select_flash___0(bus___0);
#line 275
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_rd, 1, 1);
#line 277
  setup_address___16(bus___0, adr);
#line 278
  setup_data___16(bus___0, data);
#line 280
  chain_shift_data_registers(chain, 0);
#line 282
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 0);
#line 283
  chain_shift_data_registers(chain, 0);
#line 284
  part_set_signal(p, ((bus_params_t___16 *)bus___0->params)->ex_wr, 1, 1);
#line 285
  unselect_flash___0(bus___0);
#line 286
  chain_shift_data_registers(chain, 0);
  }
#line 287
  return;
}
}
#line 289 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ixp425.c"
struct bus_driver  const  ixp425_bus  = 
#line 289
     {"ixp425", "Intel IXP425 compatible bus driver via BSR", & ixp425_bus_new, & generic_bus_free,
    & ixp425_bus_printinfo, & generic_bus_prepare_extest, & ixp425_bus_area, & ixp425_bus_read_start,
    & ixp425_bus_read_next, & ixp425_bus_read_end, & generic_bus_read, & ixp425_bus_write,
    & generic_bus_no_init};
#line 42 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  h7202_bus ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static bus_t *h7202_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 65
  failed = 0;
#line 67
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 67
  bus___0 = (bus_t *)tmp;
  }
#line 68
  if (! bus___0) {
#line 69
    return ((bus_t *)((void *)0));
  }
  {
#line 71
  bus___0->driver = driver;
#line 72
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___17 ));
  }
#line 73
  if (! bus___0->params) {
    {
#line 74
    free((void *)bus___0);
    }
#line 75
    return ((bus_t *)((void *)0));
  }
#line 78
  bus___0->chain = chain;
#line 79
  part = *((chain->parts)->parts + chain->active_part);
#line 79
  bus___0->part = part;
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < 25)) {
#line 81
      goto while_break;
    }
    {
#line 82
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RA%d",
            i);
#line 83
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->a[i],
                                     buff);
#line 83
    failed |= tmp___0;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 86
    if (! (i < 32)) {
#line 86
      goto while_break___0;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 88
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->d[i],
                                     buff);
#line 88
    failed |= tmp___1;
#line 86
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break___1;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRCS%d",
            i);
#line 93
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->nRCS[i],
                                     buff);
#line 93
    failed |= tmp___2;
#line 91
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 96
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->nROE,
                                   (char *)"nROE");
#line 96
  failed |= tmp___3;
#line 98
  i = 0;
  }
  {
#line 98
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 98
    if (! (i < 4)) {
#line 98
      goto while_break___2;
    }
    {
#line 99
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"nRWE%d",
            i);
#line 100
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___17 *)bus___0->params)->nRWE[i],
                                     buff);
#line 100
    failed |= tmp___4;
#line 98
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 103
  if (failed) {
    {
#line 104
    free(bus___0->params);
#line 105
    free((void *)bus___0);
    }
#line 106
    return ((bus_t *)((void *)0));
  }
#line 109
  return (bus___0);
}
}
#line 116 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static void h7202_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;

  {
#line 121
  i = 0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 121
      goto while_break;
    }
#line 122
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 123
      goto while_break;
    }
#line 121
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  printf((char const   */* __restrict  */)"H7202 compatible bus driver via BSR (JTAG part No. %d)\n",
         i);
  }
#line 125
  return;
}
}
#line 131 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static int h7202_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 134
  area->description = (char const   *)((void *)0);
#line 135
  area->start = 0U;
#line 136
  area->length = 4294967296UL;
#line 137
  area->width = 16U;
#line 139
  return (0);
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static void setup_address___17(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 146
  p = bus___0->part;
#line 148
  i = 0;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i < 26)) {
#line 148
      goto while_break;
    }
    {
#line 149
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 148
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 152 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static void set_data_in___17(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 156
  p = bus___0->part;
#line 159
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 161
  i = 0;
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! ((unsigned int )i < area.width)) {
#line 161
      goto while_break;
    }
    {
#line 162
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i], 0, 0);
#line 161
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return;
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static void setup_data___17(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 169
  p = bus___0->part;
#line 172
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 174
  i = 0;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned int )i < area.width)) {
#line 174
      goto while_break;
    }
    {
#line 175
    part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i], 1, (int )((d >> i) & 1U));
#line 174
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  return;
}
}
#line 182 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static void h7202_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 186
  p = bus___0->part;
#line 187
  chain = bus___0->chain;
#line 189
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 0);
#line 190
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 0);
#line 196
  setup_address___17(bus___0, adr);
#line 197
  set_data_in___17(bus___0);
#line 199
  chain_shift_data_registers(chain, 0);
  }
#line 200
  return;
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static uint32_t h7202_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 210
  p = bus___0->part;
#line 211
  chain = bus___0->chain;
#line 213
  d = (uint32_t )0;
#line 216
  h7202_bus_area(bus___0, adr, & area);
#line 218
  setup_address___17(bus___0, adr);
#line 219
  chain_shift_data_registers(chain, 1);
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 221
    if (! ((unsigned int )i < area.width)) {
#line 221
      goto while_break;
    }
    {
#line 222
    tmp = part_get_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i]);
#line 222
    d |= (uint32_t )(tmp << i);
#line 221
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return (d);
}
}
#line 231 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static uint32_t h7202_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  bus_area_t area ;
  int tmp ;

  {
  {
#line 235
  p = bus___0->part;
#line 236
  chain = bus___0->chain;
#line 238
  d = (uint32_t )0;
#line 241
  h7202_bus_area(bus___0, (uint32_t )0, & area);
#line 243
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 1);
#line 244
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 245
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 246
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 247
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 1);
#line 248
  chain_shift_data_registers(chain, 1);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! ((unsigned int )i < area.width)) {
#line 250
      goto while_break;
    }
    {
#line 251
    tmp = part_get_signal(p, ((bus_params_t___17 *)bus___0->params)->d[i]);
#line 251
    d |= (uint32_t )(tmp << i);
#line 250
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (d);
}
}
#line 260 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
static void h7202_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 264
  p = bus___0->part;
#line 265
  chain = bus___0->chain;
#line 271
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 0);
#line 272
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 276
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 0);
#line 277
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[1], 1, 1);
#line 278
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[2], 1, 1);
#line 279
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[3], 1, 1);
#line 280
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nROE, 1, 1);
#line 282
  setup_address___17(bus___0, adr);
#line 283
  setup_data___17(bus___0, data);
#line 285
  chain_shift_data_registers(chain, 0);
#line 287
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRWE[0], 1, 1);
#line 288
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[0], 1, 1);
#line 289
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[1], 1, 1);
#line 290
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[2], 1, 1);
#line 291
  part_set_signal(p, ((bus_params_t___17 *)bus___0->params)->nRCS[3], 1, 1);
#line 292
  chain_shift_data_registers(chain, 0);
  }
#line 293
  return;
}
}
#line 295 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/h7202.c"
struct bus_driver  const  h7202_bus  = 
#line 295
     {"h7202", "H7202 compatible bus driver via BSR", & h7202_bus_new, & generic_bus_free,
    & h7202_bus_printinfo, & generic_bus_prepare_extest, & h7202_bus_area, & h7202_bus_read_start,
    & h7202_bus_read_next, & h7202_bus_read_end, & generic_bus_read, & h7202_bus_write,
    & generic_bus_no_init};
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.c"
int generic_bus_attach_sig(part_t *part , signal_t **sig , char *id ) 
{ 
  int failed ;
  char *tmp ;

  {
  {
#line 34
  failed = 0;
#line 36
  *sig = part_find_signal(part, (char const   *)id);
  }
#line 37
  if (! *sig) {
    {
#line 38
    tmp = gettext("signal \'%s\' not found\n");
#line 38
    printf((char const   */* __restrict  */)tmp, id);
#line 39
    failed = 1;
    }
  }
#line 42
  return (failed);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.c"
void generic_bus_free(bus_t *bus___0 ) 
{ 


  {
  {
#line 52
  free(bus___0->params);
#line 53
  free((void *)bus___0);
  }
#line 54
  return;
}
}
#line 60 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.c"
int generic_bus_no_init(bus_t *bus___0 ) 
{ 


  {
#line 63
  bus___0->initialized = 1;
#line 65
  return (0);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.c"
void generic_bus_prepare_extest(bus_t *bus___0 ) 
{ 


  {
#line 75
  if (! bus___0->initialized) {
    {
#line 76
    (*((bus___0->driver)->init))(bus___0);
    }
  }
  {
#line 78
  part_set_instruction(bus___0->part, "EXTEST");
#line 79
  chain_shift_instructions(bus___0->chain);
  }
#line 80
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/generic_bus.c"
uint32_t generic_bus_read(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t tmp ;

  {
  {
#line 89
  (*((bus___0->driver)->read_start))(bus___0, adr);
#line 90
  tmp = (*((bus___0->driver)->read_end))(bus___0);
  }
#line 90
  return (tmp);
}
}
#line 38 "../../include/register.h"
tap_register *register_fill(tap_register *tr , int val ) ;
#line 41 "../../include/data_register.h"
data_register *data_register_alloc(char const   *name , int len ) ;
#line 43 "../../include/instruction.h"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) ;
#line 54 "../../include/chain.h"
int chain_set_trst(chain_t *chain , int trst ) ;
#line 41 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  fjmem_bus ;
#line 50 "../../include/cmd.h"
int cmd_params(char **params ) ;
#line 51
int cmd_get_number(char *s , unsigned int *i ) ;
#line 32 "../../include/tap.h"
void tap_reset_bypass(chain_t *chain ) ;
#line 33
void tap_capture_dr(chain_t *chain ) ;
#line 37
void tap_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                        int exit___0 ) ;
#line 80 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static int fjmem_detect_reg_len(chain_t *chain , part_t *part , char *opcode , int len ) 
{ 
  data_register *dr ;
  instruction *i ;
  int l ;
  int fjmem_reg_len ;
  char *tdo_bit ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 89
  dr = data_register_alloc("FJMEM_REG", 1);
  }
#line 90
  if (! dr) {
    {
#line 91
    tmp = gettext("out of memory\n");
#line 91
    printf((char const   */* __restrict  */)tmp);
    }
#line 92
    return (0);
  }
  {
#line 95
  dr->next = part->data_registers;
#line 96
  part->data_registers = dr;
#line 100
  tmp___1 = strlen((char const   *)opcode);
  }
#line 100
  if (tmp___1 != (size_t )part->instruction_length) {
    {
#line 101
    tmp___0 = gettext("invalid instruction length\n");
#line 101
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 102
    return (0);
  }
  {
#line 104
  i = instruction_alloc("FJMEM_INST", part->instruction_length, (char const   *)opcode);
  }
#line 105
  if (! i) {
    {
#line 106
    tmp___2 = gettext("out of memory\n");
#line 106
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 107
    return (0);
  }
  {
#line 109
  i->next = part->instructions;
#line 110
  part->instructions = i;
#line 111
  i->data_register = dr;
#line 115
  chain_set_trst(chain, 0);
#line 116
  chain_set_trst(chain, 1);
#line 117
  tap_reset_bypass(chain);
#line 120
  register_fill(dr->in, 0);
#line 121
  tap_capture_dr(chain);
#line 122
  l = 0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (l < (chain->parts)->len)) {
#line 122
      goto while_break;
    }
    {
#line 123
    tap_shift_register(chain, (tap_register const   *)dr->in, (tap_register *)((void *)0),
                       0);
#line 122
    l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  tap_shift_register(chain, (tap_register const   *)dr->in, (tap_register *)((void *)0),
                     1);
#line 128
  part_set_instruction(part, "FJMEM_INST");
#line 129
  chain_shift_instructions(chain);
  }
#line 132
  if (len) {
#line 133
    return (len);
  }
  {
#line 140
  fjmem_reg_len = 0;
#line 141
  register_fill(dr->in, 1);
#line 142
  register_fill(dr->out, 0);
#line 143
  tdo_bit = (dr->out)->data;
#line 145
  tap_capture_dr(chain);
#line 147
  tap_shift_register(chain, (tap_register const   *)dr->in, dr->out, 0);
#line 148
  register_get_string((tap_register const   *)dr->out);
  }
  {
#line 149
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 149
    if ((int )*(tdo_bit + 0) == 0) {
#line 149
      if (! (fjmem_reg_len < 2048)) {
#line 149
        goto while_break___0;
      }
    } else {
#line 149
      goto while_break___0;
    }
    {
#line 151
    tap_shift_register(chain, (tap_register const   *)dr->in, dr->out, 0);
#line 152
    tdo_bit = (dr->out)->data;
#line 153
    fjmem_reg_len ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 156
  fjmem_reg_len -= (chain->parts)->len - 1;
#line 158
  tap_shift_register(chain, (tap_register const   *)dr->in, (tap_register *)((void *)0),
                     1);
  }
#line 163
  if (fjmem_reg_len < 2048) {
#line 163
    tmp___3 = fjmem_reg_len;
  } else {
#line 163
    tmp___3 = -1;
  }
#line 163
  return (tmp___3);
}
}
#line 166 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static int fjmem_detect_fields(chain_t *chain , part_t *part , bus_t *bus___0 ) 
{ 
  block_desc_t *bd ;
  data_register *dr ;
  int idx ;
  char *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  tap_register *tmp___2 ;

  {
#line 169
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 170
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 177
  bd->block_len = (uint16_t )0;
#line 178
  bd->addr_pos = (uint16_t )0;
#line 179
  bd->addr_len = (uint16_t )0;
#line 180
  bd->data_pos = (uint16_t )0;
#line 181
  bd->data_len = (uint16_t )0;
#line 184
  if (dr->in) {
    {
#line 185
    free((void *)dr->in);
    }
  }
  {
#line 186
  tmp___0 = register_alloc((int )bd->reg_len);
#line 186
  dr->in = tmp___0;
  }
#line 186
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 187
    tmp = gettext("out of memory\n");
#line 187
    printf((char const   */* __restrict  */)tmp);
    }
#line 188
    return (0);
  }
#line 190
  if (dr->out) {
    {
#line 191
    free((void *)dr->out);
    }
  }
  {
#line 192
  tmp___2 = register_alloc((int )bd->reg_len);
#line 192
  dr->out = tmp___2;
  }
#line 192
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 193
    tmp___1 = gettext("out of memory\n");
#line 193
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 194
    return (0);
  }
  {
#line 198
  register_fill(dr->in, 1);
#line 199
  chain_shift_data_registers(chain, 1);
#line 203
  register_fill(dr->in, 0);
#line 205
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)1;
#line 206
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)1;
#line 209
  chain_shift_data_registers(chain, 1);
#line 217
  idx = (int )bd->block_pos;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (*((dr->out)->data + idx)) {
#line 218
      if (! (idx < (dr->out)->len)) {
#line 218
        goto while_break;
      }
    } else {
#line 218
      goto while_break;
    }
#line 219
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  bd->block_len = (uint16_t )(idx - (int )bd->block_pos);
#line 222
  bd->addr_pos = (uint16_t )idx;
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if ((int )*((dr->out)->data + idx) == 0) {
#line 223
      if (! (idx < (dr->out)->len)) {
#line 223
        goto while_break___0;
      }
    } else {
#line 223
      goto while_break___0;
    }
#line 224
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 225
  bd->addr_len = (uint16_t )(idx - (int )bd->addr_pos);
#line 227
  bd->data_pos = (uint16_t )idx;
  {
#line 228
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 228
    if (*((dr->out)->data + idx)) {
#line 228
      if (! (idx < (dr->out)->len)) {
#line 228
        goto while_break___1;
      }
    } else {
#line 228
      goto while_break___1;
    }
#line 229
    idx ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 230
  bd->data_len = (uint16_t )(idx - (int )bd->data_pos);
#line 238
  if ((int )bd->block_len > 0) {
#line 238
    if ((int )bd->addr_len > 0) {
#line 238
      if ((int )bd->data_len > 0) {
#line 241
        return (1);
      } else {
#line 243
        return (0);
      }
    } else {
#line 243
      return (0);
    }
  } else {
#line 243
    return (0);
  }
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static int fjmem_query_blocks(chain_t *chain , part_t *part , bus_t *bus___0 ) 
{ 
  block_desc_t *bd ;
  data_register *dr ;
  int max_block_num ;
  int block_num ;
  int failed ;
  int next_block_num ;
  int idx ;
  int addr_len ;
  int data_len ;
  block_param_t *bl ;
  int nbytes ;
  char *tmp ;
  void *tmp___0 ;
  uint32_t mask ;
  int tmp___1 ;

  {
#line 249
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 250
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 252
  failed = 0;
#line 259
  max_block_num = (1 << (int )bd->block_len) - 1;
#line 260
  block_num = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (block_num <= max_block_num)) {
#line 260
      goto while_break;
    }
#line 261
    next_block_num = block_num + 1;
#line 266
    idx = 0;
    {
#line 266
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 266
      if (! (idx < (int )bd->block_len)) {
#line 266
        goto while_break___0;
      }
#line 267
      *((dr->in)->data + ((int )bd->block_pos + idx)) = (char )(next_block_num & 1);
#line 268
      next_block_num >>= 1;
#line 266
      idx ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 270
    chain_shift_data_registers(chain, 1);
#line 279
    addr_len = 0;
    }
    {
#line 279
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 279
      if (! (addr_len < (int )bd->addr_len)) {
#line 279
        goto while_break___1;
      }
#line 280
      if ((int )*((dr->out)->data + ((int )bd->addr_pos + addr_len)) == 0) {
#line 281
        goto while_break___1;
      }
#line 279
      addr_len ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 284
    data_len = 0;
    {
#line 284
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 284
      if (! (data_len < (int )bd->data_len)) {
#line 284
        goto while_break___2;
      }
#line 285
      if ((int )*((dr->out)->data + ((int )bd->data_pos + data_len)) == 0) {
#line 286
        goto while_break___2;
      }
#line 284
      data_len ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 290
    if (addr_len > 0) {
#line 290
      if (data_len > 0) {
        {
#line 294
        tmp___0 = calloc((size_t )1, sizeof(block_param_t ));
#line 294
        bl = (block_param_t *)tmp___0;
        }
#line 294
        if ((unsigned long )bl == (unsigned long )((void *)0)) {
          {
#line 295
          tmp = gettext("out of memory\n");
#line 295
          printf((char const   */* __restrict  */)tmp);
#line 296
          failed |= 1;
          }
#line 297
          goto while_break;
        }
#line 300
        bl->next = bd->blocks;
#line 301
        bl->num = (uint16_t )block_num;
#line 302
        bl->addr_width = (uint16_t )addr_len;
#line 303
        bl->data_width = (uint16_t )data_len;
#line 304
        bd->blocks = bl;
#line 307
        nbytes = data_len / 8;
#line 308
        if (data_len % 8) {
#line 309
          nbytes ++;
        }
#line 311
        bl->ashift = (uint8_t )0;
        {
#line 312
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 312
          if (! (nbytes != 1)) {
#line 312
            goto while_break___3;
          }
#line 313
          bl->ashift = (uint8_t )((int )bl->ashift + 1);
#line 314
          nbytes >>= 1;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 318
        if ((unsigned long )bl->next == (unsigned long )((void *)0)) {
#line 319
          bl->start = (uint32_t )0;
        } else
#line 321
        if ((int )bl->addr_width << (int )bl->ashift <= (int )(bl->next)->addr_width << (int )(bl->next)->ashift) {
#line 322
          bl->start = (bl->next)->start + (uint32_t )(1 << ((int )(bl->next)->addr_width + (int )(bl->next)->ashift));
        } else {
#line 324
          mask = (uint32_t )(1 << ((int )bl->addr_width + (int )bl->ashift));
#line 325
          bl->start = (bl->next)->start & ~ (mask - 1U);
#line 326
          bl->start += mask;
        }
#line 330
        bl->end = (bl->start + (uint32_t )(1 << ((int )bl->addr_width + (int )bl->ashift))) - 1U;
      }
    }
#line 260
    block_num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  if (failed) {
#line 342
    tmp___1 = 0;
  } else {
#line 342
    tmp___1 = 1;
  }
#line 342
  return (tmp___1);
}
}
#line 349 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static bus_t *fjmem_bus_new(chain_t *chain , bus_driver_t const   *driver , char **params ) 
{ 
  bus_t *bus___0 ;
  int failed ;
  part_t *part ;
  char *opcode ;
  int fjmem_reg_len ;
  int idx ;
  char *comma ;
  char *value ;
  char *tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  block_desc_t *bd ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 352
  bus___0 = (bus_t *)((void *)0);
#line 353
  failed = 0;
#line 355
  opcode = (char *)((void *)0);
#line 356
  fjmem_reg_len = 0;
#line 359
  part = *((chain->parts)->parts + chain->active_part);
#line 362
  idx = 2;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 362
    tmp___3 = cmd_params(params);
    }
#line 362
    if (! (idx < tmp___3)) {
#line 362
      goto while_break;
    }
    {
#line 365
    comma = strchr((char const   *)*(params + idx), '=');
    }
#line 366
    if ((unsigned long )comma == (unsigned long )((void *)0)) {
      {
#line 367
      tmp = gettext("Wrong parameter specification: %s\n");
#line 367
      printf((char const   */* __restrict  */)tmp, *(params + idx));
      }
#line 368
      goto __Cont;
    }
    {
#line 372
    value = comma + 1;
#line 373
    *comma = (char )'\000';
#line 375
    tmp___0 = strcasecmp((char const   *)*(params + idx), "opcode");
    }
#line 375
    if (tmp___0 == 0) {
#line 376
      opcode = value;
    }
    {
#line 377
    tmp___2 = strcasecmp((char const   *)*(params + idx), "len");
    }
#line 377
    if (tmp___2 == 0) {
      {
#line 379
      cmd_get_number(value, & tmp___1);
#line 380
      fjmem_reg_len = (int )tmp___1;
      }
    }
    __Cont: /* CIL Label */ 
#line 362
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  if (opcode) {
    {
#line 387
    fjmem_reg_len = fjmem_detect_reg_len(chain, part, opcode, fjmem_reg_len);
    }
#line 388
    if (fjmem_reg_len <= 0) {
#line 389
      return ((bus_t *)((void *)0));
    }
    {
#line 391
    tmp___4 = calloc((size_t )1, sizeof(bus_t ));
#line 391
    bus___0 = (bus_t *)tmp___4;
    }
#line 392
    if (! bus___0) {
#line 393
      return ((bus_t *)((void *)0));
    }
    {
#line 395
    bus___0->driver = driver;
#line 396
    bus___0->params = calloc((size_t )1, sizeof(bus_params_t___18 ));
    }
#line 397
    if (! bus___0->params) {
      {
#line 398
      free((void *)bus___0);
      }
#line 399
      return ((bus_t *)((void *)0));
    }
    {
#line 402
    bus___0->chain = chain;
#line 403
    bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 404
    ((bus_params_t___18 *)bus___0->params)->fjmem_reg = part_find_data_register(bus___0->part,
                                                                                "FJMEM_REG");
#line 405
    bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 406
    bd->blocks = (block_param_t *)((void *)0);
#line 407
    bd->reg_len = (uint16_t )fjmem_reg_len;
#line 408
    bd->instr_pos = (uint16_t )0;
#line 409
    bd->block_pos = (uint16_t )((int )bd->instr_pos + 4);
#line 411
    tmp___6 = fjmem_detect_fields(chain, part, bus___0);
    }
#line 411
    if (tmp___6 > 0) {
      {
#line 412
      tmp___5 = fjmem_query_blocks(chain, part, bus___0);
      }
#line 412
      if (! (tmp___5 > 0)) {
#line 414
        failed |= 1;
      }
    } else {
#line 416
      failed |= 1;
    }
#line 418
    if (failed) {
      {
#line 419
      free(bus___0->params);
#line 420
      free((void *)bus___0);
      }
#line 421
      return ((bus_t *)((void *)0));
    }
  } else {
    {
#line 424
    tmp___7 = gettext("Parameter for instruction opcode missing.\n");
#line 424
    printf((char const   */* __restrict  */)tmp___7);
    }
  }
#line 426
  return (bus___0);
}
}
#line 429 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void fjmem_free_blocks(block_param_t *bl ) 
{ 


  {
#line 432
  if (bl) {
    {
#line 433
    fjmem_free_blocks(bl->next);
#line 434
    free((void *)bl);
    }
  }
#line 436
  return;
}
}
#line 442 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void fjmem_bus_free(bus_t *bus___0 ) 
{ 
  data_register *dr ;

  {
  {
#line 445
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 449
  part_set_instruction(bus___0->part, "FJMEM_INST");
#line 450
  chain_shift_instructions(bus___0->chain);
#line 452
  register_fill(dr->in, 0);
#line 453
  chain_shift_data_registers(bus___0->chain, 0);
#line 455
  fjmem_free_blocks(((bus_params_t___18 *)bus___0->params)->block_desc.blocks);
#line 456
  ((bus_params_t___18 *)bus___0->params)->block_desc.blocks = (block_param_t *)((void *)0);
#line 458
  generic_bus_free(bus___0);
  }
#line 459
  return;
}
}
#line 465 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void fjmem_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 470
  i = 0;
  {
#line 470
  while (1) {
    while_continue: /* CIL Label */ ;
#line 470
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 470
      goto while_break;
    }
#line 471
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 472
      goto while_break;
    }
#line 470
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 473
  tmp = gettext("fjmem FPGA bus driver via USER register (JTAG part No. %d)\n");
#line 473
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 474
  return;
}
}
#line 480 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void fjmem_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 483
  if (! bus___0->initialized) {
    {
#line 484
    (*((bus___0->driver)->init))(bus___0);
    }
  }
  {
#line 487
  part_set_instruction(bus___0->part, "FJMEM_INST");
#line 488
  chain_shift_instructions(bus___0->chain);
  }
#line 489
  return;
}
}
#line 491 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static int block_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area , block_param_t **bl_match ) 
{ 
  block_param_t *bl ;
  uint32_t prev_start ;

  {
#line 494
  bl = ((bus_params_t___18 *)bus___0->params)->block_desc.blocks;
#line 497
  *bl_match = (block_param_t *)((void *)0);
#line 501
  prev_start = (uint32_t )0;
  {
#line 502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 502
    if (! bl) {
#line 502
      goto while_break;
    }
#line 503
    if (bl->start <= adr) {
#line 503
      if (bl->end >= adr) {
#line 505
        area->description = (char const   *)((void *)0);
#line 506
        area->start = bl->start;
#line 507
        area->length = (uint64_t )((bl->end - bl->start) + 1U);
#line 508
        area->width = (unsigned int )bl->data_width;
#line 509
        *bl_match = bl;
#line 510
        prev_start = area->start;
      } else {
#line 503
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 511
    if (prev_start > adr) {
#line 511
      goto _L;
    } else
#line 511
    if (prev_start == 0U) {
      _L: /* CIL Label */ 
#line 511
      if (bl->end < adr) {
#line 513
        area->description = "Dummy";
#line 514
        area->start = bl->end + 1U;
#line 515
        if (prev_start > 0U) {
#line 515
          area->length = (uint64_t )(prev_start - (bl->end + 1U));
        } else {
#line 515
          area->length = 4294967296UL;
        }
#line 516
        area->width = 0U;
#line 517
        *bl_match = (block_param_t *)((void *)0);
#line 518
        prev_start = area->start;
      } else {
#line 520
        prev_start = bl->start;
      }
    } else {
#line 520
      prev_start = bl->start;
    }
#line 522
    bl = bl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 525
  return (0);
}
}
#line 532 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static int fjmem_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 
  block_param_t *bl ;
  int tmp ;

  {
  {
#line 537
  tmp = block_bus_area(bus___0, adr, area, & bl);
  }
#line 537
  return (tmp);
}
}
#line 540 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void setup_address___18(bus_t *bus___0 , uint32_t a , block_param_t *block ) 
{ 
  data_register *dr ;
  block_desc_t *bd ;
  int idx ;
  uint16_t num ;

  {
#line 543
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 544
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 546
  num = block->num;
#line 548
  ((bus_params_t___18 *)bus___0->params)->last_addr = a;
#line 551
  a >>= (int )block->ashift;
#line 554
  idx = 0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! (idx < (int )bd->block_len)) {
#line 554
      goto while_break;
    }
#line 555
    *((dr->in)->data + ((int )bd->block_pos + idx)) = (char )((int )num & 1);
#line 556
    num = (uint16_t )((int )num >> 1);
#line 554
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  idx = 0;
  {
#line 560
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 560
    if (! (idx < (int )block->addr_width)) {
#line 560
      goto while_break___0;
    }
#line 561
    *((dr->in)->data + ((int )bd->addr_pos + idx)) = (char )(a & 1U);
#line 562
    a >>= 1;
#line 560
    idx ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 564
  return;
}
}
#line 566 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void setup_data___18(bus_t *bus___0 , uint32_t d , block_param_t *block ) 
{ 
  data_register *dr ;
  block_desc_t *bd ;
  int idx ;

  {
#line 569
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 570
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 574
  idx = 0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (idx < (int )block->data_width)) {
#line 574
      goto while_break;
    }
#line 575
    *((dr->in)->data + ((int )bd->data_pos + idx)) = (char )(d & 1U);
#line 576
    d >>= 1;
#line 574
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  return;
}
}
#line 584 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void fjmem_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  bus_area_t area ;
  block_param_t *block ;
  char *tmp ;

  {
  {
#line 587
  chain = bus___0->chain;
#line 588
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 589
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 593
  block_bus_area(bus___0, adr, & area, & block);
  }
#line 594
  if (! block) {
    {
#line 595
    tmp = gettext("Address out of range\n");
#line 595
    printf((char const   */* __restrict  */)tmp);
#line 596
    ((bus_params_t___18 *)bus___0->params)->last_addr = adr;
    }
#line 597
    return;
  }
  {
#line 600
  setup_address___18(bus___0, adr, block);
#line 603
  *((dr->in)->data + (int )bd->instr_pos) = (char)1;
#line 604
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)0;
#line 605
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)0;
#line 607
  chain_shift_data_registers(chain, 0);
  }
#line 608
  return;
}
}
#line 614 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static uint32_t fjmem_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  uint32_t d ;
  bus_area_t area ;
  block_param_t *block ;
  int idx ;
  char *tmp ;

  {
  {
#line 617
  chain = bus___0->chain;
#line 618
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 619
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 625
  block_bus_area(bus___0, adr, & area, & block);
  }
#line 626
  if (! block) {
    {
#line 627
    tmp = gettext("Address out of range\n");
#line 627
    printf((char const   */* __restrict  */)tmp);
#line 628
    ((bus_params_t___18 *)bus___0->params)->last_addr = adr;
    }
#line 629
    return ((uint32_t )0);
  }
  {
#line 632
  setup_address___18(bus___0, adr, block);
#line 633
  chain_shift_data_registers(chain, 1);
#line 636
  d = (uint32_t )0;
#line 637
  idx = 0;
  }
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 637
    if (! (idx < (int )block->data_width)) {
#line 637
      goto while_break;
    }
#line 638
    if (*((dr->out)->data + ((int )bd->data_pos + idx))) {
#line 639
      d |= (unsigned int )(1 << idx);
    }
#line 637
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  return (d);
}
}
#line 648 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static uint32_t fjmem_bus_read_end(bus_t *bus___0 ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  uint32_t d ;
  bus_area_t area ;
  block_param_t *block ;
  int idx ;
  char *tmp ;

  {
  {
#line 651
  chain = bus___0->chain;
#line 652
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 653
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 659
  block_bus_area(bus___0, ((bus_params_t___18 *)bus___0->params)->last_addr, & area,
                 & block);
  }
#line 660
  if (! block) {
    {
#line 661
    tmp = gettext("Address out of range\n");
#line 661
    printf((char const   */* __restrict  */)tmp);
    }
#line 662
    return ((uint32_t )0);
  }
  {
#line 666
  *((dr->in)->data + (int )bd->instr_pos) = (char)0;
#line 667
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)0;
#line 668
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)0;
#line 670
  chain_shift_data_registers(chain, 1);
#line 673
  d = (uint32_t )0;
#line 674
  idx = 0;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (idx < (int )block->data_width)) {
#line 674
      goto while_break;
    }
#line 675
    if (*((dr->out)->data + ((int )bd->data_pos + idx))) {
#line 676
      d |= (unsigned int )(1 << idx);
    }
#line 674
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 678
  return (d);
}
}
#line 685 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
static void fjmem_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  chain_t *chain ;
  block_desc_t *bd ;
  data_register *dr ;
  bus_area_t area ;
  block_param_t *block ;
  char *tmp ;

  {
  {
#line 688
  chain = bus___0->chain;
#line 689
  bd = & ((bus_params_t___18 *)bus___0->params)->block_desc;
#line 690
  dr = ((bus_params_t___18 *)bus___0->params)->fjmem_reg;
#line 694
  block_bus_area(bus___0, adr, & area, & block);
  }
#line 695
  if (! block) {
    {
#line 696
    tmp = gettext("Address out of range\n");
#line 696
    printf((char const   */* __restrict  */)tmp);
    }
#line 697
    return;
  }
  {
#line 700
  setup_address___18(bus___0, adr, block);
#line 701
  setup_data___18(bus___0, data, block);
#line 704
  *((dr->in)->data + (int )bd->instr_pos) = (char)0;
#line 705
  *((dr->in)->data + ((int )bd->instr_pos + 1)) = (char)1;
#line 706
  *((dr->in)->data + ((int )bd->instr_pos + 2)) = (char)0;
#line 708
  chain_shift_data_registers(chain, 0);
  }
#line 709
  return;
}
}
#line 711 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/fjmem.c"
struct bus_driver  const  fjmem_bus  = 
#line 711
     {"fjmem", "FPGA JTAG memory bus driver via USER register, requires parameters:\n           opcode=<USERx OPCODE> [len=<FJMEM REG LEN>]",
    & fjmem_bus_new, & fjmem_bus_free, & fjmem_bus_printinfo, & fjmem_bus_prepare,
    & fjmem_bus_area, & fjmem_bus_read_start, & fjmem_bus_read_next, & fjmem_bus_read_end,
    & generic_bus_read, & fjmem_bus_write, & generic_bus_no_init};
#line 76 "../../include/bus_driver.h"
bus_t *bus ;
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  ejtag_bus ;
#line 74 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static bus_t *ejtag_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  void *tmp ;

  {
  {
#line 79
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 79
  bus___0 = (bus_t *)tmp;
  }
#line 80
  if (! bus___0) {
#line 81
    return ((bus_t *)((void *)0));
  }
  {
#line 83
  bus___0->driver = driver;
#line 84
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___19 ));
  }
#line 85
  if (! bus___0->params) {
    {
#line 86
    free((void *)bus___0);
    }
#line 87
    return ((bus_t *)((void *)0));
  }
#line 90
  bus___0->chain = chain;
#line 91
  bus___0->part = *((chain->parts)->parts + chain->active_part);
#line 93
  return (bus___0);
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static void ejtag_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 105
  i = 0;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 105
      goto while_break;
    }
#line 106
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 107
      goto while_break;
    }
#line 105
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 108
  tmp = gettext("EJTAG compatible bus driver via PrAcc (JTAG part No. %d)\n");
#line 108
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static uint32_t reg_value(tap_register *reg ) 
{ 
  uint32_t retval ;
  int i ;

  {
#line 114
  retval = (uint32_t )0;
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < reg->len)) {
#line 117
      goto while_break;
    }
#line 118
    if (*(reg->data + i)) {
#line 119
      retval |= (unsigned int )(1 << i);
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (retval);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static uint32_t ejtag_run_pracc(bus_t *bus___0 , uint32_t const   *code___0 , unsigned int len ) 
{ 
  data_register *ejaddr ;
  data_register *ejdata ;
  data_register *ejctrl ;
  int i ;
  int pass ;
  uint32_t addr ;
  uint32_t data ;
  uint32_t retval ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 131
  ejaddr = part_find_data_register(bus___0->part, "EJADDRESS");
#line 132
  ejdata = part_find_data_register(bus___0->part, "EJDATA");
#line 133
  ejctrl = part_find_data_register(bus___0->part, "EJCONTROL");
  }
#line 134
  if (ejaddr) {
#line 134
    if (ejdata) {
#line 134
      if (! ejctrl) {
        {
#line 135
        tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 135
        printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
               136);
        }
#line 137
        return ((uint32_t )0);
      }
    } else {
      {
#line 135
      tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 135
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
             136);
      }
#line 137
      return ((uint32_t )0);
    }
  } else {
    {
#line 135
    tmp = gettext("%s(%d) EJADDRESS, EJDATA or EJCONTROL register not found\n");
#line 135
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
           136);
    }
#line 137
    return ((uint32_t )0);
  }
  {
#line 140
  part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 141
  chain_shift_instructions(bus___0->chain);
#line 143
  pass = 0;
#line 144
  retval = (uint32_t )0;
  }
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 147
    *((ejctrl->in)->data + 18) = (char)1;
#line 148
    chain_shift_data_registers(bus___0->chain, 0);
#line 149
    chain_shift_data_registers(bus___0->chain, 1);
    }
#line 153
    if (*((ejctrl->out)->data + 31)) {
      {
#line 154
      tmp___0 = register_get_string((tap_register const   *)ejctrl->out);
#line 154
      tmp___1 = gettext("%s(%d) Reset occurred, ctrl=%s\n");
#line 154
      printf((char const   */* __restrict  */)tmp___1, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
             155, tmp___0);
#line 157
      bus___0->initialized = 0;
      }
#line 158
      goto while_break;
    }
#line 160
    if (! *((ejctrl->out)->data + 18)) {
      {
#line 161
      tmp___2 = register_get_string((tap_register const   *)ejctrl->out);
#line 161
      tmp___3 = gettext("%s(%d) No processor access, ctrl=%s\n");
#line 161
      printf((char const   */* __restrict  */)tmp___3, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
             162, tmp___2);
#line 164
      bus___0->initialized = 0;
      }
#line 165
      goto while_break;
    }
    {
#line 168
    part_set_instruction(bus___0->part, "EJTAG_ADDRESS");
#line 169
    chain_shift_instructions(bus___0->chain);
#line 171
    chain_shift_data_registers(bus___0->chain, 1);
#line 172
    addr = reg_value(ejaddr->out);
    }
#line 173
    if (addr & 3U) {
      {
#line 174
      tmp___4 = gettext("%s(%d) PrAcc bad alignment: addr=0x%08x\n");
#line 174
      printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
             175, addr);
#line 176
      addr &= 4294967292U;
      }
    }
    {
#line 179
    part_set_instruction(bus___0->part, "EJTAG_DATA");
#line 180
    chain_shift_instructions(bus___0->chain);
#line 182
    register_fill(ejdata->in, 0);
    }
#line 184
    if (*((ejctrl->out)->data + 19)) {
      {
#line 185
      chain_shift_data_registers(bus___0->chain, 1);
#line 186
      data = reg_value(ejdata->out);
      }
#line 191
      if (addr == 4280287232U) {
#line 193
        retval = data;
      } else {
        {
#line 195
        tmp___5 = gettext("%s(%d) Unknown write addr=0x%08x data=0x%08x\n");
#line 195
        printf((char const   */* __restrict  */)tmp___5, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
               196, addr, data);
        }
      }
    } else {
#line 199
      if (addr == 4280287744U) {
#line 199
        tmp___6 = pass;
#line 199
        pass ++;
#line 199
        if (tmp___6) {
#line 200
          goto while_break;
        }
      }
#line 202
      data = (uint32_t )0;
#line 203
      if (addr >= 4280287744U) {
#line 203
        if (addr < 4280287744U + (len << 2)) {
#line 204
          data = (uint32_t )*(code___0 + ((addr - 4280287744U) >> 2));
#line 206
          i = 0;
          {
#line 206
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 206
            if (! (i < 32)) {
#line 206
              goto while_break___0;
            }
#line 207
            *((ejdata->in)->data + i) = (char )((data >> i) & 1U);
#line 206
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
      {
#line 213
      chain_shift_data_registers(bus___0->chain, 0);
      }
    }
    {
#line 216
    part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 217
    chain_shift_instructions(bus___0->chain);
#line 219
    *((ejctrl->in)->data + 18) = (char)0;
#line 220
    chain_shift_data_registers(bus___0->chain, 0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (retval);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static void ejtag_bus_init(bus_t *bus___0 ) 
{ 
  data_register *ejctrl ;
  data_register *ejimpl ;
  uint32_t code___0[4] ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 229
  code___0[0] = (uint32_t )1006960416;
#line 229
  code___0[1] = (uint32_t )882835968;
#line 229
  code___0[2] = (uint32_t )65011720;
#line 229
  code___0[3] = (uint32_t )1006829568;
#line 236
  ejctrl = part_find_data_register(bus___0->part, "EJCONTROL");
#line 237
  ejimpl = part_find_data_register(bus___0->part, "EJIMPCODE");
  }
#line 238
  if (ejctrl) {
#line 238
    if (! ejimpl) {
      {
#line 239
      tmp = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 239
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
             240);
      }
#line 241
      return;
    }
  } else {
    {
#line 239
    tmp = gettext("%s(%d) EJCONTROL or EJIMPCODE register not found\n");
#line 239
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
           240);
    }
#line 241
    return;
  }
  {
#line 244
  part_set_instruction(bus___0->part, "EJTAG_IMPCODE");
#line 245
  chain_shift_instructions(bus___0->chain);
#line 246
  chain_shift_data_registers(bus___0->chain, 0);
#line 247
  chain_shift_data_registers(bus___0->chain, 1);
#line 248
  tmp___0 = register_get_string((tap_register const   *)ejimpl->out);
#line 248
  printf((char const   */* __restrict  */)"ImpCode=%s\n", tmp___0);
#line 249
  ((bus_params_t___19 *)bus___0->params)->impcode = reg_value(ejimpl->out);
  }
  {
#line 252
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) == 0U) {
#line 252
    goto case_0;
  }
#line 253
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) == 1U) {
#line 253
    goto case_1;
  }
#line 254
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) == 2U) {
#line 254
    goto case_2;
  }
#line 255
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 252
  printf((char const   */* __restrict  */)"EJTAG version: <= 2.0\n");
  }
#line 252
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 253
  printf((char const   */* __restrict  */)"EJTAG version: 2.5\n");
  }
#line 253
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 254
  printf((char const   */* __restrict  */)"EJTAG version: 2.6\n");
  }
#line 254
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 256
  printf((char const   */* __restrict  */)"EJTAG version: unknown (%d)\n", (((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U);
  }
  switch_break: /* CIL Label */ ;
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & 1U) {
#line 258
    tmp___1 = " MIPS64";
  } else {
#line 258
    tmp___1 = " MIPS32";
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 14)) {
#line 258
    tmp___2 = " NoDMA";
  } else {
#line 258
    tmp___2 = "";
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 16)) {
#line 258
    tmp___3 = " MIPS16";
  } else {
#line 258
    tmp___3 = "";
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 21)) {
#line 258
    tmp___4 = " ASID_6";
  } else {
#line 258
    tmp___4 = "";
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 22)) {
#line 258
    tmp___5 = " ASID_8";
  } else {
#line 258
    tmp___5 = "";
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 24)) {
#line 258
    tmp___6 = " DINTsup";
  } else {
#line 258
    tmp___6 = "";
  }
#line 258
  if (((bus_params_t___19 *)bus___0->params)->impcode & (unsigned int )(1 << 28)) {
#line 258
    tmp___7 = " R3k";
  } else {
#line 258
    tmp___7 = " R4k";
  }
  {
#line 258
  printf((char const   */* __restrict  */)"EJTAG Implementation flags:%s%s%s%s%s%s%s\n",
         tmp___7, tmp___6, tmp___5, tmp___4, tmp___3, tmp___2, tmp___1);
  }
#line 267
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
    {
#line 268
    part_set_instruction(bus___0->part, "EJTAGBOOT");
#line 269
    chain_shift_instructions(bus___0->chain);
    }
  }
  {
#line 272
  part_set_instruction(bus___0->part, "EJTAG_CONTROL");
#line 273
  chain_shift_instructions(bus___0->chain);
#line 275
  register_fill(ejctrl->in, 0);
#line 277
  *((ejctrl->in)->data + 16) = (char)1;
#line 278
  *((ejctrl->in)->data + 20) = (char)1;
#line 279
  chain_shift_data_registers(bus___0->chain, 0);
#line 281
  *((ejctrl->in)->data + 16) = (char)0;
#line 282
  *((ejctrl->in)->data + 20) = (char)0;
#line 283
  chain_shift_data_registers(bus___0->chain, 0);
#line 285
  *((ejctrl->in)->data + 18) = (char)1;
#line 286
  *((ejctrl->in)->data + 15) = (char)1;
  }
#line 287
  if (((((bus_params_t___19 *)bus___0->params)->impcode >> 29) & 7U) >= 1U) {
#line 288
    *((ejctrl->in)->data + 14) = (char)1;
#line 289
    *((ejctrl->in)->data + 31) = (char)1;
  }
  {
#line 291
  chain_shift_data_registers(bus___0->chain, 0);
#line 293
  *((ejctrl->in)->data + 12) = (char)1;
#line 294
  chain_shift_data_registers(bus___0->chain, 0);
#line 296
  *((ejctrl->in)->data + 12) = (char)0;
#line 297
  chain_shift_data_registers(bus___0->chain, 1);
  }
#line 299
  if (! *((ejctrl->out)->data + 3)) {
    {
#line 300
    tmp___8 = register_get_string((tap_register const   *)ejctrl->out);
#line 300
    tmp___9 = gettext("%s(%d) Failed to enter debug mode, ctrl=%s\n");
#line 300
    printf((char const   */* __restrict  */)tmp___9, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c",
           301, tmp___8);
    }
#line 303
    return;
  }
#line 306
  if (*((ejctrl->out)->data + 31)) {
    {
#line 307
    *((ejctrl->in)->data + 31) = (char)0;
#line 308
    chain_shift_data_registers(bus___0->chain, 0);
#line 309
    *((ejctrl->in)->data + 31) = (char)1;
#line 310
    chain_shift_data_registers(bus___0->chain, 1);
    }
  }
  {
#line 313
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), 4U);
#line 314
  ((bus_params_t___19 *)bus___0->params)->adr_hi = (uint16_t )0;
#line 315
  bus___0->initialized = 1;
  }
#line 316
  return;
}
}
#line 322 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static void ejtag_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 325
  if (! bus___0->initialized) {
    {
#line 326
    (*((bus___0->driver)->init))(bus___0);
    }
  }
#line 327
  return;
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static int ejtag_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 336
  if (adr < 536870912U) {
#line 337
    area->description = (char const   *)((void *)0);
#line 338
    area->start = 0U;
#line 339
    area->length = 536870912UL;
#line 340
    area->width = 8U;
  } else
#line 341
  if (adr < 1073741824U) {
#line 342
    area->description = (char const   *)((void *)0);
#line 343
    area->start = 536870912U;
#line 344
    area->length = 536870912UL;
#line 345
    area->width = 16U;
  } else
#line 346
  if (adr < 1610612736U) {
#line 347
    area->description = (char const   *)((void *)0);
#line 348
    area->start = 1073741824U;
#line 349
    area->length = 536870912UL;
#line 350
    area->width = 32U;
  } else {
#line 352
    area->description = (char const   *)((void *)0);
#line 353
    area->start = 1610612736U;
#line 354
    area->length = 2684354560UL;
#line 355
    area->width = 0U;
  }
#line 357
  return (0);
}
}
#line 360 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static int ejtag_gen_read(uint32_t *code___0 , uint32_t adr ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;

  {
#line 364
  p = code___0;
#line 367
  adr_lo = (uint16_t )(adr & 65535U);
#line 368
  adr_hi = (uint16_t )((adr >> 16) & 8191U);
#line 370
  adr_hi = (uint16_t )((int )adr_hi + ((int )adr_lo >> 15));
#line 372
  adr_hi = (uint16_t )((int )adr_hi + 40960);
#line 374
  if ((int )((bus_params_t___19 *)bus->params)->adr_hi != (int )adr_hi) {
#line 375
    ((bus_params_t___19 *)bus->params)->adr_hi = adr_hi;
#line 376
    tmp = p;
#line 376
    p ++;
#line 376
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 379
  if (adr >> 29 == 0U) {
#line 379
    goto case_0;
  }
#line 382
  if (adr >> 29 == 1U) {
#line 382
    goto case_1;
  }
#line 385
  if (adr >> 29 == 2U) {
#line 385
    goto case_2;
  }
#line 388
  goto switch_default;
  case_0: /* CIL Label */ 
#line 380
  tmp___0 = p;
#line 380
  p ++;
#line 380
  *tmp___0 = 2422341632U | (unsigned int )adr_lo;
#line 381
  goto switch_break;
  case_1: /* CIL Label */ 
#line 383
  tmp___1 = p;
#line 383
  p ++;
#line 383
  *tmp___1 = 2489450496U | (unsigned int )((int )adr_lo & -2);
#line 384
  goto switch_break;
  case_2: /* CIL Label */ 
#line 386
  tmp___2 = p;
#line 386
  p ++;
#line 386
  *tmp___2 = 2355232768U | (unsigned int )((int )adr_lo & -4);
#line 387
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 389
  tmp___3 = p;
#line 389
  p ++;
#line 389
  *tmp___3 = (uint32_t )4133;
#line 390
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 392
  tmp___4 = p;
#line 392
  p ++;
#line 392
  *tmp___4 = (uint32_t )65011720;
#line 393
  return ((int )(p - code___0));
}
}
#line 400 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static void ejtag_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t code___0[3] ;
  int tmp ;

  {
  {
#line 405
  tmp = ejtag_gen_read(code___0, adr);
#line 405
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )tmp);
  }
#line 407
  return;
}
}
#line 413 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  uint32_t d ;
  uint32_t code___0[4] ;
  uint32_t *p ;
  uint32_t *tmp ;
  int tmp___0 ;

  {
  {
#line 417
  p = code___0;
#line 419
  tmp = p;
#line 419
  p ++;
#line 419
  *tmp = 2894200832U;
#line 420
  tmp___0 = ejtag_gen_read(p, adr);
#line 420
  p += tmp___0;
#line 422
  d = ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 425
  return (d);
}
}
#line 436
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) ;
#line 436 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static uint32_t const   code[2]  = {      (uint32_t const   )2894200832U,      (uint32_t const   )65011720};
#line 432 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static uint32_t ejtag_bus_read_end(bus_t *bus___0 ) 
{ 
  uint32_t d ;

  {
  {
#line 441
  d = ejtag_run_pracc(bus___0, code, 2U);
  }
#line 444
  return (d);
}
}
#line 451 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
static void ejtag_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t adr_hi ;
  uint16_t adr_lo ;
  uint32_t code___0[5] ;
  uint32_t *p ;
  uint32_t *tmp ;
  uint32_t *tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t *tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t *tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t *tmp___6 ;
  uint32_t *tmp___7 ;

  {
#line 455
  p = code___0;
#line 458
  adr_lo = (uint16_t )(adr & 65535U);
#line 459
  adr_hi = (uint16_t )((((adr >> 16) & 8191U) + (unsigned int )((int )adr_lo >> 15)) + 40960U);
#line 461
  if ((int )((bus_params_t___19 *)bus___0->params)->adr_hi != (int )adr_hi) {
#line 462
    ((bus_params_t___19 *)bus___0->params)->adr_hi = adr_hi;
#line 463
    tmp = p;
#line 463
    p ++;
#line 463
    *tmp = (uint32_t )(1006829568 | (int )adr_hi);
  }
  {
#line 466
  if (adr >> 29 == 0U) {
#line 466
    goto case_0;
  }
#line 470
  if (adr >> 29 == 1U) {
#line 470
    goto case_1;
  }
#line 474
  if (adr >> 29 == 2U) {
#line 474
    goto case_2;
  }
#line 465
  goto switch_break;
  case_0: /* CIL Label */ 
#line 467
  tmp___0 = p;
#line 467
  p ++;
#line 467
  *tmp___0 = 872546304U | (data & 255U);
#line 468
  tmp___1 = p;
#line 468
  p ++;
#line 468
  *tmp___1 = 2690777088U | (unsigned int )adr_lo;
#line 469
  goto switch_break;
  case_1: /* CIL Label */ 
#line 471
  tmp___2 = p;
#line 471
  p ++;
#line 471
  *tmp___2 = 872546304U | (data & 65535U);
#line 472
  tmp___3 = p;
#line 472
  p ++;
#line 472
  *tmp___3 = 2757885952U | (unsigned int )((int )adr_lo & -2);
#line 473
  goto switch_break;
  case_2: /* CIL Label */ 
#line 475
  tmp___4 = p;
#line 475
  p ++;
#line 475
  *tmp___4 = 1006764032U | (data >> 16);
#line 476
  tmp___5 = p;
#line 476
  p ++;
#line 476
  *tmp___5 = 876740608U | (data & 65535U);
#line 477
  tmp___6 = p;
#line 477
  p ++;
#line 477
  *tmp___6 = 2892103680U | (unsigned int )((int )adr_lo & -4);
#line 478
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 480
  tmp___7 = p;
#line 480
  p ++;
#line 480
  *tmp___7 = (uint32_t )65011720;
#line 482
  ejtag_run_pracc(bus___0, (uint32_t const   *)(code___0), (unsigned int )(p - code___0));
  }
#line 485
  return;
}
}
#line 487 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/ejtag.c"
struct bus_driver  const  ejtag_bus  = 
#line 487
     {"ejtag", "EJTAG compatible bus driver via PrAcc", & ejtag_bus_new, & generic_bus_free,
    & ejtag_bus_printinfo, & ejtag_bus_prepare, & ejtag_bus_area, & ejtag_bus_read_start,
    & ejtag_bus_read_next, & ejtag_bus_read_end, & generic_bus_read, & ejtag_bus_write,
    (int (*)(bus_t *bus ))(& ejtag_bus_init)};
#line 38 "../../include/bus.h"
buses_t buses ;
#line 39
bus_driver_t const   *bus_drivers[35] ;
#line 41
void buses_free(void) ;
#line 42
void buses_add(bus_t *abus ) ;
#line 43
void buses_delete(bus_t *abus ) ;
#line 28 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.h"
struct bus_driver  const  au1500_bus ;
#line 29
struct bus_driver  const  avr32_bus_driver ;
#line 30
struct bus_driver  const  bcm1250_bus ;
#line 31
struct bus_driver  const  bf526_ezkit_bus ;
#line 32
struct bus_driver  const  bf527_ezkit_bus ;
#line 33
struct bus_driver  const  bf533_stamp_bus ;
#line 34
struct bus_driver  const  bf533_ezkit_bus ;
#line 35
struct bus_driver  const  bf537_stamp_bus ;
#line 36
struct bus_driver  const  bf537_ezkit_bus ;
#line 37
struct bus_driver  const  bf538f_ezkit_bus ;
#line 38
struct bus_driver  const  bf548_ezkit_bus ;
#line 39
struct bus_driver  const  bf561_ezkit_bus ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
bus_driver_t const   *bus_drivers[35]  = 
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
  {      & au1500_bus,      & avr32_bus_driver,      & bcm1250_bus,      & bf526_ezkit_bus, 
        & bf527_ezkit_bus,      & bf533_stamp_bus,      & bf533_ezkit_bus,      & bf537_stamp_bus, 
        & bf537_ezkit_bus,      & bf538f_ezkit_bus,      & bf548_ezkit_bus,      & bf561_ezkit_bus, 
        & ejtag_bus,      & fjmem_bus,      & ixp425_bus,      & jopcyc_bus, 
        & h7202_bus,      & lh7a400_bus,      & mpc5200_bus,      & mpc824x_bus, 
        & ppc405ep_bus,      & ppc440gx_ebc8_bus,      & prototype_bus,      & pxa2x0_bus, 
        & pxa27x_bus,      & s3c4510_bus,      & sa1110_bus,      & sh7727_bus, 
        & sh7750r_bus,      & sh7751r_bus,      & sharc_21065L_bus,      & slsup3_bus, 
        & tx4925_bus,      & zefant_xs3_bus,      (bus_driver_t const   *)((void *)0)};
#line 138 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
bus_t *bus  =    (bus_t *)((void *)0);
#line 139 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
buses_t buses  =    {0, (bus_t **)((void *)0)};
#line 141 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
void buses_free(void) 
{ 
  int i ;

  {
#line 145
  i = 0;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (i < buses.len)) {
#line 145
      goto while_break;
    }
    {
#line 146
    (*(((*(buses.buses + i))->driver)->free_bus))(*(buses.buses + i));
#line 145
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 148
  free((void *)buses.buses);
#line 149
  buses.len = 0;
#line 150
  buses.buses = (bus_t **)((void *)0);
#line 151
  bus = (bus_t *)((void *)0);
  }
#line 152
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
void buses_add(bus_t *abus ) 
{ 
  bus_t **b ;
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 158
  if ((unsigned long )abus == (unsigned long )((void *)0)) {
#line 159
    return;
  }
  {
#line 161
  tmp = realloc((void *)buses.buses, (unsigned long )(buses.len + 1) * sizeof(bus_t *));
#line 161
  b = (bus_t **)tmp;
  }
#line 162
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 163
    tmp___0 = gettext("Out of memory\n");
#line 163
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 164
    return;
  }
#line 166
  buses.buses = b;
#line 167
  tmp___1 = buses.len;
#line 167
  (buses.len) ++;
#line 167
  *(buses.buses + tmp___1) = abus;
#line 168
  if ((unsigned long )bus == (unsigned long )((void *)0)) {
#line 169
    bus = abus;
  }
#line 170
  return;
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/buses.c"
void buses_delete(bus_t *abus ) 
{ 
  int i ;
  bus_t **b ;
  void *tmp ;

  {
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < buses.len)) {
#line 177
      goto while_break;
    }
#line 178
    if ((unsigned long )abus == (unsigned long )*(buses.buses + i)) {
#line 179
      goto while_break;
    }
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  if (i >= buses.len) {
#line 181
    return;
  }
  {
#line 183
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 183
    if (! (i + 1 < buses.len)) {
#line 183
      goto while_break___0;
    }
#line 184
    *(buses.buses + i) = *(buses.buses + (i + 1));
#line 185
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 187
  (buses.len) --;
#line 188
  tmp = realloc((void *)buses.buses, (unsigned long )buses.len * sizeof(bus_t *));
#line 188
  b = (bus_t **)tmp;
  }
#line 189
  if ((unsigned long )b != (unsigned long )((void *)0)) {
#line 190
    buses.buses = b;
  } else
#line 189
  if (buses.len == 0) {
#line 190
    buses.buses = b;
  }
#line 192
  if ((unsigned long )bus != (unsigned long )abus) {
#line 193
    return;
  }
#line 195
  if (buses.len > 0) {
#line 196
    bus = *(buses.buses + 0);
  }
#line 197
  return;
}
}
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static bus_t *bf561_ezkit_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___20 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->ams[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 24)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 2);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 4)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ABE_B%d",
            i);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->abe[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (! (i < 32)) {
#line 106
      goto while_break___2;
    }
    {
#line 107
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 108
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->data[i],
                                     buff);
#line 108
    failed |= tmp___3;
#line 106
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 111
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 111
  failed |= tmp___4;
#line 113
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->aoe,
                                   (char *)"AOE_B");
#line 113
  failed |= tmp___5;
#line 115
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 115
  failed |= tmp___6;
#line 117
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 117
  failed |= tmp___7;
#line 119
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 119
  failed |= tmp___8;
#line 121
  i = 0;
  }
  {
#line 121
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 121
    if (! (i < 4)) {
#line 121
      goto while_break___3;
    }
    {
#line 122
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"SMS_B%d",
            i);
#line 123
    tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___20 *)bus___0->params)->sms[i],
                                     buff);
#line 123
    failed |= tmp___9;
#line 121
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 126
  if (failed) {
    {
#line 127
    free(bus___0->params);
#line 128
    free((void *)bus___0);
    }
#line 129
    return ((bus_t *)((void *)0));
  }
#line 132
  return (bus___0);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 146
      goto while_break;
    }
#line 144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 147
  tmp = gettext("Blackfin BF561 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 147
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 148
  return;
}
}
#line 154 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static int bf561_ezkit_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 


  {
#line 157
  area->description = (char const   *)((void *)0);
#line 158
  area->start = 0U;
#line 159
  area->length = 4294967296UL;
#line 160
  area->width = 16U;
#line 161
  return (0);
}
}
#line 164 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void select_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 167
  p = bus___0->part;
#line 169
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[0], 1, 0);
#line 170
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[1], 1, 1);
#line 171
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[2], 1, 1);
#line 172
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[3], 1, 1);
#line 174
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[0], 1, 0);
#line 175
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[1], 1, 0);
#line 176
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[2], 1, 0);
#line 177
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[3], 1, 0);
#line 179
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sras, 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->scas, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->swe, 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[0], 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[1], 1, 1);
#line 184
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[2], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[3], 1, 1);
  }
#line 186
  return;
}
}
#line 188 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void unselect_flash___1(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 191
  p = bus___0->part;
#line 193
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[0], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[1], 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[2], 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->ams[3], 1, 1);
#line 198
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[0], 1, 1);
#line 199
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[1], 1, 1);
#line 200
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[2], 1, 1);
#line 201
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[3], 1, 1);
#line 203
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sras, 1, 1);
#line 204
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->scas, 1, 1);
#line 205
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->swe, 1, 1);
#line 206
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[0], 1, 1);
#line 207
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[1], 1, 1);
#line 208
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[2], 1, 1);
#line 209
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->sms[3], 1, 1);
  }
#line 210
  return;
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void setup_address___19(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 216
  p = bus___0->part;
#line 218
  i = 0;
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 24)) {
#line 218
      goto while_break;
    }
    {
#line 219
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 2)) & 1U));
#line 218
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->abe[3], 1, (int )((a >> 1) & 1U));
  }
#line 221
  return;
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void set_data_in___18(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 227
  p = bus___0->part;
#line 229
  i = 0;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < 16)) {
#line 229
      goto while_break;
    }
    {
#line 230
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i], 0, 0);
#line 229
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 231
  return;
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void setup_data___19(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 237
  p = bus___0->part;
#line 239
  i = 0;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! (i < 16)) {
#line 239
      goto while_break;
    }
    {
#line 240
    part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 239
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 248 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 251
  p = bus___0->part;
#line 252
  chain = bus___0->chain;
#line 254
  select_flash___1(bus___0);
#line 255
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 0);
#line 256
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 1);
#line 258
  setup_address___19(bus___0, adr);
#line 259
  set_data_in___18(bus___0);
#line 261
  chain_shift_data_registers(chain, 0);
  }
#line 262
  return;
}
}
#line 268 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 271
  p = bus___0->part;
#line 272
  chain = bus___0->chain;
#line 274
  d = (uint32_t )0;
#line 276
  setup_address___19(bus___0, adr);
#line 277
  chain_shift_data_registers(chain, 1);
#line 279
  i = 0;
  }
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (i < 16)) {
#line 279
      goto while_break;
    }
    {
#line 280
    tmp = part_get_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i]);
#line 280
    d |= (uint32_t )(tmp << i);
#line 279
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (d);
}
}
#line 289 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static uint32_t bf561_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 292
  p = bus___0->part;
#line 293
  chain = bus___0->chain;
#line 295
  d = (uint32_t )0;
#line 297
  unselect_flash___1(bus___0);
#line 298
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 1);
#line 299
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 1);
#line 301
  chain_shift_data_registers(chain, 1);
#line 303
  i = 0;
  }
  {
#line 303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 303
    if (! (i < 16)) {
#line 303
      goto while_break;
    }
    {
#line 304
    tmp = part_get_signal(p, ((bus_params_t___20 *)bus___0->params)->data[i]);
#line 304
    d |= (uint32_t )(tmp << i);
#line 303
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (d);
}
}
#line 313 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
static void bf561_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 316
  p = bus___0->part;
#line 317
  chain = bus___0->chain;
#line 319
  select_flash___1(bus___0);
#line 320
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->aoe, 1, 1);
#line 322
  setup_address___19(bus___0, adr);
#line 323
  setup_data___19(bus___0, data);
#line 325
  chain_shift_data_registers(chain, 0);
#line 327
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 0);
#line 328
  chain_shift_data_registers(chain, 0);
#line 329
  part_set_signal(p, ((bus_params_t___20 *)bus___0->params)->awe, 1, 1);
#line 330
  unselect_flash___1(bus___0);
#line 331
  chain_shift_data_registers(chain, 0);
  }
#line 332
  return;
}
}
#line 334 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf561_ezkit.c"
struct bus_driver  const  bf561_ezkit_bus  = 
#line 334
     {"bf561_ezkit", "Blackfin BF561 EZ-KIT board bus driver", & bf561_ezkit_bus_new,
    & generic_bus_free, & bf561_ezkit_bus_printinfo, & generic_bus_prepare_extest,
    & bf561_ezkit_bus_area, & bf561_ezkit_bus_read_start, & bf561_ezkit_bus_read_next,
    & bf561_ezkit_bus_read_end, & generic_bus_read, & bf561_ezkit_bus_write, & generic_bus_no_init};
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static bus_t *bf548_ezkit_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 70
  failed = 0;
#line 72
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 72
  bus___0 = (bus_t *)tmp;
  }
#line 73
  if (! bus___0) {
#line 74
    return ((bus_t *)((void *)0));
  }
  {
#line 76
  bus___0->driver = driver;
#line 77
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___21 ));
  }
#line 78
  if (! bus___0->params) {
    {
#line 79
    free((void *)bus___0);
    }
#line 80
    return ((bus_t *)((void *)0));
  }
#line 83
  bus___0->chain = chain;
#line 84
  part = *((chain->parts)->parts + chain->active_part);
#line 84
  bus___0->part = part;
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < 4)) {
#line 86
      goto while_break;
    }
    {
#line 87
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS%dB",
            i);
#line 88
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->ams[i],
                                     buff);
#line 88
    failed |= tmp___0;
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! (i < 3)) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 1);
#line 93
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->addr[i],
                                     buff);
#line 93
    failed |= tmp___1;
#line 91
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 96
  i = 3;
  {
#line 96
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 96
    if (! (i < 9)) {
#line 96
      goto while_break___1;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PORTH_%d",
            i + 5);
#line 98
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___2;
#line 96
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 101
  i = 9;
  {
#line 101
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 101
    if (! (i < 24)) {
#line 101
      goto while_break___2;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PORTI_%d",
            i - 9);
#line 103
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->addr[i],
                                     buff);
#line 103
    failed |= tmp___3;
#line 101
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 106
    if (! (i < 16)) {
#line 106
      goto while_break___3;
    }
    {
#line 107
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 108
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->data[i],
                                     buff);
#line 108
    failed |= tmp___4;
#line 106
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 111
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->awe,
                                   (char *)"AWEB");
#line 111
  failed |= tmp___5;
#line 113
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->are,
                                   (char *)"AREB");
#line 113
  failed |= tmp___6;
#line 115
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->aoe,
                                   (char *)"AOEB");
#line 115
  failed |= tmp___7;
#line 117
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->dcs0,
                                   (char *)"CS0_B");
#line 117
  failed |= tmp___8;
#line 119
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___21 *)bus___0->params)->nce,
                                   (char *)"PORTJ_1");
#line 119
  failed |= tmp___9;
  }
#line 121
  if (failed) {
    {
#line 122
    free(bus___0->params);
#line 123
    free((void *)bus___0);
    }
#line 124
    return ((bus_t *)((void *)0));
  }
#line 127
  return (bus___0);
}
}
#line 134 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 139
  i = 0;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 139
      goto while_break;
    }
#line 140
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 141
      goto while_break;
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  tmp = gettext("Blackfin BF548 EZ-KIT compatible bus driver via BSR (JTAG part No. %d)\n");
#line 142
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 143
  return;
}
}
#line 149 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static int bf548_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 152
  area->description = (char const   *)((void *)0);
#line 153
  area->start = 0U;
#line 154
  area->length = 4294967296UL;
#line 155
  area->width = 16U;
#line 157
  return (0);
}
}
#line 160 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void select_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 163
  p = bus___0->part;
#line 165
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 0);
#line 166
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 167
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->dcs0, 1, 1);
#line 170
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->nce, 1, 1);
  }
#line 171
  return;
}
}
#line 173 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void unselect_flash___2(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 176
  p = bus___0->part;
#line 178
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[0], 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[1], 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[2], 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->ams[3], 1, 1);
#line 182
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->dcs0, 1, 1);
#line 183
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->nce, 1, 1);
  }
#line 184
  return;
}
}
#line 186 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void setup_address___20(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 190
  p = bus___0->part;
#line 192
  i = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (i < 24)) {
#line 192
      goto while_break;
    }
    {
#line 193
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 192
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return;
}
}
#line 196 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void set_data_in___19(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 200
  p = bus___0->part;
#line 202
  i = 0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! (i < 16)) {
#line 202
      goto while_break;
    }
    {
#line 203
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 0, 0);
#line 202
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 204
  return;
}
}
#line 206 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void setup_data___20(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 210
  p = bus___0->part;
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (i < 16)) {
#line 212
      goto while_break;
    }
    {
#line 213
    part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 212
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return;
}
}
#line 221 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 224
  p = bus___0->part;
#line 225
  chain = bus___0->chain;
#line 227
  select_flash___2(bus___0);
#line 228
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->aoe, 1, 0);
#line 229
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 0);
#line 230
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 232
  setup_address___20(bus___0, adr);
#line 233
  set_data_in___19(bus___0);
#line 235
  chain_shift_data_registers(chain, 0);
  }
#line 236
  return;
}
}
#line 242 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 245
  p = bus___0->part;
#line 246
  chain = bus___0->chain;
#line 248
  d = (uint32_t )0;
#line 250
  setup_address___20(bus___0, adr);
#line 251
  chain_shift_data_registers(chain, 1);
#line 253
  i = 0;
  }
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < 16)) {
#line 253
      goto while_break;
    }
    {
#line 254
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 254
    d |= (uint32_t )(tmp << i);
#line 253
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return (d);
}
}
#line 263 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static uint32_t bf548_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 266
  p = bus___0->part;
#line 267
  chain = bus___0->chain;
#line 269
  d = (uint32_t )0;
#line 271
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->aoe, 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 274
  unselect_flash___2(bus___0);
#line 276
  chain_shift_data_registers(chain, 1);
#line 278
  i = 0;
  }
  {
#line 278
  while (1) {
    while_continue: /* CIL Label */ ;
#line 278
    if (! (i < 16)) {
#line 278
      goto while_break;
    }
    {
#line 279
    tmp = part_get_signal(p, ((bus_params_t___21 *)bus___0->params)->data[i]);
#line 279
    d |= (uint32_t )(tmp << i);
#line 278
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return (d);
}
}
#line 288 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
static void bf548_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 291
  p = bus___0->part;
#line 292
  chain = bus___0->chain;
#line 294
  select_flash___2(bus___0);
#line 295
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->aoe, 1, 0);
#line 296
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->are, 1, 1);
#line 298
  setup_address___20(bus___0, adr);
#line 299
  setup_data___20(bus___0, data);
#line 301
  chain_shift_data_registers(chain, 0);
#line 303
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 0);
#line 304
  chain_shift_data_registers(chain, 0);
#line 305
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->awe, 1, 1);
#line 306
  part_set_signal(p, ((bus_params_t___21 *)bus___0->params)->aoe, 1, 1);
#line 307
  unselect_flash___2(bus___0);
#line 308
  chain_shift_data_registers(chain, 0);
  }
#line 309
  return;
}
}
#line 311 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf548_ezkit.c"
struct bus_driver  const  bf548_ezkit_bus  = 
#line 311
     {"bf548_ezkit", "Blackfin BF548 EZ-KIT board bus driver", & bf548_ezkit_bus_new,
    & generic_bus_free, & bf548_ezkit_bus_printinfo, & generic_bus_prepare_extest,
    & bf548_ezkit_bus_area, & bf548_ezkit_bus_read_start, & bf548_ezkit_bus_read_next,
    & bf548_ezkit_bus_read_end, & generic_bus_read, & bf548_ezkit_bus_write, & generic_bus_no_init};
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static bus_t *bf537_stamp_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___22 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->ams[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 19)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR%d",
            i + 1);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 16)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA%d",
            i);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->data[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 106
  failed |= tmp___3;
#line 108
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->are,
                                   (char *)"ARE_B");
#line 108
  failed |= tmp___4;
#line 110
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->abe[0],
                                   (char *)"ABE_B0");
#line 110
  failed |= tmp___5;
#line 112
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->abe[1],
                                   (char *)"ABE_B1");
#line 112
  failed |= tmp___6;
#line 114
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 114
  failed |= tmp___7;
#line 116
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 116
  failed |= tmp___8;
#line 118
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 118
  failed |= tmp___9;
#line 120
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sms,
                                    (char *)"SMS_B");
#line 120
  failed |= tmp___10;
  }
#line 122
  if (failed) {
    {
#line 123
    free(bus___0->params);
#line 124
    free((void *)bus___0);
    }
#line 125
    return ((bus_t *)((void *)0));
  }
#line 128
  return (bus___0);
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static int bf537_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 138
  area->description = (char const   *)((void *)0);
#line 139
  area->start = 0U;
#line 140
  area->length = 4294967296UL;
#line 141
  area->width = 16U;
#line 143
  return (0);
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void select_flash___3(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 149
  p = bus___0->part;
#line 151
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 0);
#line 152
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 153
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 154
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 156
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 0);
#line 157
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 0);
#line 159
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 160
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 161
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 162
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms, 1, 1);
  }
#line 163
  return;
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void unselect_flash___3(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 168
  p = bus___0->part;
#line 170
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 1);
#line 171
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 172
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 173
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 179
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 180
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 181
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms, 1, 1);
  }
#line 182
  return;
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void setup_address___21(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 188
  p = bus___0->part;
#line 190
  i = 0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < 19)) {
#line 190
      goto while_break;
    }
    {
#line 191
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 190
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void set_data_in___20(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 198
  p = bus___0->part;
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (i < 16)) {
#line 200
      goto while_break;
    }
    {
#line 201
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 0, 0);
#line 200
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void setup_data___21(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 208
  p = bus___0->part;
#line 210
  i = 0;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < 16)) {
#line 210
      goto while_break;
    }
    {
#line 211
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 210
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return;
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 222
  p = bus___0->part;
#line 223
  chain = bus___0->chain;
#line 225
  select_flash___3(bus___0);
#line 226
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 0);
#line 227
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 229
  setup_address___21(bus___0, adr);
#line 230
  set_data_in___20(bus___0);
#line 232
  chain_shift_data_registers(chain, 0);
  }
#line 233
  return;
}
}
#line 239 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 242
  p = bus___0->part;
#line 243
  chain = bus___0->chain;
#line 245
  d = (uint32_t )0;
#line 247
  setup_address___21(bus___0, adr);
#line 248
  chain_shift_data_registers(chain, 1);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < 16)) {
#line 250
      goto while_break;
    }
    {
#line 251
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 251
    d |= (uint32_t )(tmp << i);
#line 250
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (d);
}
}
#line 260 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static uint32_t bf537_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 263
  p = bus___0->part;
#line 264
  chain = bus___0->chain;
#line 266
  d = (uint32_t )0;
#line 268
  unselect_flash___3(bus___0);
#line 269
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 1);
#line 270
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 272
  chain_shift_data_registers(chain, 1);
#line 274
  i = 0;
  }
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < 16)) {
#line 274
      goto while_break;
    }
    {
#line 275
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 275
    d |= (uint32_t )(tmp << i);
#line 274
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  return (d);
}
}
#line 284 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 287
  p = bus___0->part;
#line 288
  chain = bus___0->chain;
#line 290
  select_flash___3(bus___0);
#line 291
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 1);
#line 293
  setup_address___21(bus___0, adr);
#line 294
  setup_data___21(bus___0, data);
#line 296
  chain_shift_data_registers(chain, 0);
#line 298
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 0);
#line 299
  chain_shift_data_registers(chain, 0);
#line 300
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 301
  unselect_flash___3(bus___0);
#line 302
  chain_shift_data_registers(chain, 0);
  }
#line 303
  return;
}
}
#line 309 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
static void bf537_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 314
  i = 0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 314
      goto while_break;
    }
#line 315
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 316
      goto while_break;
    }
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 317
  tmp = gettext("%s (JTAG part No. %d)\n");
#line 317
  printf((char const   */* __restrict  */)tmp, (bus___0->driver)->description, i);
  }
#line 318
  return;
}
}
#line 335 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
struct bus_driver  const  bf537_stamp_bus  = 
#line 335
     {"bf537_stamp", "Blackfin BF537 Stamp board bus driver via BSR", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 345 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
struct bus_driver  const  bf537_ezkit_bus  = 
#line 345
     {"bf537_ezkit", "Blackfin BF537 EZ-KIT board bus driver via BSR", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 355 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
struct bus_driver  const  bf527_ezkit_bus  = 
#line 355
     {"bf527_ezkit", "Blackfin BF527 EZ-KIT board bus driver via BSR", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 365 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
struct bus_driver  const  bf538f_ezkit_bus  = 
#line 365
     {"bf538f_ezkit", "Blackfin BF538F EZ-KIT board bus driver", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 375 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf537_stamp.c"
struct bus_driver  const  bf526_ezkit_bus  = 
#line 375
     {"bf526_ezkit", "Blackfin BF526 EZ-KIT board bus driver", & bf537_stamp_bus_new,
    & generic_bus_free, & bf537_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf537_stamp_bus_area, & bf537_stamp_bus_read_start, & bf537_stamp_bus_read_next,
    & bf537_stamp_bus_read_end, & generic_bus_read, & bf537_stamp_bus_write, & generic_bus_no_init};
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static bus_t *bf533_stamp_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___22 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 2)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"PF%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->abe[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 4)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->ams[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 19)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->addr[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 106
    if (! (i < 16)) {
#line 106
      goto while_break___2;
    }
    {
#line 107
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 108
    tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->data[i],
                                     buff);
#line 108
    failed |= tmp___3;
#line 106
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 111
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 111
  failed |= tmp___4;
#line 113
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->are,
                                   (char *)"AOE_B");
#line 113
  failed |= tmp___5;
#line 115
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 115
  failed |= tmp___6;
#line 117
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 117
  failed |= tmp___7;
#line 119
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 119
  failed |= tmp___8;
#line 121
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sms,
                                   (char *)"SMS_B");
#line 121
  failed |= tmp___9;
  }
#line 123
  if (failed) {
    {
#line 124
    free(bus___0->params);
#line 125
    free((void *)bus___0);
    }
#line 126
    return ((bus_t *)((void *)0));
  }
#line 129
  return (bus___0);
}
}
#line 136 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 141
      goto while_break;
    }
#line 142
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 144
  tmp = gettext("Blackfin BF533 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 144
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 145
  return;
}
}
#line 151 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static int bf533_stamp_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 154
  area->description = (char const   *)((void *)0);
#line 155
  area->start = 0U;
#line 156
  area->length = 4294967296UL;
#line 157
  area->width = 16U;
#line 159
  return (0);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void select_flash___4(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 165
  p = bus___0->part;
#line 167
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 0);
#line 168
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 0);
#line 170
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 0);
#line 171
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 172
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 173
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 177
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 178
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms, 1, 1);
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void unselect_flash___4(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 184
  p = bus___0->part;
#line 186
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 0);
#line 187
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 0);
#line 189
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 1);
#line 190
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 197
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms, 1, 1);
  }
#line 198
  return;
}
}
#line 200 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void setup_address___22(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 204
  p = bus___0->part;
#line 206
  i = 0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < 19)) {
#line 206
      goto while_break;
    }
    {
#line 207
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 206
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 208
  return;
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void set_data_in___21(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 214
  p = bus___0->part;
#line 216
  i = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < 16)) {
#line 216
      goto while_break;
    }
    {
#line 217
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 0, 0);
#line 216
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  return;
}
}
#line 220 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void setup_data___22(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 224
  p = bus___0->part;
#line 226
  i = 0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (i < 16)) {
#line 226
      goto while_break;
    }
    {
#line 227
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 226
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 238
  p = bus___0->part;
#line 239
  chain = bus___0->chain;
#line 241
  select_flash___4(bus___0);
#line 242
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 0);
#line 243
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 245
  setup_address___22(bus___0, adr);
#line 246
  set_data_in___21(bus___0);
#line 248
  chain_shift_data_registers(chain, 0);
  }
#line 249
  return;
}
}
#line 255 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 258
  p = bus___0->part;
#line 259
  chain = bus___0->chain;
#line 261
  d = (uint32_t )0;
#line 263
  setup_address___22(bus___0, adr);
#line 264
  chain_shift_data_registers(chain, 1);
#line 266
  i = 0;
  }
  {
#line 266
  while (1) {
    while_continue: /* CIL Label */ ;
#line 266
    if (! (i < 16)) {
#line 266
      goto while_break;
    }
    {
#line 267
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 267
    d |= (uint32_t )(tmp << i);
#line 266
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return (d);
}
}
#line 276 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static uint32_t bf533_stamp_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 279
  p = bus___0->part;
#line 280
  chain = bus___0->chain;
#line 282
  d = (uint32_t )0;
#line 284
  unselect_flash___4(bus___0);
#line 285
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 288
  chain_shift_data_registers(chain, 1);
#line 290
  i = 0;
  }
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < 16)) {
#line 290
      goto while_break;
    }
    {
#line 291
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 291
    d |= (uint32_t )(tmp << i);
#line 290
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return (d);
}
}
#line 300 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
static void bf533_stamp_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 303
  p = bus___0->part;
#line 304
  chain = bus___0->chain;
#line 308
  select_flash___4(bus___0);
#line 309
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 1);
#line 311
  setup_address___22(bus___0, adr);
#line 312
  setup_data___22(bus___0, data);
#line 314
  chain_shift_data_registers(chain, 0);
#line 316
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 0);
#line 317
  chain_shift_data_registers(chain, 0);
#line 318
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 319
  unselect_flash___4(bus___0);
#line 320
  chain_shift_data_registers(chain, 0);
  }
#line 321
  return;
}
}
#line 323 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_stamp.c"
struct bus_driver  const  bf533_stamp_bus  = 
#line 323
     {"bf533_stamp", "Blackfin BF533 Stamp board bus driver", & bf533_stamp_bus_new,
    & generic_bus_free, & bf533_stamp_bus_printinfo, & generic_bus_prepare_extest,
    & bf533_stamp_bus_area, & bf533_stamp_bus_read_start, & bf533_stamp_bus_read_next,
    & bf533_stamp_bus_read_end, & generic_bus_read, & bf533_stamp_bus_write, & generic_bus_no_init};
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static bus_t *bf533_ezkit_bus_new(chain_t *chain , bus_driver_t const   *driver ,
                                  char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[15] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 75
  failed = 0;
#line 77
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 77
  bus___0 = (bus_t *)tmp;
  }
#line 78
  if (! bus___0) {
#line 79
    return ((bus_t *)((void *)0));
  }
  {
#line 81
  bus___0->driver = driver;
#line 82
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___22 ));
  }
#line 83
  if (! bus___0->params) {
    {
#line 84
    free((void *)bus___0);
    }
#line 85
    return ((bus_t *)((void *)0));
  }
#line 88
  bus___0->chain = chain;
#line 89
  part = *((chain->parts)->parts + chain->active_part);
#line 89
  bus___0->part = part;
#line 91
  i = 0;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
#line 91
    if (! (i < 4)) {
#line 91
      goto while_break;
    }
    {
#line 92
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"AMS_B%d",
            i);
#line 93
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->ams[i],
                                     buff);
#line 93
    failed |= tmp___0;
#line 91
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  i = 0;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! (i < 19)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"ADDR[%d]",
            i + 1);
#line 98
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->addr[i],
                                     buff);
#line 98
    failed |= tmp___1;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  i = 0;
  {
#line 101
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 101
    if (! (i < 16)) {
#line 101
      goto while_break___1;
    }
    {
#line 102
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"DATA[%d]",
            i);
#line 103
    tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->data[i],
                                     buff);
#line 103
    failed |= tmp___2;
#line 101
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 106
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->awe,
                                   (char *)"AWE_B");
#line 106
  failed |= tmp___3;
#line 108
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->are,
                                   (char *)"AOE_B");
#line 108
  failed |= tmp___4;
#line 110
  tmp___5 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->abe[0],
                                   (char *)"ABE_B0");
#line 110
  failed |= tmp___5;
#line 112
  tmp___6 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->abe[1],
                                   (char *)"ABE_B1");
#line 112
  failed |= tmp___6;
#line 114
  tmp___7 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sras,
                                   (char *)"SRAS_B");
#line 114
  failed |= tmp___7;
#line 116
  tmp___8 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->scas,
                                   (char *)"SCAS_B");
#line 116
  failed |= tmp___8;
#line 118
  tmp___9 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->swe,
                                   (char *)"SWE_B");
#line 118
  failed |= tmp___9;
#line 120
  tmp___10 = generic_bus_attach_sig(part, & ((bus_params_t___22 *)bus___0->params)->sms,
                                    (char *)"SMS_B");
#line 120
  failed |= tmp___10;
  }
#line 122
  if (failed) {
    {
#line 123
    free(bus___0->params);
#line 124
    free((void *)bus___0);
    }
#line 125
    return ((bus_t *)((void *)0));
  }
#line 128
  return (bus___0);
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 140
      goto while_break;
    }
#line 141
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 142
      goto while_break;
    }
#line 140
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  tmp = gettext("Blackfin BF533 EZKit compatible bus driver via BSR (JTAG part No. %d)\n");
#line 143
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 144
  return;
}
}
#line 150 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static int bf533_ezkit_bus_area(bus_t *bus___0 , uint32_t adr , bus_area_t *area ) 
{ 


  {
#line 153
  area->description = (char const   *)((void *)0);
#line 154
  area->start = 0U;
#line 155
  area->length = 4294967296UL;
#line 156
  area->width = 16U;
#line 158
  return (0);
}
}
#line 161 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void select_flash___5(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 164
  p = bus___0->part;
#line 166
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 0);
#line 167
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 168
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 169
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 171
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 0);
#line 172
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 0);
#line 174
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 175
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 176
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 177
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms, 1, 1);
  }
#line 178
  return;
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void unselect_flash___5(bus_t *bus___0 ) 
{ 
  part_t *p ;

  {
  {
#line 183
  p = bus___0->part;
#line 185
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[0], 1, 1);
#line 186
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[1], 1, 1);
#line 187
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[2], 1, 1);
#line 188
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->ams[3], 1, 1);
#line 190
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[0], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->abe[1], 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sras, 1, 1);
#line 194
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->scas, 1, 1);
#line 195
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->swe, 1, 1);
#line 196
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->sms, 1, 1);
  }
#line 197
  return;
}
}
#line 199 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void setup_address___23(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 203
  p = bus___0->part;
#line 205
  i = 0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! (i < 19)) {
#line 205
      goto while_break;
    }
    {
#line 206
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->addr[i], 1, (int )((a >> (i + 1)) & 1U));
#line 205
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return;
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void set_data_in___22(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 213
  p = bus___0->part;
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (i < 16)) {
#line 215
      goto while_break;
    }
    {
#line 216
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 0, 0);
#line 215
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return;
}
}
#line 219 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void setup_data___23(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 223
  p = bus___0->part;
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < 16)) {
#line 225
      goto while_break;
    }
    {
#line 226
    part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i], 1, (int )((d >> i) & 1U));
#line 225
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  return;
}
}
#line 234 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 237
  p = bus___0->part;
#line 238
  chain = bus___0->chain;
#line 240
  select_flash___5(bus___0);
#line 241
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 0);
#line 242
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 244
  setup_address___23(bus___0, adr);
#line 245
  set_data_in___22(bus___0);
#line 247
  chain_shift_data_registers(chain, 0);
  }
#line 248
  return;
}
}
#line 254 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 257
  p = bus___0->part;
#line 258
  chain = bus___0->chain;
#line 260
  d = (uint32_t )0;
#line 262
  setup_address___23(bus___0, adr);
#line 263
  chain_shift_data_registers(chain, 1);
#line 265
  i = 0;
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (! (i < 16)) {
#line 265
      goto while_break;
    }
    {
#line 266
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 266
    d |= (uint32_t )(tmp << i);
#line 265
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (d);
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static uint32_t bf533_ezkit_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 278
  p = bus___0->part;
#line 279
  chain = bus___0->chain;
#line 281
  d = (uint32_t )0;
#line 283
  unselect_flash___5(bus___0);
#line 284
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 1);
#line 285
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 287
  chain_shift_data_registers(chain, 1);
#line 289
  i = 0;
  }
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < 16)) {
#line 289
      goto while_break;
    }
    {
#line 290
    tmp = part_get_signal(p, ((bus_params_t___22 *)bus___0->params)->data[i]);
#line 290
    d |= (uint32_t )(tmp << i);
#line 289
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 292
  return (d);
}
}
#line 299 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
static void bf533_ezkit_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 302
  p = bus___0->part;
#line 303
  chain = bus___0->chain;
#line 307
  select_flash___5(bus___0);
#line 308
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->are, 1, 1);
#line 310
  setup_address___23(bus___0, adr);
#line 311
  setup_data___23(bus___0, data);
#line 313
  chain_shift_data_registers(chain, 0);
#line 315
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 0);
#line 316
  chain_shift_data_registers(chain, 0);
#line 317
  part_set_signal(p, ((bus_params_t___22 *)bus___0->params)->awe, 1, 1);
#line 318
  unselect_flash___5(bus___0);
#line 319
  chain_shift_data_registers(chain, 0);
  }
#line 320
  return;
}
}
#line 322 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bf533_ezkit.c"
struct bus_driver  const  bf533_ezkit_bus  = 
#line 322
     {"bf533_ezkit", "Blackfin BF533 EZKit board bus driver", & bf533_ezkit_bus_new,
    & generic_bus_free, & bf533_ezkit_bus_printinfo, & generic_bus_prepare_extest,
    & bf533_ezkit_bus_area, & bf533_ezkit_bus_read_start, & bf533_ezkit_bus_read_next,
    & bf533_ezkit_bus_read_end, & generic_bus_read, & bf533_ezkit_bus_write, & generic_bus_no_init};
#line 60 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static bus_t *bcm1250_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 67
  failed = 0;
#line 69
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 69
  bus___0 = (bus_t *)tmp;
  }
#line 70
  if (! bus___0) {
#line 71
    return ((bus_t *)((void *)0));
  }
  {
#line 73
  bus___0->driver = driver;
#line 74
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___10 ));
  }
#line 75
  if (! bus___0->params) {
    {
#line 76
    free((void *)bus___0);
    }
#line 77
    return ((bus_t *)((void *)0));
  }
#line 80
  bus___0->chain = chain;
#line 81
  part = *((chain->parts)->parts + chain->active_part);
#line 81
  bus___0->part = part;
#line 83
  i = 0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < 32)) {
#line 83
      goto while_break;
    }
    {
#line 84
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_AD%d",
            i);
#line 85
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->a[i],
                                     buff);
#line 85
    failed |= tmp___0;
#line 83
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 88
  i = 0;
  {
#line 88
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 88
    if (! (i < 8)) {
#line 88
      goto while_break___0;
    }
    {
#line 89
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"IO_CS_L%d",
            i);
#line 90
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->d[i],
                                     buff);
#line 90
    failed |= tmp___1;
#line 88
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 93
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->ncs,
                                   (char *)"IO_RW");
#line 93
  failed |= tmp___2;
#line 95
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->nwe,
                                   (char *)"IO_WR_L");
#line 95
  failed |= tmp___3;
#line 97
  tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___10 *)bus___0->params)->noe,
                                   (char *)"IO_OE_L");
#line 97
  failed |= tmp___4;
  }
#line 99
  if (failed) {
    {
#line 100
    free(bus___0->params);
#line 101
    free((void *)bus___0);
    }
#line 102
    return ((bus_t *)((void *)0));
  }
#line 105
  return (bus___0);
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static void bcm1250_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 117
  i = 0;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 117
      goto while_break;
    }
#line 118
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 119
      goto while_break;
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp = gettext("Broadcom BCM1250 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 120
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 121
  return;
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static int bcm1250_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 


  {
#line 130
  area->description = (char const   *)((void *)0);
#line 131
  area->start = 0U;
#line 132
  area->length = 4294967296UL;
#line 133
  area->width = 8U;
#line 135
  return (0);
}
}
#line 140 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static void setup_address___24(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 144
  p = bus___0->part;
#line 146
  i = 0;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 146
    if (! (i < 24)) {
#line 146
      goto while_break;
    }
    {
#line 147
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i], 1, (int )((a >> i) & 1U));
#line 146
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static void set_data_in___23(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;

  {
#line 155
  p = bus___0->part;
#line 157
  i = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < 8)) {
#line 157
      goto while_break;
    }
    {
#line 158
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24], 0, 0);
#line 157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static void setup_data___24(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;

  {
#line 166
  p = bus___0->part;
#line 168
  i = 0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (! (i < 8)) {
#line 168
      goto while_break;
    }
    {
#line 169
    part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24], 1, (int )((d >> i) & 1U));
#line 168
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 177 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static void bcm1250_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 180
  p = bus___0->part;
#line 181
  chain = bus___0->chain;
#line 183
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[0], 1, 0);
#line 184
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[1], 1, 1);
#line 185
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[2], 1, 1);
#line 186
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[3], 1, 1);
#line 187
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[4], 1, 1);
#line 188
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[5], 1, 1);
#line 189
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[6], 1, 1);
#line 190
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7], 1, 1);
#line 191
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 1);
#line 192
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 193
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 0);
#line 195
  setup_address___24(bus___0, adr);
#line 196
  set_data_in___23(bus___0);
#line 198
  chain_shift_data_registers(chain, 0);
  }
#line 199
  return;
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static uint32_t bcm1250_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 208
  p = bus___0->part;
#line 209
  chain = bus___0->chain;
#line 211
  setup_address___24(bus___0, adr);
#line 212
  chain_shift_data_registers(chain, 1);
#line 216
  d = (uint32_t )0;
#line 218
  i = 0;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! (i < 8)) {
#line 218
      goto while_break;
    }
    {
#line 219
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24]);
#line 219
    d |= (uint32_t )(tmp << i);
#line 218
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return (d);
}
}
#line 230 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static uint32_t bcm1250_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  int i ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 233
  p = bus___0->part;
#line 234
  chain = bus___0->chain;
#line 236
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[0], 1, 1);
#line 237
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 238
  chain_shift_data_registers(chain, 1);
#line 242
  d = (uint32_t )0;
#line 244
  i = 0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < 8)) {
#line 244
      goto while_break;
    }
    {
#line 245
    tmp = part_get_signal(p, ((bus_params_t___10 *)bus___0->params)->a[i + 24]);
#line 245
    d |= (uint32_t )(tmp << i);
#line 244
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  return (d);
}
}
#line 256 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
static void bcm1250_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 259
  p = bus___0->part;
#line 260
  chain = bus___0->chain;
#line 262
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[0], 1, 0);
#line 263
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[1], 1, 1);
#line 264
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[2], 1, 1);
#line 265
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[3], 1, 1);
#line 266
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[4], 1, 1);
#line 267
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[5], 1, 1);
#line 268
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[6], 1, 1);
#line 269
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->d[7], 1, 1);
#line 270
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->ncs, 1, 0);
#line 271
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->noe, 1, 1);
#line 274
  setup_address___24(bus___0, adr);
#line 275
  setup_data___24(bus___0, data);
#line 277
  chain_shift_data_registers(chain, 0);
#line 279
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 0);
#line 280
  chain_shift_data_registers(chain, 0);
#line 282
  part_set_signal(p, ((bus_params_t___10 *)bus___0->params)->nwe, 1, 1);
#line 283
  chain_shift_data_registers(chain, 0);
  }
#line 284
  return;
}
}
#line 486 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/bcm1250.c"
struct bus_driver  const  bcm1250_bus  = 
#line 486
     {"bcm1250", "Broadcom BCM1250 compatible bus driver via BSR", & bcm1250_bus_new,
    & generic_bus_free, & bcm1250_bus_printinfo, & generic_bus_prepare_extest, & bcm1250_bus_area,
    & bcm1250_bus_read_start, & bcm1250_bus_read_next, & bcm1250_bus_read_end, & generic_bus_read,
    & bcm1250_bus_write, & generic_bus_no_init};
#line 131 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static void register_set_bit(tap_register *tr , unsigned int bitno , unsigned int val ) 
{ 


  {
#line 134
  if (val) {
#line 134
    *(tr->data + bitno) = (char)1;
  } else {
#line 134
    *(tr->data + bitno) = (char)0;
  }
#line 135
  return;
}
}
#line 137 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static int register_get_bit(tap_register *tr , unsigned int bitno ) 
{ 
  int tmp ;

  {
#line 140
  if ((int )*(tr->data + bitno) & 1) {
#line 140
    tmp = 1;
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return (tmp);
}
}
#line 143 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static void shift_instr(bus_t *bus___0 , unsigned int bit ) 
{ 
  tap_register *r ;
  int tmp___3 ;

  {
#line 146
  r = ((bus___0->part)->active_instruction)->out;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 150
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 152
    chain_shift_instructions_mode(bus___0->chain, 1, 1, 1);
    }
    {
#line 153
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 153
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 148
    tmp___3 = register_get_bit(r, bit);
    }
#line 148
    if (! tmp___3) {
#line 148
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 157
  return;
}
}
#line 159 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static void shift_data(bus_t *bus___0 , unsigned int bit ) 
{ 
  data_register *dr ;
  int tmp___3 ;

  {
#line 162
  dr = ((bus___0->part)->active_instruction)->data_register;
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 166
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 168
    chain_shift_data_registers(bus___0->chain, 1);
    }
    {
#line 169
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 169
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 164
    tmp___3 = register_get_bit(dr->out, bit);
    }
#line 164
    if (! tmp___3) {
#line 164
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return;
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void mwa_scan_in_instr(bus_t *bus___0 ) 
{ 


  {
  {
#line 181
  shift_instr(bus___0, 2U);
  }
#line 182
  return;
}
}
#line 184 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void mwa_scan_in_addr(bus_t *bus___0 , unsigned int slave , uint32_t addr ,
                             int mode ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 187
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 195
    if (! (i < 4)) {
#line 195
      goto while_break___0;
    }
    {
#line 196
    register_set_bit(r, (unsigned int )(31 + i), slave & (unsigned int )(1 << i));
#line 195
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 199
  addr >>= 2;
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 200
    if (! (i < 30)) {
#line 200
      goto while_break___1;
    }
    {
#line 201
    register_set_bit(r, (unsigned int )(1 + i), addr & (unsigned int )(1 << i));
#line 200
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 204
  register_set_bit(r, 0U, (unsigned int )mode);
#line 206
  shift_data(bus___0, 32U);
  }
#line 207
  return;
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void mwa_scan_in_data(bus_t *bus___0 , uint32_t data ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 212
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  register_set_bit(r, 0U, 0U);
#line 218
  register_set_bit(r, 1U, 0U);
#line 219
  register_set_bit(r, 2U, 0U);
#line 221
  i = 0;
  }
  {
#line 221
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 221
    if (! (i < 32)) {
#line 221
      goto while_break___0;
    }
    {
#line 222
    register_set_bit(r, (unsigned int )(3 + i), data & (unsigned int )(1 << i));
#line 221
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 224
  shift_data(bus___0, 0U);
  }
#line 225
  return;
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void mwa_scan_out_data(bus_t *bus___0 , uint32_t *pdata ) 
{ 
  tap_register *r ;
  uint32_t data ;
  int i ;
  int tmp ;

  {
  {
#line 230
  r = (((bus___0->part)->active_instruction)->data_register)->out;
#line 234
  shift_data(bus___0, 32U);
#line 236
  data = (uint32_t )0;
#line 237
  i = 0;
  }
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 237
    if (! (i < 32)) {
#line 237
      goto while_break;
    }
    {
#line 238
    tmp = register_get_bit(r, (unsigned int )i);
#line 238
    data |= (unsigned int )(tmp << i);
#line 237
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 240
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 242
  *pdata = data;
#line 243
  return;
}
}
#line 254 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static void mwa_write_word(bus_t *bus___0 , unsigned int slave , uint32_t addr ,
                                    uint32_t data ) 
{ 


  {
  {
#line 257
  mwa_scan_in_instr(bus___0);
#line 258
  mwa_scan_in_addr(bus___0, slave, addr, 0);
#line 259
  mwa_scan_in_data(bus___0, data);
  }
#line 260
  return;
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void nexus_access_start(bus_t *bus___0 ) 
{ 


  {
  {
#line 267
  shift_instr(bus___0, 2U);
  }
#line 268
  return;
}
}
#line 270 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void nexus_access_end(bus_t *bus___0 ) 
{ 


  {
  {
#line 273
  tap_reset_bypass(bus___0->chain);
  }
#line 274
  return;
}
}
#line 276 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void nexus_access_set_addr(bus_t *bus___0 , uint32_t addr , int mode ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 279
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 285
  register_fill(r, 0);
#line 288
  addr >>= 2;
#line 289
  i = 0;
  }
  {
#line 289
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 289
    if (! (i < 7)) {
#line 289
      goto while_break___0;
    }
    {
#line 290
    register_set_bit(r, (unsigned int )(27 + i), addr & (unsigned int )(1 << i));
#line 289
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 293
  register_set_bit(r, 26U, (unsigned int )mode);
#line 295
  shift_data(bus___0, 32U);
  }
#line 296
  return;
}
}
#line 298 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void nexus_access_read_data(bus_t *bus___0 , uint32_t *pdata ) 
{ 
  tap_register *r ;
  uint32_t data ;
  int i ;
  int tmp ;

  {
  {
#line 301
  r = (((bus___0->part)->active_instruction)->data_register)->out;
#line 305
  shift_data(bus___0, 32U);
#line 307
  data = (uint32_t )0;
#line 308
  i = 0;
  }
  {
#line 308
  while (1) {
    while_continue: /* CIL Label */ ;
#line 308
    if (! (i < 32)) {
#line 308
      goto while_break;
    }
    {
#line 309
    tmp = register_get_bit(r, (unsigned int )i);
#line 309
    data |= (unsigned int )(tmp << i);
#line 308
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 311
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 311
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 313
  *pdata = data;
#line 314
  return;
}
}
#line 316 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void nexus_access_write_data(bus_t *bus___0 , uint32_t data ) 
{ 
  tap_register *r ;
  int i ;

  {
#line 319
  r = (((bus___0->part)->active_instruction)->data_register)->in;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 324
  register_set_bit(r, 0U, 0U);
#line 325
  register_set_bit(r, 1U, 0U);
#line 327
  i = 0;
  }
  {
#line 327
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 327
    if (! (i < 32)) {
#line 327
      goto while_break___0;
    }
    {
#line 328
    register_set_bit(r, (unsigned int )(2 + i), data & (unsigned int )(1 << i));
#line 327
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 330
  shift_data(bus___0, 0U);
  }
#line 331
  return;
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static void nexus_reg_read(bus_t *bus___0 , uint32_t reg , uint32_t *data ) 
{ 


  {
  {
#line 336
  nexus_access_set_addr(bus___0, reg, 1);
#line 337
  nexus_access_read_data(bus___0, data);
  }
#line 338
  return;
}
}
#line 340 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
__inline static void nexus_reg_write(bus_t *bus___0 , uint32_t reg , uint32_t data ) 
{ 


  {
  {
#line 343
  nexus_access_set_addr(bus___0, reg, 0);
#line 344
  nexus_access_write_data(bus___0, data);
  }
#line 345
  return;
}
}
#line 349 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void nexus_memacc_set_addr(bus_t *bus___0 , uint32_t addr , uint32_t rwcs ) 
{ 


  {
  {
#line 352
  nexus_reg_write(bus___0, (uint32_t )36, addr);
#line 353
  nexus_reg_write(bus___0, (uint32_t )28, rwcs);
  }
#line 354
  return;
}
}
#line 356 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static int nexus_memacc_read(bus_t *bus___0 , uint32_t *data ) 
{ 
  uint32_t status ;
  int ret ;
  char *tmp___0 ;

  {
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 364
    nexus_reg_read(bus___0, (uint32_t )28, & status);
#line 365
    status &= 3U;
    }
#line 362
    if (! (status == 0U)) {
#line 362
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 370
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 370
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 372
  ret = 0;
  {
#line 375
  if (status == 1U) {
#line 375
    goto case_1;
  }
#line 378
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 376
  nexus_reg_read(bus___0, (uint32_t )40, data);
  }
#line 377
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 379
  tmp___0 = gettext("%s(%d): error, read failed, status=%d\n");
#line 379
  printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c",
         379, status);
#line 380
  *data = 4294967295U;
#line 381
  ret = -1;
  }
#line 382
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 385
  return (ret);
}
}
#line 388 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static int nexus_memacc_write(bus_t *bus___0 , uint32_t addr , uint32_t data , uint32_t rwcs ) 
{ 
  uint32_t status ;
  int ret ;
  char *tmp___0 ;

  {
  {
#line 394
  nexus_reg_write(bus___0, (uint32_t )36, addr);
#line 395
  nexus_reg_write(bus___0, (uint32_t )28, rwcs);
#line 396
  nexus_reg_write(bus___0, (uint32_t )40, data);
#line 398
  nexus_reg_read(bus___0, (uint32_t )28, & status);
#line 399
  status &= 3U;
  }
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  ret = 0;
#line 404
  if (status) {
    {
#line 406
    tmp___0 = gettext("%s(%d): error, write failed, status=%d\n");
#line 406
    printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c",
           406, status);
#line 407
    ret = -1;
    }
  }
#line 410
  return (ret);
}
}
#line 415 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void avr32_bus_setup(bus_t *bus___0 , chain_t *chain , part_t *part , unsigned int mode ) 
{ 


  {
#line 419
  bus___0->chain = chain;
#line 420
  bus___0->part = part;
#line 421
  ((bus_params_t___23 *)bus___0->params)->mode = mode;
  {
#line 425
  if (mode == 0U) {
#line 425
    goto case_0;
  }
#line 430
  if (mode == 1U) {
#line 430
    goto case_1;
  }
#line 435
  if (mode == 2U) {
#line 435
    goto case_2;
  }
#line 440
  if (mode == 3U) {
#line 440
    goto case_3;
  }
#line 446
  if (mode == 4U) {
#line 446
    goto case_4;
  }
#line 452
  if (mode == 5U) {
#line 452
    goto case_5;
  }
#line 423
  goto switch_break;
  case_0: /* CIL Label */ 
#line 426
  ((bus_params_t___23 *)bus___0->params)->slave = 1U;
#line 427
  ((bus_params_t___23 *)bus___0->params)->addr_mask = (uint32_t )4092;
#line 428
  goto switch_break;
  case_1: /* CIL Label */ 
#line 431
  ((bus_params_t___23 *)bus___0->params)->slave = 4U;
#line 432
  ((bus_params_t___23 *)bus___0->params)->addr_mask = 4294967292U;
#line 433
  goto switch_break;
  case_2: /* CIL Label */ 
#line 436
  ((bus_params_t___23 *)bus___0->params)->slave = 5U;
#line 437
  ((bus_params_t___23 *)bus___0->params)->addr_mask = 4294967292U;
#line 438
  goto switch_break;
  case_3: /* CIL Label */ 
#line 441
  ((bus_params_t___23 *)bus___0->params)->addr_mask = 4294967295U;
#line 442
  ((bus_params_t___23 *)bus___0->params)->rwcs_rd = 2147483648U | (unsigned int )(1 << 2);
#line 443
  ((bus_params_t___23 *)bus___0->params)->rwcs_wr = (2147483648U | (unsigned int )(1 << 2)) | 1073741824U;
#line 444
  goto switch_break;
  case_4: /* CIL Label */ 
#line 447
  ((bus_params_t___23 *)bus___0->params)->addr_mask = 4294967294U;
#line 448
  ((bus_params_t___23 *)bus___0->params)->rwcs_rd = (2147483648U | (unsigned int )(1 << 2)) | 134217728U;
#line 449
  ((bus_params_t___23 *)bus___0->params)->rwcs_wr = ((2147483648U | (unsigned int )(1 << 2)) | 1073741824U) | 134217728U;
#line 450
  goto switch_break;
  case_5: /* CIL Label */ 
#line 453
  ((bus_params_t___23 *)bus___0->params)->addr_mask = 4294967292U;
#line 454
  ((bus_params_t___23 *)bus___0->params)->rwcs_rd = (2147483648U | (unsigned int )(1 << 2)) | 268435456U;
#line 455
  ((bus_params_t___23 *)bus___0->params)->rwcs_wr = ((2147483648U | (unsigned int )(1 << 2)) | 1073741824U) | 268435456U;
#line 456
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 458
  return;
}
}
#line 460 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static int check_instruction(part_t *part , char const   *instr ) 
{ 
  int ret ;
  instruction *tmp ;
  char *tmp___0 ;

  {
  {
#line 465
  tmp = part_find_instruction(part, instr);
#line 465
  ret = (unsigned long )tmp == (unsigned long )((void *)0);
  }
#line 466
  if (ret) {
    {
#line 467
    tmp___0 = gettext("%s(%d): error, instruction %s not found\n");
#line 467
    printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c",
           467, instr);
    }
  }
#line 469
  return (ret);
}
}
#line 476 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static bus_t *avr32_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char *param ;
  unsigned int mode ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;

  {
#line 484
  part = *((chain->parts)->parts + chain->active_part);
#line 486
  param = *(cmd_params___0 + 2);
#line 487
  if (! param) {
    {
#line 489
    tmp = gettext("%s(%d): error, no bus mode specified\n");
#line 489
    printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c",
           489);
    }
#line 490
    return ((bus_t *)((void *)0));
  }
  {
#line 493
  tmp___6 = strcasecmp("OCD", (char const   *)param);
  }
#line 493
  if (tmp___6) {
    {
#line 497
    tmp___5 = strcasecmp("HSBC", (char const   *)param);
    }
#line 497
    if (tmp___5) {
      {
#line 501
      tmp___4 = strcasecmp("HSBU", (char const   *)param);
      }
#line 501
      if (tmp___4) {
        {
#line 505
        tmp___3 = strcasecmp("x8", (char const   *)param);
        }
#line 505
        if (tmp___3) {
          {
#line 509
          tmp___2 = strcasecmp("x16", (char const   *)param);
          }
#line 509
          if (tmp___2) {
            {
#line 513
            tmp___1 = strcasecmp("x32", (char const   *)param);
            }
#line 513
            if (tmp___1) {
              {
#line 519
              tmp___0 = gettext("%s(%d): error, invalid bus mode: %s\n");
#line 519
              printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c",
                     519, param);
              }
#line 520
              return ((bus_t *)((void *)0));
            } else {
#line 515
              mode = 5U;
            }
          } else {
#line 511
            mode = 4U;
          }
        } else {
#line 507
          mode = 3U;
        }
      } else {
#line 503
        mode = 2U;
      }
    } else {
#line 499
      mode = 1U;
    }
  } else {
#line 495
    mode = 0U;
  }
  {
#line 527
  if (mode == 2U) {
#line 527
    goto case_2;
  }
#line 527
  if (mode == 1U) {
#line 527
    goto case_2;
  }
#line 527
  if (mode == 0U) {
#line 527
    goto case_2;
  }
#line 533
  if (mode == 5U) {
#line 533
    goto case_5;
  }
#line 533
  if (mode == 4U) {
#line 533
    goto case_5;
  }
#line 533
  if (mode == 3U) {
#line 533
    goto case_5;
  }
#line 523
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 528
  tmp___7 = check_instruction(part, "MEMORY_WORD_ACCESS");
  }
#line 528
  if (tmp___7) {
#line 529
    return ((bus_t *)((void *)0));
  }
#line 530
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 534
  tmp___8 = check_instruction(part, "NEXUS_ACCESS");
  }
#line 534
  if (tmp___8) {
#line 535
    return ((bus_t *)((void *)0));
  }
#line 536
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 539
  tmp___9 = calloc((size_t )1, sizeof(bus_t ));
#line 539
  bus___0 = (bus_t *)tmp___9;
  }
#line 540
  if (! bus___0) {
#line 541
    return ((bus_t *)((void *)0));
  }
  {
#line 543
  bus___0->driver = driver;
#line 544
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___23 ));
  }
#line 545
  if (! bus___0->params) {
    {
#line 547
    free((void *)bus___0);
    }
#line 548
    return ((bus_t *)((void *)0));
  }
  {
#line 551
  avr32_bus_setup(bus___0, chain, part, mode);
  }
#line 553
  return (bus___0);
}
}
#line 560 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void avr32_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 565
  i = 0;
  {
#line 565
  while (1) {
    while_continue: /* CIL Label */ ;
#line 565
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 565
      goto while_break;
    }
#line 566
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 567
      goto while_break;
    }
#line 565
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 569
  tmp = gettext("AVR32 multi-mode bus driver (JTAG part No. %d)\n");
#line 569
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 570
  return;
}
}
#line 576 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void avr32_bus_prepare(bus_t *bus___0 ) 
{ 


  {
#line 579
  if (! bus___0->initialized) {
    {
#line 580
    (*((bus___0->driver)->init))(bus___0);
    }
  }
#line 581
  return;
}
}
#line 587 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static int avr32_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 


  {
  {
#line 592
  if (((bus_params_t___23 *)bus___0->params)->mode == 1U) {
#line 592
    goto case_1;
  }
#line 598
  if (((bus_params_t___23 *)bus___0->params)->mode == 2U) {
#line 598
    goto case_2;
  }
#line 604
  if (((bus_params_t___23 *)bus___0->params)->mode == 3U) {
#line 604
    goto case_3;
  }
#line 610
  if (((bus_params_t___23 *)bus___0->params)->mode == 4U) {
#line 610
    goto case_4;
  }
#line 616
  if (((bus_params_t___23 *)bus___0->params)->mode == 5U) {
#line 616
    goto case_5;
  }
#line 622
  if (((bus_params_t___23 *)bus___0->params)->mode == 0U) {
#line 622
    goto case_0;
  }
#line 632
  goto switch_default;
  case_1: /* CIL Label */ 
#line 593
  area->description = "HSB memory space, cached";
#line 594
  area->start = 0U;
#line 595
  area->length = 4294967296UL;
#line 596
  area->width = 32U;
#line 597
  goto switch_break;
  case_2: /* CIL Label */ 
#line 599
  area->description = "HSB memory space, uncached";
#line 600
  area->start = 0U;
#line 601
  area->length = 4294967296UL;
#line 602
  area->width = 32U;
#line 603
  goto switch_break;
  case_3: /* CIL Label */ 
#line 605
  area->description = "HSB memory space, uncached";
#line 606
  area->start = 0U;
#line 607
  area->length = 4294967296UL;
#line 608
  area->width = 8U;
#line 609
  goto switch_break;
  case_4: /* CIL Label */ 
#line 611
  area->description = "HSB memory space, uncached";
#line 612
  area->start = 0U;
#line 613
  area->length = 4294967296UL;
#line 614
  area->width = 16U;
#line 615
  goto switch_break;
  case_5: /* CIL Label */ 
#line 617
  area->description = "HSB memory space, uncached";
#line 618
  area->start = 0U;
#line 619
  area->length = 4294967296UL;
#line 620
  area->width = 32U;
#line 621
  goto switch_break;
  case_0: /* CIL Label */ 
#line 623
  if ((unsigned long )addr < 4096UL) {
#line 625
    area->description = "OCD registers";
#line 626
    area->start = 0U;
#line 627
    area->length = 4096UL;
#line 628
    area->width = 32U;
#line 629
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
#line 633
  area->description = (char const   *)((void *)0);
#line 634
  area->length = 4294967296UL;
#line 635
  area->width = 0U;
#line 636
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 639
  return (0);
}
}
#line 646 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void avr32_bus_read_start(bus_t *bus___0 , uint32_t addr ) 
{ 


  {
#line 649
  addr &= ((bus_params_t___23 *)bus___0->params)->addr_mask;
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 651
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 657
  if (((bus_params_t___23 *)bus___0->params)->mode == 2U) {
#line 657
    goto case_2;
  }
#line 657
  if (((bus_params_t___23 *)bus___0->params)->mode == 1U) {
#line 657
    goto case_2;
  }
#line 657
  if (((bus_params_t___23 *)bus___0->params)->mode == 0U) {
#line 657
    goto case_2;
  }
#line 665
  if (((bus_params_t___23 *)bus___0->params)->mode == 5U) {
#line 665
    goto case_5;
  }
#line 665
  if (((bus_params_t___23 *)bus___0->params)->mode == 4U) {
#line 665
    goto case_5;
  }
#line 665
  if (((bus_params_t___23 *)bus___0->params)->mode == 3U) {
#line 665
    goto case_5;
  }
#line 653
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 658
  part_set_instruction(bus___0->part, "MEMORY_WORD_ACCESS");
#line 659
  mwa_scan_in_instr(bus___0);
#line 660
  mwa_scan_in_addr(bus___0, ((bus_params_t___23 *)bus___0->params)->slave, addr, 1);
  }
#line 661
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 666
  part_set_instruction(bus___0->part, "NEXUS_ACCESS");
#line 667
  nexus_access_start(bus___0);
#line 668
  nexus_memacc_set_addr(bus___0, addr, ((bus_params_t___23 *)bus___0->params)->rwcs_rd);
  }
#line 669
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 671
  return;
}
}
#line 677 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static uint32_t avr32_bus_read_end(bus_t *bus___0 ) 
{ 
  uint32_t data ;

  {
  {
#line 686
  if (((bus_params_t___23 *)bus___0->params)->mode == 2U) {
#line 686
    goto case_2;
  }
#line 686
  if (((bus_params_t___23 *)bus___0->params)->mode == 1U) {
#line 686
    goto case_2;
  }
#line 686
  if (((bus_params_t___23 *)bus___0->params)->mode == 0U) {
#line 686
    goto case_2;
  }
#line 691
  if (((bus_params_t___23 *)bus___0->params)->mode == 5U) {
#line 691
    goto case_5;
  }
#line 691
  if (((bus_params_t___23 *)bus___0->params)->mode == 4U) {
#line 691
    goto case_5;
  }
#line 691
  if (((bus_params_t___23 *)bus___0->params)->mode == 3U) {
#line 691
    goto case_5;
  }
#line 682
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 687
  mwa_scan_out_data(bus___0, & data);
  }
#line 688
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 692
  nexus_memacc_read(bus___0, & data);
#line 693
  nexus_access_end(bus___0);
  }
#line 694
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 697
  return (data);
}
}
#line 704 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static uint32_t avr32_bus_read_next(bus_t *bus___0 , uint32_t addr ) 
{ 
  uint32_t data ;

  {
#line 709
  addr &= ((bus_params_t___23 *)bus___0->params)->addr_mask;
  {
#line 715
  if (((bus_params_t___23 *)bus___0->params)->mode == 2U) {
#line 715
    goto case_2;
  }
#line 715
  if (((bus_params_t___23 *)bus___0->params)->mode == 1U) {
#line 715
    goto case_2;
  }
#line 715
  if (((bus_params_t___23 *)bus___0->params)->mode == 0U) {
#line 715
    goto case_2;
  }
#line 721
  if (((bus_params_t___23 *)bus___0->params)->mode == 5U) {
#line 721
    goto case_5;
  }
#line 721
  if (((bus_params_t___23 *)bus___0->params)->mode == 4U) {
#line 721
    goto case_5;
  }
#line 721
  if (((bus_params_t___23 *)bus___0->params)->mode == 3U) {
#line 721
    goto case_5;
  }
#line 711
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 716
  data = avr32_bus_read_end(bus___0);
#line 717
  avr32_bus_read_start(bus___0, addr);
  }
#line 718
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 722
  nexus_memacc_read(bus___0, & data);
#line 723
  nexus_memacc_set_addr(bus___0, addr, ((bus_params_t___23 *)bus___0->params)->rwcs_rd);
  }
#line 724
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 727
  return (data);
}
}
#line 734 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
static void avr32_bus_write(bus_t *bus___0 , uint32_t addr , uint32_t data ) 
{ 


  {
#line 737
  addr &= ((bus_params_t___23 *)bus___0->params)->addr_mask;
  {
#line 743
  if (((bus_params_t___23 *)bus___0->params)->mode == 2U) {
#line 743
    goto case_2;
  }
#line 743
  if (((bus_params_t___23 *)bus___0->params)->mode == 1U) {
#line 743
    goto case_2;
  }
#line 743
  if (((bus_params_t___23 *)bus___0->params)->mode == 0U) {
#line 743
    goto case_2;
  }
#line 749
  if (((bus_params_t___23 *)bus___0->params)->mode == 5U) {
#line 749
    goto case_5;
  }
#line 749
  if (((bus_params_t___23 *)bus___0->params)->mode == 4U) {
#line 749
    goto case_5;
  }
#line 749
  if (((bus_params_t___23 *)bus___0->params)->mode == 3U) {
#line 749
    goto case_5;
  }
#line 739
  goto switch_break;
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 744
  part_set_instruction(bus___0->part, "MEMORY_WORD_ACCESS");
#line 745
  mwa_write_word(bus___0, ((bus_params_t___23 *)bus___0->params)->slave, addr, data);
  }
#line 746
  goto switch_break;
  case_5: /* CIL Label */ 
  case_4: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 750
  part_set_instruction(bus___0->part, "NEXUS_ACCESS");
#line 751
  nexus_access_start(bus___0);
#line 752
  nexus_memacc_write(bus___0, addr, data, ((bus_params_t___23 *)bus___0->params)->rwcs_wr);
#line 753
  nexus_access_end(bus___0);
  }
#line 754
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 756
  return;
}
}
#line 758 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/avr32.c"
struct bus_driver  const  avr32_bus_driver  = 
#line 758
     {"avr32", "Atmel AVR32 multi-mode bus driver, requires <mode> parameter\n           valid <mode> parameters:\n               x8:   8 bit bus for the uncached HSB area, via OCD registers\n               x16:  16 bit bus for the uncached HSB area, via OCD registers\n               x32:  32 bit bus for the uncached HSB area, via OCD registers\n               OCD : 32 bit bus for the OCD registers\n               HSBC: 32 bit bus for the cached HSB area, via SAB\n               HSBU: 32 bit bus for the uncached HSB area, via SAB",
    & avr32_bus_new, & generic_bus_free, & avr32_bus_printinfo, & avr32_bus_prepare,
    & avr32_bus_area, & avr32_bus_read_start, & avr32_bus_read_next, & avr32_bus_read_end,
    & generic_bus_read, & avr32_bus_write, & generic_bus_no_init};
#line 62 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static bus_t *au1500_bus_new(chain_t *chain , bus_driver_t const   *driver , char **cmd_params___0 ) 
{ 
  bus_t *bus___0 ;
  part_t *part ;
  char buff[10] ;
  int i ;
  int failed ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 68
  failed = 0;
#line 70
  tmp = calloc((size_t )1, sizeof(bus_t ));
#line 70
  bus___0 = (bus_t *)tmp;
  }
#line 71
  if (! bus___0) {
#line 72
    return ((bus_t *)((void *)0));
  }
  {
#line 74
  bus___0->driver = driver;
#line 75
  bus___0->params = calloc((size_t )1, sizeof(bus_params_t___24 ));
  }
#line 76
  if (! bus___0->params) {
    {
#line 77
    free((void *)bus___0);
    }
#line 78
    return ((bus_t *)((void *)0));
  }
#line 81
  bus___0->chain = chain;
#line 82
  part = *((chain->parts)->parts + chain->active_part);
#line 82
  bus___0->part = part;
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < 32)) {
#line 84
      goto while_break;
    }
    {
#line 85
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RAD%d",
            i);
#line 86
    tmp___0 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->rad[i],
                                     buff);
#line 86
    failed |= tmp___0;
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! (i < 4)) {
#line 89
      goto while_break___0;
    }
    {
#line 90
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RCE_N%d",
            i);
#line 91
    tmp___1 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->nrcs[i],
                                     buff);
#line 91
    failed |= tmp___1;
#line 89
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 95
  tmp___2 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->nrwe,
                                   (char *)"RWE_N");
#line 95
  failed |= tmp___2;
#line 97
  tmp___3 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->nroe,
                                   (char *)"ROE_N");
#line 97
  failed |= tmp___3;
#line 99
  i = 0;
  }
  {
#line 99
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 99
    if (! (i < 32)) {
#line 99
      goto while_break___1;
    }
    {
#line 100
    sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"RD%d",
            i);
#line 101
    tmp___4 = generic_bus_attach_sig(part, & ((bus_params_t___24 *)bus___0->params)->rd[i],
                                     buff);
#line 101
    failed |= tmp___4;
#line 99
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 104
  if (failed) {
    {
#line 105
    free(bus___0->params);
#line 106
    free((void *)bus___0);
    }
#line 107
    return ((bus_t *)((void *)0));
  }
#line 110
  return (bus___0);
}
}
#line 118 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static void au1500_bus_printinfo(bus_t *bus___0 ) 
{ 
  int i ;
  char *tmp ;

  {
#line 123
  i = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! (i < ((bus___0->chain)->parts)->len)) {
#line 123
      goto while_break;
    }
#line 124
    if ((unsigned long )bus___0->part == (unsigned long )*(((bus___0->chain)->parts)->parts + i)) {
#line 125
      goto while_break;
    }
#line 123
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 126
  tmp = gettext("AU1500 compatible bus driver via BSR (JTAG part No. %d)\n");
#line 126
  printf((char const   */* __restrict  */)tmp, i);
  }
#line 127
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static int au1500_bus_area(bus_t *bus___0 , uint32_t addr , bus_area_t *area ) 
{ 
  signal_t *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 136
  area->description = (char const   *)((void *)0);
#line 137
  area->start = 0U;
#line 138
  area->length = 4294967296UL;
#line 140
  tmp___1 = part_find_signal(bus___0->part, "ROMSIZ");
#line 140
  tmp___2 = part_get_signal(bus___0->part, tmp___1);
  }
#line 140
  if (tmp___2) {
#line 140
    area->width = 16U;
  } else {
#line 140
    area->width = 32U;
  }
#line 143
  return (0);
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static void setup_address___25(bus_t *bus___0 , uint32_t a ) 
{ 
  int i ;
  part_t *p ;

  {
#line 151
  p = bus___0->part;
#line 153
  i = 0;
  {
#line 153
  while (1) {
    while_continue: /* CIL Label */ ;
#line 153
    if (! (i < 32)) {
#line 153
      goto while_break;
    }
    {
#line 154
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->rad[i], 1, (int )((a >> i) & 1U));
#line 153
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  return;
}
}
#line 157 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static void set_data_in___24(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 161
  p = bus___0->part;
#line 164
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 166
  i = 0;
  }
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! ((unsigned int )i < area.width)) {
#line 166
      goto while_break;
    }
    {
#line 167
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->rd[i], 0, 0);
#line 166
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 169
  return;
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static uint32_t get_data_out(bus_t *bus___0 ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;
  uint32_t d ;
  int tmp ;

  {
  {
#line 175
  p = bus___0->part;
#line 177
  d = (uint32_t )0;
#line 179
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((unsigned int )i < area.width)) {
#line 181
      goto while_break;
    }
    {
#line 182
    tmp = part_get_signal(p, ((bus_params_t___24 *)bus___0->params)->rd[i]);
#line 182
    d |= (uint32_t )(tmp << i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (d);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static void setup_data___25(bus_t *bus___0 , uint32_t d ) 
{ 
  int i ;
  part_t *p ;
  bus_area_t area ;

  {
  {
#line 191
  p = bus___0->part;
#line 194
  au1500_bus_area(bus___0, (uint32_t )0, & area);
#line 196
  i = 0;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! ((unsigned int )i < area.width)) {
#line 196
      goto while_break;
    }
    {
#line 197
    part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->rd[i], 1, (int )((d >> i) & 1U));
#line 196
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  return;
}
}
#line 204 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static void au1500_bus_read_start(bus_t *bus___0 , uint32_t adr ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 207
  p = bus___0->part;
#line 208
  chain = bus___0->chain;
#line 210
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[0], 1, 0);
#line 211
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[1], 1, 1);
#line 212
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[2], 1, 1);
#line 213
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[3], 1, 1);
#line 214
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrwe, 1, 1);
#line 215
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nroe, 1, 0);
#line 217
  setup_address___25(bus___0, adr);
#line 218
  set_data_in___24(bus___0);
#line 220
  chain_shift_data_registers(chain, 0);
  }
#line 221
  return;
}
}
#line 227 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static uint32_t au1500_bus_read_next(bus_t *bus___0 , uint32_t adr ) 
{ 
  chain_t *chain ;
  uint32_t tmp ;

  {
  {
#line 230
  chain = bus___0->chain;
#line 232
  setup_address___25(bus___0, adr);
#line 233
  chain_shift_data_registers(chain, 1);
#line 235
  tmp = get_data_out(bus___0);
  }
#line 235
  return (tmp);
}
}
#line 242 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static uint32_t au1500_bus_read_end(bus_t *bus___0 ) 
{ 
  part_t *p ;
  chain_t *chain ;
  uint32_t tmp ;

  {
  {
#line 245
  p = bus___0->part;
#line 246
  chain = bus___0->chain;
#line 248
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[0], 1, 1);
#line 249
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[1], 1, 1);
#line 250
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[2], 1, 1);
#line 251
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[3], 1, 1);
#line 252
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrwe, 1, 1);
#line 253
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nroe, 1, 1);
#line 255
  chain_shift_data_registers(chain, 1);
#line 257
  tmp = get_data_out(bus___0);
  }
#line 257
  return (tmp);
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
static void au1500_bus_write(bus_t *bus___0 , uint32_t adr , uint32_t data ) 
{ 
  part_t *p ;
  chain_t *chain ;

  {
  {
#line 267
  p = bus___0->part;
#line 268
  chain = bus___0->chain;
#line 270
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[0], 1, 0);
#line 271
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[1], 1, 1);
#line 272
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[2], 1, 1);
#line 273
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[3], 1, 1);
#line 274
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrwe, 1, 1);
#line 275
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nroe, 1, 1);
#line 277
  setup_address___25(bus___0, adr);
#line 278
  setup_data___25(bus___0, data);
#line 280
  chain_shift_data_registers(chain, 0);
#line 282
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrwe, 1, 0);
#line 283
  chain_shift_data_registers(chain, 0);
#line 285
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrwe, 1, 1);
#line 286
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nroe, 1, 1);
#line 287
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[0], 1, 1);
#line 288
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[1], 1, 1);
#line 289
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[2], 1, 1);
#line 290
  part_set_signal(p, ((bus_params_t___24 *)bus___0->params)->nrcs[3], 1, 1);
#line 292
  chain_shift_data_registers(chain, 0);
  }
#line 293
  return;
}
}
#line 295 "/home/khheo/project/benchmark/urjtag-0.9/src/bus/au1500.c"
struct bus_driver  const  au1500_bus  = 
#line 295
     {"au1500", "AU1500 BUS Driver via BSR", & au1500_bus_new, & generic_bus_free, & au1500_bus_printinfo,
    & generic_bus_prepare_extest, & au1500_bus_area, & au1500_bus_read_start, & au1500_bus_read_next,
    & au1500_bus_read_end, & generic_bus_read, & au1500_bus_write, & generic_bus_no_init};
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
static struct amd_flash_info  const  table[21]  = 
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (uint8_t const   )1, (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536,
                                                               (uint32_t )31}, {(uint32_t )2031616,
                                                                                (uint32_t )32768,
                                                                                (uint32_t )1},
                                                              {(uint32_t )2064384,
                                                               (uint32_t )8192, (uint32_t )2},
                                                              {(uint32_t )2080768,
                                                               (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8918, "AMD AM29F800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8900, "ST M29W160DT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )48},
                                         {(uint32_t )3145728, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )4128768, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )1,
      (int const   )8830, "AMD AM29BDS643D", (long const   )8388608, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )96},
                                         {(uint32_t )6291456, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )8323072, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )31,
      (int const   )192, "Atmel AT49xV16x", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )8192, (uint32_t )8},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )7},
                                         {(uint32_t )458752, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )491520, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )507904, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (uint8_t const   )0,
      (int const   )1, (int const   )1, {{(uint32_t )0, (uint32_t )65536, (uint32_t )8}}}};
#line 368 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
int jedec_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int manid_as[2] ;
  int devid_as[2] ;
  int manid ;
  int devid ;
  int ba ;
  int bw ;
  int i ;
  int j ;
  cfi_query_structure_t *cfi ;
  bus_area_t area ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 374
  manid = 0;
#line 374
  devid = 0;
#line 380
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 380
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 381
  if (! *cfi_array___0) {
#line 382
    return (-2);
  }
  {
#line 384
  (*cfi_array___0)->bus = bus___0;
#line 385
  (*cfi_array___0)->address = adr;
#line 386
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 386
  if (tmp___0 != 0) {
#line 387
    return (-8);
  }
#line 388
  bw = (int )area.width;
#line 389
  if (bw != 8) {
#line 389
    if (bw != 16) {
#line 389
      if (bw != 32) {
#line 390
        return (-3);
      }
    }
  }
  {
#line 391
  ba = bw / 8;
#line 391
  (*cfi_array___0)->bus_width = ba;
#line 393
  tmp___1 = calloc((size_t )1, sizeof(cfi_chip_t *));
#line 393
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 394
  if (! (*cfi_array___0)->cfi_chips) {
#line 395
    return (-2);
  }
  {
#line 397
  tmp___2 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 397
  *((*cfi_array___0)->cfi_chips + 0) = (cfi_chip_t *)tmp___2;
  }
#line 398
  if (! *((*cfi_array___0)->cfi_chips + 0)) {
#line 399
    return (-2);
  }
  {
#line 402
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 403
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )170);
#line 404
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )85);
#line 405
  (*((bus___0->driver)->write))(bus___0, adr + 2730U, (uint32_t )144);
#line 407
  tmp___3 = (*((bus___0->driver)->read))(bus___0, adr);
#line 407
  manid_as[0] = (int )tmp___3;
#line 408
  tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + 2U);
#line 408
  devid_as[0] = (int )tmp___4;
#line 409
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 412
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 413
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 414
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 415
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 417
  tmp___5 = (*((bus___0->driver)->read))(bus___0, adr);
#line 417
  manid_as[1] = (int )tmp___5;
#line 418
  tmp___6 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 418
  devid_as[1] = (int )tmp___6;
#line 419
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 421
  i = 0;
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! ((unsigned long )i < sizeof(table) / sizeof(struct amd_flash_info ))) {
#line 421
      goto while_break;
    }
#line 424
    manid = manid_as[table[i].as_method];
#line 425
    devid = devid_as[table[i].as_method];
#line 426
    if (manid == (int )table[i].mfr_id) {
#line 426
      if (devid == (int )table[i].dev_id) {
#line 426
        goto while_break;
      }
    }
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"dev ID=%04x   man ID=%04x\n",
          devid, manid);
  }
#line 430
  if ((unsigned long )i == sizeof(table) / sizeof(struct amd_flash_info )) {
#line 431
    return (-4);
  }
#line 433
  cfi = & (*((*cfi_array___0)->cfi_chips + 0))->cfi;
#line 435
  cfi->identification_string.pri_id_code = (uint16_t )2;
#line 436
  cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 437
  cfi->identification_string.alt_id_code = (uint16_t )0;
#line 438
  cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 440
  cfi->device_geometry.device_size = (uint32_t )table[i].size;
#line 442
  cfi->device_geometry.device_interface = (uint16_t )table[i].interface_width;
  {
#line 444
  if ((int const   )table[i].interface_width == 0) {
#line 444
    goto case_0;
  }
#line 447
  if ((int const   )table[i].interface_width == 1) {
#line 447
    goto case_1;
  }
#line 450
  if ((int const   )table[i].interface_width == 2) {
#line 450
    goto case_2;
  }
#line 455
  if ((int const   )table[i].interface_width == 3) {
#line 455
    goto case_3;
  }
#line 458
  if ((int const   )table[i].interface_width == 4) {
#line 458
    goto case_4;
  }
#line 463
  goto switch_default;
  case_0: /* CIL Label */ 
#line 445
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 446
  goto switch_break;
  case_1: /* CIL Label */ 
#line 448
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 449
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 451
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X8_X16", "CFI_INTERFACE_X16");
#line 452
  (*((*cfi_array___0)->cfi_chips + 0))->width = 2;
#line 453
  cfi->device_geometry.device_interface = (uint16_t )1;
  }
#line 454
  goto switch_break;
  case_3: /* CIL Label */ 
#line 456
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 457
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 459
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Unsupported interface geometry %s, falling back to %s\n",
          "CFI_INTERFACE_X16_X32", "CFI_INTERFACE_X32");
#line 460
  (*((*cfi_array___0)->cfi_chips + 0))->width = 4;
#line 461
  cfi->device_geometry.device_interface = (uint16_t )3;
  }
#line 462
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 465
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Unsupported interface geometry %d, bailing out\n",
          (int const   )table[i].interface_width);
#line 466
  (*((*cfi_array___0)->cfi_chips + 0))->width = 1;
#line 467
  cfi->device_geometry.device_interface = (uint16_t )0;
  }
#line 468
  return (-5);
#line 469
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 472
  cfi->device_geometry.number_of_erase_regions = (uint8_t )table[i].numeraseregions;
#line 474
  tmp___7 = malloc((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t ));
#line 474
  cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___7;
  }
#line 476
  if (! cfi->device_geometry.erase_block_regions) {
#line 477
    return (-2);
  }
#line 479
  j = 0;
  {
#line 479
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 479
    if (! (j < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 479
      goto while_break___0;
    }
#line 480
    (cfi->device_geometry.erase_block_regions + j)->erase_block_size = (uint32_t )table[i].regions[j].erasesize;
#line 482
    (cfi->device_geometry.erase_block_regions + j)->number_of_erase_blocks = (uint32_t )table[i].regions[j].numblocks;
#line 479
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 486
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found %s flash,  size = %li bytes.\n",
          table[i].name, table[i].size);
  }
#line 488
  return (0);
}
}
#line 48 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 49
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 51
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 61
  if (tmp != 0) {
#line 62
    return (0);
  }
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 64
    if (area.width == 32U) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 64
  return (tmp___0);
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_autodetect(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 76
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 76
  if (tmp != 0) {
#line 77
    return (0);
  }
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 79
    if (area.width == 16U) {
#line 79
      tmp___0 = 1;
    } else {
#line 79
      tmp___0 = 0;
    }
  } else {
#line 79
    tmp___0 = 0;
  }
#line 79
  return (tmp___0);
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 91
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 91
  if (tmp != 0) {
#line 92
    return (0);
  }
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 94
    goto _L;
  } else
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 94
    goto _L;
  } else
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 94
    goto _L;
  } else
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 94
    if (area.width == 8U) {
#line 94
      tmp___0 = 1;
    } else {
#line 94
      tmp___0 = 0;
    }
  } else {
#line 94
    tmp___0 = 0;
  }
#line 94
  return (tmp___0);
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void _intel_flash_print_info(cfi_array_t *cfi_array___0 , int o ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  uint32_t tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 105
  bus___0 = cfi_array___0->bus;
#line 107
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 107
  mid = tmp & 255U;
  }
  {
#line 109
  if (mid == 137U) {
#line 109
    goto case_137;
  }
#line 112
  if (mid == 28U) {
#line 112
    goto case_28;
  }
#line 115
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 110
  tmp___0 = gettext("Manufacturer: %s\n");
#line 110
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 111
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 113
  tmp___1 = gettext("Manufacturer: %s\n");
#line 113
  printf((char const   */* __restrict  */)tmp___1, "Mitsubishi");
  }
#line 114
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 116
  tmp___2 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 116
  printf((char const   */* __restrict  */)tmp___2, mid);
  }
#line 117
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp___3 = gettext("Chip: ");
#line 120
  printf((char const   */* __restrict  */)tmp___3);
#line 121
  tmp___4 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 121
  cid = tmp___4 & 65535U;
  }
  {
#line 123
  if (cid == 22U) {
#line 123
    goto case_22;
  }
#line 126
  if (cid == 23U) {
#line 126
    goto case_23;
  }
#line 129
  if (cid == 24U) {
#line 129
    goto case_24;
  }
#line 132
  if (cid == 29U) {
#line 132
    goto case_29;
  }
#line 135
  if (cid == 34817U) {
#line 135
    goto case_34817;
  }
#line 138
  if (cid == 34818U) {
#line 138
    goto case_34818;
  }
#line 141
  if (cid == 34819U) {
#line 141
    goto case_34819;
  }
#line 144
  if (cid == 34821U) {
#line 144
    goto case_34821;
  }
#line 147
  if (cid == 34822U) {
#line 147
    goto case_34822;
  }
#line 150
  if (cid == 34823U) {
#line 150
    goto case_34823;
  }
#line 153
  if (cid == 34827U) {
#line 153
    goto case_34827;
  }
#line 156
  if (cid == 34828U) {
#line 156
    goto case_34828;
  }
#line 159
  if (cid == 34829U) {
#line 159
    goto case_34829;
  }
#line 162
  if (cid == 34830U) {
#line 162
    goto case_34830;
  }
#line 165
  if (cid == 34831U) {
#line 165
    goto case_34831;
  }
#line 168
  if (cid == 34832U) {
#line 168
    goto case_34832;
  }
#line 171
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 125
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 127
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 128
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 130
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 131
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 133
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 134
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 136
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 137
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 140
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 143
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 146
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 149
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 152
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 154
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 155
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 157
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 158
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 160
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 161
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 163
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 164
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 167
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 169
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 170
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 172
  tmp___5 = gettext("Unknown (0x%02X)!\n");
#line 172
  printf((char const   */* __restrict  */)tmp___5, cid);
  }
#line 173
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 177
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 178
  return;
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 183
  o = 1;
#line 184
  bus___0 = cfi_array___0->bus;
#line 190
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 193
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 195
  _intel_flash_print_info(cfi_array___0, o);
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_print_info32(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 201
  o = 2;
#line 202
  bus___0 = cfi_array___0->bus;
#line 207
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 210
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 212
  _intel_flash_print_info(cfi_array___0, o);
  }
#line 213
  return;
}
}
#line 215 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 219
  bus___0 = cfi_array___0->bus;
#line 221
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 222
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 223
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 225
    sr = (uint16_t )(tmp & 254U);
    }
#line 225
    if ((int )sr & (1 << 7)) {
#line 225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 228
    goto case_0;
  }
#line 230
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 230
    goto case_exp;
  }
#line 233
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 233
    goto case_exp___0;
  }
#line 236
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 236
    goto case_exp___1;
  }
#line 239
  goto switch_default;
  case_0: /* CIL Label */ 
#line 229
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 231
  tmp___0 = gettext("flash: invalid command seq\n");
#line 231
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 232
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 234
  tmp___1 = gettext("flash: low vpen\n");
#line 234
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 235
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 237
  tmp___2 = gettext("flash: block locked\n");
#line 237
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 238
  return (3);
  switch_default: /* CIL Label */ 
#line 240
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 243
  return (99);
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 250
  bus___0 = cfi_array___0->bus;
#line 252
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 253
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 254
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 256
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 256
    sr = (uint16_t )(tmp & 254U);
    }
#line 256
    if ((int )sr & (1 << 7)) {
#line 256
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if ((int )sr != 1 << 7) {
    {
#line 259
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 259
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 260
    return (99);
  } else {
#line 262
    return (0);
  }
}
}
#line 265 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 269
  bus___0 = cfi_array___0->bus;
#line 271
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 272
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 273
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 275
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 275
    sr = (uint16_t )(tmp & 254U);
    }
#line 275
    if ((int )sr & (1 << 7)) {
#line 275
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if ((int )sr != 1 << 7) {
    {
#line 278
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 278
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 279
    return (99);
  } else {
#line 281
    return (0);
  }
}
}
#line 284 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_erase_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 288
  bus___0 = cfi_array___0->bus;
#line 290
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 291
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 292
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 294
    sr = tmp & 16646398U;
    }
#line 294
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 294
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 297
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 298
    return (99);
  } else {
#line 300
    return (0);
  }
}
}
#line 303 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_unlock_block32(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 307
  bus___0 = cfi_array___0->bus;
#line 309
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 310
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 311
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 313
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 313
    sr = tmp & 16646398U;
    }
#line 313
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 313
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 316
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 317
    return (99);
  } else {
#line 319
    return (0);
  }
}
}
#line 322 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_program32(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 326
  bus___0 = cfi_array___0->bus;
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 329
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 330
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 332
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 332
    sr = tmp & 16646398U;
    }
#line 332
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 332
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 335
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 336
    return (99);
  } else {
#line 338
    return (0);
  }
}
}
#line 341 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_readarray32(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 345
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 346
  return;
}
}
#line 348 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_readarray(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 352
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 353
  return;
}
}
#line 355 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
flash_driver_t intel_32_flash_driver  = 
#line 355
     {4U, "Intel Standard Command Set", "supported: 28Fxxxx, 2 x 16 bit", & intel_flash_autodetect32,
    & intel_flash_print_info32, & intel_flash_erase_block32, & intel_flash_unlock_block32,
    & intel_flash_program32, & intel_flash_readarray32};
#line 367 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
flash_driver_t intel_16_flash_driver  = 
#line 367
     {2U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 16 bit", & intel_flash_autodetect,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 379 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
flash_driver_t intel_8_flash_driver  = 
#line 379
     {1U, "Intel Standard Command Set", "supported: 28Fxxxx, 1 x 8 bit", & intel_flash_autodetect8,
    & intel_flash_print_info, & intel_flash_erase_block, & intel_flash_unlock_block,
    & intel_flash_program, & intel_flash_readarray};
#line 684 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 83 "../../include/flash.h"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr ) ;
#line 84
void flashmsbin(bus_t *bus___0 , FILE *f ) ;
#line 88
flash_driver_t *flash_drivers[8] ;
#line 56 "../../include/jtag.h"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
flash_driver_t amd_32_flash_driver ;
#line 50
flash_driver_t amd_16_flash_driver ;
#line 51
flash_driver_t amd_8_flash_driver ;
#line 55
flash_driver_t amd_29xx040_flash_driver ;
#line 57 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
flash_driver_t *flash_drivers[8]  = 
#line 57
  {      & amd_32_flash_driver,      & amd_16_flash_driver,      & amd_8_flash_driver,      & intel_32_flash_driver, 
        & intel_16_flash_driver,      & intel_8_flash_driver,      & amd_29xx040_flash_driver,      (flash_driver_t *)((void *)0)};
#line 68
cfi_array_t *cfi_array ;
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
static flash_driver_t *flash_driver  =    (flash_driver_t *)((void *)0);
#line 71 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
static void set_flash_driver(void) 
{ 
  int i ;
  cfi_query_structure_t *cfi ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 77
  flash_driver = (flash_driver_t *)((void *)0);
#line 78
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
#line 79
    return;
  }
#line 80
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )flash_drivers[i] != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
    {
#line 83
    tmp = (*((flash_drivers[i])->autodetect))(cfi_array);
    }
#line 83
    if (tmp) {
      {
#line 84
      flash_driver = flash_drivers[i];
#line 85
      (*(flash_driver->print_info))(cfi_array);
      }
#line 86
      return;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___0 = gettext("unknown flash - vendor id: %d (0x%04x)\n");
#line 89
  printf((char const   */* __restrict  */)tmp___0, (int )cfi->identification_string.pri_id_code,
         (int )cfi->identification_string.pri_id_code);
#line 93
  tmp___1 = gettext("Flash not supported!\n");
#line 93
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
void flashmsbin(bus_t *bus___0 , FILE *f ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  char *tmp ;
  char sync[8] ;
  char *tmp___0 ;
  int tmp___1 ;
  uint32_t start ;
  uint32_t len ;
  int first ;
  int last ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  uint32_t a ;
  uint32_t l ;
  uint32_t c ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  uint32_t data ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  uint32_t a___0 ;
  uint32_t l___0 ;
  uint32_t c___0 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  uint32_t data___0 ;
  uint32_t readed ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
  {
#line 102
  set_flash_driver();
  }
#line 103
  if (! cfi_array) {
    {
#line 104
    tmp = gettext("no flash driver found\n");
#line 104
    printf((char const   */* __restrict  */)tmp);
    }
#line 105
    return;
  } else
#line 103
  if (! flash_driver) {
    {
#line 104
    tmp = gettext("no flash driver found\n");
#line 104
    printf((char const   */* __restrict  */)tmp);
    }
#line 105
    return;
  }
  {
#line 107
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 112
  fread((void */* __restrict  */)(& sync), sizeof(char ), (size_t )7, (FILE */* __restrict  */)f);
#line 113
  sync[7] = (char )'\000';
#line 114
  tmp___1 = strcmp("B000FF\n", (char const   *)(sync));
  }
#line 114
  if (tmp___1 != 0) {
    {
#line 115
    tmp___0 = gettext("Invalid sync sequence!\n");
#line 115
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 116
    return;
  }
  {
#line 126
  fread((void */* __restrict  */)(& start), sizeof(start), (size_t )1, (FILE */* __restrict  */)f);
#line 127
  fread((void */* __restrict  */)(& len), sizeof(len), (size_t )1, (FILE */* __restrict  */)f);
#line 128
  first = (int )(start / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
#line 129
  last = (int )(((start + len) - 1U) / ((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * 2U));
  }
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (first <= last)) {
#line 130
      goto while_break;
    }
    {
#line 131
    adr = ((uint32_t )first * (cfi->device_geometry.erase_block_regions + 0)->erase_block_size) * 2U;
#line 132
    (*(flash_driver->unlock_block))(cfi_array, adr);
#line 133
    tmp___2 = gettext("block %d unlocked\n");
#line 133
    printf((char const   */* __restrict  */)tmp___2, first);
#line 134
    tmp___3 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 134
    tmp___4 = gettext("erasing block %d: %d\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, first, tmp___3);
#line 130
    first ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  tmp___5 = gettext("program:\n");
#line 138
  printf((char const   */* __restrict  */)tmp___5);
  }
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 142
    fread((void */* __restrict  */)(& a), sizeof(a), (size_t )1, (FILE */* __restrict  */)f);
#line 143
    fread((void */* __restrict  */)(& l), sizeof(l), (size_t )1, (FILE */* __restrict  */)f);
#line 144
    fread((void */* __restrict  */)(& c), sizeof(c), (size_t )1, (FILE */* __restrict  */)f);
#line 145
    tmp___7 = feof(f);
    }
#line 145
    if (tmp___7) {
      {
#line 146
      tmp___6 = gettext("Error: premature end of file\n");
#line 146
      printf((char const   */* __restrict  */)tmp___6);
      }
#line 147
      return;
    }
    {
#line 149
    tmp___8 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 149
    printf((char const   */* __restrict  */)tmp___8, a, l, c);
    }
#line 150
    if (a == 0U) {
#line 150
      if (c == 0U) {
#line 151
        goto while_break___0;
      }
    }
#line 152
    if (l & 3U) {
      {
#line 153
      tmp___9 = gettext("Error: Invalid record length!\n");
#line 153
      printf((char const   */* __restrict  */)tmp___9);
      }
#line 154
      return;
    }
    {
#line 157
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 157
      if (! l) {
#line 157
        goto while_break___1;
      }
      {
#line 160
      tmp___10 = gettext("addr: 0x%08X");
#line 160
      printf((char const   */* __restrict  */)tmp___10, a);
#line 161
      printf((char const   */* __restrict  */)"\r");
#line 162
      fflush(stdout);
#line 163
      fread((void */* __restrict  */)(& data), sizeof(data), (size_t )1, (FILE */* __restrict  */)f);
#line 164
      tmp___12 = (*(flash_driver->program))(cfi_array, a, data);
      }
#line 164
      if (tmp___12) {
        {
#line 165
        tmp___11 = gettext("\nflash error\n");
#line 165
        printf((char const   */* __restrict  */)tmp___11);
        }
#line 166
        return;
      }
#line 168
      a += 4U;
#line 169
      l -= 4U;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 172
  printf((char const   */* __restrict  */)"\n");
#line 174
  (*(flash_driver->readarray))(cfi_array);
#line 176
  fseek(f, 15L, 0);
#line 177
  tmp___13 = gettext("verify:\n");
#line 177
  printf((char const   */* __restrict  */)tmp___13);
  }
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 182
    fread((void */* __restrict  */)(& a___0), sizeof(a___0), (size_t )1, (FILE */* __restrict  */)f);
#line 183
    fread((void */* __restrict  */)(& l___0), sizeof(l___0), (size_t )1, (FILE */* __restrict  */)f);
#line 184
    fread((void */* __restrict  */)(& c___0), sizeof(c___0), (size_t )1, (FILE */* __restrict  */)f);
#line 185
    tmp___15 = feof(f);
    }
#line 185
    if (tmp___15) {
      {
#line 186
      tmp___14 = gettext("Error: premature end of file\n");
#line 186
      printf((char const   */* __restrict  */)tmp___14);
      }
#line 187
      return;
    }
    {
#line 189
    tmp___16 = gettext("record: start = 0x%08X, len = 0x%08X, checksum = 0x%08X\n");
#line 189
    printf((char const   */* __restrict  */)tmp___16, a___0, l___0, c___0);
    }
#line 190
    if (a___0 == 0U) {
#line 190
      if (c___0 == 0U) {
#line 191
        goto while_break___2;
      }
    }
#line 192
    if (l___0 & 3U) {
      {
#line 193
      tmp___17 = gettext("Error: Invalid record length!\n");
#line 193
      printf((char const   */* __restrict  */)tmp___17);
      }
#line 194
      return;
    }
    {
#line 197
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 197
      if (! l___0) {
#line 197
        goto while_break___3;
      }
      {
#line 200
      tmp___18 = gettext("addr: 0x%08X");
#line 200
      printf((char const   */* __restrict  */)tmp___18, a___0);
#line 201
      printf((char const   */* __restrict  */)"\r");
#line 202
      fflush(stdout);
#line 203
      fread((void */* __restrict  */)(& data___0), sizeof(data___0), (size_t )1, (FILE */* __restrict  */)f);
#line 204
      readed = (*((bus___0->driver)->read))(bus___0, a___0);
      }
#line 205
      if (data___0 != readed) {
        {
#line 206
        tmp___19 = gettext("\nverify error: 0x%08X vs. 0x%08X at addr %08X\n");
#line 206
        printf((char const   */* __restrict  */)tmp___19, readed, data___0, a___0);
        }
#line 208
        return;
      }
#line 210
      a___0 += 4U;
#line 211
      l___0 -= 4U;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 215
  tmp___20 = gettext("\nDone.\n");
#line 215
  printf((char const   */* __restrict  */)tmp___20);
  }
#line 216
  return;
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
static int find_block(cfi_query_structure_t *cfi , int adr , int bus_width , int chip_width ,
                      int *bytes_until_next_block ) 
{ 
  int i ;
  int b ;
  int bb ;
  int region_blocks ;
  int flash_block_size ;
  int region_block_size ;
  int region_size ;
  int bir ;

  {
#line 222
  b = 0;
#line 223
  bb = 0;
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 225
      goto while_break;
    }
#line 226
    region_blocks = (int )(cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks;
#line 227
    flash_block_size = (int )(cfi->device_geometry.erase_block_regions + i)->erase_block_size;
#line 228
    region_block_size = (bus_width / chip_width) * flash_block_size;
#line 229
    region_size = region_blocks * region_block_size;
#line 231
    if (adr < bb + region_size) {
#line 233
      bir = (adr - bb) / region_block_size;
#line 234
      *bytes_until_next_block = (bb + (bir + 1) * region_block_size) - adr;
#line 235
      return (b + bir);
    }
#line 237
    b += region_blocks;
#line 238
    bb += region_size;
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (-1);
}
}
#line 243 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
void flashmem(bus_t *bus___0 , FILE *f , uint32_t addr ) 
{ 
  uint32_t adr ;
  cfi_query_structure_t *cfi ;
  int *erased ;
  int i ;
  int neb ;
  int bus_width ;
  int chip_width ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint32_t data ;
  uint8_t b[4096] ;
  int bc ;
  int bn ;
  int btr ;
  int block_no ;
  int tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int j ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  uint32_t data___0 ;
  uint32_t readed ;
  uint8_t b___0[4096] ;
  int bc___0 ;
  int bn___0 ;
  int btr___0 ;
  size_t tmp___14 ;
  int j___0 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;

  {
  {
#line 254
  set_flash_driver();
  }
#line 255
  if (! cfi_array) {
    {
#line 256
    tmp = gettext("no flash driver found\n");
#line 256
    printf((char const   */* __restrict  */)tmp);
    }
#line 257
    return;
  } else
#line 255
  if (! flash_driver) {
    {
#line 256
    tmp = gettext("no flash driver found\n");
#line 256
    printf((char const   */* __restrict  */)tmp);
    }
#line 257
    return;
  }
#line 259
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 261
  bus_width = cfi_array->bus_width;
#line 262
  chip_width = (*(cfi_array->cfi_chips + 0))->width;
#line 264
  i = 0;
#line 264
  neb = 0;
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 264
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 264
      goto while_break;
    }
#line 265
    neb = (int )((uint32_t )neb + (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 264
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  tmp___0 = malloc((unsigned long )neb * sizeof(*erased));
#line 267
  erased = (int *)tmp___0;
  }
#line 268
  if (! erased) {
    {
#line 269
    tmp___1 = gettext("Out of memory!\n");
#line 269
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 270
    return;
  }
#line 272
  i = 0;
  {
#line 272
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 272
    if (! (i < neb)) {
#line 272
      goto while_break___0;
    }
#line 273
    *(erased + i) = 0;
#line 272
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 275
  tmp___2 = gettext("program:\n");
#line 275
  printf((char const   */* __restrict  */)tmp___2);
#line 276
  adr = addr;
  }
  {
#line 277
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 277
    tmp___11 = feof(f);
    }
#line 277
    if (tmp___11) {
#line 277
      goto while_break___1;
    }
    {
#line 281
    bc = 0;
#line 281
    bn = 0;
#line 281
    btr = 4096;
#line 282
    tmp___3 = find_block(cfi, (int )(adr - cfi_array->address), bus_width, chip_width,
                         & btr);
#line 282
    block_no = tmp___3;
    }
#line 284
    if (btr > 4096) {
#line 284
      btr = 4096;
    }
    {
#line 285
    tmp___4 = fread((void */* __restrict  */)(b), (size_t )1, (size_t )btr, (FILE */* __restrict  */)f);
#line 285
    bn = (int )tmp___4;
    }
#line 287
    if (bn > 0) {
#line 287
      if (! *(erased + block_no)) {
        {
#line 288
        (*(flash_driver->unlock_block))(cfi_array, adr);
#line 289
        tmp___5 = gettext("\nblock %d unlocked\n");
#line 289
        printf((char const   */* __restrict  */)tmp___5, block_no);
#line 290
        tmp___6 = (*(flash_driver->erase_block))(cfi_array, adr);
#line 290
        tmp___7 = gettext("erasing block %d: %d\n");
#line 290
        printf((char const   */* __restrict  */)tmp___7, block_no, tmp___6);
#line 291
        *(erased + block_no) = 1;
        }
      }
    }
#line 294
    bc = 0;
    {
#line 294
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 294
      if (! (bc < bn)) {
#line 294
        goto while_break___2;
      }
#line 296
      if ((adr & 255U) == 0U) {
        {
#line 297
        tmp___8 = gettext("addr: 0x%08X");
#line 297
        printf((char const   */* __restrict  */)tmp___8, adr);
#line 298
        printf((char const   */* __restrict  */)"\r");
#line 299
        fflush(stdout);
        }
      }
#line 302
      data = (uint32_t )0;
#line 303
      j = 0;
      {
#line 303
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 303
        if (! ((unsigned int )j < flash_driver->bus_width)) {
#line 303
          goto while_break___3;
        }
#line 304
        if (big_endian) {
#line 305
          data = (data << 8) | (unsigned int )b[bc + j];
        } else {
#line 307
          data |= (unsigned int )((int )b[bc + j] << j * 8);
        }
#line 303
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 309
      tmp___10 = (*(flash_driver->program))(cfi_array, adr, data);
      }
#line 309
      if (tmp___10) {
        {
#line 310
        tmp___9 = gettext("\nflash error\n");
#line 310
        printf((char const   */* __restrict  */)tmp___9);
        }
#line 311
        return;
      }
#line 313
      adr += flash_driver->bus_width;
#line 294
      bc = (int )((unsigned int )bc + flash_driver->bus_width);
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 316
  tmp___12 = gettext("addr: 0x%08X\n");
#line 316
  printf((char const   */* __restrict  */)tmp___12, adr - flash_driver->bus_width);
#line 318
  (*(flash_driver->readarray))(cfi_array);
#line 320
  fseek(f, 0L, 0);
#line 321
  tmp___13 = gettext("verify:\n");
#line 321
  printf((char const   */* __restrict  */)tmp___13);
#line 322
  fflush(stdout);
#line 323
  adr = addr;
  }
  {
#line 324
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 324
    tmp___18 = feof(f);
    }
#line 324
    if (tmp___18) {
#line 324
      goto while_break___4;
    }
    {
#line 327
    bc___0 = 0;
#line 327
    bn___0 = 0;
#line 327
    btr___0 = 4096;
#line 329
    tmp___14 = fread((void */* __restrict  */)(b___0), (size_t )1, (size_t )btr___0,
                     (FILE */* __restrict  */)f);
#line 329
    bn___0 = (int )tmp___14;
#line 331
    bc___0 = 0;
    }
    {
#line 331
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 331
      if (! (bc___0 < bn___0)) {
#line 331
        goto while_break___5;
      }
#line 333
      if ((adr & 255U) == 0U) {
        {
#line 334
        tmp___15 = gettext("addr: 0x%08X");
#line 334
        printf((char const   */* __restrict  */)tmp___15, adr);
#line 335
        printf((char const   */* __restrict  */)"\r");
#line 336
        fflush(stdout);
        }
      }
#line 339
      data___0 = (uint32_t )0;
#line 340
      j___0 = 0;
      {
#line 340
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 340
        if (! ((unsigned int )j___0 < flash_driver->bus_width)) {
#line 340
          goto while_break___6;
        }
#line 341
        if (big_endian) {
#line 342
          data___0 = (data___0 << 8) | (unsigned int )b___0[bc___0 + j___0];
        } else {
#line 344
          data___0 |= (unsigned int )((int )b___0[bc___0 + j___0] << j___0 * 8);
        }
#line 340
        j___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 346
      readed = (*((bus___0->driver)->read))(bus___0, adr);
      }
#line 347
      if (data___0 != readed) {
        {
#line 348
        tmp___16 = gettext("addr: 0x%08X\n");
#line 348
        printf((char const   */* __restrict  */)tmp___16, adr);
#line 349
        tmp___17 = gettext("verify error:\nread: 0x%08X\nexpected: 0x%08X\n");
#line 349
        printf((char const   */* __restrict  */)tmp___17, readed, data___0);
        }
#line 350
        return;
      }
#line 352
      adr += flash_driver->bus_width;
#line 331
      bc___0 = (int )((unsigned int )bc___0 + flash_driver->bus_width);
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 355
  tmp___19 = gettext("addr: 0x%08X\nDone.\n");
#line 355
  printf((char const   */* __restrict  */)tmp___19, adr - flash_driver->bus_width);
#line 357
  free((void *)erased);
  }
#line 358
  return;
}
}
#line 360 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
void flasherase(bus_t *bus___0 , uint32_t addr , int number ) 
{ 
  cfi_query_structure_t *cfi ;
  int i ;
  int status ;
  char *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int addr_block ;
  int block_no ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 365
  status = 0;
#line 367
  set_flash_driver();
  }
#line 368
  if (! cfi_array) {
    {
#line 369
    tmp = gettext("no flash driver found\n");
#line 369
    printf((char const   */* __restrict  */)tmp);
    }
#line 370
    return;
  } else
#line 368
  if (! flash_driver) {
    {
#line 369
    tmp = gettext("no flash driver found\n");
#line 369
    printf((char const   */* __restrict  */)tmp);
    }
#line 370
    return;
  }
#line 372
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 374
  if (number > 1) {
#line 374
    tmp___0 = "s";
  } else {
#line 374
    tmp___0 = "";
  }
  {
#line 374
  tmp___1 = gettext("\nErasing %d Flash block%s from address 0x%x\n");
#line 374
  printf((char const   */* __restrict  */)tmp___1, number, tmp___0, addr);
#line 376
  i = 1;
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i <= number)) {
#line 376
      goto while_break;
    }
    {
#line 377
    addr_block = (int )(((cfi->device_geometry.erase_block_regions + 0)->erase_block_size * flash_driver->bus_width) / 2U);
#line 378
    block_no = (int )(addr / (uint32_t )addr_block);
#line 379
    tmp___2 = gettext("(%d%% Completed) FLASH Block %d : Unlocking ... ");
#line 379
    printf((char const   */* __restrict  */)tmp___2, (i * 100) / number, block_no);
#line 380
    fflush(stdout);
#line 381
    (*(flash_driver->unlock_block))(cfi_array, addr);
#line 382
    tmp___3 = gettext("Erasing ... ");
#line 382
    printf((char const   */* __restrict  */)tmp___3);
#line 383
    fflush(stdout);
#line 384
    status = (*(flash_driver->erase_block))(cfi_array, addr);
    }
#line 385
    if (status == 0) {
#line 386
      if (i == number) {
        {
#line 387
        printf((char const   */* __restrict  */)"\r");
#line 388
        tmp___4 = gettext("(100%% Completed) FLASH Block %d : Unlocking ... Erasing ... Ok.\n");
#line 388
        printf((char const   */* __restrict  */)tmp___4, block_no);
        }
      } else {
        {
#line 390
        tmp___5 = gettext("Ok.");
#line 390
        printf((char const   */* __restrict  */)tmp___5);
#line 391
        printf((char const   */* __restrict  */)"\r");
#line 392
        tmp___6 = gettext("%78s");
#line 392
        printf((char const   */* __restrict  */)tmp___6, "");
#line 393
        printf((char const   */* __restrict  */)"\r");
        }
      }
    } else {
      {
#line 397
      tmp___7 = gettext("ERROR.\n");
#line 397
      printf((char const   */* __restrict  */)tmp___7);
      }
    }
#line 398
    addr |= (unsigned int )(addr_block - 1);
#line 399
    addr ++;
#line 376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  if (status == 0) {
    {
#line 403
    tmp___8 = gettext("\nErasing Completed.\n");
#line 403
    printf((char const   */* __restrict  */)tmp___8);
    }
  } else {
    {
#line 405
    tmp___9 = gettext("\nErasing Failed.\n");
#line 405
    printf((char const   */* __restrict  */)tmp___9);
    }
  }
#line 410
  return;
}
}
#line 58 "../../include/flash.h"
void cfi_array_free(cfi_array_t *cfi_array___0 ) ;
#line 59
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 81
void detectflash(bus_t *bus___0 , uint32_t adr ) ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/detectflash.c"
cfi_array_t *cfi_array  =    (cfi_array_t *)((void *)0);
#line 47
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/detectflash.c"
void detectflash(bus_t *bus___0 , uint32_t adr ) 
{ 
  cfi_query_structure_t *cfi ;
  char const   *s ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  int i ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  amd_pri_extened_query_structure_t *pri_vendor_tbl ;
  uint8_t major_version ;
  uint8_t minor_version ;
  int i___0 ;
  char const   *required_or_not[2] ;
  char const   *supported_or_not[2] ;
  char const   *process_technology[6] ;
  char const   *process_technology_13[3] ;
  char const   *erase_suspend[3] ;
  char const   *sector_protect_scheme[8] ;
  char const   *page_mode_type[4] ;
  char const   *top_bottom[6] ;
  char const   *bad_value ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  char *tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;

  {
#line 55
  if (! bus___0) {
    {
#line 56
    tmp = gettext("Error: Missing bus driver!\n");
#line 56
    printf((char const   */* __restrict  */)tmp);
    }
#line 57
    return;
  }
  {
#line 60
  cfi_array_free(cfi_array);
#line 61
  cfi_array = (cfi_array_t *)((void *)0);
#line 63
  (*((bus___0->driver)->prepare))(bus___0);
#line 65
  tmp___2 = cfi_detect(bus___0, adr, & cfi_array);
  }
#line 65
  if (tmp___2) {
    {
#line 66
    cfi_array_free(cfi_array);
#line 67
    cfi_array = (cfi_array_t *)((void *)0);
#line 68
    tmp___1 = jedec_detect(bus___0, adr, & cfi_array);
    }
#line 68
    if (tmp___1 != 0) {
      {
#line 69
      cfi_array_free(cfi_array);
#line 70
      cfi_array = (cfi_array_t *)((void *)0);
#line 71
      tmp___0 = amd_detect(bus___0, adr, & cfi_array);
      }
#line 71
      if (tmp___0 != 0) {
        {
#line 73
        cfi_array_free(cfi_array);
#line 74
        cfi_array = (cfi_array_t *)((void *)0);
        }
      }
    }
  }
#line 85
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
    {
#line 87
    tmp___3 = gettext("Flash not found!\n");
#line 87
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 88
    return;
  }
  {
#line 91
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 96
  tmp___4 = gettext("Query identification string:\n");
#line 96
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 99
  if ((int )cfi->identification_string.pri_id_code == 0) {
#line 99
    goto case_0;
  }
#line 102
  if ((int )cfi->identification_string.pri_id_code == 1) {
#line 102
    goto case_1;
  }
#line 105
  if ((int )cfi->identification_string.pri_id_code == 2) {
#line 105
    goto case_2;
  }
#line 108
  if ((int )cfi->identification_string.pri_id_code == 3) {
#line 108
    goto case_3;
  }
#line 111
  if ((int )cfi->identification_string.pri_id_code == 4) {
#line 111
    goto case_4;
  }
#line 114
  if ((int )cfi->identification_string.pri_id_code == 256) {
#line 114
    goto case_256;
  }
#line 117
  if ((int )cfi->identification_string.pri_id_code == 257) {
#line 117
    goto case_257;
  }
#line 120
  if ((int )cfi->identification_string.pri_id_code == 258) {
#line 120
    goto case_258;
  }
#line 123
  goto switch_default;
  case_0: /* CIL Label */ 
#line 100
  s = "null";
#line 101
  goto switch_break;
  case_1: /* CIL Label */ 
#line 103
  s = "Intel/Sharp Extended Command Set";
#line 104
  goto switch_break;
  case_2: /* CIL Label */ 
#line 106
  s = "AMD/Fujitsu Standard Command Set";
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
#line 109
  s = "Intel Standard Command Set";
#line 110
  goto switch_break;
  case_4: /* CIL Label */ 
#line 112
  s = "AMD/Fujitsu Extended Command Set";
#line 113
  goto switch_break;
  case_256: /* CIL Label */ 
#line 115
  s = "Mitsubishi Standard Command Set";
#line 116
  goto switch_break;
  case_257: /* CIL Label */ 
#line 118
  s = "Mitsubishi Extended Command Set";
#line 119
  goto switch_break;
  case_258: /* CIL Label */ 
#line 121
  s = "Page Write Command Set";
#line 122
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 124
  s = "unknown!!!";
#line 125
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 127
  tmp___5 = gettext(s);
#line 127
  tmp___6 = gettext("\tPrimary Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 127
  printf((char const   */* __restrict  */)tmp___6, (int )cfi->identification_string.pri_id_code,
         tmp___5);
  }
  {
#line 129
  if ((int )cfi->identification_string.alt_id_code == 0) {
#line 129
    goto case_0___0;
  }
#line 132
  if ((int )cfi->identification_string.alt_id_code == 1) {
#line 132
    goto case_1___0;
  }
#line 135
  if ((int )cfi->identification_string.alt_id_code == 2) {
#line 135
    goto case_2___0;
  }
#line 138
  if ((int )cfi->identification_string.alt_id_code == 3) {
#line 138
    goto case_3___0;
  }
#line 141
  if ((int )cfi->identification_string.alt_id_code == 4) {
#line 141
    goto case_4___0;
  }
#line 144
  if ((int )cfi->identification_string.alt_id_code == 256) {
#line 144
    goto case_256___0;
  }
#line 147
  if ((int )cfi->identification_string.alt_id_code == 257) {
#line 147
    goto case_257___0;
  }
#line 150
  if ((int )cfi->identification_string.alt_id_code == 258) {
#line 150
    goto case_258___0;
  }
#line 153
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 130
  s = "null";
#line 131
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 133
  s = "Intel/Sharp Extended Command Set";
#line 134
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
#line 136
  s = "AMD/Fujitsu Standard Command Set";
#line 137
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
#line 139
  s = "Intel Standard Command Set";
#line 140
  goto switch_break___0;
  case_4___0: /* CIL Label */ 
#line 142
  s = "AMD/Fujitsu Extended Command Set";
#line 143
  goto switch_break___0;
  case_256___0: /* CIL Label */ 
#line 145
  s = "Mitsubishi Standard Command Set";
#line 146
  goto switch_break___0;
  case_257___0: /* CIL Label */ 
#line 148
  s = "Mitsubishi Extended Command Set";
#line 149
  goto switch_break___0;
  case_258___0: /* CIL Label */ 
#line 151
  s = "Page Write Command Set";
#line 152
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 154
  s = "unknown!!!";
#line 155
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 157
  tmp___7 = gettext(s);
#line 157
  tmp___8 = gettext("\tAlternate Algorithm Command Set and Control Interface ID Code: 0x%04X (%s)\n");
#line 157
  printf((char const   */* __restrict  */)tmp___8, (int )cfi->identification_string.alt_id_code,
         tmp___7);
#line 160
  tmp___9 = gettext("Query system interface information:\n");
#line 160
  printf((char const   */* __restrict  */)tmp___9);
#line 161
  tmp___10 = gettext("\tVcc Logic Supply Minimum Write/Erase or Write voltage: %d mV\n");
#line 161
  printf((char const   */* __restrict  */)tmp___10, (int )cfi->system_interface_info.vcc_min_wev);
#line 162
  tmp___11 = gettext("\tVcc Logic Supply Maximum Write/Erase or Write voltage: %d mV\n");
#line 162
  printf((char const   */* __restrict  */)tmp___11, (int )cfi->system_interface_info.vcc_max_wev);
#line 163
  tmp___12 = gettext("\tVpp [Programming] Supply Minimum Write/Erase voltage: %d mV\n");
#line 163
  printf((char const   */* __restrict  */)tmp___12, (int )cfi->system_interface_info.vpp_min_wev);
#line 164
  tmp___13 = gettext("\tVpp [Programming] Supply Maximum Write/Erase voltage: %d mV\n");
#line 164
  printf((char const   */* __restrict  */)tmp___13, (int )cfi->system_interface_info.vpp_max_wev);
#line 165
  tmp___14 = gettext("\tTypical timeout per single byte/word program: %d us\n");
#line 165
  printf((char const   */* __restrict  */)tmp___14, cfi->system_interface_info.typ_single_write_timeout);
#line 166
  tmp___15 = gettext("\tTypical timeout for maximum-size multi-byte program: %d us\n");
#line 166
  printf((char const   */* __restrict  */)tmp___15, cfi->system_interface_info.typ_buffer_write_timeout);
#line 167
  tmp___16 = gettext("\tTypical timeout per individual block erase: %d ms\n");
#line 167
  printf((char const   */* __restrict  */)tmp___16, cfi->system_interface_info.typ_block_erase_timeout);
#line 168
  tmp___17 = gettext("\tTypical timeout for full chip erase: %d ms\n");
#line 168
  printf((char const   */* __restrict  */)tmp___17, cfi->system_interface_info.typ_chip_erase_timeout);
#line 169
  tmp___18 = gettext("\tMaximum timeout for byte/word program: %d us\n");
#line 169
  printf((char const   */* __restrict  */)tmp___18, cfi->system_interface_info.max_single_write_timeout);
#line 170
  tmp___19 = gettext("\tMaximum timeout for multi-byte program: %d us\n");
#line 170
  printf((char const   */* __restrict  */)tmp___19, cfi->system_interface_info.max_buffer_write_timeout);
#line 171
  tmp___20 = gettext("\tMaximum timeout per individual block erase: %d ms\n");
#line 171
  printf((char const   */* __restrict  */)tmp___20, cfi->system_interface_info.max_block_erase_timeout);
#line 172
  tmp___21 = gettext("\tMaximum timeout for chip erase: %d ms\n");
#line 172
  printf((char const   */* __restrict  */)tmp___21, cfi->system_interface_info.max_chip_erase_timeout);
#line 175
  tmp___22 = gettext("Device geometry definition:\n");
#line 175
  printf((char const   */* __restrict  */)tmp___22);
#line 176
  tmp___23 = gettext("\tDevice Size: %d B (%d KiB, %d MiB)\n");
#line 176
  printf((char const   */* __restrict  */)tmp___23, cfi->device_geometry.device_size,
         cfi->device_geometry.device_size / 1024U, cfi->device_geometry.device_size / 1048576U);
  }
  {
#line 182
  if ((int )cfi->device_geometry.device_interface == 0) {
#line 182
    goto case_0___1;
  }
#line 185
  if ((int )cfi->device_geometry.device_interface == 1) {
#line 185
    goto case_1___1;
  }
#line 188
  if ((int )cfi->device_geometry.device_interface == 2) {
#line 188
    goto case_2___1;
  }
#line 191
  if ((int )cfi->device_geometry.device_interface == 3) {
#line 191
    goto case_3___1;
  }
#line 194
  if ((int )cfi->device_geometry.device_interface == 4) {
#line 194
    goto case_4___1;
  }
#line 197
  goto switch_default___1;
  case_0___1: /* CIL Label */ 
#line 183
  s = "x8";
#line 184
  goto switch_break___1;
  case_1___1: /* CIL Label */ 
#line 186
  s = "x16";
#line 187
  goto switch_break___1;
  case_2___1: /* CIL Label */ 
#line 189
  s = "x8/x16";
#line 190
  goto switch_break___1;
  case_3___1: /* CIL Label */ 
#line 192
  s = "x32";
#line 193
  goto switch_break___1;
  case_4___1: /* CIL Label */ 
#line 195
  s = "x16/x32";
#line 196
  goto switch_break___1;
  switch_default___1: /* CIL Label */ 
#line 198
  s = "unknown!!!";
#line 199
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 201
  tmp___24 = gettext(s);
#line 201
  tmp___25 = gettext("\tFlash Device Interface Code description: 0x%04X (%s)\n");
#line 201
  printf((char const   */* __restrict  */)tmp___25, (int )cfi->device_geometry.device_interface,
         tmp___24);
#line 202
  tmp___26 = gettext("\tMaximum number of bytes in multi-byte program: %d\n");
#line 202
  printf((char const   */* __restrict  */)tmp___26, cfi->device_geometry.max_bytes_write);
#line 203
  tmp___27 = gettext("\tNumber of Erase Block Regions within device: %d\n");
#line 203
  printf((char const   */* __restrict  */)tmp___27, (int )cfi->device_geometry.number_of_erase_regions);
#line 204
  tmp___28 = gettext("\tErase Block Region Information:\n");
#line 204
  printf((char const   */* __restrict  */)tmp___28);
#line 208
  i = 0;
  }
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 208
      goto while_break;
    }
    {
#line 209
    tmp___29 = gettext("\t\tRegion %d:\n");
#line 209
    printf((char const   */* __restrict  */)tmp___29, i);
#line 210
    tmp___30 = gettext("\t\t\tErase Block Size: %d B (%d KiB)\n");
#line 210
    printf((char const   */* __restrict  */)tmp___30, (cfi->device_geometry.erase_block_regions + i)->erase_block_size,
           (cfi->device_geometry.erase_block_regions + i)->erase_block_size / 1024U);
#line 213
    tmp___31 = gettext("\t\t\tNumber of Erase Blocks: %d\n");
#line 213
    printf((char const   */* __restrict  */)tmp___31, (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks);
#line 208
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  if ((int )cfi->identification_string.pri_id_code == 2) {
#line 217
    if ((unsigned long )cfi->identification_string.pri_vendor_tbl != (unsigned long )((void *)0)) {
      {
#line 224
      required_or_not[0] = "Required";
#line 224
      required_or_not[1] = "Not required";
#line 227
      supported_or_not[0] = "Supported";
#line 227
      supported_or_not[1] = "Not supported";
#line 230
      process_technology[0] = "170-nm Floating Gate technology";
#line 230
      process_technology[1] = "230-nm MirrorBit(tm) technology";
#line 230
      process_technology[2] = "130-nm Floating Gate technology";
#line 230
      process_technology[3] = "110-nm MirrorBit(tm) technology";
#line 230
      process_technology[4] = "90-nm Floating Gate technology";
#line 230
      process_technology[5] = "90-nm MirrorBit(tm) technology";
#line 235
      process_technology_13[0] = "CS49";
#line 235
      process_technology_13[1] = "CS59";
#line 235
      process_technology_13[2] = "CS99";
#line 238
      erase_suspend[0] = "Not supported";
#line 238
      erase_suspend[1] = "Read only";
#line 238
      erase_suspend[2] = "Read/write";
#line 241
      sector_protect_scheme[0] = "29F040 mode";
#line 241
      sector_protect_scheme[1] = "29F016 mode";
#line 241
      sector_protect_scheme[2] = "29F400 mode";
#line 241
      sector_protect_scheme[3] = "29LV800 mode";
#line 241
      sector_protect_scheme[4] = "29BDS640 mode (Software Command Locking)";
#line 241
      sector_protect_scheme[5] = "29BDD160 mode (New Sector Protect)";
#line 241
      sector_protect_scheme[6] = "29PDL128 mode (New Sector Protect + 29LV800)";
#line 241
      sector_protect_scheme[7] = "Advanced Sector Protect";
#line 248
      page_mode_type[0] = "Not supported";
#line 248
      page_mode_type[1] = "4 word Page";
#line 248
      page_mode_type[2] = "8 word Page";
#line 248
      page_mode_type[3] = "16 word Page";
#line 252
      top_bottom[0] = "No boot";
#line 252
      top_bottom[1] = "8x8kb sectors at top and bottom with WP control";
#line 252
      top_bottom[2] = "Bottom boot device";
#line 252
      top_bottom[3] = "Top boot device";
#line 252
      top_bottom[4] = "Uniform bottom boot device";
#line 252
      top_bottom[5] = "Uniform top boot device";
#line 257
      bad_value = "Bad value";
#line 261
      pri_vendor_tbl = (amd_pri_extened_query_structure_t *)cfi->identification_string.pri_vendor_tbl;
#line 262
      major_version = pri_vendor_tbl->major_version;
#line 263
      minor_version = pri_vendor_tbl->minor_version;
#line 265
      tmp___32 = gettext("Primary Vendor-Specific Extended Query:\n");
#line 265
      printf((char const   */* __restrict  */)tmp___32);
#line 266
      tmp___33 = gettext("\tMajor version number: %c\n");
#line 266
      printf((char const   */* __restrict  */)tmp___33, (int )pri_vendor_tbl->major_version);
#line 267
      tmp___34 = gettext("\tMinor version number: %c\n");
#line 267
      printf((char const   */* __restrict  */)tmp___34, (int )pri_vendor_tbl->minor_version);
      }
#line 268
      if ((int )major_version > 49) {
#line 268
        goto _L___1;
      } else
#line 268
      if ((int )major_version == 49) {
#line 268
        if ((int )minor_version >= 48) {
          _L___1: /* CIL Label */ 
#line 270
          if ((unsigned long )((int )pri_vendor_tbl->address_sensitive_unlock & 3) < sizeof(required_or_not) / sizeof(required_or_not[0])) {
            {
#line 271
            tmp___35 = gettext("\tAddress Sensitive Unlock: %s\n");
#line 271
            printf((char const   */* __restrict  */)tmp___35, required_or_not[(int )pri_vendor_tbl->address_sensitive_unlock & 3]);
            }
          } else {
            {
#line 274
            tmp___36 = gettext("\tAddress Sensitive Unlock: %s\n");
#line 274
            printf((char const   */* __restrict  */)tmp___36, bad_value);
            }
          }
#line 276
          if ((int )major_version > 49) {
#line 276
            goto _L;
          } else
#line 276
          if ((int )major_version == 49) {
#line 276
            if ((int )minor_version >= 52) {
              _L: /* CIL Label */ 
#line 278
              if ((unsigned long )((int )pri_vendor_tbl->address_sensitive_unlock >> 2) < sizeof(process_technology) / sizeof(process_technology[0])) {
                {
#line 279
                tmp___37 = gettext("\tProcess Technology: %s\n");
#line 279
                printf((char const   */* __restrict  */)tmp___37, process_technology[(int )pri_vendor_tbl->address_sensitive_unlock >> 2]);
                }
              } else {
                {
#line 282
                tmp___38 = gettext("\tProcess Technology: %s\n");
#line 282
                printf((char const   */* __restrict  */)tmp___38, bad_value);
                }
              }
            } else {
#line 276
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 284
          if ((int )major_version == 49) {
#line 284
            if ((int )minor_version == 51) {
#line 286
              if ((unsigned long )((int )pri_vendor_tbl->address_sensitive_unlock >> 2) < sizeof(process_technology_13) / sizeof(process_technology_13[0])) {
                {
#line 287
                tmp___39 = gettext("\tProcess Technology: %s\n");
#line 287
                printf((char const   */* __restrict  */)tmp___39, process_technology_13[(int )pri_vendor_tbl->address_sensitive_unlock >> 2]);
                }
              } else {
                {
#line 290
                tmp___40 = gettext("\tProcess Technology: %s\n");
#line 290
                printf((char const   */* __restrict  */)tmp___40, bad_value);
                }
              }
            }
          }
#line 292
          if ((unsigned long )pri_vendor_tbl->erase_suspend < sizeof(erase_suspend) / sizeof(erase_suspend[0])) {
            {
#line 293
            tmp___41 = gettext("\tErase Suspend: %s\n");
#line 293
            printf((char const   */* __restrict  */)tmp___41, erase_suspend[pri_vendor_tbl->erase_suspend]);
            }
          }
#line 294
          if ((int )pri_vendor_tbl->sector_protect == 0) {
            {
#line 295
            tmp___42 = gettext("\tSector Protect: Not supported\n");
#line 295
            printf((char const   */* __restrict  */)tmp___42);
            }
          } else {
            {
#line 297
            tmp___43 = gettext("\tSector Protect: %d sectors per group\n");
#line 297
            printf((char const   */* __restrict  */)tmp___43, (int )pri_vendor_tbl->sector_protect);
            }
          }
#line 298
          if ((unsigned long )pri_vendor_tbl->sector_temporary_unprotect < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 299
            tmp___44 = gettext("\tSector Temporary Unprotect: %s\n");
#line 299
            printf((char const   */* __restrict  */)tmp___44, supported_or_not[pri_vendor_tbl->sector_temporary_unprotect]);
            }
          } else {
            {
#line 301
            tmp___45 = gettext("\tSector Temporary Unprotect: %s\n");
#line 301
            printf((char const   */* __restrict  */)tmp___45, bad_value);
            }
          }
#line 302
          if ((unsigned long )pri_vendor_tbl->sector_protect_scheme < sizeof(sector_protect_scheme) / sizeof(sector_protect_scheme[0])) {
            {
#line 303
            tmp___46 = gettext("\tSector Protect/Unprotect Scheme: %s\n");
#line 303
            printf((char const   */* __restrict  */)tmp___46, sector_protect_scheme[pri_vendor_tbl->sector_protect_scheme]);
            }
          } else {
            {
#line 306
            tmp___47 = gettext("\tSector Protect/Unprotect Scheme: %s\n");
#line 306
            printf((char const   */* __restrict  */)tmp___47, bad_value);
            }
          }
#line 307
          if ((int )pri_vendor_tbl->simultaneous_operation == 0) {
            {
#line 308
            tmp___48 = gettext("\tSimultaneous Operation: Not supported\n");
#line 308
            printf((char const   */* __restrict  */)tmp___48);
            }
          } else {
            {
#line 310
            tmp___49 = gettext("\tSimultaneous Operation: %d sectors\n");
#line 310
            printf((char const   */* __restrict  */)tmp___49, (int )pri_vendor_tbl->simultaneous_operation);
            }
          }
#line 311
          if ((unsigned long )pri_vendor_tbl->burst_mode_type < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 312
            tmp___50 = gettext("\tBurst Mode Type: %s\n");
#line 312
            printf((char const   */* __restrict  */)tmp___50, supported_or_not[pri_vendor_tbl->burst_mode_type]);
            }
          } else {
            {
#line 314
            tmp___51 = gettext("\tBurst Mode Type: %s\n");
#line 314
            printf((char const   */* __restrict  */)tmp___51, bad_value);
            }
          }
#line 315
          if ((unsigned long )pri_vendor_tbl->page_mode_type < sizeof(page_mode_type) / sizeof(page_mode_type[0])) {
            {
#line 316
            tmp___52 = gettext("\tPage Mode Type: %s\n");
#line 316
            printf((char const   */* __restrict  */)tmp___52, page_mode_type[pri_vendor_tbl->page_mode_type]);
            }
          } else {
            {
#line 318
            tmp___53 = gettext("\tPage Mode Type: %s\n");
#line 318
            printf((char const   */* __restrict  */)tmp___53, bad_value);
            }
          }
        }
      }
#line 320
      if ((int )major_version > 49) {
#line 320
        goto _L___2;
      } else
#line 320
      if ((int )major_version == 49) {
#line 320
        if ((int )minor_version >= 49) {
          _L___2: /* CIL Label */ 
          {
#line 322
          tmp___54 = gettext("\tACC (Acceleration) Supply Minimum: %d mV\n");
#line 322
          printf((char const   */* __restrict  */)tmp___54, (int )pri_vendor_tbl->acc_min);
#line 323
          tmp___55 = gettext("\tACC (Acceleration) Supply Maximum: %d mV\n");
#line 323
          printf((char const   */* __restrict  */)tmp___55, (int )pri_vendor_tbl->acc_max);
          }
#line 324
          if ((unsigned long )pri_vendor_tbl->top_bottom_sector_flag < sizeof(top_bottom) / sizeof(top_bottom[0])) {
            {
#line 325
            tmp___56 = gettext("\tTop/Bottom Sector Flag: %s\n");
#line 325
            printf((char const   */* __restrict  */)tmp___56, top_bottom[pri_vendor_tbl->top_bottom_sector_flag]);
            }
          } else {
            {
#line 327
            tmp___57 = gettext("\tTop/Bottom Sector Flag: %s\n");
#line 327
            printf((char const   */* __restrict  */)tmp___57, bad_value);
            }
          }
        }
      }
#line 329
      if ((int )major_version > 49) {
#line 329
        goto _L___3;
      } else
#line 329
      if ((int )major_version == 49) {
#line 329
        if ((int )minor_version >= 50) {
          _L___3: /* CIL Label */ 
#line 331
          if ((unsigned long )pri_vendor_tbl->program_suspend < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 332
            tmp___58 = gettext("\tProgram Suspend: %s\n");
#line 332
            printf((char const   */* __restrict  */)tmp___58, supported_or_not[pri_vendor_tbl->program_suspend]);
            }
          } else {
            {
#line 334
            tmp___59 = gettext("\tProgram Suspend: %s\n");
#line 334
            printf((char const   */* __restrict  */)tmp___59, bad_value);
            }
          }
        }
      }
#line 336
      if ((int )major_version > 49) {
#line 336
        goto _L___4;
      } else
#line 336
      if ((int )major_version == 49) {
#line 336
        if ((int )minor_version >= 52) {
          _L___4: /* CIL Label */ 
#line 338
          if ((unsigned long )pri_vendor_tbl->unlock_bypass < sizeof(supported_or_not) / sizeof(supported_or_not[0])) {
            {
#line 339
            tmp___60 = gettext("\tUnlock Bypass: %s\n");
#line 339
            printf((char const   */* __restrict  */)tmp___60, supported_or_not[pri_vendor_tbl->unlock_bypass]);
            }
          } else {
            {
#line 341
            tmp___61 = gettext("\tUnlock Bypass: %s\n");
#line 341
            printf((char const   */* __restrict  */)tmp___61, bad_value);
            }
          }
          {
#line 342
          tmp___62 = gettext("\tSecSi Sector (Customer OTP Area) Size: %d bytes\n");
#line 342
          printf((char const   */* __restrict  */)tmp___62, (int )pri_vendor_tbl->secsi_sector_size);
#line 343
          tmp___63 = gettext("\tEmbedded Hardware Reset Timeout Maximum: %d ns\n");
#line 343
          printf((char const   */* __restrict  */)tmp___63, (int )pri_vendor_tbl->embedded_hwrst_timeout_max);
#line 344
          tmp___64 = gettext("\tNon-Embedded Hardware Reset Timeout Maximum: %d ns\n");
#line 344
          printf((char const   */* __restrict  */)tmp___64, (int )pri_vendor_tbl->non_embedded_hwrst_timeout_max);
#line 345
          tmp___65 = gettext("\tErase Suspend Timeout Maximum: %d us\n");
#line 345
          printf((char const   */* __restrict  */)tmp___65, (int )pri_vendor_tbl->erase_suspend_timeout_max);
#line 346
          tmp___66 = gettext("\tProgram Suspend Timeout Maximum: %d us\n");
#line 346
          printf((char const   */* __restrict  */)tmp___66, (int )pri_vendor_tbl->program_suspend_timeout_max);
          }
        }
      }
#line 348
      if ((int )major_version > 49) {
#line 348
        goto _L___5;
      } else
#line 348
      if ((int )major_version == 49) {
#line 348
        if ((int )minor_version >= 51) {
          _L___5: /* CIL Label */ 
#line 348
          if (pri_vendor_tbl->bank_organization) {
            {
#line 351
            tmp___67 = gettext("\tBank Organization:\n");
#line 351
            printf((char const   */* __restrict  */)tmp___67);
#line 352
            i___0 = 0;
            }
            {
#line 352
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 352
              if (! (i___0 < (int )pri_vendor_tbl->bank_organization)) {
#line 352
                goto while_break___0;
              }
              {
#line 353
              tmp___68 = gettext("\t\tBank%d: %d sectors\n");
#line 353
              printf((char const   */* __restrict  */)tmp___68, i___0 + 1, (int )pri_vendor_tbl->bank_region_info[i___0]);
#line 352
              i___0 ++;
              }
            }
            while_break___0: /* CIL Label */ ;
            }
          }
        }
      }
    }
  }
#line 356
  return;
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/cfi.c"
void cfi_array_free(cfi_array_t *cfi_array___0 ) 
{ 
  int i ;

  {
#line 43
  if (! cfi_array___0) {
#line 44
    return;
  }
#line 46
  if (cfi_array___0->cfi_chips) {
#line 49
    i = 0;
    {
#line 49
    while (1) {
      while_continue: /* CIL Label */ ;
#line 49
      if (! (i < cfi_array___0->bus_width)) {
#line 49
        goto while_break;
      }
#line 50
      if (! *(cfi_array___0->cfi_chips + i)) {
#line 51
        goto __Cont;
      }
      {
#line 53
      free((void *)(*(cfi_array___0->cfi_chips + i))->cfi.device_geometry.erase_block_regions);
      }
#line 54
      if ((*(cfi_array___0->cfi_chips + i))->cfi.identification_string.pri_vendor_tbl) {
        {
#line 55
        free((*(cfi_array___0->cfi_chips + i))->cfi.identification_string.pri_vendor_tbl);
        }
      }
      {
#line 56
      free((void *)*(cfi_array___0->cfi_chips + i));
      }
      __Cont: /* CIL Label */ 
#line 49
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 58
    free((void *)cfi_array___0->cfi_chips);
    }
  }
  {
#line 61
  free((void *)cfi_array___0);
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/cfi.c"
int cfi_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  unsigned int bw ;
  unsigned int d ;
  int ba ;
  int ma ;
  bus_area_t area ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  cfi_query_structure_t *cfi ;
  uint32_t tmp___2 ;
  int ret ;
  uint16_t pri_vendor_tbl_adr ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  void *tmp___6 ;
  uint32_t tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t tmp___19 ;
  int tmp___20 ;
  uint32_t tmp___21 ;
  int tmp___22 ;
  uint32_t tmp___23 ;
  int tmp___24 ;
  uint32_t tmp___25 ;
  int tmp___26 ;
  uint32_t tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t tmp___29 ;
  uint32_t tmp___30 ;
  uint32_t tmp___31 ;
  uint8_t tmp___32 ;
  uint32_t tmp___33 ;
  void *tmp___34 ;
  int a ;
  int i ;
  uint32_t y ;
  uint32_t tmp___35 ;
  uint32_t tmp___36 ;
  uint32_t z ;
  uint32_t tmp___37 ;
  uint32_t tmp___38 ;
  uint32_t tmp___39 ;
  uint32_t tmp___40 ;
  amd_pri_extened_query_structure_t *pri_vendor_tbl ;
  uint8_t major_version ;
  uint8_t minor_version ;
  uint8_t num_of_banks ;
  int i___0 ;
  uint32_t tmp___41 ;
  uint32_t tmp___42 ;
  uint32_t tmp___43 ;
  uint32_t tmp___44 ;
  uint32_t tmp___45 ;
  uint32_t tmp___46 ;
  void *tmp___47 ;
  uint32_t tmp___48 ;
  uint32_t tmp___49 ;
  uint32_t tmp___50 ;
  uint32_t tmp___51 ;
  uint32_t tmp___52 ;
  uint32_t tmp___53 ;
  uint32_t tmp___54 ;
  uint32_t tmp___55 ;
  uint32_t tmp___56 ;
  uint32_t tmp___57 ;
  uint32_t tmp___58 ;
  uint32_t tmp___59 ;
  uint32_t tmp___60 ;
  uint32_t tmp___61 ;
  uint32_t tmp___62 ;
  uint32_t tmp___63 ;
  uint32_t tmp___64 ;
  uint32_t tmp___65 ;
  uint32_t tmp___66 ;
  uint32_t tmp___67 ;
  uint32_t y___0 ;
  uint32_t z___0 ;
  uint32_t n ;

  {
#line 73
  if (! cfi_array___0) {
#line 74
    return (-1);
  } else
#line 73
  if (! bus___0) {
#line 74
    return (-1);
  }
  {
#line 76
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 76
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 77
  if (! *cfi_array___0) {
#line 78
    return (-2);
  }
  {
#line 80
  (*cfi_array___0)->bus = bus___0;
#line 81
  (*cfi_array___0)->address = adr;
#line 82
  tmp___0 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 82
  if (tmp___0 != 0) {
#line 83
    return (-8);
  }
#line 84
  bw = area.width;
#line 85
  if (bw != 8U) {
#line 85
    if (bw != 16U) {
#line 85
      if (bw != 32U) {
#line 86
        return (-3);
      }
    }
  }
  {
#line 87
  ba = (int )(bw / 8U);
#line 87
  (*cfi_array___0)->bus_width = ba;
#line 88
  tmp___1 = calloc((size_t )ba, sizeof(cfi_chip_t *));
#line 88
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___1;
  }
#line 89
  if (! (*cfi_array___0)->cfi_chips) {
#line 90
    return (-2);
  }
#line 92
  d = 0U;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (d < bw)) {
#line 92
      goto while_break;
    }
#line 102
    ret = -4;
#line 106
    ma = 1;
    {
#line 106
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 106
      if (! (ma <= 4)) {
#line 106
        goto while_break___0;
      }
      {
#line 107
      (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )((85 * ba) * ma), (uint32_t )(152 << d));
#line 109
      tmp___4 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((16 * ba) * ma));
      }
#line 109
      if (((tmp___4 >> d) & 255U) == 81U) {
        {
#line 110
        ret = -5;
#line 111
        tmp___3 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((17 * ba) * ma));
        }
#line 111
        if (((tmp___3 >> d) & 255U) == 82U) {
#line 112
          goto while_break___0;
        }
      }
      {
#line 115
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
#line 106
      ma *= 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 118
    if (ma > 4) {
#line 119
      return (ret);
    }
    {
#line 121
    tmp___5 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((18 * ba) * ma));
    }
#line 121
    if (((tmp___5 >> d) & 255U) != 89U) {
      {
#line 122
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 123
      return (-6);
    }
    {
#line 126
    tmp___6 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 126
    *((*cfi_array___0)->cfi_chips + d / 8U) = (cfi_chip_t *)tmp___6;
    }
#line 127
    if (! *((*cfi_array___0)->cfi_chips + d / 8U)) {
      {
#line 128
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 129
      return (-2);
    }
    {
#line 131
    cfi = & (*((*cfi_array___0)->cfi_chips + d / 8U))->cfi;
#line 134
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((19 * ba) * ma));
#line 134
    tmp___7 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((20 * ba) * ma));
#line 134
    tmp___8 = (*((bus___0->driver)->read_end))(bus___0);
#line 134
    cfi->identification_string.pri_id_code = (uint16_t )(((tmp___7 >> d) & 255U) | (((tmp___8 >> d) & 255U) << 8));
#line 135
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 136
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((23 * ba) * ma));
#line 136
    tmp___9 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((24 * ba) * ma));
#line 136
    tmp___10 = (*((bus___0->driver)->read_end))(bus___0);
#line 136
    cfi->identification_string.alt_id_code = (uint16_t )(((tmp___9 >> d) & 255U) | (((tmp___10 >> d) & 255U) << 8));
#line 137
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 140
    tmp___11 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((27 * ba) * ma));
#line 140
    tmp___2 = (tmp___11 >> d) & 255U;
#line 141
    cfi->system_interface_info.vcc_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 142
    tmp___12 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((28 * ba) * ma));
#line 142
    tmp___2 = (tmp___12 >> d) & 255U;
#line 143
    cfi->system_interface_info.vcc_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 144
    tmp___13 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((29 * ba) * ma));
#line 144
    tmp___2 = (tmp___13 >> d) & 255U;
#line 145
    cfi->system_interface_info.vpp_min_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 146
    tmp___14 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((30 * ba) * ma));
#line 146
    tmp___2 = (tmp___14 >> d) & 255U;
#line 147
    cfi->system_interface_info.vpp_max_wev = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 150
    tmp___15 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((31 * ba) * ma));
#line 150
    tmp___2 = (tmp___15 >> d) & 255U;
    }
#line 151
    if (tmp___2) {
#line 151
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 151
      cfi->system_interface_info.typ_single_write_timeout = (uint32_t )0;
    }
    {
#line 153
    tmp___16 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((32 * ba) * ma));
#line 153
    tmp___2 = (tmp___16 >> d) & 255U;
    }
#line 154
    if (tmp___2) {
#line 154
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 154
      cfi->system_interface_info.typ_buffer_write_timeout = (uint32_t )0;
    }
    {
#line 156
    tmp___17 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((33 * ba) * ma));
#line 156
    tmp___2 = (tmp___17 >> d) & 255U;
    }
#line 157
    if (tmp___2) {
#line 157
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 157
      cfi->system_interface_info.typ_block_erase_timeout = (uint32_t )0;
    }
    {
#line 159
    tmp___18 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((34 * ba) * ma));
#line 159
    tmp___2 = (tmp___18 >> d) & 255U;
    }
#line 160
    if (tmp___2) {
#line 160
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )(1 << tmp___2);
    } else {
#line 160
      cfi->system_interface_info.typ_chip_erase_timeout = (uint32_t )0;
    }
    {
#line 162
    tmp___19 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((35 * ba) * ma));
#line 162
    tmp___2 = (tmp___19 >> d) & 255U;
    }
#line 163
    if (tmp___2) {
#line 163
      tmp___20 = 1 << tmp___2;
    } else {
#line 163
      tmp___20 = 0;
    }
    {
#line 163
    cfi->system_interface_info.max_single_write_timeout = (uint32_t )tmp___20 * cfi->system_interface_info.typ_single_write_timeout;
#line 166
    tmp___21 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((36 * ba) * ma));
#line 166
    tmp___2 = (tmp___21 >> d) & 255U;
    }
#line 167
    if (tmp___2) {
#line 167
      tmp___22 = 1 << tmp___2;
    } else {
#line 167
      tmp___22 = 0;
    }
    {
#line 167
    cfi->system_interface_info.max_buffer_write_timeout = (uint32_t )tmp___22 * cfi->system_interface_info.typ_buffer_write_timeout;
#line 170
    tmp___23 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((37 * ba) * ma));
#line 170
    tmp___2 = (tmp___23 >> d) & 255U;
    }
#line 171
    if (tmp___2) {
#line 171
      tmp___24 = 1 << tmp___2;
    } else {
#line 171
      tmp___24 = 0;
    }
    {
#line 171
    cfi->system_interface_info.max_block_erase_timeout = (uint32_t )tmp___24 * cfi->system_interface_info.typ_block_erase_timeout;
#line 174
    tmp___25 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((38 * ba) * ma));
#line 174
    tmp___2 = (tmp___25 >> d) & 255U;
    }
#line 175
    if (tmp___2) {
#line 175
      tmp___26 = 1 << tmp___2;
    } else {
#line 175
      tmp___26 = 0;
    }
    {
#line 175
    cfi->system_interface_info.max_chip_erase_timeout = (uint32_t )tmp___26 * cfi->system_interface_info.typ_chip_erase_timeout;
#line 180
    tmp___27 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((39 * ba) * ma));
#line 180
    cfi->device_geometry.device_size = (uint32_t )(1 << ((tmp___27 >> d) & 255U));
#line 182
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((40 * ba) * ma));
#line 182
    tmp___28 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((41 * ba) * ma));
#line 182
    tmp___29 = (*((bus___0->driver)->read_end))(bus___0);
#line 182
    cfi->device_geometry.device_interface = (uint16_t )(((tmp___28 >> d) & 255U) | (((tmp___29 >> d) & 255U) << 8));
#line 185
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((42 * ba) * ma));
#line 185
    tmp___30 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((43 * ba) * ma));
#line 185
    tmp___31 = (*((bus___0->driver)->read_end))(bus___0);
#line 185
    cfi->device_geometry.max_bytes_write = (uint32_t )(1 << (((tmp___30 >> d) & 255U) | (((tmp___31 >> d) & 255U) << 8)));
#line 187
    tmp___33 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((44 * ba) * ma));
#line 187
    tmp___32 = (uint8_t )((tmp___33 >> d) & 255U);
#line 187
    cfi->device_geometry.number_of_erase_regions = tmp___32;
#line 187
    tmp___2 = (uint32_t )tmp___32;
#line 189
    tmp___34 = malloc((unsigned long )tmp___2 * sizeof(cfi_erase_block_region_t ));
#line 189
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___34;
    }
#line 190
    if (! cfi->device_geometry.erase_block_regions) {
      {
#line 191
      (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
      }
#line 192
      return (-2);
    }
#line 199
    i = 0;
#line 199
    a = 45;
    {
#line 199
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 199
      if (! ((uint32_t )i < tmp___2)) {
#line 199
        goto while_break___1;
      }
      {
#line 200
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((a * ba) * ma));
#line 200
      tmp___35 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )(((a + 1) * ba) * ma));
#line 200
      tmp___36 = (*((bus___0->driver)->read_end))(bus___0);
#line 200
      y = ((tmp___35 >> d) & 255U) | (((tmp___36 >> d) & 255U) << 8);
#line 201
      (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )(((a + 2) * ba) * ma));
#line 201
      tmp___37 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((((a + 2) + 1) * ba) * ma));
#line 201
      tmp___38 = (*((bus___0->driver)->read_end))(bus___0);
#line 201
      z = (((tmp___37 >> d) & 255U) | (((tmp___38 >> d) & 255U) << 8)) << 8;
      }
#line 202
      if (z == 0U) {
#line 203
        z = (uint32_t )128;
      }
#line 204
      (cfi->device_geometry.erase_block_regions + i)->erase_block_size = z;
#line 205
      (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = y + 1U;
#line 199
      i ++;
#line 199
      a += 4;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 209
    (*((bus___0->driver)->read_start))(bus___0, adr + (uint32_t )((21 * ba) * ma));
#line 209
    tmp___39 = (*((bus___0->driver)->read_next))(bus___0, adr + (uint32_t )((22 * ba) * ma));
#line 209
    tmp___40 = (*((bus___0->driver)->read_end))(bus___0);
#line 209
    pri_vendor_tbl_adr = (uint16_t )(((tmp___39 >> d) & 255U) | (((tmp___40 >> d) & 255U) << 8));
    }
#line 212
    if ((int )cfi->identification_string.pri_id_code == 2) {
#line 212
      if ((int )pri_vendor_tbl_adr != 0) {
        {
#line 222
        tmp___41 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma));
        }
#line 222
        if (((tmp___41 >> d) & 255U) != 80U) {
          {
#line 223
          (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                        (uint32_t )(255 << d));
          }
#line 224
          return (-9);
        } else {
          {
#line 222
          tmp___42 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 1) * ba) * ma));
          }
#line 222
          if (((tmp___42 >> d) & 255U) != 82U) {
            {
#line 223
            (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                          (uint32_t )(255 << d));
            }
#line 224
            return (-9);
          } else {
            {
#line 222
            tmp___43 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 2) * ba) * ma));
            }
#line 222
            if (((tmp___43 >> d) & 255U) != 73U) {
              {
#line 223
              (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                            (uint32_t )(255 << d));
              }
#line 224
              return (-9);
            }
          }
        }
        {
#line 227
        tmp___44 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 3) * ba) * ma));
#line 227
        major_version = (uint8_t )((tmp___44 >> d) & 255U);
#line 228
        tmp___45 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 4) * ba) * ma));
#line 228
        minor_version = (uint8_t )((tmp___45 >> d) & 255U);
        }
#line 229
        if ((int )major_version > 49) {
          {
#line 230
          tmp___46 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 23) * ba) * ma));
#line 230
          num_of_banks = (uint8_t )((tmp___46 >> d) & 255U);
          }
        } else
#line 229
        if ((int )major_version == 49) {
#line 229
          if ((int )minor_version >= 51) {
            {
#line 230
            tmp___46 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 23) * ba) * ma));
#line 230
            num_of_banks = (uint8_t )((tmp___46 >> d) & 255U);
            }
          } else {
#line 232
            num_of_banks = (uint8_t )0;
          }
        } else {
#line 232
          num_of_banks = (uint8_t )0;
        }
        {
#line 233
        tmp___47 = calloc((size_t )1, sizeof(amd_pri_extened_query_structure_t ) + (unsigned long )num_of_banks * sizeof(uint8_t ));
#line 233
        pri_vendor_tbl = (amd_pri_extened_query_structure_t *)tmp___47;
        }
#line 236
        if (! pri_vendor_tbl) {
          {
#line 237
          (*((bus___0->driver)->write))(bus___0, adr + (uint32_t )(((int )pri_vendor_tbl_adr * ba) * ma),
                                        (uint32_t )(255 << d));
          }
#line 238
          return (-2);
        }
#line 241
        if ((int )major_version > 49) {
#line 241
          goto _L;
        } else
#line 241
        if ((int )major_version == 49) {
#line 241
          if ((int )minor_version >= 48) {
            _L: /* CIL Label */ 
            {
#line 242
            pri_vendor_tbl->major_version = major_version;
#line 243
            pri_vendor_tbl->minor_version = minor_version;
#line 244
            tmp___48 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 5) * ba) * ma));
#line 244
            pri_vendor_tbl->address_sensitive_unlock = (uint8_t )((tmp___48 >> d) & 255U);
#line 245
            tmp___49 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 6) * ba) * ma));
#line 245
            pri_vendor_tbl->erase_suspend = (uint8_t )((tmp___49 >> d) & 255U);
#line 246
            tmp___50 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 7) * ba) * ma));
#line 246
            pri_vendor_tbl->sector_protect = (uint8_t )((tmp___50 >> d) & 255U);
#line 247
            tmp___51 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 8) * ba) * ma));
#line 247
            pri_vendor_tbl->sector_temporary_unprotect = (uint8_t )((tmp___51 >> d) & 255U);
#line 248
            tmp___52 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 9) * ba) * ma));
#line 248
            pri_vendor_tbl->sector_protect_scheme = (uint8_t )((tmp___52 >> d) & 255U);
#line 249
            tmp___53 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 10) * ba) * ma));
#line 249
            pri_vendor_tbl->simultaneous_operation = (uint8_t )((tmp___53 >> d) & 255U);
#line 250
            tmp___54 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 11) * ba) * ma));
#line 250
            pri_vendor_tbl->burst_mode_type = (uint8_t )((tmp___54 >> d) & 255U);
#line 251
            tmp___55 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 12) * ba) * ma));
#line 251
            pri_vendor_tbl->page_mode_type = (uint8_t )((tmp___55 >> d) & 255U);
            }
          }
        }
#line 253
        if ((int )major_version > 49) {
#line 253
          goto _L___0;
        } else
#line 253
        if ((int )major_version == 49) {
#line 253
          if ((int )minor_version >= 49) {
            _L___0: /* CIL Label */ 
            {
#line 254
            tmp___56 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 13) * ba) * ma));
#line 254
            tmp___2 = (tmp___56 >> d) & 255U;
#line 255
            pri_vendor_tbl->acc_min = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 256
            tmp___57 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 14) * ba) * ma));
#line 256
            tmp___2 = (tmp___57 >> d) & 255U;
#line 257
            pri_vendor_tbl->acc_max = (uint16_t )(((tmp___2 >> 4) & 15U) * 1000U + (tmp___2 & 15U) * 100U);
#line 258
            tmp___58 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 15) * ba) * ma));
#line 258
            pri_vendor_tbl->top_bottom_sector_flag = (uint8_t )((tmp___58 >> d) & 255U);
            }
          }
        }
#line 260
        if ((int )major_version > 49) {
          {
#line 261
          tmp___59 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 16) * ba) * ma));
#line 261
          pri_vendor_tbl->program_suspend = (uint8_t )((tmp___59 >> d) & 255U);
          }
        } else
#line 260
        if ((int )major_version == 49) {
#line 260
          if ((int )minor_version >= 50) {
            {
#line 261
            tmp___59 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 16) * ba) * ma));
#line 261
            pri_vendor_tbl->program_suspend = (uint8_t )((tmp___59 >> d) & 255U);
            }
          }
        }
#line 262
        if ((int )major_version > 49) {
#line 262
          goto _L___1;
        } else
#line 262
        if ((int )major_version == 49) {
#line 262
          if ((int )minor_version >= 51) {
            _L___1: /* CIL Label */ 
#line 263
            if (pri_vendor_tbl->simultaneous_operation) {
              {
#line 264
              tmp___60 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 23) * ba) * ma));
#line 264
              pri_vendor_tbl->bank_organization = (uint8_t )((tmp___60 >> d) & 255U);
              }
            } else {
#line 266
              pri_vendor_tbl->bank_organization = (uint8_t )0;
            }
#line 267
            i___0 = 0;
            {
#line 267
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 267
              if (! (i___0 < (int )pri_vendor_tbl->bank_organization)) {
#line 267
                goto while_break___2;
              }
              {
#line 268
              tmp___61 = (*((bus___0->driver)->read))(bus___0, (uint32_t )((unsigned long )adr + (((unsigned long )((int )pri_vendor_tbl_adr + 24) + (unsigned long )i___0 * sizeof(uint8_t )) * (unsigned long )ba) * (unsigned long )ma));
#line 268
              pri_vendor_tbl->bank_region_info[i___0] = (uint8_t )((tmp___61 >> d) & 255U);
#line 267
              i___0 ++;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
#line 270
        if ((int )major_version > 49) {
#line 270
          goto _L___2;
        } else
#line 270
        if ((int )major_version == 49) {
#line 270
          if ((int )minor_version >= 52) {
            _L___2: /* CIL Label */ 
            {
#line 271
            tmp___62 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 17) * ba) * ma));
#line 271
            pri_vendor_tbl->unlock_bypass = (uint8_t )((tmp___62 >> d) & 255U);
#line 272
            tmp___63 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 18) * ba) * ma));
#line 272
            tmp___2 = (tmp___63 >> d) & 255U;
            }
#line 273
            if (tmp___2) {
#line 273
              pri_vendor_tbl->secsi_sector_size = (uint8_t )(1 << tmp___2);
            } else {
#line 273
              pri_vendor_tbl->secsi_sector_size = (uint8_t )0;
            }
            {
#line 274
            tmp___64 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 19) * ba) * ma));
#line 274
            tmp___2 = (tmp___64 >> d) & 255U;
            }
#line 275
            if (tmp___2) {
#line 275
              pri_vendor_tbl->embedded_hwrst_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 275
              pri_vendor_tbl->embedded_hwrst_timeout_max = (uint8_t )0;
            }
            {
#line 276
            tmp___65 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 20) * ba) * ma));
#line 276
            tmp___2 = (tmp___65 >> d) & 255U;
            }
#line 277
            if (tmp___2) {
#line 277
              pri_vendor_tbl->non_embedded_hwrst_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 277
              pri_vendor_tbl->non_embedded_hwrst_timeout_max = (uint8_t )0;
            }
            {
#line 278
            tmp___66 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 21) * ba) * ma));
#line 278
            tmp___2 = (tmp___66 >> d) & 255U;
            }
#line 279
            if (tmp___2) {
#line 279
              pri_vendor_tbl->erase_suspend_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 279
              pri_vendor_tbl->erase_suspend_timeout_max = (uint8_t )0;
            }
            {
#line 280
            tmp___67 = (*((bus___0->driver)->read))(bus___0, adr + (uint32_t )((((int )pri_vendor_tbl_adr + 22) * ba) * ma));
#line 280
            tmp___2 = (tmp___67 >> d) & 255U;
            }
#line 281
            if (tmp___2) {
#line 281
              pri_vendor_tbl->program_suspend_timeout_max = (uint8_t )(1 << tmp___2);
            } else {
#line 281
              pri_vendor_tbl->program_suspend_timeout_max = (uint8_t )0;
            }
          }
        }
#line 284
        cfi->identification_string.pri_vendor_tbl = (void *)pri_vendor_tbl;
#line 290
        if ((int )major_version > 49) {
#line 290
          goto _L___3;
        } else
#line 290
        if ((int )major_version == 49) {
#line 290
          if ((int )minor_version >= 49) {
            _L___3: /* CIL Label */ 
#line 290
            if ((int )pri_vendor_tbl->top_bottom_sector_flag == 3) {
#line 294
              n = (uint32_t )cfi->device_geometry.number_of_erase_regions;
#line 296
              i___0 = 0;
              {
#line 296
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 296
                if (! ((uint32_t )i___0 < n / 2U)) {
#line 296
                  goto while_break___3;
                }
#line 297
                z___0 = (cfi->device_geometry.erase_block_regions + i___0)->erase_block_size;
#line 298
                y___0 = (cfi->device_geometry.erase_block_regions + i___0)->number_of_erase_blocks;
#line 299
                (cfi->device_geometry.erase_block_regions + i___0)->erase_block_size = (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->erase_block_size;
#line 301
                (cfi->device_geometry.erase_block_regions + i___0)->number_of_erase_blocks = (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->number_of_erase_blocks;
#line 303
                (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->erase_block_size = z___0;
#line 304
                (cfi->device_geometry.erase_block_regions + ((n - (uint32_t )i___0) - 1U))->number_of_erase_blocks = y___0;
#line 296
                i___0 ++;
              }
              while_break___3: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
    {
#line 312
    (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )(255 << d));
    }
    {
#line 322
    if ((int )cfi->device_geometry.device_interface == 0) {
#line 322
      goto case_0;
    }
#line 327
    if ((int )cfi->device_geometry.device_interface == 1) {
#line 327
      goto case_1;
    }
#line 333
    if ((int )cfi->device_geometry.device_interface == 2) {
#line 333
      goto case_2;
    }
#line 340
    if ((int )cfi->device_geometry.device_interface == 3) {
#line 340
      goto case_3;
    }
#line 346
    if ((int )cfi->device_geometry.device_interface == 4) {
#line 346
      goto case_4;
    }
#line 355
    goto switch_default;
    case_0: /* CIL Label */ 
#line 323
    if (ma != 1) {
#line 324
      return (-7);
    }
#line 325
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 1;
#line 326
    goto switch_break;
    case_1: /* CIL Label */ 
#line 328
    if (ma != 1) {
#line 329
      return (-7);
    }
#line 330
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2;
#line 331
    d += 8U;
#line 332
    goto switch_break;
    case_2: /* CIL Label */ 
#line 334
    if (ma != 1) {
#line 334
      if (ma != 2) {
#line 335
        return (-7);
      }
    }
#line 336
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 2 / ma;
#line 337
    if (ma == 1) {
#line 338
      d += 8U;
    }
#line 339
    goto switch_break;
    case_3: /* CIL Label */ 
#line 341
    if (ma != 1) {
#line 342
      return (-7);
    }
#line 343
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4;
#line 344
    d += 24U;
#line 345
    goto switch_break;
    case_4: /* CIL Label */ 
#line 347
    if (ma != 1) {
#line 347
      if (ma != 2) {
#line 348
        return (-7);
      }
    }
#line 349
    (*((*cfi_array___0)->cfi_chips + d / 8U))->width = 4 / ma;
#line 350
    if (ma == 1) {
#line 351
      d += 24U;
    } else {
#line 353
      d += 8U;
    }
#line 354
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 356
    return (-7);
    switch_break: /* CIL Label */ ;
    }
#line 92
    d += 8U;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return (0);
}
}
#line 463 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 46 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int dbg  =    0;
#line 48
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 49
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 51
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_address_shift(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 73
  if (cfi_array___0->bus_width == 4) {
#line 73
    return (2);
  }
  {
#line 80
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 1) {
#line 80
    goto case_1;
  }
#line 80
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 2) {
#line 80
    goto case_1;
  }
#line 84
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 3) {
#line 84
    goto case_3;
  }
#line 84
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 4) {
#line 84
    goto case_3;
  }
#line 87
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 81
  return (1);
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 85
  return (2);
  switch_default: /* CIL Label */ 
#line 87
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  if (cfi_array___0->bus_width == 2) {
#line 90
    return (1);
  }
#line 92
  return (0);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_autodetect32(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 99
  if (cfi_array___0->bus_width != 4) {
#line 99
    return (0);
  }
#line 100
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_autodetect16(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 106
  if (cfi_array___0->bus_width != 2) {
#line 106
    return (0);
  }
#line 107
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_autodetect8(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 113
  if (cfi_array___0->bus_width != 1) {
#line 113
    return (0);
  }
#line 114
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amdstatus(cfi_array_t *cfi_array___0 , uint32_t adr , int data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;

  {
#line 165
  bus___0 = cfi_array___0->bus;
#line 168
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 171
  timeout = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (timeout < 7000)) {
#line 171
      goto while_break;
    }
    {
#line 172
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 172
    data1 = tmp;
#line 173
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 173
    data2 = tmp___0;
    }
#line 177
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 178
      return (1);
    }
#line 182
    if (dbg) {
      {
#line 183
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    } else {
      {
#line 185
      printf((char const   */* __restrict  */)".");
      }
    }
    {
#line 186
    usleep((__useconds_t )100);
#line 171
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (0);
}
}
#line 262 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static void amd_flash_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 266
  bus___0 = cfi_array___0->bus;
#line 267
  tmp = amd_flash_address_shift(cfi_array___0);
#line 267
  o = tmp;
#line 269
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 270
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 271
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )9437328);
#line 272
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 272
  mid = (int )(tmp___0 & 65535U);
#line 273
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 273
  cid = (int )(tmp___1 & 65535U);
#line 274
  tmp___2 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o));
#line 274
  prot = (int )(tmp___2 & 255U);
#line 275
  amd_flash_read_array(cfi_array___0);
#line 276
  tmp___3 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 276
  printf((char const   */* __restrict  */)tmp___3);
  }
  {
#line 278
  if (mid == 1) {
#line 278
    goto case_1;
  }
#line 302
  if (mid == 31) {
#line 302
    goto case_31;
  }
#line 317
  if (mid == 32) {
#line 317
    goto case_32;
  }
#line 335
  if (mid == 194) {
#line 335
    goto case_194;
  }
#line 347
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 279
  printf((char const   */* __restrict  */)"AMD");
#line 280
  tmp___4 = gettext("\n\tChip: ");
#line 280
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 282
  if (cid == 73) {
#line 282
    goto case_73;
  }
#line 285
  if (cid == 147) {
#line 285
    goto case_147;
  }
#line 288
  if (cid == 79) {
#line 288
    goto case_79;
  }
#line 291
  if (cid == 8919) {
#line 291
    goto case_8919;
  }
#line 294
  if (cid == 8795) {
#line 294
    goto case_8795;
  }
#line 297
  goto switch_default;
  case_73: /* CIL Label */ 
  {
#line 283
  printf((char const   */* __restrict  */)"AM29LV160DB");
  }
#line 284
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 286
  printf((char const   */* __restrict  */)"Am29LV065D");
  }
#line 287
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 289
  printf((char const   */* __restrict  */)"Am29LV040B");
  }
#line 290
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 292
  printf((char const   */* __restrict  */)"Am29LV640D/Am29LV641D/Am29LV642D");
  }
#line 293
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 295
  printf((char const   */* __restrict  */)"Am29LV800B");
  }
#line 296
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 298
  tmp___5 = gettext("Unknown (ID 0x%04x)");
#line 298
  printf((char const   */* __restrict  */)tmp___5, cid);
  }
#line 299
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 301
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 303
  printf((char const   */* __restrict  */)"Atmel");
#line 304
  tmp___6 = gettext("\n\tChip: ");
#line 304
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 306
  if (cid == 466) {
#line 306
    goto case_466;
  }
#line 309
  if (cid == 470) {
#line 309
    goto case_470;
  }
#line 312
  goto switch_default___0;
  case_466: /* CIL Label */ 
  {
#line 307
  printf((char const   */* __restrict  */)"AT49BW642DT");
  }
#line 308
  goto switch_break___1;
  case_470: /* CIL Label */ 
  {
#line 310
  printf((char const   */* __restrict  */)"AT49BW642D");
  }
#line 311
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 313
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 313
  printf((char const   */* __restrict  */)tmp___7, cid);
  }
#line 314
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 316
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 318
  printf((char const   */* __restrict  */)"ST/Samsung");
#line 319
  tmp___8 = gettext("\n\tChip: ");
#line 319
  printf((char const   */* __restrict  */)tmp___8);
  }
  {
#line 321
  if (cid == 202) {
#line 321
    goto case_202;
  }
#line 324
  if (cid == 203) {
#line 324
    goto case_203;
  }
#line 327
  if (cid == 8941) {
#line 327
    goto case_8941;
  }
#line 330
  goto switch_default___1;
  case_202: /* CIL Label */ 
  {
#line 322
  printf((char const   */* __restrict  */)"M29W320DT");
  }
#line 323
  goto switch_break___2;
  case_203: /* CIL Label */ 
  {
#line 325
  printf((char const   */* __restrict  */)"M29W320DB");
  }
#line 326
  goto switch_break___2;
  case_8941: /* CIL Label */ 
  {
#line 328
  printf((char const   */* __restrict  */)"M29W640DT");
  }
#line 329
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 331
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 331
  printf((char const   */* __restrict  */)tmp___9, cid);
  }
#line 332
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 336
  printf((char const   */* __restrict  */)"Macronix");
#line 337
  tmp___10 = gettext("\n\tChip: ");
#line 337
  printf((char const   */* __restrict  */)tmp___10);
  }
  {
#line 339
  if (cid == 8777) {
#line 339
    goto case_8777;
  }
#line 342
  goto switch_default___2;
  case_8777: /* CIL Label */ 
  {
#line 340
  printf((char const   */* __restrict  */)"MX29LV160B");
  }
#line 341
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 343
  tmp___11 = gettext("Unknown (ID 0x%04x)");
#line 343
  printf((char const   */* __restrict  */)tmp___11, cid);
  }
#line 344
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 346
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 348
  tmp___12 = gettext("Unknown manufacturer (ID 0x%04x) Chip (ID 0x%04x)");
#line 348
  printf((char const   */* __restrict  */)tmp___12, mid, cid);
  }
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  tmp___13 = gettext("\n\tProtected: %04x\n");
#line 351
  printf((char const   */* __restrict  */)tmp___13, prot);
#line 354
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 355
  return;
}
}
#line 357 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 360
  bus___0 = cfi_array___0->bus;
#line 361
  tmp = amd_flash_address_shift(cfi_array___0);
#line 361
  o = tmp;
#line 363
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 367
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 368
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 369
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )8388736);
#line 370
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 371
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 372
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 374
  tmp___0 = amdstatus(cfi_array___0, adr, 65535);
  }
#line 374
  if (tmp___0) {
    {
#line 375
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 376
    amd_flash_read_array(cfi_array___0);
    }
#line 377
    return (0);
  }
  {
#line 379
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 381
  amd_flash_read_array(cfi_array___0);
  }
#line 383
  return (99);
}
}
#line 386 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 389
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 390
  return (0);
}
}
#line 393 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;

  {
  {
#line 397
  bus___0 = cfi_array___0->bus;
#line 398
  tmp = amd_flash_address_shift(cfi_array___0);
#line 398
  o = tmp;
  }
#line 400
  if (dbg) {
    {
#line 401
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 403
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 404
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 405
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )10485920);
#line 407
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 408
  status = amdstatus(cfi_array___0, adr, (int )data);
  }
#line 411
  return (! status);
}
}
#line 414 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static void amd_flash_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 418
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 419
  return;
}
}
#line 421 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
flash_driver_t amd_32_flash_driver  = 
#line 421
     {4U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV640D, 29LV641D, 29LV642D; 2x16 Bit",
    & amd_flash_autodetect32, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 433 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
flash_driver_t amd_16_flash_driver  = 
#line 433
     {2U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV800B; 1x16 Bit", & amd_flash_autodetect16,
    & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block, & amd_flash_program,
    & amd_flash_read_array};
#line 445 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
flash_driver_t amd_8_flash_driver  = 
#line 445
     {1U, "AMD/Fujitsu Standard Command Set", "supported: AMD 29LV160, AMD 29LV065D, AMD 29LV040B; 1x8 Bit",
    & amd_flash_autodetect8, & amd_flash_print_info, & amd_flash_erase_block, & amd_flash_unlock_block,
    & amd_flash_program, & amd_flash_read_array};
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
struct __anonstruct_var_forced_detection_991519274 var_forced_detection  ;
#line 77
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) ;
#line 78
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 79
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) ;
#line 80
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) ;
#line 81
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 82
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 83
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 85 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
int amd_detect(bus_t *bus___0 , uint32_t adr , cfi_array_t **cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  bus_area_t area ;
  cfi_query_structure_t *cfi ;
  void *tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  int tmp___2 ;
  unsigned int bw ;
  int ba ;
  int i ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
#line 92
  if (! cfi_array___0) {
#line 93
    return (-1);
  } else
#line 92
  if (! bus___0) {
#line 93
    return (-1);
  }
  {
#line 95
  tmp = calloc((size_t )1, sizeof(cfi_array_t ));
#line 95
  *cfi_array___0 = (cfi_array_t *)tmp;
  }
#line 96
  if (! *cfi_array___0) {
#line 97
    return (-2);
  }
  {
#line 99
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 100
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )170);
#line 101
  (*((bus___0->driver)->write))(bus___0, adr + 682U, (uint32_t )85);
#line 102
  (*((bus___0->driver)->write))(bus___0, adr + 1365U, (uint32_t )144);
#line 103
  tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 103
  mid = (int )tmp___0;
#line 104
  tmp___1 = (*((bus___0->driver)->read))(bus___0, adr + 1U);
#line 104
  did = (int )tmp___1;
#line 105
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )240);
#line 107
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_detect", mid,
         did);
  }
#line 108
  if (mid != 1) {
#line 109
    return (-1);
  }
  {
#line 113
  if (did == 164) {
#line 113
    goto case_164;
  }
#line 116
  if (did == 79) {
#line 116
    goto case_79;
  }
#line 120
  goto switch_default;
  case_164: /* CIL Label */ 
#line 114
  var_forced_detection.flash = 1UL;
#line 115
  goto switch_break;
  case_79: /* CIL Label */ 
#line 117
  var_forced_detection.flash = 1UL;
#line 118
  var_forced_detection.algorithm = (unsigned short)1;
#line 119
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 121
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 124
  (*cfi_array___0)->bus = bus___0;
#line 125
  (*cfi_array___0)->address = (uint32_t )0;
#line 126
  tmp___2 = (*((bus___0->driver)->area))(bus___0, adr, & area);
  }
#line 126
  if (tmp___2 != 0) {
#line 127
    return (-8);
  }
#line 128
  bw = area.width;
#line 130
  if (bw != 8U) {
#line 130
    if (bw != 16U) {
#line 130
      if (bw != 32U) {
#line 131
        return (-3);
      }
    }
  }
  {
#line 132
  ba = (int )(bw / 8U);
#line 132
  (*cfi_array___0)->bus_width = ba;
#line 133
  tmp___3 = calloc((size_t )ba, sizeof(cfi_chip_t *));
#line 133
  (*cfi_array___0)->cfi_chips = (cfi_chip_t **)tmp___3;
  }
#line 134
  if (! (*cfi_array___0)->cfi_chips) {
#line 135
    return (-2);
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < ba)) {
#line 136
      goto while_break;
    }
    {
#line 138
    tmp___4 = calloc((size_t )1, sizeof(cfi_chip_t ));
#line 138
    *((*cfi_array___0)->cfi_chips + i) = (cfi_chip_t *)tmp___4;
    }
#line 139
    if (! *((*cfi_array___0)->cfi_chips + i)) {
#line 140
      return (-2);
    }
    {
#line 141
    (*((*cfi_array___0)->cfi_chips + i))->width = 1;
#line 142
    cfi = & (*((*cfi_array___0)->cfi_chips + i))->cfi;
#line 144
    cfi->identification_string.pri_id_code = (uint16_t )0;
#line 145
    cfi->identification_string.pri_vendor_tbl = (void *)0;
#line 146
    cfi->identification_string.alt_id_code = (uint16_t )0;
#line 147
    cfi->identification_string.alt_vendor_tbl = (void *)0;
#line 149
    cfi->device_geometry.device_size = (uint32_t )524288;
#line 150
    cfi->device_geometry.device_interface = (uint16_t )0;
#line 151
    cfi->device_geometry.max_bytes_write = (uint32_t )32;
#line 152
    cfi->device_geometry.number_of_erase_regions = (uint8_t )1;
#line 153
    tmp___5 = malloc((unsigned long )cfi->device_geometry.number_of_erase_regions * sizeof(cfi_erase_block_region_t ));
#line 153
    cfi->device_geometry.erase_block_regions = (cfi_erase_block_region_t *)tmp___5;
    }
#line 155
    if (! cfi->device_geometry.erase_block_regions) {
#line 156
      return (-2);
    }
#line 158
    (cfi->device_geometry.erase_block_regions + i)->erase_block_size = (uint32_t )65536;
#line 159
    (cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks = (uint32_t )8;
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (0);
}
}
#line 166 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_autodetect(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 168
  return (var_forced_detection.flash == 1UL);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_status(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 177
  dq7mask = (unsigned short )(1 << 7);
#line 178
  dq5mask = (unsigned short )(1 << 5);
#line 179
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 181
  timeout = (short)0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((int )timeout < 1000)) {
#line 181
      goto while_break;
    }
    {
#line 183
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 183
    data1 = (unsigned short )(tmp & 255U);
    }
#line 184
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 185
      return (1);
    }
#line 187
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 189
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 189
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 190
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 192
        return (1);
      } else {
#line 196
        return (0);
      }
    }
    {
#line 199
    usleep((__useconds_t )50);
#line 181
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static void amd_29xx040_print_info(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 210
  bus___0 = cfi_array___0->bus;
#line 213
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 214
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 217
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 217
  mid = (int )tmp;
#line 218
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 218
  did = (int )tmp___0;
#line 219
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 219
  prot = (int )tmp___1;
#line 220
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 222
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 227
  if (mid == 1) {
#line 227
    goto case_1;
  }
#line 230
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 228
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 228
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 229
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 231
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 231
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp___4 = gettext("\n\tChip: ");
#line 234
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 236
  if (did == 164) {
#line 236
    goto case_164;
  }
#line 240
  if (did == 79) {
#line 240
    goto case_79;
  }
#line 244
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 237
  printf((char const   */* __restrict  */)"Am29C040B\t-\t");
#line 238
  tmp___5 = gettext("5V Flash\n");
#line 238
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 239
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 241
  printf((char const   */* __restrict  */)"Am29LV040B\t-\t");
#line 242
  tmp___6 = gettext("3V Flash\n");
#line 242
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 243
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 245
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 245
  printf((char const   */* __restrict  */)tmp___7, did);
  }
#line 246
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 248
  tmp___8 = gettext("\n\tProtected: %04x\n");
#line 248
  printf((char const   */* __restrict  */)tmp___8, prot);
  }
#line 249
  return;
}
}
#line 251 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static void amd_29xx040_read_array(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 254
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 256
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 257
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 258
    usleep((__useconds_t )100);
#line 259
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 261
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 262
  return;
}
}
#line 266 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_erase_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 268
  bus___0 = cfi_array___0->bus;
#line 270
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 274
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 276
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 277
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 278
    usleep((__useconds_t )100);
#line 279
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 282
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 283
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 289
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 292
  tmp = amd_29xx040_status(bus___0, adr, (unsigned short)255);
  }
#line 292
  if (tmp) {
    {
#line 293
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 294
    amd_29xx040_read_array(cfi_array___0);
    }
#line 295
    return (1);
  }
  {
#line 297
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 299
  amd_29xx040_read_array(cfi_array___0);
  }
#line 301
  return (-5);
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_program(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 307
  bus___0 = cfi_array___0->bus;
#line 311
  if ((int )var_forced_detection.algorithm == 1) {
#line 313
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 315
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 316
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 318
      usleep((__useconds_t )1000);
#line 319
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 324
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 325
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 329
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 330
  status = amd_29xx040_status(bus___0, adr, (unsigned short )data);
  }
#line 333
  return (! status);
}
}
#line 336 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_unlock_block(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 338
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 339
  return (0);
}
}
#line 343 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
flash_driver_t amd_29xx040_flash_driver  = 
#line 343
     {1U, "AMD Standard Command Set", "supported: AMD 29LV040B, 29C040B, 1x8 Bit", & amd_29xx040_autodetect,
    & amd_29xx040_print_info, & amd_29xx040_erase_block, & amd_29xx040_unlock_block,
    & amd_29xx040_program, & amd_29xx040_read_array};
#line 63 "../../include/usbconn.h"
int usbconn_open(usbconn_t *conn ) ;
#line 143 "../../include/cable.h"
void cable_wait(cable_t *cable ) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.h"
void generic_disconnect(cable_t *cable ) ;
#line 40
void generic_set_frequency(cable_t *cable , uint32_t new_frequency ) ;
#line 41
int generic_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 42
int generic_get_trst(cable_t *cable ) ;
#line 44
void generic_flush_using_transfer(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.h"
int generic_usbconn_connect(char **params , cable_t *cable ) ;
#line 32
void generic_usbconn_done(cable_t *cable ) ;
#line 33
void generic_usbconn_help(char const   *cablename ) ;
#line 34
void generic_usbconn_free(cable_t *cable ) ;
#line 291 "/usr/include/usb.h"
extern int usb_close(usb_dev_handle *dev ) ;
#line 304
extern int usb_bulk_write(usb_dev_handle *dev , int ep , char const   *bytes , int size ,
                          int timeout ) ;
#line 306
extern int usb_bulk_read(usb_dev_handle *dev , int ep , char *bytes , int size , int timeout ) ;
#line 312
extern int usb_control_msg(usb_dev_handle *dev , int requesttype , int request , int value ,
                           int index , char *bytes , int size , int timeout ) ;
#line 396 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int last_tdo  ;
#line 78 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_output_enable(struct usb_dev_handle *xpcu , int enable ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 80
  if (enable) {
#line 80
    tmp = 24;
  } else {
#line 80
    tmp = 16;
  }
  {
#line 80
  tmp___0 = usb_control_msg(xpcu, 64, 176, tmp, 0, (char *)((void *)0), 0, 1000);
  }
#line 80
  if (tmp___0 < 0) {
    {
#line 82
    perror("usb_control_msg(0x10/0x18)");
    }
#line 83
    return (-1);
  }
#line 86
  return (0);
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_bit_reverse(struct usb_dev_handle *xpcu , uint8_t bits_in , uint8_t *bits_out ) 
{ 
  int tmp ;

  {
  {
#line 93
  tmp = usb_control_msg(xpcu, 192, 176, 32, (int )bits_in, (char *)bits_out, 1, 1000);
  }
#line 93
  if (tmp < 0) {
    {
#line 95
    perror("usb_control_msg(0x20.x) (bit reverse)");
    }
#line 96
    return (-1);
  }
#line 99
  return (0);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_request_28(struct usb_dev_handle *xpcu , int value ) 
{ 
  int tmp ;

  {
  {
#line 108
  tmp = usb_control_msg(xpcu, 64, 176, 40, value, (char *)((void *)0), 0, 1000);
  }
#line 108
  if (tmp < 0) {
    {
#line 110
    perror("usb_control_msg(0x28.x)");
    }
#line 111
    return (-1);
  }
#line 114
  return (0);
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_write_gpio(struct usb_dev_handle *xpcu , uint8_t bits ) 
{ 
  int tmp ;

  {
  {
#line 121
  tmp = usb_control_msg(xpcu, 64, 176, 48, (int )bits, (char *)((void *)0), 0, 1000);
  }
#line 121
  if (tmp < 0) {
    {
#line 123
    perror("usb_control_msg(0x30.0x00) (write port E)");
    }
#line 124
    return (-1);
  }
#line 127
  return (0);
}
}
#line 132 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_read_gpio(struct usb_dev_handle *xpcu , uint8_t *bits ) 
{ 
  int tmp ;

  {
  {
#line 134
  tmp = usb_control_msg(xpcu, 192, 176, 56, 0, (char *)bits, 1, 1000);
  }
#line 134
  if (tmp < 0) {
    {
#line 136
    perror("usb_control_msg(0x38.0x00) (read port E)");
    }
#line 137
    return (-1);
  }
#line 140
  return (0);
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_read_cpld_version(struct usb_dev_handle *xpcu , uint16_t *buf ) 
{ 
  int tmp ;

  {
  {
#line 148
  tmp = usb_control_msg(xpcu, 192, 176, 80, 1, (char *)buf, 2, 1000);
  }
#line 148
  if (tmp < 0) {
    {
#line 150
    perror("usb_control_msg(0x50.1) (read_cpld_version)");
    }
#line 151
    return (-1);
  }
#line 153
  return (0);
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_read_firmware_version(struct usb_dev_handle *xpcu , uint16_t *buf ) 
{ 
  int tmp ;

  {
  {
#line 160
  tmp = usb_control_msg(xpcu, 192, 176, 80, 0, (char *)buf, 2, 1000);
  }
#line 160
  if (tmp < 0) {
    {
#line 162
    perror("usb_control_msg(0x50.0) (read_firmware_version)");
    }
#line 163
    return (-1);
  }
#line 166
  return (0);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
int xpcu_select_gpio(struct usb_dev_handle *xpcu , int int_or_ext ) 
{ 
  int tmp ;

  {
  {
#line 173
  tmp = usb_control_msg(xpcu, 64, 176, 82, int_or_ext, (char *)((void *)0), 0, 1000);
  }
#line 173
  if (tmp < 0) {
    {
#line 175
    perror("usb_control_msg(0x52.x) (select gpio)");
    }
#line 176
    return (-1);
  }
#line 179
  return (0);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpcu_shift(struct usb_dev_handle *xpcu , int reqno , int bits , int in_len ,
                      uint8_t *in , int out_len , uint8_t *out ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 228
  tmp = usb_control_msg(xpcu, 64, 176, reqno, bits, (char *)((void *)0), 0, 1000);
  }
#line 228
  if (tmp < 0) {
    {
#line 230
    perror("usb_control_msg(x.x) (shift)");
    }
#line 231
    return (-1);
  }
  {
#line 249
  tmp___2 = usb_bulk_write(xpcu, 2, (char const   *)((char *)in), in_len, 1000);
  }
#line 249
  if (tmp___2 < 0) {
    {
#line 251
    tmp___0 = __errno_location();
#line 251
    tmp___1 = strerror(*tmp___0);
#line 251
    printf((char const   */* __restrict  */)"\nusb_bulk_write error(shift): %s\n",
           tmp___1);
    }
#line 252
    return (-1);
  }
#line 255
  if (out_len > 0) {
#line 255
    if ((unsigned long )out != (unsigned long )((void *)0)) {
      {
#line 257
      tmp___5 = usb_bulk_read(xpcu, 134, (char *)out, out_len, 1000);
      }
#line 257
      if (tmp___5 < 0) {
        {
#line 259
        tmp___3 = __errno_location();
#line 259
        tmp___4 = strerror(*tmp___3);
#line 259
        printf((char const   */* __restrict  */)"\nusb_bulk_read error(shift): %s\n",
               tmp___4);
        }
#line 260
        return (-1);
      }
    }
  }
#line 273
  return (0);
}
}
#line 278 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpcu_common_init(cable_t *cable ) 
{ 
  int r ;
  uint16_t buf ;
  struct usb_dev_handle *xpcu ;
  int tmp ;

  {
  {
#line 285
  tmp = usbconn_open(cable->link.usb);
  }
#line 285
  if (tmp) {
#line 285
    return (-1);
  }
  {
#line 287
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 289
  r = xpcu_request_28(xpcu, 17);
  }
#line 290
  if (r >= 0) {
    {
#line 290
    r = xpcu_write_gpio(xpcu, (uint8_t )8);
    }
  }
#line 294
  if (r >= 0) {
    {
#line 294
    r = xpcu_read_firmware_version(xpcu, & buf);
    }
  }
#line 295
  if (r >= 0) {
    {
#line 297
    printf((char const   */* __restrict  */)"firmware version = 0x%04X (%u)\n", (int )buf,
           (int )buf);
    }
  }
#line 302
  if (r >= 0) {
    {
#line 302
    xpcu_read_cpld_version(xpcu, & buf);
    }
  }
#line 303
  if (r >= 0) {
    {
#line 305
    printf((char const   */* __restrict  */)"cable CPLD version = 0x%04X (%u)\n",
           (int )buf, (int )buf);
    }
#line 306
    if ((int )buf == 0) {
      {
#line 308
      printf((char const   */* __restrict  */)"Warning: version \'0\' can\'t be correct. Please try resetting the cable\n");
#line 309
      r = -1;
      }
    }
  }
#line 313
  if (r < 0) {
    {
#line 315
    usb_close(xpcu);
    }
  }
#line 318
  return (r);
}
}
#line 321 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_int_init(cable_t *cable ) 
{ 
  struct usb_dev_handle *xpcu ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 326
  tmp = xpcu_common_init(cable);
  }
#line 326
  if (tmp < 0) {
#line 326
    return (-1);
  }
  {
#line 328
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 329
  tmp___0 = xpcu_select_gpio(xpcu, 0);
  }
#line 329
  if (tmp___0 < 0) {
#line 329
    return (-1);
  }
#line 331
  return (0);
}
}
#line 334 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_ext_init(cable_t *cable ) 
{ 
  struct usb_dev_handle *xpcu ;
  uint8_t zero[2] ;
  int r ;

  {
  {
#line 338
  zero[0] = (uint8_t )0;
#line 338
  zero[1] = (uint8_t )0;
#line 341
  free(cable->params);
#line 342
  cable->params = (void *)0;
#line 344
  r = xpcu_common_init(cable);
  }
#line 346
  if (r < 0) {
#line 346
    return (r);
  }
  {
#line 348
  cable->params = malloc(sizeof(xpc_cable_params_t ));
  }
#line 349
  if ((unsigned long )cable->params == (unsigned long )((void *)0)) {
#line 349
    r = -1;
  }
#line 351
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 353
  if (r >= 0) {
    {
#line 353
    r = xpcu_request_28(xpcu, 17);
    }
  }
#line 354
  if (r >= 0) {
    {
#line 354
    r = xpcu_output_enable(xpcu, 1);
    }
  }
#line 355
  if (r >= 0) {
    {
#line 355
    r = xpcu_shift(xpcu, 166, 2, 2, zero, 0, (uint8_t *)((void *)0));
    }
  }
#line 356
  if (r >= 0) {
    {
#line 356
    r = xpcu_request_28(xpcu, 18);
    }
  }
#line 358
  if (r < 0) {
    {
#line 360
    usb_close(xpcu);
#line 362
    free(cable->params);
#line 363
    cable->params = (void *)0;
    }
  }
#line 366
  return (r);
}
}
#line 371 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_ext_done(cable_t *cable ) 
{ 
  struct usb_dev_handle *xpcu ;

  {
  {
#line 375
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 376
  xpcu_output_enable(xpcu, 0);
#line 377
  generic_usbconn_done(cable);
  }
#line 378
  return;
}
}
#line 382 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_ext_free(cable_t *cable ) 
{ 


  {
#line 385
  if (cable->params) {
    {
#line 387
    free(cable->params);
#line 388
    cable->params = (void *)0;
    }
  }
  {
#line 390
  generic_usbconn_free(cable);
  }
#line 391
  return;
}
}
#line 401 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  struct usb_dev_handle *xpcu ;
  int tmp ;

  {
#line 406
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 408
  if (tms) {
#line 408
    tms = 1 << 1;
  } else {
#line 408
    tms = 0;
  }
#line 409
  if (tdi) {
#line 409
    tdi = 1;
  } else {
#line 409
    tdi = 0;
  }
  {
#line 411
  tmp = xpcu_write_gpio(xpcu, (uint8_t )(((1 << 3) | tms) | tdi));
  }
#line 411
  if (tmp >= 0) {
    {
#line 413
    cable_wait(cable);
#line 414
    i = 0;
    }
    {
#line 414
    while (1) {
      while_continue: /* CIL Label */ ;
#line 414
      if (! (i < n)) {
#line 414
        goto while_break;
      }
      {
#line 416
      xpcu_write_gpio(xpcu, (uint8_t )((((1 << 3) | (1 << 2)) | tms) | tdi));
#line 417
      cable_wait(cable);
#line 418
      xpcu_write_gpio(xpcu, (uint8_t )(((1 << 3) | tms) | tdi));
#line 419
      cable_wait(cable);
#line 414
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 422
  return;
}
}
#line 426 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_get_tdo(cable_t *cable ) 
{ 
  unsigned char d ;
  struct usb_dev_handle *xpcu ;
  int tmp ;

  {
  {
#line 431
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 433
  xpcu_read_gpio(xpcu, & d);
  }
#line 434
  if ((int )d & 1) {
#line 434
    tmp = 1;
  } else {
#line 434
    tmp = 0;
  }
#line 434
  return (tmp);
}
}
#line 439 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 442
  return (1);
}
}
#line 447 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_ext_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  uint8_t tdo[2] ;
  uint8_t clock[2] ;
  struct usb_dev_handle *xpcu ;
  int tmp ;
  int tmp___0 ;

  {
#line 455
  if (tms) {
#line 455
    tmp = 16;
  } else {
#line 455
    tmp = 0;
  }
#line 455
  if (tdi) {
#line 455
    tmp___0 = 1;
  } else {
#line 455
    tmp___0 = 0;
  }
#line 455
  clock[0] = (uint8_t )(tmp | tmp___0);
#line 456
  clock[1] = (uint8_t )17;
#line 458
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 460
  i = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (i < n)) {
#line 460
      goto while_break;
    }
    {
#line 460
    xpcu_shift(xpcu, 166, 1, 2, clock, 2, tdo);
#line 460
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if (tdo[1]) {
#line 462
    last_tdo = 1;
  } else {
#line 462
    last_tdo = 0;
  }
#line 464
  return;
}
}
#line 468 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_ext_get_tdo(cable_t *cable ) 
{ 


  {
#line 471
  return (last_tdo);
}
}
#line 494 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpcu_do_ext_transfer(xpc_ext_transfer_state_t *xts ) 
{ 
  int r ;
  int in_len ;
  int out_len ;
  int out_idx ;
  int out_rem ;
  uint32_t mask ;
  uint32_t rxw ;

  {
#line 501
  in_len = 2 * (xts->in_bits >> 2);
#line 502
  if ((xts->in_bits & 3) != 0) {
#line 502
    in_len += 2;
  }
#line 504
  out_len = 2 * (xts->out_bits >> 4);
#line 505
  if ((xts->out_bits & 15) != 0) {
#line 505
    out_len += 2;
  }
#line 507
  if ((unsigned long )xts->out != (unsigned long )((void *)0)) {
    {
#line 509
    r = xpcu_shift(xts->xpcu, 166, xts->in_bits, in_len, xts->buf, out_len, xts->buf);
    }
  } else {
    {
#line 513
    r = xpcu_shift(xts->xpcu, 166, xts->in_bits, in_len, xts->buf, 0, (uint8_t *)((void *)0));
    }
  }
#line 516
  if (r >= 0) {
#line 516
    if (xts->out_bits > 0) {
#line 518
      out_idx = 0;
#line 519
      out_rem = xts->out_bits;
      {
#line 521
      while (1) {
        while_continue: /* CIL Label */ ;
#line 521
        if (! (out_rem > 0)) {
#line 521
          goto while_break;
        }
#line 525
        rxw = (uint32_t )(((int )xts->buf[out_idx + 1] << 8) | (int )xts->buf[out_idx]);
#line 529
        if (out_rem >= 16) {
#line 529
          mask = (uint32_t )1;
        } else {
#line 529
          mask = (uint32_t )(1 << (16 - out_rem));
        }
        {
#line 531
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 531
          if (mask <= 32768U) {
#line 531
            if (! (out_rem > 0)) {
#line 531
              goto while_break___0;
            }
          } else {
#line 531
            goto while_break___0;
          }
#line 533
          if (rxw & mask) {
#line 533
            last_tdo = 1;
          } else {
#line 533
            last_tdo = 0;
          }
#line 534
          *(xts->out + xts->out_done) = (uint8_t )last_tdo;
#line 535
          (xts->out_done) ++;
#line 536
          mask <<= 1;
#line 537
          out_rem --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 540
        out_idx += 2;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 544
  xts->in_bits = 0;
#line 545
  xts->out_bits = 0;
#line 549
  return (r);
}
}
#line 554 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpcu_add_bit_for_ext_transfer(xpc_ext_transfer_state_t *xts , char in ,
                                          char is_real ) 
{ 
  int bit_idx ;
  int buf_idx ;

  {
#line 557
  bit_idx = xts->in_bits & 3;
#line 558
  buf_idx = (xts->in_bits - bit_idx) >> 1;
#line 560
  if (bit_idx == 0) {
#line 562
    xts->buf[buf_idx] = (uint8_t )0;
#line 563
    xts->buf[buf_idx + 1] = (uint8_t )0;
  }
#line 566
  (xts->in_bits) ++;
#line 568
  if (is_real) {
#line 570
    if (in) {
#line 570
      xts->buf[buf_idx] = (uint8_t )((int )xts->buf[buf_idx] | (1 << bit_idx));
    }
#line 572
    if (xts->out) {
#line 574
      xts->buf[buf_idx + 1] = (uint8_t )((int )xts->buf[buf_idx + 1] | (17 << bit_idx));
#line 575
      (xts->out_bits) ++;
    } else {
#line 579
      xts->buf[buf_idx + 1] = (uint8_t )((int )xts->buf[buf_idx + 1] | (1 << bit_idx));
    }
  }
#line 582
  return;
}
}
#line 586 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_ext_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int j ;
  xpc_ext_transfer_state_t xts ;

  {
#line 600
  xts.xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 601
  xts.out = (uint8_t *)out;
#line 602
  xts.in_bits = 0;
#line 603
  xts.out_bits = 0;
#line 604
  xts.out_done = 0;
#line 605
  xts.cable = cable;
#line 607
  i = 0;
#line 607
  j = 0;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (i < len) {
#line 607
      if (! (j >= 0)) {
#line 607
        goto while_break;
      }
    } else {
#line 607
      goto while_break;
    }
    {
#line 609
    xpcu_add_bit_for_ext_transfer(& xts, *(in + i), (char)1);
    }
#line 610
    if (xts.in_bits == 15) {
      {
#line 612
      j = xpcu_do_ext_transfer(& xts);
      }
    }
#line 607
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  if (xts.in_bits > 0) {
#line 616
    if (j >= 0) {
#line 619
      if ((xts.in_bits & 3) == 0) {
        {
#line 621
        xpcu_add_bit_for_ext_transfer(& xts, (char)0, (char)0);
        }
      }
      {
#line 623
      j = xpcu_do_ext_transfer(& xts);
      }
    }
  }
#line 626
  return (j);
}
}
#line 632 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
cable_driver_t xpc_int_cable_driver  = 
#line 632
     {"xpc_int", "Xilinx Platform Cable USB internal chain", & generic_usbconn_connect,
    & generic_disconnect, & generic_usbconn_free, & xpc_int_init, & generic_usbconn_done,
    & generic_set_frequency, & xpc_clock, & xpc_get_tdo, & generic_transfer, & xpc_set_trst,
    & generic_get_trst, & generic_flush_using_transfer, & generic_usbconn_help};
#line 650 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
usbconn_cable_t usbconn_cable_xpc_int  =    {(char *)"xpc_int", (char *)((void *)0), (char *)"libusb", 1021, 8};
#line 658 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
cable_driver_t xpc_ext_cable_driver  = 
#line 658
     {"xpc_ext", "Xilinx Platform Cable USB external chain", & generic_usbconn_connect,
    & generic_disconnect, & xpc_ext_free, & xpc_ext_init, & xpc_ext_done, & generic_set_frequency,
    & xpc_ext_clock, & xpc_ext_get_tdo, & xpc_ext_transfer, & xpc_set_trst, & generic_get_trst,
    & generic_flush_using_transfer, & generic_usbconn_help};
#line 676 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
usbconn_cable_t usbconn_cable_xpc_ext  =    {(char *)"xpc_ext", (char *)((void *)0), (char *)"libusb", 1021, 8};
#line 53 "../../include/parport.h"
int parport_open(parport_t *port ) ;
#line 55
int parport_set_data(parport_t *port , uint8_t data ) ;
#line 56
int parport_get_data(parport_t *port ) ;
#line 57
int parport_get_status(parport_t *port ) ;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.h"
void generic_flush_one_by_one(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.h"
int generic_parport_connect(char **params , cable_t *cable ) ;
#line 32
void generic_parport_free(cable_t *cable ) ;
#line 33
void generic_parport_done(cable_t *cable ) ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static char const   *std_wgl_map  =    "7,4,3,2,1,#0";
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int map_pin(char *pin , int *act , int *inact ) 
{ 
  int bitnum ;
  int inverted ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 114
  inverted = 0;
#line 116
  if ((int )*pin == 35) {
#line 117
    inverted = 1;
#line 118
    pin ++;
  }
  {
#line 121
  tmp = __ctype_b_loc();
  }
#line 121
  if (! ((int const   )*(*tmp + (int )*pin) & 2048)) {
#line 122
    return (-1);
  }
  {
#line 124
  tmp___0 = atoi((char const   *)pin);
#line 124
  bitnum = tmp___0 % 8;
#line 126
  bitnum = 1 << bitnum;
  }
#line 128
  if (inverted) {
#line 128
    *act = 0;
  } else {
#line 128
    *act = bitnum;
  }
#line 129
  if (inverted) {
#line 129
    *inact = bitnum;
  } else {
#line 129
    *inact = 0;
  }
#line 131
  return (0);
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int set_mapping(char *bitmap , cable_t *cable ) 
{ 
  char delim ;
  int syntax ;
  char *tdo ;
  char *trst ;
  char *tdi ;
  char *tck ;
  char *tms ;
  char *srst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 138
  delim = (char )',';
#line 139
  syntax = 0;
#line 143
  tdo = bitmap;
#line 143
  if (tdo) {
    {
#line 144
    trst = strchr((char const   *)tdo, (int )delim);
    }
#line 144
    if (trst) {
      {
#line 145
      trst ++;
#line 146
      tdi = strchr((char const   *)trst, (int )delim);
      }
#line 146
      if (tdi) {
        {
#line 147
        tdi ++;
#line 148
        tck = strchr((char const   *)tdi, (int )delim);
        }
#line 148
        if (tck) {
          {
#line 149
          tck ++;
#line 150
          tms = strchr((char const   *)tck, (int )delim);
          }
#line 150
          if (tms) {
            {
#line 151
            tms ++;
#line 152
            srst = strchr((char const   *)tms, (int )delim);
            }
#line 152
            if (srst) {
#line 153
              srst ++;
#line 154
              syntax = 1;
            }
          }
        }
      }
    }
  }
#line 157
  if (! syntax) {
#line 158
    return (-1);
  }
  {
#line 160
  tmp = map_pin(tdo, & ((wiggler_params_t *)cable->params)->tdo_act, & ((wiggler_params_t *)cable->params)->tdo_inact);
  }
#line 160
  if (tmp != 0) {
#line 160
    return (-1);
  }
  {
#line 161
  tmp___0 = map_pin(trst, & ((wiggler_params_t *)cable->params)->trst_act, & ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 161
  if (tmp___0 != 0) {
#line 161
    return (-1);
  }
  {
#line 162
  tmp___1 = map_pin(tdi, & ((wiggler_params_t *)cable->params)->tdi_act, & ((wiggler_params_t *)cable->params)->tdi_inact);
  }
#line 162
  if (tmp___1 != 0) {
#line 162
    return (-1);
  }
  {
#line 163
  tmp___2 = map_pin(tck, & ((wiggler_params_t *)cable->params)->tck_act, & ((wiggler_params_t *)cable->params)->tck_inact);
  }
#line 163
  if (tmp___2 != 0) {
#line 163
    return (-1);
  }
  {
#line 164
  tmp___3 = map_pin(tms, & ((wiggler_params_t *)cable->params)->tms_act, & ((wiggler_params_t *)cable->params)->tms_inact);
  }
#line 164
  if (tmp___3 != 0) {
#line 164
    return (-1);
  }
  {
#line 165
  tmp___4 = map_pin(srst, & ((wiggler_params_t *)cable->params)->srst_act, & ((wiggler_params_t *)cable->params)->srst_inact);
  }
#line 165
  if (tmp___4 != 0) {
#line 165
    return (-1);
  }
#line 167
  return (0);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_connect(char **params , cable_t *cable ) 
{ 
  int result ;
  char *param_bitmap ;
  wiggler_params_t *wiggler_params ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 175
  param_bitmap = (char *)((void *)0);
#line 178
  tmp = cmd_params(params);
  }
#line 178
  if (tmp == 4) {
#line 180
    param_bitmap = *(params + 3);
#line 182
    *(params + 3) = (char *)((void *)0);
  }
  {
#line 185
  result = generic_parport_connect(params, cable);
  }
#line 185
  if (result != 0) {
#line 186
    return (result);
  }
#line 188
  if (param_bitmap) {
#line 189
    *(params + 3) = param_bitmap;
  }
  {
#line 191
  tmp___0 = malloc(sizeof(*wiggler_params));
#line 191
  wiggler_params = (wiggler_params_t *)tmp___0;
  }
#line 192
  if (! wiggler_params) {
    {
#line 193
    tmp___1 = gettext("%s(%d) malloc failed!\n");
#line 193
    printf((char const   */* __restrict  */)tmp___1, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c",
           193);
#line 199
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
    }
#line 200
    return (4);
  }
  {
#line 204
  free(cable->params);
#line 205
  cable->params = (void *)wiggler_params;
  }
#line 207
  if (! param_bitmap) {
#line 208
    param_bitmap = (char *)std_wgl_map;
  }
  {
#line 210
  result = set_mapping(param_bitmap, cable);
  }
#line 210
  if (result != 0) {
    {
#line 211
    tmp___2 = gettext("Pin mapping failed\n");
#line 211
    printf((char const   */* __restrict  */)tmp___2);
#line 217
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
#line 218
    free(cable->params);
    }
#line 219
    return (result);
  }
#line 224
  ((wiggler_params_t *)cable->params)->unused_bits = ~ (((((((((((wiggler_params_t *)cable->params)->srst_act | ((wiggler_params_t *)cable->params)->srst_inact) | ((wiggler_params_t *)cable->params)->tms_act) | ((wiggler_params_t *)cable->params)->tms_inact) | ((wiggler_params_t *)cable->params)->tck_act) | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->tdi_act) | ((wiggler_params_t *)cable->params)->tdi_inact) | ((wiggler_params_t *)cable->params)->trst_act) | ((wiggler_params_t *)cable->params)->trst_inact) & 255;
#line 230
  return (0);
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 238
  tmp = parport_open(cable->link.port);
  }
#line 238
  if (tmp) {
#line 239
    return (-1);
  }
  {
#line 241
  data = parport_get_data(cable->link.port);
  }
#line 241
  if (data < 0) {
    {
#line 242
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
    }
#line 242
    if (tmp___0) {
#line 243
      return (-1);
    }
#line 244
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact;
  } else {
#line 246
    ((wiggler_params_t *)cable->params)->trst_lvl = data & (((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 248
  return (0);
}
}
#line 251 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static void wiggler_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 256
  if (tms) {
#line 256
    tms = 1;
  } else {
#line 256
    tms = 0;
  }
#line 257
  if (tdi) {
#line 257
    tdi = 1;
  } else {
#line 257
    tdi = 0;
  }
#line 259
  i = 0;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i < n)) {
#line 259
      goto while_break;
    }
#line 260
    if (tms) {
#line 260
      tmp = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 260
      tmp = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 260
    if (tdi) {
#line 260
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 260
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 260
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | tmp) | tmp___0) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 265
    cable_wait(cable);
    }
#line 266
    if (tms) {
#line 266
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 266
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 266
    if (tdi) {
#line 266
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 266
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 266
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_act) | tmp___1) | tmp___2) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 271
    cable_wait(cable);
#line 259
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_get_tdo(cable_t *cable ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 278
  parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 281
  cable_wait(cable);
#line 282
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 282
  if ((tmp___1 & (((wiggler_params_t *)cable->params)->tdo_act | ((wiggler_params_t *)cable->params)->tdo_inact)) ^ ((wiggler_params_t *)cable->params)->tdo_act) {
#line 282
    tmp___0 = 0;
  } else {
#line 282
    tmp___0 = 1;
  }
#line 282
  return (tmp___0);
}
}
#line 286 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
#line 289
  if (trst) {
#line 289
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act;
  } else {
#line 289
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_inact;
  }
  {
#line 291
  parport_set_data(cable->link.port, (uint8_t )(((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->unused_bits));
  }
#line 293
  if (((wiggler_params_t *)cable->params)->trst_lvl ^ ((wiggler_params_t *)cable->params)->trst_act) {
#line 293
    tmp = 0;
  } else {
#line 293
    tmp = 1;
  }
#line 293
  return (tmp);
}
}
#line 296 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_get_trst(cable_t *cable ) 
{ 
  int tmp ;

  {
#line 299
  if (((wiggler_params_t *)cable->params)->trst_lvl ^ ((wiggler_params_t *)cable->params)->trst_act) {
#line 299
    tmp = 0;
  } else {
#line 299
    tmp = 1;
  }
#line 299
  return (tmp);
}
}
#line 302 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static void wiggler_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 305
  tmp = gettext("Usage: cable %s parallel PORTADDR [TDO,TRST,TDI,TCK,TMS,SRESET]\n   or: cable %s ppdev PPDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEV      ppdev device (e.g. /dev/parport0)\nTDO, ...   parallel port bit number, prepend \'#\' for inversion\n           default is \'%s\'\n\n");
#line 305
  printf((char const   */* __restrict  */)tmp, cablename, cablename, std_wgl_map);
  }
#line 334
  return;
}
}
#line 336 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
cable_driver_t wiggler_cable_driver  = 
#line 336
     {"WIGGLER", "Macraigor Wiggler JTAG Cable", & wiggler_connect, & generic_disconnect,
    & generic_parport_free, & wiggler_init, & generic_parport_done, & generic_set_frequency,
    & wiggler_clock, & wiggler_get_tdo, & generic_transfer, & wiggler_set_trst, & wiggler_get_trst,
    & generic_flush_one_by_one, & wiggler_help};
#line 354 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
cable_driver_t igloo_cable_driver  = 
#line 354
     {"IGLOO", "Excelpoint IGLOO JTAG Cable", & wiggler_connect, & generic_disconnect,
    & generic_parport_free, & wiggler_init, & generic_parport_done, & generic_set_frequency,
    & wiggler_clock, & wiggler_get_tdo, & generic_transfer, & wiggler_set_trst, & wiggler_get_trst,
    & generic_flush_one_by_one, & wiggler_help};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.h"
void generic_parport_help(char const   *cablename ) ;
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static int wiggler2_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  tmp = parport_open(cable->link.port);
  }
#line 73
  if (tmp) {
#line 74
    return (-1);
  }
  {
#line 76
  data = parport_get_data(cable->link.port);
  }
#line 76
  if (data < 0) {
    {
#line 77
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255));
    }
#line 77
    if (tmp___0) {
#line 78
      return (-1);
    }
#line 79
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 81
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 83
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static void wiggler2_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 91
  if (tms) {
#line 91
    tms = 1;
  } else {
#line 91
    tms = 0;
  }
#line 92
  if (tdi) {
#line 92
    tdi = 1;
  } else {
#line 92
    tdi = 0;
  }
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < n)) {
#line 94
      goto while_break;
    }
    {
#line 95
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 96
    cable_wait(cable);
#line 97
    parport_set_data(cable->link.port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 4) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 98
    cable_wait(cable);
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static int wiggler2_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 105
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 106
  cable_wait(cable);
#line 107
  tmp = parport_get_status(cable->link.port);
  }
#line 107
  return ((tmp >> 7) & 1);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static int wiggler2_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 113
  if (trst) {
#line 113
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 113
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 115
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
  }
#line 116
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
cable_driver_t wiggler2_cable_driver  = 
#line 119
     {"WIGGLER2", "Modified (with CPU Reset) WIGGLER JTAG Cable", & generic_parport_connect,
    & generic_disconnect, & generic_parport_free, & wiggler2_init, & generic_parport_done,
    & generic_set_frequency, & wiggler2_clock, & wiggler2_get_tdo, & generic_transfer,
    & wiggler2_set_trst, & generic_get_trst, & generic_flush_one_by_one, & generic_parport_help};
#line 64 "../../include/usbconn.h"
int usbconn_close(usbconn_t *conn ) ;
#line 65
int usbconn_read(usbconn_t *conn , uint8_t *buf , int len ) ;
#line 66
int usbconn_write(usbconn_t *conn , uint8_t *buf , int len , int recv ) ;
#line 67
usbconn_driver_t *usbconn_drivers[2] ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn.c"
usbconn_driver_t usbconn_libusb_driver ;
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn.c"
usbconn_driver_t *usbconn_drivers[2]  = {      & usbconn_libusb_driver,      (usbconn_driver_t *)((void *)0)};
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn.c"
int usbconn_open(usbconn_t *conn ) 
{ 
  int tmp ;

  {
  {
#line 61
  tmp = (*((conn->driver)->open))(conn);
  }
#line 61
  return (tmp);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn.c"
int usbconn_close(usbconn_t *conn ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = (*((conn->driver)->close))(conn);
  }
#line 67
  return (tmp);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn.c"
int usbconn_read(usbconn_t *conn , uint8_t *buf , int len ) 
{ 
  int tmp ;

  {
#line 73
  if ((conn->driver)->read) {
    {
#line 74
    tmp = (*((conn->driver)->read))(conn, buf, len);
    }
#line 74
    return (tmp);
  } else {
#line 76
    return (0);
  }
}
}
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn.c"
int usbconn_write(usbconn_t *conn , uint8_t *buf , int len , int recv ) 
{ 
  int tmp ;

  {
#line 82
  if ((conn->driver)->write) {
    {
#line 83
    tmp = (*((conn->driver)->write))(conn, buf, len, recv);
    }
#line 83
    return (tmp);
  } else {
#line 85
    return (0);
  }
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static int triton_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 72
  tmp = parport_open(cable->link.port);
  }
#line 72
  if (tmp) {
#line 73
    return (-1);
  }
#line 75
  ((generic_params_t *)cable->params)->trst = 1;
#line 76
  ((generic_params_t *)cable->params)->sreset = 1;
#line 78
  return (0);
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static void triton_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 86
  if (tms) {
#line 86
    tms = 1;
  } else {
#line 86
    tms = 0;
  }
#line 87
  if (tdi) {
#line 87
    tdi = 1;
  } else {
#line 87
    tdi = 0;
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < n)) {
#line 89
      goto while_break;
    }
    {
#line 90
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | (tms << 2)) | (tdi << 1)));
#line 91
    cable_wait(cable);
#line 92
    parport_set_data(cable->link.port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | 1) | (tms << 2)) | (tdi << 1)));
#line 93
    cable_wait(cable);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static int triton_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 100
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
#line 101
  cable_wait(cable);
#line 102
  tmp = parport_get_status(cable->link.port);
  }
#line 102
  return ((tmp >> 7) & 1);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static int triton_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 108
  if (trst) {
#line 108
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 108
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 110
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
  }
#line 111
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
cable_driver_t triton_cable_driver  = 
#line 114
     {"TRITON", "Ka-Ro TRITON Starterkit II (PXA255/250) JTAG Cable", & generic_parport_connect,
    & generic_disconnect, & generic_parport_free, & triton_init, & generic_parport_done,
    & generic_set_frequency, & triton_clock, & triton_get_tdo, & generic_transfer,
    & triton_set_trst, & generic_get_trst, & generic_flush_one_by_one, & generic_parport_help};
#line 78 "../../include/part.h"
void parts_set_instruction(parts_t *ps , char const   *iname ) ;
#line 130 "../../include/cable.h"
int cable_get_tdo_late(cable_t *cable ) ;
#line 131
int cable_defer_get_tdo(cable_t *cable ) ;
#line 138
int cable_transfer_late(cable_t *cable , char *out ) ;
#line 139
int cable_defer_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 53 "../../include/chain.h"
void chain_defer_clock(chain_t *chain , int tms , int tdi , int n ) ;
#line 31 "../../include/tap.h"
void tap_reset(chain_t *chain ) ;
#line 34
void tap_capture_ir(chain_t *chain ) ;
#line 35
void tap_defer_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                              int exit___0 ) ;
#line 36
void tap_shift_register_output(chain_t *chain , tap_register const   *in , tap_register *out ,
                               int exit___0 ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_reset(chain_t *chain ) 
{ 


  {
  {
#line 37
  tap_state_reset(chain);
#line 39
  chain_clock(chain, 1, 0, 5);
#line 40
  chain_clock(chain, 0, 0, 1);
  }
#line 41
  return;
}
}
#line 43 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_reset_bypass(chain_t *chain ) 
{ 
  tap_register *ir ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 46
  tap_reset(chain);
  }
#line 50
  if (chain->total_instr_len > 0) {
    {
#line 51
    tmp = register_alloc(chain->total_instr_len);
#line 51
    tmp___0 = register_fill(tmp, 1);
#line 51
    ir = tmp___0;
    }
#line 52
    if (! ir) {
      {
#line 53
      tmp___1 = gettext("out of memory\n");
#line 53
      printf((char const   */* __restrict  */)tmp___1);
      }
#line 54
      return;
    }
    {
#line 57
    tap_capture_ir(chain);
#line 58
    tap_shift_register(chain, (tap_register const   *)ir, (tap_register *)((void *)0),
                       1);
#line 59
    register_free(ir);
#line 61
    parts_set_instruction(chain->parts, "BYPASS");
    }
  }
#line 63
  return;
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_defer_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                              int exit___0 ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 70
  tmp___1 = tap_state(chain);
  }
#line 70
  if (! (tmp___1 & (1 << 2))) {
    {
#line 71
    tmp = tap_state(chain);
#line 71
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 71
    printf((char const   */* __restrict  */)tmp___0, "tap_shift_register", tmp);
    }
  }
  {
#line 74
  tmp___2 = tap_state(chain);
  }
#line 74
  if (tmp___2 & (1 << 4)) {
    {
#line 75
    chain_defer_clock(chain, 0, 0, 1);
    }
  }
#line 77
  i = (int )in->len;
#line 78
  if (exit___0) {
#line 78
    i --;
  }
#line 79
  if (out) {
#line 79
    if (out->len < i) {
#line 79
      i = out->len;
    }
  }
#line 81
  if (out) {
    {
#line 82
    cable_defer_transfer(chain->cable, i, (char *)in->data, out->data);
    }
  } else {
    {
#line 84
    cable_defer_transfer(chain->cable, i, (char *)in->data, (char *)((void *)0));
    }
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < (int )in->len)) {
#line 86
      goto while_break;
    }
#line 87
    if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 87
      if (i < out->len) {
        {
#line 88
        tmp___3 = cable_defer_get_tdo(chain->cable);
#line 88
        *(out->data + i) = (char )tmp___3;
        }
      }
    }
#line 89
    if (exit___0 != 0) {
#line 89
      if (i + 1 == (int )in->len) {
#line 89
        tmp___4 = 1;
      } else {
#line 89
        tmp___4 = 0;
      }
    } else {
#line 89
      tmp___4 = 0;
    }
    {
#line 89
    chain_defer_clock(chain, tmp___4, (int )*(in->data + i), 1);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 93
  if (exit___0 == 1) {
    {
#line 94
    chain_defer_clock(chain, 1, 0, 1);
#line 95
    chain_defer_clock(chain, 0, 0, 1);
    }
  } else
#line 96
  if (exit___0 == 3) {
    {
#line 97
    chain_defer_clock(chain, 1, 0, 1);
    }
  }
#line 98
  return;
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_shift_register_output(chain_t *chain , tap_register const   *in , tap_register *out ,
                               int exit___0 ) 
{ 
  int j ;
  int tmp ;

  {
#line 103
  if ((unsigned long )out != (unsigned long )((void *)0)) {
#line 107
    j = (int )in->len;
#line 108
    if (exit___0) {
#line 108
      j --;
    }
#line 109
    if (out) {
#line 109
      if (out->len < j) {
#line 109
        j = out->len;
      }
    }
    {
#line 114
    cable_transfer_late(chain->cable, out->data);
    }
    {
#line 115
    while (1) {
      while_continue: /* CIL Label */ ;
#line 115
      if (j < (int )in->len) {
#line 115
        if (! (j < out->len)) {
#line 115
          goto while_break;
        }
      } else {
#line 115
        goto while_break;
      }
      {
#line 116
      tmp = cable_get_tdo_late(chain->cable);
#line 116
      *(out->data + j) = (char )tmp;
#line 115
      j ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 118
  return;
}
}
#line 120 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_shift_register(chain_t *chain , tap_register const   *in , tap_register *out ,
                        int exit___0 ) 
{ 


  {
  {
#line 123
  tap_defer_shift_register(chain, in, out, exit___0);
#line 124
  tap_shift_register_output(chain, in, out, exit___0);
  }
#line 125
  return;
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_capture_dr(chain_t *chain ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 130
  tmp___1 = tap_state(chain);
  }
#line 130
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 131
    tmp = tap_state(chain);
#line 131
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 131
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_dr", tmp);
    }
  }
  {
#line 134
  chain_defer_clock(chain, 1, 0, 1);
#line 135
  chain_defer_clock(chain, 0, 0, 1);
  }
#line 136
  return;
}
}
#line 138 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/tap.c"
void tap_capture_ir(chain_t *chain ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 141
  tmp___1 = tap_state(chain);
  }
#line 141
  if ((tmp___1 & ((1 << 7) | (1 << 3))) != 1 << 3) {
    {
#line 142
    tmp = tap_state(chain);
#line 142
    tmp___0 = gettext("%s: Invalid state: %2X\n");
#line 142
    printf((char const   */* __restrict  */)tmp___0, "tap_capture_ir", tmp);
    }
  }
  {
#line 145
  chain_defer_clock(chain, 1, 0, 2);
#line 146
  chain_defer_clock(chain, 0, 0, 1);
  }
#line 147
  return;
}
}
#line 60 "../../include/state.h"
int tap_state_init(chain_t *chain ) ;
#line 61
int tap_state_done(chain_t *chain ) ;
#line 63
int tap_state_set_trst(chain_t *chain , int old_trst , int new_trst ) ;
#line 64
int tap_state_clock(chain_t *chain , int tms ) ;
#line 29 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/state.c"
int tap_state(chain_t *chain ) 
{ 


  {
#line 32
  return (chain->state);
}
}
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/state.c"
int tap_state_init(chain_t *chain ) 
{ 
  int tmp ;

  {
#line 38
  tmp = 1 << 7;
#line 38
  chain->state = tmp;
#line 38
  return (tmp);
}
}
#line 41 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/state.c"
int tap_state_done(chain_t *chain ) 
{ 
  int tmp ;

  {
#line 44
  tmp = 1 << 7;
#line 44
  chain->state = tmp;
#line 44
  return (tmp);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/state.c"
int tap_state_reset(chain_t *chain ) 
{ 
  int tmp ;

  {
#line 50
  tmp = (1 << 7) | (1 << 3);
#line 50
  chain->state = tmp;
#line 50
  return (tmp);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/state.c"
int tap_state_set_trst(chain_t *chain , int old_trst , int new_trst ) 
{ 


  {
#line 56
  if (old_trst) {
#line 56
    old_trst = 1;
  } else {
#line 56
    old_trst = 0;
  }
#line 57
  if (new_trst) {
#line 57
    new_trst = 1;
  } else {
#line 57
    new_trst = 0;
  }
#line 59
  if (old_trst != new_trst) {
#line 60
    if (new_trst) {
#line 61
      chain->state = (1 << 7) | (1 << 3);
    } else {
#line 63
      chain->state = 1 << 7;
    }
  }
#line 66
  return (chain->state);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/state.c"
int tap_state_clock(chain_t *chain , int tms ) 
{ 


  {
#line 72
  if (tms) {
    {
#line 74
    if (chain->state == ((1 << 7) | (1 << 3))) {
#line 74
      goto case_exp;
    }
#line 78
    if (chain->state == ((1 << 1) | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain->state == (1 | (1 << 3))) {
#line 78
      goto case_exp___0;
    }
#line 78
    if (chain->state == 1 << 3) {
#line 78
      goto case_exp___0;
    }
#line 81
    if (chain->state == 1) {
#line 81
      goto case_1;
    }
#line 85
    if (chain->state == (1 | (1 << 2))) {
#line 85
      goto case_exp___3;
    }
#line 85
    if (chain->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 85
      goto case_exp___3;
    }
#line 89
    if (chain->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 89
      goto case_exp___5;
    }
#line 89
    if (chain->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 89
      goto case_exp___5;
    }
#line 92
    if (chain->state == (1 | (1 << 6))) {
#line 92
      goto case_exp___7;
    }
#line 95
    if (chain->state == 1 << 1) {
#line 95
      goto case_exp___8;
    }
#line 99
    if (chain->state == ((1 << 1) | (1 << 2))) {
#line 99
      goto case_exp___9;
    }
#line 99
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 99
      goto case_exp___9;
    }
#line 103
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 103
      goto case_exp___11;
    }
#line 103
    if (chain->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 103
      goto case_exp___11;
    }
#line 106
    if (chain->state == ((1 << 1) | (1 << 6))) {
#line 106
      goto case_exp___13;
    }
#line 109
    goto switch_default;
    case_exp: /* CIL Label */ 
#line 75
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
    case_exp___2: /* CIL Label */ 
#line 79
    chain->state = 1;
#line 80
    goto switch_break;
    case_1: /* CIL Label */ 
#line 82
    chain->state = 1 << 1;
#line 83
    goto switch_break;
    case_exp___3: /* CIL Label */ 
    case_exp___4: /* CIL Label */ 
#line 86
    chain->state = (1 | (1 << 5)) | (1 << 6);
#line 87
    goto switch_break;
    case_exp___5: /* CIL Label */ 
    case_exp___6: /* CIL Label */ 
#line 90
    chain->state = 1 | (1 << 3);
#line 91
    goto switch_break;
    case_exp___7: /* CIL Label */ 
#line 93
    chain->state = (1 | (1 << 2)) | (1 << 5);
#line 94
    goto switch_break;
    case_exp___8: /* CIL Label */ 
#line 96
    chain->state = (1 << 7) | (1 << 3);
#line 97
    goto switch_break;
    case_exp___9: /* CIL Label */ 
    case_exp___10: /* CIL Label */ 
#line 100
    chain->state = ((1 << 1) | (1 << 5)) | (1 << 6);
#line 101
    goto switch_break;
    case_exp___11: /* CIL Label */ 
    case_exp___12: /* CIL Label */ 
#line 104
    chain->state = (1 << 1) | (1 << 3);
#line 105
    goto switch_break;
    case_exp___13: /* CIL Label */ 
#line 107
    chain->state = ((1 << 1) | (1 << 2)) | (1 << 5);
#line 108
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 110
    chain->state = 1 << 7;
#line 111
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 118
    if (chain->state == ((1 << 1) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain->state == (1 | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain->state == 1 << 3) {
#line 118
      goto case_exp___14;
    }
#line 118
    if (chain->state == ((1 << 7) | (1 << 3))) {
#line 118
      goto case_exp___14;
    }
#line 121
    if (chain->state == 1) {
#line 121
      goto case_1___0;
    }
#line 126
    if (chain->state == ((1 | (1 << 2)) | (1 << 5))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain->state == (1 | (1 << 2))) {
#line 126
      goto case_exp___18;
    }
#line 126
    if (chain->state == ((1 | (1 << 2)) | (1 << 4))) {
#line 126
      goto case_exp___18;
    }
#line 130
    if (chain->state == (1 | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 130
    if (chain->state == ((1 | (1 << 5)) | (1 << 6))) {
#line 130
      goto case_exp___21;
    }
#line 133
    if (chain->state == 1 << 1) {
#line 133
      goto case_exp___23;
    }
#line 138
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 5))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain->state == ((1 << 1) | (1 << 2))) {
#line 138
      goto case_exp___24;
    }
#line 138
    if (chain->state == (((1 << 1) | (1 << 2)) | (1 << 4))) {
#line 138
      goto case_exp___24;
    }
#line 142
    if (chain->state == ((1 << 1) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 142
    if (chain->state == (((1 << 1) | (1 << 5)) | (1 << 6))) {
#line 142
      goto case_exp___27;
    }
#line 145
    goto switch_default___0;
    case_exp___14: /* CIL Label */ 
    case_exp___15: /* CIL Label */ 
    case_exp___16: /* CIL Label */ 
    case_exp___17: /* CIL Label */ 
#line 119
    chain->state = 1 << 3;
#line 120
    goto switch_break___0;
    case_1___0: /* CIL Label */ 
#line 122
    chain->state = (1 | (1 << 2)) | (1 << 4);
#line 123
    goto switch_break___0;
    case_exp___18: /* CIL Label */ 
    case_exp___19: /* CIL Label */ 
    case_exp___20: /* CIL Label */ 
#line 127
    chain->state = 1 | (1 << 2);
#line 128
    goto switch_break___0;
    case_exp___21: /* CIL Label */ 
    case_exp___22: /* CIL Label */ 
#line 131
    chain->state = 1 | (1 << 6);
#line 132
    goto switch_break___0;
    case_exp___23: /* CIL Label */ 
#line 134
    chain->state = ((1 << 1) | (1 << 2)) | (1 << 4);
#line 135
    goto switch_break___0;
    case_exp___24: /* CIL Label */ 
    case_exp___25: /* CIL Label */ 
    case_exp___26: /* CIL Label */ 
#line 139
    chain->state = (1 << 1) | (1 << 2);
#line 140
    goto switch_break___0;
    case_exp___27: /* CIL Label */ 
    case_exp___28: /* CIL Label */ 
#line 143
    chain->state = (1 << 1) | (1 << 6);
#line 144
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 146
    chain->state = 1 << 7;
#line 147
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 151
  return (chain->state);
}
}
#line 36 "../../include/register.h"
tap_register *register_duplicate(tap_register const   *tr ) ;
#line 40
int register_all_bits_same_value(tap_register const   *tr ) ;
#line 42
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) ;
#line 43
int register_match(tap_register const   *tr , char const   *expr ) ;
#line 44
tap_register *register_inc(tap_register *tr ) ;
#line 45
tap_register *register_dec(tap_register *tr ) ;
#line 46
tap_register *register_shift_right(tap_register *tr , int shift ) ;
#line 47
tap_register *register_shift_left(tap_register *tr , int shift ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_alloc(int len ) 
{ 
  tap_register *tr ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 35
  if (len < 1) {
#line 36
    return ((tap_register *)((void *)0));
  }
  {
#line 38
  tmp = malloc(sizeof(tap_register ));
#line 38
  tr = (tap_register *)tmp;
  }
#line 39
  if (! tr) {
#line 40
    return ((tap_register *)((void *)0));
  }
  {
#line 42
  tmp___0 = malloc((size_t )len);
#line 42
  tr->data = (char *)tmp___0;
  }
#line 43
  if (! tr->data) {
    {
#line 44
    free((void *)tr);
    }
#line 45
    return ((tap_register *)((void *)0));
  }
  {
#line 48
  memset((void *)tr->data, 0, (size_t )len);
#line 50
  tmp___1 = malloc((size_t )(len + 1));
#line 50
  tr->string = (char *)tmp___1;
  }
#line 51
  if (! tr->string) {
    {
#line 52
    free((void *)tr->data);
#line 53
    free((void *)tr);
    }
#line 54
    return ((tap_register *)((void *)0));
  }
#line 57
  tr->len = len;
#line 58
  *(tr->string + len) = (char )'\000';
#line 60
  return (tr);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_duplicate(tap_register const   *tr ) 
{ 
  char const   *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;

  {
#line 66
  if (! tr) {
#line 67
    return ((tap_register *)((void *)0));
  }
  {
#line 69
  tmp = register_get_string(tr);
#line 69
  tmp___0 = register_alloc((int )tr->len);
#line 69
  tmp___1 = register_init(tmp___0, tmp);
  }
#line 69
  return (tmp___1);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
void register_free(tap_register *tr ) 
{ 


  {
#line 75
  if (tr) {
    {
#line 76
    free((void *)tr->data);
#line 77
    free((void *)tr->string);
    }
  }
  {
#line 79
  free((void *)tr);
  }
#line 80
  return;
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_fill(tap_register *tr , int val ) 
{ 


  {
#line 85
  if (tr) {
    {
#line 86
    memset((void *)tr->data, val & 1, (size_t )tr->len);
    }
  }
#line 88
  return (tr);
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
char const   *register_get_string(tap_register const   *tr ) 
{ 
  int i ;

  {
#line 96
  if (! tr) {
#line 97
    return ((char const   *)((void *)0));
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < (int )tr->len)) {
#line 99
      goto while_break;
    }
#line 100
    if ((int )*(tr->data + i) & 1) {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'1';
    } else {
#line 100
      *(tr->string + ((tr->len - 1) - (int const   )i)) = (char )'0';
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  return ((char const   *)tr->string);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
int register_all_bits_same_value(tap_register const   *tr ) 
{ 
  int i ;
  int value ;

  {
#line 109
  if (! tr) {
#line 109
    return (-1);
  }
#line 110
  if (tr->len < 0) {
#line 110
    return (-1);
  }
#line 115
  value = (int )*(tr->data + 0) & 1;
#line 117
  i = 1;
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! (i < (int )tr->len)) {
#line 117
      goto while_break;
    }
#line 119
    if (((int )*(tr->data + i) & 1) != value) {
#line 119
      return (-1);
    }
#line 117
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (value);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_init(tap_register *tr , char const   *value ) 
{ 
  int i ;
  char const   *p ;
  char *tmp ;

  {
#line 131
  if (! value) {
#line 132
    return (tr);
  } else
#line 131
  if (! tr) {
#line 132
    return (tr);
  }
  {
#line 134
  tmp = strchr(value, '\000');
#line 134
  p = (char const   *)tmp;
#line 136
  i = 0;
  }
  {
#line 136
  while (1) {
    while_continue: /* CIL Label */ ;
#line 136
    if (! (i < tr->len)) {
#line 136
      goto while_break;
    }
#line 137
    if ((unsigned long )p == (unsigned long )value) {
#line 138
      *(tr->data + i) = (char)0;
    } else {
#line 140
      p --;
#line 141
      if ((int const   )*p == 48) {
#line 141
        *(tr->data + i) = (char)0;
      } else {
#line 141
        *(tr->data + i) = (char)1;
      }
    }
#line 136
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (tr);
}
}
#line 148 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
int register_compare(tap_register const   *tr , tap_register const   *tr2 ) 
{ 
  int i ;

  {
#line 153
  if (! tr) {
#line 153
    if (! tr2) {
#line 154
      return (0);
    }
  }
#line 156
  if (! tr) {
#line 157
    return (1);
  } else
#line 156
  if (! tr2) {
#line 157
    return (1);
  }
#line 159
  if (tr->len != tr2->len) {
#line 160
    return (1);
  }
#line 162
  i = 0;
  {
#line 162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 162
    if (! (i < (int )tr->len)) {
#line 162
      goto while_break;
    }
#line 163
    if ((int )*(tr->data + i) != (int )*(tr2->data + i)) {
#line 164
      return (1);
    }
#line 162
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  return (0);
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
int register_match(tap_register const   *tr , char const   *expr ) 
{ 
  int i ;
  char const   *s ;
  size_t tmp ;

  {
#line 175
  if (! tr) {
#line 176
    return (0);
  } else
#line 175
  if (! expr) {
#line 176
    return (0);
  } else {
    {
#line 175
    tmp = strlen(expr);
    }
#line 175
    if ((size_t )tr->len != tmp) {
#line 176
      return (0);
    }
  }
  {
#line 178
  s = register_get_string(tr);
#line 180
  i = 0;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! (i < (int )tr->len)) {
#line 180
      goto while_break;
    }
#line 181
    if ((int const   )*(expr + i) != 63) {
#line 181
      if ((int const   )*(expr + i) != (int const   )*(s + i)) {
#line 182
        return (0);
      }
    }
#line 180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  return (1);
}
}
#line 187 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_inc(tap_register *tr ) 
{ 
  int i ;

  {
#line 192
  if (! tr) {
#line 193
    return ((tap_register *)((void *)0));
  }
#line 195
  i = 0;
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
#line 195
    if (! (i < tr->len)) {
#line 195
      goto while_break;
    }
#line 196
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 198
    if ((int )*(tr->data + i) == 1) {
#line 199
      goto while_break;
    }
#line 195
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (tr);
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_dec(tap_register *tr ) 
{ 
  int i ;

  {
#line 210
  if (! tr) {
#line 211
    return ((tap_register *)((void *)0));
  }
#line 213
  i = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (i < tr->len)) {
#line 213
      goto while_break;
    }
#line 214
    *(tr->data + i) = (char )((int )*(tr->data + i) ^ 1);
#line 216
    if ((int )*(tr->data + i) == 0) {
#line 217
      goto while_break;
    }
#line 213
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  return (tr);
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_shift_right(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 228
  if (! tr) {
#line 229
    return ((tap_register *)((void *)0));
  }
#line 231
  if (shift < 1) {
#line 232
    return (tr);
  }
#line 234
  i = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    if (! (i < tr->len)) {
#line 234
      goto while_break;
    }
#line 235
    if (i + shift < tr->len) {
#line 236
      *(tr->data + i) = *(tr->data + (i + shift));
    } else {
#line 238
      *(tr->data + i) = (char)0;
    }
#line 234
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  return (tr);
}
}
#line 244 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/register.c"
tap_register *register_shift_left(tap_register *tr , int shift ) 
{ 
  int i ;

  {
#line 249
  if (! tr) {
#line 250
    return ((tap_register *)((void *)0));
  }
#line 252
  if (shift < 1) {
#line 253
    return (tr);
  }
#line 255
  i = tr->len - 1;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i >= 0)) {
#line 255
      goto while_break;
    }
#line 256
    if (i - shift >= 0) {
#line 257
      *(tr->data + i) = *(tr->data + (i - shift));
    } else {
#line 259
      *(tr->data + i) = (char)0;
    }
#line 255
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (tr);
}
}
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 67 "/usr/include/stropts.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 45 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver ;
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static port_node_t *ports  =    (port_node_t *)((void *)0);
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static parport_t *ppdev_parport_alloc(char const   *port ) 
{ 
  ppdev_params_t *params ;
  void *tmp ;
  char *portname ;
  char *tmp___0 ;
  parport_t *parport ;
  void *tmp___1 ;
  port_node_t *node ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = malloc(sizeof(*params));
#line 64
  params = (ppdev_params_t *)tmp;
#line 65
  tmp___0 = strdup(port);
#line 65
  portname = tmp___0;
#line 66
  tmp___1 = malloc(sizeof(*parport));
#line 66
  parport = (parport_t *)tmp___1;
#line 67
  tmp___2 = malloc(sizeof(*node));
#line 67
  node = (port_node_t *)tmp___2;
  }
#line 69
  if (! node) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! parport) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! params) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! portname) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  }
#line 77
  params->portname = portname;
#line 78
  params->fd = -1;
#line 80
  parport->params = (void *)params;
#line 81
  parport->driver = & ppdev_parport_driver;
#line 82
  parport->cable = (cable_t *)((void *)0);
#line 84
  node->port = parport;
#line 85
  node->next = ports;
#line 87
  ports = node;
#line 89
  return (parport);
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static void ppdev_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 97
  prev = & ports;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 99
      goto while_break;
    }
#line 97
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*prev) {
    {
#line 102
    pn = *prev;
#line 103
    *prev = pn->next;
#line 104
    free((void *)pn);
    }
  }
  {
#line 107
  free((void *)((ppdev_params_t *)port->params)->portname);
#line 108
  free(port->params);
#line 109
  free((void *)port);
  }
#line 110
  return;
}
}
#line 112 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
parport_t *ppdev_connect(char const   **par , int parnum ) 
{ 
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 118
  if (parnum != 1) {
    {
#line 119
    tmp = gettext("Syntax error!\n");
#line 119
    printf((char const   */* __restrict  */)tmp);
    }
#line 120
    return ((parport_t *)((void *)0));
  }
#line 123
  pn = ports;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 123
    if (! pn) {
#line 123
      goto while_break;
    }
    {
#line 124
    tmp___2 = strcmp((char const   *)(pn->port)->params, *(par + 0));
    }
#line 124
    if (tmp___2 == 0) {
      {
#line 125
      tmp___0 = gettext((((pn->port)->cable)->driver)->description);
#line 125
      tmp___1 = gettext("Disconnecting %s from ppdev port %s\n");
#line 125
      printf((char const   */* __restrict  */)tmp___1, tmp___0, *(par + 0));
#line 126
      (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
      }
#line 127
      goto while_break;
    }
#line 123
    pn = pn->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 130
  tmp___3 = gettext("Initializing ppdev port %s\n");
#line 130
  printf((char const   */* __restrict  */)tmp___3, *(par + 0));
#line 132
  parport = ppdev_parport_alloc(*(par + 0));
  }
#line 133
  if (! parport) {
    {
#line 134
    tmp___4 = gettext("%s(%d) Out of memory.\n");
#line 134
    printf((char const   */* __restrict  */)tmp___4, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c",
           134);
    }
#line 135
    return ((parport_t *)((void *)0));
  }
#line 138
  return (parport);
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_open(parport_t *parport ) 
{ 
  ppdev_params_t *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 144
  p = (ppdev_params_t *)parport->params;
#line 146
  p->fd = open((char const   *)p->portname, 2);
  }
#line 147
  if (p->fd < 0) {
    {
#line 148
    tmp = __errno_location();
#line 148
    tmp___0 = strerror(*tmp);
#line 148
    tmp___1 = gettext("Could not open port %s: %s\n");
#line 148
    printf((char const   */* __restrict  */)tmp___1, p->portname, tmp___0);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___5 = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 139U));
  }
#line 152
  if (tmp___5 == -1) {
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    tmp___4 = gettext("Could not claim ppdev device: %s\n");
#line 153
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 154
    close(p->fd);
#line 155
    p->fd = -1;
    }
#line 156
    return (-1);
  }
#line 159
  return (0);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_close(parport_t *parport ) 
{ 
  int r ;
  ppdev_params_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  r = 0;
#line 166
  p = (ppdev_params_t *)parport->params;
#line 168
  tmp = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 140U));
  }
#line 168
  if (tmp == -1) {
#line 169
    r = -1;
  }
  {
#line 171
  tmp___0 = close(p->fd);
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 174
  p->fd = -1;
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_set_data(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 181
  p = (ppdev_params_t *)parport->params;
#line 183
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 134U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 183
  if (tmp == -1) {
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_get_data(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 193
  p = (ppdev_params_t *)parport->params;
#line 195
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 133U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 195
  if (tmp == -1) {
#line 196
    return (-1);
  }
#line 198
  return ((int )d);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_get_status(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 205
  p = (ppdev_params_t *)parport->params;
#line 207
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 129U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 207
  if (tmp == -1) {
#line 208
    return (-1);
  }
#line 210
  return ((int )d ^ 128);
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_set_control(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 216
  p = (ppdev_params_t *)parport->params;
#line 218
  data = (uint8_t )((int )data ^ 11);
#line 220
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 132U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 223
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
parport_driver_t ppdev_parport_driver  = 
#line 226
     {"ppdev", & ppdev_connect, & ppdev_parport_free, & ppdev_open, & ppdev_close, & ppdev_set_data,
    & ppdev_get_data, & ppdev_get_status, & ppdev_set_control};
#line 54 "../../include/parport.h"
int parport_close(parport_t *port ) ;
#line 58
int parport_set_control(parport_t *port , uint8_t data ) ;
#line 60
parport_driver_t *parport_drivers[3] ;
#line 29 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
parport_driver_t direct_parport_driver ;
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
parport_driver_t *parport_drivers[3]  = {      & direct_parport_driver,      & ppdev_parport_driver,      (parport_driver_t *)((void *)0)};
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
int parport_open(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 52
  tmp = (*((port->driver)->open))(port);
  }
#line 52
  return (tmp);
}
}
#line 55 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
int parport_close(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 58
  tmp = (*((port->driver)->close))(port);
  }
#line 58
  return (tmp);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
int parport_set_data(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 64
  tmp = (*((port->driver)->set_data))(port, data);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
int parport_get_data(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 70
  tmp = (*((port->driver)->get_data))(port);
  }
#line 70
  return (tmp);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
int parport_get_status(parport_t *port ) 
{ 
  int tmp ;

  {
  {
#line 76
  tmp = (*((port->driver)->get_status))(port);
  }
#line 76
  return (tmp);
}
}
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport.c"
int parport_set_control(parport_t *port , uint8_t data ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = (*((port->driver)->set_control))(port, data);
  }
#line 82
  return (tmp);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static int mpcbdm_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = parport_open(cable->link.port);
  }
#line 67
  if (tmp) {
#line 68
    return (-1);
  }
  {
#line 70
  parport_set_control(cable->link.port, (uint8_t )0);
#line 71
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 73
  return (0);
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static void mpcbdm_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 81
  if (tms) {
#line 81
    tms = 1;
  } else {
#line 81
    tms = 0;
  }
#line 82
  if (tdi) {
#line 82
    tdi = 1;
  } else {
#line 82
    tdi = 0;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < n)) {
#line 84
      goto while_break;
    }
    {
#line 85
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | (tdi << 1)));
#line 86
    cable_wait(cable);
#line 87
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 2)) | (tdi << 1)));
#line 88
    cable_wait(cable);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static int mpcbdm_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 95
  parport_set_data(cable->link.port, (uint8_t )0);
#line 96
  cable_wait(cable);
#line 97
  tmp = parport_get_status(cable->link.port);
  }
#line 97
  return ((tmp >> 5) & 1);
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static int mpcbdm_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 103
  if (trst) {
#line 103
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 103
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 105
  parport_set_control(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst ^ 1));
  }
#line 106
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 109 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
cable_driver_t mpcbdm_cable_driver  = 
#line 109
     {"MPCBDM", "Mpcbdm JTAG cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & mpcbdm_init, & generic_parport_done, & generic_set_frequency,
    & mpcbdm_clock, & mpcbdm_get_tdo, & generic_transfer, & mpcbdm_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_parport_help};
#line 290 "/usr/include/usb.h"
extern usb_dev_handle *usb_open(struct usb_device *dev ) ;
#line 294
extern int usb_get_string_simple(usb_dev_handle *dev , int index , char *buf , size_t buflen ) ;
#line 314
extern int usb_set_configuration(usb_dev_handle *dev , int configuration ) ;
#line 315
extern int usb_claim_interface(usb_dev_handle *dev , int interface ) ;
#line 316
extern int usb_release_interface(usb_dev_handle *dev , int interface ) ;
#line 317
extern int usb_set_altinterface(usb_dev_handle *dev , int alternate ) ;
#line 332
extern void usb_init(void) ;
#line 334
extern int usb_find_busses(void) ;
#line 335
extern int usb_find_devices(void) ;
#line 337
extern struct usb_bus *usb_get_busses(void) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static int libusb_match_desc(struct usb_device *dev , char *desc ) 
{ 
  int r ;
  char buf[256] ;
  usb_dev_handle *handle ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 61
  r = 0;
#line 65
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
#line 65
    return (1);
  }
  {
#line 67
  handle = usb_open(dev);
  }
#line 68
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
    {
#line 70
    perror("libusb: usb_open() failed");
    }
#line 71
    return (0);
  }
#line 73
  if (dev->descriptor.iManufacturer) {
    {
#line 75
    r = usb_get_string_simple(handle, (int )dev->descriptor.iManufacturer, buf, sizeof(buf));
    }
#line 76
    if (r > 0) {
      {
#line 78
      tmp = strstr((char const   *)(buf), (char const   *)desc);
      }
#line 78
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 78
        r = 0;
      }
    }
  }
#line 81
  if (r <= 0) {
#line 81
    if (dev->descriptor.iProduct) {
      {
#line 83
      r = usb_get_string_simple(handle, (int )dev->descriptor.iProduct, buf, sizeof(buf));
      }
#line 84
      if (r > 0) {
        {
#line 86
        tmp___0 = strstr((char const   *)(buf), (char const   *)desc);
        }
#line 86
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 86
          r = 0;
        }
      }
    }
  }
#line 89
  if (r <= 0) {
#line 89
    if (dev->descriptor.iSerialNumber) {
      {
#line 91
      r = usb_get_string_simple(handle, (int )dev->descriptor.iSerialNumber, buf,
                                sizeof(buf));
      }
#line 92
      if (r > 0) {
        {
#line 94
        tmp___1 = strstr((char const   *)(buf), (char const   *)desc);
        }
#line 94
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 94
          r = 0;
        }
      }
    }
  }
  {
#line 97
  usb_close(handle);
  }
#line 98
  if (r > 0) {
#line 98
    tmp___2 = 1;
  } else {
#line 98
    tmp___2 = 0;
  }
#line 98
  return (tmp___2);
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
usbconn_t *usbconn_libusb_connect(char const   **param , int paramc , usbconn_cable_t *template ) 
{ 
  struct usb_bus *bus___0 ;
  struct usb_device *found_dev ;
  usbconn_t *libusb_conn ;
  libusb_param_t___0 *libusb_params ;
  int tmp ;
  int tmp___0 ;
  struct usb_device *dev ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 108
  found_dev = (struct usb_device *)((void *)0);
#line 112
  usb_init();
#line 113
  tmp = usb_find_busses();
  }
#line 113
  if (tmp < 0) {
    {
#line 115
    perror("libusb: usb_find_busses failed");
    }
#line 116
    return ((usbconn_t *)((void *)0));
  }
  {
#line 118
  tmp___0 = usb_find_devices();
  }
#line 118
  if (tmp___0 < 0) {
    {
#line 120
    perror("libusb: usb_find_devices failed");
    }
#line 121
    return ((usbconn_t *)((void *)0));
  }
  {
#line 124
  bus___0 = usb_get_busses();
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (bus___0) {
#line 124
      if (! (! found_dev)) {
#line 124
        goto while_break;
      }
    } else {
#line 124
      goto while_break;
    }
#line 128
    dev = bus___0->devices;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 128
      if (dev) {
#line 128
        if (! (! found_dev)) {
#line 128
          goto while_break___0;
        }
      } else {
#line 128
        goto while_break___0;
      }
#line 130
      if (template->vid < 0) {
#line 130
        goto _L___0;
      } else
#line 130
      if ((int )dev->descriptor.idVendor == template->vid) {
        _L___0: /* CIL Label */ 
#line 130
        if (template->pid < 0) {
#line 130
          goto _L;
        } else
#line 130
        if ((int )dev->descriptor.idProduct == template->pid) {
          _L: /* CIL Label */ 
          {
#line 133
          tmp___1 = libusb_match_desc(dev, template->desc);
          }
#line 133
          if (tmp___1) {
#line 135
            found_dev = dev;
          }
        }
      }
#line 128
      dev = dev->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 124
    bus___0 = bus___0->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 141
  if (! found_dev) {
#line 143
    return ((usbconn_t *)((void *)0));
  }
  {
#line 146
  tmp___2 = malloc(sizeof(usbconn_t ));
#line 146
  libusb_conn = (usbconn_t *)tmp___2;
#line 147
  tmp___3 = malloc(sizeof(libusb_param_t___0 ));
#line 147
  libusb_params = (libusb_param_t___0 *)tmp___3;
  }
#line 148
  if ((unsigned long )libusb_params == (unsigned long )((void *)0)) {
#line 148
    goto _L___1;
  } else
#line 148
  if ((unsigned long )libusb_conn == (unsigned long )((void *)0)) {
    _L___1: /* CIL Label */ 
    {
#line 150
    tmp___4 = gettext("Out of memory\n");
#line 150
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 151
    if (libusb_params) {
      {
#line 152
      free((void *)libusb_params);
      }
    }
#line 153
    if (libusb_conn) {
      {
#line 154
      free((void *)libusb_conn);
      }
    }
#line 155
    return ((usbconn_t *)((void *)0));
  }
#line 158
  libusb_params->dev = found_dev;
#line 159
  libusb_params->handle = (struct usb_dev_handle *)((void *)0);
#line 160
  libusb_conn->params = (void *)libusb_params;
#line 161
  libusb_conn->driver = & usbconn_libusb_driver;
#line 162
  libusb_conn->cable = (cable_t *)((void *)0);
#line 164
  return (libusb_conn);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static int usbconn_libusb_open(usbconn_t *conn ) 
{ 
  libusb_param_t___0 *p ;
  int tmp ;

  {
  {
#line 173
  p = (libusb_param_t___0 *)conn->params;
#line 175
  p->handle = usb_open(p->dev);
  }
#line 176
  if ((unsigned long )p->handle == (unsigned long )((void *)0)) {
    {
#line 178
    perror("libusb: usb_open() failed");
    }
  } else {
    {
#line 183
    usb_set_configuration(p->handle, (int )((p->dev)->config + 0)->bConfigurationValue);
#line 186
    tmp = usb_claim_interface(p->handle, 0);
    }
#line 186
    if (tmp != 0) {
      {
#line 188
      perror("libusb: usb_claim_interface failed");
#line 189
      usb_close(p->handle);
#line 190
      p->handle = (struct usb_dev_handle *)((void *)0);
      }
    } else {
      {
#line 195
      usb_set_altinterface(p->handle, 0);
      }
    }
  }
#line 200
  if ((unsigned long )p->handle == (unsigned long )((void *)0)) {
#line 203
    return (-1);
  }
#line 206
  return (0);
}
}
#line 211 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static int usbconn_libusb_close(usbconn_t *conn ) 
{ 
  libusb_param_t___0 *p ;

  {
#line 214
  p = (libusb_param_t___0 *)conn->params;
#line 215
  if ((unsigned long )p->handle != (unsigned long )((void *)0)) {
    {
#line 217
    usb_release_interface(p->handle, 0);
#line 218
    usb_close(p->handle);
    }
  }
#line 220
  p->handle = (struct usb_dev_handle *)((void *)0);
#line 221
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static void usbconn_libusb_free(usbconn_t *conn ) 
{ 


  {
  {
#line 229
  free(conn->params);
#line 230
  free((void *)conn);
  }
#line 231
  return;
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
usbconn_driver_t usbconn_libusb_driver  =    {"libusb", & usbconn_libusb_connect, & usbconn_libusb_free, & usbconn_libusb_open,
    & usbconn_libusb_close, (int (*)(usbconn_t * , uint8_t * , int  ))((void *)0),
    (int (*)(usbconn_t * , uint8_t * , int  , int  ))((void *)0)};
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static int lattice_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
#line 60
  ((generic_params_t *)cable->params)->trst = 1;
#line 62
  return (0);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static void lattice_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 70
  if (tms) {
#line 70
    tms = 1;
  } else {
#line 70
    tms = 0;
  }
#line 71
  if (tdi) {
#line 71
    tdi = 1;
  } else {
#line 71
    tdi = 0;
  }
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < n)) {
#line 73
      goto while_break;
    }
    {
#line 74
    parport_set_data(cable->link.port, (uint8_t )(((tms << 2) | tdi) | (1 << 4)));
#line 75
    cable_wait(cable);
#line 76
    parport_set_data(cable->link.port, (uint8_t )((((1 << 1) | (tms << 2)) | tdi) | (1 << 4)));
#line 77
    cable_wait(cable);
#line 73
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static int lattice_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 84
  parport_set_data(cable->link.port, (uint8_t )(1 << 4));
#line 85
  cable_wait(cable);
#line 86
  tmp = parport_get_status(cable->link.port);
  }
#line 86
  return ((tmp >> 6) & 1);
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static int lattice_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 92
  tmp = parport_set_data(cable->link.port, (uint8_t )(trst << 4));
  }
#line 92
  return (tmp);
}
}
#line 95 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
cable_driver_t lattice_cable_driver  = 
#line 95
     {"Lattice", "Lattice Parallel Port JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & lattice_init, & generic_parport_done, & generic_set_frequency,
    & lattice_clock, & lattice_get_tdo, & generic_transfer, & lattice_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_parport_help};
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static int keithkoep_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = parport_open(cable->link.port);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
  {
#line 72
  parport_set_control(cable->link.port, (uint8_t )1);
#line 73
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 75
  return (0);
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static void keithkoep_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | tdi));
#line 88
    cable_wait(cable);
#line 89
    parport_set_data(cable->link.port, (uint8_t )(((1 << 1) | (tms << 2)) | tdi));
#line 90
    cable_wait(cable);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static int keithkoep_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 97
  parport_set_data(cable->link.port, (uint8_t )0);
#line 98
  cable_wait(cable);
#line 99
  tmp = parport_get_status(cable->link.port);
  }
#line 99
  return ((tmp >> 5) & 1);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static int keithkoep_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 105
  if (trst) {
#line 105
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 105
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 107
  parport_set_control(cable->link.port, (uint8_t )((generic_params_t *)cable->params)->trst);
  }
#line 108
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
cable_driver_t keithkoep_cable_driver  = 
#line 111
     {"KeithKoep", "Keith & Koep JTAG cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & keithkoep_init, & generic_parport_done, & generic_set_frequency,
    & keithkoep_clock, & keithkoep_get_tdo, & generic_transfer, & keithkoep_set_trst,
    & generic_get_trst, & generic_flush_one_by_one, & generic_parport_help};
#line 320 "/usr/include/usb.h"
extern int usb_reset(usb_dev_handle *dev ) ;
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_reset(libusb_param_t *params , int trst , int srst ) ;
#line 100
static void jlink_simple_command(libusb_param_t *params , uint8_t command ) ;
#line 104
static void jlink_tap_init(jlink_usbconn_data_t *data ) ;
#line 105
static int jlink_tap_execute(libusb_param_t *params ) ;
#line 106
static void jlink_tap_append_step(jlink_usbconn_data_t *data , int tms , int tdi ) ;
#line 109
static int jlink_usb_message(libusb_param_t *params , int out_length , int in_length ) ;
#line 110
static int jlink_usb_write(libusb_param_t *params , unsigned int out_length ) ;
#line 111
static int jlink_usb_read(libusb_param_t *params ) ;
#line 113
static void jlink_debug_buffer(char *buffer , int length ) ;
#line 117
void jlink_set_frequency(cable_t *cable , uint32_t frequency ) ;
#line 122 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_reset(libusb_param_t *params , int trst , int srst ) 
{ 


  {
#line 127
  if (trst == 0) {
    {
#line 129
    jlink_simple_command(params, (uint8_t )223);
    }
  } else
#line 131
  if (trst == 1) {
    {
#line 133
    jlink_simple_command(params, (uint8_t )222);
    }
  }
#line 136
  if (srst == 0) {
    {
#line 138
    jlink_simple_command(params, (uint8_t )221);
    }
  } else
#line 140
  if (srst == 1) {
    {
#line 142
    jlink_simple_command(params, (uint8_t )220);
    }
  }
#line 144
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_simple_command(libusb_param_t *params , uint8_t command ) 
{ 
  int result ;
  jlink_usbconn_data_t *data ;

  {
  {
#line 150
  data = (jlink_usbconn_data_t *)params->data;
#line 154
  data->usb_out_buffer[0] = (char )command;
#line 155
  result = jlink_usb_write(params, 1U);
  }
#line 157
  if (result != 1) {
    {
#line 159
    printf((char const   */* __restrict  */)"J-Link command 0x%02x failed (%d)\n",
           (int )command, result);
    }
  }
#line 161
  return;
}
}
#line 163 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_get_status(libusb_param_t *params ) 
{ 
  int result ;
  jlink_usbconn_data_t *data ;
  int vref ;

  {
  {
#line 166
  data = (jlink_usbconn_data_t *)params->data;
#line 168
  jlink_simple_command(params, (uint8_t )7);
#line 170
  result = jlink_usb_read(params);
  }
#line 172
  if (result == 8) {
    {
#line 174
    vref = (int )data->usb_in_buffer[0] + ((int )data->usb_in_buffer[1] << 8);
#line 175
    printf((char const   */* __restrict  */)"Vref = %d.%d TCK=%d TDI=%d TDO=%d TMS=%d TRES=%d TRST=%d\n",
           vref / 1000, vref % 1000, (int )data->usb_in_buffer[2], (int )data->usb_in_buffer[3],
           (int )data->usb_in_buffer[4], (int )data->usb_in_buffer[5], (int )data->usb_in_buffer[6],
           (int )data->usb_in_buffer[7]);
    }
#line 183
    if (vref < 1500) {
      {
#line 185
      printf((char const   */* __restrict  */)"Vref too low. Eventually the target isn\'t powered or disconnected?\n");
#line 186
      result = -15;
      }
    }
  } else {
    {
#line 191
    printf((char const   */* __restrict  */)"J-Link command 0x07 (get status) failed (%d)\n",
           result);
    }
  }
#line 194
  return (result);
}
}
#line 200 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_tap_init(jlink_usbconn_data_t *data ) 
{ 


  {
#line 202
  data->tap_length = 0;
#line 203
  return;
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_tap_append_step(jlink_usbconn_data_t *data , int tms , int tdi ) 
{ 
  int index___0 ;
  int bit_index ;
  uint8_t bit ;

  {
#line 207
  index___0 = data->tap_length >> 3;
#line 209
  if (index___0 < 390) {
#line 211
    bit_index = data->tap_length & 7;
#line 212
    bit = (uint8_t )(1 << bit_index);
#line 214
    if (bit_index == 0) {
#line 216
      data->tms_buffer[index___0] = (uint8_t )0;
#line 217
      data->tdi_buffer[index___0] = (uint8_t )0;
    }
#line 220
    if (tms) {
#line 220
      data->tms_buffer[index___0] = (uint8_t )((int )data->tms_buffer[index___0] | (int )bit);
    }
#line 221
    if (tdi) {
#line 221
      data->tdi_buffer[index___0] = (uint8_t )((int )data->tdi_buffer[index___0] | (int )bit);
    }
#line 223
    (data->tap_length) ++;
  } else {
    {
#line 227
    printf((char const   */* __restrict  */)"jlink_tap_append_step, overflow\n");
    }
  }
#line 229
  return;
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_tap_execute(libusb_param_t *params ) 
{ 
  jlink_usbconn_data_t *data ;
  int byte_length ;
  int tms_offset ;
  int tdi_offset ;
  int i ;
  int result ;
  int bit_index ;
  uint8_t bit ;

  {
#line 235
  data = (jlink_usbconn_data_t *)params->data;
#line 242
  if (data->tap_length > 0) {
#line 244
    byte_length = (data->tap_length + 7) >> 3;
#line 245
    data->usb_out_buffer[0] = (char)-51;
#line 246
    data->usb_out_buffer[1] = (char )(data->tap_length & 255);
#line 247
    data->usb_out_buffer[2] = (char )((data->tap_length >> 8) & 255);
#line 249
    tms_offset = 3;
#line 250
    i = 0;
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 250
      if (! (i < byte_length)) {
#line 250
        goto while_break;
      }
#line 252
      data->usb_out_buffer[tms_offset + i] = (char )data->tms_buffer[i];
#line 250
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 256
    tdi_offset = tms_offset + byte_length;
#line 257
    i = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (i < byte_length)) {
#line 257
        goto while_break___0;
      }
#line 259
      data->usb_out_buffer[tdi_offset + i] = (char )data->tdi_buffer[i];
#line 257
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 263
    result = jlink_usb_message(params, 3 + 2 * byte_length, byte_length);
    }
#line 268
    if (result == byte_length) {
#line 270
      bit_index = (data->tap_length - 1) & 7;
#line 271
      bit = (uint8_t )(1 << bit_index);
#line 273
      if ((int )data->usb_in_buffer[byte_length - 1] & (int )bit) {
#line 273
        data->last_tdo = 1;
      } else {
#line 273
        data->last_tdo = 0;
      }
    } else {
      {
#line 278
      printf((char const   */* __restrict  */)"jlink_tap_execute, wrong result %d, expected %d\n",
             result, byte_length);
      }
#line 283
      return (-2);
    }
    {
#line 286
    jlink_tap_init(data);
    }
  }
#line 288
  return (0);
}
}
#line 294 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_usb_message(libusb_param_t *params , int out_length , int in_length ) 
{ 
  int result ;

  {
  {
#line 301
  result = jlink_usb_write(params, (unsigned int )out_length);
  }
#line 302
  if (result == out_length) {
    {
#line 304
    result = jlink_usb_read(params);
    }
#line 305
    if (result == in_length) {
#line 307
      return (result);
    } else {
      {
#line 311
      printf((char const   */* __restrict  */)"usb_bulk_read failed (requested=%d, result=%d)\n",
             in_length, result);
      }
#line 316
      return (-1);
    }
  } else {
    {
#line 321
    printf((char const   */* __restrict  */)"usb_bulk_write failed (requested=%d, result=%d)\n",
           out_length, result);
    }
#line 326
    return (-1);
  }
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_usb_write(libusb_param_t *params , unsigned int out_length ) 
{ 
  int result ;
  jlink_usbconn_data_t *data ;

  {
#line 338
  data = (jlink_usbconn_data_t *)params->data;
#line 340
  if (out_length > 2064U) {
    {
#line 342
    printf((char const   */* __restrict  */)"jlink_jtag_write illegal out_length=%d (max=%d)\n",
           out_length, 2064);
    }
#line 345
    return (-1);
  }
  {
#line 348
  result = usb_bulk_write(params->handle, 2, (char const   *)(data->usb_out_buffer),
                          (int )out_length, 100);
#line 356
  jlink_debug_buffer(data->usb_out_buffer, (int )out_length);
  }
#line 357
  return (result);
}
}
#line 363 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_usb_read(libusb_param_t *params ) 
{ 
  jlink_usbconn_data_t *data ;
  int result ;
  int tmp ;

  {
  {
#line 365
  data = (jlink_usbconn_data_t *)params->data;
#line 367
  tmp = usb_bulk_read(params->handle, 129, data->usb_in_buffer, 2064, 100);
#line 367
  result = tmp;
#line 375
  jlink_debug_buffer(data->usb_in_buffer, result);
  }
#line 376
  return (result);
}
}
#line 383 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_debug_buffer(char *buffer , int length ) 
{ 
  char line[81] ;
  char s[4] ;
  int i ;
  int j ;

  {
#line 390
  i = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < length)) {
#line 390
      goto while_break;
    }
    {
#line 392
    snprintf((char */* __restrict  */)(line), (size_t )5, (char const   */* __restrict  */)"%04x",
             i);
#line 393
    j = i;
    }
    {
#line 393
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 393
      if (j < i + 16) {
#line 393
        if (! (j < length)) {
#line 393
          goto while_break___0;
        }
      } else {
#line 393
        goto while_break___0;
      }
      {
#line 395
      snprintf((char */* __restrict  */)(s), (size_t )4, (char const   */* __restrict  */)" %02x",
               (int )*(buffer + j));
#line 396
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(s));
#line 393
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 390
    i += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return;
}
}
#line 405 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_init(cable_t *cable ) 
{ 
  int result ;
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;
  int tmp ;

  {
  {
#line 412
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 413
  params->data = malloc(sizeof(jlink_usbconn_data_t ));
  }
#line 414
  if ((unsigned long )params->data == (unsigned long )((void *)0)) {
#line 416
    return (-1);
  }
  {
#line 418
  data = (jlink_usbconn_data_t *)params->data;
#line 420
  tmp = usbconn_open(cable->link.usb);
  }
#line 420
  if (tmp) {
#line 420
    return (-1);
  }
  {
#line 422
  jlink_tap_init(data);
#line 424
  result = jlink_usb_read(params);
  }
#line 426
  if (result != 2) {
    {
#line 429
    printf((char const   */* __restrict  */)"J-Link initial read failed, don\'t worry (result=%d)\n",
           result);
    }
  } else
#line 426
  if ((int )data->usb_in_buffer[0] != 7) {
    {
#line 429
    printf((char const   */* __restrict  */)"J-Link initial read failed, don\'t worry (result=%d)\n",
           result);
    }
  } else
#line 426
  if ((int )data->usb_in_buffer[1] != 0) {
    {
#line 429
    printf((char const   */* __restrict  */)"J-Link initial read failed, don\'t worry (result=%d)\n",
           result);
    }
  }
  {
#line 432
  result = jlink_get_status(params);
  }
#line 433
  if (result < 0) {
    {
#line 435
    printf((char const   */* __restrict  */)"Resetting J-Link. Please retry the cable command.\n");
#line 436
    usb_reset(params->handle);
    }
#line 437
    return (-1);
  }
  {
#line 440
  printf((char const   */* __restrict  */)"J-Link JTAG Interface ready\n");
#line 442
  jlink_set_frequency(cable, (uint32_t )4E6);
#line 444
  jlink_reset(params, 0, 0);
  }
#line 446
  return (0);
}
}
#line 451 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_free(cable_t *cable ) 
{ 
  jlink_usbconn_data_t *data ;

  {
  {
#line 455
  data = (jlink_usbconn_data_t *)((libusb_param_t *)(cable->link.usb)->params)->data;
#line 456
  free((void *)data);
#line 458
  generic_usbconn_free(cable);
  }
#line 459
  return;
}
}
#line 463 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
void jlink_set_frequency(cable_t *cable , uint32_t frequency ) 
{ 
  int result ;
  int speed ;
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;

  {
#line 466
  speed = (int )((double )frequency / 1E3);
#line 467
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 468
  data = (jlink_usbconn_data_t *)params->data;
#line 470
  if (1 <= speed) {
#line 470
    if (speed <= 12000) {
      {
#line 472
      data->usb_out_buffer[0] = (char)5;
#line 474
      data->usb_out_buffer[1] = (char )(speed & 255);
#line 475
      data->usb_out_buffer[2] = (char )((speed >> 8) & 255);
#line 477
      result = jlink_usb_write(params, 3U);
      }
#line 479
      if (result != 3) {
        {
#line 481
        printf((char const   */* __restrict  */)"J-Link setting speed failed (%d)\n",
               result);
        }
      }
    } else {
      {
#line 486
      printf((char const   */* __restrict  */)"Requested speed %dkHz exceeds maximum of %dkHz, ignored\n",
             speed, 12000);
      }
    }
  } else {
    {
#line 486
    printf((char const   */* __restrict  */)"Requested speed %dkHz exceeds maximum of %dkHz, ignored\n",
           speed, 12000);
    }
  }
#line 489
  return;
}
}
#line 493 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;

  {
#line 497
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 498
  data = (jlink_usbconn_data_t *)params->data;
#line 500
  i = 0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! (i < n)) {
#line 500
      goto while_break;
    }
    {
#line 502
    jlink_tap_append_step(data, tms, tdi);
#line 500
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 504
  jlink_tap_execute(params);
  }
#line 505
  return;
}
}
#line 509 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_get_tdo(cable_t *cable ) 
{ 
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;

  {
#line 512
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 513
  data = (jlink_usbconn_data_t *)params->data;
#line 518
  return (data->last_tdo);
}
}
#line 523 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
void jlink_copy_out_data(jlink_usbconn_data_t *data , int len , int offset , char *buf ) 
{ 
  int i ;
  int bit ;
  int byte ;

  {
#line 527
  i = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! (i < len)) {
#line 527
      goto while_break;
    }
#line 529
    bit = 1 << (i & 7);
#line 530
    byte = i >> 3;
#line 531
    if ((int )data->usb_in_buffer[byte] & bit) {
#line 531
      *(buf + (offset + i)) = (char)1;
    } else {
#line 531
      *(buf + (offset + i)) = (char)0;
    }
#line 527
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return;
}
}
#line 535 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
int jlink_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int j ;
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;

  {
#line 539
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 540
  data = (jlink_usbconn_data_t *)params->data;
#line 542
  j = 0;
#line 542
  i = 0;
  {
#line 542
  while (1) {
    while_continue: /* CIL Label */ ;
#line 542
    if (! (i < len)) {
#line 542
      goto while_break;
    }
    {
#line 544
    jlink_tap_append_step(data, 0, (int )*(in + i));
    }
#line 546
    if (data->tap_length >= 3120) {
      {
#line 548
      jlink_tap_execute(params);
      }
#line 549
      if (out) {
        {
#line 549
        jlink_copy_out_data(data, i - j, j, out);
        }
      }
#line 550
      j = i;
    }
#line 542
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  if (data->tap_length > 0) {
    {
#line 555
    jlink_tap_execute(params);
    }
#line 556
    if (out) {
      {
#line 556
      jlink_copy_out_data(data, i - j, j, out);
      }
    }
  }
#line 559
  return (i);
}
}
#line 564 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 567
  return (1);
}
}
#line 570 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
cable_driver_t jlink_cable_driver  = 
#line 570
     {"jlink", "Segger/IAR J-Link, Atmel SAM-ICE and others.", & generic_usbconn_connect,
    & generic_disconnect, & jlink_free, & jlink_init, & generic_usbconn_done, & jlink_set_frequency,
    & jlink_clock, & jlink_get_tdo, & jlink_transfer, & jlink_set_trst, & generic_get_trst,
    & generic_flush_using_transfer, & generic_usbconn_help};
#line 588 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
usbconn_cable_t usbconn_cable_jlink  =    {(char *)"jlink", (char *)((void *)0), (char *)"libusb", 4966, 257};
#line 51 "../../include/jtag.h"
void idcode(chain_t *chain , unsigned int bytes ) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/idcode.c"
void idcode(chain_t *chain , unsigned int bytes ) 
{ 
  int i ;
  int hit ;
  tap_register *rz ;
  tap_register *rout ;
  tap_register *rnull ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 39
  hit = 0;
#line 44
  chain_set_trst(chain, 0);
#line 45
  chain_set_trst(chain, 1);
#line 47
  tap_reset(chain);
#line 48
  tap_capture_dr(chain);
#line 51
  tmp = register_alloc(8);
#line 51
  rz = register_fill(tmp, 0);
#line 52
  tmp___0 = register_alloc(8);
#line 52
  rnull = register_fill(tmp___0, 0);
#line 53
  rout = register_alloc(8);
  }
#line 55
  if (! rz) {
    {
#line 57
    tmp___1 = gettext("Allocation failed\n");
#line 57
    printf((char const   */* __restrict  */)tmp___1);
    }
  } else
#line 55
  if (! rout) {
    {
#line 57
    tmp___1 = gettext("Allocation failed\n");
#line 57
    printf((char const   */* __restrict  */)tmp___1);
    }
  } else
#line 55
  if (! rnull) {
    {
#line 57
    tmp___1 = gettext("Allocation failed\n");
#line 57
    printf((char const   */* __restrict  */)tmp___1);
    }
  }
  {
#line 59
  tmp___2 = gettext("Read");
#line 59
  printf((char const   */* __restrict  */)tmp___2);
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (bytes) {
#line 60
      tmp___6 = bytes;
    } else {
#line 60
      tmp___6 = 1000U;
    }
#line 60
    if (! ((unsigned int )i < tmp___6)) {
#line 60
      goto while_break;
    }
    {
#line 62
    tap_shift_register(chain, (tap_register const   *)rz, rout, 0);
#line 63
    tmp___3 = register_get_string((tap_register const   *)rout);
#line 63
    tmp___4 = gettext(" %s");
#line 63
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
    }
#line 64
    if (! bytes) {
      {
#line 67
      tmp___5 = register_compare((tap_register const   *)rout, (tap_register const   *)rnull);
      }
#line 67
      if (tmp___5) {
#line 70
        hit = 0;
      } else {
#line 68
        hit ++;
      }
#line 71
      if (hit > 3) {
#line 72
        goto while_break;
      }
    }
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  register_free(rz);
#line 76
  register_free(rnull);
#line 77
  register_free(rout);
#line 78
  tmp___7 = gettext("\n");
#line 78
  printf((char const   */* __restrict  */)tmp___7);
  }
#line 79
  return;
}
}
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 120 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 84 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.c"
usbconn_cable_t *usbconn_cables[4]  = {      & usbconn_cable_xpc_int,      & usbconn_cable_xpc_ext,      & usbconn_cable_jlink,      (usbconn_cable_t *)((void *)0)};
#line 132 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.c"
int generic_usbconn_connect(char **params , cable_t *cable ) 
{ 
  usbconn_cable_t user_specified ;
  int paramc ;
  int tmp ;
  generic_params_t *cable_params ;
  usbconn_t *conn ;
  int i ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int j ;
  usbconn_cable_t cable_try ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  char *tmp___12 ;

  {
  {
#line 135
  user_specified.name = (char *)((void *)0);
#line 135
  user_specified.desc = (char *)((void *)0);
#line 135
  user_specified.driver = (char *)((void *)0);
#line 135
  user_specified.vid = -1;
#line 135
  user_specified.pid = -1;
#line 143
  tmp = cmd_params(params);
#line 143
  paramc = tmp;
#line 145
  conn = (usbconn_t *)((void *)0);
#line 148
  tmp___0 = strcasecmp((char const   *)*(params + 0), "usb");
  }
#line 148
  if (tmp___0 != 0) {
#line 150
    user_specified.name = *(params + 0);
  }
#line 154
  i = 1;
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! (i < paramc)) {
#line 154
      goto while_break;
    }
    {
#line 156
    tmp___6 = strncasecmp("pid=", (char const   *)*(params + i), (size_t )4);
    }
#line 156
    if (tmp___6 == 0) {
      {
#line 158
      tmp___1 = strtol((char const   */* __restrict  */)(*(params + i) + 4), (char **/* __restrict  */)((void *)0),
                       16);
#line 158
      user_specified.pid = (int32_t )tmp___1;
      }
    } else {
      {
#line 160
      tmp___5 = strncasecmp("vid=", (char const   *)*(params + i), (size_t )4);
      }
#line 160
      if (tmp___5 == 0) {
        {
#line 162
        tmp___2 = strtol((char const   */* __restrict  */)(*(params + i) + 4), (char **/* __restrict  */)((void *)0),
                         16);
#line 162
        user_specified.vid = (int32_t )tmp___2;
        }
      } else {
        {
#line 164
        tmp___4 = strncasecmp("desc=", (char const   *)*(params + i), (size_t )5);
        }
#line 164
        if (tmp___4 == 0) {
#line 166
          user_specified.desc = *(params + i) + 5;
        } else {
          {
#line 168
          tmp___3 = strncasecmp("driver=", (char const   *)*(params + i), (size_t )7);
          }
#line 168
          if (tmp___3 == 0) {
#line 170
            user_specified.driver = *(params + i) + 7;
          }
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  i = 0;
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (usbconn_drivers[i]) {
#line 175
      if (! (! conn)) {
#line 175
        goto while_break___0;
      }
    } else {
#line 175
      goto while_break___0;
    }
#line 177
    if ((unsigned long )user_specified.driver == (unsigned long )((void *)0)) {
#line 177
      goto _L___0;
    } else {
      {
#line 177
      tmp___9 = strcasecmp((char const   *)user_specified.driver, (usbconn_drivers[i])->type);
      }
#line 177
      if (tmp___9 == 0) {
        _L___0: /* CIL Label */ 
#line 183
        j = 0;
        {
#line 183
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 183
          if (usbconn_cables[j]) {
#line 183
            if (! (! conn)) {
#line 183
              goto while_break___1;
            }
          } else {
#line 183
            goto while_break___1;
          }
#line 185
          if ((unsigned long )user_specified.name == (unsigned long )((void *)0)) {
#line 185
            goto _L;
          } else {
            {
#line 185
            tmp___8 = strcasecmp((char const   *)user_specified.name, (char const   *)(usbconn_cables[j])->name);
            }
#line 185
            if (tmp___8 == 0) {
              _L: /* CIL Label */ 
              {
#line 188
              tmp___7 = strcasecmp((char const   *)(usbconn_cables[j])->driver, (usbconn_drivers[i])->type);
              }
#line 188
              if (tmp___7 == 0) {
#line 190
                cable_try = *(usbconn_cables[j]);
#line 192
                if (user_specified.vid >= 0) {
#line 192
                  cable_try.vid = user_specified.vid;
                }
#line 193
                if (user_specified.pid >= 0) {
#line 193
                  cable_try.pid = user_specified.pid;
                }
#line 194
                if ((unsigned long )user_specified.desc != (unsigned long )((char *)0)) {
#line 194
                  cable_try.desc = user_specified.desc;
                }
                {
#line 196
                conn = (*((usbconn_drivers[i])->connect))((char const   **)(params + 1),
                                                          paramc - 1, & cable_try);
                }
              }
            }
          }
#line 183
          j ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
#line 175
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 204
  if (! conn) {
    {
#line 205
    tmp___10 = gettext("Couldn\'t connect to suitable USB device.\n");
#line 205
    printf((char const   */* __restrict  */)tmp___10);
    }
#line 206
    return (2);
  }
  {
#line 209
  tmp___11 = malloc(sizeof(generic_params_t ));
#line 209
  cable_params = (generic_params_t *)tmp___11;
  }
#line 210
  if (! cable_params) {
    {
#line 211
    tmp___12 = gettext("%s(%d) malloc failed!\n");
#line 211
    printf((char const   */* __restrict  */)tmp___12, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.c",
           211);
#line 212
    (*((usbconn_drivers[i])->free))(conn);
    }
#line 213
    return (4);
  }
#line 216
  cable->link.usb = conn;
#line 217
  cable->params = (void *)cable_params;
#line 218
  cable->chain = (chain_t *)((void *)0);
#line 220
  return (0);
}
}
#line 223 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.c"
void generic_usbconn_free(cable_t *cable ) 
{ 


  {
  {
#line 226
  (*(((cable->link.usb)->driver)->free))(cable->link.usb);
#line 227
  free(cable->params);
#line 228
  free((void *)cable);
  }
#line 229
  return;
}
}
#line 231 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.c"
void generic_usbconn_done(cable_t *cable ) 
{ 


  {
  {
#line 234
  usbconn_close(cable->link.usb);
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_usbconn.c"
void generic_usbconn_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 240
  tmp = gettext("Usage: cable %s [vid=VID] [pid=PID] [desc=DESC] [...]\n\nVID        USB Device Vendor ID (hex, e.g. 0abc)\nPID        USB Device Product ID (hex, e.g. 0abc)\nDESC       Some string to match in description or serial no.\n\n");
#line 240
  printf((char const   */* __restrict  */)tmp, cablename);
  }
#line 250
  return;
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.c"
int generic_parport_connect(char **params , cable_t *cable ) 
{ 
  generic_params_t *cable_params ;
  parport_t *port ;
  int i ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 57
  tmp___0 = cmd_params(params);
  }
#line 57
  if (tmp___0 < 3) {
    {
#line 58
    tmp = gettext("not enough arguments!\n");
#line 58
    printf((char const   */* __restrict  */)tmp);
    }
#line 59
    return (1);
  }
#line 63
  i = 0;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! parport_drivers[i]) {
#line 63
      goto while_break;
    }
    {
#line 64
    tmp___1 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 64
    if (tmp___1 == 0) {
#line 65
      goto while_break;
    }
#line 63
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  if (! parport_drivers[i]) {
    {
#line 67
    tmp___2 = gettext("Unknown port driver: %s\n");
#line 67
    printf((char const   */* __restrict  */)tmp___2, *(params + 1));
    }
#line 68
    return (2);
  }
  {
#line 72
  tmp___3 = cmd_params(params);
#line 72
  port = (*((parport_drivers[i])->connect))((char const   **)(params + 2), tmp___3 - 2);
  }
#line 75
  if ((unsigned long )port == (unsigned long )((void *)0)) {
    {
#line 76
    tmp___4 = gettext("Error: Cable connection failed!\n");
#line 76
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 77
    return (3);
  }
  {
#line 80
  tmp___5 = malloc(sizeof(*cable_params));
#line 80
  cable_params = (generic_params_t *)tmp___5;
  }
#line 81
  if (! cable_params) {
    {
#line 82
    tmp___6 = gettext("%s(%d) malloc failed!\n");
#line 82
    printf((char const   */* __restrict  */)tmp___6, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.c",
           82);
#line 83
    (*((parport_drivers[i])->parport_free))(port);
    }
#line 84
    return (4);
  }
#line 87
  cable->link.port = port;
#line 88
  cable->params = (void *)cable_params;
#line 89
  cable->chain = (chain_t *)((void *)0);
#line 91
  return (0);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.c"
void generic_parport_free(cable_t *cable ) 
{ 


  {
  {
#line 97
  (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
#line 98
  free(cable->params);
#line 99
  free((void *)cable);
  }
#line 100
  return;
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.c"
void generic_parport_done(cable_t *cable ) 
{ 


  {
  {
#line 105
  parport_close(cable->link.port);
  }
#line 106
  return;
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic_parport.c"
void generic_parport_help(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 111
  tmp = gettext("Usage: cable %s parallel PORTADDR\n   or: cable %s ppdev PPDEV\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEV      ppdev device (e.g. /dev/parport0)\n\n");
#line 111
  printf((char const   */* __restrict  */)tmp, cablename, cablename);
  }
#line 137
  return;
}
}
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 51 "../../include/chain.h"
void chain_disconnect(chain_t *chain ) ;
#line 125 "../../include/cable.h"
void cable_done(cable_t *cable ) ;
#line 144
void cable_purge_queue(cable_queue_info_t *q , int io ) ;
#line 145
int cable_add_queue_item(cable_t *cable , cable_queue_info_t *q ) ;
#line 146
int cable_get_queue_item(cable_t *cable , cable_queue_info_t *q ) ;
#line 35 "../../include/fclock.h"
long double frealtime(void) ;
#line 60 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
void generic_disconnect(cable_t *cable ) 
{ 


  {
  {
#line 63
  cable_done(cable);
#line 64
  chain_disconnect(cable->chain);
  }
#line 65
  return;
}
}
#line 67 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
int generic_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int tmp ;

  {
#line 72
  if (out) {
#line 73
    i = 0;
    {
#line 73
    while (1) {
      while_continue: /* CIL Label */ ;
#line 73
      if (! (i < len)) {
#line 73
        goto while_break;
      }
      {
#line 74
      tmp = (*((cable->driver)->get_tdo))(cable);
#line 74
      *(out + i) = (char )tmp;
#line 75
      (*((cable->driver)->clock))(cable, 0, (int )*(in + i), 1);
#line 73
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 78
    i = 0;
    {
#line 78
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 78
      if (! (i < len)) {
#line 78
        goto while_break___0;
      }
      {
#line 79
      (*((cable->driver)->clock))(cable, 0, (int )*(in + i), 1);
#line 78
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 82
  return (i);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
int generic_get_trst(cable_t *cable ) 
{ 


  {
#line 88
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
int do_one_queued_action(cable_t *cable ) 
{ 
  int i ;
  int j ;
  char *tmp ;
  int r ;
  int tmp___0 ;

  {
  {
#line 100
  i = cable_get_queue_item(cable, & cable->todo);
  }
#line 100
  if (i >= 0) {
#line 104
    if (cable->done.num_items >= cable->done.max_items) {
#line 106
      if ((unsigned int )(cable->todo.data + i)->action == 1U) {
        {
#line 110
        tmp = gettext("No space in cable activity results queue.\n");
#line 110
        printf((char const   */* __restrict  */)tmp);
#line 111
        cable_purge_queue(& cable->done, 1);
        }
      } else
#line 106
      if ((unsigned int )(cable->todo.data + i)->action == 4U) {
        {
#line 110
        tmp = gettext("No space in cable activity results queue.\n");
#line 110
        printf((char const   */* __restrict  */)tmp);
#line 111
        cable_purge_queue(& cable->done, 1);
        }
      } else
#line 106
      if ((unsigned int )(cable->todo.data + i)->action == 2U) {
        {
#line 110
        tmp = gettext("No space in cable activity results queue.\n");
#line 110
        printf((char const   */* __restrict  */)tmp);
#line 111
        cable_purge_queue(& cable->done, 1);
        }
      }
    }
    {
#line 117
    if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 117
      goto case_0;
    }
#line 123
    if ((unsigned int )(cable->todo.data + i)->action == 3U) {
#line 123
      goto case_3;
    }
#line 127
    if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 127
      goto case_2;
    }
#line 148
    if ((unsigned int )(cable->todo.data + i)->action == 1U) {
#line 148
      goto case_1;
    }
#line 157
    if ((unsigned int )(cable->todo.data + i)->action == 4U) {
#line 157
      goto case_4;
    }
#line 115
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 118
    (*((cable->driver)->clock))(cable, (cable->todo.data + i)->arg.clock.tms, (cable->todo.data + i)->arg.clock.tdi,
                                (cable->todo.data + i)->arg.clock.n);
    }
#line 122
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 124
    cable_set_trst(cable, (cable->todo.data + i)->arg.value.trst);
    }
#line 126
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 129
    tmp___0 = (*((cable->driver)->transfer))(cable, (cable->todo.data + i)->arg.transfer.len,
                                             (cable->todo.data + i)->arg.transfer.in,
                                             (cable->todo.data + i)->arg.transfer.out);
#line 129
    r = tmp___0;
#line 134
    free((void *)(cable->todo.data + i)->arg.transfer.in);
    }
#line 135
    if ((unsigned long )(cable->todo.data + i)->arg.transfer.out != (unsigned long )((void *)0)) {
      {
#line 137
      j = cable_add_queue_item(cable, & cable->done);
#line 141
      (cable->done.data + j)->action = (enum __anonenum_action_990402164 )2;
#line 142
      (cable->done.data + j)->arg.xferred.len = (cable->todo.data + i)->arg.transfer.len;
#line 143
      (cable->done.data + j)->arg.xferred.res = r;
#line 144
      (cable->done.data + j)->arg.xferred.out = (cable->todo.data + i)->arg.transfer.out;
      }
    }
#line 146
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 149
    j = cable_add_queue_item(cable, & cable->done);
#line 153
    (cable->done.data + j)->action = (enum __anonenum_action_990402164 )1;
#line 154
    (cable->done.data + j)->arg.value.tdo = (*((cable->driver)->get_tdo))(cable);
    }
#line 156
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 158
    j = cable_add_queue_item(cable, & cable->done);
#line 162
    (cable->done.data + j)->action = (enum __anonenum_action_990402164 )4;
#line 163
    (cable->done.data + j)->arg.value.trst = (*((cable->driver)->get_trst))(cable);
    }
#line 165
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 171
    return (1);
  }
#line 177
  return (0);
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
void generic_flush_one_by_one(cable_t *cable , cable_flush_amount_t how_much ) 
{ 
  int tmp ;

  {
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 186
    tmp = do_one_queued_action(cable);
    }
#line 186
    if (! tmp) {
#line 186
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
void generic_flush_using_transfer(cable_t *cable , cable_flush_amount_t how_much ) 
{ 
  int i ;
  int j ;
  int n ;
  char *in ;
  char *out ;
  int r ;
  int bits ;
  int tdo ;
  int k ;
  int k___0 ;
  void *tmp ;
  void *tmp___0 ;
  int k___1 ;
  int tmp___1 ;
  int len ;
  int k___2 ;
  int tmp___2 ;
  int c ;
  int tmp___3 ;
  char *p ;
  int len___0 ;
  int c___0 ;
  int tmp___4 ;

  {
#line 195
  if ((unsigned int )how_much == 0U) {
#line 195
    return;
  }
#line 197
  if (cable->todo.num_items == 0) {
#line 197
    return;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    bits = 0;
#line 201
    tdo = 0;
#line 211
    i = cable->todo.next_item;
#line 211
    n = 0;
    {
#line 211
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 211
      if (! (n < cable->todo.num_items)) {
#line 211
        goto while_break___0;
      }
#line 213
      if ((unsigned int )(cable->todo.data + i)->action != 0U) {
#line 213
        if ((unsigned int )(cable->todo.data + i)->action != 2U) {
#line 213
          if ((unsigned int )(cable->todo.data + i)->action != 1U) {
#line 220
            goto while_break___0;
          }
        }
      }
#line 222
      if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 222
        if ((cable->todo.data + i)->arg.clock.tms != 0) {
#line 228
          goto while_break___0;
        }
      }
#line 230
      if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 232
        k = (cable->todo.data + i)->arg.clock.n;
#line 236
        bits += k;
      } else
#line 238
      if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 240
        k___0 = (cable->todo.data + i)->arg.transfer.len;
#line 244
        bits += k___0;
      }
#line 246
      i ++;
#line 247
      if (i >= cable->todo.max_items) {
#line 247
        i = 0;
      }
#line 211
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    if (bits == 0) {
      {
#line 256
      do_one_queued_action(cable);
      }
    } else
#line 254
    if (n <= 1) {
      {
#line 256
      do_one_queued_action(cable);
      }
    } else {
      {
#line 262
      tmp = malloc((size_t )bits);
#line 262
      in = (char *)tmp;
#line 263
      tmp___0 = malloc((size_t )bits);
#line 263
      out = (char *)tmp___0;
      }
#line 265
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 265
        goto _L;
      } else
#line 265
      if ((unsigned long )out == (unsigned long )((void *)0)) {
        _L: /* CIL Label */ 
#line 267
        if ((unsigned long )in != (unsigned long )((void *)0)) {
          {
#line 267
          free((void *)in);
          }
        }
#line 268
        if ((unsigned long )out != (unsigned long )((void *)0)) {
          {
#line 268
          free((void *)out);
          }
        }
        {
#line 269
        generic_flush_one_by_one(cable, how_much);
        }
#line 270
        goto while_break;
      }
#line 273
      j = 0;
#line 273
      bits = 0;
#line 273
      i = cable->todo.next_item;
      {
#line 273
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 273
        if (! (j < n)) {
#line 273
          goto while_break___1;
        }
#line 275
        if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 278
          k___1 = 0;
          {
#line 278
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 278
            if (! (k___1 < (cable->todo.data + i)->arg.clock.n)) {
#line 278
              goto while_break___2;
            }
#line 279
            tmp___1 = bits;
#line 279
            bits ++;
#line 279
            *(in + tmp___1) = (char )(cable->todo.data + i)->arg.clock.tdi;
#line 278
            k___1 ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        } else
#line 281
        if ((unsigned int )(cable->todo.data + i)->action == 2U) {
#line 283
          len = (cable->todo.data + i)->arg.transfer.len;
#line 284
          if (len > 0) {
            {
#line 286
            memcpy((void */* __restrict  */)(in + bits), (void const   */* __restrict  */)(cable->todo.data + i)->arg.transfer.in,
                   (size_t )len);
#line 287
            bits += len;
            }
          }
        }
#line 290
        i ++;
#line 291
        if (i >= cable->todo.max_items) {
#line 291
          i = 0;
        }
#line 273
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 296
      r = (*((cable->driver)->transfer))(cable, bits, in, out);
#line 304
      j = 0;
#line 304
      bits = 0;
#line 304
      i = cable->todo.next_item;
      }
      {
#line 304
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 304
        if (! (j < n)) {
#line 304
          goto while_break___3;
        }
#line 306
        if ((unsigned int )(cable->todo.data + i)->action == 0U) {
#line 309
          k___2 = 0;
          {
#line 309
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 309
            if (! (k___2 < (cable->todo.data + i)->arg.clock.n)) {
#line 309
              goto while_break___4;
            }
#line 310
            tmp___2 = bits;
#line 310
            bits ++;
#line 310
            tdo = (int )*(out + tmp___2);
#line 309
            k___2 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
        } else
#line 312
        if ((unsigned int )(cable->todo.data + i)->action == 1U) {
          {
#line 314
          tmp___3 = cable_add_queue_item(cable, & cable->done);
#line 314
          c = tmp___3;
#line 318
          (cable->done.data + c)->action = (enum __anonenum_action_990402164 )1;
#line 319
          (cable->done.data + c)->arg.value.tdo = tdo;
          }
        } else
#line 321
        if ((unsigned int )(cable->todo.data + i)->action == 2U) {
          {
#line 323
          p = (cable->todo.data + i)->arg.transfer.out;
#line 324
          len___0 = (cable->todo.data + i)->arg.transfer.len;
#line 325
          free((void *)(cable->todo.data + i)->arg.transfer.in);
          }
#line 326
          if ((unsigned long )p != (unsigned long )((void *)0)) {
            {
#line 328
            tmp___4 = cable_add_queue_item(cable, & cable->done);
#line 328
            c___0 = tmp___4;
#line 332
            (cable->done.data + c___0)->action = (enum __anonenum_action_990402164 )2;
#line 333
            (cable->done.data + c___0)->arg.xferred.len = len___0;
#line 334
            (cable->done.data + c___0)->arg.xferred.res = r;
#line 335
            (cable->done.data + c___0)->arg.xferred.out = p;
            }
#line 336
            if (len___0 > 0) {
              {
#line 336
              memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(out + bits),
                     (size_t )len___0);
              }
            }
          }
#line 338
          if (len___0 > 0) {
#line 338
            bits += len___0;
          }
#line 339
          if (bits > 0) {
#line 339
            tdo = (int )*(out + (bits - 1));
          }
        }
#line 341
        i ++;
#line 342
        if (i >= cable->todo.max_items) {
#line 342
          i = 0;
        }
#line 304
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 345
      cable->todo.next_item = i;
#line 346
      cable->todo.num_items -= n;
#line 348
      free((void *)in);
#line 349
      free((void *)out);
      }
    }
#line 199
    if (! (cable->todo.num_items > 0)) {
#line 199
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  return;
}
}
#line 355 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c"
void generic_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 
  double tolerance ;
  uint32_t loops ;
  uint32_t delay ;
  uint32_t frequency ;
  uint32_t i ;
  uint32_t new_delay ;
  long double start ;
  long double end ;
  long double real_frequency ;

  {
#line 358
  if (new_frequency == 0U) {
#line 359
    cable->delay = (uint32_t )0;
#line 360
    cable->frequency = (uint32_t )0;
  } else {
#line 362
    tolerance = 0.1;
#line 363
    loops = (uint32_t )2000;
#line 364
    delay = cable->delay;
#line 365
    frequency = cable->frequency;
#line 367
    if ((double )new_frequency > (1.0 - tolerance) * (double )frequency) {
#line 367
      if ((double )new_frequency < (1.0 + tolerance) * (double )frequency) {
#line 369
        return;
      }
    }
    {
#line 371
    printf((char const   */* __restrict  */)"requested frequency %u, now calibrating delay loop\n",
           new_frequency);
    }
    {
#line 373
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 377
      cable->delay = delay;
#line 378
      start = frealtime();
#line 379
      i = (uint32_t )0;
      }
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! (i < loops)) {
#line 379
          goto while_break___0;
        }
        {
#line 380
        (*((cable->driver)->clock))(cable, 0, 0, 1);
#line 379
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 382
      end = frealtime();
      }
#line 384
      if (! (end > start)) {
        {
#line 384
        __assert_fail("end > start", "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/generic.c",
                      384U, "generic_set_frequency");
        }
      }
      {
#line 385
      real_frequency = (long double )loops / (end - start);
#line 386
      printf((char const   */* __restrict  */)"new real frequency %Lg, delay %u\n",
             real_frequency, delay);
#line 389
      new_delay = (uint32_t )(((long double )delay * real_frequency) / (long double )new_frequency);
      }
#line 391
      if (real_frequency >= (long double )((1.0 - tolerance) * (double )new_frequency)) {
#line 392
        if (real_frequency <= (long double )((1.0 + tolerance) * (double )new_frequency)) {
#line 393
          frequency = (uint32_t )real_frequency;
#line 394
          goto while_break;
        }
#line 396
        if (new_delay > delay) {
#line 397
          delay = new_delay;
        } else {
#line 399
          delay ++;
        }
      } else {
#line 403
        if (delay == 0U) {
          {
#line 404
          printf((char const   */* __restrict  */)"operating without delay\n");
#line 405
          frequency = (uint32_t )real_frequency;
          }
#line 406
          goto while_break;
        }
#line 409
        if (new_delay < delay) {
#line 410
          delay = new_delay;
        } else
#line 412
        if (delay > 0U) {
#line 413
          delay --;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 418
    printf((char const   */* __restrict  */)"done\n");
#line 420
    cable->delay = delay;
#line 421
    cable->frequency = frequency;
    }
  }
#line 423
  return;
}
}
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static int ei012_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = parport_open(cable->link.port);
  }
#line 59
  if (tmp) {
#line 60
    return (-1);
  }
  {
#line 62
  data = parport_get_data(cable->link.port);
  }
#line 62
  if (data < 0) {
    {
#line 63
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 63
    if (tmp___0) {
#line 64
      return (-1);
    }
#line 65
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 67
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 69
  return (0);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static void ei012_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 77
  if (tms) {
#line 77
    tms = 1;
  } else {
#line 77
    tms = 0;
  }
#line 78
  if (tdi) {
#line 78
    tdi = 1;
  } else {
#line 78
    tdi = 0;
  }
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < n)) {
#line 80
      goto while_break;
    }
    {
#line 81
    parport_set_data(cable->link.port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | (tdi << 1)));
#line 82
    cable_wait(cable);
#line 83
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | 1) | (tms << 2)) | (tdi << 1)));
#line 84
    cable_wait(cable);
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static int ei012_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 91
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 92
  cable_wait(cable);
#line 93
  tmp = parport_get_status(cable->link.port);
  }
#line 93
  return ((tmp >> 7) & 1);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static int ei012_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 99
  if (trst) {
#line 99
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 99
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 101
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 102
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
cable_driver_t ei012_cable_driver  = 
#line 105
     {"EI012", "ETC EI012 JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & ei012_init, & generic_parport_done, & generic_set_frequency,
    & ei012_clock, & ei012_get_tdo, & generic_transfer, & ei012_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_parport_help};
#line 52 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static int ea253_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 65
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 67
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static void ea253_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | tdi));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static int ea253_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 89
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 90
  cable_wait(cable);
#line 91
  tmp = parport_get_status(cable->link.port);
  }
#line 91
  return ((tmp >> 4) & 1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static int ea253_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 97
  if (trst) {
#line 97
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 97
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 99
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 100
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
cable_driver_t ea253_cable_driver  = 
#line 103
     {"EA253", "ETC EA253 JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & ea253_init, & generic_parport_done, & generic_set_frequency,
    & ea253_clock, & ea253_get_tdo, & generic_transfer, & ea253_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_parport_help};
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static int dlc5_init(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = parport_open(cable->link.port);
  }
#line 62
  if (tmp) {
#line 63
    return (-1);
  }
#line 65
  ((generic_params_t *)cable->params)->trst = 1;
#line 67
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static void dlc5_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((1 << 4) | (tms << 2)) | tdi));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((1 << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static int dlc5_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 89
  parport_set_data(cable->link.port, (uint8_t )(1 << 4));
#line 90
  cable_wait(cable);
#line 91
  tmp = parport_get_status(cable->link.port);
  }
#line 91
  return ((tmp >> 4) & 1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static int dlc5_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 97
  return (1);
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
cable_driver_t dlc5_cable_driver  = 
#line 100
     {"DLC5", "Xilinx DLC5 JTAG Parallel Cable III", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & dlc5_init, & generic_parport_done, & generic_set_frequency,
    & dlc5_clock, & dlc5_get_tdo, & generic_transfer, & dlc5_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_parport_help};
#line 49 "../../include/jtag.h"
int detect_register_size(chain_t *chain ) ;
#line 50
void discovery(chain_t *chain ) ;
#line 41 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/discovery.c"
int detect_register_size(chain_t *chain ) 
{ 
  int len ;
  tap_register *rz ;
  tap_register *rout ;
  tap_register *rpat ;
  int tdo ;
  int tdo_stuck ;
  int p ;
  int ok ;
  tap_register *tmp ;
  tap_register *tmp___0 ;
  tap_register *tmp___1 ;
  int i ;
  char const   *s ;
  int tmp___2 ;
  char *tmp___3 ;

  {
#line 50
  tdo_stuck = -2;
#line 52
  len = 1;
  {
#line 52
  while (1) {
    while_continue: /* CIL Label */ ;
#line 52
    if (! (len <= 1024)) {
#line 52
      goto while_break;
    }
    {
#line 54
    ok = 0;
#line 56
    tmp = register_alloc(len);
#line 56
    rz = register_fill(tmp, 0);
#line 57
    rout = register_alloc(8 + len);
#line 58
    tmp___0 = register_alloc(8 + len);
#line 58
    tmp___1 = register_fill(tmp___0, 0);
#line 58
    rpat = register_inc(tmp___1);
#line 60
    p = 1;
    }
    {
#line 60
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 60
      if (! (p < 1 << 8)) {
#line 60
        goto while_break___0;
      }
      {
#line 63
      ok = 0;
#line 65
      s = register_get_string((tap_register const   *)rpat);
      }
      {
#line 66
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 66
        if (! *s) {
#line 66
          goto while_break___1;
        }
#line 67
        s ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 69
      i = 0;
      {
#line 69
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 69
        if (! (i < 1)) {
#line 69
          goto while_break___2;
        }
        {
#line 70
        tap_shift_register(chain, (tap_register const   *)rz, (tap_register *)((void *)0),
                           0);
#line 71
        tap_shift_register(chain, (tap_register const   *)rpat, rout, 0);
#line 73
        tdo = register_all_bits_same_value((tap_register const   *)rout);
        }
#line 74
        if (tdo_stuck == -2) {
#line 74
          tdo_stuck = tdo;
        }
#line 75
        if (tdo_stuck != tdo) {
#line 75
          tdo_stuck = -1;
        }
        {
#line 77
        register_shift_right(rout, len);
#line 79
        tmp___2 = register_compare((tap_register const   *)rpat, (tap_register const   *)rout);
        }
#line 79
        if (tmp___2 == 0) {
#line 80
          ok ++;
        }
#line 69
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 82
      if (100 * ok < 100) {
#line 83
        ok = 0;
#line 84
        goto while_break___0;
      }
      {
#line 87
      register_inc(rpat);
#line 60
      p ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 90
    register_free(rz);
#line 91
    register_free(rout);
#line 92
    register_free(rpat);
    }
#line 94
    if (ok) {
#line 95
      return (len);
    }
#line 52
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  if (tdo_stuck >= 0) {
    {
#line 100
    tmp___3 = gettext("Warning: TDO seems to be stuck at %d\n");
#line 100
    printf((char const   */* __restrict  */)tmp___3, tdo_stuck);
    }
  }
#line 103
  return (-1);
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/discovery.c"
void jtag_reset(chain_t *chain ) 
{ 


  {
  {
#line 109
  chain_set_trst(chain, 0);
#line 110
  chain_set_trst(chain, 1);
#line 112
  tap_reset(chain);
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/discovery.c"
void discovery(chain_t *chain ) 
{ 
  int irlen ;
  tap_register *ir ;
  tap_register *irz ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  tap_register *tmp___2 ;
  char *tmp___3 ;
  int rs ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 123
  jtag_reset(chain);
#line 125
  tmp = gettext("Detecting IR length ... ");
#line 125
  printf((char const   */* __restrict  */)tmp);
#line 126
  fflush(stdout);
#line 128
  tap_capture_ir(chain);
#line 129
  irlen = detect_register_size(chain);
#line 131
  tmp___0 = gettext("%d\n");
#line 131
  printf((char const   */* __restrict  */)tmp___0, irlen);
  }
#line 133
  if (irlen < 1) {
    {
#line 134
    tmp___1 = gettext("Error: Invalid IR length!\n");
#line 134
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 135
    return;
  }
  {
#line 139
  tmp___2 = register_alloc(irlen);
#line 139
  ir = register_fill(tmp___2, 1);
#line 140
  irz = register_duplicate((tap_register const   *)ir);
  }
#line 142
  if (! ir) {
    {
#line 143
    register_free(ir);
#line 144
    register_free(irz);
#line 145
    tmp___3 = gettext("Error: Out of memory!\n");
#line 145
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 146
    return;
  } else
#line 142
  if (! irz) {
    {
#line 143
    register_free(ir);
#line 144
    register_free(irz);
#line 145
    tmp___3 = gettext("Error: Out of memory!\n");
#line 145
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 146
    return;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 152
    jtag_reset(chain);
#line 154
    tap_capture_ir(chain);
#line 155
    tap_shift_register(chain, (tap_register const   *)ir, (tap_register *)((void *)0),
                       1);
#line 157
    tmp___4 = register_get_string((tap_register const   *)ir);
#line 157
    tmp___5 = gettext("Detecting DR length for IR %s ... ");
#line 157
    printf((char const   */* __restrict  */)tmp___5, tmp___4);
#line 158
    fflush(stdout);
#line 160
    tap_capture_dr(chain);
#line 161
    rs = detect_register_size(chain);
#line 163
    tmp___6 = gettext("%d\n");
#line 163
    printf((char const   */* __restrict  */)tmp___6, rs);
#line 165
    register_inc(ir);
#line 166
    tmp___7 = register_compare((tap_register const   *)ir, (tap_register const   *)irz);
    }
#line 166
    if (tmp___7 == 0) {
#line 167
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 169
  register_free(ir);
#line 170
  register_free(irz);
  }
#line 171
  return;
}
}
#line 837 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 32 "/usr/include/x86_64-linux-gnu/sys/io.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioperm)(unsigned long __from ,
                                                                             unsigned long __num ,
                                                                             int __turn_on ) ;
#line 38
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iopl)(int __level ) ;
#line 42 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static unsigned char inb(unsigned short __port ) 
{ 
  unsigned char _v ;

  {
#line 47
  __asm__  volatile   ("inb %w1,%0": "=a" (_v): "Nd" (__port));
#line 48
  return (_v);
}
}
#line 95 "/usr/include/x86_64-linux-gnu/sys/io.h"
__inline static void outb(unsigned char __value , unsigned short __port ) 
{ 


  {
#line 98
  __asm__  volatile   ("outb %b0,%w1": : "a" (__value), "Nd" (__port));
#line 99
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static port_node_t *ports___0  =    (port_node_t *)((void *)0);
#line 111 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static parport_t *direct_parport_alloc(unsigned int port ) 
{ 
  direct_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;

  {
  {
#line 114
  tmp = malloc(sizeof(*params));
#line 114
  params = (direct_params_t *)tmp;
#line 115
  tmp___0 = malloc(sizeof(*parport));
#line 115
  parport = (parport_t *)tmp___0;
#line 116
  tmp___1 = malloc(sizeof(*node));
#line 116
  node = (port_node_t *)tmp___1;
  }
#line 118
  if (! node) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! parport) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! params) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  }
#line 125
  params->port = port;
#line 127
  parport->params = (void *)params;
#line 128
  parport->driver = & direct_parport_driver;
#line 129
  parport->cable = (cable_t *)((void *)0);
#line 131
  node->port = parport;
#line 132
  node->next = ports___0;
#line 134
  ports___0 = node;
#line 136
  return (parport);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static void direct_parport_free(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 144
  prev = & ports___0;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! *prev) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 146
      goto while_break;
    }
#line 144
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (*prev) {
    {
#line 149
    pn = *prev;
#line 150
    *prev = pn->next;
#line 151
    free((void *)pn);
    }
  }
  {
#line 154
  free(port->params);
#line 155
  free((void *)port);
  }
#line 156
  return;
}
}
#line 158 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
parport_t *direct_connect(char const   **par , int parnum ) 
{ 
  long port_scan_val ;
  unsigned int port ;
  port_node_t *pn ;
  parport_t *parport ;
  char *tmp ;
  char *tmp___0 ;
  unsigned int aport ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 163
  pn = ports___0;
#line 166
  if (parnum != 1) {
    {
#line 167
    tmp = gettext("Syntax error!\n");
#line 167
    printf((char const   */* __restrict  */)tmp);
    }
#line 168
    return ((parport_t *)((void *)0));
  }
  {
#line 171
  port_scan_val = strtol((char const   */* __restrict  */)*(par + 0), (char **/* __restrict  */)((void *)0),
                         0);
  }
#line 173
  if (port_scan_val < 0L) {
    {
#line 174
    tmp___0 = gettext("Invalid port address!\n");
#line 174
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 175
    return ((parport_t *)((void *)0));
  } else
#line 173
  if (port_scan_val + 3L > 65535L) {
    {
#line 174
    tmp___0 = gettext("Invalid port address!\n");
#line 174
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 175
    return ((parport_t *)((void *)0));
  }
#line 178
  port = (unsigned int )port_scan_val;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! pn) {
#line 180
      goto while_break;
    }
#line 181
    pn = ports___0;
    {
#line 181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 181
      if (! pn) {
#line 181
        goto while_break___0;
      }
      {
#line 184
      aport = ((direct_params_t *)(pn->port)->params)->port;
#line 185
      tmp___3 = abs((int )(aport - port));
      }
#line 185
      if (tmp___3 < 3) {
        {
#line 186
        tmp___1 = gettext((((pn->port)->cable)->driver)->description);
#line 186
        tmp___2 = gettext("Disconnecting %s from parallel port at 0x%x\n");
#line 186
        printf((char const   */* __restrict  */)tmp___2, tmp___1, aport);
#line 187
        (*((((pn->port)->cable)->driver)->disconnect))((pn->port)->cable);
        }
#line 188
        goto while_break___0;
      }
#line 181
      pn = pn->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 192
  tmp___4 = gettext("Initializing parallel port at 0x%x\n");
#line 192
  printf((char const   */* __restrict  */)tmp___4, port);
#line 194
  parport = direct_parport_alloc(port);
  }
#line 195
  if (! parport) {
    {
#line 196
    tmp___5 = gettext("%s(%d) Out of memory.\n");
#line 196
    printf((char const   */* __restrict  */)tmp___5, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c",
           196);
    }
#line 197
    return ((parport_t *)((void *)0));
  }
#line 200
  return (parport);
}
}
#line 203 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_open(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 206
  port = ((direct_params_t *)parport->params)->port;
#line 207
  if (port + 3U <= 1024U) {
    {
#line 207
    tmp = ioperm((unsigned long )port, 3UL, 1);
    }
#line 207
    if (tmp) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 207
  if (port + 3U > 1024U) {
    {
#line 207
    tmp___0 = iopl(3);
    }
#line 207
    if (tmp___0) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      tmp___1 = 0;
    }
  } else {
#line 207
    tmp___1 = 0;
  }
#line 207
  return (tmp___1);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_close(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 213
  port = ((direct_params_t *)parport->params)->port;
#line 214
  if (port + 3U <= 1024U) {
    {
#line 214
    tmp = ioperm((unsigned long )port, 3UL, 0);
#line 214
    tmp___1 = tmp;
    }
  } else {
    {
#line 214
    tmp___0 = iopl(0);
#line 214
    tmp___1 = tmp___0;
    }
  }
#line 214
  return (tmp___1);
}
}
#line 217 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_set_data(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 220
  port = ((direct_params_t *)parport->params)->port;
#line 221
  outb(data, (unsigned short )port);
  }
#line 222
  return (0);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_get_data(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 228
  port = ((direct_params_t *)parport->params)->port;
#line 229
  tmp = inb((unsigned short )port);
  }
#line 229
  return ((int )tmp);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_get_status(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 235
  port = ((direct_params_t *)parport->params)->port;
#line 236
  tmp = inb((unsigned short )(port + 1U));
  }
#line 236
  return ((int )tmp ^ 128);
}
}
#line 239 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_set_control(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 242
  port = ((direct_params_t *)parport->params)->port;
#line 243
  outb((unsigned char )((int )data ^ 11), (unsigned short )(port + 2U));
  }
#line 244
  return (0);
}
}
#line 247 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
parport_driver_t direct_parport_driver  = 
#line 247
     {"parallel", & direct_connect, & direct_parport_free, & direct_open, & direct_close,
    & direct_set_data, & direct_get_data, & direct_get_status, & direct_set_control};
#line 564 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 252 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 302
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 57 "../../include/part.h"
part_t *part_alloc(tap_register const   *id ) ;
#line 75
parts_t *parts_alloc(void) ;
#line 76
void parts_free(parts_t *ps ) ;
#line 77
int parts_add_part(parts_t *ps , part_t *p ) ;
#line 47 "../../include/jtag.h"
int detect_parts(chain_t *chain , char const   *db_path ) ;
#line 48
int manual_add(chain_t *chain , int instr_len ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/detect.c"
static int find_record(char *filename , tap_register *key , struct id_record *idr ) 
{ 
  FILE *file ;
  tap_register *tr ;
  int r ;
  char *tmp ;
  char *p ;
  char *s ;
  char line[1024] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 54
  r = 0;
#line 56
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 57
  if (! file) {
    {
#line 58
    tmp = gettext("Cannot open %s\n");
#line 58
    printf((char const   */* __restrict  */)tmp, filename);
    }
#line 59
    return (0);
  }
  {
#line 62
  tr = register_alloc(key->len);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)file);
    }
#line 69
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 70
      goto while_break;
    }
    {
#line 73
    p = strpbrk((char const   *)(line), "#\n");
    }
#line 74
    if (p) {
#line 75
      *p = (char )'\000';
    }
#line 77
    p = line;
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (*p) {
        {
#line 80
        tmp___1 = __ctype_b_loc();
        }
#line 80
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 80
          goto while_break___0;
        }
      } else {
#line 80
        goto while_break___0;
      }
#line 81
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 84
    s = strchr((char const   *)p, '\000');
    }
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! ((unsigned long )s != (unsigned long )p)) {
#line 85
        goto while_break___1;
      }
      {
#line 86
      tmp___2 = __ctype_b_loc();
#line 86
      s --;
      }
#line 86
      if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 87
        goto while_break___1;
      }
#line 88
      *s = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 92
    if (! *p) {
#line 93
      goto __Cont;
    }
#line 96
    s = p;
    {
#line 97
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 97
      if (*s) {
        {
#line 97
        tmp___3 = __ctype_b_loc();
        }
#line 97
        if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 97
          goto while_break___2;
        }
      } else {
#line 97
        goto while_break___2;
      }
#line 98
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 99
    if (*s) {
#line 100
      tmp___4 = s;
#line 100
      s ++;
#line 100
      *tmp___4 = (char )'\000';
    }
    {
#line 103
    tmp___5 = strlen((char const   *)p);
    }
#line 103
    if (tmp___5 != (size_t )key->len) {
#line 104
      goto __Cont;
    }
    {
#line 107
    register_init(tr, (char const   *)p);
#line 108
    tmp___6 = register_compare((tap_register const   *)tr, (tap_register const   *)key);
    }
#line 108
    if (tmp___6) {
#line 109
      goto __Cont;
    }
#line 112
    p = s;
    {
#line 115
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 115
      if (*p) {
        {
#line 115
        tmp___7 = __ctype_b_loc();
        }
#line 115
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 115
          goto while_break___3;
        }
      } else {
#line 115
        goto while_break___3;
      }
#line 116
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 119
    if (! *p) {
#line 120
      goto __Cont;
    }
#line 123
    s = p;
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 124
      if (*s) {
        {
#line 124
        tmp___8 = __ctype_b_loc();
        }
#line 124
        if ((int const   )*(*tmp___8 + (int )*s) & 8192) {
#line 124
          goto while_break___4;
        }
      } else {
#line 124
        goto while_break___4;
      }
#line 125
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 126
    if (*s) {
#line 127
      tmp___9 = s;
#line 127
      s ++;
#line 127
      *tmp___9 = (char )'\000';
    }
    {
#line 130
    tmp___10 = strlen((char const   *)p);
    }
#line 130
    if (tmp___10 >= sizeof(idr->name)) {
#line 131
      goto __Cont;
    }
    {
#line 134
    strcpy((char */* __restrict  */)(idr->name), (char const   */* __restrict  */)p);
#line 137
    p = s;
    }
    {
#line 140
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 140
      if (*p) {
        {
#line 140
        tmp___11 = __ctype_b_loc();
        }
#line 140
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 140
          goto while_break___5;
        }
      } else {
#line 140
        goto while_break___5;
      }
#line 141
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 144
    if (! *p) {
#line 145
      goto __Cont;
    }
    {
#line 148
    tmp___12 = strlen((char const   *)p);
    }
#line 148
    if (tmp___12 >= sizeof(idr->fullname)) {
#line 149
      goto __Cont;
    }
    {
#line 152
    strcpy((char */* __restrict  */)(idr->fullname), (char const   */* __restrict  */)p);
#line 154
    r = 1;
    }
#line 155
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  fclose(file);
#line 160
  register_free(tr);
  }
#line 162
  return (r);
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/detect.c"
uint64_t bits_to_uint64(tap_register *t ) 
{ 
  int i ;
  uint64_t l ;
  uint64_t b ;

  {
#line 170
  l = (uint64_t )0;
#line 170
  b = (uint64_t )1;
#line 171
  i = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (i < t->len)) {
#line 171
      goto while_break;
    }
#line 172
    if ((int )*(t->data + i) & 1) {
#line 172
      l |= b;
    }
#line 173
    b <<= 1;
#line 171
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (l);
}
}
#line 179 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/detect.c"
int detect_parts(chain_t *chain , char const   *db_path ) 
{ 
  int irlen ;
  tap_register *ir ;
  int chlen ;
  tap_register *one ;
  tap_register *ones ;
  tap_register *br ;
  tap_register *id ;
  parts_t *ps ;
  int i ;
  char data_path[1024] ;
  char *cmd[3] ;
  char manufacturer[26] ;
  char partname[21] ;
  char stepping[9] ;
  char *tmp ;
  tap_register *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  tap_register *tmp___4 ;
  tap_register *tmp___5 ;
  char *tmp___6 ;
  part_t *part ;
  tap_register *did ;
  tap_register *key ;
  struct id_record idr ;
  char *p ;
  int tmp___7 ;
  uint64_t tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  size_t tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  size_t tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  size_t tmp___26 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;

  {
  {
#line 193
  cmd[0] = (char *)"include";
#line 193
  cmd[1] = data_path;
#line 193
  cmd[2] = (char *)((void *)0);
#line 199
  tap_reset(chain);
#line 200
  tap_capture_ir(chain);
#line 201
  irlen = detect_register_size(chain);
  }
#line 202
  if (irlen < 1) {
#line 203
    return (0);
  }
  {
#line 205
  tmp = gettext("IR length: %d\n");
#line 205
  printf((char const   */* __restrict  */)tmp, irlen);
#line 206
  chain->total_instr_len = irlen;
#line 209
  tmp___0 = register_alloc(irlen);
#line 209
  ir = register_fill(tmp___0, 1);
  }
#line 210
  if ((unsigned long )ir == (unsigned long )((void *)0)) {
    {
#line 211
    tmp___1 = gettext("out of memory\n");
#line 211
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 212
    return (0);
  }
  {
#line 215
  tap_shift_register(chain, (tap_register const   *)ir, (tap_register *)((void *)0),
                     1);
#line 216
  register_free(ir);
#line 219
  tap_capture_dr(chain);
#line 220
  chlen = detect_register_size(chain);
  }
#line 221
  if (chlen < 1) {
    {
#line 222
    tmp___2 = gettext("Unable to detect JTAG chain length\n");
#line 222
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 223
    return (0);
  }
  {
#line 225
  tmp___3 = gettext("Chain length: %d\n");
#line 225
  printf((char const   */* __restrict  */)tmp___3, chlen);
#line 228
  tmp___4 = register_alloc(1);
#line 228
  one = register_fill(tmp___4, 1);
#line 229
  tmp___5 = register_alloc(31);
#line 229
  ones = register_fill(tmp___5, 1);
#line 230
  br = register_alloc(1);
#line 231
  id = register_alloc(32);
#line 232
  ps = parts_alloc();
  }
#line 233
  if (! one) {
#line 233
    goto _L;
  } else
#line 233
  if (! ones) {
#line 233
    goto _L;
  } else
#line 233
  if (! br) {
#line 233
    goto _L;
  } else
#line 233
  if (! id) {
#line 233
    goto _L;
  } else
#line 233
  if (! ps) {
    _L: /* CIL Label */ 
    {
#line 234
    tmp___6 = gettext("out of memory\n");
#line 234
    printf((char const   */* __restrict  */)tmp___6);
#line 236
    register_free(one);
#line 237
    register_free(ones);
#line 238
    register_free(br);
#line 239
    register_free(id);
#line 240
    parts_free(ps);
    }
#line 241
    return (0);
  }
  {
#line 243
  chain->parts = ps;
#line 244
  chain->active_part = 0;
#line 247
  tap_reset(chain);
#line 248
  tap_capture_dr(chain);
#line 250
  i = 0;
  }
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < chlen)) {
#line 250
      goto while_break;
    }
    {
#line 252
    did = br;
#line 257
    tap_shift_register(chain, (tap_register const   *)one, br, 0);
#line 258
    tmp___7 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 258
    if (tmp___7 == 0) {
      {
#line 260
      tap_shift_register(chain, (tap_register const   *)ones, id, 0);
#line 261
      register_shift_left(id, 1);
#line 262
      *(id->data + 0) = (char)1;
#line 263
      did = id;
      }
    }
    {
#line 266
    tmp___8 = bits_to_uint64(did);
#line 266
    tmp___9 = register_get_string((tap_register const   *)did);
#line 266
    tmp___10 = gettext("Device Id: %s (0x%016lX)\n");
#line 266
    printf((char const   */* __restrict  */)tmp___10, tmp___9, tmp___8);
#line 268
    part = part_alloc((tap_register const   *)did);
    }
#line 269
    if ((unsigned long )part == (unsigned long )((void *)0)) {
      {
#line 270
      tmp___11 = gettext("Out of memory\n");
#line 270
      printf((char const   */* __restrict  */)tmp___11);
      }
#line 271
      goto while_break;
    }
    {
#line 273
    parts_add_part(ps, part);
    }
#line 275
    if ((unsigned long )did == (unsigned long )br) {
#line 276
      goto __Cont;
    }
    {
#line 278
    chain->active_part = ps->len - 1;
#line 281
    tmp___28 = register_get_string((tap_register const   *)did);
#line 281
    tmp___29 = bsdl_scan_files(chain, tmp___28, (((1 << 4) | (1 << 6)) | (1 << 7)) | (1 << 3));
    }
#line 281
    if (tmp___29 <= 0) {
      {
#line 287
      strcpy((char */* __restrict  */)(data_path), (char const   */* __restrict  */)db_path);
#line 290
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/MANUFACTURERS");
#line 292
      key = register_alloc(11);
#line 293
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 1),
             (size_t )key->len);
#line 294
      tmp___13 = find_record(data_path, key, & idr);
      }
#line 294
      if (! tmp___13) {
        {
#line 295
        tmp___12 = gettext("  Unknown manufacturer!\n");
#line 295
        printf((char const   */* __restrict  */)tmp___12);
#line 296
        register_free(key);
        }
#line 297
        goto __Cont;
      }
      {
#line 299
      register_free(key);
#line 301
      tmp___14 = gettext("  Manufacturer: %s\n");
#line 301
      printf((char const   */* __restrict  */)tmp___14, idr.fullname);
#line 302
      tmp___16 = strlen((char const   *)(idr.fullname));
      }
#line 302
      if (tmp___16 > 25UL) {
        {
#line 303
        tmp___15 = gettext("Warning: Manufacturer too long\n");
#line 303
        printf((char const   */* __restrict  */)tmp___15);
        }
      }
      {
#line 304
      strncpy((char */* __restrict  */)(manufacturer), (char const   */* __restrict  */)(idr.fullname),
              (size_t )25);
#line 305
      manufacturer[25] = (char )'\000';
#line 308
      p = strrchr((char const   *)(data_path), '/');
      }
#line 309
      if (p) {
#line 310
        *(p + 1) = (char )'\000';
      } else {
#line 312
        data_path[0] = (char )'\000';
      }
      {
#line 313
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 314
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/PARTS");
#line 316
      key = register_alloc(16);
#line 317
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 12),
             (size_t )key->len);
#line 318
      tmp___18 = find_record(data_path, key, & idr);
      }
#line 318
      if (! tmp___18) {
        {
#line 319
        tmp___17 = gettext("  Unknown part!\n");
#line 319
        printf((char const   */* __restrict  */)tmp___17);
#line 320
        register_free(key);
        }
#line 321
        goto __Cont;
      }
      {
#line 323
      register_free(key);
#line 325
      tmp___19 = gettext("  Part(%d):         %s\n");
#line 325
      printf((char const   */* __restrict  */)tmp___19, chain->active_part, idr.fullname);
#line 326
      tmp___21 = strlen((char const   *)(idr.fullname));
      }
#line 326
      if (tmp___21 > 20UL) {
        {
#line 327
        tmp___20 = gettext("Warning: Part too long\n");
#line 327
        printf((char const   */* __restrict  */)tmp___20);
        }
      }
      {
#line 328
      strncpy((char */* __restrict  */)(partname), (char const   */* __restrict  */)(idr.fullname),
              (size_t )20);
#line 329
      partname[20] = (char )'\000';
#line 332
      p = strrchr((char const   *)(data_path), '/');
      }
#line 333
      if (p) {
#line 334
        *(p + 1) = (char )'\000';
      } else {
#line 336
        data_path[0] = (char )'\000';
      }
      {
#line 337
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 338
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)"/STEPPINGS");
#line 340
      key = register_alloc(4);
#line 341
      memcpy((void */* __restrict  */)key->data, (void const   */* __restrict  */)(id->data + 28),
             (size_t )key->len);
#line 342
      tmp___23 = find_record(data_path, key, & idr);
      }
#line 342
      if (! tmp___23) {
        {
#line 343
        tmp___22 = gettext("  Unknown stepping!\n");
#line 343
        printf((char const   */* __restrict  */)tmp___22);
#line 344
        register_free(key);
        }
#line 345
        goto __Cont;
      }
      {
#line 347
      register_free(key);
#line 349
      tmp___24 = gettext("  Stepping:     %s\n");
#line 349
      printf((char const   */* __restrict  */)tmp___24, idr.fullname);
#line 350
      tmp___26 = strlen((char const   *)(idr.fullname));
      }
#line 350
      if (tmp___26 > 8UL) {
        {
#line 351
        tmp___25 = gettext("Warning: Stepping too long\n");
#line 351
        printf((char const   */* __restrict  */)tmp___25);
        }
      }
      {
#line 352
      strncpy((char */* __restrict  */)(stepping), (char const   */* __restrict  */)(idr.fullname),
              (size_t )8);
#line 353
      stepping[8] = (char )'\000';
#line 356
      p = strrchr((char const   *)(data_path), '/');
      }
#line 357
      if (p) {
#line 358
        *(p + 1) = (char )'\000';
      } else {
#line 360
        data_path[0] = (char )'\000';
      }
      {
#line 361
      strcat((char */* __restrict  */)(data_path), (char const   */* __restrict  */)(idr.name));
#line 363
      tmp___27 = gettext("  Filename:     %s\n");
#line 363
      printf((char const   */* __restrict  */)tmp___27, data_path);
#line 366
      strcpy((char */* __restrict  */)(part->manufacturer), (char const   */* __restrict  */)(manufacturer));
#line 367
      strcpy((char */* __restrict  */)(part->part), (char const   */* __restrict  */)(partname));
#line 368
      strcpy((char */* __restrict  */)(part->stepping), (char const   */* __restrict  */)(stepping));
#line 369
      cmd_run(chain, cmd);
      }
    }
#line 374
    if ((unsigned long )part->active_instruction == (unsigned long )((void *)0)) {
      {
#line 375
      part->active_instruction = part_find_instruction(part, "IDCODE");
      }
    }
    __Cont: /* CIL Label */ 
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 378
  i = 0;
  {
#line 378
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 378
    if (! (i < 32)) {
#line 378
      goto while_break___0;
    }
    {
#line 379
    tap_shift_register(chain, (tap_register const   *)one, br, 0);
#line 380
    tmp___31 = register_compare((tap_register const   *)one, (tap_register const   *)br);
    }
#line 380
    if (tmp___31 != 0) {
      {
#line 381
      tmp___30 = gettext("Error: Unable to detect JTAG chain end!\n");
#line 381
      printf((char const   */* __restrict  */)tmp___30);
      }
#line 382
      goto while_break___0;
    }
#line 378
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 385
  tap_shift_register(chain, (tap_register const   *)one, (tap_register *)((void *)0),
                     1);
#line 387
  register_free(one);
#line 388
  register_free(ones);
#line 389
  register_free(br);
#line 390
  register_free(id);
  }
#line 392
  return (ps->len);
}
}
#line 398 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/detect.c"
int manual_add(chain_t *chain , int instr_len ) 
{ 
  tap_register *id ;
  part_t *part ;
  char *cmd[5] ;
  char *str ;
  int result ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 402
  cmd[0] = (char *)((void *)0);
#line 402
  cmd[1] = (char *)((void *)0);
#line 402
  cmd[2] = (char *)((void *)0);
#line 402
  cmd[3] = (char *)((void *)0);
#line 402
  cmd[4] = (char *)((void *)0);
#line 406
  id = register_alloc(1);
  }
#line 407
  if ((unsigned long )id == (unsigned long )((void *)0)) {
    {
#line 408
    tmp = gettext("Error: Unable to allocate a register!\n");
#line 408
    printf((char const   */* __restrict  */)tmp);
    }
#line 409
    return (0);
  }
#line 413
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
    {
#line 414
    chain->parts = parts_alloc();
    }
#line 415
    if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
      {
#line 416
      tmp___0 = gettext("Error: Unable to allocate space for parts!\n");
#line 416
      printf((char const   */* __restrict  */)tmp___0);
      }
#line 417
      return (0);
    }
  }
  {
#line 421
  part = part_alloc((tap_register const   *)id);
  }
#line 422
  if ((unsigned long )part == (unsigned long )((void *)0)) {
    {
#line 423
    tmp___1 = gettext("Error: Unable to allocate space for a part!\n");
#line 423
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 424
    return (0);
  }
  {
#line 427
  strncpy((char */* __restrict  */)(part->part), (char const   */* __restrict  */)"unknown",
          (size_t )20);
#line 428
  part->instruction_length = instr_len;
#line 430
  parts_add_part(chain->parts, part);
#line 431
  chain->active_part = (chain->parts)->len - 1;
#line 434
  cmd[0] = (char *)"register";
#line 435
  cmd[1] = (char *)"BR";
#line 436
  cmd[2] = (char *)"1";
#line 437
  cmd[3] = (char *)((void *)0);
#line 438
  tmp___3 = cmd_run(chain, cmd);
  }
#line 438
  if (tmp___3 < 1) {
    {
#line 439
    tmp___2 = gettext("Error: could not set BR register");
#line 439
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 440
    return (0);
  }
  {
#line 444
  cmd[0] = (char *)"instruction";
#line 445
  cmd[1] = (char *)"BYPASS";
#line 446
  cmd[3] = (char *)"BR";
#line 447
  cmd[4] = (char *)((void *)0);
#line 448
  tmp___4 = calloc((size_t )(instr_len + 1), sizeof(char ));
#line 448
  str = (char *)tmp___4;
  }
#line 449
  if ((unsigned long )str == (unsigned long )((void *)0)) {
    {
#line 450
    tmp___5 = gettext("Out of memory!\n");
#line 450
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 451
    return (0);
  }
  {
#line 454
  memset((void *)str, '1', (size_t )instr_len);
#line 455
  *(str + instr_len) = (char )'\000';
#line 456
  cmd[2] = str;
#line 457
  result = cmd_run(chain, cmd);
#line 458
  free((void *)str);
  }
#line 460
  if (result < 1) {
    {
#line 461
    tmp___6 = gettext("Error: could not set BYPASS instruction");
#line 461
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 462
    return (0);
  }
#line 466
  chain->total_instr_len += instr_len;
#line 468
  return ((chain->parts)->len);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.h"
int cx_cmd_push(cx_cmd_root_t *cmd_root , uint8_t d ) ;
#line 51
cx_cmd_t *cx_cmd_dequeue(cx_cmd_root_t *cmd_root ) ;
#line 52
void cx_cmd_free(cx_cmd_t *cmd ) ;
#line 53
cx_cmd_t *cx_cmd_queue(cx_cmd_root_t *cmd_root , uint32_t to_recv ) ;
#line 54
void cx_cmd_init(cx_cmd_root_t *cmd_root ) ;
#line 55
void cx_cmd_deinit(cx_cmd_root_t *cmd_root ) ;
#line 57
void cx_xfer(cx_cmd_root_t *cmd_root , cx_cmd_t const   *out_cmd , cable_t *cable ,
             cable_flush_amount_t how_much ) ;
#line 59
uint8_t cx_xfer_recv(cable_t *cable ) ;
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
static int extend_cmd_buffer(cx_cmd_t *cmd ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 53
  if (cmd->buf_pos >= cmd->buf_len) {
#line 55
    cmd->buf_len *= 2U;
#line 56
    if (cmd->buf) {
      {
#line 57
      tmp = realloc((void *)cmd->buf, (size_t )cmd->buf_len);
#line 57
      cmd->buf = (uint8_t *)tmp;
      }
    }
  }
#line 60
  if (cmd->buf) {
#line 60
    tmp___0 = 1;
  } else {
#line 60
    tmp___0 = 0;
  }
#line 60
  return (tmp___0);
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
int cx_cmd_push(cx_cmd_root_t *cmd_root , uint8_t d ) 
{ 
  cx_cmd_t *cmd ;
  int tmp ;
  uint32_t tmp___0 ;

  {
#line 80
  cmd = cmd_root->last;
#line 82
  if (! cmd) {
#line 83
    return (0);
  }
  {
#line 85
  tmp = extend_cmd_buffer(cmd);
  }
#line 85
  if (! tmp) {
#line 86
    return (0);
  }
#line 88
  tmp___0 = cmd->buf_pos;
#line 88
  (cmd->buf_pos) ++;
#line 88
  *(cmd->buf + tmp___0) = d;
#line 90
  return (1);
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
cx_cmd_t *cx_cmd_dequeue(cx_cmd_root_t *cmd_root ) 
{ 
  cx_cmd_t *cmd ;
  cx_cmd_t *tmp ;

  {
#line 109
  cmd = cmd_root->first;
#line 111
  if (cmd) {
#line 113
    tmp = cmd->next;
#line 113
    cmd_root->first = tmp;
#line 113
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 114
      cmd_root->last = (cx_cmd_t *)((void *)0);
    }
#line 115
    cmd->next = (cx_cmd_t *)((void *)0);
  }
#line 118
  return (cmd);
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
void cx_cmd_free(cx_cmd_t *cmd ) 
{ 


  {
#line 136
  if (cmd) {
#line 138
    if (cmd->buf) {
      {
#line 139
      free((void *)cmd->buf);
      }
    }
    {
#line 140
    free((void *)cmd);
    }
  }
#line 142
  return;
}
}
#line 160 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
cx_cmd_t *cx_cmd_queue(cx_cmd_root_t *cmd_root , uint32_t to_recv ) 
{ 
  cx_cmd_t *cmd ;
  void *tmp ;
  uint8_t *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 163
  tmp = malloc(sizeof(cx_cmd_t ));
#line 163
  cmd = (cx_cmd_t *)tmp;
  }
#line 165
  if (cmd) {
    {
#line 167
    cmd->buf_len = (uint32_t )64;
#line 168
    tmp___1 = malloc((size_t )cmd->buf_len);
#line 168
    tmp___0 = (uint8_t *)tmp___1;
#line 168
    cmd->buf = tmp___0;
    }
#line 168
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 170
      free((void *)cmd);
#line 171
      cmd = (cx_cmd_t *)((void *)0);
      }
    } else {
#line 175
      cmd->buf_pos = (uint32_t )0;
#line 176
      cmd->to_recv = to_recv;
#line 177
      cmd->next = (cx_cmd_t *)((void *)0);
#line 178
      if (! cmd_root->first) {
#line 179
        cmd_root->first = cmd;
      }
#line 180
      if (cmd_root->last) {
#line 181
        (cmd_root->last)->next = cmd;
      }
#line 182
      cmd_root->last = cmd;
    }
  }
#line 186
  return (cmd);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
void cx_cmd_init(cx_cmd_root_t *cmd_root ) 
{ 


  {
#line 204
  cmd_root->first = (cx_cmd_t *)((void *)0);
#line 205
  cmd_root->last = (cx_cmd_t *)((void *)0);
#line 206
  return;
}
}
#line 220 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
void cx_cmd_deinit(cx_cmd_root_t *cmd_root ) 
{ 
  cx_cmd_t *cmd ;

  {
  {
#line 224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 224
    if (! cmd_root->first) {
#line 224
      goto while_break;
    }
    {
#line 226
    cmd = cx_cmd_dequeue(cmd_root);
#line 227
    cx_cmd_free(cmd);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  return;
}
}
#line 253 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
void cx_xfer(cx_cmd_root_t *cmd_root , cx_cmd_t const   *out_cmd , cable_t *cable ,
             cable_flush_amount_t how_much ) 
{ 
  cx_cmd_t *cmd ;
  cx_cmd_t *tmp ;
  uint32_t bytes_to_recv ;

  {
  {
#line 257
  tmp = cx_cmd_dequeue(cmd_root);
#line 257
  cmd = tmp;
#line 260
  bytes_to_recv = (uint32_t )0;
  }
  {
#line 262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 262
    if (! cmd) {
#line 262
      goto while_break;
    }
    {
#line 266
    bytes_to_recv += cmd->to_recv;
#line 268
    usbconn_write(cable->link.usb, cmd->buf, (int )cmd->buf_pos, (int )cmd->to_recv);
#line 269
    cx_cmd_free(cmd);
#line 270
    cmd = cx_cmd_dequeue(cmd_root);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  if (bytes_to_recv) {
#line 276
    if (out_cmd) {
      {
#line 278
      usbconn_write(cable->link.usb, (uint8_t *)out_cmd->buf, (int )out_cmd->buf_pos,
                    (int )out_cmd->to_recv);
#line 279
      bytes_to_recv += (uint32_t )out_cmd->to_recv;
      }
    }
  }
#line 282
  if (bytes_to_recv) {
    {
#line 285
    usbconn_read(cable->link.usb, (uint8_t *)((void *)0), 0);
#line 287
    bytes_to_recv = (uint32_t )0;
    }
  } else
#line 282
  if ((unsigned int )how_much != 1U) {
    {
#line 285
    usbconn_read(cable->link.usb, (uint8_t *)((void *)0), 0);
#line 287
    bytes_to_recv = (uint32_t )0;
    }
  }
#line 289
  return;
}
}
#line 303 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
uint8_t cx_xfer_recv(cable_t *cable ) 
{ 
  uint8_t buf ;
  int tmp ;

  {
  {
#line 308
  tmp = usbconn_read(cable->link.usb, & buf, 1);
  }
#line 308
  if (tmp == 1) {
#line 310
    return (buf);
  } else {
#line 313
    return ((uint8_t )0);
  }
}
}
#line 123 "../../include/cable.h"
void cable_free(cable_t *cable ) ;
#line 126
void cable_flush(cable_t *cable , cable_flush_amount_t how_much ) ;
#line 127
void cable_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 128
int cable_defer_clock(cable_t *cable , int tms , int tdi , int n ) ;
#line 134
int cable_get_trst(cable_t *cable ) ;
#line 49 "../../include/chain.h"
chain_t *chain_alloc(void) ;
#line 50
void chain_free(chain_t *chain ) ;
#line 55
int chain_get_trst(chain_t *chain ) ;
#line 60
void chain_flush(chain_t *chain ) ;
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
chain_t *chain_alloc(void) 
{ 
  chain_t *chain ;
  void *tmp ;

  {
  {
#line 39
  tmp = malloc(sizeof(chain_t ));
#line 39
  chain = (chain_t *)tmp;
  }
#line 40
  if (! chain) {
#line 41
    return ((chain_t *)((void *)0));
  }
  {
#line 43
  chain->cable = (cable_t *)((void *)0);
#line 44
  chain->parts = (parts_t *)((void *)0);
#line 45
  chain->total_instr_len = 0;
#line 46
  chain->active_part = 0;
#line 47
  chain->bsdl.path_list = (char **)((void *)0);
#line 47
  chain->bsdl.debug = 0;
#line 48
  tap_state_init(chain);
  }
#line 50
  return (chain);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_free(chain_t *chain ) 
{ 


  {
#line 56
  if (! chain) {
#line 57
    return;
  }
  {
#line 59
  chain_disconnect(chain);
#line 61
  parts_free(chain->parts);
#line 62
  free((void *)chain);
  }
#line 63
  return;
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_disconnect(chain_t *chain ) 
{ 


  {
#line 68
  if (! chain->cable) {
#line 69
    return;
  }
  {
#line 71
  tap_state_done(chain);
#line 72
  cable_done(chain->cable);
#line 73
  cable_free(chain->cable);
#line 74
  chain->cable = (cable_t *)((void *)0);
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_clock(chain_t *chain , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 82
  if (! chain) {
#line 83
    return;
  } else
#line 82
  if (! chain->cable) {
#line 83
    return;
  }
  {
#line 85
  cable_clock(chain->cable, tms, tdi, n);
#line 87
  i = 0;
  }
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 87
    if (! (i < n)) {
#line 87
      goto while_break;
    }
    {
#line 88
    tap_state_clock(chain, tms);
#line 87
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_defer_clock(chain_t *chain , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 96
  if (! chain) {
#line 97
    return;
  } else
#line 96
  if (! chain->cable) {
#line 97
    return;
  }
  {
#line 99
  cable_defer_clock(chain->cable, tms, tdi, n);
#line 101
  i = 0;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if (! (i < n)) {
#line 101
      goto while_break;
    }
    {
#line 102
    tap_state_clock(chain, tms);
#line 101
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 103
  return;
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
int chain_set_trst(chain_t *chain , int trst ) 
{ 
  int old_trst ;
  int tmp ;

  {
  {
#line 108
  tmp = cable_get_trst(chain->cable);
#line 108
  old_trst = tmp;
#line 109
  trst = cable_set_trst(chain->cable, trst);
#line 110
  tap_state_set_trst(chain, old_trst, trst);
  }
#line 111
  return (trst);
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
int chain_get_trst(chain_t *chain ) 
{ 
  int tmp ;

  {
  {
#line 117
  tmp = cable_get_trst(chain->cable);
  }
#line 117
  return (tmp);
}
}
#line 120 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_shift_instructions_mode(chain_t *chain , int capture_output , int capture ,
                                   int exit___0 ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  int tmp___0 ;
  tap_register *tmp___1 ;
  int tmp___2 ;

  {
#line 126
  if (! chain) {
#line 127
    return;
  } else
#line 126
  if (! chain->parts) {
#line 127
    return;
  }
#line 129
  ps = chain->parts;
#line 131
  i = 0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < ps->len)) {
#line 131
      goto while_break;
    }
#line 132
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 133
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 133
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c",
             133, i);
      }
#line 134
      return;
    }
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  if (capture) {
    {
#line 139
    tap_capture_ir(chain);
    }
  }
#line 144
  i = 0;
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 144
    if (! (i < ps->len)) {
#line 144
      goto while_break___0;
    }
#line 145
    if (i + 1 == ps->len) {
#line 145
      tmp___0 = exit___0;
    } else {
#line 145
      tmp___0 = 0;
    }
#line 145
    if (capture_output) {
#line 145
      tmp___1 = ((*(ps->parts + i))->active_instruction)->out;
    } else {
#line 145
      tmp___1 = (tap_register *)((void *)0);
    }
    {
#line 145
    tap_defer_shift_register(chain, (tap_register const   *)((*(ps->parts + i))->active_instruction)->value,
                             tmp___1, tmp___0);
#line 144
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 150
  if (capture_output) {
#line 152
    i = 0;
    {
#line 152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 152
      if (! (i < ps->len)) {
#line 152
        goto while_break___1;
      }
#line 153
      if (i + 1 == ps->len) {
#line 153
        tmp___2 = exit___0;
      } else {
#line 153
        tmp___2 = 0;
      }
      {
#line 153
      tap_shift_register_output(chain, (tap_register const   *)((*(ps->parts + i))->active_instruction)->value,
                                ((*(ps->parts + i))->active_instruction)->out, tmp___2);
#line 152
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 161
    cable_flush(chain->cable, (cable_flush_amount_t )1);
    }
  }
#line 163
  return;
}
}
#line 165 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_shift_instructions(chain_t *chain ) 
{ 


  {
  {
#line 168
  chain_shift_instructions_mode(chain, 0, 1, 1);
  }
#line 169
  return;
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_shift_data_registers_mode(chain_t *chain , int capture_output , int capture ,
                                     int exit___0 ) 
{ 
  int i ;
  parts_t *ps ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  tap_register *tmp___2 ;
  int tmp___3 ;

  {
#line 177
  if (! chain) {
#line 178
    return;
  } else
#line 177
  if (! chain->parts) {
#line 178
    return;
  }
#line 180
  ps = chain->parts;
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < ps->len)) {
#line 182
      goto while_break;
    }
#line 183
    if ((unsigned long )(*(ps->parts + i))->active_instruction == (unsigned long )((void *)0)) {
      {
#line 184
      tmp = gettext("%s(%d) Part %d without active instruction\n");
#line 184
      printf((char const   */* __restrict  */)tmp, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c",
             184, i);
      }
#line 185
      return;
    }
#line 187
    if ((unsigned long )((*(ps->parts + i))->active_instruction)->data_register == (unsigned long )((void *)0)) {
      {
#line 188
      tmp___0 = gettext("%s(%d) Part %d without data register\n");
#line 188
      printf((char const   */* __restrict  */)tmp___0, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c",
             188, i);
      }
#line 189
      return;
    }
#line 182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if (capture) {
    {
#line 194
    tap_capture_dr(chain);
    }
  }
#line 199
  i = 0;
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (! (i < ps->len)) {
#line 199
      goto while_break___0;
    }
#line 200
    if (i + 1 == ps->len) {
#line 200
      tmp___1 = exit___0;
    } else {
#line 200
      tmp___1 = 0;
    }
#line 200
    if (capture_output) {
#line 200
      tmp___2 = (((*(ps->parts + i))->active_instruction)->data_register)->out;
    } else {
#line 200
      tmp___2 = (tap_register *)((void *)0);
    }
    {
#line 200
    tap_defer_shift_register(chain, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                             tmp___2, tmp___1);
#line 199
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 205
  if (capture_output) {
#line 207
    i = 0;
    {
#line 207
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 207
      if (! (i < ps->len)) {
#line 207
        goto while_break___1;
      }
#line 208
      if (i + 1 == ps->len) {
#line 208
        tmp___3 = exit___0;
      } else {
#line 208
        tmp___3 = 0;
      }
      {
#line 208
      tap_shift_register_output(chain, (tap_register const   *)(((*(ps->parts + i))->active_instruction)->data_register)->in,
                                (((*(ps->parts + i))->active_instruction)->data_register)->out,
                                tmp___3);
#line 207
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 216
    cable_flush(chain->cable, (cable_flush_amount_t )1);
    }
  }
#line 218
  return;
}
}
#line 220 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_shift_data_registers(chain_t *chain , int capture_output ) 
{ 


  {
  {
#line 223
  chain_shift_data_registers_mode(chain, capture_output, 1, 1);
  }
#line 224
  return;
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/chain.c"
void chain_flush(chain_t *chain ) 
{ 


  {
#line 229
  if ((unsigned long )chain->cable != (unsigned long )((void *)0)) {
    {
#line 230
    cable_flush(chain->cable, (cable_flush_amount_t )2);
    }
  }
#line 231
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 124 "../../include/cable.h"
int cable_init(cable_t *cable ) ;
#line 129
int cable_get_tdo(cable_t *cable ) ;
#line 133
int cable_defer_set_trst(cable_t *cable , int trst ) ;
#line 135
int cable_get_trst_late(cable_t *cable ) ;
#line 136
int cable_defer_get_trst(cable_t *cable ) ;
#line 137
int cable_transfer(cable_t *cable , int len , char *in , char *out ) ;
#line 148
cable_driver_t *cable_drivers[16] ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
cable_driver_t arcom_cable_driver ;
#line 43
cable_driver_t byteblaster_cable_driver ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
cable_driver_t *cable_drivers[16]  = 
#line 70
  {      & arcom_cable_driver,      & byteblaster_cable_driver,      & dlc5_cable_driver,      & ea253_cable_driver, 
        & ei012_cable_driver,      & igloo_cable_driver,      & keithkoep_cable_driver,      & lattice_cable_driver, 
        & mpcbdm_cable_driver,      & triton_cable_driver,      & wiggler_cable_driver,      & wiggler2_cable_driver, 
        & xpc_int_cable_driver,      & xpc_ext_cable_driver,      & jlink_cable_driver,      (cable_driver_t *)((void *)0)};
#line 140 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_free(cable_t *cable ) 
{ 


  {
  {
#line 143
  (*((cable->driver)->cable_free))(cable);
  }
#line 144
  return;
}
}
#line 146 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_init(cable_t *cable ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 149
  cable->delay = (uint32_t )0;
#line 150
  cable->frequency = (uint32_t )0;
#line 152
  cable->todo.max_items = 128;
#line 153
  cable->todo.num_items = 0;
#line 154
  cable->todo.next_item = 0;
#line 155
  cable->todo.next_free = 0;
#line 156
  tmp = malloc((unsigned long )cable->todo.max_items * sizeof(cable_queue_t ));
#line 156
  cable->todo.data = (cable_queue_t *)tmp;
#line 158
  cable->done.max_items = 128;
#line 159
  cable->done.num_items = 0;
#line 160
  cable->done.next_item = 0;
#line 161
  cable->done.next_free = 0;
#line 162
  tmp___0 = malloc((unsigned long )cable->done.max_items * sizeof(cable_queue_t ));
#line 162
  cable->done.data = (cable_queue_t *)tmp___0;
  }
#line 164
  if ((unsigned long )cable->todo.data == (unsigned long )((void *)0)) {
#line 164
    goto _L;
  } else
#line 164
  if ((unsigned long )cable->done.data == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
    {
#line 166
    tmp___1 = gettext("Failed to allocate memory for cable activity queue.\n");
#line 166
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 167
    if ((unsigned long )cable->todo.data != (unsigned long )((void *)0)) {
      {
#line 167
      free((void *)cable->todo.data);
      }
    }
#line 168
    if ((unsigned long )cable->done.data != (unsigned long )((void *)0)) {
      {
#line 168
      free((void *)cable->done.data);
      }
    }
#line 169
    return (1);
  }
  {
#line 172
  tmp___2 = (*((cable->driver)->init))(cable);
  }
#line 172
  return (tmp___2);
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_flush(cable_t *cable , cable_flush_amount_t how_much ) 
{ 


  {
  {
#line 178
  (*((cable->driver)->flush))(cable, how_much);
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_done(cable_t *cable ) 
{ 


  {
  {
#line 184
  cable_flush(cable, (cable_flush_amount_t )2);
  }
#line 185
  if ((unsigned long )cable->todo.data != (unsigned long )((void *)0)) {
    {
#line 187
    free((void *)cable->todo.data);
#line 188
    free((void *)cable->done.data);
    }
  }
  {
#line 190
  (*((cable->driver)->done))(cable);
  }
#line 190
  return;
}
}
#line 193 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_add_queue_item(cable_t *cable , cable_queue_info_t *q ) 
{ 
  int i ;
  int j ;
  int new_max_items ;
  cable_queue_t *resized ;
  void *tmp ;
  char *tmp___0 ;
  int added_space ;
  int num_to_move ;
  int dest ;

  {
#line 197
  if (q->num_items >= q->max_items) {
    {
#line 207
    new_max_items = q->max_items + 128;
#line 208
    tmp = realloc((void *)q->data, (unsigned long )new_max_items * sizeof(cable_queue_t ));
#line 208
    resized = (cable_queue_t *)tmp;
    }
#line 209
    if ((unsigned long )resized == (unsigned long )((void *)0)) {
      {
#line 211
      tmp___0 = gettext("Out of memory: couldn\'t resize activity queue to %d\n");
#line 211
      printf((char const   */* __restrict  */)tmp___0, new_max_items);
      }
#line 213
      return (-1);
    }
#line 219
    q->data = resized;
#line 228
    if (q->next_item != 0) {
#line 230
      added_space = new_max_items - q->max_items;
#line 231
      num_to_move = q->max_items - q->next_item;
#line 234
      if (num_to_move <= q->next_free) {
        {
#line 240
        dest = new_max_items - num_to_move;
#line 245
        memmove((void *)(q->data + dest), (void const   *)(q->data + q->next_item),
                (unsigned long )num_to_move * sizeof(cable_queue_t ));
#line 248
        q->next_item = dest;
        }
      } else
#line 253
      if (q->next_free <= added_space) {
        {
#line 261
        memcpy((void */* __restrict  */)(q->data + q->max_items), (void const   */* __restrict  */)(q->data + 0),
               (unsigned long )q->next_free * sizeof(cable_queue_t ));
        }
      } else {
        {
#line 276
        memcpy((void */* __restrict  */)(q->data + q->max_items), (void const   */* __restrict  */)(q->data + 0),
               (unsigned long )added_space * sizeof(cable_queue_t ));
#line 286
        memmove((void *)(q->data + 0), (void const   *)(q->data + added_space), (unsigned long )(q->next_free - added_space) * sizeof(cable_queue_t ));
        }
      }
    }
#line 292
    q->max_items = new_max_items;
#line 293
    q->next_free = q->next_item + q->num_items;
#line 294
    if (q->next_free >= new_max_items) {
#line 294
      q->next_free -= new_max_items;
    }
  }
#line 302
  i = q->next_free;
#line 303
  j = i + 1;
#line 304
  if (j >= q->max_items) {
#line 304
    j = 0;
  }
#line 305
  q->next_free = j;
#line 306
  (q->num_items) ++;
#line 309
  return (i);
}
}
#line 312 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_get_queue_item(cable_t *cable , cable_queue_info_t *q ) 
{ 
  int i ;
  int j ;

  {
#line 315
  if (q->num_items > 0) {
#line 317
    i = q->next_item;
#line 318
    j = i + 1;
#line 319
    if (j >= q->max_items) {
#line 319
      j = 0;
    }
#line 320
    q->next_item = j;
#line 321
    (q->num_items) --;
#line 323
    return (i);
  }
#line 327
  return (-1);
}
}
#line 330 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_purge_queue(cable_queue_info_t *q , int io ) 
{ 
  int i ;

  {
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (q->num_items > 0)) {
#line 333
      goto while_break;
    }
#line 335
    i = q->next_item;
#line 336
    if ((unsigned int )(q->data + i)->action == 2U) {
#line 338
      if (io == 0) {
#line 340
        if ((unsigned long )(q->data + i)->arg.transfer.in != (unsigned long )((void *)0)) {
          {
#line 340
          free((void *)(q->data + i)->arg.transfer.in);
          }
        }
#line 341
        if ((unsigned long )(q->data + i)->arg.transfer.out != (unsigned long )((void *)0)) {
          {
#line 341
          free((void *)(q->data + i)->arg.transfer.out);
          }
        }
      } else
#line 345
      if ((unsigned long )(q->data + i)->arg.xferred.out != (unsigned long )((void *)0)) {
        {
#line 345
        free((void *)(q->data + i)->arg.xferred.out);
        }
      }
    }
#line 349
    i ++;
#line 350
    if (i >= q->max_items) {
#line 350
      i = 0;
    }
#line 351
    (q->num_items) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 354
  q->num_items = 0;
#line 355
  q->next_item = 0;
#line 356
  q->next_free = 0;
#line 357
  return;
}
}
#line 359 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 


  {
  {
#line 362
  cable_flush(cable, (cable_flush_amount_t )2);
#line 363
  (*((cable->driver)->clock))(cable, tms, tdi, n);
  }
#line 364
  return;
}
}
#line 366 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_defer_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 369
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 369
  i = tmp;
  }
#line 370
  if (i < 0) {
#line 370
    return (1);
  }
  {
#line 371
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )0;
#line 372
  (cable->todo.data + i)->arg.clock.tms = tms;
#line 373
  (cable->todo.data + i)->arg.clock.tdi = tdi;
#line 374
  (cable->todo.data + i)->arg.clock.n = n;
#line 375
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 376
  return (0);
}
}
#line 379 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 382
  cable_flush(cable, (cable_flush_amount_t )2);
#line 383
  tmp = (*((cable->driver)->get_tdo))(cable);
  }
#line 383
  return (tmp);
}
}
#line 386 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_get_tdo_late(cable_t *cable ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 390
  cable_flush(cable, (cable_flush_amount_t )1);
#line 391
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 392
  if (i >= 0) {
#line 394
    if ((unsigned int )(cable->done.data + i)->action != 1U) {
      {
#line 396
      tmp = gettext("Internal error: Got wrong type of result from queue (%d? %p.%d)\n");
#line 396
      printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 398
      cable_purge_queue(& cable->done, 1);
      }
    } else {
#line 402
      return ((cable->done.data + i)->arg.value.tdo);
    }
  }
  {
#line 405
  tmp___0 = (*((cable->driver)->get_tdo))(cable);
  }
#line 405
  return (tmp___0);
}
}
#line 408 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_defer_get_tdo(cable_t *cable ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 411
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 411
  i = tmp;
  }
#line 412
  if (i < 0) {
#line 412
    return (1);
  }
  {
#line 413
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )1;
#line 414
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 415
  return (0);
}
}
#line 418 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_set_trst(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 421
  cable_flush(cable, (cable_flush_amount_t )2);
#line 422
  tmp = (*((cable->driver)->set_trst))(cable, trst);
  }
#line 422
  return (tmp);
}
}
#line 425 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_defer_set_trst(cable_t *cable , int trst ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 428
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 428
  i = tmp;
  }
#line 429
  if (i < 0) {
#line 429
    return (1);
  }
  {
#line 430
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )3;
#line 431
  (cable->todo.data + i)->arg.value.trst = trst;
#line 432
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 433
  return (0);
}
}
#line 436 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_get_trst(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 439
  cable_flush(cable, (cable_flush_amount_t )2);
#line 440
  tmp = (*((cable->driver)->get_trst))(cable);
  }
#line 440
  return (tmp);
}
}
#line 443 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_get_trst_late(cable_t *cable ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 447
  cable_flush(cable, (cable_flush_amount_t )1);
#line 448
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 449
  if (i >= 0) {
#line 451
    if ((unsigned int )(cable->done.data + i)->action != 4U) {
      {
#line 453
      tmp = gettext("Internal error: Got wrong type of result from queue (%d? %p.%d)\n");
#line 453
      printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
             & cable->done, i);
#line 455
      cable_purge_queue(& cable->done, 1);
      }
    } else {
#line 459
      return ((cable->done.data + i)->arg.value.trst);
    }
  }
  {
#line 462
  tmp___0 = (*((cable->driver)->get_trst))(cable);
  }
#line 462
  return (tmp___0);
}
}
#line 465 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_defer_get_trst(cable_t *cable ) 
{ 
  int i ;
  int tmp ;

  {
  {
#line 468
  tmp = cable_add_queue_item(cable, & cable->todo);
#line 468
  i = tmp;
  }
#line 469
  if (i < 0) {
#line 469
    return (1);
  }
  {
#line 470
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )4;
#line 471
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 472
  return (0);
}
}
#line 475 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  int tmp ;

  {
  {
#line 478
  cable_flush(cable, (cable_flush_amount_t )2);
#line 479
  tmp = (*((cable->driver)->transfer))(cable, len, in, out);
  }
#line 479
  return (tmp);
}
}
#line 482 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_transfer_late(cable_t *cable , char *out ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 486
  cable_flush(cable, (cable_flush_amount_t )1);
#line 487
  i = cable_get_queue_item(cable, & cable->done);
  }
#line 489
  if (i >= 0) {
#line 489
    if ((unsigned int )(cable->done.data + i)->action == 2U) {
#line 497
      if (out) {
        {
#line 497
        memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)(cable->done.data + i)->arg.xferred.out,
               (size_t )(cable->done.data + i)->arg.xferred.len);
        }
      }
      {
#line 500
      free((void *)(cable->done.data + i)->arg.xferred.out);
      }
#line 501
      return ((cable->done.data + i)->arg.xferred.res);
    }
  }
#line 504
  if ((unsigned int )(cable->done.data + i)->action != 2U) {
    {
#line 506
    tmp = gettext("Internal error: Got wrong type of result from queue (#%d %p.%d)\n");
#line 506
    printf((char const   */* __restrict  */)tmp, (unsigned int )(cable->done.data + i)->action,
           & cable->done, i);
#line 508
    cable_purge_queue(& cable->done, 1);
    }
  } else {
    {
#line 512
    tmp___0 = gettext("Internal error: Wanted transfer result but none was queued\n");
#line 512
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
#line 514
  return (0);
}
}
#line 517 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
int cable_defer_transfer(cable_t *cable , int len , char *in , char *out ) 
{ 
  char *ibuf ;
  char *obuf ;
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 520
  obuf = (char *)((void *)0);
#line 523
  tmp = malloc((size_t )len);
#line 523
  ibuf = (char *)tmp;
  }
#line 524
  if ((unsigned long )ibuf == (unsigned long )((void *)0)) {
#line 524
    return (1);
  }
#line 526
  if (out) {
    {
#line 528
    tmp___0 = malloc((size_t )len);
#line 528
    obuf = (char *)tmp___0;
    }
#line 529
    if ((unsigned long )obuf == (unsigned long )((void *)0)) {
      {
#line 531
      free((void *)ibuf);
      }
#line 532
      return (1);
    }
  }
  {
#line 536
  i = cable_add_queue_item(cable, & cable->todo);
  }
#line 537
  if (i < 0) {
    {
#line 539
    free((void *)ibuf);
    }
#line 540
    if (obuf) {
      {
#line 540
      free((void *)obuf);
      }
    }
#line 541
    return (1);
  }
#line 544
  (cable->todo.data + i)->action = (enum __anonenum_action_990402164 )2;
#line 545
  (cable->todo.data + i)->arg.transfer.len = len;
#line 546
  if (in) {
    {
#line 546
    memcpy((void */* __restrict  */)ibuf, (void const   */* __restrict  */)in, (size_t )len);
    }
  }
  {
#line 547
  (cable->todo.data + i)->arg.transfer.in = ibuf;
#line 548
  (cable->todo.data + i)->arg.transfer.out = obuf;
#line 549
  cable_flush(cable, (cable_flush_amount_t )0);
  }
#line 550
  return (0);
}
}
#line 553 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_set_frequency(cable_t *cable , uint32_t new_frequency ) 
{ 


  {
  {
#line 556
  cable_flush(cable, (cable_flush_amount_t )2);
#line 557
  (*((cable->driver)->set_frequency))(cable, new_frequency);
  }
#line 558
  return;
}
}
#line 560 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
uint32_t cable_get_frequency(cable_t *cable ) 
{ 


  {
#line 563
  return (cable->frequency);
}
}
#line 566 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable.c"
void cable_wait(cable_t *cable ) 
{ 
  int i ;
  int volatile   j ;
  uint32_t delay ;

  {
#line 571
  delay = cable->delay;
#line 573
  if (delay == 0U) {
#line 574
    return;
  }
#line 576
  i = 0;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! ((uint32_t )i < delay)) {
#line 576
      goto while_break;
    }
#line 577
    j = (int volatile   )i;
#line 576
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 579
  return;
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static int byteblaster_init(cable_t *cable ) 
{ 
  int BB_II ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 73
  BB_II = 0;
#line 75
  tmp = parport_open(cable->link.port);
  }
#line 75
  if (tmp) {
#line 76
    return (-1);
  }
  {
#line 78
  ((generic_params_t *)cable->params)->trst = 1;
#line 81
  parport_set_data(cable->link.port, (uint8_t )(1 << 5));
#line 82
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 82
  if (! ((tmp___0 >> 6) & 1)) {
#line 83
    BB_II = 1;
  }
  {
#line 84
  parport_set_data(cable->link.port, (uint8_t )0);
#line 85
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 85
  if ((tmp___1 >> 6) & 1) {
#line 86
    BB_II = 1;
  }
#line 90
  if (BB_II) {
    {
#line 90
    tmp___2 = parport_get_status(cable->link.port);
    }
#line 90
    if ((tmp___2 >> 3) & 1) {
#line 91
      return (-1);
    }
  }
  {
#line 94
  parport_set_control(cable->link.port, (uint8_t )12);
  }
#line 96
  return (0);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static void byteblaster_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 104
  if (tms) {
#line 104
    tms = 1;
  } else {
#line 104
    tms = 0;
  }
#line 105
  if (tdi) {
#line 105
    tdi = 1;
  } else {
#line 105
    tdi = 0;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < n)) {
#line 107
      goto while_break;
    }
    {
#line 108
    parport_set_data(cable->link.port, (uint8_t )((tms << 1) | (tdi << 6)));
#line 109
    cable_wait(cable);
#line 110
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 1)) | (tdi << 6)));
#line 111
    cable_wait(cable);
#line 107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static int byteblaster_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 118
  parport_set_data(cable->link.port, (uint8_t )0);
#line 119
  cable_wait(cable);
#line 120
  tmp = parport_get_status(cable->link.port);
  }
#line 120
  return ((tmp >> 7) & 1);
}
}
#line 123 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static int byteblaster_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 126
  return (1);
}
}
#line 129 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
cable_driver_t byteblaster_cable_driver  = 
#line 129
     {"ByteBlaster", "Altera ByteBlaster/ByteBlaster II/ByteBlasterMV Parallel Port Download Cable",
    & generic_parport_connect, & generic_disconnect, & generic_parport_free, & byteblaster_init,
    & generic_parport_done, & generic_set_frequency, & byteblaster_clock, & byteblaster_get_tdo,
    & generic_transfer, & byteblaster_set_trst, & generic_get_trst, & generic_flush_one_by_one,
    & generic_parport_help};
#line 52 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static int arcom_init(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 3));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 65
    ((generic_params_t *)cable->params)->trst = (data >> 3) & 1;
  }
#line 67
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static void arcom_clock(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 3) | (tms << 2)) | (tdi << 1)));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | 1) | (tms << 2)) | (tdi << 1)));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static int arcom_get_tdo(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 89
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
#line 90
  cable_wait(cable);
#line 91
  tmp = parport_get_status(cable->link.port);
  }
#line 91
  return ((tmp >> 7) & 1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static int arcom_set_trst(cable_t *cable , int trst ) 
{ 


  {
#line 97
  if (trst) {
#line 97
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 97
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 99
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
  }
#line 100
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
cable_driver_t arcom_cable_driver  = 
#line 103
     {"ARCOM", "Arcom JTAG Cable", & generic_parport_connect, & generic_disconnect,
    & generic_parport_free, & arcom_init, & generic_parport_done, & generic_set_frequency,
    & arcom_clock, & arcom_get_tdo, & generic_transfer, & arcom_set_trst, & generic_get_trst,
    & generic_flush_one_by_one, & generic_parport_help};
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
static struct amd_flash_info  const  table___0[21]  = 
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/jedec.c"
  {      {(int const   )1, (int const   )8900, "AMD AM29LV160DT", (long const   )2097152,
      (uint8_t const   )1, (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536,
                                                               (uint32_t )31}, {(uint32_t )2031616,
                                                                                (uint32_t )32768,
                                                                                (uint32_t )1},
                                                              {(uint32_t )2064384,
                                                               (uint32_t )8192, (uint32_t )2},
                                                              {(uint32_t )2080768,
                                                               (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8777, "AMD AM29LV160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )152,
      (int const   )194, "Toshiba TC58FVT160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8900, "Fujitsu MBM29LV160TE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )152,
      (int const   )67, "Toshiba TC58FVB160", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )4,
      (int const   )8777, "Fujitsu MBM29LV160BE", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8792, "AMD AM29F800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )1,
      (int const   )8922, "AMD AM29LV800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8918, "AMD AM29F800BT", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )8795, "AMD AM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )4,
      (int const   )8795, "Fujitsu MBM29LV800BB", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )15}}}, 
        {(int const   )32,
      (int const   )215, "ST M29W800T", (long const   )1048576, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )983040, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )1015808, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )1032192, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8900, "ST M29W160DT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )2064384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )2080768, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )32,
      (int const   )8777, "ST M29W160DB", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )16384, (uint32_t )1},
                                         {(uint32_t )16384, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )32768, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )1,
      (int const   )8913, "AMD AM29BDS323D", (long const   )4194304, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )48},
                                         {(uint32_t )3145728, (uint32_t )65536, (uint32_t )15},
                                         {(uint32_t )4128768, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )1,
      (int const   )8830, "AMD AM29BDS643D", (long const   )8388608, (uint8_t const   )1,
      (int const   )0, (int const   )3, {{(uint32_t )0, (uint32_t )65536, (uint32_t )96},
                                         {(uint32_t )6291456, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )8323072, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )31,
      (int const   )192, "Atmel AT49xV16x", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )8192, (uint32_t )8},
                                         {(uint32_t )65536, (uint32_t )65536, (uint32_t )31}}}, 
        {(int const   )31,
      (int const   )194, "Atmel AT49xV16xT", (long const   )2097152, (uint8_t const   )1,
      (int const   )0, (int const   )2, {{(uint32_t )0, (uint32_t )65536, (uint32_t )31},
                                         {(uint32_t )2031616, (uint32_t )8192, (uint32_t )8}}}, 
        {(int const   )194,
      (int const   )8889, "MX 29LV400T", (long const   )524288, (uint8_t const   )1,
      (int const   )0, (int const   )4, {{(uint32_t )0, (uint32_t )65536, (uint32_t )7},
                                         {(uint32_t )458752, (uint32_t )32768, (uint32_t )1},
                                         {(uint32_t )491520, (uint32_t )8192, (uint32_t )2},
                                         {(uint32_t )507904, (uint32_t )16384, (uint32_t )1}}}, 
        {(int const   )1,
      (int const   )79, "AMD AM29LV040B", (long const   )524288, (uint8_t const   )0,
      (int const   )1, (int const   )1, {{(uint32_t )0, (uint32_t )65536, (uint32_t )8}}}};
#line 48 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 49
static int intel_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int intel_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 51
static int intel_flash_erase_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 52
static int intel_flash_unlock_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 53
static int intel_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_autodetect32___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 61
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 61
  if (tmp != 0) {
#line 62
    return (0);
  }
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 64
    goto _L;
  } else
#line 64
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 64
    if (area.width == 32U) {
#line 64
      tmp___0 = 1;
    } else {
#line 64
      tmp___0 = 0;
    }
  } else {
#line 64
    tmp___0 = 0;
  }
#line 64
  return (tmp___0);
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_autodetect___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 76
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 76
  if (tmp != 0) {
#line 77
    return (0);
  }
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 79
    goto _L;
  } else
#line 79
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 79
    if (area.width == 16U) {
#line 79
      tmp___0 = 1;
    } else {
#line 79
      tmp___0 = 0;
    }
  } else {
#line 79
    tmp___0 = 0;
  }
#line 79
  return (tmp___0);
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_autodetect8___0(cfi_array_t *cfi_array___0 ) 
{ 
  bus_area_t area ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 91
  tmp = (*(((cfi_array___0->bus)->driver)->area))(cfi_array___0->bus, cfi_array___0->address,
                                                  & area);
  }
#line 91
  if (tmp != 0) {
#line 92
    return (0);
  }
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 256) {
#line 94
    goto _L;
  } else
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 257) {
#line 94
    goto _L;
  } else
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 1) {
#line 94
    goto _L;
  } else
#line 94
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 3) {
    _L: /* CIL Label */ 
#line 94
    if (area.width == 8U) {
#line 94
      tmp___0 = 1;
    } else {
#line 94
      tmp___0 = 0;
    }
  } else {
#line 94
    tmp___0 = 0;
  }
#line 94
  return (tmp___0);
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void _intel_flash_print_info___0(cfi_array_t *cfi_array___0 , int o ) 
{ 
  uint32_t mid ;
  uint32_t cid ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  uint32_t tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 105
  bus___0 = cfi_array___0->bus;
#line 107
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 107
  mid = tmp & 255U;
  }
  {
#line 109
  if (mid == 137U) {
#line 109
    goto case_137;
  }
#line 112
  if (mid == 28U) {
#line 112
    goto case_28;
  }
#line 115
  goto switch_default;
  case_137: /* CIL Label */ 
  {
#line 110
  tmp___0 = gettext("Manufacturer: %s\n");
#line 110
  printf((char const   */* __restrict  */)tmp___0, "Intel");
  }
#line 111
  goto switch_break;
  case_28: /* CIL Label */ 
  {
#line 113
  tmp___1 = gettext("Manufacturer: %s\n");
#line 113
  printf((char const   */* __restrict  */)tmp___1, "Mitsubishi");
  }
#line 114
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 116
  tmp___2 = gettext("Unknown manufacturer (0x%04X)!\n");
#line 116
  printf((char const   */* __restrict  */)tmp___2, mid);
  }
#line 117
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 120
  tmp___3 = gettext("Chip: ");
#line 120
  printf((char const   */* __restrict  */)tmp___3);
#line 121
  tmp___4 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 121
  cid = tmp___4 & 65535U;
  }
  {
#line 123
  if (cid == 22U) {
#line 123
    goto case_22;
  }
#line 126
  if (cid == 23U) {
#line 126
    goto case_23;
  }
#line 129
  if (cid == 24U) {
#line 129
    goto case_24;
  }
#line 132
  if (cid == 29U) {
#line 132
    goto case_29;
  }
#line 135
  if (cid == 34817U) {
#line 135
    goto case_34817;
  }
#line 138
  if (cid == 34818U) {
#line 138
    goto case_34818;
  }
#line 141
  if (cid == 34819U) {
#line 141
    goto case_34819;
  }
#line 144
  if (cid == 34821U) {
#line 144
    goto case_34821;
  }
#line 147
  if (cid == 34822U) {
#line 147
    goto case_34822;
  }
#line 150
  if (cid == 34823U) {
#line 150
    goto case_34823;
  }
#line 153
  if (cid == 34827U) {
#line 153
    goto case_34827;
  }
#line 156
  if (cid == 34828U) {
#line 156
    goto case_34828;
  }
#line 159
  if (cid == 34829U) {
#line 159
    goto case_34829;
  }
#line 162
  if (cid == 34830U) {
#line 162
    goto case_34830;
  }
#line 165
  if (cid == 34831U) {
#line 165
    goto case_34831;
  }
#line 168
  if (cid == 34832U) {
#line 168
    goto case_34832;
  }
#line 171
  goto switch_default___0;
  case_22: /* CIL Label */ 
  {
#line 124
  printf((char const   */* __restrict  */)"28F320J3A\n");
  }
#line 125
  goto switch_break___0;
  case_23: /* CIL Label */ 
  {
#line 127
  printf((char const   */* __restrict  */)"28F640J3A\n");
  }
#line 128
  goto switch_break___0;
  case_24: /* CIL Label */ 
  {
#line 130
  printf((char const   */* __restrict  */)"28F128J3A\n");
  }
#line 131
  goto switch_break___0;
  case_29: /* CIL Label */ 
  {
#line 133
  printf((char const   */* __restrict  */)"28F256J3A\n");
  }
#line 134
  goto switch_break___0;
  case_34817: /* CIL Label */ 
  {
#line 136
  printf((char const   */* __restrict  */)"28F640K3\n");
  }
#line 137
  goto switch_break___0;
  case_34818: /* CIL Label */ 
  {
#line 139
  printf((char const   */* __restrict  */)"28F128K3\n");
  }
#line 140
  goto switch_break___0;
  case_34819: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)"28F256K3\n");
  }
#line 143
  goto switch_break___0;
  case_34821: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)"28F640K18\n");
  }
#line 146
  goto switch_break___0;
  case_34822: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)"28F128K18\n");
  }
#line 149
  goto switch_break___0;
  case_34823: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"28F256K18\n");
  }
#line 152
  goto switch_break___0;
  case_34827: /* CIL Label */ 
  {
#line 154
  printf((char const   */* __restrict  */)"GE28F640L18T\n");
  }
#line 155
  goto switch_break___0;
  case_34828: /* CIL Label */ 
  {
#line 157
  printf((char const   */* __restrict  */)"GE28F128L18T\n");
  }
#line 158
  goto switch_break___0;
  case_34829: /* CIL Label */ 
  {
#line 160
  printf((char const   */* __restrict  */)"GE28F256L18T\n");
  }
#line 161
  goto switch_break___0;
  case_34830: /* CIL Label */ 
  {
#line 163
  printf((char const   */* __restrict  */)"GE28F640L18B\n");
  }
#line 164
  goto switch_break___0;
  case_34831: /* CIL Label */ 
  {
#line 166
  printf((char const   */* __restrict  */)"GE28F128L18B\n");
  }
#line 167
  goto switch_break___0;
  case_34832: /* CIL Label */ 
  {
#line 169
  printf((char const   */* __restrict  */)"GE28F256L18B\n");
  }
#line 170
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 172
  tmp___5 = gettext("Unknown (0x%02X)!\n");
#line 172
  printf((char const   */* __restrict  */)tmp___5, cid);
  }
#line 173
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 177
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 178
  return;
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 183
  o = 1;
#line 184
  bus___0 = cfi_array___0->bus;
#line 190
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 193
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )144);
#line 195
  _intel_flash_print_info___0(cfi_array___0, o);
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_print_info32___0(cfi_array_t *cfi_array___0 ) 
{ 
  int o ;
  bus_t *bus___0 ;

  {
  {
#line 201
  o = 2;
#line 202
  bus___0 = cfi_array___0->bus;
#line 207
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )5242960);
#line 210
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )9437328);
#line 212
  _intel_flash_print_info___0(cfi_array___0, o);
  }
#line 213
  return;
}
}
#line 215 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 219
  bus___0 = cfi_array___0->bus;
#line 221
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 222
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )32);
#line 223
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 225
    sr = (uint16_t )(tmp & 254U);
    }
#line 225
    if ((int )sr & (1 << 7)) {
#line 225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 228
  if (((int )sr & ~ (1 << 7)) == 0) {
#line 228
    goto case_0;
  }
#line 230
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 4))) {
#line 230
    goto case_exp;
  }
#line 233
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 3))) {
#line 233
    goto case_exp___0;
  }
#line 236
  if (((int )sr & ~ (1 << 7)) == ((1 << 5) | (1 << 1))) {
#line 236
    goto case_exp___1;
  }
#line 239
  goto switch_default;
  case_0: /* CIL Label */ 
#line 229
  return (0);
  case_exp: /* CIL Label */ 
  {
#line 231
  tmp___0 = gettext("flash: invalid command seq\n");
#line 231
  printf((char const   */* __restrict  */)tmp___0);
  }
#line 232
  return (1);
  case_exp___0: /* CIL Label */ 
  {
#line 234
  tmp___1 = gettext("flash: low vpen\n");
#line 234
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 235
  return (2);
  case_exp___1: /* CIL Label */ 
  {
#line 237
  tmp___2 = gettext("flash: block locked\n");
#line 237
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 238
  return (3);
  switch_default: /* CIL Label */ 
#line 240
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 243
  return (99);
}
}
#line 246 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 250
  bus___0 = cfi_array___0->bus;
#line 252
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 253
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )96);
#line 254
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )208);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 256
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 256
    sr = (uint16_t )(tmp & 254U);
    }
#line 256
    if ((int )sr & (1 << 7)) {
#line 256
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 258
  if ((int )sr != 1 << 7) {
    {
#line 259
    tmp___0 = gettext("flash: unknown error while unblocking\n");
#line 259
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 260
    return (99);
  } else {
#line 262
    return (0);
  }
}
}
#line 265 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint16_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  char *tmp___0 ;

  {
  {
#line 269
  bus___0 = cfi_array___0->bus;
#line 271
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )80);
#line 272
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )64);
#line 273
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 275
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 275
    sr = (uint16_t )(tmp & 254U);
    }
#line 275
    if ((int )sr & (1 << 7)) {
#line 275
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if ((int )sr != 1 << 7) {
    {
#line 278
    tmp___0 = gettext("flash: unknown error while programming\n");
#line 278
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 279
    return (99);
  } else {
#line 281
    return (0);
  }
}
}
#line 284 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_erase_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 288
  bus___0 = cfi_array___0->bus;
#line 290
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 291
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((32 << 16) | 32));
#line 292
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 294
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 294
    sr = tmp & 16646398U;
    }
#line 294
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 294
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 297
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 298
    return (99);
  } else {
#line 300
    return (0);
  }
}
}
#line 303 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_unlock_block32___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 307
  bus___0 = cfi_array___0->bus;
#line 309
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 310
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((96 << 16) | 96));
#line 311
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((208 << 16) | 208));
  }
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 313
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 313
    sr = tmp & 16646398U;
    }
#line 313
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 313
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 315
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 316
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 317
    return (99);
  } else {
#line 319
    return (0);
  }
}
}
#line 322 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static int intel_flash_program32___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  uint32_t sr ;
  bus_t *bus___0 ;
  uint32_t tmp ;

  {
  {
#line 326
  bus___0 = cfi_array___0->bus;
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )((80 << 16) | 80));
#line 329
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )((64 << 16) | 64));
#line 330
  (*((bus___0->driver)->write))(bus___0, adr, data);
  }
  {
#line 332
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 332
    tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 332
    sr = tmp & 16646398U;
    }
#line 332
    if (! ((sr & (unsigned int )(((1 << 7) << 16) | (1 << 7))) != (unsigned int )(((1 << 7) << 16) | (1 << 7)))) {
#line 332
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 334
  if (sr != (uint32_t )(((1 << 7) << 16) | (1 << 7))) {
    {
#line 335
    printf((char const   */* __restrict  */)"\nsr = 0x%08X\n", sr);
    }
#line 336
    return (99);
  } else {
#line 338
    return (0);
  }
}
}
#line 341 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_readarray32___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 345
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 346
  return;
}
}
#line 348 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/intel.c"
static void intel_flash_readarray___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 352
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )16711935);
  }
#line 353
  return;
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
static flash_driver_t *flash_driver___0  =    (flash_driver_t *)((void *)0);
#line 71 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
static void set_flash_driver___0(void) 
{ 
  int i ;
  cfi_query_structure_t *cfi ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 77
  flash_driver___0 = (flash_driver_t *)((void *)0);
#line 78
  if ((unsigned long )cfi_array == (unsigned long )((void *)0)) {
#line 79
    return;
  }
#line 80
  cfi = & (*(cfi_array->cfi_chips + 0))->cfi;
#line 82
  i = 0;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! ((unsigned long )flash_drivers[i] != (unsigned long )((void *)0))) {
#line 82
      goto while_break;
    }
    {
#line 83
    tmp = (*((flash_drivers[i])->autodetect))(cfi_array);
    }
#line 83
    if (tmp) {
      {
#line 84
      flash_driver___0 = flash_drivers[i];
#line 85
      (*(flash_driver___0->print_info))(cfi_array);
      }
#line 86
      return;
    }
#line 82
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 89
  tmp___0 = gettext("unknown flash - vendor id: %d (0x%04x)\n");
#line 89
  printf((char const   */* __restrict  */)tmp___0, (int )cfi->identification_string.pri_id_code,
         (int )cfi->identification_string.pri_id_code);
#line 93
  tmp___1 = gettext("Flash not supported!\n");
#line 93
  printf((char const   */* __restrict  */)tmp___1);
  }
#line 94
  return;
}
}
#line 218 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/flash.c"
static int find_block___0(cfi_query_structure_t *cfi , int adr , int bus_width , int chip_width ,
                          int *bytes_until_next_block ) 
{ 
  int i ;
  int b ;
  int bb ;
  int region_blocks ;
  int flash_block_size ;
  int region_block_size ;
  int region_size ;
  int bir ;

  {
#line 222
  b = 0;
#line 223
  bb = 0;
#line 225
  i = 0;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
#line 225
    if (! (i < (int )cfi->device_geometry.number_of_erase_regions)) {
#line 225
      goto while_break;
    }
#line 226
    region_blocks = (int )(cfi->device_geometry.erase_block_regions + i)->number_of_erase_blocks;
#line 227
    flash_block_size = (int )(cfi->device_geometry.erase_block_regions + i)->erase_block_size;
#line 228
    region_block_size = (bus_width / chip_width) * flash_block_size;
#line 229
    region_size = region_blocks * region_block_size;
#line 231
    if (adr < bb + region_size) {
#line 233
      bir = (adr - bb) / region_block_size;
#line 234
      *bytes_until_next_block = (bb + (bir + 1) * region_block_size) - adr;
#line 235
      return (b + bir);
    }
#line 237
    b += region_blocks;
#line 238
    bb += region_size;
#line 225
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  return (-1);
}
}
#line 46 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int dbg___0  =    0;
#line 48
static int amd_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 49
static int amd_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 50
static int amd_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 51
static void amd_flash_read_array___0(cfi_array_t *cfi_array___0 ) ;
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_address_shift___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 73
  if (cfi_array___0->bus_width == 4) {
#line 73
    return (2);
  }
  {
#line 80
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 1) {
#line 80
    goto case_1;
  }
#line 80
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 2) {
#line 80
    goto case_1;
  }
#line 84
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 3) {
#line 84
    goto case_3;
  }
#line 84
  if ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.device_geometry.device_interface == 4) {
#line 84
    goto case_3;
  }
#line 87
  goto switch_default;
  case_1: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 81
  return (1);
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 85
  return (2);
  switch_default: /* CIL Label */ 
#line 87
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 90
  if (cfi_array___0->bus_width == 2) {
#line 90
    return (1);
  }
#line 92
  return (0);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_autodetect32___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 99
  if (cfi_array___0->bus_width != 4) {
#line 99
    return (0);
  }
#line 100
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 103 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_autodetect16___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 106
  if (cfi_array___0->bus_width != 2) {
#line 106
    return (0);
  }
#line 107
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_autodetect8___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 113
  if (cfi_array___0->bus_width != 1) {
#line 113
    return (0);
  }
#line 114
  return ((int )(*(cfi_array___0->cfi_chips + 0))->cfi.identification_string.pri_id_code == 2);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amdstatus___0(cfi_array_t *cfi_array___0 , uint32_t adr , int data ) 
{ 
  bus_t *bus___0 ;
  int timeout ;
  uint32_t togglemask ;
  uint32_t data1 ;
  uint32_t tmp ;
  uint32_t data2 ;
  uint32_t tmp___0 ;

  {
#line 165
  bus___0 = cfi_array___0->bus;
#line 168
  togglemask = (uint32_t )(((1 << 6) << 16) + (1 << 6));
#line 171
  timeout = 0;
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! (timeout < 7000)) {
#line 171
      goto while_break;
    }
    {
#line 172
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 172
    data1 = tmp;
#line 173
    tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 173
    data2 = tmp___0;
    }
#line 177
    if ((data1 & togglemask) == (data2 & togglemask)) {
#line 178
      return (1);
    }
#line 182
    if (dbg___0) {
      {
#line 183
      printf((char const   */* __restrict  */)"amdstatus %d: %04X/%04X\n", timeout,
             data1, data2);
      }
    } else {
      {
#line 185
      printf((char const   */* __restrict  */)".");
      }
    }
    {
#line 186
    usleep((__useconds_t )100);
#line 171
    timeout ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  return (0);
}
}
#line 262 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static void amd_flash_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int cid ;
  int prot ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 266
  bus___0 = cfi_array___0->bus;
#line 267
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 267
  o = tmp;
#line 269
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 270
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 271
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )9437328);
#line 272
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 272
  mid = (int )(tmp___0 & 65535U);
#line 273
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(1 << o));
#line 273
  cid = (int )(tmp___1 & 65535U);
#line 274
  tmp___2 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + (uint32_t )(2 << o));
#line 274
  prot = (int )(tmp___2 & 255U);
#line 275
  amd_flash_read_array___0(cfi_array___0);
#line 276
  tmp___3 = gettext("Chip: AMD Flash\n\tManufacturer: ");
#line 276
  printf((char const   */* __restrict  */)tmp___3);
  }
  {
#line 278
  if (mid == 1) {
#line 278
    goto case_1;
  }
#line 302
  if (mid == 31) {
#line 302
    goto case_31;
  }
#line 317
  if (mid == 32) {
#line 317
    goto case_32;
  }
#line 335
  if (mid == 194) {
#line 335
    goto case_194;
  }
#line 347
  goto switch_default___3;
  case_1: /* CIL Label */ 
  {
#line 279
  printf((char const   */* __restrict  */)"AMD");
#line 280
  tmp___4 = gettext("\n\tChip: ");
#line 280
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 282
  if (cid == 73) {
#line 282
    goto case_73;
  }
#line 285
  if (cid == 147) {
#line 285
    goto case_147;
  }
#line 288
  if (cid == 79) {
#line 288
    goto case_79;
  }
#line 291
  if (cid == 8919) {
#line 291
    goto case_8919;
  }
#line 294
  if (cid == 8795) {
#line 294
    goto case_8795;
  }
#line 297
  goto switch_default;
  case_73: /* CIL Label */ 
  {
#line 283
  printf((char const   */* __restrict  */)"AM29LV160DB");
  }
#line 284
  goto switch_break___0;
  case_147: /* CIL Label */ 
  {
#line 286
  printf((char const   */* __restrict  */)"Am29LV065D");
  }
#line 287
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 289
  printf((char const   */* __restrict  */)"Am29LV040B");
  }
#line 290
  goto switch_break___0;
  case_8919: /* CIL Label */ 
  {
#line 292
  printf((char const   */* __restrict  */)"Am29LV640D/Am29LV641D/Am29LV642D");
  }
#line 293
  goto switch_break___0;
  case_8795: /* CIL Label */ 
  {
#line 295
  printf((char const   */* __restrict  */)"Am29LV800B");
  }
#line 296
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 298
  tmp___5 = gettext("Unknown (ID 0x%04x)");
#line 298
  printf((char const   */* __restrict  */)tmp___5, cid);
  }
#line 299
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 301
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 303
  printf((char const   */* __restrict  */)"Atmel");
#line 304
  tmp___6 = gettext("\n\tChip: ");
#line 304
  printf((char const   */* __restrict  */)tmp___6);
  }
  {
#line 306
  if (cid == 466) {
#line 306
    goto case_466;
  }
#line 309
  if (cid == 470) {
#line 309
    goto case_470;
  }
#line 312
  goto switch_default___0;
  case_466: /* CIL Label */ 
  {
#line 307
  printf((char const   */* __restrict  */)"AT49BW642DT");
  }
#line 308
  goto switch_break___1;
  case_470: /* CIL Label */ 
  {
#line 310
  printf((char const   */* __restrict  */)"AT49BW642D");
  }
#line 311
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 313
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 313
  printf((char const   */* __restrict  */)tmp___7, cid);
  }
#line 314
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 316
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 318
  printf((char const   */* __restrict  */)"ST/Samsung");
#line 319
  tmp___8 = gettext("\n\tChip: ");
#line 319
  printf((char const   */* __restrict  */)tmp___8);
  }
  {
#line 321
  if (cid == 202) {
#line 321
    goto case_202;
  }
#line 324
  if (cid == 203) {
#line 324
    goto case_203;
  }
#line 327
  if (cid == 8941) {
#line 327
    goto case_8941;
  }
#line 330
  goto switch_default___1;
  case_202: /* CIL Label */ 
  {
#line 322
  printf((char const   */* __restrict  */)"M29W320DT");
  }
#line 323
  goto switch_break___2;
  case_203: /* CIL Label */ 
  {
#line 325
  printf((char const   */* __restrict  */)"M29W320DB");
  }
#line 326
  goto switch_break___2;
  case_8941: /* CIL Label */ 
  {
#line 328
  printf((char const   */* __restrict  */)"M29W640DT");
  }
#line 329
  goto switch_break___2;
  switch_default___1: /* CIL Label */ 
  {
#line 331
  tmp___9 = gettext("Unknown (ID 0x%04x)");
#line 331
  printf((char const   */* __restrict  */)tmp___9, cid);
  }
#line 332
  goto switch_break___2;
  switch_break___2: /* CIL Label */ ;
  }
#line 334
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 336
  printf((char const   */* __restrict  */)"Macronix");
#line 337
  tmp___10 = gettext("\n\tChip: ");
#line 337
  printf((char const   */* __restrict  */)tmp___10);
  }
  {
#line 339
  if (cid == 8777) {
#line 339
    goto case_8777;
  }
#line 342
  goto switch_default___2;
  case_8777: /* CIL Label */ 
  {
#line 340
  printf((char const   */* __restrict  */)"MX29LV160B");
  }
#line 341
  goto switch_break___3;
  switch_default___2: /* CIL Label */ 
  {
#line 343
  tmp___11 = gettext("Unknown (ID 0x%04x)");
#line 343
  printf((char const   */* __restrict  */)tmp___11, cid);
  }
#line 344
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 346
  goto switch_break;
  switch_default___3: /* CIL Label */ 
  {
#line 348
  tmp___12 = gettext("Unknown manufacturer (ID 0x%04x) Chip (ID 0x%04x)");
#line 348
  printf((char const   */* __restrict  */)tmp___12, mid, cid);
  }
#line 349
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 351
  tmp___13 = gettext("\n\tProtected: %04x\n");
#line 351
  printf((char const   */* __restrict  */)tmp___13, prot);
#line 354
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )16711935);
  }
#line 355
  return;
}
}
#line 357 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int o ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 360
  bus___0 = cfi_array___0->bus;
#line 361
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 361
  o = tmp;
#line 363
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
#line 367
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 368
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 369
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )8388736);
#line 370
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 371
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 372
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )3145776);
#line 374
  tmp___0 = amdstatus___0(cfi_array___0, adr, 65535);
  }
#line 374
  if (tmp___0) {
    {
#line 375
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 376
    amd_flash_read_array___0(cfi_array___0);
    }
#line 377
    return (0);
  }
  {
#line 379
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 381
  amd_flash_read_array___0(cfi_array___0);
  }
#line 383
  return (99);
}
}
#line 386 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 389
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 390
  return (0);
}
}
#line 393 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static int amd_flash_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;
  int o ;
  int tmp ;

  {
  {
#line 397
  bus___0 = cfi_array___0->bus;
#line 398
  tmp = amd_flash_address_shift___0(cfi_array___0);
#line 398
  o = tmp;
  }
#line 400
  if (dbg___0) {
    {
#line 401
    printf((char const   */* __restrict  */)"\nflash_program 0x%08X = 0x%08X\n", adr,
           data);
    }
  }
  {
#line 403
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )11141290);
#line 404
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(682 << o),
                                (uint32_t )5570645);
#line 405
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + (uint32_t )(1365 << o),
                                (uint32_t )10485920);
#line 407
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 408
  status = amdstatus___0(cfi_array___0, adr, (int )data);
  }
#line 411
  return (! status);
}
}
#line 414 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd.c"
static void amd_flash_read_array___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
  {
#line 418
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )15728880);
  }
#line 419
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_autodetect___0(cfi_array_t *cfi_array___0 ) ;
#line 78
static int amd_29xx040_status___0(bus_t *bus___0 , uint32_t adr , unsigned short data ) ;
#line 79
static void amd_29xx040_print_info___0(cfi_array_t *cfi_array___0 ) ;
#line 80
static void amd_29xx040_read_array___0(cfi_array_t *cfi_array___0 ) ;
#line 81
static int amd_29xx040_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 82
static int amd_29xx040_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) ;
#line 83
static int amd_29xx040_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) ;
#line 166 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_autodetect___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 168
  return (var_forced_detection.flash == 1UL);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_status___0(bus_t *bus___0 , uint32_t adr , unsigned short data ) 
{ 
  short timeout ;
  unsigned short dq7bit ;
  unsigned short dq7mask ;
  unsigned short dq5mask ;
  unsigned short data1 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 177
  dq7mask = (unsigned short )(1 << 7);
#line 178
  dq5mask = (unsigned short )(1 << 5);
#line 179
  dq7bit = (unsigned short )((int )data & (int )dq7mask);
#line 181
  timeout = (short)0;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! ((int )timeout < 1000)) {
#line 181
      goto while_break;
    }
    {
#line 183
    tmp = (*((bus___0->driver)->read))(bus___0, adr);
#line 183
    data1 = (unsigned short )(tmp & 255U);
    }
#line 184
    if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 185
      return (1);
    }
#line 187
    if (((int )data1 & (int )dq5mask) == (int )dq5mask) {
      {
#line 189
      tmp___0 = (*((bus___0->driver)->read))(bus___0, adr);
#line 189
      data1 = (unsigned short )(tmp___0 & 255U);
      }
#line 190
      if (((int )data1 & (int )dq7mask) == (int )dq7bit) {
#line 192
        return (1);
      } else {
#line 196
        return (0);
      }
    }
    {
#line 199
    usleep((__useconds_t )50);
#line 181
    timeout = (short )((int )timeout + 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 207 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static void amd_29xx040_print_info___0(cfi_array_t *cfi_array___0 ) 
{ 
  int mid ;
  int did ;
  int prot ;
  bus_t *bus___0 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 210
  bus___0 = cfi_array___0->bus;
#line 213
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 214
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 215
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 216
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 217
  tmp = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address);
#line 217
  mid = (int )tmp;
#line 218
  tmp___0 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 1U);
#line 218
  did = (int )tmp___0;
#line 219
  tmp___1 = (*((bus___0->driver)->read))(bus___0, cfi_array___0->address + 2U);
#line 219
  prot = (int )tmp___1;
#line 220
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 222
  printf((char const   */* __restrict  */)"%s: mid %x, did %x\n", "amd_29xx040_print_info",
         mid, did);
  }
  {
#line 227
  if (mid == 1) {
#line 227
    goto case_1;
  }
#line 230
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 228
  tmp___2 = gettext("Chip: AMD Flash\n\tPartNumber: ");
#line 228
  printf((char const   */* __restrict  */)tmp___2);
  }
#line 229
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 231
  tmp___3 = gettext("Unknown manufacturer (ID 0x%04x)");
#line 231
  printf((char const   */* __restrict  */)tmp___3, mid);
  }
#line 232
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 234
  tmp___4 = gettext("\n\tChip: ");
#line 234
  printf((char const   */* __restrict  */)tmp___4);
  }
  {
#line 236
  if (did == 164) {
#line 236
    goto case_164;
  }
#line 240
  if (did == 79) {
#line 240
    goto case_79;
  }
#line 244
  goto switch_default___0;
  case_164: /* CIL Label */ 
  {
#line 237
  printf((char const   */* __restrict  */)"Am29C040B\t-\t");
#line 238
  tmp___5 = gettext("5V Flash\n");
#line 238
  printf((char const   */* __restrict  */)tmp___5);
  }
#line 239
  goto switch_break___0;
  case_79: /* CIL Label */ 
  {
#line 241
  printf((char const   */* __restrict  */)"Am29LV040B\t-\t");
#line 242
  tmp___6 = gettext("3V Flash\n");
#line 242
  printf((char const   */* __restrict  */)tmp___6);
  }
#line 243
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 245
  tmp___7 = gettext("Unknown (ID 0x%04x)");
#line 245
  printf((char const   */* __restrict  */)tmp___7, did);
  }
#line 246
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 248
  tmp___8 = gettext("\n\tProtected: %04x\n");
#line 248
  printf((char const   */* __restrict  */)tmp___8, prot);
  }
#line 249
  return;
}
}
#line 251 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static void amd_29xx040_read_array___0(cfi_array_t *cfi_array___0 ) 
{ 


  {
#line 254
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 256
    (*((bus->driver)->write))(bus, cfi_array___0->address + 1365U, (uint32_t )144);
#line 257
    (*((bus->driver)->write))(bus, cfi_array___0->address + 682U, (uint32_t )0);
#line 258
    usleep((__useconds_t )100);
#line 259
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 261
  (*(((cfi_array___0->bus)->driver)->write))(cfi_array___0->bus, cfi_array___0->address,
                                             (uint32_t )240);
  }
#line 262
  return;
}
}
#line 266 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_erase_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 
  bus_t *bus___0 ;
  int tmp ;

  {
  {
#line 268
  bus___0 = cfi_array___0->bus;
#line 270
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X\n", adr);
  }
#line 274
  if ((int )var_forced_detection.unlock_bypass == 1) {
    {
#line 276
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )144);
#line 277
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )0);
#line 278
    usleep((__useconds_t )100);
#line 279
    var_forced_detection.unlock_bypass = (unsigned short)0;
    }
  }
  {
#line 282
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address, (uint32_t )240);
#line 283
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 284
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 285
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )128);
#line 286
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 287
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 289
  (*((bus___0->driver)->write))(bus___0, adr, (uint32_t )48);
#line 292
  tmp = amd_29xx040_status___0(bus___0, adr, (unsigned short)255);
  }
#line 292
  if (tmp) {
    {
#line 293
    printf((char const   */* __restrict  */)"flash_erase_block 0x%08X DONE\n", adr);
#line 294
    amd_29xx040_read_array___0(cfi_array___0);
    }
#line 295
    return (1);
  }
  {
#line 297
  printf((char const   */* __restrict  */)"flash_erase_block 0x%08X FAILED\n", adr);
#line 299
  amd_29xx040_read_array___0(cfi_array___0);
  }
#line 301
  return (-5);
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_program___0(cfi_array_t *cfi_array___0 , uint32_t adr , uint32_t data ) 
{ 
  int status ;
  bus_t *bus___0 ;

  {
#line 307
  bus___0 = cfi_array___0->bus;
#line 311
  if ((int )var_forced_detection.algorithm == 1) {
#line 313
    if ((int )var_forced_detection.unlock_bypass != 1) {
      {
#line 315
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 316
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
#line 317
      (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )32);
#line 318
      usleep((__useconds_t )1000);
#line 319
      var_forced_detection.unlock_bypass = (unsigned short)1;
      }
    }
  } else {
    {
#line 324
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )170);
#line 325
    (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 682U, (uint32_t )85);
    }
  }
  {
#line 328
  (*((bus___0->driver)->write))(bus___0, cfi_array___0->address + 1365U, (uint32_t )160);
#line 329
  (*((bus___0->driver)->write))(bus___0, adr, data);
#line 330
  status = amd_29xx040_status___0(bus___0, adr, (unsigned short )data);
  }
#line 333
  return (! status);
}
}
#line 336 "/home/khheo/project/benchmark/urjtag-0.9/src/flash/amd_flash.c"
static int amd_29xx040_unlock_block___0(cfi_array_t *cfi_array___0 , uint32_t adr ) 
{ 


  {
  {
#line 338
  printf((char const   */* __restrict  */)"flash_unlock_block 0x%08X IGNORE\n", adr);
  }
#line 339
  return (0);
}
}
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 85 "/home/khheo/project/benchmark/urjtag-0.9/src/lib/fclock.c"
extern int ( /* missing proto */  __builtin_isnormal)() ;
#line 73 "/home/khheo/project/benchmark/urjtag-0.9/src/lib/fclock.c"
long double frealtime(void) 
{ 
  long double result ;
  struct timespec t ;
  int tmp ;
  int tmp___3 ;

  {
  {
#line 79
  tmp = clock_gettime(0, & t);
  }
#line 79
  if (tmp == -1) {
    {
#line 80
    perror("frealtime (clock_gettime)");
#line 81
    exit(1);
    }
  }
  {
#line 83
  result = (long double )t.tv_sec + (long double )t.tv_nsec * (long double )1e-9;
#line 85
  tmp___3 = __builtin_isnormal(result);
  }
#line 85
  if (! tmp___3) {
    {
#line 85
    __assert_fail("isnormal(result)", "/home/khheo/project/benchmark/urjtag-0.9/src/lib/fclock.c",
                  85U, "frealtime");
    }
  }
#line 86
  if (! (result > (long double )0)) {
    {
#line 86
    __assert_fail("result > 0", "/home/khheo/project/benchmark/urjtag-0.9/src/lib/fclock.c",
                  86U, "frealtime");
    }
  }
#line 87
  return (result);
}
}
#line 49 "../../include/bssignal.h"
signal_t *signal_alloc(char const   *name ) ;
#line 50
void signal_free(signal_t *s ) ;
#line 52
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) ;
#line 53
void salias_free(salias_t *salias ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.9/src/part/signal.c"
signal_t *signal_alloc(char const   *name ) 
{ 
  signal_t *s ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc(sizeof(*s));
#line 33
  s = (signal_t *)tmp;
  }
#line 34
  if (! s) {
#line 35
    return ((signal_t *)((void *)0));
  }
  {
#line 37
  s->name = strdup(name);
  }
#line 38
  if (! s->name) {
    {
#line 39
    free((void *)s);
    }
#line 40
    return ((signal_t *)((void *)0));
  }
#line 42
  s->pin = (char *)((void *)0);
#line 43
  s->next = (signal_t *)((void *)0);
#line 44
  s->input = (bsbit_t *)((void *)0);
#line 45
  s->output = (bsbit_t *)((void *)0);
#line 47
  return (s);
}
}
#line 50 "/home/khheo/project/benchmark/urjtag-0.9/src/part/signal.c"
void signal_free(signal_t *s ) 
{ 


  {
#line 53
  if (! s) {
#line 54
    return;
  }
  {
#line 55
  free((void *)s->name);
#line 56
  free((void *)s);
  }
#line 57
  return;
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/part/signal.c"
salias_t *salias_alloc(char const   *name , signal_t const   *signal ) 
{ 
  salias_t *sa ;
  void *tmp ;

  {
  {
#line 62
  tmp = malloc(sizeof(*sa));
#line 62
  sa = (salias_t *)tmp;
  }
#line 63
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 64
    return ((salias_t *)((void *)0));
  }
  {
#line 66
  sa->name = strdup(name);
  }
#line 67
  if ((unsigned long )sa->name == (unsigned long )((void *)0)) {
    {
#line 68
    free((void *)sa);
    }
#line 69
    return ((salias_t *)((void *)0));
  }
#line 71
  sa->next = (salias_t *)((void *)0);
#line 72
  sa->signal = (signal_t *)signal;
#line 74
  return (sa);
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.9/src/part/signal.c"
void salias_free(salias_t *salias ) 
{ 


  {
#line 79
  if ((unsigned long )salias == (unsigned long )((void *)0)) {
#line 80
    return;
  }
  {
#line 81
  free((void *)salias->name);
#line 82
  free((void *)salias);
  }
#line 83
  return;
}
}
#line 52 "../../include/bsbit.h"
void bsbit_free(bsbit_t *b ) ;
#line 42 "../../include/data_register.h"
void data_register_free(data_register *dr ) ;
#line 44 "../../include/instruction.h"
void instruction_free(instruction *i ) ;
#line 58 "../../include/part.h"
void part_free(part_t *p ) ;
#line 66
void part_print(part_t *p ) ;
#line 79
void parts_print(parts_t *ps ) ;
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
part_t *part_alloc(tap_register const   *id ) 
{ 
  part_t *p ;
  void *tmp ;

  {
  {
#line 37
  tmp = malloc(sizeof(*p));
#line 37
  p = (part_t *)tmp;
  }
#line 38
  if (! p) {
#line 39
    return ((part_t *)((void *)0));
  }
  {
#line 40
  p->alias = (char *)((void *)0);
#line 41
  p->id = register_duplicate(id);
#line 42
  p->manufacturer[0] = (char )'\000';
#line 43
  p->part[0] = (char )'\000';
#line 44
  p->stepping[0] = (char )'\000';
#line 45
  p->signals = (signal_t *)((void *)0);
#line 46
  p->saliases = (salias_t *)((void *)0);
#line 47
  p->instruction_length = 0;
#line 48
  p->instructions = (instruction *)((void *)0);
#line 49
  p->active_instruction = (instruction *)((void *)0);
#line 50
  p->data_registers = (data_register *)((void *)0);
#line 51
  p->boundary_length = 0;
#line 52
  p->bsbits = (bsbit_t **)((void *)0);
  }
#line 54
  return (p);
}
}
#line 57 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void part_free(part_t *p ) 
{ 
  int i ;
  signal_t *s ;
  salias_t *sa ;
  instruction *i___0 ;
  data_register *dr ;

  {
#line 62
  if (! p) {
#line 63
    return;
  }
  {
#line 66
  free((void *)p->id);
  }
#line 68
  if (p->alias) {
    {
#line 68
    free((void *)p->alias);
    }
  }
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! p->signals) {
#line 71
      goto while_break;
    }
    {
#line 72
    s = p->signals;
#line 73
    p->signals = s->next;
#line 74
    signal_free(s);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 78
    if (! p->saliases) {
#line 78
      goto while_break___0;
    }
    {
#line 79
    sa = p->saliases;
#line 80
    p->saliases = sa->next;
#line 81
    salias_free(sa);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 85
    if (! p->instructions) {
#line 85
      goto while_break___1;
    }
    {
#line 86
    i___0 = p->instructions;
#line 87
    p->instructions = i___0->next;
#line 88
    instruction_free(i___0);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 92
    if (! p->data_registers) {
#line 92
      goto while_break___2;
    }
    {
#line 93
    dr = p->data_registers;
#line 94
    p->data_registers = dr->next;
#line 95
    data_register_free(dr);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 99
    if (! (i < p->boundary_length)) {
#line 99
      goto while_break___3;
    }
    {
#line 100
    bsbit_free(*(p->bsbits + i));
#line 99
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 101
  free((void *)p->bsbits);
#line 103
  free((void *)p);
  }
#line 104
  return;
}
}
#line 106 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
instruction *part_find_instruction(part_t *p , char const   *iname ) 
{ 
  instruction *i ;
  int tmp ;

  {
#line 111
  if (! p) {
#line 112
    return ((instruction *)((void *)0));
  } else
#line 111
  if (! iname) {
#line 112
    return ((instruction *)((void *)0));
  }
#line 114
  i = p->instructions;
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 115
    if (! i) {
#line 115
      goto while_break;
    }
    {
#line 116
    tmp = strcasecmp(iname, (char const   *)(i->name));
    }
#line 116
    if (tmp == 0) {
#line 117
      goto while_break;
    }
#line 118
    i = i->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  return (i);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
data_register *part_find_data_register(part_t *p , char const   *drname ) 
{ 
  data_register *dr ;
  int tmp ;

  {
#line 129
  if (! p) {
#line 130
    return ((data_register *)((void *)0));
  } else
#line 129
  if (! drname) {
#line 130
    return ((data_register *)((void *)0));
  }
#line 132
  dr = p->data_registers;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! dr) {
#line 133
      goto while_break;
    }
    {
#line 134
    tmp = strcasecmp(drname, (char const   *)(dr->name));
    }
#line 134
    if (tmp == 0) {
#line 135
      goto while_break;
    }
#line 136
    dr = dr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 139
  return (dr);
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
signal_t *part_find_signal(part_t *p , char const   *signalname ) 
{ 
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;

  {
#line 148
  if (! p) {
#line 149
    return ((signal_t *)((void *)0));
  } else
#line 148
  if (! signalname) {
#line 149
    return ((signal_t *)((void *)0));
  }
#line 151
  s = p->signals;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! s) {
#line 152
      goto while_break;
    }
    {
#line 153
    tmp = strcasecmp(signalname, (char const   *)s->name);
    }
#line 153
    if (tmp == 0) {
#line 154
      return (s);
    }
#line 155
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 158
  sa = p->saliases;
  {
#line 159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 159
    if (! sa) {
#line 159
      goto while_break___0;
    }
    {
#line 160
    tmp___0 = strcasecmp(signalname, (char const   *)sa->name);
    }
#line 160
    if (tmp___0 == 0) {
#line 161
      return (sa->signal);
    }
#line 162
    sa = sa->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 165
  return ((signal_t *)((void *)0));
}
}
#line 168 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void part_set_instruction(part_t *p , char const   *iname ) 
{ 


  {
#line 171
  if (p) {
    {
#line 172
    p->active_instruction = part_find_instruction(p, iname);
    }
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void part_set_signal(part_t *p , signal_t *s , int out , int val ) 
{ 
  data_register *bsr ;
  char *tmp ;
  int control ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 180
  if (! p) {
#line 181
    return;
  } else
#line 180
  if (! s) {
#line 181
    return;
  }
  {
#line 184
  bsr = part_find_data_register(p, "BSR");
  }
#line 185
  if (! bsr) {
    {
#line 186
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 186
    printf((char const   */* __restrict  */)tmp, "part_set_signal", "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c",
           186);
    }
#line 187
    return;
  }
#line 191
  if (out) {
#line 193
    if (! s->output) {
      {
#line 194
      tmp___0 = gettext("signal \'%s\' cannot be set as output\n");
#line 194
      printf((char const   */* __restrict  */)tmp___0, s->name);
      }
#line 195
      return;
    }
#line 197
    *((bsr->in)->data + (s->output)->bit) = (char )(val & 1);
#line 199
    control = (*(p->bsbits + (s->output)->bit))->control;
#line 200
    if (control >= 0) {
#line 201
      *((bsr->in)->data + control) = (char )((*(p->bsbits + (s->output)->bit))->control_value ^ 1);
    }
  } else {
#line 203
    if (! s->input) {
      {
#line 204
      tmp___1 = gettext("signal \'%s\' cannot be set as input\n");
#line 204
      printf((char const   */* __restrict  */)tmp___1, s->name);
      }
#line 205
      return;
    }
#line 207
    if (s->output) {
#line 208
      *((bsr->in)->data + (s->output)->control) = (char )(*(p->bsbits + (s->output)->bit))->control_value;
    }
  }
#line 210
  return;
}
}
#line 212 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
int part_get_signal(part_t *p , signal_t *s ) 
{ 
  data_register *bsr ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 217
  if (! p) {
#line 218
    return (-1);
  } else
#line 217
  if (! s) {
#line 218
    return (-1);
  }
  {
#line 221
  bsr = part_find_data_register(p, "BSR");
  }
#line 222
  if (! bsr) {
    {
#line 223
    tmp = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 223
    printf((char const   */* __restrict  */)tmp, "part_get_signal", "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c",
           223);
    }
#line 224
    return (-1);
  }
#line 227
  if (! s->input) {
    {
#line 228
    tmp___0 = gettext("signal \'%s\' is not input signal\n");
#line 228
    printf((char const   */* __restrict  */)tmp___0, s->name);
    }
#line 229
    return (-1);
  }
#line 232
  return ((int )*((bsr->out)->data + (s->input)->bit));
}
}
#line 235 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void part_print(part_t *p ) 
{ 
  char *instruction___0 ;
  char *dr ;
  char format[100] ;
  char *tmp ;

  {
#line 238
  instruction___0 = (char *)((void *)0);
#line 239
  dr = (char *)((void *)0);
#line 242
  if (! p) {
#line 243
    return;
  }
  {
#line 245
  tmp = gettext("%%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 245
  snprintf((char */* __restrict  */)(format), (size_t )100, (char const   */* __restrict  */)tmp,
           25, 20, 8, 20, 32);
  }
#line 248
  if (p->active_instruction) {
#line 249
    instruction___0 = (p->active_instruction)->name;
#line 250
    if ((unsigned long )(p->active_instruction)->data_register != (unsigned long )((void *)0)) {
#line 251
      dr = ((p->active_instruction)->data_register)->name;
    }
  }
#line 253
  if ((unsigned long )instruction___0 == (unsigned long )((void *)0)) {
    {
#line 254
    instruction___0 = gettext("(none)");
    }
  }
#line 255
  if ((unsigned long )dr == (unsigned long )((void *)0)) {
    {
#line 256
    dr = gettext("(none)");
    }
  }
  {
#line 257
  printf((char const   */* __restrict  */)(format), p->manufacturer, p->part, p->stepping,
         instruction___0, dr);
  }
#line 258
  return;
}
}
#line 262 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
parts_t *parts_alloc(void) 
{ 
  parts_t *ps ;
  void *tmp ;

  {
  {
#line 265
  tmp = malloc(sizeof(*ps));
#line 265
  ps = (parts_t *)tmp;
  }
#line 266
  if (! ps) {
#line 267
    return ((parts_t *)((void *)0));
  }
#line 269
  ps->len = 0;
#line 270
  ps->parts = (part_t **)((void *)0);
#line 272
  return (ps);
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void parts_free(parts_t *ps ) 
{ 
  int i ;

  {
#line 280
  if (! ps) {
#line 281
    return;
  }
#line 283
  i = 0;
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < ps->len)) {
#line 283
      goto while_break;
    }
    {
#line 284
    part_free(*(ps->parts + i));
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 286
  free((void *)ps->parts);
#line 287
  free((void *)ps);
  }
#line 288
  return;
}
}
#line 290 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
int parts_add_part(parts_t *ps , part_t *p ) 
{ 
  part_t **np ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 293
  tmp = realloc((void *)ps->parts, (unsigned long )(ps->len + 1) * sizeof(*(ps->parts)));
#line 293
  np = (part_t **)tmp;
  }
#line 295
  if (! np) {
#line 296
    return (0);
  }
#line 298
  ps->parts = np;
#line 299
  tmp___0 = ps->len;
#line 299
  (ps->len) ++;
#line 299
  *(ps->parts + tmp___0) = p;
#line 301
  return (1);
}
}
#line 304 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void parts_set_instruction(parts_t *ps , char const   *iname ) 
{ 
  int i ;

  {
#line 309
  if (! ps) {
#line 310
    return;
  }
#line 312
  i = 0;
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! (i < ps->len)) {
#line 312
      goto while_break;
    }
    {
#line 313
    (*(ps->parts + i))->active_instruction = part_find_instruction(*(ps->parts + i),
                                                                   iname);
#line 312
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return;
}
}
#line 316 "/home/khheo/project/benchmark/urjtag-0.9/src/part/part.c"
void parts_print(parts_t *ps ) 
{ 
  int i ;
  part_t *p ;
  char *tmp ;

  {
#line 321
  if (! ps) {
#line 322
    return;
  }
#line 324
  i = 0;
  {
#line 324
  while (1) {
    while_continue: /* CIL Label */ ;
#line 324
    if (! (i < ps->len)) {
#line 324
      goto while_break;
    }
#line 325
    p = *(ps->parts + i);
#line 327
    if (! p) {
#line 328
      goto __Cont;
    }
    {
#line 330
    tmp = gettext(" %3d ");
#line 330
    printf((char const   */* __restrict  */)tmp, i);
#line 331
    part_print(p);
    }
    __Cont: /* CIL Label */ 
#line 324
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  return;
}
}
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/part/instruction.c"
instruction *instruction_alloc(char const   *name , int len , char const   *val ) 
{ 
  instruction *i ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 38
  if (! name) {
#line 39
    return ((instruction *)((void *)0));
  } else
#line 38
  if (! val) {
#line 39
    return ((instruction *)((void *)0));
  }
  {
#line 41
  tmp = malloc(sizeof(*i));
#line 41
  i = (instruction *)tmp;
  }
#line 42
  if (! i) {
#line 43
    return ((instruction *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 20UL) {
    {
#line 46
    tmp___0 = gettext("Warning: Instruction name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(i->name), (char const   */* __restrict  */)name,
          (size_t )20);
#line 48
  i->name[20] = (char )'\000';
#line 50
  i->value = register_alloc(len);
  }
#line 51
  if (! i->value) {
    {
#line 52
    free((void *)i);
    }
#line 53
    return ((instruction *)((void *)0));
  }
  {
#line 55
  i->out = register_alloc(len);
  }
#line 56
  if (! i->out) {
    {
#line 57
    free((void *)i->value);
#line 58
    free((void *)i);
    }
#line 59
    return ((instruction *)((void *)0));
  }
  {
#line 62
  register_init(i->value, val);
#line 63
  i->data_register = (data_register *)((void *)0);
#line 64
  i->next = (instruction *)((void *)0);
  }
#line 66
  return (i);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/part/instruction.c"
void instruction_free(instruction *i ) 
{ 


  {
#line 72
  if (! i) {
#line 73
    return;
  }
#line 75
  if (i->value) {
    {
#line 76
    register_free(i->value);
    }
  }
#line 77
  if (i->out) {
    {
#line 78
    register_free(i->out);
    }
  }
  {
#line 79
  free((void *)i);
  }
#line 80
  return;
}
}
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/part/data_register.c"
data_register *data_register_alloc(char const   *name , int len ) 
{ 
  data_register *dr ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 38
  if (! name) {
#line 39
    return ((data_register *)((void *)0));
  }
  {
#line 41
  tmp = malloc(sizeof(*dr));
#line 41
  dr = (data_register *)tmp;
  }
#line 42
  if (! dr) {
#line 43
    return ((data_register *)((void *)0));
  }
  {
#line 45
  tmp___1 = strlen(name);
  }
#line 45
  if (tmp___1 > 32UL) {
    {
#line 46
    tmp___0 = gettext("Warning: Data register name too long\n");
#line 46
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
  {
#line 47
  strncpy((char */* __restrict  */)(dr->name), (char const   */* __restrict  */)name,
          (size_t )32);
#line 48
  dr->name[32] = (char )'\000';
  }
#line 50
  if (len > 0) {
    {
#line 52
    dr->in = register_alloc(len);
#line 53
    dr->out = register_alloc(len);
    }
  } else {
    {
#line 57
    dr->in = register_alloc(1);
#line 58
    dr->out = register_alloc(1);
    }
  }
#line 60
  if (! dr->in) {
    {
#line 61
    free((void *)dr->in);
#line 62
    free((void *)dr->out);
#line 63
    free((void *)(dr->name));
#line 64
    free((void *)dr);
    }
#line 65
    return ((data_register *)((void *)0));
  } else
#line 60
  if (! dr->out) {
    {
#line 61
    free((void *)dr->in);
#line 62
    free((void *)dr->out);
#line 63
    free((void *)(dr->name));
#line 64
    free((void *)dr);
    }
#line 65
    return ((data_register *)((void *)0));
  }
#line 68
  dr->next = (data_register *)((void *)0);
#line 70
  return (dr);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.9/src/part/data_register.c"
void data_register_free(data_register *dr ) 
{ 


  {
#line 76
  if (! dr) {
#line 77
    return;
  }
  {
#line 79
  register_free(dr->in);
#line 80
  register_free(dr->out);
#line 81
  free((void *)dr);
  }
#line 82
  return;
}
}
#line 51 "../../include/bsbit.h"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) ;
#line 30 "/home/khheo/project/benchmark/urjtag-0.9/src/part/bsbit.c"
bsbit_t *bsbit_alloc(int bit , char const   *name , int type , signal_t *signal ,
                     int safe ) 
{ 
  bsbit_t *b ;
  void *tmp ;

  {
  {
#line 33
  tmp = malloc(sizeof(*b));
#line 33
  b = (bsbit_t *)tmp;
  }
#line 34
  if (! b) {
#line 35
    return ((bsbit_t *)((void *)0));
  }
  {
#line 37
  b->name = strdup(name);
  }
#line 38
  if (! b->name) {
    {
#line 39
    free((void *)b);
    }
#line 40
    return ((bsbit_t *)((void *)0));
  }
#line 43
  b->bit = bit;
#line 44
  b->type = type;
#line 45
  b->signal = (signal_t *)((void *)0);
#line 46
  b->safe = safe;
#line 47
  b->control = -1;
#line 49
  if ((unsigned long )signal != (unsigned long )((void *)0)) {
#line 50
    b->signal = signal;
    {
#line 52
    if (type == 1) {
#line 52
      goto case_1;
    }
#line 55
    if (type == 2) {
#line 55
      goto case_2;
    }
#line 58
    if (type == 5) {
#line 58
      goto case_5;
    }
#line 51
    goto switch_break;
    case_1: /* CIL Label */ 
#line 53
    signal->input = b;
#line 54
    goto switch_break;
    case_2: /* CIL Label */ 
#line 56
    signal->output = b;
#line 57
    goto switch_break;
    case_5: /* CIL Label */ 
#line 59
    signal->input = b;
#line 60
    signal->output = b;
#line 61
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 65
  return (b);
}
}
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/part/bsbit.c"
void bsbit_free(bsbit_t *b ) 
{ 


  {
#line 71
  if (! b) {
#line 72
    return;
  }
  {
#line 74
  free((void *)b->name);
#line 75
  free((void *)b);
  }
#line 76
  return;
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int last_tdo___0  ;
#line 225 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpcu_shift___0(struct usb_dev_handle *xpcu , int reqno , int bits , int in_len ,
                          uint8_t *in , int out_len , uint8_t *out ) 
{ 
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 228
  tmp = usb_control_msg(xpcu, 64, 176, reqno, bits, (char *)((void *)0), 0, 1000);
  }
#line 228
  if (tmp < 0) {
    {
#line 230
    perror("usb_control_msg(x.x) (shift)");
    }
#line 231
    return (-1);
  }
  {
#line 249
  tmp___2 = usb_bulk_write(xpcu, 2, (char const   *)((char *)in), in_len, 1000);
  }
#line 249
  if (tmp___2 < 0) {
    {
#line 251
    tmp___0 = __errno_location();
#line 251
    tmp___1 = strerror(*tmp___0);
#line 251
    printf((char const   */* __restrict  */)"\nusb_bulk_write error(shift): %s\n",
           tmp___1);
    }
#line 252
    return (-1);
  }
#line 255
  if (out_len > 0) {
#line 255
    if ((unsigned long )out != (unsigned long )((void *)0)) {
      {
#line 257
      tmp___5 = usb_bulk_read(xpcu, 134, (char *)out, out_len, 1000);
      }
#line 257
      if (tmp___5 < 0) {
        {
#line 259
        tmp___3 = __errno_location();
#line 259
        tmp___4 = strerror(*tmp___3);
#line 259
        printf((char const   */* __restrict  */)"\nusb_bulk_read error(shift): %s\n",
               tmp___4);
        }
#line 260
        return (-1);
      }
    }
  }
#line 273
  return (0);
}
}
#line 278 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpcu_common_init___0(cable_t *cable ) 
{ 
  int r ;
  uint16_t buf ;
  struct usb_dev_handle *xpcu ;
  int tmp ;

  {
  {
#line 285
  tmp = usbconn_open(cable->link.usb);
  }
#line 285
  if (tmp) {
#line 285
    return (-1);
  }
  {
#line 287
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 289
  r = xpcu_request_28(xpcu, 17);
  }
#line 290
  if (r >= 0) {
    {
#line 290
    r = xpcu_write_gpio(xpcu, (uint8_t )8);
    }
  }
#line 294
  if (r >= 0) {
    {
#line 294
    r = xpcu_read_firmware_version(xpcu, & buf);
    }
  }
#line 295
  if (r >= 0) {
    {
#line 297
    printf((char const   */* __restrict  */)"firmware version = 0x%04X (%u)\n", (int )buf,
           (int )buf);
    }
  }
#line 302
  if (r >= 0) {
    {
#line 302
    xpcu_read_cpld_version(xpcu, & buf);
    }
  }
#line 303
  if (r >= 0) {
    {
#line 305
    printf((char const   */* __restrict  */)"cable CPLD version = 0x%04X (%u)\n",
           (int )buf, (int )buf);
    }
#line 306
    if ((int )buf == 0) {
      {
#line 308
      printf((char const   */* __restrict  */)"Warning: version \'0\' can\'t be correct. Please try resetting the cable\n");
#line 309
      r = -1;
      }
    }
  }
#line 313
  if (r < 0) {
    {
#line 315
    usb_close(xpcu);
    }
  }
#line 318
  return (r);
}
}
#line 321 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_int_init___0(cable_t *cable ) 
{ 
  struct usb_dev_handle *xpcu ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 326
  tmp = xpcu_common_init___0(cable);
  }
#line 326
  if (tmp < 0) {
#line 326
    return (-1);
  }
  {
#line 328
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 329
  tmp___0 = xpcu_select_gpio(xpcu, 0);
  }
#line 329
  if (tmp___0 < 0) {
#line 329
    return (-1);
  }
#line 331
  return (0);
}
}
#line 334 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_ext_init___0(cable_t *cable ) 
{ 
  struct usb_dev_handle *xpcu ;
  uint8_t zero[2] ;
  int r ;

  {
  {
#line 338
  zero[0] = (uint8_t )0;
#line 338
  zero[1] = (uint8_t )0;
#line 341
  free(cable->params);
#line 342
  cable->params = (void *)0;
#line 344
  r = xpcu_common_init___0(cable);
  }
#line 346
  if (r < 0) {
#line 346
    return (r);
  }
  {
#line 348
  cable->params = malloc(sizeof(xpc_cable_params_t ));
  }
#line 349
  if ((unsigned long )cable->params == (unsigned long )((void *)0)) {
#line 349
    r = -1;
  }
#line 351
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 353
  if (r >= 0) {
    {
#line 353
    r = xpcu_request_28(xpcu, 17);
    }
  }
#line 354
  if (r >= 0) {
    {
#line 354
    r = xpcu_output_enable(xpcu, 1);
    }
  }
#line 355
  if (r >= 0) {
    {
#line 355
    r = xpcu_shift___0(xpcu, 166, 2, 2, zero, 0, (uint8_t *)((void *)0));
    }
  }
#line 356
  if (r >= 0) {
    {
#line 356
    r = xpcu_request_28(xpcu, 18);
    }
  }
#line 358
  if (r < 0) {
    {
#line 360
    usb_close(xpcu);
#line 362
    free(cable->params);
#line 363
    cable->params = (void *)0;
    }
  }
#line 366
  return (r);
}
}
#line 371 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_ext_done___0(cable_t *cable ) 
{ 
  struct usb_dev_handle *xpcu ;

  {
  {
#line 375
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 376
  xpcu_output_enable(xpcu, 0);
#line 377
  generic_usbconn_done(cable);
  }
#line 378
  return;
}
}
#line 382 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_ext_free___0(cable_t *cable ) 
{ 


  {
#line 385
  if (cable->params) {
    {
#line 387
    free(cable->params);
#line 388
    cable->params = (void *)0;
    }
  }
  {
#line 390
  generic_usbconn_free(cable);
  }
#line 391
  return;
}
}
#line 401 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  struct usb_dev_handle *xpcu ;
  int tmp ;

  {
#line 406
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 408
  if (tms) {
#line 408
    tms = 1 << 1;
  } else {
#line 408
    tms = 0;
  }
#line 409
  if (tdi) {
#line 409
    tdi = 1;
  } else {
#line 409
    tdi = 0;
  }
  {
#line 411
  tmp = xpcu_write_gpio(xpcu, (uint8_t )(((1 << 3) | tms) | tdi));
  }
#line 411
  if (tmp >= 0) {
    {
#line 413
    cable_wait(cable);
#line 414
    i = 0;
    }
    {
#line 414
    while (1) {
      while_continue: /* CIL Label */ ;
#line 414
      if (! (i < n)) {
#line 414
        goto while_break;
      }
      {
#line 416
      xpcu_write_gpio(xpcu, (uint8_t )((((1 << 3) | (1 << 2)) | tms) | tdi));
#line 417
      cable_wait(cable);
#line 418
      xpcu_write_gpio(xpcu, (uint8_t )(((1 << 3) | tms) | tdi));
#line 419
      cable_wait(cable);
#line 414
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 422
  return;
}
}
#line 426 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_get_tdo___0(cable_t *cable ) 
{ 
  unsigned char d ;
  struct usb_dev_handle *xpcu ;
  int tmp ;

  {
  {
#line 431
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 433
  xpcu_read_gpio(xpcu, & d);
  }
#line 434
  if ((int )d & 1) {
#line 434
    tmp = 1;
  } else {
#line 434
    tmp = 0;
  }
#line 434
  return (tmp);
}
}
#line 439 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 442
  return (1);
}
}
#line 447 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpc_ext_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  uint8_t tdo[2] ;
  uint8_t clock[2] ;
  struct usb_dev_handle *xpcu ;
  int tmp ;
  int tmp___0 ;

  {
#line 455
  if (tms) {
#line 455
    tmp = 16;
  } else {
#line 455
    tmp = 0;
  }
#line 455
  if (tdi) {
#line 455
    tmp___0 = 1;
  } else {
#line 455
    tmp___0 = 0;
  }
#line 455
  clock[0] = (uint8_t )(tmp | tmp___0);
#line 456
  clock[1] = (uint8_t )17;
#line 458
  xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 460
  i = 0;
  {
#line 460
  while (1) {
    while_continue: /* CIL Label */ ;
#line 460
    if (! (i < n)) {
#line 460
      goto while_break;
    }
    {
#line 460
    xpcu_shift___0(xpcu, 166, 1, 2, clock, 2, tdo);
#line 460
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  if (tdo[1]) {
#line 462
    last_tdo___0 = 1;
  } else {
#line 462
    last_tdo___0 = 0;
  }
#line 464
  return;
}
}
#line 468 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_ext_get_tdo___0(cable_t *cable ) 
{ 


  {
#line 471
  return (last_tdo___0);
}
}
#line 494 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpcu_do_ext_transfer___0(xpc_ext_transfer_state_t *xts ) 
{ 
  int r ;
  int in_len ;
  int out_len ;
  int out_idx ;
  int out_rem ;
  uint32_t mask ;
  uint32_t rxw ;

  {
#line 501
  in_len = 2 * (xts->in_bits >> 2);
#line 502
  if ((xts->in_bits & 3) != 0) {
#line 502
    in_len += 2;
  }
#line 504
  out_len = 2 * (xts->out_bits >> 4);
#line 505
  if ((xts->out_bits & 15) != 0) {
#line 505
    out_len += 2;
  }
#line 507
  if ((unsigned long )xts->out != (unsigned long )((void *)0)) {
    {
#line 509
    r = xpcu_shift___0(xts->xpcu, 166, xts->in_bits, in_len, xts->buf, out_len, xts->buf);
    }
  } else {
    {
#line 513
    r = xpcu_shift___0(xts->xpcu, 166, xts->in_bits, in_len, xts->buf, 0, (uint8_t *)((void *)0));
    }
  }
#line 516
  if (r >= 0) {
#line 516
    if (xts->out_bits > 0) {
#line 518
      out_idx = 0;
#line 519
      out_rem = xts->out_bits;
      {
#line 521
      while (1) {
        while_continue: /* CIL Label */ ;
#line 521
        if (! (out_rem > 0)) {
#line 521
          goto while_break;
        }
#line 525
        rxw = (uint32_t )(((int )xts->buf[out_idx + 1] << 8) | (int )xts->buf[out_idx]);
#line 529
        if (out_rem >= 16) {
#line 529
          mask = (uint32_t )1;
        } else {
#line 529
          mask = (uint32_t )(1 << (16 - out_rem));
        }
        {
#line 531
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 531
          if (mask <= 32768U) {
#line 531
            if (! (out_rem > 0)) {
#line 531
              goto while_break___0;
            }
          } else {
#line 531
            goto while_break___0;
          }
#line 533
          if (rxw & mask) {
#line 533
            last_tdo___0 = 1;
          } else {
#line 533
            last_tdo___0 = 0;
          }
#line 534
          *(xts->out + xts->out_done) = (uint8_t )last_tdo___0;
#line 535
          (xts->out_done) ++;
#line 536
          mask <<= 1;
#line 537
          out_rem --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 540
        out_idx += 2;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 544
  xts->in_bits = 0;
#line 545
  xts->out_bits = 0;
#line 549
  return (r);
}
}
#line 554 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static void xpcu_add_bit_for_ext_transfer___0(xpc_ext_transfer_state_t *xts , char in ,
                                              char is_real ) 
{ 
  int bit_idx ;
  int buf_idx ;

  {
#line 557
  bit_idx = xts->in_bits & 3;
#line 558
  buf_idx = (xts->in_bits - bit_idx) >> 1;
#line 560
  if (bit_idx == 0) {
#line 562
    xts->buf[buf_idx] = (uint8_t )0;
#line 563
    xts->buf[buf_idx + 1] = (uint8_t )0;
  }
#line 566
  (xts->in_bits) ++;
#line 568
  if (is_real) {
#line 570
    if (in) {
#line 570
      xts->buf[buf_idx] = (uint8_t )((int )xts->buf[buf_idx] | (1 << bit_idx));
    }
#line 572
    if (xts->out) {
#line 574
      xts->buf[buf_idx + 1] = (uint8_t )((int )xts->buf[buf_idx + 1] | (17 << bit_idx));
#line 575
      (xts->out_bits) ++;
    } else {
#line 579
      xts->buf[buf_idx + 1] = (uint8_t )((int )xts->buf[buf_idx + 1] | (1 << bit_idx));
    }
  }
#line 582
  return;
}
}
#line 586 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/xpc.c"
static int xpc_ext_transfer___0(cable_t *cable , int len , char *in , char *out ) 
{ 
  int i ;
  int j ;
  xpc_ext_transfer_state_t xts ;

  {
#line 600
  xts.xpcu = ((libusb_param_t *)(cable->link.usb)->params)->handle;
#line 601
  xts.out = (uint8_t *)out;
#line 602
  xts.in_bits = 0;
#line 603
  xts.out_bits = 0;
#line 604
  xts.out_done = 0;
#line 605
  xts.cable = cable;
#line 607
  i = 0;
#line 607
  j = 0;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (i < len) {
#line 607
      if (! (j >= 0)) {
#line 607
        goto while_break;
      }
    } else {
#line 607
      goto while_break;
    }
    {
#line 609
    xpcu_add_bit_for_ext_transfer___0(& xts, *(in + i), (char)1);
    }
#line 610
    if (xts.in_bits == 15) {
      {
#line 612
      j = xpcu_do_ext_transfer___0(& xts);
      }
    }
#line 607
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 616
  if (xts.in_bits > 0) {
#line 616
    if (j >= 0) {
#line 619
      if ((xts.in_bits & 3) == 0) {
        {
#line 621
        xpcu_add_bit_for_ext_transfer___0(& xts, (char)0, (char)0);
        }
      }
      {
#line 623
      j = xpcu_do_ext_transfer___0(& xts);
      }
    }
  }
#line 626
  return (j);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static char const   *std_wgl_map___0  =    "7,4,3,2,1,#0";
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int map_pin___0(char *pin , int *act , int *inact ) 
{ 
  int bitnum ;
  int inverted ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 114
  inverted = 0;
#line 116
  if ((int )*pin == 35) {
#line 117
    inverted = 1;
#line 118
    pin ++;
  }
  {
#line 121
  tmp = __ctype_b_loc();
  }
#line 121
  if (! ((int const   )*(*tmp + (int )*pin) & 2048)) {
#line 122
    return (-1);
  }
  {
#line 124
  tmp___0 = atoi((char const   *)pin);
#line 124
  bitnum = tmp___0 % 8;
#line 126
  bitnum = 1 << bitnum;
  }
#line 128
  if (inverted) {
#line 128
    *act = 0;
  } else {
#line 128
    *act = bitnum;
  }
#line 129
  if (inverted) {
#line 129
    *inact = bitnum;
  } else {
#line 129
    *inact = 0;
  }
#line 131
  return (0);
}
}
#line 135 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int set_mapping___0(char *bitmap , cable_t *cable ) 
{ 
  char delim ;
  int syntax ;
  char *tdo ;
  char *trst ;
  char *tdi ;
  char *tck ;
  char *tms ;
  char *srst ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 138
  delim = (char )',';
#line 139
  syntax = 0;
#line 143
  tdo = bitmap;
#line 143
  if (tdo) {
    {
#line 144
    trst = strchr((char const   *)tdo, (int )delim);
    }
#line 144
    if (trst) {
      {
#line 145
      trst ++;
#line 146
      tdi = strchr((char const   *)trst, (int )delim);
      }
#line 146
      if (tdi) {
        {
#line 147
        tdi ++;
#line 148
        tck = strchr((char const   *)tdi, (int )delim);
        }
#line 148
        if (tck) {
          {
#line 149
          tck ++;
#line 150
          tms = strchr((char const   *)tck, (int )delim);
          }
#line 150
          if (tms) {
            {
#line 151
            tms ++;
#line 152
            srst = strchr((char const   *)tms, (int )delim);
            }
#line 152
            if (srst) {
#line 153
              srst ++;
#line 154
              syntax = 1;
            }
          }
        }
      }
    }
  }
#line 157
  if (! syntax) {
#line 158
    return (-1);
  }
  {
#line 160
  tmp = map_pin___0(tdo, & ((wiggler_params_t *)cable->params)->tdo_act, & ((wiggler_params_t *)cable->params)->tdo_inact);
  }
#line 160
  if (tmp != 0) {
#line 160
    return (-1);
  }
  {
#line 161
  tmp___0 = map_pin___0(trst, & ((wiggler_params_t *)cable->params)->trst_act, & ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 161
  if (tmp___0 != 0) {
#line 161
    return (-1);
  }
  {
#line 162
  tmp___1 = map_pin___0(tdi, & ((wiggler_params_t *)cable->params)->tdi_act, & ((wiggler_params_t *)cable->params)->tdi_inact);
  }
#line 162
  if (tmp___1 != 0) {
#line 162
    return (-1);
  }
  {
#line 163
  tmp___2 = map_pin___0(tck, & ((wiggler_params_t *)cable->params)->tck_act, & ((wiggler_params_t *)cable->params)->tck_inact);
  }
#line 163
  if (tmp___2 != 0) {
#line 163
    return (-1);
  }
  {
#line 164
  tmp___3 = map_pin___0(tms, & ((wiggler_params_t *)cable->params)->tms_act, & ((wiggler_params_t *)cable->params)->tms_inact);
  }
#line 164
  if (tmp___3 != 0) {
#line 164
    return (-1);
  }
  {
#line 165
  tmp___4 = map_pin___0(srst, & ((wiggler_params_t *)cable->params)->srst_act, & ((wiggler_params_t *)cable->params)->srst_inact);
  }
#line 165
  if (tmp___4 != 0) {
#line 165
    return (-1);
  }
#line 167
  return (0);
}
}
#line 171 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_connect___0(char **params , cable_t *cable ) 
{ 
  int result ;
  char *param_bitmap ;
  wiggler_params_t *wiggler_params ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 175
  param_bitmap = (char *)((void *)0);
#line 178
  tmp = cmd_params(params);
  }
#line 178
  if (tmp == 4) {
#line 180
    param_bitmap = *(params + 3);
#line 182
    *(params + 3) = (char *)((void *)0);
  }
  {
#line 185
  result = generic_parport_connect(params, cable);
  }
#line 185
  if (result != 0) {
#line 186
    return (result);
  }
#line 188
  if (param_bitmap) {
#line 189
    *(params + 3) = param_bitmap;
  }
  {
#line 191
  tmp___0 = malloc(sizeof(*wiggler_params));
#line 191
  wiggler_params = (wiggler_params_t *)tmp___0;
  }
#line 192
  if (! wiggler_params) {
    {
#line 193
    tmp___1 = gettext("%s(%d) malloc failed!\n");
#line 193
    printf((char const   */* __restrict  */)tmp___1, "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c",
           193);
#line 199
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
    }
#line 200
    return (4);
  }
  {
#line 204
  free(cable->params);
#line 205
  cable->params = (void *)wiggler_params;
  }
#line 207
  if (! param_bitmap) {
#line 208
    param_bitmap = (char *)std_wgl_map___0;
  }
  {
#line 210
  result = set_mapping___0(param_bitmap, cable);
  }
#line 210
  if (result != 0) {
    {
#line 211
    tmp___2 = gettext("Pin mapping failed\n");
#line 211
    printf((char const   */* __restrict  */)tmp___2);
#line 217
    (*(((cable->link.port)->driver)->parport_free))(cable->link.port);
#line 218
    free(cable->params);
    }
#line 219
    return (result);
  }
#line 224
  ((wiggler_params_t *)cable->params)->unused_bits = ~ (((((((((((wiggler_params_t *)cable->params)->srst_act | ((wiggler_params_t *)cable->params)->srst_inact) | ((wiggler_params_t *)cable->params)->tms_act) | ((wiggler_params_t *)cable->params)->tms_inact) | ((wiggler_params_t *)cable->params)->tck_act) | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->tdi_act) | ((wiggler_params_t *)cable->params)->tdi_inact) | ((wiggler_params_t *)cable->params)->trst_act) | ((wiggler_params_t *)cable->params)->trst_inact) & 255;
#line 230
  return (0);
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 238
  tmp = parport_open(cable->link.port);
  }
#line 238
  if (tmp) {
#line 239
    return (-1);
  }
  {
#line 241
  data = parport_get_data(cable->link.port);
  }
#line 241
  if (data < 0) {
    {
#line 242
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
    }
#line 242
    if (tmp___0) {
#line 243
      return (-1);
    }
#line 244
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact;
  } else {
#line 246
    ((wiggler_params_t *)cable->params)->trst_lvl = data & (((wiggler_params_t *)cable->params)->trst_act | ((wiggler_params_t *)cable->params)->trst_inact);
  }
#line 248
  return (0);
}
}
#line 251 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static void wiggler_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 256
  if (tms) {
#line 256
    tms = 1;
  } else {
#line 256
    tms = 0;
  }
#line 257
  if (tdi) {
#line 257
    tdi = 1;
  } else {
#line 257
    tdi = 0;
  }
#line 259
  i = 0;
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 259
    if (! (i < n)) {
#line 259
      goto while_break;
    }
#line 260
    if (tms) {
#line 260
      tmp = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 260
      tmp = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 260
    if (tdi) {
#line 260
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 260
      tmp___0 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 260
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | tmp) | tmp___0) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 265
    cable_wait(cable);
    }
#line 266
    if (tms) {
#line 266
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_act;
    } else {
#line 266
      tmp___1 = ((wiggler_params_t *)cable->params)->tms_inact;
    }
#line 266
    if (tdi) {
#line 266
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_act;
    } else {
#line 266
      tmp___2 = ((wiggler_params_t *)cable->params)->tdi_inact;
    }
    {
#line 266
    parport_set_data(cable->link.port, (uint8_t )((((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_act) | tmp___1) | tmp___2) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 271
    cable_wait(cable);
#line 259
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 275 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_get_tdo___0(cable_t *cable ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 278
  parport_set_data(cable->link.port, (uint8_t )((((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->tck_inact) | ((wiggler_params_t *)cable->params)->unused_bits));
#line 281
  cable_wait(cable);
#line 282
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 282
  if ((tmp___1 & (((wiggler_params_t *)cable->params)->tdo_act | ((wiggler_params_t *)cable->params)->tdo_inact)) ^ ((wiggler_params_t *)cable->params)->tdo_act) {
#line 282
    tmp___0 = 0;
  } else {
#line 282
    tmp___0 = 1;
  }
#line 282
  return (tmp___0);
}
}
#line 286 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_set_trst___0(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
#line 289
  if (trst) {
#line 289
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_act;
  } else {
#line 289
    ((wiggler_params_t *)cable->params)->trst_lvl = ((wiggler_params_t *)cable->params)->trst_inact;
  }
  {
#line 291
  parport_set_data(cable->link.port, (uint8_t )(((wiggler_params_t *)cable->params)->trst_lvl | ((wiggler_params_t *)cable->params)->unused_bits));
  }
#line 293
  if (((wiggler_params_t *)cable->params)->trst_lvl ^ ((wiggler_params_t *)cable->params)->trst_act) {
#line 293
    tmp = 0;
  } else {
#line 293
    tmp = 1;
  }
#line 293
  return (tmp);
}
}
#line 296 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static int wiggler_get_trst___0(cable_t *cable ) 
{ 
  int tmp ;

  {
#line 299
  if (((wiggler_params_t *)cable->params)->trst_lvl ^ ((wiggler_params_t *)cable->params)->trst_act) {
#line 299
    tmp = 0;
  } else {
#line 299
    tmp = 1;
  }
#line 299
  return (tmp);
}
}
#line 302 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler.c"
static void wiggler_help___0(char const   *cablename ) 
{ 
  char *tmp ;

  {
  {
#line 305
  tmp = gettext("Usage: cable %s parallel PORTADDR [TDO,TRST,TDI,TCK,TMS,SRESET]\n   or: cable %s ppdev PPDEV [TDO,TRST,TDI,TCK,TMS,SRESET]\n\nPORTADDR   parallel port address (e.g. 0x378)\nPPDEV      ppdev device (e.g. /dev/parport0)\nTDO, ...   parallel port bit number, prepend \'#\' for inversion\n           default is \'%s\'\n\n");
#line 305
  printf((char const   */* __restrict  */)tmp, cablename, cablename, std_wgl_map___0);
  }
#line 334
  return;
}
}
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static int wiggler2_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 73
  tmp = parport_open(cable->link.port);
  }
#line 73
  if (tmp) {
#line 74
    return (-1);
  }
  {
#line 76
  data = parport_get_data(cable->link.port);
  }
#line 76
  if (data < 0) {
    {
#line 77
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255));
    }
#line 77
    if (tmp___0) {
#line 78
      return (-1);
    }
#line 79
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 81
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 83
  return (0);
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static void wiggler2_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 91
  if (tms) {
#line 91
    tms = 1;
  } else {
#line 91
    tms = 0;
  }
#line 92
  if (tdi) {
#line 92
    tdi = 1;
  } else {
#line 92
    tdi = 0;
  }
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (i < n)) {
#line 94
      goto while_break;
    }
    {
#line 95
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 96
    cable_wait(cable);
#line 97
    parport_set_data(cable->link.port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 4) | (1 << 2)) | (tms << 1)) | (tdi << 3)) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 98
    cable_wait(cable);
#line 94
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 100
  return;
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static int wiggler2_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 105
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
#line 106
  cable_wait(cable);
#line 107
  tmp = parport_get_status(cable->link.port);
  }
#line 107
  return ((tmp >> 7) & 1);
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/wiggler2.c"
static int wiggler2_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 113
  if (trst) {
#line 113
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 113
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 115
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 4) | (~ (((((1 << 3) | (1 << 2)) | (1 << 1)) | (1 << 4)) | 1) & 255)));
  }
#line 116
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static int triton_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 72
  tmp = parport_open(cable->link.port);
  }
#line 72
  if (tmp) {
#line 73
    return (-1);
  }
#line 75
  ((generic_params_t *)cable->params)->trst = 1;
#line 76
  ((generic_params_t *)cable->params)->sreset = 1;
#line 78
  return (0);
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static void triton_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 86
  if (tms) {
#line 86
    tms = 1;
  } else {
#line 86
    tms = 0;
  }
#line 87
  if (tdi) {
#line 87
    tdi = 1;
  } else {
#line 87
    tdi = 0;
  }
#line 89
  i = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (i < n)) {
#line 89
      goto while_break;
    }
    {
#line 90
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | (tms << 2)) | (tdi << 1)));
#line 91
    cable_wait(cable);
#line 92
    parport_set_data(cable->link.port, (uint8_t )(((((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)) | 1) | (tms << 2)) | (tdi << 1)));
#line 93
    cable_wait(cable);
#line 89
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 97 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static int triton_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 100
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
#line 101
  cable_wait(cable);
#line 102
  tmp = parport_get_status(cable->link.port);
  }
#line 102
  return ((tmp >> 7) & 1);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/triton.c"
static int triton_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 108
  if (trst) {
#line 108
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 108
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 110
  parport_set_data(cable->link.port, (uint8_t )((((generic_params_t *)cable->params)->trst << 3) | (((generic_params_t *)cable->params)->sreset << 4)));
  }
#line 111
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static port_node_t *ports___1  =    (port_node_t *)((void *)0);
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static parport_t *ppdev_parport_alloc___0(char const   *port ) 
{ 
  ppdev_params_t *params ;
  void *tmp ;
  char *portname ;
  char *tmp___0 ;
  parport_t *parport ;
  void *tmp___1 ;
  port_node_t *node ;
  void *tmp___2 ;

  {
  {
#line 64
  tmp = malloc(sizeof(*params));
#line 64
  params = (ppdev_params_t *)tmp;
#line 65
  tmp___0 = strdup(port);
#line 65
  portname = tmp___0;
#line 66
  tmp___1 = malloc(sizeof(*parport));
#line 66
  parport = (parport_t *)tmp___1;
#line 67
  tmp___2 = malloc(sizeof(*node));
#line 67
  node = (port_node_t *)tmp___2;
  }
#line 69
  if (! node) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! parport) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! params) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  } else
#line 69
  if (! portname) {
    {
#line 70
    free((void *)node);
#line 71
    free((void *)parport);
#line 72
    free((void *)params);
#line 73
    free((void *)portname);
    }
#line 74
    return ((parport_t *)((void *)0));
  }
#line 77
  params->portname = portname;
#line 78
  params->fd = -1;
#line 80
  parport->params = (void *)params;
#line 81
  parport->driver = & ppdev_parport_driver;
#line 82
  parport->cable = (cable_t *)((void *)0);
#line 84
  node->port = parport;
#line 85
  node->next = ports___1;
#line 87
  ports___1 = node;
#line 89
  return (parport);
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static void ppdev_parport_free___0(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 97
  prev = & ports___1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! *prev) {
#line 97
      goto while_break;
    }
#line 98
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 99
      goto while_break;
    }
#line 97
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  if (*prev) {
    {
#line 102
    pn = *prev;
#line 103
    *prev = pn->next;
#line 104
    free((void *)pn);
    }
  }
  {
#line 107
  free((void *)((ppdev_params_t *)port->params)->portname);
#line 108
  free(port->params);
#line 109
  free((void *)port);
  }
#line 110
  return;
}
}
#line 141 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_open___0(parport_t *parport ) 
{ 
  ppdev_params_t *p ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 144
  p = (ppdev_params_t *)parport->params;
#line 146
  p->fd = open((char const   *)p->portname, 2);
  }
#line 147
  if (p->fd < 0) {
    {
#line 148
    tmp = __errno_location();
#line 148
    tmp___0 = strerror(*tmp);
#line 148
    tmp___1 = gettext("Could not open port %s: %s\n");
#line 148
    printf((char const   */* __restrict  */)tmp___1, p->portname, tmp___0);
    }
#line 149
    return (-1);
  }
  {
#line 152
  tmp___5 = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 139U));
  }
#line 152
  if (tmp___5 == -1) {
    {
#line 153
    tmp___2 = __errno_location();
#line 153
    tmp___3 = strerror(*tmp___2);
#line 153
    tmp___4 = gettext("Could not claim ppdev device: %s\n");
#line 153
    printf((char const   */* __restrict  */)tmp___4, tmp___3);
#line 154
    close(p->fd);
#line 155
    p->fd = -1;
    }
#line 156
    return (-1);
  }
#line 159
  return (0);
}
}
#line 162 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_close___0(parport_t *parport ) 
{ 
  int r ;
  ppdev_params_t *p ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 165
  r = 0;
#line 166
  p = (ppdev_params_t *)parport->params;
#line 168
  tmp = ioctl(p->fd, (unsigned long )((unsigned int )(112 << 8) | 140U));
  }
#line 168
  if (tmp == -1) {
#line 169
    r = -1;
  }
  {
#line 171
  tmp___0 = close(p->fd);
  }
#line 171
  if (tmp___0 != 0) {
#line 172
    return (-1);
  }
#line 174
  p->fd = -1;
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_set_data___0(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 181
  p = (ppdev_params_t *)parport->params;
#line 183
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 134U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 183
  if (tmp == -1) {
#line 184
    return (-1);
  }
#line 186
  return (0);
}
}
#line 189 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_get_data___0(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 193
  p = (ppdev_params_t *)parport->params;
#line 195
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 133U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 195
  if (tmp == -1) {
#line 196
    return (-1);
  }
#line 198
  return ((int )d);
}
}
#line 201 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_get_status___0(parport_t *parport ) 
{ 
  unsigned char d ;
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 205
  p = (ppdev_params_t *)parport->params;
#line 207
  tmp = ioctl(p->fd, (unsigned long )(((2U << 30) | (unsigned int )(112 << 8)) | 129U) | (sizeof(unsigned char ) << 16),
              & d);
  }
#line 207
  if (tmp == -1) {
#line 208
    return (-1);
  }
#line 210
  return ((int )d ^ 128);
}
}
#line 213 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/ppdev.c"
static int ppdev_set_control___0(parport_t *parport , uint8_t data ) 
{ 
  ppdev_params_t *p ;
  int tmp ;

  {
  {
#line 216
  p = (ppdev_params_t *)parport->params;
#line 218
  data = (uint8_t )((int )data ^ 11);
#line 220
  tmp = ioctl(p->fd, (unsigned long )(((1U << 30) | (unsigned int )(112 << 8)) | 132U) | (sizeof(unsigned char ) << 16),
              & data);
  }
#line 220
  if (tmp == -1) {
#line 221
    return (-1);
  }
#line 223
  return (0);
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static int mpcbdm_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 67
  tmp = parport_open(cable->link.port);
  }
#line 67
  if (tmp) {
#line 68
    return (-1);
  }
  {
#line 70
  parport_set_control(cable->link.port, (uint8_t )0);
#line 71
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 73
  return (0);
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static void mpcbdm_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 81
  if (tms) {
#line 81
    tms = 1;
  } else {
#line 81
    tms = 0;
  }
#line 82
  if (tdi) {
#line 82
    tdi = 1;
  } else {
#line 82
    tdi = 0;
  }
#line 84
  i = 0;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < n)) {
#line 84
      goto while_break;
    }
    {
#line 85
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | (tdi << 1)));
#line 86
    cable_wait(cable);
#line 87
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 2)) | (tdi << 1)));
#line 88
    cable_wait(cable);
#line 84
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static int mpcbdm_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 95
  parport_set_data(cable->link.port, (uint8_t )0);
#line 96
  cable_wait(cable);
#line 97
  tmp = parport_get_status(cable->link.port);
  }
#line 97
  return ((tmp >> 5) & 1);
}
}
#line 100 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/mpcbdm.c"
static int mpcbdm_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 103
  if (trst) {
#line 103
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 103
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 105
  parport_set_control(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst ^ 1));
  }
#line 106
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static int libusb_match_desc___0(struct usb_device *dev , char *desc ) 
{ 
  int r ;
  char buf[256] ;
  usb_dev_handle *handle ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 61
  r = 0;
#line 65
  if ((unsigned long )desc == (unsigned long )((void *)0)) {
#line 65
    return (1);
  }
  {
#line 67
  handle = usb_open(dev);
  }
#line 68
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
    {
#line 70
    perror("libusb: usb_open() failed");
    }
#line 71
    return (0);
  }
#line 73
  if (dev->descriptor.iManufacturer) {
    {
#line 75
    r = usb_get_string_simple(handle, (int )dev->descriptor.iManufacturer, buf, sizeof(buf));
    }
#line 76
    if (r > 0) {
      {
#line 78
      tmp = strstr((char const   *)(buf), (char const   *)desc);
      }
#line 78
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 78
        r = 0;
      }
    }
  }
#line 81
  if (r <= 0) {
#line 81
    if (dev->descriptor.iProduct) {
      {
#line 83
      r = usb_get_string_simple(handle, (int )dev->descriptor.iProduct, buf, sizeof(buf));
      }
#line 84
      if (r > 0) {
        {
#line 86
        tmp___0 = strstr((char const   *)(buf), (char const   *)desc);
        }
#line 86
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 86
          r = 0;
        }
      }
    }
  }
#line 89
  if (r <= 0) {
#line 89
    if (dev->descriptor.iSerialNumber) {
      {
#line 91
      r = usb_get_string_simple(handle, (int )dev->descriptor.iSerialNumber, buf,
                                sizeof(buf));
      }
#line 92
      if (r > 0) {
        {
#line 94
        tmp___1 = strstr((char const   *)(buf), (char const   *)desc);
        }
#line 94
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 94
          r = 0;
        }
      }
    }
  }
  {
#line 97
  usb_close(handle);
  }
#line 98
  if (r > 0) {
#line 98
    tmp___2 = 1;
  } else {
#line 98
    tmp___2 = 0;
  }
#line 98
  return (tmp___2);
}
}
#line 170 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static int usbconn_libusb_open___0(usbconn_t *conn ) 
{ 
  libusb_param_t___0 *p ;
  int tmp ;

  {
  {
#line 173
  p = (libusb_param_t___0 *)conn->params;
#line 175
  p->handle = usb_open(p->dev);
  }
#line 176
  if ((unsigned long )p->handle == (unsigned long )((void *)0)) {
    {
#line 178
    perror("libusb: usb_open() failed");
    }
  } else {
    {
#line 183
    usb_set_configuration(p->handle, (int )((p->dev)->config + 0)->bConfigurationValue);
#line 186
    tmp = usb_claim_interface(p->handle, 0);
    }
#line 186
    if (tmp != 0) {
      {
#line 188
      perror("libusb: usb_claim_interface failed");
#line 189
      usb_close(p->handle);
#line 190
      p->handle = (struct usb_dev_handle *)((void *)0);
      }
    } else {
      {
#line 195
      usb_set_altinterface(p->handle, 0);
      }
    }
  }
#line 200
  if ((unsigned long )p->handle == (unsigned long )((void *)0)) {
#line 203
    return (-1);
  }
#line 206
  return (0);
}
}
#line 211 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static int usbconn_libusb_close___0(usbconn_t *conn ) 
{ 
  libusb_param_t___0 *p ;

  {
#line 214
  p = (libusb_param_t___0 *)conn->params;
#line 215
  if ((unsigned long )p->handle != (unsigned long )((void *)0)) {
    {
#line 217
    usb_release_interface(p->handle, 0);
#line 218
    usb_close(p->handle);
    }
  }
#line 220
  p->handle = (struct usb_dev_handle *)((void *)0);
#line 221
  return (0);
}
}
#line 226 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/usbconn/libusb.c"
static void usbconn_libusb_free___0(usbconn_t *conn ) 
{ 


  {
  {
#line 229
  free(conn->params);
#line 230
  free((void *)conn);
  }
#line 231
  return;
}
}
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static int lattice_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
#line 60
  ((generic_params_t *)cable->params)->trst = 1;
#line 62
  return (0);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static void lattice_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 70
  if (tms) {
#line 70
    tms = 1;
  } else {
#line 70
    tms = 0;
  }
#line 71
  if (tdi) {
#line 71
    tdi = 1;
  } else {
#line 71
    tdi = 0;
  }
#line 73
  i = 0;
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < n)) {
#line 73
      goto while_break;
    }
    {
#line 74
    parport_set_data(cable->link.port, (uint8_t )(((tms << 2) | tdi) | (1 << 4)));
#line 75
    cable_wait(cable);
#line 76
    parport_set_data(cable->link.port, (uint8_t )((((1 << 1) | (tms << 2)) | tdi) | (1 << 4)));
#line 77
    cable_wait(cable);
#line 73
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static int lattice_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 84
  parport_set_data(cable->link.port, (uint8_t )(1 << 4));
#line 85
  cable_wait(cable);
#line 86
  tmp = parport_get_status(cable->link.port);
  }
#line 86
  return ((tmp >> 6) & 1);
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/lattice.c"
static int lattice_set_trst___0(cable_t *cable , int trst ) 
{ 
  int tmp ;

  {
  {
#line 92
  tmp = parport_set_data(cable->link.port, (uint8_t )(trst << 4));
  }
#line 92
  return (tmp);
}
}
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static int keithkoep_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 69
  tmp = parport_open(cable->link.port);
  }
#line 69
  if (tmp) {
#line 70
    return (-1);
  }
  {
#line 72
  parport_set_control(cable->link.port, (uint8_t )1);
#line 73
  ((generic_params_t *)cable->params)->trst = 1;
  }
#line 75
  return (0);
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static void keithkoep_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 83
  if (tms) {
#line 83
    tms = 1;
  } else {
#line 83
    tms = 0;
  }
#line 84
  if (tdi) {
#line 84
    tdi = 1;
  } else {
#line 84
    tdi = 0;
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < n)) {
#line 86
      goto while_break;
    }
    {
#line 87
    parport_set_data(cable->link.port, (uint8_t )((tms << 2) | tdi));
#line 88
    cable_wait(cable);
#line 89
    parport_set_data(cable->link.port, (uint8_t )(((1 << 1) | (tms << 2)) | tdi));
#line 90
    cable_wait(cable);
#line 86
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static int keithkoep_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 97
  parport_set_data(cable->link.port, (uint8_t )0);
#line 98
  cable_wait(cable);
#line 99
  tmp = parport_get_status(cable->link.port);
  }
#line 99
  return ((tmp >> 5) & 1);
}
}
#line 102 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/keithkoep.c"
static int keithkoep_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 105
  if (trst) {
#line 105
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 105
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 107
  parport_set_control(cable->link.port, (uint8_t )((generic_params_t *)cable->params)->trst);
  }
#line 108
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_reset___0(libusb_param_t *params , int trst , int srst ) ;
#line 100
static void jlink_simple_command___0(libusb_param_t *params , uint8_t command ) ;
#line 104
static void jlink_tap_init___0(jlink_usbconn_data_t *data ) ;
#line 105
static int jlink_tap_execute___0(libusb_param_t *params ) ;
#line 106
static void jlink_tap_append_step___0(jlink_usbconn_data_t *data , int tms , int tdi ) ;
#line 109
static int jlink_usb_message___0(libusb_param_t *params , int out_length , int in_length ) ;
#line 110
static int jlink_usb_write___0(libusb_param_t *params , unsigned int out_length ) ;
#line 111
static int jlink_usb_read___0(libusb_param_t *params ) ;
#line 113
static void jlink_debug_buffer___0(char *buffer , int length ) ;
#line 122 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_reset___0(libusb_param_t *params , int trst , int srst ) 
{ 


  {
#line 127
  if (trst == 0) {
    {
#line 129
    jlink_simple_command___0(params, (uint8_t )223);
    }
  } else
#line 131
  if (trst == 1) {
    {
#line 133
    jlink_simple_command___0(params, (uint8_t )222);
    }
  }
#line 136
  if (srst == 0) {
    {
#line 138
    jlink_simple_command___0(params, (uint8_t )221);
    }
  } else
#line 140
  if (srst == 1) {
    {
#line 142
    jlink_simple_command___0(params, (uint8_t )220);
    }
  }
#line 144
  return;
}
}
#line 147 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_simple_command___0(libusb_param_t *params , uint8_t command ) 
{ 
  int result ;
  jlink_usbconn_data_t *data ;

  {
  {
#line 150
  data = (jlink_usbconn_data_t *)params->data;
#line 154
  data->usb_out_buffer[0] = (char )command;
#line 155
  result = jlink_usb_write___0(params, 1U);
  }
#line 157
  if (result != 1) {
    {
#line 159
    printf((char const   */* __restrict  */)"J-Link command 0x%02x failed (%d)\n",
           (int )command, result);
    }
  }
#line 161
  return;
}
}
#line 163 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_get_status___0(libusb_param_t *params ) 
{ 
  int result ;
  jlink_usbconn_data_t *data ;
  int vref ;

  {
  {
#line 166
  data = (jlink_usbconn_data_t *)params->data;
#line 168
  jlink_simple_command___0(params, (uint8_t )7);
#line 170
  result = jlink_usb_read___0(params);
  }
#line 172
  if (result == 8) {
    {
#line 174
    vref = (int )data->usb_in_buffer[0] + ((int )data->usb_in_buffer[1] << 8);
#line 175
    printf((char const   */* __restrict  */)"Vref = %d.%d TCK=%d TDI=%d TDO=%d TMS=%d TRES=%d TRST=%d\n",
           vref / 1000, vref % 1000, (int )data->usb_in_buffer[2], (int )data->usb_in_buffer[3],
           (int )data->usb_in_buffer[4], (int )data->usb_in_buffer[5], (int )data->usb_in_buffer[6],
           (int )data->usb_in_buffer[7]);
    }
#line 183
    if (vref < 1500) {
      {
#line 185
      printf((char const   */* __restrict  */)"Vref too low. Eventually the target isn\'t powered or disconnected?\n");
#line 186
      result = -15;
      }
    }
  } else {
    {
#line 191
    printf((char const   */* __restrict  */)"J-Link command 0x07 (get status) failed (%d)\n",
           result);
    }
  }
#line 194
  return (result);
}
}
#line 200 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_tap_init___0(jlink_usbconn_data_t *data ) 
{ 


  {
#line 202
  data->tap_length = 0;
#line 203
  return;
}
}
#line 205 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_tap_append_step___0(jlink_usbconn_data_t *data , int tms , int tdi ) 
{ 
  int index___0 ;
  int bit_index ;
  uint8_t bit ;

  {
#line 207
  index___0 = data->tap_length >> 3;
#line 209
  if (index___0 < 390) {
#line 211
    bit_index = data->tap_length & 7;
#line 212
    bit = (uint8_t )(1 << bit_index);
#line 214
    if (bit_index == 0) {
#line 216
      data->tms_buffer[index___0] = (uint8_t )0;
#line 217
      data->tdi_buffer[index___0] = (uint8_t )0;
    }
#line 220
    if (tms) {
#line 220
      data->tms_buffer[index___0] = (uint8_t )((int )data->tms_buffer[index___0] | (int )bit);
    }
#line 221
    if (tdi) {
#line 221
      data->tdi_buffer[index___0] = (uint8_t )((int )data->tdi_buffer[index___0] | (int )bit);
    }
#line 223
    (data->tap_length) ++;
  } else {
    {
#line 227
    printf((char const   */* __restrict  */)"jlink_tap_append_step, overflow\n");
    }
  }
#line 229
  return;
}
}
#line 233 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_tap_execute___0(libusb_param_t *params ) 
{ 
  jlink_usbconn_data_t *data ;
  int byte_length ;
  int tms_offset ;
  int tdi_offset ;
  int i ;
  int result ;
  int bit_index ;
  uint8_t bit ;

  {
#line 235
  data = (jlink_usbconn_data_t *)params->data;
#line 242
  if (data->tap_length > 0) {
#line 244
    byte_length = (data->tap_length + 7) >> 3;
#line 245
    data->usb_out_buffer[0] = (char)-51;
#line 246
    data->usb_out_buffer[1] = (char )(data->tap_length & 255);
#line 247
    data->usb_out_buffer[2] = (char )((data->tap_length >> 8) & 255);
#line 249
    tms_offset = 3;
#line 250
    i = 0;
    {
#line 250
    while (1) {
      while_continue: /* CIL Label */ ;
#line 250
      if (! (i < byte_length)) {
#line 250
        goto while_break;
      }
#line 252
      data->usb_out_buffer[tms_offset + i] = (char )data->tms_buffer[i];
#line 250
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 256
    tdi_offset = tms_offset + byte_length;
#line 257
    i = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (i < byte_length)) {
#line 257
        goto while_break___0;
      }
#line 259
      data->usb_out_buffer[tdi_offset + i] = (char )data->tdi_buffer[i];
#line 257
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 263
    result = jlink_usb_message___0(params, 3 + 2 * byte_length, byte_length);
    }
#line 268
    if (result == byte_length) {
#line 270
      bit_index = (data->tap_length - 1) & 7;
#line 271
      bit = (uint8_t )(1 << bit_index);
#line 273
      if ((int )data->usb_in_buffer[byte_length - 1] & (int )bit) {
#line 273
        data->last_tdo = 1;
      } else {
#line 273
        data->last_tdo = 0;
      }
    } else {
      {
#line 278
      printf((char const   */* __restrict  */)"jlink_tap_execute, wrong result %d, expected %d\n",
             result, byte_length);
      }
#line 283
      return (-2);
    }
    {
#line 286
    jlink_tap_init___0(data);
    }
  }
#line 288
  return (0);
}
}
#line 294 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_usb_message___0(libusb_param_t *params , int out_length , int in_length ) 
{ 
  int result ;

  {
  {
#line 301
  result = jlink_usb_write___0(params, (unsigned int )out_length);
  }
#line 302
  if (result == out_length) {
    {
#line 304
    result = jlink_usb_read___0(params);
    }
#line 305
    if (result == in_length) {
#line 307
      return (result);
    } else {
      {
#line 311
      printf((char const   */* __restrict  */)"usb_bulk_read failed (requested=%d, result=%d)\n",
             in_length, result);
      }
#line 316
      return (-1);
    }
  } else {
    {
#line 321
    printf((char const   */* __restrict  */)"usb_bulk_write failed (requested=%d, result=%d)\n",
           out_length, result);
    }
#line 326
    return (-1);
  }
}
}
#line 333 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_usb_write___0(libusb_param_t *params , unsigned int out_length ) 
{ 
  int result ;
  jlink_usbconn_data_t *data ;

  {
#line 338
  data = (jlink_usbconn_data_t *)params->data;
#line 340
  if (out_length > 2064U) {
    {
#line 342
    printf((char const   */* __restrict  */)"jlink_jtag_write illegal out_length=%d (max=%d)\n",
           out_length, 2064);
    }
#line 345
    return (-1);
  }
  {
#line 348
  result = usb_bulk_write(params->handle, 2, (char const   *)(data->usb_out_buffer),
                          (int )out_length, 100);
#line 356
  jlink_debug_buffer___0(data->usb_out_buffer, (int )out_length);
  }
#line 357
  return (result);
}
}
#line 363 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_usb_read___0(libusb_param_t *params ) 
{ 
  jlink_usbconn_data_t *data ;
  int result ;
  int tmp ;

  {
  {
#line 365
  data = (jlink_usbconn_data_t *)params->data;
#line 367
  tmp = usb_bulk_read(params->handle, 129, data->usb_in_buffer, 2064, 100);
#line 367
  result = tmp;
#line 375
  jlink_debug_buffer___0(data->usb_in_buffer, result);
  }
#line 376
  return (result);
}
}
#line 383 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_debug_buffer___0(char *buffer , int length ) 
{ 
  char line[81] ;
  char s[4] ;
  int i ;
  int j ;

  {
#line 390
  i = 0;
  {
#line 390
  while (1) {
    while_continue: /* CIL Label */ ;
#line 390
    if (! (i < length)) {
#line 390
      goto while_break;
    }
    {
#line 392
    snprintf((char */* __restrict  */)(line), (size_t )5, (char const   */* __restrict  */)"%04x",
             i);
#line 393
    j = i;
    }
    {
#line 393
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 393
      if (j < i + 16) {
#line 393
        if (! (j < length)) {
#line 393
          goto while_break___0;
        }
      } else {
#line 393
        goto while_break___0;
      }
      {
#line 395
      snprintf((char */* __restrict  */)(s), (size_t )4, (char const   */* __restrict  */)" %02x",
               (int )*(buffer + j));
#line 396
      strcat((char */* __restrict  */)(line), (char const   */* __restrict  */)(s));
#line 393
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 390
    i += 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 401
  return;
}
}
#line 405 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_init___0(cable_t *cable ) 
{ 
  int result ;
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;
  int tmp ;

  {
  {
#line 412
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 413
  params->data = malloc(sizeof(jlink_usbconn_data_t ));
  }
#line 414
  if ((unsigned long )params->data == (unsigned long )((void *)0)) {
#line 416
    return (-1);
  }
  {
#line 418
  data = (jlink_usbconn_data_t *)params->data;
#line 420
  tmp = usbconn_open(cable->link.usb);
  }
#line 420
  if (tmp) {
#line 420
    return (-1);
  }
  {
#line 422
  jlink_tap_init___0(data);
#line 424
  result = jlink_usb_read___0(params);
  }
#line 426
  if (result != 2) {
    {
#line 429
    printf((char const   */* __restrict  */)"J-Link initial read failed, don\'t worry (result=%d)\n",
           result);
    }
  } else
#line 426
  if ((int )data->usb_in_buffer[0] != 7) {
    {
#line 429
    printf((char const   */* __restrict  */)"J-Link initial read failed, don\'t worry (result=%d)\n",
           result);
    }
  } else
#line 426
  if ((int )data->usb_in_buffer[1] != 0) {
    {
#line 429
    printf((char const   */* __restrict  */)"J-Link initial read failed, don\'t worry (result=%d)\n",
           result);
    }
  }
  {
#line 432
  result = jlink_get_status___0(params);
  }
#line 433
  if (result < 0) {
    {
#line 435
    printf((char const   */* __restrict  */)"Resetting J-Link. Please retry the cable command.\n");
#line 436
    usb_reset(params->handle);
    }
#line 437
    return (-1);
  }
  {
#line 440
  printf((char const   */* __restrict  */)"J-Link JTAG Interface ready\n");
#line 442
  jlink_set_frequency(cable, (uint32_t )4E6);
#line 444
  jlink_reset___0(params, 0, 0);
  }
#line 446
  return (0);
}
}
#line 451 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_free___0(cable_t *cable ) 
{ 
  jlink_usbconn_data_t *data ;

  {
  {
#line 455
  data = (jlink_usbconn_data_t *)((libusb_param_t *)(cable->link.usb)->params)->data;
#line 456
  free((void *)data);
#line 458
  generic_usbconn_free(cable);
  }
#line 459
  return;
}
}
#line 493 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static void jlink_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;

  {
#line 497
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 498
  data = (jlink_usbconn_data_t *)params->data;
#line 500
  i = 0;
  {
#line 500
  while (1) {
    while_continue: /* CIL Label */ ;
#line 500
    if (! (i < n)) {
#line 500
      goto while_break;
    }
    {
#line 502
    jlink_tap_append_step___0(data, tms, tdi);
#line 500
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 504
  jlink_tap_execute___0(params);
  }
#line 505
  return;
}
}
#line 509 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_get_tdo___0(cable_t *cable ) 
{ 
  libusb_param_t *params ;
  jlink_usbconn_data_t *data ;

  {
#line 512
  params = (libusb_param_t *)(cable->link.usb)->params;
#line 513
  data = (jlink_usbconn_data_t *)params->data;
#line 518
  return (data->last_tdo);
}
}
#line 564 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/jlink.c"
static int jlink_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 567
  return (1);
}
}
#line 54 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static int ei012_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 59
  tmp = parport_open(cable->link.port);
  }
#line 59
  if (tmp) {
#line 60
    return (-1);
  }
  {
#line 62
  data = parport_get_data(cable->link.port);
  }
#line 62
  if (data < 0) {
    {
#line 63
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 63
    if (tmp___0) {
#line 64
      return (-1);
    }
#line 65
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 67
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 69
  return (0);
}
}
#line 72 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static void ei012_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 77
  if (tms) {
#line 77
    tms = 1;
  } else {
#line 77
    tms = 0;
  }
#line 78
  if (tdi) {
#line 78
    tdi = 1;
  } else {
#line 78
    tdi = 0;
  }
#line 80
  i = 0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    if (! (i < n)) {
#line 80
      goto while_break;
    }
    {
#line 81
    parport_set_data(cable->link.port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | (tdi << 1)));
#line 82
    cable_wait(cable);
#line 83
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | 1) | (tms << 2)) | (tdi << 1)));
#line 84
    cable_wait(cable);
#line 80
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return;
}
}
#line 88 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static int ei012_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 91
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 92
  cable_wait(cable);
#line 93
  tmp = parport_get_status(cable->link.port);
  }
#line 93
  return ((tmp >> 7) & 1);
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ei012.c"
static int ei012_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 99
  if (trst) {
#line 99
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 99
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 101
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 102
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 52 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static int ea253_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 4));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 65
    ((generic_params_t *)cable->params)->trst = (data >> 4) & 1;
  }
#line 67
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static void ea253_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 4) | (tms << 2)) | tdi));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static int ea253_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 89
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
#line 90
  cable_wait(cable);
#line 91
  tmp = parport_get_status(cable->link.port);
  }
#line 91
  return ((tmp >> 4) & 1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/ea253.c"
static int ea253_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 97
  if (trst) {
#line 97
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 97
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 99
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 4));
  }
#line 100
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static int dlc5_init___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 62
  tmp = parport_open(cable->link.port);
  }
#line 62
  if (tmp) {
#line 63
    return (-1);
  }
#line 65
  ((generic_params_t *)cable->params)->trst = 1;
#line 67
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static void dlc5_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((1 << 4) | (tms << 2)) | tdi));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((1 << 4) | (1 << 1)) | (tms << 2)) | tdi));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static int dlc5_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 89
  parport_set_data(cable->link.port, (uint8_t )(1 << 4));
#line 90
  cable_wait(cable);
#line 91
  tmp = parport_get_status(cable->link.port);
  }
#line 91
  return ((tmp >> 4) & 1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/dlc5.c"
static int dlc5_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 97
  return (1);
}
}
#line 105 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static port_node_t *ports___2  =    (port_node_t *)((void *)0);
#line 111 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static parport_t *direct_parport_alloc___0(unsigned int port ) 
{ 
  direct_params_t *params ;
  void *tmp ;
  parport_t *parport ;
  void *tmp___0 ;
  port_node_t *node ;
  void *tmp___1 ;

  {
  {
#line 114
  tmp = malloc(sizeof(*params));
#line 114
  params = (direct_params_t *)tmp;
#line 115
  tmp___0 = malloc(sizeof(*parport));
#line 115
  parport = (parport_t *)tmp___0;
#line 116
  tmp___1 = malloc(sizeof(*node));
#line 116
  node = (port_node_t *)tmp___1;
  }
#line 118
  if (! node) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! parport) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  } else
#line 118
  if (! params) {
    {
#line 119
    free((void *)node);
#line 120
    free((void *)parport);
#line 121
    free((void *)params);
    }
#line 122
    return ((parport_t *)((void *)0));
  }
#line 125
  params->port = port;
#line 127
  parport->params = (void *)params;
#line 128
  parport->driver = & direct_parport_driver;
#line 129
  parport->cable = (cable_t *)((void *)0);
#line 131
  node->port = parport;
#line 132
  node->next = ports___2;
#line 134
  ports___2 = node;
#line 136
  return (parport);
}
}
#line 139 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static void direct_parport_free___0(parport_t *port ) 
{ 
  port_node_t **prev ;
  port_node_t *pn ;

  {
#line 144
  prev = & ports___2;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! *prev) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )(*prev)->port == (unsigned long )port) {
#line 146
      goto while_break;
    }
#line 144
    prev = & (*prev)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  if (*prev) {
    {
#line 149
    pn = *prev;
#line 150
    *prev = pn->next;
#line 151
    free((void *)pn);
    }
  }
  {
#line 154
  free(port->params);
#line 155
  free((void *)port);
  }
#line 156
  return;
}
}
#line 203 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_open___0(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 206
  port = ((direct_params_t *)parport->params)->port;
#line 207
  if (port + 3U <= 1024U) {
    {
#line 207
    tmp = ioperm((unsigned long )port, 3UL, 1);
    }
#line 207
    if (tmp) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 207
  if (port + 3U > 1024U) {
    {
#line 207
    tmp___0 = iopl(3);
    }
#line 207
    if (tmp___0) {
#line 207
      tmp___1 = 1;
    } else {
#line 207
      tmp___1 = 0;
    }
  } else {
#line 207
    tmp___1 = 0;
  }
#line 207
  return (tmp___1);
}
}
#line 210 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_close___0(parport_t *parport ) 
{ 
  unsigned int port ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 213
  port = ((direct_params_t *)parport->params)->port;
#line 214
  if (port + 3U <= 1024U) {
    {
#line 214
    tmp = ioperm((unsigned long )port, 3UL, 0);
#line 214
    tmp___1 = tmp;
    }
  } else {
    {
#line 214
    tmp___0 = iopl(0);
#line 214
    tmp___1 = tmp___0;
    }
  }
#line 214
  return (tmp___1);
}
}
#line 217 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_set_data___0(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 220
  port = ((direct_params_t *)parport->params)->port;
#line 221
  outb(data, (unsigned short )port);
  }
#line 222
  return (0);
}
}
#line 225 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_get_data___0(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 228
  port = ((direct_params_t *)parport->params)->port;
#line 229
  tmp = inb((unsigned short )port);
  }
#line 229
  return ((int )tmp);
}
}
#line 232 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_get_status___0(parport_t *parport ) 
{ 
  unsigned int port ;
  unsigned char tmp ;

  {
  {
#line 235
  port = ((direct_params_t *)parport->params)->port;
#line 236
  tmp = inb((unsigned short )(port + 1U));
  }
#line 236
  return ((int )tmp ^ 128);
}
}
#line 239 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/parport/direct.c"
static int direct_set_control___0(parport_t *parport , uint8_t data ) 
{ 
  unsigned int port ;

  {
  {
#line 242
  port = ((direct_params_t *)parport->params)->port;
#line 243
  outb((unsigned char )((int )data ^ 11), (unsigned short )(port + 2U));
  }
#line 244
  return (0);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/detect.c"
static int find_record___0(char *filename , tap_register *key , struct id_record *idr ) 
{ 
  FILE *file ;
  tap_register *tr ;
  int r ;
  char *tmp ;
  char *p ;
  char *s ;
  char line[1024] ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 54
  r = 0;
#line 56
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 57
  if (! file) {
    {
#line 58
    tmp = gettext("Cannot open %s\n");
#line 58
    printf((char const   */* __restrict  */)tmp, filename);
    }
#line 59
    return (0);
  }
  {
#line 62
  tr = register_alloc(key->len);
  }
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp___0 = fgets((char */* __restrict  */)(line), 1024, (FILE */* __restrict  */)file);
    }
#line 69
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 70
      goto while_break;
    }
    {
#line 73
    p = strpbrk((char const   *)(line), "#\n");
    }
#line 74
    if (p) {
#line 75
      *p = (char )'\000';
    }
#line 77
    p = line;
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (*p) {
        {
#line 80
        tmp___1 = __ctype_b_loc();
        }
#line 80
        if (! ((int const   )*(*tmp___1 + (int )*p) & 8192)) {
#line 80
          goto while_break___0;
        }
      } else {
#line 80
        goto while_break___0;
      }
#line 81
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 84
    s = strchr((char const   *)p, '\000');
    }
    {
#line 85
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 85
      if (! ((unsigned long )s != (unsigned long )p)) {
#line 85
        goto while_break___1;
      }
      {
#line 86
      tmp___2 = __ctype_b_loc();
#line 86
      s --;
      }
#line 86
      if (! ((int const   )*(*tmp___2 + (int )*s) & 8192)) {
#line 87
        goto while_break___1;
      }
#line 88
      *s = (char )'\000';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 92
    if (! *p) {
#line 93
      goto __Cont;
    }
#line 96
    s = p;
    {
#line 97
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 97
      if (*s) {
        {
#line 97
        tmp___3 = __ctype_b_loc();
        }
#line 97
        if ((int const   )*(*tmp___3 + (int )*s) & 8192) {
#line 97
          goto while_break___2;
        }
      } else {
#line 97
        goto while_break___2;
      }
#line 98
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 99
    if (*s) {
#line 100
      tmp___4 = s;
#line 100
      s ++;
#line 100
      *tmp___4 = (char )'\000';
    }
    {
#line 103
    tmp___5 = strlen((char const   *)p);
    }
#line 103
    if (tmp___5 != (size_t )key->len) {
#line 104
      goto __Cont;
    }
    {
#line 107
    register_init(tr, (char const   *)p);
#line 108
    tmp___6 = register_compare((tap_register const   *)tr, (tap_register const   *)key);
    }
#line 108
    if (tmp___6) {
#line 109
      goto __Cont;
    }
#line 112
    p = s;
    {
#line 115
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 115
      if (*p) {
        {
#line 115
        tmp___7 = __ctype_b_loc();
        }
#line 115
        if (! ((int const   )*(*tmp___7 + (int )*p) & 8192)) {
#line 115
          goto while_break___3;
        }
      } else {
#line 115
        goto while_break___3;
      }
#line 116
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 119
    if (! *p) {
#line 120
      goto __Cont;
    }
#line 123
    s = p;
    {
#line 124
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 124
      if (*s) {
        {
#line 124
        tmp___8 = __ctype_b_loc();
        }
#line 124
        if ((int const   )*(*tmp___8 + (int )*s) & 8192) {
#line 124
          goto while_break___4;
        }
      } else {
#line 124
        goto while_break___4;
      }
#line 125
      s ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 126
    if (*s) {
#line 127
      tmp___9 = s;
#line 127
      s ++;
#line 127
      *tmp___9 = (char )'\000';
    }
    {
#line 130
    tmp___10 = strlen((char const   *)p);
    }
#line 130
    if (tmp___10 >= sizeof(idr->name)) {
#line 131
      goto __Cont;
    }
    {
#line 134
    strcpy((char */* __restrict  */)(idr->name), (char const   */* __restrict  */)p);
#line 137
    p = s;
    }
    {
#line 140
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 140
      if (*p) {
        {
#line 140
        tmp___11 = __ctype_b_loc();
        }
#line 140
        if (! ((int const   )*(*tmp___11 + (int )*p) & 8192)) {
#line 140
          goto while_break___5;
        }
      } else {
#line 140
        goto while_break___5;
      }
#line 141
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 144
    if (! *p) {
#line 145
      goto __Cont;
    }
    {
#line 148
    tmp___12 = strlen((char const   *)p);
    }
#line 148
    if (tmp___12 >= sizeof(idr->fullname)) {
#line 149
      goto __Cont;
    }
    {
#line 152
    strcpy((char */* __restrict  */)(idr->fullname), (char const   */* __restrict  */)p);
#line 154
    r = 1;
    }
#line 155
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 158
  fclose(file);
#line 160
  register_free(tr);
  }
#line 162
  return (r);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/cmd_xfer.c"
static int extend_cmd_buffer___0(cx_cmd_t *cmd ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 53
  if (cmd->buf_pos >= cmd->buf_len) {
#line 55
    cmd->buf_len *= 2U;
#line 56
    if (cmd->buf) {
      {
#line 57
      tmp = realloc((void *)cmd->buf, (size_t )cmd->buf_len);
#line 57
      cmd->buf = (uint8_t *)tmp;
      }
    }
  }
#line 60
  if (cmd->buf) {
#line 60
    tmp___0 = 1;
  } else {
#line 60
    tmp___0 = 0;
  }
#line 60
  return (tmp___0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static int byteblaster_init___0(cable_t *cable ) 
{ 
  int BB_II ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 73
  BB_II = 0;
#line 75
  tmp = parport_open(cable->link.port);
  }
#line 75
  if (tmp) {
#line 76
    return (-1);
  }
  {
#line 78
  ((generic_params_t *)cable->params)->trst = 1;
#line 81
  parport_set_data(cable->link.port, (uint8_t )(1 << 5));
#line 82
  tmp___0 = parport_get_status(cable->link.port);
  }
#line 82
  if (! ((tmp___0 >> 6) & 1)) {
#line 83
    BB_II = 1;
  }
  {
#line 84
  parport_set_data(cable->link.port, (uint8_t )0);
#line 85
  tmp___1 = parport_get_status(cable->link.port);
  }
#line 85
  if ((tmp___1 >> 6) & 1) {
#line 86
    BB_II = 1;
  }
#line 90
  if (BB_II) {
    {
#line 90
    tmp___2 = parport_get_status(cable->link.port);
    }
#line 90
    if ((tmp___2 >> 3) & 1) {
#line 91
      return (-1);
    }
  }
  {
#line 94
  parport_set_control(cable->link.port, (uint8_t )12);
  }
#line 96
  return (0);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static void byteblaster_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 104
  if (tms) {
#line 104
    tms = 1;
  } else {
#line 104
    tms = 0;
  }
#line 105
  if (tdi) {
#line 105
    tdi = 1;
  } else {
#line 105
    tdi = 0;
  }
#line 107
  i = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (! (i < n)) {
#line 107
      goto while_break;
    }
    {
#line 108
    parport_set_data(cable->link.port, (uint8_t )((tms << 1) | (tdi << 6)));
#line 109
    cable_wait(cable);
#line 110
    parport_set_data(cable->link.port, (uint8_t )((1 | (tms << 1)) | (tdi << 6)));
#line 111
    cable_wait(cable);
#line 107
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static int byteblaster_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 118
  parport_set_data(cable->link.port, (uint8_t )0);
#line 119
  cable_wait(cable);
#line 120
  tmp = parport_get_status(cable->link.port);
  }
#line 120
  return ((tmp >> 7) & 1);
}
}
#line 123 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/byteblaster.c"
static int byteblaster_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 126
  return (1);
}
}
#line 52 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static int arcom_init___0(cable_t *cable ) 
{ 
  int data ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 57
  tmp = parport_open(cable->link.port);
  }
#line 57
  if (tmp) {
#line 58
    return (-1);
  }
  {
#line 60
  data = parport_get_data(cable->link.port);
  }
#line 60
  if (data < 0) {
    {
#line 61
    tmp___0 = parport_set_data(cable->link.port, (uint8_t )(1 << 3));
    }
#line 61
    if (tmp___0) {
#line 62
      return (-1);
    }
#line 63
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 65
    ((generic_params_t *)cable->params)->trst = (data >> 3) & 1;
  }
#line 67
  return (0);
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static void arcom_clock___0(cable_t *cable , int tms , int tdi , int n ) 
{ 
  int i ;

  {
#line 75
  if (tms) {
#line 75
    tms = 1;
  } else {
#line 75
    tms = 0;
  }
#line 76
  if (tdi) {
#line 76
    tdi = 1;
  } else {
#line 76
    tdi = 0;
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < n)) {
#line 78
      goto while_break;
    }
    {
#line 79
    parport_set_data(cable->link.port, (uint8_t )(((((generic_params_t *)cable->params)->trst << 3) | (tms << 2)) | (tdi << 1)));
#line 80
    cable_wait(cable);
#line 81
    parport_set_data(cable->link.port, (uint8_t )((((((generic_params_t *)cable->params)->trst << 3) | 1) | (tms << 2)) | (tdi << 1)));
#line 82
    cable_wait(cable);
#line 78
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return;
}
}
#line 86 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static int arcom_get_tdo___0(cable_t *cable ) 
{ 
  int tmp ;

  {
  {
#line 89
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
#line 90
  cable_wait(cable);
#line 91
  tmp = parport_get_status(cable->link.port);
  }
#line 91
  return ((tmp >> 7) & 1);
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/tap/cable/arcom.c"
static int arcom_set_trst___0(cable_t *cable , int trst ) 
{ 


  {
#line 97
  if (trst) {
#line 97
    ((generic_params_t *)cable->params)->trst = 1;
  } else {
#line 97
    ((generic_params_t *)cable->params)->trst = 0;
  }
  {
#line 99
  parport_set_data(cable->link.port, (uint8_t )(((generic_params_t *)cable->params)->trst << 3));
  }
#line 100
  return (((generic_params_t *)cable->params)->trst);
}
}
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/writemem.c"
static int cmd_writemem_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 4) {
#line 40
    return (-1);
  }
#line 42
  if (! bus) {
    {
#line 43
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 43
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 44
    return (1);
  }
  {
#line 47
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 47
  if (tmp___1) {
#line 48
    return (-1);
  } else {
    {
#line 47
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 47
    if (tmp___2) {
#line 48
      return (-1);
    }
  }
  {
#line 50
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"r");
  }
#line 51
  if (! f) {
    {
#line 52
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 52
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 53
    return (1);
  }
  {
#line 55
  writemem(bus, f, adr, len);
#line 56
  fclose(f);
  }
#line 58
  return (1);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/writemem.c"
static void cmd_writemem_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nWrite to device memory starting at ADDR the FILENAME file.\n\nADDR       start address of the written memory area\nLEN        written memory length\nFILENAME   name of the input file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\nNOTE: This is NOT useful for FLASH programming!\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "writemem");
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/writemem.c"
cmd_t cmd_writemem  =    {(char *)"writemem", (char *)"write content of file to the memory", & cmd_writemem_help,
    & cmd_writemem_run};
#line 52 "../../include/cmd.h"
int cmd_test_cable(chain_t *chain ) ;
#line 37 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/test.c"
static int cmd_test_run(chain_t *chain , char **params ) 
{ 
  int data ;
  unsigned int i ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 44
  tmp = cmd_params(params);
  }
#line 44
  if (tmp != 4) {
#line 45
    return (-1);
  }
  {
#line 47
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 47
  if (tmp___0 != 0) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___1 = cmd_test_cable(chain);
  }
#line 50
  if (! tmp___1) {
#line 51
    return (1);
  }
#line 53
  if (! chain->parts) {
    {
#line 54
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 55
    return (1);
  }
#line 58
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 59
    tmp___3 = gettext("%s: no active part\n");
#line 59
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 60
    return (1);
  }
  {
#line 63
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 64
  if (! s) {
    {
#line 65
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 66
    return (1);
  }
  {
#line 72
  tmp___5 = cmd_get_number(*(params + 3), & i);
  }
#line 72
  if (tmp___5) {
#line 73
    return (1);
  }
  {
#line 75
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 76
  if (data != -1) {
#line 77
    if ((unsigned int )data != i) {
      {
#line 78
      tmp___6 = gettext("<FAIL>%s = %d\n");
#line 78
      printf((char const   */* __restrict  */)tmp___6, *(params + 2), data);
      }
#line 79
      return (-99);
    }
  }
#line 82
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/test.c"
static void cmd_test_help(void) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL 0/1\nTest signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/test.c"
cmd_t cmd_test  =    {(char *)"test", (char *)"test external signal value", & cmd_test_help, & cmd_test_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/svf.c"
static int cmd_svf_run(chain_t *chain , char **params ) 
{ 
  FILE *SVF_FILE ;
  int num_params ;
  int i ;
  int result ;
  int stop ;
  int print_progress ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 38
  result = -1;
#line 39
  stop = 0;
#line 40
  print_progress = 0;
#line 42
  num_params = cmd_params(params);
  }
#line 43
  if (num_params > 1) {
#line 44
    i = 2;
    {
#line 44
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      if (! (i < num_params)) {
#line 44
        goto while_break;
      }
      {
#line 45
      tmp___0 = strcasecmp((char const   *)*(params + i), "stop");
      }
#line 45
      if (tmp___0 == 0) {
#line 46
        stop = 1;
      } else {
        {
#line 47
        tmp = strcasecmp((char const   *)*(params + i), "progress");
        }
#line 47
        if (tmp == 0) {
#line 48
          print_progress = 1;
        } else {
#line 50
          return (-1);
        }
      }
#line 44
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 53
    SVF_FILE = fopen((char const   */* __restrict  */)*(params + 1), (char const   */* __restrict  */)"r");
    }
#line 53
    if ((unsigned long )SVF_FILE != (unsigned long )((void *)0)) {
      {
#line 54
      svf_run(chain, SVF_FILE, stop, print_progress);
#line 55
      result = 1;
#line 57
      fclose(SVF_FILE);
      }
    } else {
      {
#line 59
      tmp___1 = gettext("%s: cannot open file \'%s\' for reading\n");
#line 59
      printf((char const   */* __restrict  */)tmp___1, "svf", *(params + 1));
      }
    }
  }
#line 64
  return (result);
}
}
#line 68 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/svf.c"
static void cmd_svf_help(void) 
{ 
  char *tmp ;

  {
  {
#line 71
  tmp = gettext("Usage: %s FILE [stop] [progress]\nExecute svf commands from FILE.\nstop     : Command execution stops upon TDO mismatch.\nprogress : Continually displays progress status.\n\nFILE file containing SVF commans\n");
#line 71
  printf((char const   */* __restrict  */)tmp, "svf");
  }
#line 79
  return;
}
}
#line 81 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/svf.c"
cmd_t cmd_svf  =    {(char *)"svf", (char *)"execute svf commands from file", & cmd_svf_help, & cmd_svf_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/signal.c"
static int cmd_signal_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  signal_t *s ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 42
  i = cmd_params(params);
  }
#line 42
  if (i < 2) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable(chain);
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "signal");
    }
#line 56
    return (1);
  }
  {
#line 59
  part = *((chain->parts)->parts + chain->active_part);
#line 60
  s = part_find_signal(part, (char const   *)*(params + 1));
  }
#line 60
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 61
    if (i == 3) {
      {
#line 62
      printf((char const   */* __restrict  */)"Defining pin for signal %s\n", s->name);
      }
#line 64
      if (s->pin) {
        {
#line 64
        free((void *)s->pin);
        }
      }
      {
#line 67
      tmp___2 = strlen((char const   *)*(params + 2));
#line 67
      tmp___3 = malloc(tmp___2 + 1UL);
#line 67
      s->pin = (char *)tmp___3;
#line 68
      strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
      }
#line 70
      return (1);
    } else {
      {
#line 73
      tmp___4 = gettext("Signal \'%s\' already defined\n");
#line 73
      printf((char const   */* __restrict  */)tmp___4, *(params + 1));
      }
#line 74
      return (1);
    }
  }
  {
#line 78
  s = signal_alloc((char const   *)*(params + 1));
  }
#line 80
  if (i == 3) {
    {
#line 82
    tmp___5 = strlen((char const   *)*(params + 2));
#line 82
    tmp___6 = malloc(tmp___5 + 1UL);
#line 82
    s->pin = (char *)tmp___6;
#line 83
    strcpy((char */* __restrict  */)s->pin, (char const   */* __restrict  */)*(params + 2));
    }
  }
#line 87
  if (! s) {
    {
#line 88
    tmp___7 = gettext("out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___7);
    }
#line 89
    return (1);
  }
#line 92
  s->next = part->signals;
#line 93
  part->signals = s;
#line 95
  return (1);
}
}
#line 98 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/signal.c"
static void cmd_signal_help(void) 
{ 
  char *tmp ;

  {
  {
#line 101
  tmp = gettext("Usage: %s SIGNAL [PIN#]\nDefine new signal with name SIGNAL for a part.\n\nSIGNAL\t\tNew signal name\nPIN#   \tList of pin # for a signal\n");
#line 101
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 108
  return;
}
}
#line 110 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/signal.c"
cmd_t cmd_signal  =    {(char *)"signal", (char *)"define new signal for a part", & cmd_signal_help, & cmd_signal_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/shift.c"
static int cmd_shift_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 38
  tmp = cmd_params(params);
  }
#line 38
  if (tmp != 2) {
#line 39
    return (-1);
  }
  {
#line 41
  tmp___0 = cmd_test_cable(chain);
  }
#line 41
  if (! tmp___0) {
#line 42
    return (1);
  }
  {
#line 44
  tmp___1 = strcasecmp((char const   *)*(params + 1), "ir");
  }
#line 44
  if (tmp___1 == 0) {
    {
#line 45
    chain_shift_instructions(chain);
    }
#line 46
    return (1);
  }
  {
#line 48
  tmp___2 = strcasecmp((char const   *)*(params + 1), "dr");
  }
#line 48
  if (tmp___2 == 0) {
    {
#line 49
    chain_shift_data_registers(chain, 1);
    }
#line 50
    return (1);
  }
#line 53
  return (-1);
}
}
#line 56 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/shift.c"
static void cmd_shift_help(void) 
{ 
  char *tmp ;

  {
  {
#line 59
  tmp = gettext("Usage: %s\nUsage: %s\nShift instruction or data register through JTAG chain.\n");
#line 59
  printf((char const   */* __restrict  */)tmp, "shift ir", "shift dr");
  }
#line 64
  return;
}
}
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/shift.c"
cmd_t cmd_shift  =    {(char *)"shift", (char *)"shift data/instruction registers through JTAG chain",
    & cmd_shift_help, & cmd_shift_run};
#line 781 "/usr/include/stdlib.h"
extern int system(char const   *__command ) ;
#line 39 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/shell.c"
static int cmd_shell_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int len ;
  int n ;
  int tmp ;
  char *shell_cmd ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 42
  tmp = cmd_params(params);
#line 42
  n = tmp;
#line 45
  n = cmd_params(params);
  }
#line 45
  if (n == 1) {
#line 46
    return (-1);
  }
#line 57
  i = 1;
#line 57
  len = 0;
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! (i < n)) {
#line 57
      goto while_break;
    }
    {
#line 57
    tmp___0 = strlen((char const   *)*(params + i));
#line 57
    len = (int )((size_t )len + (1UL + tmp___0));
#line 57
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 59
  tmp___1 = malloc((size_t )len);
#line 59
  shell_cmd = (char *)tmp___1;
  }
#line 60
  if ((unsigned long )shell_cmd == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___2 = gettext("Out of memory\n");
#line 62
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 63
    return (-1);
  }
  {
#line 66
  strcpy((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + 1));
#line 67
  i = 2;
  }
  {
#line 67
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 67
    if (! (i < n)) {
#line 67
      goto while_break___0;
    }
    {
#line 69
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)" ");
#line 70
    strcat((char */* __restrict  */)shell_cmd, (char const   */* __restrict  */)*(params + i));
#line 67
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 72
  printf((char const   */* __restrict  */)"Executing \'%s\'\n", shell_cmd);
#line 74
  system((char const   *)shell_cmd);
#line 75
  free((void *)shell_cmd);
  }
#line 77
  return (1);
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/shell.c"
static void cmd_shell_help(void) 
{ 
  char *tmp ;

  {
  {
#line 83
  tmp = gettext("Usage: %s cmmd\nShell out to os for a command.\n\nCMMD OS Shell Command\n");
#line 83
  printf((char const   */* __restrict  */)tmp, "shell cmmd");
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/shell.c"
cmd_t cmd_shell  =    {(char *)"shell", (char *)"shell cmmd", & cmd_shell_help, & cmd_shell_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/set.c"
static int cmd_set_run(chain_t *chain , char **params ) 
{ 
  int dir ;
  unsigned int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 40
  data = 0U;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp < 4) {
#line 44
    return (-1);
  } else {
    {
#line 43
    tmp___0 = cmd_params(params);
    }
#line 43
    if (tmp___0 > 5) {
#line 44
      return (-1);
    }
  }
  {
#line 46
  tmp___1 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 46
  if (tmp___1 != 0) {
#line 47
    return (-1);
  }
  {
#line 49
  tmp___2 = cmd_test_cable(chain);
  }
#line 49
  if (! tmp___2) {
#line 50
    return (1);
  }
#line 52
  if (! chain->parts) {
    {
#line 53
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 54
    return (1);
  }
#line 57
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 58
    tmp___4 = gettext("%s: no active part\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "set");
    }
#line 59
    return (1);
  }
  {
#line 63
  tmp___5 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 63
  if (tmp___5 != 0) {
    {
#line 63
    tmp___6 = strcasecmp((char const   *)*(params + 3), "out");
    }
#line 63
    if (tmp___6 != 0) {
#line 64
      return (-1);
    }
  }
  {
#line 66
  tmp___8 = strcasecmp((char const   *)*(params + 3), "in");
  }
#line 66
  if (tmp___8 == 0) {
#line 66
    dir = 0;
  } else {
#line 66
    dir = 1;
  }
#line 68
  if (dir) {
    {
#line 69
    tmp___9 = cmd_get_number(*(params + 4), & data);
    }
#line 69
    if (tmp___9) {
#line 70
      return (-1);
    }
#line 71
    if (data > 1U) {
#line 72
      return (-1);
    }
  }
  {
#line 75
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 76
  if (! s) {
    {
#line 77
    tmp___10 = gettext("signal \'%s\' not found\n");
#line 77
    printf((char const   */* __restrict  */)tmp___10, *(params + 2));
    }
#line 78
    return (1);
  }
  {
#line 80
  part_set_signal(*((chain->parts)->parts + chain->active_part), s, dir, (int )data);
  }
#line 82
  return (1);
}
}
#line 85 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/set.c"
static void cmd_set_help(void) 
{ 
  char *tmp ;

  {
  {
#line 88
  tmp = gettext("Usage: %s SIGNAL DIR [DATA]\nSet signal state in input BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\nDIR           requested signal direction; possible values: \'in\' or \'out\'\nDATA          desired output signal value (\'0\' or \'1\'); used only if DIR\n                is \'out\'\n");
#line 88
  printf((char const   */* __restrict  */)tmp, "set signal");
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/set.c"
cmd_t cmd_set  =    {(char *)"set", (char *)"set external signal value", & cmd_set_help, & cmd_set_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/scan.c"
static int cmd_scan_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  data_register *bsr ;
  tap_register *obsr ;
  int i ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  instruction *tmp___4 ;
  instruction *tmp___5 ;
  char *tmp___6 ;
  signal_t *s ;
  char const   *tmp___7 ;
  int old ;
  int new ;
  salias_t *a ;
  char *tmp___8 ;

  {
  {
#line 43
  i = cmd_params(params);
  }
#line 43
  if (i < 1) {
#line 44
    return (-1);
  }
  {
#line 46
  tmp = cmd_test_cable(chain);
  }
#line 46
  if (! tmp) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___1 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___1, "scan");
    }
#line 56
    return (1);
  }
  {
#line 59
  part = *((chain->parts)->parts + chain->active_part);
#line 62
  bsr = part_find_data_register(part, "BSR");
  }
#line 63
  if (! bsr) {
    {
#line 64
    tmp___2 = gettext("%s(%s:%d) Boundary Scan Register (BSR) not found\n");
#line 64
    printf((char const   */* __restrict  */)tmp___2, "cmd_scan_run", "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/scan.c",
           64);
    }
#line 65
    return (1);
  }
  {
#line 68
  tmp___5 = part_find_instruction(part, "SAMPLE");
  }
#line 68
  if (tmp___5) {
    {
#line 70
    part_set_instruction(part, "SAMPLE");
    }
  } else {
    {
#line 72
    tmp___4 = part_find_instruction(part, "SAMPLE/PRELOAD");
    }
#line 72
    if (tmp___4) {
      {
#line 74
      part_set_instruction(part, "SAMPLE/PRELOAD");
      }
    } else {
      {
#line 78
      tmp___3 = gettext("%s(%s:%d) Part can\'t SAMPLE\n");
#line 78
      printf((char const   */* __restrict  */)tmp___3, "cmd_scan_run", "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/scan.c",
             78);
      }
#line 79
      return (1);
    }
  }
  {
#line 82
  chain_shift_instructions(chain);
#line 84
  obsr = register_alloc((bsr->out)->len);
  }
#line 86
  if (! obsr) {
    {
#line 88
    tmp___6 = gettext("Out of memory\n");
#line 88
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 89
    return (1);
  }
  {
#line 95
  tmp___7 = register_get_string((tap_register const   *)bsr->out);
#line 95
  register_init(obsr, tmp___7);
#line 97
  chain_shift_data_registers(chain, 1);
#line 99
  s = part->signals;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! s) {
#line 99
      goto while_break;
    }
#line 101
    if ((unsigned long )s->input != (unsigned long )((void *)0)) {
#line 103
      old = (int )*(obsr->data + (s->input)->bit);
#line 104
      new = (int )*((bsr->out)->data + (s->input)->bit);
#line 105
      if (old != new) {
        {
#line 108
        printf((char const   */* __restrict  */)"%s", s->name);
#line 109
        a = part->saliases;
        }
        {
#line 109
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 109
          if (! a) {
#line 109
            goto while_break___0;
          }
#line 111
          if ((unsigned long )a->signal == (unsigned long )s) {
            {
#line 111
            printf((char const   */* __restrict  */)",%s", a->name);
            }
          }
#line 109
          a = a->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 113
        tmp___8 = gettext(": %d > %d\n");
#line 113
        printf((char const   */* __restrict  */)tmp___8, old, new);
        }
      }
    }
#line 99
    s = s->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 119
  register_free(obsr);
  }
#line 121
  return (1);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/scan.c"
static void cmd_scan_help(void) 
{ 
  char *tmp ;

  {
  {
#line 127
  tmp = gettext("Usage: %s [SIGNAL]* \nRead BSR and show changes since last scan.\n");
#line 127
  printf((char const   */* __restrict  */)tmp, "scan");
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/scan.c"
cmd_t cmd_scan  =    {(char *)"scan", (char *)"read BSR and show changes since last scan", & cmd_scan_help,
    & cmd_scan_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/salias.c"
static int cmd_salias_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  signal_t *s ;
  salias_t *sa ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  signal_t *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable(chain);
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
#line 48
  if (! chain->parts) {
    {
#line 49
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 50
    return (1);
  }
#line 53
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 54
    tmp___2 = gettext("%s: no active part\n");
#line 54
    printf((char const   */* __restrict  */)tmp___2, "signal");
    }
#line 55
    return (1);
  }
  {
#line 58
  part = *((chain->parts)->parts + chain->active_part);
#line 59
  tmp___4 = part_find_signal(part, (char const   *)*(params + 1));
  }
#line 59
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
    {
#line 60
    tmp___3 = gettext("Signal \'%s\' already defined\n");
#line 60
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 61
    return (1);
  }
  {
#line 64
  s = part_find_signal(part, (char const   *)*(params + 2));
  }
#line 65
  if ((unsigned long )s == (unsigned long )((void *)0)) {
    {
#line 66
    tmp___5 = gettext("Signal \'%s\' not found\n");
#line 66
    printf((char const   */* __restrict  */)tmp___5, *(params + 2));
    }
#line 67
    return (1);
  }
  {
#line 70
  sa = salias_alloc((char const   *)*(params + 1), (signal_t const   *)s);
  }
#line 71
  if (! sa) {
    {
#line 72
    tmp___6 = gettext("out of memory\n");
#line 72
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 73
    return (1);
  }
#line 76
  sa->next = part->saliases;
#line 77
  part->saliases = sa;
#line 79
  return (1);
}
}
#line 82 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/salias.c"
static void cmd_salias_help(void) 
{ 
  char *tmp ;

  {
  {
#line 85
  tmp = gettext("Usage: %s ALIAS SIGNAL\nDefine new signal ALIAS as alias for existing SIGNAL.\n\nALIAS         New signal alias name\nSIGNAL        Existing signal name\n");
#line 85
  printf((char const   */* __restrict  */)tmp, "signal");
  }
#line 92
  return;
}
}
#line 94 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/salias.c"
struct __anonstruct_cmd_t_148900231  const  cmd_salias  =    {(char *)"salias", (char *)"define an alias for a signal", & cmd_salias_help, & cmd_salias_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/reset.c"
static int cmd_reset_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 38
  tmp = cmd_params(params);
  }
#line 38
  if (tmp > 1) {
#line 39
    return (-1);
  }
  {
#line 41
  tmp___0 = cmd_test_cable(chain);
  }
#line 41
  if (! tmp___0) {
#line 42
    return (1);
  }
  {
#line 44
  tap_reset_bypass(chain);
  }
#line 46
  return (1);
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/reset.c"
static void cmd_reset_help(void) 
{ 
  char *tmp ;

  {
  {
#line 52
  tmp = gettext("Usage: %s\nReset current JTAG chain.\n");
#line 52
  printf((char const   */* __restrict  */)tmp, "reset");
  }
#line 56
  return;
}
}
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/reset.c"
cmd_t cmd_reset  =    {(char *)"reset", (char *)"reset JTAG chain", & cmd_reset_help, & cmd_reset_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/register.c"
static int cmd_register_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  unsigned int len ;
  data_register *dr ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  data_register *tmp___5 ;
  char *tmp___6 ;
  int i ;
  void *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 46
  tmp___0 = cmd_test_cable(chain);
  }
#line 46
  if (! tmp___0) {
#line 47
    return (1);
  }
#line 49
  if (! chain->parts) {
    {
#line 50
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 50
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 51
    return (1);
  }
#line 54
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 55
    tmp___2 = gettext("%s: no active part\n");
#line 55
    printf((char const   */* __restrict  */)tmp___2, "register");
    }
#line 56
    return (1);
  }
  {
#line 59
  tmp___3 = cmd_get_number(*(params + 2), & len);
  }
#line 59
  if (tmp___3) {
#line 60
    return (-1);
  }
  {
#line 62
  part = *((chain->parts)->parts + chain->active_part);
#line 64
  tmp___5 = part_find_data_register(part, (char const   *)*(params + 1));
  }
#line 64
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
    {
#line 65
    tmp___4 = gettext("Data register \'%s\' already defined\n");
#line 65
    printf((char const   */* __restrict  */)tmp___4, *(params + 1));
    }
#line 66
    return (1);
  }
  {
#line 69
  dr = data_register_alloc((char const   *)*(params + 1), (int )len);
  }
#line 70
  if (! dr) {
    {
#line 71
    tmp___6 = gettext("out of memory\n");
#line 71
    printf((char const   */* __restrict  */)tmp___6);
    }
#line 72
    return (1);
  }
  {
#line 75
  dr->next = part->data_registers;
#line 76
  part->data_registers = dr;
#line 79
  tmp___9 = strcasecmp((char const   *)(dr->name), "BSR");
  }
#line 79
  if (tmp___9 == 0) {
    {
#line 82
    part->boundary_length = (int )len;
#line 83
    tmp___7 = malloc((unsigned long )part->boundary_length * sizeof(*(part->bsbits)));
#line 83
    part->bsbits = (bsbit_t **)tmp___7;
    }
#line 84
    if (! part->bsbits) {
      {
#line 85
      tmp___8 = gettext("out of memory\n");
#line 85
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 86
      return (1);
    }
#line 88
    i = 0;
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (! (i < part->boundary_length)) {
#line 88
        goto while_break;
      }
#line 89
      *(part->bsbits + i) = (bsbit_t *)((void *)0);
#line 88
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 93
  tmp___11 = strcasecmp((char const   *)(dr->name), "DIR");
  }
#line 93
  if (tmp___11 == 0) {
    {
#line 94
    tmp___10 = register_get_string((tap_register const   *)part->id);
#line 94
    register_init(dr->out, tmp___10);
    }
  }
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/register.c"
static void cmd_register_help(void) 
{ 
  char *tmp ;

  {
  {
#line 102
  tmp = gettext("Usage: %s NAME LENGTH\nDefine new data register with specified NAME and LENGTH.\n\nNAME          Data register name\nLENGTH        Data register length\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "register");
  }
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/register.c"
cmd_t cmd_register  =    {(char *)"register", (char *)"define new data register for a part", & cmd_register_help,
    & cmd_register_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/readmem.c"
static int cmd_readmem_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t len ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp != 4) {
#line 42
    return (-1);
  }
#line 44
  if (! bus) {
    {
#line 45
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 45
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 46
    return (1);
  }
  {
#line 49
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 49
  if (tmp___1) {
#line 50
    return (-1);
  } else {
    {
#line 49
    tmp___2 = cmd_get_number(*(params + 2), & len);
    }
#line 49
    if (tmp___2) {
#line 50
      return (-1);
    }
  }
  {
#line 52
  f = fopen((char const   */* __restrict  */)*(params + 3), (char const   */* __restrict  */)"w");
  }
#line 53
  if (! f) {
    {
#line 54
    tmp___3 = gettext("Unable to create file `%s\'!\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, *(params + 3));
    }
#line 55
    return (1);
  }
  {
#line 57
  readmem(bus, f, adr, len);
#line 58
  fclose(f);
  }
#line 60
  return (1);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/readmem.c"
static void cmd_readmem_help(void) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = gettext("Usage: %s ADDR LEN FILENAME\nCopy device memory content starting with ADDR to FILENAME file.\n\nADDR       start address of the copied memory area\nLEN        copied memory length\nFILENAME   name of the output file\n\nADDR and LEN could be in decimal or hexadecimal (prefixed with 0x) form.\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "readmem");
  }
#line 76
  return;
}
}
#line 78 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/readmem.c"
cmd_t cmd_readmem  =    {(char *)"readmem", (char *)"read content of the memory and write it to file",
    & cmd_readmem_help, & cmd_readmem_run};
#line 31 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/quit.c"
static int cmd_quit_run(chain_t *chain , char **params ) 
{ 


  {
#line 34
  if (*(params + 1)) {
#line 35
    return (-1);
  }
#line 37
  return (0);
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/quit.c"
static void cmd_quit_help(void) 
{ 
  char *tmp ;

  {
  {
#line 43
  tmp = gettext("Usage: %s\nExit from %s.\n");
#line 43
  printf((char const   */* __restrict  */)tmp, "quit", "urjtag");
  }
#line 47
  return;
}
}
#line 49 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/quit.c"
cmd_t cmd_quit  =    {(char *)"quit", (char *)"exit and terminate this session", & cmd_quit_help, & cmd_quit_run};
#line 930 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 933
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcstombs)(char * __restrict  __s ,
                                                                                  wchar_t const   * __restrict  __pwcs ,
                                                                                  size_t __n ) ;
#line 524 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 222 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcslen)(wchar_t const   *__s )  __attribute__((__pure__)) ;
#line 590
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) swprintf)(wchar_t * __restrict  __s ,
                                                                               size_t __n ,
                                                                               wchar_t const   * __restrict  __format 
                                                                               , ...) ;
#line 46 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/print.c"
static int cmd_print_run(chain_t *chain , char **params ) 
{ 
  char format[128] ;
  wchar_t wformat[128] ;
  wchar_t wheader[128] ;
  char header[128] ;
  int i ;
  int noheader ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  part_t *part ;
  signal_t *s ;
  salias_t *sa ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  int i___0 ;
  uint64_t a ;
  bus_area_t area ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;

  {
  {
#line 56
  noheader = 0;
#line 58
  tmp = cmd_params(params);
  }
#line 58
  if (tmp > 2) {
#line 59
    return (-1);
  }
  {
#line 61
  tmp___0 = cmd_test_cable(chain);
  }
#line 61
  if (! tmp___0) {
#line 62
    return (1);
  }
#line 64
  if (! chain->parts) {
    {
#line 65
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 65
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 66
    return (1);
  }
  {
#line 69
  tmp___4 = cmd_params(params);
  }
#line 69
  if (tmp___4 == 2) {
    {
#line 70
    tmp___2 = strcasecmp((char const   *)*(params + 1), "bus");
    }
#line 70
    if (tmp___2 == 0) {
#line 71
      noheader = 1;
    }
    {
#line 73
    tmp___3 = strcasecmp((char const   *)*(params + 1), "signals");
    }
#line 73
    if (tmp___3 == 0) {
      {
#line 75
      printf((char const   */* __restrict  */)"Signals:\n");
#line 78
      part = *((chain->parts)->parts + chain->active_part);
#line 79
      s = part->signals;
      }
      {
#line 79
      while (1) {
        while_continue: /* CIL Label */ ;
#line 79
        if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 79
          goto while_break;
        }
#line 81
        if (s->pin) {
          {
#line 81
          printf((char const   */* __restrict  */)"%s %s", s->name, s->pin);
          }
        } else {
          {
#line 82
          printf((char const   */* __restrict  */)"%s", s->name);
          }
        }
#line 83
        if (s->input) {
          {
#line 83
          printf((char const   */* __restrict  */)"\tinput=%s", (s->input)->name);
          }
        }
#line 84
        if (s->output) {
          {
#line 84
          printf((char const   */* __restrict  */)"\toutput=%s", (s->output)->name);
          }
        }
#line 86
        sa = part->saliases;
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if (! ((unsigned long )sa != (unsigned long )((void *)0))) {
#line 86
            goto while_break___0;
          }
#line 87
          if ((unsigned long )s == (unsigned long )sa->signal) {
            {
#line 87
            printf((char const   */* __restrict  */)"\tsalias=%s", sa->name);
            }
          }
#line 86
          sa = sa->next;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 89
        printf((char const   */* __restrict  */)"\n");
#line 79
        s = s->next;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 91
      return (1);
    }
  }
#line 95
  if (noheader == 0) {
    {
#line 96
    tmp___5 = gettext(" No. %%-%ds %%-%ds %%-%ds %%-%ds %%-%ds\n");
#line 96
    snprintf((char */* __restrict  */)(format), (size_t )128, (char const   */* __restrict  */)tmp___5,
             25, 20, 8, 20, 32);
#line 99
    tmp___7 = mbstowcs((wchar_t */* __restrict  */)(wformat), (char const   */* __restrict  */)(format),
                       (size_t )128);
    }
#line 99
    if (tmp___7 == 0xffffffffffffffffUL) {
      {
#line 100
      tmp___6 = gettext("(%d) String conversion failed!\n");
#line 100
      printf((char const   */* __restrict  */)tmp___6, 100);
      }
    }
    {
#line 101
    tmp___8 = gettext("Register");
#line 101
    tmp___9 = gettext("Instruction");
#line 101
    tmp___10 = gettext("Stepping");
#line 101
    tmp___11 = gettext("Part");
#line 101
    tmp___12 = gettext("Manufacturer");
#line 101
    swprintf((wchar_t */* __restrict  */)(wheader), (size_t )128, (wchar_t const   */* __restrict  */)(wformat),
             tmp___12, tmp___11, tmp___10, tmp___9, tmp___8);
#line 102
    tmp___14 = wcstombs((char */* __restrict  */)(header), (wchar_t const   */* __restrict  */)(wheader),
                        (size_t )128);
    }
#line 102
    if (tmp___14 == 0xffffffffffffffffUL) {
      {
#line 103
      tmp___13 = gettext("(%d) String conversion failed!\n");
#line 103
      printf((char const   */* __restrict  */)tmp___13, 103);
      }
    }
    {
#line 109
    printf((char const   */* __restrict  */)(header));
#line 111
    i = 0;
    }
    {
#line 111
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 111
      tmp___15 = wcslen((wchar_t const   *)(wheader));
      }
#line 111
      if (! ((size_t )i < tmp___15)) {
#line 111
        goto while_break___1;
      }
      {
#line 112
      putchar('-');
#line 111
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 113
    putchar('\n');
    }
  }
  {
#line 116
  tmp___24 = cmd_params(params);
  }
#line 116
  if (tmp___24 == 1) {
#line 117
    if ((chain->parts)->len > chain->active_part) {
#line 118
      if ((*((chain->parts)->parts + chain->active_part))->alias) {
        {
#line 119
        tmp___16 = gettext(" %3d %s ");
#line 119
        printf((char const   */* __restrict  */)tmp___16, chain->active_part, (*((chain->parts)->parts + chain->active_part))->alias);
        }
      } else {
        {
#line 121
        tmp___17 = gettext(" %3d ");
#line 121
        printf((char const   */* __restrict  */)tmp___17, chain->active_part);
        }
      }
      {
#line 123
      part_print(*((chain->parts)->parts + chain->active_part));
      }
    }
#line 125
    if ((unsigned long )bus != (unsigned long )((void *)0)) {
#line 130
      i___0 = 0;
      {
#line 130
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 130
        if (! (i___0 < buses.len)) {
#line 130
          goto while_break___2;
        }
#line 131
        if ((unsigned long )*(buses.buses + i___0) == (unsigned long )bus) {
#line 132
          goto while_break___2;
        }
#line 130
        i___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 133
      tmp___18 = gettext("\nActive bus:\n*%d: ");
#line 133
      printf((char const   */* __restrict  */)tmp___18, i___0);
#line 134
      (*((bus->driver)->printinfo))(bus);
#line 136
      a = (uint64_t )0;
      }
      {
#line 136
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 136
        if (! (a < 4294967296UL)) {
#line 136
          goto while_break___3;
        }
        {
#line 137
        tmp___20 = (*((bus->driver)->area))(bus, (uint32_t )a, & area);
        }
#line 137
        if (tmp___20 != 0) {
          {
#line 138
          tmp___19 = gettext("Error in bus area discovery at 0x%08llX\n");
#line 138
          printf((char const   */* __restrict  */)tmp___19, (unsigned long long )a);
          }
#line 139
          goto while_break___3;
        }
#line 141
        if (area.width != 0U) {
#line 142
          if ((unsigned long )area.description != (unsigned long )((void *)0)) {
            {
#line 143
            tmp___21 = gettext(area.description);
#line 143
            tmp___22 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit, (%s)\n");
#line 143
            printf((char const   */* __restrict  */)tmp___22, area.start, (unsigned long long )area.length,
                   area.width, tmp___21);
            }
          } else {
            {
#line 145
            tmp___23 = gettext("\tstart: 0x%08X, length: 0x%08llX, data width: %d bit\n");
#line 145
            printf((char const   */* __restrict  */)tmp___23, area.start, (unsigned long long )area.length,
                   area.width);
            }
          }
        }
#line 136
        a = (uint64_t )area.start + area.length;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 150
    return (1);
  }
  {
#line 153
  tmp___25 = strcasecmp((char const   *)*(params + 1), "chain");
  }
#line 153
  if (tmp___25 == 0) {
    {
#line 154
    parts_print(chain->parts);
    }
#line 155
    return (1);
  }
#line 158
  i = 0;
  {
#line 158
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 158
    if (! (i < buses.len)) {
#line 158
      goto while_break___4;
    }
#line 159
    if ((unsigned long )*(buses.buses + i) == (unsigned long )bus) {
      {
#line 160
      tmp___26 = gettext("*%d: ");
#line 160
      printf((char const   */* __restrict  */)tmp___26, i);
      }
    } else {
      {
#line 162
      tmp___27 = gettext("%d: ");
#line 162
      printf((char const   */* __restrict  */)tmp___27, i);
      }
    }
    {
#line 163
    (*(((*(buses.buses + i))->driver)->printinfo))(*(buses.buses + i));
#line 158
    i ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 166
  return (1);
}
}
#line 169 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/print.c"
static void cmd_print_help(void) 
{ 
  char *tmp ;

  {
  {
#line 172
  tmp = gettext("Usage: %s [chain|bus|signals]\nDisplay JTAG chain status.\n\nDisplay list of the parts connected to the JTAG chain including\npart number and current (active) instruction and data register.\n");
#line 172
  printf((char const   */* __restrict  */)tmp, "print");
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/print.c"
cmd_t cmd_print  =    {(char *)"print", (char *)"display JTAG chain list/status", & cmd_print_help, & cmd_print_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/peekpoke.c"
static int cmd_peek_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  int pars ;
  int j ;
  bus_area_t area ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 38
  j = 1;
#line 43
  pars = cmd_params(params);
  }
#line 43
  if (pars < 2) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp);
    }
#line 48
    return (1);
  }
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___0 = cmd_get_number(*(params + j), & adr);
    }
#line 51
    if (tmp___0) {
#line 52
      return (-1);
    }
    {
#line 54
    (*((bus->driver)->prepare))(bus);
#line 55
    (*((bus->driver)->area))(bus, adr, & area);
#line 56
    val = (*((bus->driver)->read))(bus, adr);
    }
    {
#line 60
    if (area.width == 8U) {
#line 60
      goto case_8;
    }
#line 64
    if (area.width == 16U) {
#line 64
      goto case_16;
    }
#line 68
    goto switch_default;
    case_8: /* CIL Label */ 
    {
#line 61
    val &= 255U;
#line 62
    tmp___1 = gettext("bus_read(0x%08x) = 0x%02X (%i)\n");
#line 62
    printf((char const   */* __restrict  */)tmp___1, adr, val, val);
    }
#line 63
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 65
    val &= 65535U;
#line 66
    tmp___2 = gettext("bus_read(0x%08x) = 0x%04X (%i)\n");
#line 66
    printf((char const   */* __restrict  */)tmp___2, adr, val, val);
    }
#line 67
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 69
    tmp___3 = gettext("bus_read(0x%08x) = 0x%08X (%i)\n");
#line 69
    printf((char const   */* __restrict  */)tmp___3, adr, val, val);
    }
    switch_break: /* CIL Label */ ;
    }
#line 50
    j ++;
#line 50
    if (! (j != pars)) {
#line 50
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  return (1);
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/peekpoke.c"
static void cmd_peek_help(void) 
{ 
  char *tmp ;

  {
  {
#line 79
  tmp = gettext("Usage: %s ADDR\nRead a single word (bus width size).\n\nADDR       address to read from\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 79
  printf((char const   */* __restrict  */)tmp, "peek");
  }
#line 88
  return;
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/peekpoke.c"
cmd_t cmd_peek  =    {(char *)"peek", (char *)"read a single word", & cmd_peek_help, & cmd_peek_run};
#line 97 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/peekpoke.c"
static int cmd_poke_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  uint32_t val ;
  bus_area_t area ;
  int k ;
  int pars ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 103
  k = 1;
#line 103
  tmp = cmd_params(params);
#line 103
  pars = tmp;
  }
#line 105
  if (pars < 3) {
#line 106
    return (-1);
  } else
#line 105
  if (! (pars & 1)) {
#line 106
    return (-1);
  }
#line 108
  if (! bus) {
    {
#line 109
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 109
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 110
    return (1);
  }
  {
#line 114
  (*((bus->driver)->prepare))(bus);
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (k < pars)) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp___1 = cmd_get_number(*(params + k), & adr);
    }
#line 117
    if (tmp___1) {
#line 118
      return (-1);
    } else {
      {
#line 117
      tmp___2 = cmd_get_number(*(params + (k + 1)), & val);
      }
#line 117
      if (tmp___2) {
#line 118
        return (-1);
      }
    }
    {
#line 119
    (*((bus->driver)->area))(bus, adr, & area);
#line 120
    (*((bus->driver)->write))(bus, adr, val);
#line 121
    k += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 124
  return (1);
}
}
#line 127 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/peekpoke.c"
static void cmd_poke_help(void) 
{ 
  char *tmp ;

  {
  {
#line 130
  tmp = gettext("Usage: %s ADDR VAL [ADDR VAL] ... \nWrite a single word (bus width size).\n\nADDR       address to write\nVAL        value to write\n\nADDR and VAL could be in decimal or hexadecimal (prefixed with 0x) form.\n\n");
#line 130
  printf((char const   */* __restrict  */)tmp, "poke");
  }
#line 140
  return;
}
}
#line 142 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/peekpoke.c"
cmd_t cmd_poke  =    {(char *)"poke", (char *)"write a single word", & cmd_poke_help, & cmd_poke_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/part.c"
static int cmd_part_run(chain_t *chain , char **params ) 
{ 
  unsigned int n ;
  part_t *part ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int i ;
  char *a ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 41
  tmp___2 = cmd_params(params);
  }
#line 41
  if (tmp___2 == 3) {
    {
#line 42
    tmp___1 = strcasecmp((char const   *)*(params + 1), "alias");
    }
#line 42
    if (tmp___1 == 0) {
      {
#line 44
      part = *((chain->parts)->parts + chain->active_part);
#line 45
      tmp = strlen((char const   *)*(params + 2));
#line 45
      tmp___0 = malloc(tmp + 1UL);
#line 45
      part->alias = (char *)tmp___0;
#line 46
      strcpy((char */* __restrict  */)part->alias, (char const   */* __restrict  */)*(params + 2));
      }
#line 47
      return (1);
    }
  }
  {
#line 52
  tmp___3 = cmd_params(params);
  }
#line 52
  if (tmp___3 != 2) {
#line 53
    return (-1);
  }
  {
#line 55
  tmp___4 = cmd_test_cable(chain);
  }
#line 55
  if (! tmp___4) {
#line 56
    return (1);
  }
#line 58
  if (! chain->parts) {
    {
#line 59
    tmp___5 = gettext("Run \"detect\" first.\n");
#line 59
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 60
    return (1);
  }
  {
#line 64
  tmp___7 = cmd_get_number(*(params + 1), & n);
  }
#line 64
  if (tmp___7) {
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue: /* CIL Label */ ;
#line 70
      if (! (i < (chain->parts)->len)) {
#line 70
        goto while_break;
      }
#line 71
      a = (*((chain->parts)->parts + i))->alias;
#line 72
      if (a) {
        {
#line 72
        tmp___6 = strcasecmp((char const   *)a, (char const   *)*(params + 1));
        }
#line 72
        if (tmp___6 == 0) {
#line 72
          goto while_break;
        }
      }
#line 70
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 74
    if (i < (chain->parts)->len) {
#line 74
      n = (unsigned int )i;
    } else {
#line 77
      return (-1);
    }
  }
#line 80
  if (n >= (unsigned int )(chain->parts)->len) {
    {
#line 81
    tmp___8 = gettext("%s: invalid part number\n");
#line 81
    printf((char const   */* __restrict  */)tmp___8, "part");
    }
#line 82
    return (1);
  }
#line 85
  chain->active_part = (int )n;
#line 87
  return (1);
}
}
#line 90 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/part.c"
static void cmd_part_help(void) 
{ 
  char *tmp ;

  {
  {
#line 93
  tmp = gettext("Usage: %s PART\nChange active part for current JTAG chain.\n\nPART          part number | alias\n");
#line 93
  printf((char const   */* __restrict  */)tmp, "part");
  }
#line 99
  return;
}
}
#line 101 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/part.c"
cmd_t cmd_part  =    {(char *)"part", (char *)"change active part for current JTAG chain", & cmd_part_help,
    & cmd_part_run};
#line 39 "../../include/jtag.h"
int debug_mode ;
#line 43
int jtag_parse_file(chain_t *chain , char const   *filename ) ;
#line 44
int jtag_parse_line(chain_t *chain , char *line ) ;
#line 45
int jtag_parse_stream(chain_t *chain , FILE *f ) ;
#line 42 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/parse.c"
int jtag_parse_line(chain_t *chain , char *line ) 
{ 
  int l ;
  int i ;
  int r ;
  int tcnt ;
  char **a ;
  char *c ;
  char *d ;
  char *sline ;
  size_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 50
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 51
    return (1);
  }
  {
#line 52
  tmp = strlen((char const   *)line);
#line 52
  l = (int )tmp;
  }
#line 53
  if (l == 0) {
#line 54
    return (1);
  }
  {
#line 57
  tmp___0 = malloc((unsigned long )(l + 1) * sizeof(char ));
#line 57
  sline = (char *)tmp___0;
  }
#line 58
  if ((unsigned long )sline == (unsigned long )((void *)0)) {
    {
#line 59
    tmp___1 = gettext("Out of memory\n");
#line 59
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 60
    return (1);
  }
#line 64
  c = line;
#line 65
  d = sline;
#line 66
  tcnt = 0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 69
      tmp___2 = __ctype_b_loc();
      }
#line 69
      if (! ((int const   )*(*tmp___2 + (int )*c) & 8192)) {
#line 69
        goto while_break___0;
      }
#line 70
      c ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 73
    if ((int )*c == 0) {
#line 74
      goto while_break;
    } else
#line 73
    if ((int )*c == 35) {
#line 74
      goto while_break;
    }
    {
#line 77
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 77
      tmp___5 = __ctype_b_loc();
      }
#line 77
      if ((int const   )*(*tmp___5 + (int )*c) & 8192) {
#line 77
        goto while_break___1;
      } else
#line 77
      if (! ((int )*c != 0)) {
#line 77
        goto while_break___1;
      }
#line 78
      tmp___3 = d;
#line 78
      d ++;
#line 78
      tmp___4 = c;
#line 78
      c ++;
#line 78
      *tmp___3 = *tmp___4;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 81
    tmp___6 = d;
#line 81
    d ++;
#line 81
    *tmp___6 = (char )'\000';
#line 82
    tcnt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  if (tcnt == 0) {
    {
#line 86
    free((void *)sline);
    }
#line 87
    return (1);
  }
  {
#line 91
  tmp___7 = malloc((unsigned long )(tcnt + 1) * sizeof(char *));
#line 91
  a = (char **)tmp___7;
  }
#line 92
  if ((unsigned long )a == (unsigned long )((void *)0)) {
    {
#line 93
    tmp___8 = gettext("Out of memory\n");
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8);
    }
#line 94
    return (1);
  }
#line 98
  d = sline;
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 99
    if (! (i < tcnt)) {
#line 99
      goto while_break___2;
    }
#line 101
    *(a + i) = d;
    {
#line 102
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 102
      tmp___9 = d;
#line 102
      d ++;
#line 102
      if (! ((int )*tmp___9 != 0)) {
#line 102
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 99
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 105
  *(a + tcnt) = (char *)((void *)0);
#line 107
  r = cmd_run(chain, a);
  }
#line 108
  if (debug_mode & 1) {
    {
#line 108
    printf((char const   */* __restrict  */)"Return in jtag_parse_line r=%d\n", r);
    }
  }
  {
#line 109
  free((void *)a);
#line 110
  free((void *)sline);
  }
#line 111
  return (r);
}
}
#line 115 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/parse.c"
int jtag_parse_stream(chain_t *chain , FILE *f ) 
{ 
  char inputline[101] ;
  int go ;
  int i ;
  int c ;
  int lnr ;
  int clip ;
  int tmp ;

  {
#line 119
  go = 1;
#line 122
  lnr = 0;
  {
#line 123
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    i = 0;
#line 125
    clip = 0;
    {
#line 128
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 129
      c = fgetc(f);
      }
#line 130
      if (c == -1) {
#line 131
        goto while_break___0;
      } else
#line 130
      if (c == 10) {
#line 131
        goto while_break___0;
      }
#line 132
      if ((unsigned long )i < sizeof(inputline) - 1UL) {
#line 133
        tmp = i;
#line 133
        i ++;
#line 133
        inputline[tmp] = (char )c;
      } else {
#line 135
        clip = 1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 137
    inputline[i] = (char )'\000';
#line 138
    lnr ++;
#line 139
    if (clip) {
      {
#line 140
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Warning: line %d exceeds %d characters, clipped\n",
              lnr, (int )sizeof(inputline) - 1);
      }
    }
    {
#line 141
    go = jtag_parse_line(chain, inputline);
    }
#line 123
    if (go) {
#line 123
      if (! (c != -1)) {
#line 123
        goto while_break;
      }
    } else {
#line 123
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  return (go);
}
}
#line 148 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/parse.c"
int jtag_parse_file(chain_t *chain , char const   *filename ) 
{ 
  FILE *f ;
  int go ;

  {
  {
#line 154
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 155
  if (! f) {
#line 156
    return (-1);
  }
  {
#line 158
  go = jtag_parse_stream(chain, f);
#line 160
  fclose(f);
  }
#line 161
  if (debug_mode & 1) {
    {
#line 161
    printf((char const   */* __restrict  */)"File Closed gp=%d\n", go);
    }
  }
#line 162
  return (go);
}
}
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/jtag_data_dir.c"
char const   *jtag_get_data_dir(void) 
{ 


  {
#line 36
  return ("/usr/local/share/urjtag");
}
}
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/instruction.c"
static int cmd_instruction_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  unsigned int len ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  instruction *i ;
  char *tmp___8 ;
  size_t tmp___9 ;
  char *tmp___10 ;
  instruction *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 40
  tmp = cmd_test_cable(chain);
  }
#line 40
  if (! tmp) {
#line 41
    return (1);
  }
#line 43
  if (! chain->parts) {
    {
#line 44
    tmp___0 = gettext("Run \"detect\" first.\n");
#line 44
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 45
    return (1);
  }
#line 48
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 49
    tmp___1 = gettext("%s: no active part\n");
#line 49
    printf((char const   */* __restrict  */)tmp___1, "instruction");
    }
#line 50
    return (1);
  }
  {
#line 53
  part = *((chain->parts)->parts + chain->active_part);
#line 55
  tmp___3 = cmd_params(params);
  }
#line 55
  if (tmp___3 == 2) {
    {
#line 56
    part_set_instruction(part, (char const   *)*(params + 1));
    }
#line 57
    if ((unsigned long )part->active_instruction == (unsigned long )((void *)0)) {
      {
#line 58
      tmp___2 = gettext("%s: unknown instruction \'%s\'\n");
#line 58
      printf((char const   */* __restrict  */)tmp___2, "instruction", *(params + 1));
      }
    }
#line 59
    return (1);
  }
  {
#line 62
  tmp___7 = cmd_params(params);
  }
#line 62
  if (tmp___7 == 3) {
    {
#line 65
    tmp___4 = strcasecmp((char const   *)*(params + 1), "length");
    }
#line 65
    if (tmp___4 != 0) {
#line 66
      return (-1);
    }
#line 68
    if ((unsigned long )part->instructions != (unsigned long )((void *)0)) {
      {
#line 69
      tmp___5 = gettext("instruction length is already set and used\n");
#line 69
      printf((char const   */* __restrict  */)tmp___5);
      }
#line 70
      return (1);
    }
    {
#line 73
    tmp___6 = cmd_get_number(*(params + 2), & len);
    }
#line 73
    if (tmp___6) {
#line 74
      return (-1);
    }
#line 76
    part->instruction_length = (int )len;
#line 77
    return (1);
  }
  {
#line 80
  tmp___14 = cmd_params(params);
  }
#line 80
  if (tmp___14 == 4) {
    {
#line 83
    tmp___9 = strlen((char const   *)*(params + 2));
    }
#line 83
    if (tmp___9 != (size_t )part->instruction_length) {
      {
#line 84
      tmp___8 = gettext("invalid instruction length\n");
#line 84
      printf((char const   */* __restrict  */)tmp___8);
      }
#line 85
      return (1);
    }
    {
#line 88
    tmp___11 = part_find_instruction(part, (char const   *)*(params + 1));
    }
#line 88
    if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
      {
#line 89
      tmp___10 = gettext("Instruction \'%s\' already defined\n");
#line 89
      printf((char const   */* __restrict  */)tmp___10, *(params + 1));
      }
#line 90
      return (1);
    }
    {
#line 93
    i = instruction_alloc((char const   *)*(params + 1), part->instruction_length,
                          (char const   *)*(params + 2));
    }
#line 94
    if (! i) {
      {
#line 95
      tmp___12 = gettext("out of memory\n");
#line 95
      printf((char const   */* __restrict  */)tmp___12);
      }
#line 96
      return (1);
    }
    {
#line 99
    i->next = part->instructions;
#line 100
    part->instructions = i;
#line 102
    i->data_register = part_find_data_register(part, (char const   *)*(params + 3));
    }
#line 103
    if ((unsigned long )i->data_register == (unsigned long )((void *)0)) {
      {
#line 104
      tmp___13 = gettext("unknown data register \'%s\'\n");
#line 104
      printf((char const   */* __restrict  */)tmp___13, *(params + 3));
      }
#line 105
      return (1);
    }
#line 108
    return (1);
  }
#line 111
  return (-1);
}
}
#line 114 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/instruction.c"
static void cmd_instruction_help(void) 
{ 
  char *tmp ;

  {
  {
#line 117
  tmp = gettext("Usage: %s INSTRUCTION\nUsage: %s length LENGTH\nUsage: %s INSTRUCTION CODE REGISTER\nChange active INSTRUCTION for a part or declare new instruction.\n\nINSTRUCTION   instruction name (e.g. BYPASS)\nLENGTH        common instruction length\nCODE          instruction code (e.g. 11111)\nREGISTER      default data register for instruction (e.g. BR)\n");
#line 117
  printf((char const   */* __restrict  */)tmp, "instruction", "instruction", "instruction");
  }
#line 128
  return;
}
}
#line 130 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/instruction.c"
cmd_t cmd_instruction  =    {(char *)"instruction", (char *)"change active instruction for a part or declare new instruction",
    & cmd_instruction_help, & cmd_instruction_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/initbus.c"
static int cmd_initbus_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  bus_t *bus___0 ;
  bus_t *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp < 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable(chain);
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
#line 50
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 51
    tmp___2 = gettext("%s: no active part\n");
#line 51
    printf((char const   */* __restrict  */)tmp___2, "initbus");
    }
#line 52
    return (1);
  } else
#line 50
  if (chain->active_part < 0) {
    {
#line 51
    tmp___2 = gettext("%s: no active part\n");
#line 51
    printf((char const   */* __restrict  */)tmp___2, "initbus");
    }
#line 52
    return (1);
  }
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 55
      goto while_break;
    }
    {
#line 56
    tmp___7 = strcasecmp((char const   *)(bus_drivers[i])->name, (char const   *)*(params + 1));
    }
#line 56
    if (tmp___7 == 0) {
      {
#line 57
      tmp___3 = (*((bus_drivers[i])->new_bus))(chain, bus_drivers[i], params);
#line 57
      bus___0 = tmp___3;
      }
#line 58
      if ((unsigned long )bus___0 == (unsigned long )((void *)0)) {
        {
#line 59
        tmp___4 = gettext("bus alloc/attach failed!\n");
#line 59
        printf((char const   */* __restrict  */)tmp___4);
        }
#line 60
        return (1);
      }
      {
#line 62
      buses_add(bus___0);
#line 63
      tmp___6 = (*((bus___0->driver)->init))(bus___0);
      }
#line 63
      if (tmp___6) {
        {
#line 64
        tmp___5 = gettext("bus initialization failed!\n");
#line 64
        printf((char const   */* __restrict  */)tmp___5);
        }
      }
#line 65
      return (1);
    }
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  tmp___8 = gettext("Unknown bus: %s\n");
#line 69
  printf((char const   */* __restrict  */)tmp___8, *(params + 1));
  }
#line 71
  return (1);
}
}
#line 74 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/initbus.c"
static void cmd_initbus_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 79
  tmp = gettext("Usage: %s BUSNAME\nInitialize new bus driver for active part.\n\nBUSNAME       Name of the bus\n\nList of available buses:\n");
#line 79
  printf((char const   */* __restrict  */)tmp, "initbus");
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! ((unsigned long )bus_drivers[i] != (unsigned long )((void *)0))) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___0 = gettext("%-10s %s\n");
#line 89
    printf((char const   */* __restrict  */)tmp___0, (bus_drivers[i])->name, (bus_drivers[i])->description);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/initbus.c"
struct __anonstruct_cmd_t_148900231  const  cmd_initbus  =    {(char *)"initbus", (char *)"initialize bus driver for active part", & cmd_initbus_help,
    & cmd_initbus_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
static int cmd_include_or_script_run(chain_t *chain , int is_include , char **params ) 
{ 
  int go ;
  int i ;
  int j ;
  char *path ;
  int len ;
  int tmp ;
  char *tmp___0 ;
  char *jtag_data_dir ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;

  {
  {
#line 39
  go = 0;
#line 39
  j = 1;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp < 2) {
#line 44
    return (-1);
  }
#line 46
  if (! is_include) {
    {
#line 48
    tmp___0 = gettext("Please use the \'include\' command instead of \'script\'\n");
#line 48
    printf((char const   */* __restrict  */)tmp___0);
    }
  }
#line 54
  path = *(params + 1);
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! ((int )*path == 46)) {
#line 58
      goto while_break;
    }
#line 58
    path ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if ((int )*path == 47) {
    {
#line 61
    path = strdup((char const   *)*(params + 1));
    }
  } else
#line 59
  if ((int )*path == 92) {
    {
#line 61
    path = strdup((char const   *)*(params + 1));
    }
  } else
#line 59
  if (! is_include) {
    {
#line 61
    path = strdup((char const   *)*(params + 1));
    }
  } else {
    {
#line 65
    tmp___1 = jtag_get_data_dir();
#line 65
    jtag_data_dir = (char *)tmp___1;
#line 66
    tmp___2 = strlen((char const   *)jtag_data_dir);
#line 66
    tmp___3 = strlen((char const   *)*(params + 1));
#line 66
    len = (int )((tmp___2 + tmp___3) + 2UL);
#line 66
    tmp___4 = malloc((size_t )len);
#line 66
    path = (char *)tmp___4;
    }
#line 67
    if ((unsigned long )path != (unsigned long )((void *)0)) {
      {
#line 69
      snprintf((char */* __restrict  */)path, (size_t )len, (char const   */* __restrict  */)"%s/%s",
               jtag_data_dir, *(params + 1));
      }
    }
  }
#line 72
  if ((unsigned long )path == (unsigned long )((void *)0)) {
    {
#line 73
    tmp___5 = gettext("Out of memory\n");
#line 73
    printf((char const   */* __restrict  */)tmp___5);
    }
#line 74
    return (1);
  }
  {
#line 79
  tmp___6 = bsdl_read_file(chain, (char const   *)path, 1 << 3, (char const   *)((void *)0));
  }
#line 79
  if (tmp___6 >= 0) {
    {
#line 82
    go = bsdl_read_file(chain, (char const   *)path, ((((1 << 4) | (1 << 6)) | (1 << 1)) | (1 << 2)) | (1 << 3),
                        (char const   *)((void *)0));
#line 84
    free((void *)path);
    }
#line 85
    return (1);
  }
  {
#line 89
  tmp___7 = cmd_params(params);
  }
#line 89
  if (tmp___7 > 2) {
    {
#line 90
    sscanf((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"%d",
           & j);
    }
  }
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 93
    if (! (i < j)) {
#line 93
      goto while_break___0;
    }
    {
#line 94
    go = jtag_parse_file(chain, (char const   *)path);
    }
#line 96
    if (go < 0) {
#line 97
      if (go != -99) {
        {
#line 98
        tmp___8 = gettext("Unable to open file `%s go=%d\'!\n");
#line 98
        printf((char const   */* __restrict  */)tmp___8, path, go);
        }
      }
#line 99
      goto while_break___0;
    }
#line 93
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 103
  free((void *)path);
  }
#line 105
  if (go) {
#line 105
    tmp___9 = 1;
  } else {
#line 105
    tmp___9 = 0;
  }
#line 105
  return (tmp___9);
}
}
#line 108 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
static void cmd_include_or_script_help(char *cmd ) 
{ 
  char *tmp ;

  {
  {
#line 111
  tmp = gettext("Usage: %s FILENAME [n] \nRun command sequence n times from external FILENAME.\n\nFILENAME      Name of the file with commands\n");
#line 111
  printf((char const   */* __restrict  */)tmp, cmd);
  }
#line 117
  return;
}
}
#line 119 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
static int cmd_include_run(chain_t *chain , char **params ) 
{ 
  int tmp ;

  {
  {
#line 122
  tmp = cmd_include_or_script_run(chain, 1, params);
  }
#line 122
  return (tmp);
}
}
#line 125 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
static void cmd_include_help(void) 
{ 


  {
  {
#line 128
  cmd_include_or_script_help((char *)"include");
  }
#line 129
  return;
}
}
#line 131 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
cmd_t cmd_include  =    {(char *)"include", (char *)"include command sequence from external repository",
    & cmd_include_help, & cmd_include_run};
#line 138 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
static int cmd_script_run(chain_t *chain , char **params ) 
{ 
  int tmp ;

  {
  {
#line 141
  tmp = cmd_include_or_script_run(chain, 0, params);
  }
#line 141
  return (tmp);
}
}
#line 144 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
static void cmd_script_help(void) 
{ 


  {
  {
#line 147
  cmd_include_or_script_help((char *)"script");
  }
#line 148
  return;
}
}
#line 150 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/include.c"
cmd_t cmd_script  =    {(char *)"script", (char *)"run command sequence from external file", & cmd_script_help,
    & cmd_script_run};
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/idcode.c"
static int cmd_idcode_run(chain_t *chain , char **params ) 
{ 
  unsigned int bytes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 35
  bytes = 0U;
#line 37
  tmp___1 = cmd_params(params);
  }
#line 37
  if (tmp___1 == 1) {
#line 38
    bytes = 0U;
  } else {
    {
#line 41
    tmp___0 = cmd_params(params);
    }
#line 41
    if (tmp___0 > 2) {
#line 42
      return (-1);
    } else {
      {
#line 44
      tmp = cmd_get_number(*(params + 1), & bytes);
      }
#line 44
      if (tmp) {
#line 45
        return (-1);
      }
    }
  }
  {
#line 47
  tmp___2 = cmd_test_cable(chain);
  }
#line 47
  if (! tmp___2) {
#line 48
    return (1);
  }
  {
#line 50
  tmp___3 = gettext("Reading %d bytes if idcode\n");
#line 50
  printf((char const   */* __restrict  */)tmp___3, bytes);
#line 51
  idcode(chain, bytes);
  }
#line 52
  return (1);
}
}
#line 55 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/idcode.c"
static void cmd_idcode_help(void) 
{ 
  char *tmp ;

  {
  {
#line 58
  tmp = gettext("Usage: %s [BYTES]\nRead [BYTES]|all IDCODEs of all parts in a JTAG chain.\n\nBYTES must be an unsigned integer, Use 0 for BYTES to read all bytes\n");
#line 58
  printf((char const   */* __restrict  */)tmp, "idcode");
  }
#line 64
  return;
}
}
#line 66 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/idcode.c"
cmd_t cmd_idcode  =    {(char *)"idcode", (char *)"Read IDCODEs of all parts in a JTAG chain", & cmd_idcode_help,
    & cmd_idcode_run};
#line 46 "../../include/cmd.h"
cmd_t const   *cmds[39] ;
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/help.c"
static int cmd_help_run(chain_t *chain , char **params ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 38
  if (! *(params + 1)) {
    {
#line 39
    tmp = gettext("Command list:\n\n");
#line 39
    printf((char const   */* __restrict  */)tmp);
#line 40
    i = 0;
    }
    {
#line 40
    while (1) {
      while_continue: /* CIL Label */ ;
#line 40
      if (! cmds[i]) {
#line 40
        goto while_break;
      }
#line 41
      if ((cmds[i])->desc) {
        {
#line 41
        tmp___0 = gettext((char const   *)(cmds[i])->desc);
#line 41
        tmp___2 = tmp___0;
        }
      } else {
        {
#line 41
        tmp___1 = gettext("(no description available)");
#line 41
        tmp___2 = tmp___1;
        }
      }
      {
#line 41
      tmp___3 = gettext("%-13s %s\n");
#line 41
      printf((char const   */* __restrict  */)tmp___3, (cmds[i])->name, tmp___2);
#line 40
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 42
    tmp___4 = gettext("\nType \"help COMMAND\" for details about a particular command.\n");
#line 42
    printf((char const   */* __restrict  */)tmp___4);
    }
#line 43
    return (1);
  }
#line 46
  if (*(params + 2)) {
#line 47
    return (-1);
  }
#line 50
  i = 0;
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! cmds[i]) {
#line 50
      goto while_break___0;
    }
    {
#line 51
    tmp___5 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 1));
    }
#line 51
    if (tmp___5 == 0) {
#line 52
      if ((cmds[i])->help) {
        {
#line 53
        (*((cmds[i])->help))();
        }
      }
#line 54
      return (1);
    }
#line 50
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 57
  tmp___6 = gettext("%s: unknown command\n");
#line 57
  printf((char const   */* __restrict  */)tmp___6, *(params + 1));
  }
#line 59
  return (1);
}
}
#line 62 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/help.c"
static void cmd_help_help(void) 
{ 
  char *tmp ;

  {
  {
#line 65
  tmp = gettext("Usage: %s [COMMAND]\nPrint short help for COMMAND, or list of available commands.\n");
#line 65
  printf((char const   */* __restrict  */)tmp, "help");
  }
#line 69
  return;
}
}
#line 71 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/help.c"
cmd_t cmd_help  =    {(char *)"help", (char *)"display this help", & cmd_help_help, & cmd_help_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/get.c"
static int cmd_get_run(chain_t *chain , char **params ) 
{ 
  int data ;
  signal_t *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = strcasecmp((char const   *)*(params + 1), "signal");
  }
#line 45
  if (tmp___0 != 0) {
#line 46
    return (-1);
  }
  {
#line 48
  tmp___1 = cmd_test_cable(chain);
  }
#line 48
  if (! tmp___1) {
#line 49
    return (1);
  }
#line 51
  if (! chain->parts) {
    {
#line 52
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 52
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 53
    return (1);
  }
#line 56
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 57
    tmp___3 = gettext("%s: no active part\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, "get");
    }
#line 58
    return (1);
  }
  {
#line 61
  s = part_find_signal(*((chain->parts)->parts + chain->active_part), (char const   *)*(params + 2));
  }
#line 62
  if (! s) {
    {
#line 63
    tmp___4 = gettext("signal \'%s\' not found\n");
#line 63
    printf((char const   */* __restrict  */)tmp___4, *(params + 2));
    }
#line 64
    return (1);
  }
  {
#line 66
  data = part_get_signal(*((chain->parts)->parts + chain->active_part), s);
  }
#line 67
  if (data != -1) {
    {
#line 68
    tmp___5 = gettext("%s = %d\n");
#line 68
    printf((char const   */* __restrict  */)tmp___5, *(params + 2), data);
    }
  }
#line 70
  return (1);
}
}
#line 73 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/get.c"
static void cmd_get_help(void) 
{ 
  char *tmp ;

  {
  {
#line 76
  tmp = gettext("Usage: %s SIGNAL\nGet signal state from output BSR (Boundary Scan Register).\n\nSIGNAL        signal name (from JTAG declaration file)\n");
#line 76
  printf((char const   */* __restrict  */)tmp, "get signal");
  }
#line 82
  return;
}
}
#line 84 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/get.c"
cmd_t cmd_get  =    {(char *)"get", (char *)"get external signal value", & cmd_get_help, & cmd_get_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/frequency.c"
static int cmd_frequency_run(chain_t *chain , char **params ) 
{ 
  unsigned int freq ;
  int tmp ;
  uint32_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 39
  tmp = cmd_test_cable(chain);
  }
#line 39
  if (! tmp) {
#line 40
    return (1);
  }
  {
#line 42
  tmp___2 = cmd_params(params);
  }
#line 42
  if (tmp___2 == 1) {
    {
#line 43
    tmp___0 = cable_get_frequency(chain->cable);
#line 43
    tmp___1 = gettext("Current TCK frequency is %u Hz\n");
#line 43
    printf((char const   */* __restrict  */)tmp___1, tmp___0);
    }
#line 44
    return (1);
  }
  {
#line 47
  tmp___3 = cmd_params(params);
  }
#line 47
  if (tmp___3 != 2) {
#line 48
    return (-1);
  }
  {
#line 50
  tmp___4 = cmd_get_number(*(params + 1), & freq);
  }
#line 50
  if (tmp___4) {
#line 51
    return (-1);
  }
  {
#line 53
  tmp___5 = gettext("Setting TCK frequency to %u Hz\n");
#line 53
  printf((char const   */* __restrict  */)tmp___5, freq);
#line 54
  cable_set_frequency(chain->cable, freq);
  }
#line 56
  return (1);
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/frequency.c"
static void cmd_frequency_help(void) 
{ 
  char *tmp ;

  {
  {
#line 62
  tmp = gettext("Usage: %s [FREQ]\nChange TCK frequency to FREQ or print current TCK frequency.\n\nFREQ is in hertz. It\'s a maximum TCK frequency for JTAG interface.\nIn some cases the TCK frequency is less than FREQ, but the frequency\nis never more than FREQ. Maximum supported frequency depends on JTAG\nadapter.\n\nFREQ must be an unsigned integer. Minimum allowed frequency is 1 Hz.\nUse 0 for FREQ to disable frequency limit.\n");
#line 62
  printf((char const   */* __restrict  */)tmp, "frequency");
  }
#line 74
  return;
}
}
#line 76 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/frequency.c"
cmd_t cmd_frequency  =    {(char *)"frequency", (char *)"setup JTAG frequency", & cmd_frequency_help, & cmd_frequency_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/flashmem.c"
static int cmd_flashmem_run(chain_t *chain , char **params ) 
{ 
  int msbin ;
  uint32_t adr ;
  FILE *f ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 40
  adr = (uint32_t )0;
#line 43
  tmp = cmd_params(params);
  }
#line 43
  if (tmp != 3) {
#line 44
    return (-1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 48
    return (1);
  }
  {
#line 51
  tmp___1 = strcasecmp("msbin", (char const   *)*(params + 1));
#line 51
  msbin = tmp___1 == 0;
  }
#line 52
  if (! msbin) {
    {
#line 52
    tmp___2 = cmd_get_number(*(params + 1), & adr);
    }
#line 52
    if (tmp___2) {
#line 53
      return (-1);
    }
  }
  {
#line 55
  f = fopen((char const   */* __restrict  */)*(params + 2), (char const   */* __restrict  */)"rb");
  }
#line 56
  if (! f) {
    {
#line 57
    tmp___3 = gettext("Unable to open file `%s\'!\n");
#line 57
    printf((char const   */* __restrict  */)tmp___3, *(params + 2));
    }
#line 58
    return (1);
  }
#line 60
  if (msbin) {
    {
#line 61
    flashmsbin(bus, f);
    }
  } else {
    {
#line 63
    flashmem(bus, f, adr);
    }
  }
  {
#line 64
  fclose(f);
  }
#line 66
  return (1);
}
}
#line 69 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/flashmem.c"
static void cmd_flashmem_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 74
  tmp = gettext("Usage: %s ADDR FILENAME\nUsage: %s FILENAME\nProgram FILENAME content to flash memory.\n\nADDR       target address for raw binary image\nFILENAME   name of the input file\n%-10s FILENAME is in MS .bin format (for WinCE)\n\nADDR could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 74
  printf((char const   */* __restrict  */)tmp, "flashmem", "flashmem msbin", "msbin");
#line 88
  i = 0;
  }
  {
#line 88
  while (1) {
    while_continue: /* CIL Label */ ;
#line 88
    if (! flash_drivers[i]) {
#line 88
      goto while_break;
    }
    {
#line 89
    tmp___0 = gettext((flash_drivers[i])->description);
#line 89
    tmp___1 = gettext((flash_drivers[i])->name);
#line 89
    tmp___2 = gettext("%s\n     %s\n");
#line 89
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 88
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return;
}
}
#line 92 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/flashmem.c"
cmd_t cmd_flashmem  =    {(char *)"flashmem", (char *)"burn flash memory with data from a file", & cmd_flashmem_help,
    & cmd_flashmem_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/eraseflash.c"
static int cmd_eraseflash_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  unsigned int number ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 39
  adr = (uint32_t )0;
#line 40
  number = 0U;
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 3) {
#line 43
    return (-1);
  }
  {
#line 44
  tmp___0 = cmd_test_cable(chain);
  }
#line 44
  if (! tmp___0) {
#line 45
    return (1);
  }
#line 46
  if (! bus) {
    {
#line 47
    tmp___1 = gettext("Error: Bus driver missing.\n");
#line 47
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 48
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & adr);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
  {
#line 52
  tmp___3 = cmd_get_number(*(params + 2), & number);
  }
#line 52
  if (tmp___3) {
#line 53
    return (-1);
  }
  {
#line 54
  flasherase(bus, adr, (int )number);
  }
#line 56
  return (1);
}
}
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/eraseflash.c"
static void cmd_eraseflash_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 64
  tmp = gettext("Usage: %s ADDR BLOCKS\nErase flash memory from ADDR.\n\nADDR       target addres for erasing block\nBLOCKS     number of blocks to erase\n\nADDR and BLOCKS could be in decimal or hexadecimal (prefixed with 0x) form.\n\nSupported Flash Memories:\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "eraseflash");
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! flash_drivers[i]) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = gettext((flash_drivers[i])->description);
#line 77
    tmp___1 = gettext((flash_drivers[i])->name);
#line 77
    tmp___2 = gettext("%s\n     %s\n");
#line 77
    printf((char const   */* __restrict  */)tmp___2, tmp___1, tmp___0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/eraseflash.c"
cmd_t cmd_eraseflash  =    {(char *)"eraseflash", (char *)"erase flash memory by number of blocks", & cmd_eraseflash_help,
    & cmd_eraseflash_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/endian.c"
static int cmd_endian_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp > 2) {
#line 38
    return (-1);
  }
#line 40
  if (! *(params + 1)) {
#line 41
    if (big_endian) {
      {
#line 42
      tmp___0 = gettext("Endianess for external files: big\n");
#line 42
      printf((char const   */* __restrict  */)tmp___0);
      }
    } else {
      {
#line 44
      tmp___1 = gettext("Endianess for external files: little\n");
#line 44
      printf((char const   */* __restrict  */)tmp___1);
      }
    }
#line 45
    return (1);
  }
  {
#line 49
  tmp___2 = strcasecmp((char const   *)*(params + 1), "little");
  }
#line 49
  if (tmp___2 == 0) {
#line 50
    big_endian = 0;
#line 51
    return (1);
  }
  {
#line 53
  tmp___3 = strcasecmp((char const   *)*(params + 1), "big");
  }
#line 53
  if (tmp___3 == 0) {
#line 54
    big_endian = 1;
#line 55
    return (1);
  }
#line 58
  return (-1);
}
}
#line 61 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/endian.c"
static void cmd_endian_help(void) 
{ 
  char *tmp ;

  {
  {
#line 64
  tmp = gettext("Usage: %s\nSet or print endianess for external files.\n");
#line 64
  printf((char const   */* __restrict  */)tmp, "endian [little|big]");
  }
#line 68
  return;
}
}
#line 70 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/endian.c"
cmd_t cmd_endian  =    {(char *)"endian", (char *)"set/print endianess", & cmd_endian_help, & cmd_endian_run};
#line 276 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/dr.c"
static int cmd_dr_run(chain_t *chain , char **params ) 
{ 
  int dir ;
  tap_register *r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned int bit ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 38
  dir = 1;
#line 41
  tmp = cmd_params(params);
  }
#line 41
  if (tmp < 1) {
#line 42
    return (-1);
  } else {
    {
#line 41
    tmp___0 = cmd_params(params);
    }
#line 41
    if (tmp___0 > 2) {
#line 42
      return (-1);
    }
  }
  {
#line 44
  tmp___1 = cmd_test_cable(chain);
  }
#line 44
  if (! tmp___1) {
#line 45
    return (1);
  }
#line 47
  if (! chain->parts) {
    {
#line 48
    tmp___2 = gettext("Run \"detect\" first.\n");
#line 48
    printf((char const   */* __restrict  */)tmp___2);
    }
#line 49
    return (1);
  }
#line 52
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 53
    tmp___3 = gettext("%s: no active part\n");
#line 53
    printf((char const   */* __restrict  */)tmp___3, "dr");
    }
#line 54
    return (1);
  }
#line 57
  if ((unsigned long )(*((chain->parts)->parts + chain->active_part))->active_instruction == (unsigned long )((void *)0)) {
    {
#line 58
    tmp___4 = gettext("%s: part without active instruction\n");
#line 58
    printf((char const   */* __restrict  */)tmp___4, "dr");
    }
#line 59
    return (1);
  }
#line 61
  if ((unsigned long )((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register == (unsigned long )((void *)0)) {
    {
#line 62
    tmp___5 = gettext("%s: part without active data register\n");
#line 62
    printf((char const   */* __restrict  */)tmp___5, "dr");
    }
#line 63
    return (1);
  }
#line 66
  if (*(params + 1)) {
    {
#line 67
    tmp___11 = strcasecmp((char const   *)*(params + 1), "in");
    }
#line 67
    if (tmp___11 == 0) {
#line 68
      dir = 0;
    } else {
      {
#line 69
      tmp___10 = strcasecmp((char const   *)*(params + 1), "out");
      }
#line 69
      if (tmp___10 == 0) {
#line 70
        dir = 1;
      } else {
        {
#line 73
        tmp___6 = strspn((char const   *)*(params + 1), "01");
#line 73
        tmp___7 = strlen((char const   *)*(params + 1));
        }
#line 73
        if (tmp___6 != tmp___7) {
#line 74
          return (-1);
        }
        {
#line 77
        r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
#line 78
        tmp___9 = strlen((char const   *)*(params + 1));
        }
#line 78
        if ((size_t )r->len != tmp___9) {
          {
#line 79
          tmp___8 = gettext("%s: register length mismatch\n");
#line 79
          printf((char const   */* __restrict  */)tmp___8, "dr");
          }
#line 80
          return (1);
        }
#line 82
        bit = 0U;
        {
#line 82
        while (1) {
          while_continue: /* CIL Label */ ;
#line 82
          if (! *(*(params + 1) + bit)) {
#line 82
            goto while_break;
          }
#line 83
          *(r->data + ((unsigned int )(r->len - 1) - bit)) = (char )((int )*(*(params + 1) + bit) == 49);
#line 82
          bit ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 86
        dir = 0;
      }
    }
  }
#line 90
  if (dir) {
#line 91
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->out;
  } else {
#line 93
    r = (((*((chain->parts)->parts + chain->active_part))->active_instruction)->data_register)->in;
  }
  {
#line 94
  tmp___12 = register_get_string((tap_register const   *)r);
#line 94
  tmp___13 = gettext("%s\n");
#line 94
  printf((char const   */* __restrict  */)tmp___13, tmp___12);
  }
#line 96
  return (1);
}
}
#line 99 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/dr.c"
static void cmd_dr_help(void) 
{ 
  char *tmp ;

  {
  {
#line 102
  tmp = gettext("Usage: %s [DIR]\nUsage: %s BITSTRING\nDisplay input or output data register content or set current register.\n\nDIR           requested data register; possible values: \'in\' for\n              input and \'out\' for output; default is \'out\'\nBITSTRING     set current data register with BITSTRING (e.g. 01010)\n");
#line 102
  printf((char const   */* __restrict  */)tmp, "dr", "dr");
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/dr.c"
cmd_t cmd_dr  =    {(char *)"dr", (char *)"display active data register for a part", & cmd_dr_help,
    & cmd_dr_run};
#line 33 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/discovery.c"
static int cmd_discovery_run(chain_t *chain , char **params ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = cmd_params(params);
  }
#line 36
  if (tmp != 1) {
#line 37
    return (-1);
  }
  {
#line 39
  tmp___0 = cmd_test_cable(chain);
  }
#line 39
  if (! tmp___0) {
#line 40
    return (1);
  }
  {
#line 42
  discovery(chain);
  }
#line 44
  return (1);
}
}
#line 47 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/discovery.c"
static void cmd_discovery_help(void) 
{ 
  char *tmp ;

  {
  {
#line 50
  tmp = gettext("Usage: %s\nDiscovery of unknown parts in the JTAG chain.\n\n\'%s\' attempts to detect these parameters of an unknown JTAG\nchain:\n 1. IR (instruction register) length\n 2. DR (data register) length for all possible instructions\n\nWarning: This may be dangerous for some parts (especially if the\npart doesn\'t have TRST signal).\n");
#line 50
  printf((char const   */* __restrict  */)tmp, "discovery", "discovery");
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/discovery.c"
cmd_t cmd_discovery  =    {(char *)"discovery", (char *)"discovery of unknown parts in the JTAG chain", & cmd_discovery_help,
    & cmd_discovery_run};
#line 36 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/detect.c"
static int cmd_detect_run(chain_t *chain , char **params ) 
{ 
  int i ;
  bus_t *abus ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 1) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_test_cable(chain);
  }
#line 45
  if (! tmp___0) {
#line 46
    return (1);
  }
  {
#line 48
  buses_free();
#line 49
  parts_free(chain->parts);
#line 50
  chain->parts = (parts_t *)((void *)0);
#line 51
  tmp___1 = jtag_get_data_dir();
#line 51
  detect_parts(chain, tmp___1);
  }
#line 52
  if (! chain->parts) {
#line 53
    return (1);
  }
#line 54
  if (! (chain->parts)->len) {
    {
#line 55
    parts_free(chain->parts);
#line 56
    chain->parts = (parts_t *)((void *)0);
    }
#line 57
    return (1);
  }
  {
#line 59
  parts_set_instruction(chain->parts, "SAMPLE/PRELOAD");
#line 60
  chain_shift_instructions(chain);
#line 61
  chain_shift_data_registers(chain, 1);
#line 62
  parts_set_instruction(chain->parts, "BYPASS");
#line 63
  chain_shift_instructions(chain);
#line 66
  i = 0;
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
#line 66
    if (! (i < buses.len)) {
#line 66
      goto while_break;
    }
#line 68
    abus = *(buses.buses + i);
#line 69
    if ((abus->driver)->init) {
      {
#line 71
      tmp___2 = (*((abus->driver)->init))(abus);
      }
#line 71
      if (tmp___2) {
#line 72
        return (-1);
      }
    }
#line 66
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return (1);
}
}
#line 79 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/detect.c"
static void cmd_detect_help(void) 
{ 
  char *tmp ;

  {
  {
#line 82
  tmp = gettext("Usage: %s\nDetect parts on the JTAG chain.\n\nOutput from this command is a list of the detected parts.\nIf no parts are detected other commands may not work properly.\n");
#line 82
  printf((char const   */* __restrict  */)tmp, "detect");
  }
#line 89
  return;
}
}
#line 91 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/detect.c"
cmd_t cmd_detect  =    {(char *)"detect", (char *)"detect parts on the JTAG chain", & cmd_detect_help,
    & cmd_detect_run};
#line 32 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/detectflash.c"
static int cmd_detectflash_run(chain_t *chain , char **params ) 
{ 
  uint32_t adr ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 37
  tmp = cmd_params(params);
  }
#line 37
  if (tmp != 2) {
#line 38
    return (-1);
  }
#line 40
  if (! bus) {
    {
#line 41
    tmp___0 = gettext("Error: Bus driver missing.\n");
#line 41
    printf((char const   */* __restrict  */)tmp___0);
    }
#line 42
    return (1);
  }
  {
#line 45
  tmp___1 = cmd_get_number(*(params + 1), & adr);
  }
#line 45
  if (tmp___1) {
#line 46
    return (-1);
  }
  {
#line 48
  detectflash(bus, adr);
  }
#line 50
  return (1);
}
}
#line 53 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/detectflash.c"
static void cmd_detectflash_help(void) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("Usage: %s ADDRESS\nDetect flash memory type connected to a part.\n\nADDRESS    Base address for memory region\n");
#line 56
  printf((char const   */* __restrict  */)tmp, "detectflash");
  }
#line 62
  return;
}
}
#line 64 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/detectflash.c"
cmd_t cmd_detectflash  =    {(char *)"detectflash", (char *)"detect parameters of flash chips attached to a part",
    & cmd_detectflash_help, & cmd_detectflash_run};
#line 37 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/debug.c"
static int cmd_debug_run(chain_t *chain , char **params ) 
{ 
  unsigned int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 42
  tmp = cmd_params(params);
  }
#line 42
  if (tmp != 2) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___0 = cmd_get_number(*(params + 1), & i);
  }
#line 45
  if (tmp___0) {
#line 46
    return (1);
  }
#line 48
  debug_mode = (int )i;
#line 49
  return (1);
}
}
#line 52 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/debug.c"
static void cmd_debug_help(void) 
{ 
  char *tmp ;

  {
  {
#line 55
  tmp = gettext("Usage: %s  n\nEnabled debugging.\n\nn =1 fileio, 2=tap commands, 4 =?\n");
#line 55
  printf((char const   */* __restrict  */)tmp, "debug n");
  }
#line 61
  return;
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/debug.c"
cmd_t cmd_debug  =    {(char *)"debug", (char *)"debug jtag program", & cmd_debug_help, & cmd_debug_run};
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cmd.c"
cmd_t cmd_cable ;
#line 48
cmd_t cmd_bit ;
#line 53
cmd_t cmd_bus ;
#line 71
cmd_t cmd_addpart ;
#line 76
cmd_t cmd_bsdl ;
#line 80 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cmd.c"
cmd_t const   *cmds[39]  = 
#line 80
  {      (cmd_t const   *)(& cmd_quit),      (cmd_t const   *)(& cmd_help),      (cmd_t const   *)(& cmd_frequency),      (cmd_t const   *)(& cmd_cable), 
        (cmd_t const   *)(& cmd_reset),      (cmd_t const   *)(& cmd_discovery),      (cmd_t const   *)(& cmd_idcode),      (cmd_t const   *)(& cmd_detect), 
        (cmd_t const   *)(& cmd_signal),      (cmd_t const   *)(& cmd_scan),      & cmd_salias,      (cmd_t const   *)(& cmd_bit), 
        (cmd_t const   *)(& cmd_register),      & cmd_initbus,      (cmd_t const   *)(& cmd_print),      (cmd_t const   *)(& cmd_part), 
        (cmd_t const   *)(& cmd_bus),      (cmd_t const   *)(& cmd_instruction),      (cmd_t const   *)(& cmd_shift),      (cmd_t const   *)(& cmd_dr), 
        (cmd_t const   *)(& cmd_get),      (cmd_t const   *)(& cmd_test),      (cmd_t const   *)(& cmd_shell),      (cmd_t const   *)(& cmd_set), 
        (cmd_t const   *)(& cmd_endian),      (cmd_t const   *)(& cmd_peek),      (cmd_t const   *)(& cmd_poke),      (cmd_t const   *)(& cmd_readmem), 
        (cmd_t const   *)(& cmd_writemem),      (cmd_t const   *)(& cmd_detectflash),      (cmd_t const   *)(& cmd_flashmem),      (cmd_t const   *)(& cmd_eraseflash), 
        (cmd_t const   *)(& cmd_script),      (cmd_t const   *)(& cmd_include),      (cmd_t const   *)(& cmd_addpart),      (cmd_t const   *)(& cmd_svf), 
        (cmd_t const   *)(& cmd_bsdl),      (cmd_t const   *)(& cmd_debug),      (cmd_t const   *)((void *)0)};
#line 160 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cmd.c"
int cmd_test_cable(chain_t *chain ) 
{ 
  char *tmp ;

  {
#line 163
  if (chain->cable) {
#line 164
    return (1);
  }
  {
#line 166
  tmp = gettext("Error: Cable not configured. Please use \'%s\' command first!\n");
#line 166
  printf((char const   */* __restrict  */)tmp, "cable");
  }
#line 167
  return (0);
}
}
#line 172 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cmd.c"
int cmd_run(chain_t *chain , char **params ) 
{ 
  int i ;
  int pidx ;
  size_t len ;
  int r ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 178
  if (! *(params + 0)) {
#line 179
    return (1);
  }
  {
#line 181
  pidx = -1;
#line 182
  len = strlen((char const   *)*(params + 0));
#line 184
  i = 0;
  }
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! cmds[i]) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp___1 = strcasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 0));
    }
#line 185
    if (tmp___1 == 0) {
      run_cmd: 
      {
#line 188
      r = (*((cmds[i])->run))(chain, params);
      }
#line 189
      if (r < 0) {
        {
#line 190
        tmp = gettext("%s: syntax error!\n");
#line 190
        printf((char const   */* __restrict  */)tmp, *(params + 0));
        }
      }
#line 191
      return (r);
    } else {
      {
#line 192
      tmp___0 = strncasecmp((char const   *)(cmds[i])->name, (char const   *)*(params + 0),
                            len);
      }
#line 192
      if (tmp___0 == 0) {
#line 193
        if (pidx == -1) {
#line 194
          pidx = i;
        } else {
#line 196
          pidx = -2;
        }
      }
    }
#line 184
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 201
  if (pidx == -2) {
#line 201
    goto case_neg_2;
  }
#line 202
  if (pidx == -1) {
#line 202
    goto case_neg_1;
  }
#line 203
  goto switch_default;
  case_neg_2: /* CIL Label */ 
  {
#line 201
  tmp___2 = gettext("%s: Ambiguous command\n");
#line 201
  printf((char const   */* __restrict  */)tmp___2, *(params + 0));
  }
#line 201
  goto switch_break;
  case_neg_1: /* CIL Label */ 
  {
#line 202
  tmp___3 = gettext("%s: unknown command\n");
#line 202
  printf((char const   */* __restrict  */)tmp___3, *(params + 0));
  }
#line 202
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 203
  i = pidx;
#line 203
  goto run_cmd;
  switch_break: /* CIL Label */ ;
  }
#line 206
  return (1);
}
}
#line 209 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cmd.c"
int cmd_params(char **params ) 
{ 
  int i ;

  {
#line 212
  i = 0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! *(params + i)) {
#line 214
      goto while_break;
    }
#line 215
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  return (i);
}
}
#line 220 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cmd.c"
int cmd_get_number(char *s , unsigned int *i ) 
{ 
  int n ;
  int r ;
  size_t l ;

  {
#line 227
  if (! s) {
#line 228
    return (-1);
  } else
#line 227
  if (! i) {
#line 228
    return (-1);
  }
  {
#line 230
  l = strlen((char const   *)s);
#line 232
  n = -1;
#line 233
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"0x%x%n",
             i, & n);
  }
#line 234
  if (r == 1) {
#line 234
    if ((size_t )n == l) {
#line 235
      return (0);
    }
  }
  {
#line 237
  n = -1;
#line 238
  r = sscanf((char const   */* __restrict  */)s, (char const   */* __restrict  */)"%u%n",
             i, & n);
  }
#line 239
  if (r == 1) {
#line 239
    if ((size_t )n == l) {
#line 240
      return (0);
    }
  }
#line 242
  return (-1);
}
}
#line 40 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cable.c"
static int cmd_cable_run(chain_t *chain , char **params ) 
{ 
  cable_t *cable ;
  int i ;
  int paramc ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmparam ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 45
  tmp = cmd_params(params);
#line 45
  paramc = tmp;
  }
#line 48
  if (paramc < 2) {
#line 48
    return (-1);
  }
#line 51
  i = 0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    if (! parport_drivers[i]) {
#line 51
      goto while_break;
    }
    {
#line 52
    tmp___0 = strcasecmp((char const   *)*(params + 1), (parport_drivers[i])->type);
    }
#line 52
    if (tmp___0 == 0) {
#line 53
      goto while_break;
    }
#line 51
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 55
  if ((unsigned long )parport_drivers[i] != (unsigned long )((parport_driver_t *)0)) {
    {
#line 58
    tmp___1 = gettext("Note: the \'cable\' command syntax changed, please read the help text\n");
#line 58
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 59
    if (paramc >= 4) {
#line 62
      tmparam = *(params + 3);
#line 63
      *(params + 3) = *(params + 2);
#line 64
      *(params + 2) = *(params + 1);
#line 65
      *(params + 1) = tmparam;
    } else {
#line 68
      return (-1);
    }
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 72
    if (! cable_drivers[i]) {
#line 72
      goto while_break___0;
    }
    {
#line 73
    tmp___2 = strcasecmp((char const   *)*(params + 1), (cable_drivers[i])->name);
    }
#line 73
    if (tmp___2 == 0) {
#line 74
      goto while_break___0;
    }
#line 72
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 75
  if (! cable_drivers[i]) {
    {
#line 76
    tmp___3 = gettext("Unknown cable type: %s\n");
#line 76
    printf((char const   */* __restrict  */)tmp___3, *(params + 1));
    }
#line 77
    return (1);
  }
#line 80
  if (paramc >= 3) {
    {
#line 82
    tmp___4 = strcasecmp((char const   *)*(params + 2), "help");
    }
#line 82
    if (tmp___4 == 0) {
      {
#line 84
      (*((cable_drivers[i])->help))((cable_drivers[i])->name);
      }
#line 85
      return (1);
    }
  }
#line 89
  if (bus) {
    {
#line 90
    (*((bus->driver)->free_bus))(bus);
#line 91
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 94
  chain_disconnect(chain);
#line 96
  tmp___5 = calloc((size_t )1, sizeof(cable_t ));
#line 96
  cable = (cable_t *)tmp___5;
  }
#line 97
  if (! cable) {
    {
#line 98
    tmp___6 = gettext("%s(%d) malloc failed!\n");
#line 98
    printf((char const   */* __restrict  */)tmp___6, "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cable.c",
           98);
    }
#line 99
    return (1);
  }
  {
#line 102
  cable->driver = cable_drivers[i];
#line 104
  params ++;
#line 104
  tmp___8 = (*((cable->driver)->connect))(params, cable);
  }
#line 104
  if (tmp___8) {
    {
#line 105
    tmp___7 = gettext("Error: Cable connection failed!\n");
#line 105
    printf((char const   */* __restrict  */)tmp___7);
#line 106
    free((void *)cable);
    }
#line 107
    return (1);
  }
  {
#line 110
  chain->cable = cable;
#line 112
  tmp___10 = cable_init(chain->cable);
  }
#line 112
  if (tmp___10) {
    {
#line 113
    tmp___9 = gettext("Error: Cable initialization failed!\n");
#line 113
    printf((char const   */* __restrict  */)tmp___9);
#line 114
    chain_disconnect(chain);
    }
#line 115
    return (1);
  }
  {
#line 117
  chain_set_trst(chain, 0);
#line 118
  chain_set_trst(chain, 1);
#line 119
  tap_reset(chain);
  }
#line 121
  return (1);
}
}
#line 124 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cable.c"
static void cmd_cable_help(void) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 129
  tmp = gettext("Usage: %s DRIVER [DRIVER_OPTS]\nSelect JTAG cable type.\n\nDRIVER      name of cable\nDRIVER_OPTS options for the selected cable\n\nType \"cable DRIVER help\" for info about options for cable DRIVER.\n\nList of supported cables:\n");
#line 129
  printf((char const   */* __restrict  */)tmp, "cable");
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! cable_drivers[i]) {
#line 141
      goto while_break;
    }
    {
#line 142
    tmp___0 = gettext((cable_drivers[i])->description);
#line 142
    tmp___1 = gettext("%-13s %s\n");
#line 142
    printf((char const   */* __restrict  */)tmp___1, (cable_drivers[i])->name, tmp___0);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  return;
}
}
#line 145 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/cable.c"
cmd_t cmd_cable  =    {(char *)"cable", (char *)"select JTAG cable", & cmd_cable_help, & cmd_cable_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bus.c"
static int cmd_bus_run(chain_t *chain , char **params ) 
{ 
  unsigned int n ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_test_cable(chain);
  }
#line 42
  if (! tmp___0) {
#line 43
    return (1);
  }
#line 45
  if (! chain->parts) {
    {
#line 46
    tmp___1 = gettext("Run \"detect\" first.\n");
#line 46
    printf((char const   */* __restrict  */)tmp___1);
    }
#line 47
    return (1);
  }
  {
#line 50
  tmp___2 = cmd_get_number(*(params + 1), & n);
  }
#line 50
  if (tmp___2) {
#line 51
    return (-1);
  }
#line 53
  if (n >= (unsigned int )buses.len) {
    {
#line 54
    tmp___3 = gettext("%s: invalid bus number\n");
#line 54
    printf((char const   */* __restrict  */)tmp___3, "bus");
    }
#line 55
    return (1);
  }
#line 58
  bus = *(buses.buses + n);
#line 60
  return (1);
}
}
#line 63 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bus.c"
static void cmd_bus_help(void) 
{ 
  char *tmp ;

  {
  {
#line 66
  tmp = gettext("Usage: %s BUS\nChange active bus.\n\nBUS           bus number\n");
#line 66
  printf((char const   */* __restrict  */)tmp, "bus");
  }
#line 72
  return;
}
}
#line 74 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bus.c"
cmd_t cmd_bus  =    {(char *)"bus", (char *)"change active bus", & cmd_bus_help, & cmd_bus_run};
#line 35 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bsdl.c"
static int cmd_bsdl_run(chain_t *chain , char **params ) 
{ 
  int num_params ;
  int result ;
  bsdl_globs_t *globs ;
  int debug_save ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 38
  result = -1;
#line 39
  globs = & chain->bsdl;
#line 41
  num_params = cmd_params(params);
  }
#line 42
  if (num_params >= 2) {
    {
#line 43
    tmp___1 = strcmp((char const   *)*(params + 1), "test");
    }
#line 43
    if (tmp___1 == 0) {
#line 46
      debug_save = globs->debug;
#line 47
      globs->debug = 1;
#line 48
      if (num_params == 3) {
        {
#line 49
        tmp___0 = bsdl_read_file(chain, (char const   *)*(params + 2), (1 << 4) | ((((1 << 3) | (1 << 2)) | (1 << 1)) | 1),
                                 (char const   *)((void *)0));
        }
#line 49
        if (tmp___0 >= 0) {
#line 49
          result = 1;
        } else {
#line 49
          result = -1;
        }
      } else
#line 50
      if (num_params == 2) {
        {
#line 51
        bsdl_scan_files(chain, (char const   *)((void *)0), (1 << 4) | ((((1 << 3) | (1 << 2)) | (1 << 1)) | 1));
#line 52
        result = 1;
        }
      }
#line 54
      globs->debug = debug_save;
    }
    {
#line 57
    tmp___4 = strcmp((char const   *)*(params + 1), "dump");
    }
#line 57
    if (tmp___4 == 0) {
#line 58
      if (num_params == 3) {
        {
#line 59
        tmp___3 = bsdl_read_file(chain, (char const   *)*(params + 2), ((((1 << 4) | (1 << 5)) | (1 << 1)) | (1 << 2)) | (1 << 3),
                                 (char const   *)((void *)0));
        }
#line 59
        if (tmp___3 >= 0) {
#line 59
          result = 1;
        } else {
#line 59
          result = -1;
        }
      } else
#line 60
      if (num_params == 2) {
        {
#line 61
        bsdl_scan_files(chain, (char const   *)((void *)0), ((((1 << 4) | (1 << 5)) | (1 << 1)) | (1 << 2)) | (1 << 3));
#line 62
        result = 1;
        }
      }
    }
#line 66
    if (num_params == 3) {
      {
#line 67
      tmp___5 = strcmp((char const   *)*(params + 1), "path");
      }
#line 67
      if (tmp___5 == 0) {
        {
#line 68
        bsdl_set_path(chain, (char const   *)*(params + 2));
#line 69
        result = 1;
        }
      }
      {
#line 72
      tmp___8 = strcmp((char const   *)*(params + 1), "debug");
      }
#line 72
      if (tmp___8 == 0) {
        {
#line 73
        tmp___6 = strcmp((char const   *)*(params + 2), "on");
        }
#line 73
        if (tmp___6 == 0) {
#line 74
          globs->debug = 1;
#line 75
          result = 1;
        }
        {
#line 77
        tmp___7 = strcmp((char const   *)*(params + 2), "off");
        }
#line 77
        if (tmp___7 == 0) {
#line 78
          globs->debug = 0;
#line 79
          result = 1;
        }
      }
    }
  }
#line 85
  return (result);
}
}
#line 89 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bsdl.c"
static void cmd_bsdl_help(void) 
{ 
  char *tmp ;

  {
  {
#line 92
  tmp = gettext("Usage: %s path PATHLIST\nUsage: %s test [FILE]\nUsage: %s dump [FILE]\nUsage: %s debug on|off\nManage BSDL files\n\nPATHLIST semicolon separated list of directory paths to search for BSDL files\nFILE file containing part description in BSDL format\n");
#line 92
  printf((char const   */* __restrict  */)tmp, "bsdl", "bsdl", "bsdl", "bsdl");
  }
#line 102
  return;
}
}
#line 104 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bsdl.c"
cmd_t cmd_bsdl  =    {(char *)"bsdl", (char *)"manage BSDL files", & cmd_bsdl_help, & cmd_bsdl_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bit.c"
static void cmd_bit_print_params(char **params , unsigned int parameters , char *command ) 
{ 
  unsigned int i ;

  {
  {
#line 39
  strcpy((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + 0));
#line 40
  i = 1U;
  }
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < parameters)) {
#line 40
      goto while_break;
    }
    {
#line 41
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)" ");
#line 42
    strcat((char */* __restrict  */)command, (char const   */* __restrict  */)*(params + i));
#line 40
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bit.c"
static int cmd_bit_run(chain_t *chain , char **params ) 
{ 
  part_t *part ;
  data_register *bsr ;
  unsigned int bit ;
  int type ;
  int safe ;
  unsigned int control ;
  unsigned int parameters ;
  int tmp ;
  char command[1024] ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  signal_t *tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  size_t tmp___22 ;
  int tmp___23 ;

  {
  {
#line 55
  tmp = cmd_params(params);
#line 55
  parameters = (unsigned int )tmp;
#line 58
  cmd_bit_print_params(params, parameters, command);
  }
#line 60
  if (parameters != 5U) {
#line 60
    if (parameters != 8U) {
      {
#line 61
      tmp___0 = gettext("%s: invalid number of parameters (%d) for command \'%s\'\n");
#line 61
      printf((char const   */* __restrict  */)tmp___0, "bit", parameters, command);
      }
#line 62
      return (-1);
    }
  }
  {
#line 65
  tmp___2 = cmd_test_cable(chain);
  }
#line 65
  if (! tmp___2) {
    {
#line 66
    tmp___1 = gettext("%s: cable test failed for command \'%s\'\n");
#line 66
    printf((char const   */* __restrict  */)tmp___1, "bit", command);
    }
#line 67
    return (1);
  }
#line 70
  if (! chain->parts) {
    {
#line 71
    tmp___3 = gettext("Run \"detect\" first.\n");
#line 71
    printf((char const   */* __restrict  */)tmp___3);
    }
#line 72
    return (1);
  }
#line 75
  if (chain->active_part >= (chain->parts)->len) {
    {
#line 76
    tmp___4 = gettext("%s: no active part\n");
#line 76
    printf((char const   */* __restrict  */)tmp___4, "bit");
    }
#line 77
    return (1);
  }
  {
#line 80
  part = *((chain->parts)->parts + chain->active_part);
#line 81
  bsr = part_find_data_register(part, "BSR");
  }
#line 82
  if ((unsigned long )bsr == (unsigned long )((void *)0)) {
    {
#line 83
    tmp___5 = gettext("%s: missing Boundary Scan Register (BSR) for command \'%s\'\n");
#line 83
    printf((char const   */* __restrict  */)tmp___5, "bit", command);
    }
#line 84
    return (1);
  }
  {
#line 88
  tmp___7 = cmd_get_number(*(params + 1), & bit);
  }
#line 88
  if (tmp___7) {
    {
#line 89
    tmp___6 = gettext("%s: unable to get boundary bit number for command \'%s\'\n");
#line 89
    printf((char const   */* __restrict  */)tmp___6, "bit", command);
    }
#line 90
    return (-1);
  }
#line 93
  if (bit >= (unsigned int )(bsr->in)->len) {
    {
#line 94
    tmp___8 = gettext("%s: invalid boundary bit number for command \'%s\'\n");
#line 94
    printf((char const   */* __restrict  */)tmp___8, "bit", command);
    }
#line 95
    return (1);
  }
#line 97
  if ((unsigned long )*(part->bsbits + bit) != (unsigned long )((void *)0)) {
    {
#line 98
    tmp___9 = gettext("%s: duplicate bit declaration for command \'%s\'\n");
#line 98
    printf((char const   */* __restrict  */)tmp___9, "bit", command);
    }
#line 99
    return (1);
  }
  {
#line 103
  tmp___11 = strlen((char const   *)*(params + 2));
  }
#line 103
  if (tmp___11 != 1UL) {
    {
#line 104
    tmp___10 = gettext("%s: invalid bit type length for command \'%s\'\n");
#line 104
    printf((char const   */* __restrict  */)tmp___10, "bit", command);
    }
#line 105
    return (-1);
  }
  {
#line 109
  if ((int )*(*(params + 2) + 0) == 105) {
#line 109
    goto case_105;
  }
#line 109
  if ((int )*(*(params + 2) + 0) == 73) {
#line 109
    goto case_105;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 111) {
#line 113
    goto case_111;
  }
#line 113
  if ((int )*(*(params + 2) + 0) == 79) {
#line 113
    goto case_111;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 98) {
#line 117
    goto case_98;
  }
#line 117
  if ((int )*(*(params + 2) + 0) == 66) {
#line 117
    goto case_98;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 99) {
#line 121
    goto case_99;
  }
#line 121
  if ((int )*(*(params + 2) + 0) == 67) {
#line 121
    goto case_99;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 120) {
#line 125
    goto case_120;
  }
#line 125
  if ((int )*(*(params + 2) + 0) == 88) {
#line 125
    goto case_120;
  }
#line 128
  goto switch_default;
  case_105: /* CIL Label */ 
  case_73: /* CIL Label */ 
#line 110
  type = 1;
#line 111
  goto switch_break;
  case_111: /* CIL Label */ 
  case_79: /* CIL Label */ 
#line 114
  type = 2;
#line 115
  goto switch_break;
  case_98: /* CIL Label */ 
  case_66: /* CIL Label */ 
#line 118
  type = 5;
#line 119
  goto switch_break;
  case_99: /* CIL Label */ 
  case_67: /* CIL Label */ 
#line 122
  type = 3;
#line 123
  goto switch_break;
  case_120: /* CIL Label */ 
  case_88: /* CIL Label */ 
#line 126
  type = 4;
#line 127
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 129
  tmp___12 = gettext("%s: invalid bit type for command \'%s\'\n");
#line 129
  printf((char const   */* __restrict  */)tmp___12, "bit", command);
  }
#line 130
  return (-1);
  switch_break: /* CIL Label */ ;
  }
  {
#line 134
  tmp___14 = strlen((char const   *)*(params + 3));
  }
#line 134
  if (tmp___14 != 1UL) {
    {
#line 135
    tmp___13 = gettext("%s: invalid default value length for command \'%s\'\n");
#line 135
    printf((char const   */* __restrict  */)tmp___13, "bit", command);
    }
#line 136
    return (-1);
  }
#line 139
  if ((int )*(*(params + 3) + 0) == 49) {
#line 139
    safe = 1;
  } else {
#line 139
    safe = 0;
  }
  {
#line 140
  *((bsr->in)->data + bit) = (char )safe;
#line 143
  tmp___15 = part_find_signal(part, (char const   *)*(params + 4));
#line 143
  *(part->bsbits + bit) = bsbit_alloc((int )bit, (char const   *)*(params + 4), type,
                                      tmp___15, safe);
  }
#line 144
  if ((unsigned long )*(part->bsbits + bit) == (unsigned long )((void *)0)) {
    {
#line 145
    tmp___16 = gettext("%s: out of memory for command \'%s\'\n");
#line 145
    printf((char const   */* __restrict  */)tmp___16, "bit", command);
    }
#line 146
    return (1);
  }
  {
#line 150
  tmp___17 = cmd_params(params);
  }
#line 150
  if (tmp___17 == 5) {
#line 151
    return (1);
  }
  {
#line 154
  tmp___19 = cmd_get_number(*(params + 5), & control);
  }
#line 154
  if (tmp___19) {
    {
#line 155
    tmp___18 = gettext("%s: unable to get control bit number for command \'%s\'\n");
#line 155
    printf((char const   */* __restrict  */)tmp___18, "bit", command);
    }
#line 156
    return (-1);
  }
#line 158
  if (control >= (unsigned int )(bsr->in)->len) {
    {
#line 159
    tmp___20 = gettext("%s: invalid control bit number for command \'%s\'\n");
#line 159
    printf((char const   */* __restrict  */)tmp___20, "bit", command);
    }
#line 160
    return (1);
  }
  {
#line 162
  (*(part->bsbits + bit))->control = (int )control;
#line 165
  tmp___22 = strlen((char const   *)*(params + 6));
  }
#line 165
  if (tmp___22 != 1UL) {
    {
#line 166
    tmp___21 = gettext("%s: invalid control value length for command \'%s\'\n");
#line 166
    printf((char const   */* __restrict  */)tmp___21, "bit", command);
    }
#line 167
    return (-1);
  }
#line 169
  if ((int )*(*(params + 6) + 0) == 49) {
#line 169
    (*(part->bsbits + bit))->control_value = 1;
  } else {
#line 169
    (*(part->bsbits + bit))->control_value = 0;
  }
  {
#line 172
  tmp___23 = strcasecmp((char const   *)*(params + 7), "Z");
  }
#line 172
  if (tmp___23) {
#line 173
    return (-1);
  }
#line 175
  (*(part->bsbits + bit))->control_state = -1;
#line 177
  return (1);
}
}
#line 180 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bit.c"
static void cmd_bit_help(void) 
{ 
  char *tmp ;

  {
  {
#line 183
  tmp = gettext("Usage: %s NUMBER TYPE DEFAULT SIGNAL [CBIT CVAL CSTATE]\nDefine new BSR (Boundary Scan Register) bit for SIGNAL, with\nDEFAULT value.\n\nNUMBER        Bit number in the BSR\nTYPE          Bit type, valid values are I, O, B, C, and X\nDEFAULT       Default (safe) bit value, valid values are 1, 0, ?\nSIGNAL        Associated signal name\nCBIT          Control bit number\nCVAL          Control value\nCSTATE        Control state, valid state is only Z\n");
#line 183
  printf((char const   */* __restrict  */)tmp, "bit");
  }
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/bit.c"
cmd_t cmd_bit  =    {(char *)"bit", (char *)"define new BSR bit", & cmd_bit_help, & cmd_bit_run};
#line 34 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/addpart.c"
static int cmd_addpart_run(chain_t *chain , char **params ) 
{ 
  unsigned int len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 39
  tmp = cmd_params(params);
  }
#line 39
  if (tmp != 2) {
#line 40
    return (-1);
  }
  {
#line 42
  tmp___0 = cmd_get_number(*(params + 1), & len);
  }
#line 42
  if (tmp___0) {
#line 43
    return (-1);
  }
  {
#line 45
  tmp___1 = cmd_test_cable(chain);
  }
#line 45
  if (! tmp___1) {
#line 46
    return (1);
  }
  {
#line 48
  manual_add(chain, (int )len);
  }
#line 50
  if ((unsigned long )chain->parts == (unsigned long )((void *)0)) {
#line 51
    return (1);
  }
#line 53
  if ((chain->parts)->len == 0) {
    {
#line 54
    parts_free(chain->parts);
#line 55
    chain->parts = (parts_t *)((void *)0);
    }
  }
  {
#line 58
  parts_set_instruction(chain->parts, "BYPASS");
#line 59
  chain_shift_instructions(chain);
  }
#line 61
  return (1);
}
}
#line 65 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/addpart.c"
static void cmd_addpart_help(void) 
{ 
  char *tmp ;

  {
  {
#line 68
  tmp = gettext("Usage: %s IRLENGTH\nManually add a part to the end of the chain.\n\nIRLENGTH           instruction register length\n");
#line 68
  printf((char const   */* __restrict  */)tmp, "addpart");
  }
#line 74
  return;
}
}
#line 77 "/home/khheo/project/benchmark/urjtag-0.9/src/cmd/addpart.c"
cmd_t cmd_addpart  =    {(char *)"addpart", (char *)"manually adds parts on the JTAG chain", & cmd_addpart_help,
    & cmd_addpart_run};
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 678 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h"
extern int optind ;
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 66 "/usr/include/x86_64-linux-gnu/bits/getopt_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) getopt_long)(int ___argc ,
                                                                                                    char * const  *___argv ,
                                                                                                    char const   *__shortopts ,
                                                                                                    struct option  const  *__longopts ,
                                                                                                    int *__longind ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 58 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
int debug_mode  =    0;
#line 59 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
int big_endian  =    0;
#line 60 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
int interactive  =    0;
#line 67 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
static void jtag_create_jtagdir(void) 
{ 
  char *home ;
  char *tmp ;
  char *jdir ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 70
  tmp = getenv("HOME");
#line 70
  home = tmp;
  }
#line 73
  if (! home) {
#line 74
    return;
  }
  {
#line 76
  tmp___0 = strlen((char const   *)home);
#line 76
  tmp___1 = strlen(".jtag");
#line 76
  tmp___2 = malloc((tmp___0 + tmp___1) + 2UL);
#line 76
  jdir = (char *)tmp___2;
  }
#line 77
  if (! jdir) {
#line 78
    return;
  }
  {
#line 80
  strcpy((char */* __restrict  */)jdir, (char const   */* __restrict  */)home);
#line 81
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)"/");
#line 82
  strcat((char */* __restrict  */)jdir, (char const   */* __restrict  */)".jtag");
#line 88
  mkdir((char const   *)jdir, (__mode_t )((((448 | (256 >> 3)) | (64 >> 3)) | ((256 >> 3) >> 3)) | ((64 >> 3) >> 3)));
#line 91
  free((void *)jdir);
  }
#line 92
  return;
}
}
#line 150 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
static int jtag_readline_multiple_commands_support(chain_t *chain , char *line ) 
{ 
  int r ;
  char *nextcmd ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 153
  nextcmd = line;
#line 155
  if (! line) {
#line 156
    return (1);
  } else {
    {
#line 155
    tmp = strlen((char const   *)line);
    }
#line 155
    if (! (tmp > 0UL)) {
#line 156
      return (1);
    }
  }
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 159
    line = nextcmd;
#line 161
    nextcmd = strstr((char const   *)nextcmd, "::");
    }
#line 163
    if (nextcmd) {
#line 164
      tmp___0 = nextcmd;
#line 164
      nextcmd ++;
#line 164
      *tmp___0 = (char)0;
#line 165
      nextcmd ++;
      {
#line 166
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 166
        if (! ((int )*line == 58)) {
#line 166
          goto while_break___0;
        }
#line 166
        line ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 169
    r = jtag_parse_line(chain, line);
#line 171
    chain_flush(chain);
    }
#line 158
    if (nextcmd) {
#line 158
      if (! r) {
#line 158
        goto while_break;
      }
    } else {
#line 158
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return (r);
}
}
#line 178 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
static void jtag_readline_loop(chain_t *chain , char const   *prompt ) 
{ 
  char line[1024] ;
  int tmp ;
  char *tmp___0 ;

  {
#line 225
  line[0] = (char)0;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 228
    tmp = jtag_readline_multiple_commands_support(chain, line);
    }
#line 228
    if (! tmp) {
#line 229
      goto while_break;
    }
    {
#line 230
    printf((char const   */* __restrict  */)"%s", prompt);
#line 231
    fflush(stdout);
#line 226
    tmp___0 = fgets((char */* __restrict  */)(line), 1023, (FILE */* __restrict  */)stdin);
    }
#line 226
    if (! tmp___0) {
#line 226
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return;
}
}
#line 237 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
static int jtag_parse_rc(chain_t *chain ) 
{ 
  char *home ;
  char *tmp ;
  char *file ;
  int go ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 240
  tmp = getenv("HOME");
#line 240
  home = tmp;
  }
#line 244
  if (! home) {
#line 245
    return (1);
  }
  {
#line 247
  tmp___0 = strlen((char const   *)home);
#line 247
  tmp___1 = strlen(".jtag");
#line 247
  tmp___2 = strlen("rc");
#line 247
  tmp___3 = malloc(((tmp___0 + tmp___1) + tmp___2) + 3UL);
#line 247
  file = (char *)tmp___3;
  }
#line 248
  if (! file) {
#line 249
    return (1);
  }
  {
#line 251
  strcpy((char */* __restrict  */)file, (char const   */* __restrict  */)home);
#line 252
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 253
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)".jtag");
#line 254
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 255
  strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"rc");
#line 257
  go = jtag_parse_file(chain, (char const   *)file);
#line 259
  free((void *)file);
  }
#line 261
  return (go);
}
}
#line 264 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
static void cleanup(chain_t *chain ) 
{ 


  {
  {
#line 267
  cfi_array_free(cfi_array);
#line 268
  cfi_array = (cfi_array_t *)((void *)0);
  }
#line 270
  if (bus) {
    {
#line 271
    (*((bus->driver)->free_bus))(bus);
#line 272
    bus = (bus_t *)((void *)0);
    }
  }
  {
#line 274
  chain_free(chain);
#line 275
  chain = (chain_t *)((void *)0);
  }
#line 276
  return;
}
}
#line 278 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
char const   *jtag_argv0  ;
#line 308
int main(int argc , char * const  *argv ) ;
#line 308 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
static struct option long_options[6]  = {      {"version", 0, (int *)0, 'v'}, 
        {"norc", 0, (int *)0, 'n'}, 
        {"interactive", 0, (int *)0, 'i'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"quiet", 0, (int *)0, 'q'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 279 "/home/khheo/project/benchmark/urjtag-0.9/src/jtag.c"
int main(int argc , char * const  *argv ) 
{ 
  int go ;
  int i ;
  int c ;
  int norc ;
  int help ;
  int version ;
  int quiet ;
  chain_t *chain ;
  char *tmp ;
  __uid_t tmp___0 ;
  __uid_t tmp___1 ;
  int option_index ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char const   *tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 282
  go = 0;
#line 285
  norc = 0;
#line 286
  help = 0;
#line 287
  version = 0;
#line 288
  quiet = 0;
#line 289
  chain = (chain_t *)((void *)0);
#line 291
  jtag_argv0 = (char const   *)*(argv + 0);
#line 293
  tmp___0 = geteuid();
  }
#line 293
  if (tmp___0 == 0U) {
    {
#line 293
    tmp___1 = getuid();
    }
#line 293
    if (tmp___1 != 0U) {
      {
#line 295
      tmp = gettext("\'%s\' must not be run suid root!\n");
#line 295
      printf((char const   */* __restrict  */)tmp, "jtag");
      }
#line 296
      return (-1);
    }
  }
  {
#line 301
  setlocale(6, "");
#line 302
  bindtextdomain("urjtag", "/usr/local/share/locale");
#line 303
  textdomain("urjtag");
  }
  {
#line 306
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 319
    option_index = 0;
#line 321
    c = getopt_long(argc, argv, "vnhiq", (struct option  const  *)(long_options),
                    & option_index);
    }
#line 325
    if (c == -1) {
#line 326
      goto while_break;
    }
    {
#line 330
    if (c == 118) {
#line 330
      goto case_118;
    }
#line 334
    if (c == 110) {
#line 334
      goto case_110;
    }
#line 338
    if (c == 105) {
#line 338
      goto case_105;
    }
#line 347
    if (c == 113) {
#line 347
      goto case_113;
    }
#line 343
    goto switch_default;
    case_118: /* CIL Label */ 
#line 331
    version = 1;
#line 332
    goto switch_break;
    case_110: /* CIL Label */ 
#line 335
    norc = 1;
#line 336
    goto switch_break;
    case_105: /* CIL Label */ 
#line 339
    interactive = 1;
#line 340
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 344
    help = 1;
#line 345
    goto switch_break;
    case_113: /* CIL Label */ 
#line 348
    quiet = 1;
#line 349
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 353
  if (help) {
    {
#line 356
    tmp___2 = gettext("%s #%s\n");
#line 356
    printf((char const   */* __restrict  */)tmp___2, "UrJTAG 0.9", "1359");
#line 357
    printf((char const   */* __restrict  */)"\n");
#line 359
    tmp___3 = gettext("Usage: %s [OPTION] [FILE]\n");
#line 359
    printf((char const   */* __restrict  */)tmp___3, "jtag");
#line 360
    printf((char const   */* __restrict  */)"\n");
#line 362
    tmp___4 = gettext("  -h, --help          display this help and exit\n");
#line 362
    printf((char const   */* __restrict  */)tmp___4);
#line 363
    tmp___5 = gettext("  -v, --version       display version information and exit\n");
#line 363
    printf((char const   */* __restrict  */)tmp___5);
#line 364
    printf((char const   */* __restrict  */)"\n");
#line 365
    tmp___6 = gettext("  -n, --norc          disable reading ~/.jtag/rc on startup\n");
#line 365
    printf((char const   */* __restrict  */)tmp___6);
#line 366
    tmp___7 = gettext("  -i, --interactive   enter interactive mode after reading files\n");
#line 366
    printf((char const   */* __restrict  */)tmp___7);
#line 367
    tmp___8 = gettext("  -q, --quiet         Do not print help on startup\n");
#line 367
    printf((char const   */* __restrict  */)tmp___8);
#line 368
    printf((char const   */* __restrict  */)"\n");
#line 369
    tmp___9 = gettext("  [FILE]              file containing commands to execute\n");
#line 369
    printf((char const   */* __restrict  */)tmp___9);
#line 370
    printf((char const   */* __restrict  */)"\n");
#line 372
    tmp___10 = gettext("  Please report bugs at http://www.urjtag.org\n");
#line 372
    printf((char const   */* __restrict  */)tmp___10);
#line 374
    exit(0);
    }
  }
#line 377
  if (version) {
    {
#line 379
    tmp___11 = gettext("\n%s #%s\n\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n");
#line 379
    printf((char const   */* __restrict  */)tmp___11, "UrJTAG 0.9", "1359");
#line 384
    tmp___12 = gettext("\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n");
#line 384
    printf((char const   */* __restrict  */)tmp___12);
#line 399
    exit(0);
    }
  }
#line 403
  if (argc > optind) {
#line 404
    i = optind;
    {
#line 404
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 404
      if (! (i < argc)) {
#line 404
        goto while_break___0;
      }
      {
#line 405
      chain = chain_alloc();
      }
#line 406
      if (! chain) {
        {
#line 407
        tmp___13 = gettext("Out of memory\n");
#line 407
        printf((char const   */* __restrict  */)tmp___13);
        }
#line 408
        return (-1);
      }
      {
#line 411
      go = jtag_parse_file(chain, (char const   *)*(argv + i));
#line 412
      cleanup(chain);
      }
#line 413
      if (go < 0) {
        {
#line 414
        tmp___14 = gettext("Unable to open file `%s\'!\n");
#line 414
        printf((char const   */* __restrict  */)tmp___14, *(argv + i));
        }
#line 415
        goto while_break___0;
      }
#line 404
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 419
    if (! interactive) {
#line 419
      return (0);
    }
  }
  {
#line 423
  tmp___16 = isatty(0);
  }
#line 423
  if (! tmp___16) {
    {
#line 424
    chain = chain_alloc();
    }
#line 425
    if (! chain) {
      {
#line 426
      tmp___15 = gettext("Out of memory\n");
#line 426
      printf((char const   */* __restrict  */)tmp___15);
      }
#line 427
      return (-1);
    }
    {
#line 429
    jtag_parse_stream(chain, stdin);
#line 431
    cleanup(chain);
    }
#line 433
    return (0);
  }
#line 437
  if (! quiet) {
    {
#line 438
    tmp___17 = gettext("\n%s #%s\nCopyright (C) 2002, 2003 ETC s.r.o.\nCopyright (C) 2007, 2008 Kolja Waschk and the respective authors\n\n%s is free software, covered by the GNU General Public License, and you are\nwelcome to change it and/or distribute copies of it under certain conditions.\nThere is absolutely no warranty for %s.\n\n");
#line 438
    printf((char const   */* __restrict  */)tmp___17, "UrJTAG 0.9", "1359", "UrJTAG",
           "UrJTAG");
    }
  }
  {
#line 448
  chain = chain_alloc();
  }
#line 449
  if (! chain) {
    {
#line 450
    tmp___18 = gettext("Out of memory\n");
#line 450
    printf((char const   */* __restrict  */)tmp___18);
    }
#line 451
    return (-1);
  }
#line 454
  if (! quiet) {
    {
#line 455
    tmp___19 = gettext("WARNING: %s may damage your hardware!\n");
#line 455
    printf((char const   */* __restrict  */)tmp___19, "UrJTAG");
#line 456
    tmp___20 = gettext("Type \"quit\" to exit, \"help\" for help.\n\n");
#line 456
    printf((char const   */* __restrict  */)tmp___20);
    }
  }
  {
#line 460
  jtag_create_jtagdir();
  }
#line 463
  if (norc) {
#line 463
    go = 1;
  } else {
    {
#line 463
    tmp___21 = jtag_parse_rc(chain);
#line 463
    go = tmp___21;
    }
  }
#line 471
  if (go) {
    {
#line 479
    tmp___24 = getenv("JTAG_PROMPT");
#line 479
    tmp___23 = (char const   *)tmp___24;
    }
#line 479
    if (! tmp___23) {
#line 479
      tmp___23 = "jtag> ";
    }
    {
#line 479
    jtag_readline_loop(chain, tmp___23);
    }
  }
  {
#line 487
  cleanup(chain);
  }
#line 489
  return (0);
}
}
