/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef unsigned long size_t;
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef long ptrdiff_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uintmax_t;
#line 112 "/usr/include/stdint.h"
typedef __uintmax_t uintmax_t;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 198 "./getopt.h"
struct rpl_option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 26 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint32_t uint32_t;
#line 25 "./unitypes.h"
typedef uint32_t ucs4_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 4 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h"
struct _IO_FILE ;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/x86_64-linux-gnu/bits/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 324 "/usr/lib/gcc/x86_64-linux-gnu/4.9/include/stddef.h"
typedef int wchar_t;
#line 20 "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h"
typedef unsigned int wint_t;
#line 49 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
enum __anonenum_arg_type_817662448 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 49 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
typedef enum __anonenum_arg_type_817662448 arg_type;
#line 91 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
union __anonunion_a_145370145 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 91 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
struct __anonstruct_argument_739513695 {
   arg_type type ;
   union __anonunion_a_145370145 a ;
};
#line 91 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
typedef struct __anonstruct_argument_739513695 argument;
#line 141 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
struct __anonstruct_arguments_927136039 {
   size_t count ;
   argument *arg ;
   argument direct_alloc_arg[7] ;
};
#line 141 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
typedef struct __anonstruct_arguments_927136039 arguments;
#line 53 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-parse.h"
struct __anonstruct_char_directive_658480644 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 53 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-parse.h"
typedef struct __anonstruct_char_directive_658480644 char_directive;
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-parse.h"
struct __anonstruct_char_directives_461991359 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
   char_directive direct_alloc_dir[7] ;
};
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-parse.h"
typedef struct __anonstruct_char_directives_461991359 char_directives;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 8 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h"
typedef __time_t time_t;
#line 9 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 549 "./time.h"
struct tm_zone ;
#line 549 "./time.h"
typedef struct tm_zone *timezone_t;
#line 21 "/home/khheo/project/benchmark/tar-1.29/gnu/time-internal.h"
struct tm_zone {
   struct tm_zone *next ;
   char tz_is_set ;
   char abbrs[] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __uint64_t;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 52 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 58 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint64_t uint64_t;
#line 256 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.h"
struct permission_context {
   mode_t mode ;
};
#line 67 "./selinux/selinux.h"
typedef unsigned short security_class_t;
#line 68 "./selinux/selinux.h"
typedef char *security_context_t;
#line 37 "./selinux/context.h"
typedef int context_t;
#line 34 "/usr/include/dirent.h"
typedef __ino_t ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.h"
enum savedir_option {
    SAVEDIR_SORT_NONE = 0,
    SAVEDIR_SORT_NAME = 1,
    SAVEDIR_SORT_INODE = 2,
    SAVEDIR_SORT_FASTREAD = 2
} ;
#line 40 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
struct __anonstruct_direntry_t_888070708 {
   char *name ;
   ino_t ino ;
};
#line 40 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
typedef struct __anonstruct_direntry_t_888070708 direntry_t;
#line 72 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
typedef int (*comparison_function)(void const   * , void const   * );
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 239
struct quoting_options ;
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
struct __anonstruct___mbstate_t_1055809117 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h"
typedef struct __anonstruct___mbstate_t_1055809117 __mbstate_t;
#line 6 "/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h"
typedef __mbstate_t mbstate_t;
#line 55 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 723 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 61 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intmax_t;
#line 111 "/usr/include/stdint.h"
typedef __intmax_t intmax_t;
#line 111 "./parse-datetime.y"
typedef long long_time_t;
#line 131 "./parse-datetime.y"
struct __anonstruct_textint_824309684 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 131 "./parse-datetime.y"
typedef struct __anonstruct_textint_824309684 textint;
#line 139 "./parse-datetime.y"
struct __anonstruct_table_528220008 {
   char const   *name ;
   int type ;
   int value ;
};
#line 139 "./parse-datetime.y"
typedef struct __anonstruct_table_528220008 table;
#line 152 "./parse-datetime.y"
struct __anonstruct_relative_time_110745635 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
#line 152 "./parse-datetime.y"
typedef struct __anonstruct_relative_time_110745635 relative_time;
#line 171 "./parse-datetime.y"
struct __anonstruct_parser_control_427311395 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 171 "./parse-datetime.y"
typedef struct __anonstruct_parser_control_427311395 parser_control;
#line 216
union YYSTYPE ;
#line 440 "parse-datetime.c"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 440 "parse-datetime.c"
typedef union YYSTYPE YYSTYPE;
#line 475 "parse-datetime.c"
typedef unsigned char yytype_uint8;
#line 482 "parse-datetime.c"
typedef signed char yytype_int8;
#line 496 "parse-datetime.c"
typedef short yytype_int16;
#line 628 "parse-datetime.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 86 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off_t off_t;
#line 152 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 159 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.h"
union __anonunion_temp_355861816 {
   size_t i ;
   void *p ;
};
#line 159 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.h"
union __anonunion_chunkfun_5259977 {
   void *(*plain)(size_t  ) ;
   void *(*extra)(void * , size_t  ) ;
};
#line 159 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.h"
union __anonunion_freefun_5259978 {
   void (*plain)(void * ) ;
   void (*extra)(void * , void * ) ;
};
#line 159 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.h"
struct obstack {
   size_t chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_355861816 temp ;
   size_t alignment_mask ;
   union __anonunion_chunkfun_5259977 chunkfun ;
   union __anonunion_freefun_5259978 freefun ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 25 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.h"
struct mode_change ;
#line 98 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.c"
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
#line 76 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
typedef long long_int;
#line 169 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 181 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
typedef struct mbchar mbchar_t;
#line 117 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 210 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 100 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.c"
struct preliminary_header {
   void *next ;
   int magic ;
};
#line 56 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.c"
struct __anonstruct_magic_951761807 {
   char room[(((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(int )] ;
   int word ;
};
#line 56 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.c"
union header {
   void *next ;
   struct __anonstruct_magic_951761807 magic ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 51 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 53 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 65 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 67
struct hash_table ;
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.h"
typedef struct hash_table Hash_table;
#line 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint8_t uint8_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h"
typedef __uint16_t uint16_t;
#line 46 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 7 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h"
typedef __clockid_t clockid_t;
#line 62 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt_int.h"
enum __ord {
    REQUIRE_ORDER = 0,
    PERMUTE = 1,
    RETURN_IN_ORDER = 2
} ;
#line 68 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt_int.h"
struct _getopt_data {
   int rpl_optind ;
   int rpl_opterr ;
   int rpl_optopt ;
   char *rpl_optarg ;
   int __initialized ;
   char *__nextchar ;
   enum __ord __ordering ;
   int __posixly_correct ;
   int __first_nonopt ;
   int __last_nonopt ;
};
#line 485 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
struct option_list {
   struct rpl_option  const  *p ;
   struct option_list *next ;
};
#line 63 "./regex.h"
typedef unsigned long __re_long_size_t;
#line 79 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 420
struct re_dfa_t ;
#line 420 "./regex.h"
struct re_pattern_buffer {
   struct re_dfa_t *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 485 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 496 "./regex.h"
typedef int regoff_t;
#line 523 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 523 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.h"
struct exclude ;
#line 76 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
union __anonunion_v_827610566 {
   char const   *pattern ;
   regex_t re ;
};
#line 76 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
struct patopts {
   int options ;
   union __anonunion_v_827610566 v ;
};
#line 88 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 95
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 101 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
union __anonunion_v_510793701 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 101 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_510793701 v ;
};
#line 113 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
struct pattern_buffer {
   struct pattern_buffer *next ;
   char *base ;
};
#line 121 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct pattern_buffer *patbuf ;
};
#line 41 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/careadlinkat.h"
struct allocator ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/allocator.h"
struct allocator {
   void *(*allocate)(size_t  ) ;
   void *(*reallocate)(void * , size_t  ) ;
   void (*free)(void * ) ;
   void (*die)(size_t  ) ;
};
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 146 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 314 "/usr/include/x86_64-linux-gnu/bits/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 52 "/usr/include/errno.h"
typedef int error_t;
#line 77 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
struct argp_option {
   char const   *name ;
   int key ;
   char const   *arg ;
   int flags ;
   char const   *doc ;
   int group ;
};
#line 151
struct argp ;
#line 152
struct argp_state ;
#line 153
struct argp_child ;
#line 225 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
struct argp {
   struct argp_option  const  *options ;
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   char const   *args_doc ;
   char const   *doc ;
   struct argp_child  const  *children ;
   char *(*help_filter)(int __key , char const   *__text , void *__input ) ;
   char const   *argp_domain ;
};
#line 293 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
struct argp_child {
   struct argp  const  *argp ;
   int flags ;
   char const   *header ;
   int group ;
};
#line 318 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
struct argp_state {
   struct argp  const  *root_argp ;
   int argc ;
   char **argv ;
   int next ;
   unsigned int flags ;
   unsigned int arg_num ;
   int quoted ;
   void *input ;
   void **child_inputs ;
   void *hook ;
   char *name ;
   FILE *err_stream ;
   FILE *out_stream ;
   void *pstate ;
};
#line 194 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
struct group {
   error_t (*parser)(int key , char *arg , struct argp_state *state ) ;
   struct argp  const  *argp ;
   char *short_end ;
   unsigned int args_processed ;
   struct group *parent ;
   unsigned int parent_index ;
   void *input ;
   void **child_inputs ;
   void *hook ;
};
#line 241 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
struct parser {
   struct argp  const  *argp ;
   char *short_opts ;
   struct rpl_option *long_opts ;
   struct _getopt_data opt_data ;
   struct group *groups ;
   struct group *egroup ;
   void **child_inputs ;
   int try_getopt ;
   struct argp_state state ;
   void *storage ;
};
#line 276 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
struct parser_convert_state {
   struct parser *parser ;
   char *short_end ;
   struct rpl_option *long_end ;
   void **child_inputs_end ;
};
#line 417 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
struct parser_sizes {
   size_t short_len ;
   size_t long_len ;
   size_t num_groups ;
   size_t num_child_inputs ;
};
#line 91 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
struct argp_fmtstream {
   FILE *stream ;
   size_t lmargin ;
   size_t rmargin ;
   ssize_t wmargin ;
   size_t point_offs ;
   ssize_t point_col ;
   char *buf ;
   char *p ;
   char *end ;
};
#line 108 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
typedef struct argp_fmtstream *argp_fmtstream_t;
#line 78 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct uparams {
   int dup_args ;
   int dup_args_note ;
   int short_opt_col ;
   int long_opt_col ;
   int doc_opt_col ;
   int opt_doc_col ;
   int header_col ;
   int usage_indent ;
   int rmargin ;
   int valid ;
};
#line 112 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct uparam_name {
   char const   *name ;
   int is_bool ;
   size_t uparams_offs ;
};
#line 351
struct hol_cluster ;
#line 353 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct hol_entry {
   struct argp_option  const  *opt ;
   unsigned int num ;
   char *short_options ;
   int group ;
   struct hol_cluster *cluster ;
   struct argp  const  *argp ;
   unsigned int ord ;
};
#line 384 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct hol_cluster {
   char const   *header ;
   int index ;
   int group ;
   struct hol_cluster *parent ;
   struct argp  const  *argp ;
   int depth ;
   struct hol_cluster *next ;
};
#line 414 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct hol {
   struct hol_entry *entries ;
   unsigned int num_entries ;
   char *short_options ;
   struct hol_cluster *clusters ;
};
#line 981 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct hol_help_state {
   struct hol_entry *prev_entry ;
   int sep_groups ;
   int suppressed_dup_arg ;
};
#line 998 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
struct pentry_state {
   struct hol_entry  const  *entry ;
   argp_fmtstream_t stream ;
   struct hol_help_state *hhstate ;
   int first ;
   struct argp_state  const  *state ;
};
#line 31 "./wordsplit.h"
struct wordsplit_node ;
#line 31 "./wordsplit.h"
struct wordsplit {
   size_t ws_wordc ;
   char **ws_wordv ;
   size_t ws_offs ;
   size_t ws_wordn ;
   int ws_flags ;
   char const   *ws_delim ;
   char const   *ws_comment ;
   char const   *ws_escape ;
   void (*ws_alloc_die)(struct wordsplit *wsp ) ;
   void ( /* format attribute */  (*ws_error))(char const   *  , ...) ;
   void ( /* format attribute */  (*ws_debug))(char const   *  , ...) ;
   char const   **ws_env ;
   char const   *(*ws_getvar)(char const   * , size_t  , void * ) ;
   void *ws_closure ;
   char const   *ws_input ;
   size_t ws_len ;
   size_t ws_endp ;
   int ws_errno ;
   struct wordsplit_node *ws_head ;
   struct wordsplit_node *ws_tail ;
};
#line 220 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
struct __anonstruct_segm_73278319 {
   size_t beg ;
   size_t end ;
};
#line 220 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
union __anonunion_v_958793228 {
   struct __anonstruct_segm_73278319 segm ;
   char *word ;
};
#line 220 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
struct wordsplit_node {
   struct wordsplit_node *prev ;
   struct wordsplit_node *next ;
   unsigned int flags ;
   union __anonunion_v_958793228 v ;
};
#line 614
enum __anonenum_state_691190535 {
    st_init = 0,
    st_squote = 1,
    st_dquote = 2
} ;
#line 152 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __daddr_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 72 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 30 "/usr/include/x86_64-linux-gnu/sys/mtio.h"
struct mtop {
   short mt_op ;
   int mt_count ;
};
#line 81 "/usr/include/x86_64-linux-gnu/sys/mtio.h"
struct mtget {
   long mt_type ;
   long mt_resid ;
   long mt_dsreg ;
   long mt_gstat ;
   long mt_erreg ;
   __daddr_t mt_fileno ;
   __daddr_t mt_blkno ;
};
#line 98 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 266 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct sp_array {
   off_t offset ;
   off_t numbytes ;
};
#line 272 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct xheader {
   struct obstack *stk ;
   size_t size ;
   char *buffer ;
   uintmax_t string_length ;
};
#line 281 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct xattr_array {
   char *xkey ;
   char *xval_ptr ;
   size_t xval_len ;
};
#line 288
struct exclist ;
#line 288 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct tar_stat_info {
   char *orig_file_name ;
   char *file_name ;
   _Bool had_trailing_slash ;
   char *link_name ;
   char *uname ;
   char *gname ;
   char *cntx_name ;
   char *acls_a_ptr ;
   size_t acls_a_len ;
   char *acls_d_ptr ;
   size_t acls_d_len ;
   struct stat stat ;
   struct timespec atime ;
   struct timespec mtime ;
   struct timespec ctime ;
   off_t archive_file_size ;
   _Bool is_sparse ;
   unsigned int sparse_major ;
   unsigned int sparse_minor ;
   size_t sparse_map_avail ;
   size_t sparse_map_size ;
   struct sp_array *sparse_map ;
   off_t real_size ;
   int real_size_set ;
   size_t xattr_map_size ;
   struct xattr_array *xattr_map ;
   struct xheader xhdr ;
   _Bool is_dumpdir ;
   _Bool skipped ;
   char *dumpdir ;
   struct tar_stat_info *parent ;
   DIR *dirstream ;
   int fd ;
   struct exclist *exclude_list ;
};
#line 33 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
struct xattrs_mask_map {
   char const   **masks ;
   size_t size ;
   size_t used ;
};
#line 41 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
struct __anonstruct_xattrs_setup_1047061541 {
   struct xattrs_mask_map incl ;
   struct xattrs_mask_map excl ;
};
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 25 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct posix_header {
   char name[100] ;
   char mode[8] ;
   char uid[8] ;
   char gid[8] ;
   char size[12] ;
   char mtime[12] ;
   char chksum[8] ;
   char typeflag ;
   char linkname[100] ;
   char magic[6] ;
   char version[2] ;
   char uname[32] ;
   char gname[32] ;
   char devmajor[8] ;
   char devminor[8] ;
   char prefix[155] ;
};
#line 99 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct sparse {
   char offset[12] ;
   char numbytes[12] ;
};
#line 124 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct sparse_header {
   struct sparse sp[21] ;
   char isextended ;
};
#line 140 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct oldgnu_header {
   char unused_pad1[345] ;
   char atime[12] ;
   char ctime[12] ;
   char offset[12] ;
   char longnames[4] ;
   char unused_pad2 ;
   struct sparse sp[4] ;
   char isextended ;
   char realsize[12] ;
};
#line 196 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct star_header {
   char name[100] ;
   char mode[8] ;
   char uid[8] ;
   char gid[8] ;
   char size[12] ;
   char mtime[12] ;
   char chksum[8] ;
   char typeflag ;
   char linkname[100] ;
   char magic[6] ;
   char version[2] ;
   char uname[32] ;
   char gname[32] ;
   char devmajor[8] ;
   char devminor[8] ;
   char prefix[131] ;
   char atime[12] ;
   char ctime[12] ;
};
#line 222 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct star_in_header {
   char fill[345] ;
   char prefix[1] ;
   char fill2 ;
   char fill3[8] ;
   char isextended ;
   struct sparse sp[4] ;
   char realsize[12] ;
   char offset[12] ;
   char atime[12] ;
   char ctime[12] ;
   char mfill[8] ;
   char xmagic[4] ;
};
#line 238 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
struct star_ext_header {
   struct sparse sp[21] ;
   char isextended ;
};
#line 252
enum archive_format {
    DEFAULT_FORMAT = 0,
    V7_FORMAT = 1,
    OLDGNU_FORMAT = 2,
    USTAR_FORMAT = 3,
    POSIX_FORMAT = 4,
    STAR_FORMAT = 5,
    GNU_FORMAT = 6
} ;
#line 370 "/home/khheo/project/benchmark/tar-1.29/src/tar.h"
union block {
   char buffer[512] ;
   struct posix_header header ;
   struct star_header star_header ;
   struct oldgnu_header oldgnu_header ;
   struct sparse_header sparse_header ;
   struct star_in_header star_in_header ;
   struct star_ext_header star_ext_header ;
};
#line 83 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum subcommand {
    UNKNOWN_SUBCOMMAND = 0,
    APPEND_SUBCOMMAND = 1,
    CAT_SUBCOMMAND = 2,
    CREATE_SUBCOMMAND = 3,
    DELETE_SUBCOMMAND = 4,
    DIFF_SUBCOMMAND = 5,
    EXTRACT_SUBCOMMAND = 6,
    LIST_SUBCOMMAND = 7,
    UPDATE_SUBCOMMAND = 8,
    TEST_LABEL_SUBCOMMAND = 9
} ;
#line 359
struct directory ;
#line 362 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct name {
   struct name *next ;
   struct name *prev ;
   char *name ;
   size_t length ;
   int matching_flags ;
   _Bool cmdline ;
   int change_dir ;
   uintmax_t found_count ;
   struct directory *directory ;
   struct name *parent ;
   struct name *child ;
   struct name *sibling ;
   char *caname ;
};
#line 426
enum access_mode {
    ACCESS_READ = 0,
    ACCESS_WRITE = 1,
    ACCESS_UPDATE = 2
} ;
#line 571
enum read_header {
    HEADER_STILL_UNREAD = 0,
    HEADER_SUCCESS = 1,
    HEADER_SUCCESS_EXTENDED = 2,
    HEADER_ZERO_BLOCK = 3,
    HEADER_END_OF_FILE = 4,
    HEADER_FAILURE = 5
} ;
#line 583
enum read_header_mode {
    read_header_auto = 0,
    read_header_x_raw = 1,
    read_header_x_global = 2
} ;
#line 634
struct namebuf ;
#line 634 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
typedef struct namebuf *namebuf_t;
#line 24 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
struct deferred_unlink {
   struct deferred_unlink *next ;
   int dir_idx ;
   char *file_name ;
   _Bool is_dir ;
   off_t records_written ;
};
#line 21 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
enum transform_type {
    transform_first = 0,
    transform_global = 1
} ;
#line 27
enum replace_segm_type {
    segm_literal = 0,
    segm_backref = 1,
    segm_case_ctl = 2
} ;
#line 34
enum case_ctl_type {
    ctl_stop = 0,
    ctl_upcase_next = 1,
    ctl_locase_next = 2,
    ctl_upcase = 3,
    ctl_locase = 4
} ;
#line 43 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
struct __anonstruct_literal_653462436 {
   char *ptr ;
   size_t size ;
};
#line 43 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
union __anonunion_v_748780225 {
   struct __anonstruct_literal_653462436 literal ;
   size_t ref ;
   enum case_ctl_type ctl ;
};
#line 43 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
struct replace_segm {
   struct replace_segm *next ;
   enum replace_segm_type type ;
   union __anonunion_v_748780225 v ;
};
#line 59 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
struct transform {
   struct transform *next ;
   enum transform_type transform_type ;
   int flags ;
   unsigned int match_number ;
   regex_t regex ;
   struct replace_segm *repl_head ;
   struct replace_segm *repl_tail ;
   size_t segm_count ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 28 "/home/khheo/project/benchmark/tar-1.29/src/arith.h"
typedef double tarlong;
#line 122 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum atime_preserve {
    no_atime_preserve = 0,
    replace_atime_preserve = 1,
    system_atime_preserve = 2
} ;
#line 181
enum old_files {
    DEFAULT_OLD_FILES = 0,
    NO_OVERWRITE_DIR_OLD_FILES = 1,
    OVERWRITE_OLD_FILES = 2,
    UNLINK_FIRST_OLD_FILES = 3,
    KEEP_OLD_FILES = 4,
    SKIP_OLD_FILES = 5,
    KEEP_NEWER_FILES = 6
} ;
#line 214
enum set_mtime_option_mode {
    USE_FILE_MTIME = 0,
    FORCE_MTIME = 1,
    CLAMP_MTIME = 2
} ;
#line 290
enum hole_detection_method {
    HOLE_DETECTION_DEFAULT = 0,
    HOLE_DETECTION_RAW = 1,
    HOLE_DETECTION_SEEK = 2
} ;
#line 789
enum option_source {
    OPTS_ENVIRON = 0,
    OPTS_COMMAND_LINE = 1,
    OPTS_FILE = 2
} ;
#line 797 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct option_locus {
   enum option_source source ;
   char const   *name ;
   size_t line ;
   struct option_locus *prev ;
};
#line 142 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
struct fmttab {
   char const   *name ;
   enum archive_format fmt ;
};
#line 805
struct textual_date ;
#line 805 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
struct tar_args {
   struct option_locus *loc ;
   struct textual_date *textual_date ;
   _Bool o_option ;
   _Bool pax_option ;
   char const   *backup_suffix_string ;
   char const   *version_control_string ;
   _Bool input_files ;
   int compress_autodetect ;
};
#line 981 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
struct sigtab {
   char const   *name ;
   int signo ;
};
#line 1009 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
struct textual_date {
   struct textual_date *next ;
   struct timespec ts ;
   char const   *rpl_option ;
   char *date ;
};
#line 22 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
struct compression_suffix {
   char const   *suffix ;
   size_t length ;
   char const   *program ;
};
#line 487 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum dump_status {
    dump_status_ok = 0,
    dump_status_short = 1,
    dump_status_fail = 2,
    dump_status_not_implemented = 3
} ;
#line 23 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
struct tar_sparse_file ;
#line 26
enum sparse_scan_state {
    scan_begin = 0,
    scan_block = 1,
    scan_end = 2
} ;
#line 33 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
struct tar_sparse_optab {
   _Bool (*init)(struct tar_sparse_file * ) ;
   _Bool (*done)(struct tar_sparse_file * ) ;
   _Bool (*sparse_member_p)(struct tar_sparse_file * ) ;
   _Bool (*dump_header)(struct tar_sparse_file * ) ;
   _Bool (*fixup_header)(struct tar_sparse_file * ) ;
   _Bool (*decode_header)(struct tar_sparse_file * ) ;
   _Bool (*scan_block)(struct tar_sparse_file * , enum sparse_scan_state  , void * ) ;
   _Bool (*dump_region)(struct tar_sparse_file * , size_t  ) ;
   _Bool (*extract_region)(struct tar_sparse_file * , size_t  ) ;
};
#line 47 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
struct tar_sparse_file {
   int fd ;
   _Bool seekable ;
   off_t offset ;
   off_t dumped_size ;
   struct tar_stat_info *stat_info ;
   struct tar_sparse_optab  const  *optab ;
   void *closure ;
};
#line 712
enum oldgnu_add_status {
    add_ok = 0,
    add_finish = 1,
    add_fail = 2
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group___0 {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 149 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum exclusion_tag_type {
    exclusion_tag_none = 0,
    exclusion_tag_contents = 1,
    exclusion_tag_under = 2,
    exclusion_tag_all = 3
} ;
#line 196 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
enum wildcards {
    default_wildcards = 0,
    disable_wildcards = 1,
    enable_wildcards = 2
} ;
#line 608
enum nelt_type {
    NELT_NAME = 0,
    NELT_CHDIR = 1,
    NELT_FILE = 2,
    NELT_NOOP = 3,
    NELT_OPTION = 4
} ;
#line 617 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct __anonstruct_file_581978823 {
   char const   *name ;
   size_t line ;
   int term ;
   _Bool verbatim ;
   FILE *fp ;
};
#line 617 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct __anonstruct_opt_540876730 {
   int rpl_option ;
   char const   *arg ;
};
#line 617 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
union __anonunion_v_725591487 {
   char const   *name ;
   struct __anonstruct_file_581978823 file ;
   struct __anonstruct_opt_540876730 opt ;
};
#line 617 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct name_elt {
   struct name_elt *next ;
   struct name_elt *prev ;
   enum nelt_type type ;
   union __anonunion_v_725591487 v ;
};
#line 747 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct file_id_list {
   struct file_id_list *next ;
   ino_t ino ;
   dev_t dev ;
   char const   *from_file ;
};
#line 810
enum read_file_list_state {
    file_list_success = 0,
    file_list_end = 1,
    file_list_zero = 2,
    file_list_skip = 3
} ;
#line 680 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum remove_option {
    ORDINARY_REMOVE_OPTION = 0,
    RECURSIVE_REMOVE_OPTION = 1,
    WANT_DIRECTORY_REMOVE_OPTION = 2
} ;
#line 845 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
struct wd {
   char const   *name ;
   char *abspath ;
   int fd ;
};
#line 1163 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
struct namebuf {
   char *buffer ;
   size_t buffer_size ;
   size_t dir_length ;
};
#line 26 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
struct mapentry {
   uintmax_t orig_id ;
   uintmax_t new_id ;
   char *new_name ;
};
#line 29 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
enum children {
    NO_CHILDREN = 0,
    CHANGED_CHILDREN = 1,
    ALL_CHILDREN = 2
} ;
#line 53 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
struct dumpdir {
   char *contents ;
   size_t total ;
   size_t elc ;
   char **elv ;
};
#line 62 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
struct directory {
   struct directory *next ;
   struct timespec mtime ;
   dev_t device_number ;
   ino_t inode_number ;
   struct dumpdir *dump ;
   struct dumpdir *idump ;
   enum children children ;
   unsigned int flags ;
   struct directory *orig ;
   char const   *tagfile ;
   char *caname ;
   char *name ;
};
#line 147 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
struct dumpdir_iter {
   struct dumpdir *dump ;
   int all ;
   size_t next ;
};
#line 1284 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
struct field_range {
   char const   *fieldname ;
   intmax_t min_val ;
   uintmax_t max_val ;
};
#line 79 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
struct keyword_list {
   struct keyword_list *next ;
   char *pattern ;
   char *value ;
};
#line 584 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
struct xhdr_tab {
   char const   *keyword ;
   void (*coder)(struct tar_stat_info  const  * , char const   * , struct xheader * ,
                 void const   *data ) ;
   void (*decoder)(struct tar_stat_info * , char const   * , char const   * , size_t  ) ;
   int flags ;
   _Bool prefix ;
};
#line 64 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
struct delayed_set_stat {
   struct delayed_set_stat *next ;
   dev_t dev ;
   ino_t ino ;
   mode_t mode ;
   uid_t uid ;
   gid_t gid ;
   struct timespec atime ;
   struct timespec mtime ;
   mode_t current_mode ;
   mode_t current_mode_mask ;
   _Bool interdir ;
   int atflag ;
   _Bool after_links ;
   int change_dir ;
   char *cntx_name ;
   char *acls_a_ptr ;
   size_t acls_a_len ;
   char *acls_d_ptr ;
   size_t acls_d_len ;
   size_t xattr_map_size ;
   struct xattr_array *xattr_map ;
   size_t file_name_len ;
   char *file_name ;
};
#line 118
struct string_list ;
#line 118 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
struct delayed_link {
   struct delayed_link *next ;
   dev_t dev ;
   ino_t ino ;
   struct timespec birthtime ;
   _Bool is_symlink ;
   mode_t mode ;
   uid_t uid ;
   gid_t gid ;
   struct timespec atime ;
   struct timespec mtime ;
   int change_dir ;
   struct string_list *sources ;
   char *cntx_name ;
   char *acls_a_ptr ;
   size_t acls_a_len ;
   char *acls_d_ptr ;
   size_t acls_d_len ;
   size_t xattr_map_size ;
   struct xattr_array *xattr_map ;
   char target[1] ;
};
#line 168 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
struct string_list {
   struct string_list *next ;
   char string[1] ;
};
#line 1495 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
typedef int (*tar_extractor_t)(char *file_name , int typeflag );
#line 28 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
struct vcs_ignore_file {
   char const   *filename ;
   int flags ;
   void (*addfn)(struct exclude * , char const   * , int  , void * ) ;
   void *(*initfn)(void * ) ;
   void *data ;
};
#line 39 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
struct excfile {
   struct excfile *next ;
   int flags ;
   char name[1] ;
};
#line 62 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
struct exclist {
   struct exclist *next ;
   struct exclist *prev ;
   int flags ;
   struct exclude *excluded ;
};
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 35 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
struct link {
   dev_t dev ;
   ino_t ino ;
   nlink_t nlink ;
   char name[1] ;
};
#line 43 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
struct exclusion_tag {
   char const   *name ;
   size_t length ;
   enum exclusion_tag_type type ;
   _Bool (*predicate)(int fd ) ;
   struct exclusion_tag *next ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 27 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
enum checkpoint_opcode {
    cop_dot = 0,
    cop_bell = 1,
    cop_echo = 2,
    cop_ttyout = 3,
    cop_sleep = 4,
    cop_exec = 5,
    cop_totals = 6
} ;
#line 38 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
union __anonunion_v_38348287 {
   time_t time ;
   char *command ;
};
#line 38 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
struct checkpoint_action {
   struct checkpoint_action *next ;
   enum checkpoint_opcode opcode ;
   union __anonunion_v_38348287 v ;
};
#line 117 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
struct bufmap {
   struct bufmap *next ;
   size_t start ;
   char *file_name ;
   off_t sizetotal ;
   off_t sizeleft ;
};
#line 264
enum compress_type {
    ct_none = 0,
    ct_tar = 1,
    ct_compress = 2,
    ct_gzip = 3,
    ct_bzip2 = 4,
    ct_lzip = 5,
    ct_lzma = 6,
    ct_lzop = 7,
    ct_xz = 8
} ;
#line 278 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
struct zip_magic {
   enum compress_type type ;
   size_t length ;
   char const   *magic ;
};
#line 285 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
struct zip_program {
   enum compress_type type ;
   char const   *program ;
   char const   *rpl_option ;
};
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 48 "/home/khheo/project/benchmark/tar-1.29/gnu/xvasprintf.h"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args___0 ) ;
#line 37 "/usr/include/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 384
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 352 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vasprintf)(char ** __restrict  __ptr ,
                                                                              char const   * __restrict  __f ,
                                                                              __gnuc_va_list __arg ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 56
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 58
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 64
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 101
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 103
__inline void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 103 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
__inline void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 106
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 106
    tmp = -1;
  } else {
#line 106
    tmp = -2;
  }
#line 106
  if ((size_t )tmp / s < n) {
    {
#line 107
    xalloc_die();
    }
  }
  {
#line 108
  tmp___0 = xmalloc(n * s);
  }
#line 108
  return (tmp___0);
}
}
#line 114
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 116
__inline void *xnrealloc(void *p , size_t n , size_t s )  __attribute__((__alloc_size__(2,3))) ;
#line 116 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
__inline void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 119
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 119
    tmp = -1;
  } else {
#line 119
    tmp = -2;
  }
#line 119
  if ((size_t )tmp / s < n) {
    {
#line 120
    xalloc_die();
    }
  }
  {
#line 121
  tmp___0 = xrealloc(p, n * s);
  }
#line 121
  return (tmp___0);
}
}
#line 178 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
__inline void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 181
  n = *pn;
#line 183
  if (! p) {
#line 185
    if (! n) {
#line 193
      n = 128UL / s;
#line 194
      n += (size_t )(! n);
    }
  } else {
#line 203
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
      {
#line 204
      xalloc_die();
      }
    }
#line 205
    n += n / 2UL + 1UL;
  }
  {
#line 208
  *pn = n;
#line 209
  tmp = xrealloc(p, n * s);
  }
#line 209
  return (tmp);
}
}
#line 215
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 217
__inline char *xcharalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 217 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
__inline char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 220
  if (sizeof(char ) == 1UL) {
    {
#line 220
    tmp = xmalloc(n);
#line 220
    tmp___1 = tmp;
    }
  } else {
    {
#line 220
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 220
    tmp___1 = tmp___0;
    }
  }
#line 220
  return ((char *)tmp___1);
}
}
#line 262
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
#pragma GCC diagnostic push
#line 33
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 33
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 59 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
__inline size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 65
  sum = size1 + size2;
#line 66
  if (sum >= size1) {
#line 66
    tmp = sum;
  } else {
#line 66
    tmp = 0xffffffffffffffffUL;
  }
#line 66
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
__inline size_t __attribute__((__pure__))  xsum3(size_t size1 , size_t size2 , size_t size3 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;

  {
  {
#line 76
  tmp = xsum(size1, size2);
#line 76
  tmp___0 = xsum((size_t )tmp, size3);
  }
#line 76
  return (tmp___0);
}
}
#line 80 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
__inline size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 , size_t size3 ,
                                                 size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
  {
#line 86
  tmp = xsum(size1, size2);
#line 86
  tmp___0 = xsum((size_t )tmp, size3);
#line 86
  tmp___1 = xsum((size_t )tmp___0, size4);
  }
#line 86
  return (tmp___1);
}
}
#line 90 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
__inline size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 98
  if (size1 >= size2) {
#line 98
    tmp = size1;
  } else {
#line 98
    tmp = size2;
  }
#line 98
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 115
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/xvasprintf.c"
static char *xstrcat(size_t argcount , va_list args___0 ) 
{ 
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *next___0 ;
  char const   *tmp___8 ;
  size_t len ;
  size_t tmp___9 ;

  {
  {
#line 42
  totalsize = (size_t )0;
#line 43
  __builtin_va_copy(ap, args___0);
#line 44
  i = argcount;
  }
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (i > 0UL)) {
#line 44
      goto while_break;
    }
    {
#line 46
    tmp___0 = __builtin_va_arg(ap, char const   *);
#line 46
    next = tmp___0;
#line 47
    tmp___1 = strlen(next);
#line 47
    tmp___2 = xsum(totalsize, tmp___1);
#line 47
    totalsize = (size_t )tmp___2;
#line 44
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 49
  __builtin_va_end(ap);
  }
#line 54
  if (totalsize == 0xffffffffffffffffUL) {
    {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
    }
#line 57
    return ((char *)((void *)0));
  } else
#line 54
  if (totalsize > 2147483647UL) {
    {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
    }
#line 57
    return ((char *)((void *)0));
  }
#line 61
  if (sizeof(char ) == 1UL) {
    {
#line 61
    tmp___4 = xmalloc(totalsize + 1UL);
#line 61
    tmp___6 = tmp___4;
    }
  } else {
    {
#line 61
    tmp___5 = xnmalloc(totalsize + 1UL, sizeof(char ));
#line 61
    tmp___6 = tmp___5;
    }
  }
#line 61
  result = (char *)tmp___6;
#line 62
  p = result;
#line 63
  i = argcount;
  {
#line 63
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 63
    if (! (i > 0UL)) {
#line 63
      goto while_break___0;
    }
    {
#line 65
    tmp___8 = __builtin_va_arg(args___0, char const   *);
#line 65
    next___0 = tmp___8;
#line 66
    tmp___9 = strlen(next___0);
#line 66
    len = tmp___9;
#line 67
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)next___0,
           len);
#line 68
    p += len;
#line 63
    i --;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 70
  *p = (char )'\000';
#line 72
  return (result);
}
}
#line 75 "/home/khheo/project/benchmark/tar-1.29/gnu/xvasprintf.c"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args___0 ) 
{ 
  char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  argcount = (size_t )0;
#line 87
  f = format;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if ((int const   )*f == 0) {
      {
#line 91
      tmp = xstrcat(argcount, args___0);
      }
#line 91
      return (tmp);
    }
#line 92
    if ((int const   )*f != 37) {
#line 93
      goto while_break;
    }
#line 94
    f ++;
#line 95
    if ((int const   )*f != 115) {
#line 96
      goto while_break;
    }
#line 97
    f ++;
#line 98
    argcount ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 102
  tmp___1 = vasprintf((char **/* __restrict  */)(& result), (char const   */* __restrict  */)format,
                      args___0);
  }
#line 102
  if (tmp___1 < 0) {
    {
#line 104
    tmp___0 = __errno_location();
    }
#line 104
    if (*tmp___0 == 12) {
      {
#line 105
      xalloc_die();
      }
    }
#line 106
    return ((char *)((void *)0));
  }
#line 109
  return (result);
}
}
#line 301 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__leaf__)) strtoumax)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ,
                                                                                      int __base ) ;
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val___0 ,
                        char const   *valid_suffixes ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 225 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 59 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
static strtol_error bkm_scale(uintmax_t *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (uintmax_t )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
static strtol_error bkm_scale_by_power(uintmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val___0 ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c",
                    96U, "xstrtoumax");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c",
                  96U, "xstrtoumax");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 104
  q = s;
#line 105
  ch = (unsigned char )*q;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp___2 = __ctype_b_loc();
    }
#line 106
    if (! ((int const   )*(*tmp___2 + (int )ch) & 8192)) {
#line 106
      goto while_break;
    }
#line 107
    q ++;
#line 107
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((int )ch == 45) {
#line 109
    return ((strtol_error )4);
  }
  {
#line 112
  tmp = strtoumax((char const   */* __restrict  */)s, (char **/* __restrict  */)p,
                  strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = (uintmax_t )1;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val___0 = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val___0 = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 151
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 151
    if (tmp___7) {
      {
#line 162
      if ((int )*(*(p + 0) + 1) == 105) {
#line 162
        goto case_105;
      }
#line 168
      if ((int )*(*(p + 0) + 1) == 68) {
#line 168
        goto case_68;
      }
#line 168
      if ((int )*(*(p + 0) + 1) == 66) {
#line 168
        goto case_68;
      }
#line 160
      goto switch_break;
      case_105: /* CIL Label */ 
#line 163
      if ((int )*(*(p + 0) + 2) == 66) {
#line 164
        suffixes += 2;
      }
#line 165
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 169
      base = 1000;
#line 170
      suffixes ++;
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 177
    if ((int )*(*p) == 98) {
#line 177
      goto case_98;
    }
#line 181
    if ((int )*(*p) == 66) {
#line 181
      goto case_66___0;
    }
#line 185
    if ((int )*(*p) == 99) {
#line 185
      goto case_99;
    }
#line 189
    if ((int )*(*p) == 69) {
#line 189
      goto case_69;
    }
#line 194
    if ((int )*(*p) == 103) {
#line 194
      goto case_103;
    }
#line 194
    if ((int )*(*p) == 71) {
#line 194
      goto case_103;
    }
#line 199
    if ((int )*(*p) == 75) {
#line 199
      goto case_75;
    }
#line 199
    if ((int )*(*p) == 107) {
#line 199
      goto case_75;
    }
#line 204
    if ((int )*(*p) == 109) {
#line 204
      goto case_109;
    }
#line 204
    if ((int )*(*p) == 77) {
#line 204
      goto case_109;
    }
#line 208
    if ((int )*(*p) == 80) {
#line 208
      goto case_80;
    }
#line 213
    if ((int )*(*p) == 116) {
#line 213
      goto case_116;
    }
#line 213
    if ((int )*(*p) == 84) {
#line 213
      goto case_116;
    }
#line 217
    if ((int )*(*p) == 119) {
#line 217
      goto case_119;
    }
#line 221
    if ((int )*(*p) == 89) {
#line 221
      goto case_89;
    }
#line 225
    if ((int )*(*p) == 90) {
#line 225
      goto case_90;
    }
#line 229
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 178
    overflow = bkm_scale(& tmp, 512);
    }
#line 179
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale(& tmp, 1024);
    }
#line 183
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 186
    overflow = (strtol_error )0;
#line 187
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale_by_power(& tmp, base, 6);
    }
#line 191
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power(& tmp, base, 3);
    }
#line 196
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power(& tmp, base, 1);
    }
#line 201
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 205
    overflow = bkm_scale_by_power(& tmp, base, 2);
    }
#line 206
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 209
    overflow = bkm_scale_by_power(& tmp, base, 5);
    }
#line 210
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 214
    overflow = bkm_scale_by_power(& tmp, base, 4);
    }
#line 215
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 218
    overflow = bkm_scale(& tmp, 2);
    }
#line 219
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 222
    overflow = bkm_scale_by_power(& tmp, base, 8);
    }
#line 223
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 226
    overflow = bkm_scale_by_power(& tmp, base, 7);
    }
#line 227
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 230
    *val___0 = tmp;
#line 231
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 234
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 235
    *p += suffixes;
#line 236
    if (*(*p)) {
#line 237
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 240
  *val___0 = tmp;
#line 241
  return (err);
}
}
#line 45 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val___0 ,
                      char const   *valid_suffixes ) ;
#line 180 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 59 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
static strtol_error bkm_scale___0(unsigned long *x , int scale_factor ) 
{ 


  {
#line 67
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 69
    *x = 0xffffffffffffffffUL;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (unsigned long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
static strtol_error bkm_scale_by_power___0(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___0(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val___0 ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c",
                    96U, "xstrtoul");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c",
                  96U, "xstrtoul");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 104
  q = s;
#line 105
  ch = (unsigned char )*q;
  }
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 106
    tmp___2 = __ctype_b_loc();
    }
#line 106
    if (! ((int const   )*(*tmp___2 + (int )ch) & 8192)) {
#line 106
      goto while_break;
    }
#line 107
    q ++;
#line 107
    ch = (unsigned char )*q;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  if ((int )ch == 45) {
#line 109
    return ((strtol_error )4);
  }
  {
#line 112
  tmp = strtoul((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = 1UL;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val___0 = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val___0 = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 151
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 151
    if (tmp___7) {
      {
#line 162
      if ((int )*(*(p + 0) + 1) == 105) {
#line 162
        goto case_105;
      }
#line 168
      if ((int )*(*(p + 0) + 1) == 68) {
#line 168
        goto case_68;
      }
#line 168
      if ((int )*(*(p + 0) + 1) == 66) {
#line 168
        goto case_68;
      }
#line 160
      goto switch_break;
      case_105: /* CIL Label */ 
#line 163
      if ((int )*(*(p + 0) + 2) == 66) {
#line 164
        suffixes += 2;
      }
#line 165
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 169
      base = 1000;
#line 170
      suffixes ++;
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 177
    if ((int )*(*p) == 98) {
#line 177
      goto case_98;
    }
#line 181
    if ((int )*(*p) == 66) {
#line 181
      goto case_66___0;
    }
#line 185
    if ((int )*(*p) == 99) {
#line 185
      goto case_99;
    }
#line 189
    if ((int )*(*p) == 69) {
#line 189
      goto case_69;
    }
#line 194
    if ((int )*(*p) == 103) {
#line 194
      goto case_103;
    }
#line 194
    if ((int )*(*p) == 71) {
#line 194
      goto case_103;
    }
#line 199
    if ((int )*(*p) == 75) {
#line 199
      goto case_75;
    }
#line 199
    if ((int )*(*p) == 107) {
#line 199
      goto case_75;
    }
#line 204
    if ((int )*(*p) == 109) {
#line 204
      goto case_109;
    }
#line 204
    if ((int )*(*p) == 77) {
#line 204
      goto case_109;
    }
#line 208
    if ((int )*(*p) == 80) {
#line 208
      goto case_80;
    }
#line 213
    if ((int )*(*p) == 116) {
#line 213
      goto case_116;
    }
#line 213
    if ((int )*(*p) == 84) {
#line 213
      goto case_116;
    }
#line 217
    if ((int )*(*p) == 119) {
#line 217
      goto case_119;
    }
#line 221
    if ((int )*(*p) == 89) {
#line 221
      goto case_89;
    }
#line 225
    if ((int )*(*p) == 90) {
#line 225
      goto case_90;
    }
#line 229
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 178
    overflow = bkm_scale___0(& tmp, 512);
    }
#line 179
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale___0(& tmp, 1024);
    }
#line 183
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 186
    overflow = (strtol_error )0;
#line 187
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
    }
#line 191
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
    }
#line 196
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
    }
#line 201
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 205
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
    }
#line 206
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 209
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
    }
#line 210
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 214
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
    }
#line 215
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 218
    overflow = bkm_scale___0(& tmp, 2);
    }
#line 219
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 222
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
    }
#line 223
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 226
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
    }
#line 227
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 230
    *val___0 = tmp;
#line 231
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 234
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 235
    *p += suffixes;
#line 236
    if (*(*p)) {
#line 237
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 240
  *val___0 = tmp;
#line 241
  return (err);
}
}
#line 44 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val___0 ,
                     char const   *valid_suffixes ) ;
#line 176 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 59 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
static strtol_error bkm_scale___1(long *x , int scale_factor ) 
{ 


  {
#line 62
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 64
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 65
    return ((strtol_error )1);
  }
#line 67
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 69
    *x = 9223372036854775807L;
#line 70
    return ((strtol_error )1);
  }
#line 72
  *x *= (long )scale_factor;
#line 73
  return ((strtol_error )0);
}
}
#line 76 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
static strtol_error bkm_scale_by_power___1(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 79
  err = (strtol_error )0;
  {
#line 80
  while (1) {
    while_continue: /* CIL Label */ ;
#line 80
    tmp___0 = power;
#line 80
    power --;
#line 80
    if (! tmp___0) {
#line 80
      goto while_break;
    }
    {
#line 81
    tmp = bkm_scale___1(x, base);
#line 81
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 82
  return (err);
}
}
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val___0 ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 94
  err = (strtol_error )0;
#line 96
  if (0 <= strtol_base) {
#line 96
    if (! (strtol_base <= 36)) {
      {
#line 96
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c",
                    96U, "xstrtol");
      }
    }
  } else {
    {
#line 96
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.c",
                  96U, "xstrtol");
    }
  }
#line 98
  if (ptr) {
#line 98
    p = ptr;
  } else {
#line 98
    p = & t_ptr;
  }
  {
#line 100
  tmp___1 = __errno_location();
#line 100
  *tmp___1 = 0;
#line 112
  tmp = strtol((char const   */* __restrict  */)s, (char **/* __restrict  */)p, strtol_base);
  }
#line 114
  if ((unsigned long )*p == (unsigned long )s) {
#line 118
    if (valid_suffixes) {
#line 118
      if (*(*p)) {
        {
#line 118
        tmp___3 = strchr(valid_suffixes, (int )*(*p));
        }
#line 118
        if (tmp___3) {
#line 119
          tmp = 1L;
        } else {
#line 121
          return ((strtol_error )4);
        }
      } else {
#line 121
        return ((strtol_error )4);
      }
    } else {
#line 121
      return ((strtol_error )4);
    }
  } else {
    {
#line 123
    tmp___5 = __errno_location();
    }
#line 123
    if (*tmp___5 != 0) {
      {
#line 125
      tmp___4 = __errno_location();
      }
#line 125
      if (*tmp___4 != 34) {
#line 126
        return ((strtol_error )4);
      }
#line 127
      err = (strtol_error )1;
    }
  }
#line 133
  if (! valid_suffixes) {
#line 135
    *val___0 = tmp;
#line 136
    return (err);
  }
#line 139
  if ((int )*(*p) != 0) {
    {
#line 141
    base = 1024;
#line 142
    suffixes = 1;
#line 145
    tmp___6 = strchr(valid_suffixes, (int )*(*p));
    }
#line 145
    if (! tmp___6) {
#line 147
      *val___0 = tmp;
#line 148
      return ((strtol_error )((unsigned int )err | 2U));
    }
    {
#line 151
    tmp___7 = strchr(valid_suffixes, '0');
    }
#line 151
    if (tmp___7) {
      {
#line 162
      if ((int )*(*(p + 0) + 1) == 105) {
#line 162
        goto case_105;
      }
#line 168
      if ((int )*(*(p + 0) + 1) == 68) {
#line 168
        goto case_68;
      }
#line 168
      if ((int )*(*(p + 0) + 1) == 66) {
#line 168
        goto case_68;
      }
#line 160
      goto switch_break;
      case_105: /* CIL Label */ 
#line 163
      if ((int )*(*(p + 0) + 2) == 66) {
#line 164
        suffixes += 2;
      }
#line 165
      goto switch_break;
      case_68: /* CIL Label */ 
      case_66: /* CIL Label */ 
#line 169
      base = 1000;
#line 170
      suffixes ++;
#line 171
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 177
    if ((int )*(*p) == 98) {
#line 177
      goto case_98;
    }
#line 181
    if ((int )*(*p) == 66) {
#line 181
      goto case_66___0;
    }
#line 185
    if ((int )*(*p) == 99) {
#line 185
      goto case_99;
    }
#line 189
    if ((int )*(*p) == 69) {
#line 189
      goto case_69;
    }
#line 194
    if ((int )*(*p) == 103) {
#line 194
      goto case_103;
    }
#line 194
    if ((int )*(*p) == 71) {
#line 194
      goto case_103;
    }
#line 199
    if ((int )*(*p) == 75) {
#line 199
      goto case_75;
    }
#line 199
    if ((int )*(*p) == 107) {
#line 199
      goto case_75;
    }
#line 204
    if ((int )*(*p) == 109) {
#line 204
      goto case_109;
    }
#line 204
    if ((int )*(*p) == 77) {
#line 204
      goto case_109;
    }
#line 208
    if ((int )*(*p) == 80) {
#line 208
      goto case_80;
    }
#line 213
    if ((int )*(*p) == 116) {
#line 213
      goto case_116;
    }
#line 213
    if ((int )*(*p) == 84) {
#line 213
      goto case_116;
    }
#line 217
    if ((int )*(*p) == 119) {
#line 217
      goto case_119;
    }
#line 221
    if ((int )*(*p) == 89) {
#line 221
      goto case_89;
    }
#line 225
    if ((int )*(*p) == 90) {
#line 225
      goto case_90;
    }
#line 229
    goto switch_default;
    case_98: /* CIL Label */ 
    {
#line 178
    overflow = bkm_scale___1(& tmp, 512);
    }
#line 179
    goto switch_break___0;
    case_66___0: /* CIL Label */ 
    {
#line 182
    overflow = bkm_scale___1(& tmp, 1024);
    }
#line 183
    goto switch_break___0;
    case_99: /* CIL Label */ 
#line 186
    overflow = (strtol_error )0;
#line 187
    goto switch_break___0;
    case_69: /* CIL Label */ 
    {
#line 190
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
    }
#line 191
    goto switch_break___0;
    case_103: /* CIL Label */ 
    case_71: /* CIL Label */ 
    {
#line 195
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
    }
#line 196
    goto switch_break___0;
    case_75: /* CIL Label */ 
    case_107: /* CIL Label */ 
    {
#line 200
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
    }
#line 201
    goto switch_break___0;
    case_109: /* CIL Label */ 
    case_77: /* CIL Label */ 
    {
#line 205
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
    }
#line 206
    goto switch_break___0;
    case_80: /* CIL Label */ 
    {
#line 209
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
    }
#line 210
    goto switch_break___0;
    case_116: /* CIL Label */ 
    case_84: /* CIL Label */ 
    {
#line 214
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
    }
#line 215
    goto switch_break___0;
    case_119: /* CIL Label */ 
    {
#line 218
    overflow = bkm_scale___1(& tmp, 2);
    }
#line 219
    goto switch_break___0;
    case_89: /* CIL Label */ 
    {
#line 222
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
    }
#line 223
    goto switch_break___0;
    case_90: /* CIL Label */ 
    {
#line 226
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
    }
#line 227
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 230
    *val___0 = tmp;
#line 231
    return ((strtol_error )((unsigned int )err | 2U));
    switch_break___0: /* CIL Label */ ;
    }
#line 234
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 235
    *p += suffixes;
#line 236
    if (*(*p)) {
#line 237
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 240
  *val___0 = tmp;
#line 241
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol.h"
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options ,
                                                  char const   *arg___0 ) ;
#line 588 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 18 "/home/khheo/project/benchmark/tar-1.29/gnu/exitfail.h"
int volatile   exit_failure ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 46 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options ,
                          char const   *arg___0 , int exit_status___0 ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *rpl_option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
  {
#line 62
  if ((unsigned int )err == 4U) {
#line 62
    goto case_4;
  }
#line 67
  if ((unsigned int )err == 3U) {
#line 67
    goto case_3;
  }
#line 67
  if ((unsigned int )err == 2U) {
#line 67
    goto case_3;
  }
#line 71
  if ((unsigned int )err == 1U) {
#line 71
    goto case_1;
  }
#line 59
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 60
  abort();
  }
  case_4: /* CIL Label */ 
#line 63
  msgid = "invalid %s%s argument \'%s\'";
#line 64
  goto switch_break;
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 68
  msgid = "invalid suffix in %s%s argument \'%s\'";
#line 69
  goto switch_break;
  case_1: /* CIL Label */ 
#line 72
  msgid = "%s%s argument \'%s\' too large";
#line 73
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    rpl_option = (char const   *)(option_buffer);
  } else {
#line 84
    rpl_option = (char const   *)(long_options + opt_idx)->name;
  }
  {
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status___0, 0, (char const   *)tmp, hyphens, rpl_option, arg___0);
  }
#line 87
  return;
}
}
#line 91
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct rpl_option  const  *long_options ,
                                                  char const   *arg___0 ) ;
#line 91 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct rpl_option  const  *long_options ,
                   char const   *arg___0 ) 
{ 


  {
  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options, arg___0, (int )exit_failure);
#line 97
  abort();
  }
}
}
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 174 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
  }
#line 33
  if (! s) {
    {
#line 34
    xalloc_die();
    }
  }
#line 35
  return (s);
}
}
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
#pragma GCC diagnostic push
#line 33
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 33
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 115
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 60
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 62
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 66
void *x2realloc(void *p , size_t *pn ) ;
#line 67
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 69
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 262
#pragma GCC diagnostic pop
#line 539 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 541
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 549
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 563
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 60 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(n);
#line 41
  p = tmp;
  }
#line 42
  if (! p) {
#line 42
    if (n != 0UL) {
      {
#line 43
      xalloc_die();
      }
    }
  }
#line 44
  return (p);
}
}
#line 50
void *xrealloc(void *p , size_t n )  __attribute__((__alloc_size__(2))) ;
#line 50 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 53
  if (! n) {
#line 53
    if (p) {
      {
#line 57
      free(p);
      }
#line 58
      return ((void *)0);
    }
  }
  {
#line 61
  p = realloc(p, n);
  }
#line 62
  if (! p) {
#line 62
    if (n) {
      {
#line 63
      xalloc_die();
      }
    }
  }
#line 64
  return (p);
}
}
#line 73 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
  {
#line 76
  tmp = x2nrealloc(p, pn, (size_t )1);
  }
#line 76
  return (tmp);
}
}
#line 83
void *xzalloc(size_t s )  __attribute__((__malloc__, __alloc_size__(1))) ;
#line 83 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 86
  tmp = xmalloc(s);
#line 86
  tmp___0 = memset(tmp, 0, s);
  }
#line 86
  return (tmp___0);
}
}
#line 92
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__, __alloc_size__(1,2))) ;
#line 92 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
  {
#line 100
  p = calloc(n, s);
  }
#line 100
  if (! p) {
    {
#line 102
    xalloc_die();
    }
  }
#line 103
  return (p);
}
}
#line 110
void *xmemdup(void const   *p , size_t s )  __attribute__((__alloc_size__(2))) ;
#line 110 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 113
  tmp = xmalloc(s);
#line 113
  tmp___0 = memcpy((void */* __restrict  */)tmp, (void const   */* __restrict  */)p,
                   s);
  }
#line 113
  return (tmp___0);
}
}
#line 118
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 118 "/home/khheo/project/benchmark/tar-1.29/gnu/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 121
  tmp = strlen(string);
#line 121
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
  }
#line 121
  return ((char *)tmp___0);
}
}
#line 17 "/home/khheo/project/benchmark/tar-1.29/gnu/xgetcwd.h"
char *xgetcwd(void) ;
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/tar-1.29/gnu/xgetcwd.c"
char *xgetcwd(void) 
{ 
  char *cwd___0 ;
  char *tmp ;
  int *tmp___0 ;

  {
  {
#line 37
  tmp = getcwd((char *)((void *)0), (size_t )0);
#line 37
  cwd___0 = tmp;
  }
#line 38
  if (! cwd___0) {
    {
#line 38
    tmp___0 = __errno_location();
    }
#line 38
    if (*tmp___0 == 12) {
      {
#line 39
      xalloc_die();
      }
    }
  }
#line 40
  return (cwd___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 46 "/home/khheo/project/benchmark/tar-1.29/gnu/xvasprintf.h"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) ;
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/xasprintf.c"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) 
{ 
  va_list args___0 ;
  char *result ;

  {
  {
#line 29
  __builtin_va_start(args___0, format);
#line 30
  result = xvasprintf(format, args___0);
#line 31
  __builtin_va_end(args___0);
  }
#line 33
  return (result);
}
}
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
  }
}
}
#line 41 "./uniwidth.h"
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 136 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 20 "/home/khheo/project/benchmark/tar-1.29/gnu/uniwidth/cjk.h"
static int is_cjk_encoding(char const   *encoding ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 23
  tmp = strcmp(encoding, "EUC-JP");
  }
#line 23
  if (tmp == 0) {
#line 35
    return (1);
  } else {
    {
#line 23
    tmp___0 = strcmp(encoding, "GB2312");
    }
#line 23
    if (tmp___0 == 0) {
#line 35
      return (1);
    } else {
      {
#line 23
      tmp___1 = strcmp(encoding, "GBK");
      }
#line 23
      if (tmp___1 == 0) {
#line 35
        return (1);
      } else {
        {
#line 23
        tmp___2 = strcmp(encoding, "EUC-TW");
        }
#line 23
        if (tmp___2 == 0) {
#line 35
          return (1);
        } else {
          {
#line 23
          tmp___3 = strcmp(encoding, "BIG5");
          }
#line 23
          if (tmp___3 == 0) {
#line 35
            return (1);
          } else {
            {
#line 23
            tmp___4 = strcmp(encoding, "EUC-KR");
            }
#line 23
            if (tmp___4 == 0) {
#line 35
              return (1);
            } else {
              {
#line 23
              tmp___5 = strcmp(encoding, "CP949");
              }
#line 23
              if (tmp___5 == 0) {
#line 35
                return (1);
              } else {
                {
#line 23
                tmp___6 = strcmp(encoding, "JOHAB");
                }
#line 23
                if (tmp___6 == 0) {
#line 35
                  return (1);
                }
              }
            }
          }
        }
      }
    }
  }
#line 36
  return (0);
}
}
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/uniwidth/width.c"
static unsigned char const   nonspacing_table_data[2304]  = 
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/uniwidth/width.c"
  {      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )191, 
        (unsigned char const   )182,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )23, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )191, 
        (unsigned char const   )159,      (unsigned char const   )61,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )251, 
        (unsigned char const   )239,      (unsigned char const   )62,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )248,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )20, 
        (unsigned char const   )254,      (unsigned char const   )33,      (unsigned char const   )254,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )134,      (unsigned char const   )57,      (unsigned char const   )2,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )35,      (unsigned char const   )0, 
        (unsigned char const   )6,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )190,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )144, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )193,      (unsigned char const   )61,      (unsigned char const   )96,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )30,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )12,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )4,      (unsigned char const   )92,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )7, 
        (unsigned char const   )128,      (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )242,      (unsigned char const   )27, 
        (unsigned char const   )0,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )160,      (unsigned char const   )2, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )254,      (unsigned char const   )127, 
        (unsigned char const   )223,      (unsigned char const   )224,      (unsigned char const   )255,      (unsigned char const   )254, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )31, 
        (unsigned char const   )64,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )224,      (unsigned char const   )253,      (unsigned char const   )102, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )195, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )30,      (unsigned char const   )0, 
        (unsigned char const   )100,      (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )12,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )176,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )254,      (unsigned char const   )15,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )135,      (unsigned char const   )1,      (unsigned char const   )4,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )9, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64,      (unsigned char const   )127, 
        (unsigned char const   )229,      (unsigned char const   )31,      (unsigned char const   )248,      (unsigned char const   )159, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )208,      (unsigned char const   )23, 
        (unsigned char const   )4,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )15,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )60,      (unsigned char const   )59,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )64,      (unsigned char const   )163,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )240,      (unsigned char const   )207,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )247,      (unsigned char const   )255, 
        (unsigned char const   )253,      (unsigned char const   )33,      (unsigned char const   )16,      (unsigned char const   )3, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )63,      (unsigned char const   )240, 
        (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )124,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )223,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )1,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )6, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )247,      (unsigned char const   )63, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )68,      (unsigned char const   )8,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )63,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )255,      (unsigned char const   )3,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )200,      (unsigned char const   )19, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )126,      (unsigned char const   )102,      (unsigned char const   )0, 
        (unsigned char const   )8,      (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )157,      (unsigned char const   )193, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )48,      (unsigned char const   )64,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )64, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )14, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )32, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )7, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )110,      (unsigned char const   )240,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )135, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )96,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )2,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )255, 
        (unsigned char const   )127,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )120,      (unsigned char const   )38, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )239,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )8,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )192,      (unsigned char const   )127, 
        (unsigned char const   )0,      (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )211,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )128, 
        (unsigned char const   )248,      (unsigned char const   )7,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )3,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )16, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )192,      (unsigned char const   )31,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )133, 
        (unsigned char const   )13,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )176, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )48, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248,      (unsigned char const   )167, 
        (unsigned char const   )1,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )40,      (unsigned char const   )191,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )224, 
        (unsigned char const   )188,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )31,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )128,      (unsigned char const   )7,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )96, 
        (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )128,      (unsigned char const   )3,      (unsigned char const   )248,      (unsigned char const   )255, 
        (unsigned char const   )231,      (unsigned char const   )15,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )60,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )28,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )127,      (unsigned char const   )248, 
        (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255,      (unsigned char const   )255, 
        (unsigned char const   )255,      (unsigned char const   )31,      (unsigned char const   )32,      (unsigned char const   )0, 
        (unsigned char const   )16,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )248, 
        (unsigned char const   )254,      (unsigned char const   )255,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )127,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
#line 361 "/home/khheo/project/benchmark/tar-1.29/gnu/uniwidth/width.c"
static signed char const   nonspacing_table_ind[248]  = 
#line 361
  {      (signed char const   )0,      (signed char const   )1,      (signed char const   )2,      (signed char const   )3, 
        (signed char const   )4,      (signed char const   )5,      (signed char const   )6,      (signed char const   )7, 
        (signed char const   )8,      (signed char const   )9,      (signed char const   )-1,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )-1, 
        (signed char const   )14,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )15,      (signed char const   )-1, 
        (signed char const   )16,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )17, 
        (signed char const   )18,      (signed char const   )19,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )20,      (signed char const   )-1,      (signed char const   )21, 
        (signed char const   )22,      (signed char const   )23,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )24,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )25,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )29,      (signed char const   )-1,      (signed char const   )30, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )31,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )32,      (signed char const   )33,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )34,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )35,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 396
int uc_width(ucs4_t uc , char const   *encoding )  __attribute__((__pure__)) ;
#line 396 "/home/khheo/project/benchmark/tar-1.29/gnu/uniwidth/width.c"
int uc_width(ucs4_t uc , char const   *encoding ) 
{ 
  int ind ;
  int tmp ;
  int tmp___0 ;

  {
#line 400
  if (uc >> 9 < 248U) {
#line 402
    ind = (int )nonspacing_table_ind[uc >> 9];
#line 403
    if (ind >= 0) {
#line 404
      if (((int const   )nonspacing_table_data[(unsigned int )(64 * ind) + ((uc >> 3) & 63U)] >> (uc & 7U)) & 1) {
#line 406
        if (uc > 0U) {
#line 406
          if (uc < 160U) {
#line 407
            return (-1);
          } else {
#line 409
            return (0);
          }
        } else {
#line 409
          return (0);
        }
      }
    }
  } else
#line 412
  if (uc >> 9 == (ucs4_t )(917504 >> 9)) {
#line 414
    if (uc >= 917760U) {
#line 416
      if (uc <= 917999U) {
#line 417
        return (0);
      }
    } else {
#line 421
      if (uc >= 917536U) {
#line 421
        tmp = uc <= 917631U;
      } else {
#line 421
        tmp = uc == 917505U;
      }
#line 421
      if (tmp) {
#line 422
        return (0);
      }
    }
  }
#line 429
  if (uc >= 4352U) {
#line 429
    if (uc < 4448U) {
#line 443
      return (2);
    } else
#line 429
    if (uc >= 9001U) {
#line 429
      if (uc < 9003U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___9;
      }
    } else
    _L___9: /* CIL Label */ 
#line 429
    if (uc >= 11904U) {
#line 429
      if (uc < 42192U) {
#line 429
        if (! (uc == 12351U)) {
#line 429
          if (uc >= 19904U) {
#line 429
            if (uc < 19968U) {
#line 429
              goto _L___8;
            } else {
#line 443
              return (2);
            }
          } else {
#line 443
            return (2);
          }
        } else {
#line 429
          goto _L___8;
        }
      } else {
#line 429
        goto _L___8;
      }
    } else
    _L___8: /* CIL Label */ 
#line 429
    if (uc >= 44032U) {
#line 429
      if (uc < 55204U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 429
    if (uc >= 63744U) {
#line 429
      if (uc < 64256U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 429
    if (uc >= 65040U) {
#line 429
      if (uc < 65056U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 429
    if (uc >= 65072U) {
#line 429
      if (uc < 65136U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 429
    if (uc >= 65280U) {
#line 429
      if (uc < 65377U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 429
    if (uc >= 65504U) {
#line 429
      if (uc < 65511U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 429
    if (uc >= 131072U) {
#line 429
      if (uc <= 196607U) {
#line 443
        return (2);
      } else {
#line 429
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 429
    if (uc >= 196608U) {
#line 429
      if (uc <= 262143U) {
#line 443
        return (2);
      }
    }
  }
#line 446
  if (uc >= 161U) {
#line 446
    if (uc < 65377U) {
#line 446
      if (uc != 8361U) {
        {
#line 446
        tmp___0 = is_cjk_encoding(encoding);
        }
#line 446
        if (tmp___0) {
#line 448
          return (2);
        }
      }
    }
  }
#line 449
  return (1);
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 136 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 312
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 318
extern int printf(char const   * __restrict  __format  , ...) ;
#line 662
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 34 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc.h"
char const   version_etc_copyright[47] ;
#line 52
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 63
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 69
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 61 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 67
  if (command_name) {
    {
#line 68
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s (%s) %s\n",
            command_name, package, version);
    }
  } else {
    {
#line 70
    fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"%s %s\n",
            package, version);
    }
  }
  {
#line 84
  tmp = gettext("(C)");
#line 84
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)(version_etc_copyright),
          tmp, 2015);
#line 86
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 86
  fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
  }
  {
#line 97
  if (n_authors == 0UL) {
#line 97
    goto case_0;
  }
#line 100
  if (n_authors == 1UL) {
#line 100
    goto case_1;
  }
#line 104
  if (n_authors == 2UL) {
#line 104
    goto case_2;
  }
#line 108
  if (n_authors == 3UL) {
#line 108
    goto case_3;
  }
#line 113
  if (n_authors == 4UL) {
#line 113
    goto case_4;
  }
#line 120
  if (n_authors == 5UL) {
#line 120
    goto case_5;
  }
#line 127
  if (n_authors == 6UL) {
#line 127
    goto case_6;
  }
#line 135
  if (n_authors == 7UL) {
#line 135
    goto case_7;
  }
#line 143
  if (n_authors == 8UL) {
#line 143
    goto case_8;
  }
#line 152
  if (n_authors == 9UL) {
#line 152
    goto case_9;
  }
#line 161
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 99
  abort();
  }
  case_1: /* CIL Label */ 
  {
#line 102
  tmp___1 = gettext("Written by %s.\n");
#line 102
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___1,
          *(authors + 0));
  }
#line 103
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 106
  tmp___2 = gettext("Written by %s and %s.\n");
#line 106
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___2,
          *(authors + 0), *(authors + 1));
  }
#line 107
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 110
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 110
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___3,
          *(authors + 0), *(authors + 1), *(authors + 2));
  }
#line 112
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 117
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 117
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___4,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3));
  }
#line 119
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 124
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 124
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___5,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
  }
#line 126
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 131
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 131
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___6,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5));
  }
#line 134
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 139
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 139
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___7,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6));
  }
#line 142
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 147
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 147
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___8,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7));
  }
#line 151
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 156
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 156
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___9,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 160
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 167
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 167
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)tmp___10,
          *(authors + 0), *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4),
          *(authors + 5), *(authors + 6), *(authors + 7), *(authors + 8));
  }
#line 171
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 173
  return;
}
}
#line 179 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 186
  n_authors = (size_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *(authors + n_authors)) {
#line 186
      goto while_break;
    }
#line 186
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 188
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
  }
#line 189
  return;
}
}
#line 195 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 203
  n_authors = (size_t )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    if (n_authors < 10UL) {
      {
#line 203
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 203
      tmp = tmp___0;
#line 203
      authtab[n_authors] = tmp;
      }
#line 203
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 203
        goto while_break;
      }
    } else {
#line 203
      goto while_break;
    }
#line 203
    n_authors ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 208
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
  }
#line 210
  return;
}
}
#line 226
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 226 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
  {
#line 233
  __builtin_va_start(authors, version);
#line 234
  version_etc_va(stream, command_name, package, version, authors);
#line 235
  __builtin_va_end(authors);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 245
  tmp = gettext("\nReport bugs to: %s\n");
#line 245
  printf((char const   */* __restrict  */)tmp, "bug-tar@gnu.org");
#line 251
  tmp___0 = gettext("%s home page: <%s>\n");
#line 251
  printf((char const   */* __restrict  */)tmp___0, "GNU tar", "http://www.gnu.org/software/tar/");
#line 256
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 256
  fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdout);
  }
#line 258
  return;
}
}
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 72 "/home/khheo/project/benchmark/tar-1.29/gnu/vasnprintf.h"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args___0 ) ;
#line 340 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 154 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.h"
int printf_fetchargs(va_list args___0 , arguments *a ) ;
#line 188 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
#pragma GCC diagnostic push
#line 33
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 33
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 115
#pragma GCC diagnostic pop
#line 1772 "/home/khheo/project/benchmark/tar-1.29/gnu/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args___0 ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  arg_type type ;
  int flags ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  int orig_errno ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t n___0 ;
  char const   *mp ;
  char *tmp___24 ;
  char const   *tmp___25 ;
  size_t n___1 ;
  char const   *mp___0 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  unsigned int tmp___31 ;
  unsigned int tmp___32 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___33 ;
  size_t __attribute__((__pure__))  tmp___34 ;
  size_t __attribute__((__pure__))  tmp___35 ;
  void *tmp___36 ;
  void *tmp___37 ;
  size_t __attribute__((__pure__))  tmp___38 ;
  int *tmp___39 ;
  int count ;
  int retcount ;
  size_t maxlen ;
  int *tmp___40 ;
  int arg___0 ;
  unsigned int arg___1 ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  long arg___6 ;
  unsigned long arg___7 ;
  long long arg___8 ;
  unsigned long long arg___9 ;
  double arg___10 ;
  long double arg___11 ;
  int arg___12 ;
  wint_t arg___13 ;
  char const   *arg___14 ;
  wchar_t const   *arg___15 ;
  void *arg___16 ;
  int saved_errno ;
  int *tmp___41 ;
  int *tmp___42 ;
  size_t n___2 ;
  size_t tmp___43 ;
  size_t __attribute__((__pure__))  tmp___44 ;
  size_t __attribute__((__pure__))  tmp___45 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___46 ;
  void *tmp___47 ;
  void *tmp___48 ;
  int *tmp___49 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___50 ;
  size_t __attribute__((__pure__))  tmp___51 ;
  size_t __attribute__((__pure__))  tmp___52 ;
  void *tmp___53 ;
  void *tmp___54 ;
  size_t __attribute__((__pure__))  tmp___55 ;
  char *memory___4 ;
  void *tmp___56 ;
  int *tmp___57 ;
  int *tmp___58 ;

  {
  {
#line 1779
  tmp = printf_parse(format, & d, & a);
  }
#line 1779
  if (tmp < 0) {
#line 1781
    return ((char *)((void *)0));
  }
  {
#line 1789
  tmp___1 = printf_fetchargs(args___0, & a);
  }
#line 1789
  if (tmp___1 < 0) {
#line 1791
    if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
      {
#line 1791
      free((void *)d.dir);
      }
    }
#line 1791
    if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
      {
#line 1791
      free((void *)a.arg);
      }
    }
    {
#line 1792
    tmp___0 = __errno_location();
#line 1792
    *tmp___0 = 22;
    }
#line 1793
    return ((char *)((void *)0));
  }
  {
#line 1810
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1810
  buf_neededlength = (size_t )tmp___2;
  }
#line 1813
  if (buf_neededlength < 4000UL / sizeof(char )) {
    {
#line 1815
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1815
    buf = (char *)tmp___3;
#line 1816
    buf_malloced = (char *)((void *)0);
    }
  } else {
#line 1821
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1821
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1821
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1821
    buf_memsize = tmp___4;
#line 1822
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1823
      goto out_of_memory_1;
    }
    {
#line 1824
    tmp___5 = malloc(buf_memsize);
#line 1824
    buf = (char *)tmp___5;
    }
#line 1825
    if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 1826
      goto out_of_memory_1;
    }
#line 1827
    buf_malloced = buf;
  }
#line 1830
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1832
    result = resultbuf;
#line 1833
    allocated = *lengthp;
  } else {
#line 1837
    result = (char *)((void *)0);
#line 1838
    allocated = (size_t )0;
  }
#line 1840
  length = (size_t )0;
#line 1870
  cp = format;
#line 1870
  i = (size_t )0;
#line 1870
  dp = d.dir + 0;
  {
#line 1870
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1872
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
      {
#line 1874
      n = (size_t )(dp->dir_start - cp);
#line 1875
      tmp___6 = xsum(length, n);
#line 1875
      augmented_length = (size_t )tmp___6;
      }
#line 1877
      if (augmented_length > allocated) {
#line 1877
        if (allocated > 0UL) {
#line 1877
          if (allocated <= 9223372036854775807UL) {
#line 1877
            tmp___7 = allocated * 2UL;
          } else {
#line 1877
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1877
          allocated = tmp___7;
        } else {
#line 1877
          allocated = (size_t )12;
        }
#line 1877
        if (augmented_length > allocated) {
#line 1877
          allocated = augmented_length;
        }
#line 1877
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1877
          memory_size = allocated * sizeof(char );
        } else {
#line 1877
          memory_size = 0xffffffffffffffffUL;
        }
#line 1877
        if (memory_size == 0xffffffffffffffffUL) {
#line 1877
          goto out_of_memory;
        }
#line 1877
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1877
          tmp___8 = malloc(memory_size);
#line 1877
          memory = (char *)tmp___8;
          }
        } else
#line 1877
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1877
          tmp___8 = malloc(memory_size);
#line 1877
          memory = (char *)tmp___8;
          }
        } else {
          {
#line 1877
          tmp___9 = realloc((void *)result, memory_size);
#line 1877
          memory = (char *)tmp___9;
          }
        }
#line 1877
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1877
          goto out_of_memory;
        }
#line 1877
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1877
          if (length > 0UL) {
            {
#line 1877
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1877
        result = memory;
      }
#line 1881
      if (sizeof(char ) == sizeof(char )) {
        {
#line 1883
        memcpy((void */* __restrict  */)(result + length), (void const   */* __restrict  */)cp,
               n);
#line 1884
        length = augmented_length;
        }
      } else {
        {
#line 1888
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1889
          tmp___10 = length;
#line 1889
          length ++;
#line 1889
          tmp___11 = cp;
#line 1889
          cp ++;
#line 1889
          *(result + tmp___10) = (char )*tmp___11;
#line 1888
          n --;
#line 1888
          if (! (n > 0UL)) {
#line 1888
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1893
    if (i == d.count) {
#line 1894
      goto while_break;
    }
#line 1897
    if ((int )dp->conversion == 37) {
#line 1901
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
        {
#line 1902
        abort();
        }
      }
      {
#line 1903
      tmp___12 = xsum(length, (size_t )1);
#line 1903
      augmented_length___0 = (size_t )tmp___12;
      }
#line 1904
      if (augmented_length___0 > allocated) {
#line 1904
        if (allocated > 0UL) {
#line 1904
          if (allocated <= 9223372036854775807UL) {
#line 1904
            tmp___13 = allocated * 2UL;
          } else {
#line 1904
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1904
          allocated = tmp___13;
        } else {
#line 1904
          allocated = (size_t )12;
        }
#line 1904
        if (augmented_length___0 > allocated) {
#line 1904
          allocated = augmented_length___0;
        }
#line 1904
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1904
          memory_size___0 = allocated * sizeof(char );
        } else {
#line 1904
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1904
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1904
          goto out_of_memory;
        }
#line 1904
        if ((unsigned long )result == (unsigned long )resultbuf) {
          {
#line 1904
          tmp___14 = malloc(memory_size___0);
#line 1904
          memory___0 = (char *)tmp___14;
          }
        } else
#line 1904
        if ((unsigned long )result == (unsigned long )((void *)0)) {
          {
#line 1904
          tmp___14 = malloc(memory_size___0);
#line 1904
          memory___0 = (char *)tmp___14;
          }
        } else {
          {
#line 1904
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1904
          memory___0 = (char *)tmp___15;
          }
        }
#line 1904
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1904
          goto out_of_memory;
        }
#line 1904
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1904
          if (length > 0UL) {
            {
#line 1904
            memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)result,
                   length);
            }
          }
        }
#line 1904
        result = memory___0;
      }
#line 1905
      *(result + length) = (char )'%';
#line 1906
      length = augmented_length___0;
    } else {
#line 1910
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
        {
#line 1911
        abort();
        }
      }
#line 1913
      if ((int )dp->conversion == 110) {
        {
#line 1917
        if ((unsigned int )(a.arg + dp->arg_index)->type == 18U) {
#line 1917
          goto case_18;
        }
#line 1920
        if ((unsigned int )(a.arg + dp->arg_index)->type == 19U) {
#line 1920
          goto case_19;
        }
#line 1923
        if ((unsigned int )(a.arg + dp->arg_index)->type == 20U) {
#line 1923
          goto case_20;
        }
#line 1926
        if ((unsigned int )(a.arg + dp->arg_index)->type == 21U) {
#line 1926
          goto case_21;
        }
#line 1930
        if ((unsigned int )(a.arg + dp->arg_index)->type == 22U) {
#line 1930
          goto case_22;
        }
#line 1934
        goto switch_default;
        case_18: /* CIL Label */ 
#line 1918
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1919
        goto switch_break;
        case_19: /* CIL Label */ 
#line 1921
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1922
        goto switch_break;
        case_20: /* CIL Label */ 
#line 1924
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1925
        goto switch_break;
        case_21: /* CIL Label */ 
#line 1927
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1928
        goto switch_break;
        case_22: /* CIL Label */ 
#line 1931
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1932
        goto switch_break;
        switch_default: /* CIL Label */ 
        {
#line 1935
        abort();
        }
        switch_break: /* CIL Label */ ;
        }
      } else {
#line 4589
        type = (a.arg + dp->arg_index)->type;
#line 4590
        flags = dp->flags;
#line 4756
        fbp = buf;
#line 4757
        tmp___16 = fbp;
#line 4757
        fbp ++;
#line 4757
        *tmp___16 = (char )'%';
#line 4763
        if (flags & 1) {
#line 4764
          tmp___17 = fbp;
#line 4764
          fbp ++;
#line 4764
          *tmp___17 = (char )'\'';
        }
#line 4766
        if (flags & 2) {
#line 4767
          tmp___18 = fbp;
#line 4767
          fbp ++;
#line 4767
          *tmp___18 = (char )'-';
        }
#line 4768
        if (flags & 4) {
#line 4769
          tmp___19 = fbp;
#line 4769
          fbp ++;
#line 4769
          *tmp___19 = (char )'+';
        }
#line 4770
        if (flags & 8) {
#line 4771
          tmp___20 = fbp;
#line 4771
          fbp ++;
#line 4771
          *tmp___20 = (char )' ';
        }
#line 4772
        if (flags & 16) {
#line 4773
          tmp___21 = fbp;
#line 4773
          fbp ++;
#line 4773
          *tmp___21 = (char )'#';
        }
#line 4775
        if (flags & 64) {
#line 4776
          tmp___22 = fbp;
#line 4776
          fbp ++;
#line 4776
          *tmp___22 = (char )'I';
        }
#line 4780
        if (flags & 32) {
#line 4781
          tmp___23 = fbp;
#line 4781
          fbp ++;
#line 4781
          *tmp___23 = (char )'0';
        }
#line 4782
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4784
          n___0 = (size_t )(dp->width_end - dp->width_start);
#line 4787
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4789
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->width_start,
                   n___0 * sizeof(char ));
#line 4790
            fbp += n___0;
            }
          } else {
#line 4794
            mp = dp->width_start;
            {
#line 4795
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 4796
              tmp___24 = fbp;
#line 4796
              fbp ++;
#line 4796
              tmp___25 = mp;
#line 4796
              mp ++;
#line 4796
              *tmp___24 = (char )*tmp___25;
#line 4795
              n___0 --;
#line 4795
              if (! (n___0 > 0UL)) {
#line 4795
                goto while_break___1;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 4803
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4805
          n___1 = (size_t )(dp->precision_end - dp->precision_start);
#line 4808
          if (sizeof(char ) == sizeof(char )) {
            {
#line 4810
            memcpy((void */* __restrict  */)fbp, (void const   */* __restrict  */)dp->precision_start,
                   n___1 * sizeof(char ));
#line 4811
            fbp += n___1;
            }
          } else {
#line 4815
            mp___0 = dp->precision_start;
            {
#line 4816
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 4817
              tmp___26 = fbp;
#line 4817
              fbp ++;
#line 4817
              tmp___27 = mp___0;
#line 4817
              mp___0 ++;
#line 4817
              *tmp___26 = (char )*tmp___27;
#line 4816
              n___1 --;
#line 4816
              if (! (n___1 > 0UL)) {
#line 4816
                goto while_break___2;
              }
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        }
        {
#line 4827
        if ((unsigned int )type == 10U) {
#line 4827
          goto case_10;
        }
#line 4827
        if ((unsigned int )type == 9U) {
#line 4827
          goto case_10;
        }
#line 4844
        if ((unsigned int )type == 16U) {
#line 4844
          goto case_16;
        }
#line 4844
        if ((unsigned int )type == 14U) {
#line 4844
          goto case_16;
        }
#line 4844
        if ((unsigned int )type == 8U) {
#line 4844
          goto case_16;
        }
#line 4844
        if ((unsigned int )type == 7U) {
#line 4844
          goto case_16;
        }
#line 4848
        if ((unsigned int )type == 12U) {
#line 4848
          goto case_12;
        }
#line 4851
        goto switch_default___0;
        case_10: /* CIL Label */ 
        case_9: /* CIL Label */ 
#line 4834
        tmp___28 = fbp;
#line 4834
        fbp ++;
#line 4834
        *tmp___28 = (char )'l';
        case_16: /* CIL Label */ 
        case_14: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_7: /* CIL Label */ 
#line 4846
        tmp___29 = fbp;
#line 4846
        fbp ++;
#line 4846
        *tmp___29 = (char )'l';
#line 4847
        goto switch_break___0;
        case_12: /* CIL Label */ 
#line 4849
        tmp___30 = fbp;
#line 4849
        fbp ++;
#line 4849
        *tmp___30 = (char )'L';
#line 4850
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 4852
        goto switch_break___0;
        switch_break___0: /* CIL Label */ ;
        }
#line 4859
        *fbp = dp->conversion;
#line 4890
        *(fbp + 1) = (char )'\000';
#line 4897
        prefix_count = 0U;
#line 4898
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4900
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
            {
#line 4901
            abort();
            }
          }
#line 4902
          tmp___31 = prefix_count;
#line 4902
          prefix_count ++;
#line 4902
          prefixes[tmp___31] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4904
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4906
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
            {
#line 4907
            abort();
            }
          }
#line 4908
          tmp___32 = prefix_count;
#line 4908
          prefix_count ++;
#line 4908
          prefixes[tmp___32] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
        {
#line 4920
        tmp___38 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
        }
#line 4920
        if (tmp___38 > (size_t __attribute__((__pure__))  )allocated) {
#line 4920
          if (allocated > 0UL) {
#line 4920
            if (allocated <= 9223372036854775807UL) {
#line 4920
              tmp___33 = allocated * 2UL;
            } else {
#line 4920
              tmp___33 = 0xffffffffffffffffUL;
            }
#line 4920
            allocated = tmp___33;
          } else {
#line 4920
            allocated = (size_t )12;
          }
          {
#line 4920
          tmp___35 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
          }
#line 4920
          if (tmp___35 > (size_t __attribute__((__pure__))  )allocated) {
            {
#line 4920
            tmp___34 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4920
            allocated = (size_t )tmp___34;
            }
          }
#line 4920
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4920
            memory_size___1 = allocated * sizeof(char );
          } else {
#line 4920
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 4920
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4920
            goto out_of_memory;
          }
#line 4920
          if ((unsigned long )result == (unsigned long )resultbuf) {
            {
#line 4920
            tmp___36 = malloc(memory_size___1);
#line 4920
            memory___1 = (char *)tmp___36;
            }
          } else
#line 4920
          if ((unsigned long )result == (unsigned long )((void *)0)) {
            {
#line 4920
            tmp___36 = malloc(memory_size___1);
#line 4920
            memory___1 = (char *)tmp___36;
            }
          } else {
            {
#line 4920
            tmp___37 = realloc((void *)result, memory_size___1);
#line 4920
            memory___1 = (char *)tmp___37;
            }
          }
#line 4920
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4920
            goto out_of_memory;
          }
#line 4920
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4920
            if (length > 0UL) {
              {
#line 4920
              memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)result,
                     length);
              }
            }
          }
#line 4920
          result = memory___1;
        }
        {
#line 4925
        *(result + length) = (char )'\000';
#line 4928
        tmp___39 = __errno_location();
#line 4928
        orig_errno = *tmp___39;
        }
        {
#line 4930
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 4932
          count = -1;
#line 4935
          retcount = 0;
#line 4936
          maxlen = allocated - length;
#line 4939
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4940
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
          {
#line 4941
          maxlen *= sizeof(char ) / sizeof(char );
#line 4983
          tmp___40 = __errno_location();
#line 4983
          *tmp___40 = 0;
          }
          {
#line 4986
          if ((unsigned int )type == 1U) {
#line 4986
            goto case_1;
          }
#line 4992
          if ((unsigned int )type == 2U) {
#line 4992
            goto case_2___0;
          }
#line 4998
          if ((unsigned int )type == 3U) {
#line 4998
            goto case_3;
          }
#line 5004
          if ((unsigned int )type == 4U) {
#line 5004
            goto case_4;
          }
#line 5010
          if ((unsigned int )type == 5U) {
#line 5010
            goto case_5;
          }
#line 5016
          if ((unsigned int )type == 6U) {
#line 5016
            goto case_6;
          }
#line 5022
          if ((unsigned int )type == 7U) {
#line 5022
            goto case_7___0;
          }
#line 5028
          if ((unsigned int )type == 8U) {
#line 5028
            goto case_8___0;
          }
#line 5035
          if ((unsigned int )type == 9U) {
#line 5035
            goto case_9___0;
          }
#line 5041
          if ((unsigned int )type == 10U) {
#line 5041
            goto case_10___0;
          }
#line 5048
          if ((unsigned int )type == 11U) {
#line 5048
            goto case_11;
          }
#line 5054
          if ((unsigned int )type == 12U) {
#line 5054
            goto case_12___0;
          }
#line 5060
          if ((unsigned int )type == 13U) {
#line 5060
            goto case_13;
          }
#line 5067
          if ((unsigned int )type == 14U) {
#line 5067
            goto case_14___0;
          }
#line 5074
          if ((unsigned int )type == 15U) {
#line 5074
            goto case_15;
          }
#line 5081
          if ((unsigned int )type == 16U) {
#line 5081
            goto case_16___0;
          }
#line 5088
          if ((unsigned int )type == 17U) {
#line 5088
            goto case_17;
          }
#line 5094
          goto switch_default___18;
          case_1: /* CIL Label */ 
#line 4988
          arg___0 = (int )(a.arg + dp->arg_index)->a.a_schar;
          {
#line 4989
          if (prefix_count == 0U) {
#line 4989
            goto case_0;
          }
#line 4989
          if (prefix_count == 1U) {
#line 4989
            goto case_1___0;
          }
#line 4989
          if (prefix_count == 2U) {
#line 4989
            goto case_2;
          }
#line 4989
          goto switch_default___1;
          case_0: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___0, & count);
          }
#line 4989
          goto switch_break___2;
          case_1___0: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___0,
                              & count);
          }
#line 4989
          goto switch_break___2;
          case_2: /* CIL Label */ 
          {
#line 4989
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___0, & count);
          }
#line 4989
          goto switch_break___2;
          switch_default___1: /* CIL Label */ 
          {
#line 4989
          abort();
          }
          switch_break___2: /* CIL Label */ ;
          }
#line 4991
          goto switch_break___1;
          case_2___0: /* CIL Label */ 
#line 4994
          arg___1 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
          {
#line 4995
          if (prefix_count == 0U) {
#line 4995
            goto case_0___0;
          }
#line 4995
          if (prefix_count == 1U) {
#line 4995
            goto case_1___1;
          }
#line 4995
          if (prefix_count == 2U) {
#line 4995
            goto case_2___1;
          }
#line 4995
          goto switch_default___2;
          case_0___0: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___1, & count);
          }
#line 4995
          goto switch_break___3;
          case_1___1: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___1,
                              & count);
          }
#line 4995
          goto switch_break___3;
          case_2___1: /* CIL Label */ 
          {
#line 4995
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___1, & count);
          }
#line 4995
          goto switch_break___3;
          switch_default___2: /* CIL Label */ 
          {
#line 4995
          abort();
          }
          switch_break___3: /* CIL Label */ ;
          }
#line 4997
          goto switch_break___1;
          case_3: /* CIL Label */ 
#line 5000
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_short;
          {
#line 5001
          if (prefix_count == 0U) {
#line 5001
            goto case_0___1;
          }
#line 5001
          if (prefix_count == 1U) {
#line 5001
            goto case_1___2;
          }
#line 5001
          if (prefix_count == 2U) {
#line 5001
            goto case_2___2;
          }
#line 5001
          goto switch_default___3;
          case_0___1: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___2, & count);
          }
#line 5001
          goto switch_break___4;
          case_1___2: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___2,
                              & count);
          }
#line 5001
          goto switch_break___4;
          case_2___2: /* CIL Label */ 
          {
#line 5001
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___2, & count);
          }
#line 5001
          goto switch_break___4;
          switch_default___3: /* CIL Label */ 
          {
#line 5001
          abort();
          }
          switch_break___4: /* CIL Label */ ;
          }
#line 5003
          goto switch_break___1;
          case_4: /* CIL Label */ 
#line 5006
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
          {
#line 5007
          if (prefix_count == 0U) {
#line 5007
            goto case_0___2;
          }
#line 5007
          if (prefix_count == 1U) {
#line 5007
            goto case_1___3;
          }
#line 5007
          if (prefix_count == 2U) {
#line 5007
            goto case_2___3;
          }
#line 5007
          goto switch_default___4;
          case_0___2: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___3, & count);
          }
#line 5007
          goto switch_break___5;
          case_1___3: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___3,
                              & count);
          }
#line 5007
          goto switch_break___5;
          case_2___3: /* CIL Label */ 
          {
#line 5007
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___3, & count);
          }
#line 5007
          goto switch_break___5;
          switch_default___4: /* CIL Label */ 
          {
#line 5007
          abort();
          }
          switch_break___5: /* CIL Label */ ;
          }
#line 5009
          goto switch_break___1;
          case_5: /* CIL Label */ 
#line 5012
          arg___4 = (a.arg + dp->arg_index)->a.a_int;
          {
#line 5013
          if (prefix_count == 0U) {
#line 5013
            goto case_0___3;
          }
#line 5013
          if (prefix_count == 1U) {
#line 5013
            goto case_1___4;
          }
#line 5013
          if (prefix_count == 2U) {
#line 5013
            goto case_2___4;
          }
#line 5013
          goto switch_default___5;
          case_0___3: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___4, & count);
          }
#line 5013
          goto switch_break___6;
          case_1___4: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___4,
                              & count);
          }
#line 5013
          goto switch_break___6;
          case_2___4: /* CIL Label */ 
          {
#line 5013
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___4, & count);
          }
#line 5013
          goto switch_break___6;
          switch_default___5: /* CIL Label */ 
          {
#line 5013
          abort();
          }
          switch_break___6: /* CIL Label */ ;
          }
#line 5015
          goto switch_break___1;
          case_6: /* CIL Label */ 
#line 5018
          arg___5 = (a.arg + dp->arg_index)->a.a_uint;
          {
#line 5019
          if (prefix_count == 0U) {
#line 5019
            goto case_0___4;
          }
#line 5019
          if (prefix_count == 1U) {
#line 5019
            goto case_1___5;
          }
#line 5019
          if (prefix_count == 2U) {
#line 5019
            goto case_2___5;
          }
#line 5019
          goto switch_default___6;
          case_0___4: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___5, & count);
          }
#line 5019
          goto switch_break___7;
          case_1___5: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___5,
                              & count);
          }
#line 5019
          goto switch_break___7;
          case_2___5: /* CIL Label */ 
          {
#line 5019
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___5, & count);
          }
#line 5019
          goto switch_break___7;
          switch_default___6: /* CIL Label */ 
          {
#line 5019
          abort();
          }
          switch_break___7: /* CIL Label */ ;
          }
#line 5021
          goto switch_break___1;
          case_7___0: /* CIL Label */ 
#line 5024
          arg___6 = (a.arg + dp->arg_index)->a.a_longint;
          {
#line 5025
          if (prefix_count == 0U) {
#line 5025
            goto case_0___5;
          }
#line 5025
          if (prefix_count == 1U) {
#line 5025
            goto case_1___6;
          }
#line 5025
          if (prefix_count == 2U) {
#line 5025
            goto case_2___6;
          }
#line 5025
          goto switch_default___7;
          case_0___5: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___6, & count);
          }
#line 5025
          goto switch_break___8;
          case_1___6: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___6,
                              & count);
          }
#line 5025
          goto switch_break___8;
          case_2___6: /* CIL Label */ 
          {
#line 5025
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___6, & count);
          }
#line 5025
          goto switch_break___8;
          switch_default___7: /* CIL Label */ 
          {
#line 5025
          abort();
          }
          switch_break___8: /* CIL Label */ ;
          }
#line 5027
          goto switch_break___1;
          case_8___0: /* CIL Label */ 
#line 5030
          arg___7 = (a.arg + dp->arg_index)->a.a_ulongint;
          {
#line 5031
          if (prefix_count == 0U) {
#line 5031
            goto case_0___6;
          }
#line 5031
          if (prefix_count == 1U) {
#line 5031
            goto case_1___7;
          }
#line 5031
          if (prefix_count == 2U) {
#line 5031
            goto case_2___7;
          }
#line 5031
          goto switch_default___8;
          case_0___6: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___7, & count);
          }
#line 5031
          goto switch_break___9;
          case_1___7: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___7,
                              & count);
          }
#line 5031
          goto switch_break___9;
          case_2___7: /* CIL Label */ 
          {
#line 5031
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___7, & count);
          }
#line 5031
          goto switch_break___9;
          switch_default___8: /* CIL Label */ 
          {
#line 5031
          abort();
          }
          switch_break___9: /* CIL Label */ ;
          }
#line 5033
          goto switch_break___1;
          case_9___0: /* CIL Label */ 
#line 5037
          arg___8 = (a.arg + dp->arg_index)->a.a_longlongint;
          {
#line 5038
          if (prefix_count == 0U) {
#line 5038
            goto case_0___7;
          }
#line 5038
          if (prefix_count == 1U) {
#line 5038
            goto case_1___8;
          }
#line 5038
          if (prefix_count == 2U) {
#line 5038
            goto case_2___8;
          }
#line 5038
          goto switch_default___9;
          case_0___7: /* CIL Label */ 
          {
#line 5038
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___8, & count);
          }
#line 5038
          goto switch_break___10;
          case_1___8: /* CIL Label */ 
          {
#line 5038
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___8,
                              & count);
          }
#line 5038
          goto switch_break___10;
          case_2___8: /* CIL Label */ 
          {
#line 5038
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___8, & count);
          }
#line 5038
          goto switch_break___10;
          switch_default___9: /* CIL Label */ 
          {
#line 5038
          abort();
          }
          switch_break___10: /* CIL Label */ ;
          }
#line 5040
          goto switch_break___1;
          case_10___0: /* CIL Label */ 
#line 5043
          arg___9 = (a.arg + dp->arg_index)->a.a_ulonglongint;
          {
#line 5044
          if (prefix_count == 0U) {
#line 5044
            goto case_0___8;
          }
#line 5044
          if (prefix_count == 1U) {
#line 5044
            goto case_1___9;
          }
#line 5044
          if (prefix_count == 2U) {
#line 5044
            goto case_2___9;
          }
#line 5044
          goto switch_default___10;
          case_0___8: /* CIL Label */ 
          {
#line 5044
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___9, & count);
          }
#line 5044
          goto switch_break___11;
          case_1___9: /* CIL Label */ 
          {
#line 5044
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___9,
                              & count);
          }
#line 5044
          goto switch_break___11;
          case_2___9: /* CIL Label */ 
          {
#line 5044
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___9, & count);
          }
#line 5044
          goto switch_break___11;
          switch_default___10: /* CIL Label */ 
          {
#line 5044
          abort();
          }
          switch_break___11: /* CIL Label */ ;
          }
#line 5046
          goto switch_break___1;
          case_11: /* CIL Label */ 
#line 5050
          arg___10 = (a.arg + dp->arg_index)->a.a_double;
          {
#line 5051
          if (prefix_count == 0U) {
#line 5051
            goto case_0___9;
          }
#line 5051
          if (prefix_count == 1U) {
#line 5051
            goto case_1___10;
          }
#line 5051
          if (prefix_count == 2U) {
#line 5051
            goto case_2___10;
          }
#line 5051
          goto switch_default___11;
          case_0___9: /* CIL Label */ 
          {
#line 5051
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___10, & count);
          }
#line 5051
          goto switch_break___12;
          case_1___10: /* CIL Label */ 
          {
#line 5051
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___10,
                              & count);
          }
#line 5051
          goto switch_break___12;
          case_2___10: /* CIL Label */ 
          {
#line 5051
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___10, & count);
          }
#line 5051
          goto switch_break___12;
          switch_default___11: /* CIL Label */ 
          {
#line 5051
          abort();
          }
          switch_break___12: /* CIL Label */ ;
          }
#line 5053
          goto switch_break___1;
          case_12___0: /* CIL Label */ 
#line 5056
          arg___11 = (a.arg + dp->arg_index)->a.a_longdouble;
          {
#line 5057
          if (prefix_count == 0U) {
#line 5057
            goto case_0___10;
          }
#line 5057
          if (prefix_count == 1U) {
#line 5057
            goto case_1___11;
          }
#line 5057
          if (prefix_count == 2U) {
#line 5057
            goto case_2___11;
          }
#line 5057
          goto switch_default___12;
          case_0___10: /* CIL Label */ 
          {
#line 5057
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___11, & count);
          }
#line 5057
          goto switch_break___13;
          case_1___11: /* CIL Label */ 
          {
#line 5057
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___11,
                              & count);
          }
#line 5057
          goto switch_break___13;
          case_2___11: /* CIL Label */ 
          {
#line 5057
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___11, & count);
          }
#line 5057
          goto switch_break___13;
          switch_default___12: /* CIL Label */ 
          {
#line 5057
          abort();
          }
          switch_break___13: /* CIL Label */ ;
          }
#line 5059
          goto switch_break___1;
          case_13: /* CIL Label */ 
#line 5062
          arg___12 = (a.arg + dp->arg_index)->a.a_char;
          {
#line 5063
          if (prefix_count == 0U) {
#line 5063
            goto case_0___11;
          }
#line 5063
          if (prefix_count == 1U) {
#line 5063
            goto case_1___12;
          }
#line 5063
          if (prefix_count == 2U) {
#line 5063
            goto case_2___12;
          }
#line 5063
          goto switch_default___13;
          case_0___11: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___12, & count);
          }
#line 5063
          goto switch_break___14;
          case_1___12: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___12,
                              & count);
          }
#line 5063
          goto switch_break___14;
          case_2___12: /* CIL Label */ 
          {
#line 5063
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___12, & count);
          }
#line 5063
          goto switch_break___14;
          switch_default___13: /* CIL Label */ 
          {
#line 5063
          abort();
          }
          switch_break___14: /* CIL Label */ ;
          }
#line 5065
          goto switch_break___1;
          case_14___0: /* CIL Label */ 
#line 5069
          arg___13 = (a.arg + dp->arg_index)->a.a_wide_char;
          {
#line 5070
          if (prefix_count == 0U) {
#line 5070
            goto case_0___12;
          }
#line 5070
          if (prefix_count == 1U) {
#line 5070
            goto case_1___13;
          }
#line 5070
          if (prefix_count == 2U) {
#line 5070
            goto case_2___13;
          }
#line 5070
          goto switch_default___14;
          case_0___12: /* CIL Label */ 
          {
#line 5070
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___13, & count);
          }
#line 5070
          goto switch_break___15;
          case_1___13: /* CIL Label */ 
          {
#line 5070
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___13,
                              & count);
          }
#line 5070
          goto switch_break___15;
          case_2___13: /* CIL Label */ 
          {
#line 5070
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___13, & count);
          }
#line 5070
          goto switch_break___15;
          switch_default___14: /* CIL Label */ 
          {
#line 5070
          abort();
          }
          switch_break___15: /* CIL Label */ ;
          }
#line 5072
          goto switch_break___1;
          case_15: /* CIL Label */ 
#line 5076
          arg___14 = (a.arg + dp->arg_index)->a.a_string;
          {
#line 5077
          if (prefix_count == 0U) {
#line 5077
            goto case_0___13;
          }
#line 5077
          if (prefix_count == 1U) {
#line 5077
            goto case_1___14;
          }
#line 5077
          if (prefix_count == 2U) {
#line 5077
            goto case_2___14;
          }
#line 5077
          goto switch_default___15;
          case_0___13: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___14, & count);
          }
#line 5077
          goto switch_break___16;
          case_1___14: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___14,
                              & count);
          }
#line 5077
          goto switch_break___16;
          case_2___14: /* CIL Label */ 
          {
#line 5077
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___14, & count);
          }
#line 5077
          goto switch_break___16;
          switch_default___15: /* CIL Label */ 
          {
#line 5077
          abort();
          }
          switch_break___16: /* CIL Label */ ;
          }
#line 5079
          goto switch_break___1;
          case_16___0: /* CIL Label */ 
#line 5083
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_string;
          {
#line 5084
          if (prefix_count == 0U) {
#line 5084
            goto case_0___14;
          }
#line 5084
          if (prefix_count == 1U) {
#line 5084
            goto case_1___15;
          }
#line 5084
          if (prefix_count == 2U) {
#line 5084
            goto case_2___15;
          }
#line 5084
          goto switch_default___16;
          case_0___14: /* CIL Label */ 
          {
#line 5084
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___15, & count);
          }
#line 5084
          goto switch_break___17;
          case_1___15: /* CIL Label */ 
          {
#line 5084
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___15,
                              & count);
          }
#line 5084
          goto switch_break___17;
          case_2___15: /* CIL Label */ 
          {
#line 5084
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___15, & count);
          }
#line 5084
          goto switch_break___17;
          switch_default___16: /* CIL Label */ 
          {
#line 5084
          abort();
          }
          switch_break___17: /* CIL Label */ ;
          }
#line 5086
          goto switch_break___1;
          case_17: /* CIL Label */ 
#line 5090
          arg___16 = (a.arg + dp->arg_index)->a.a_pointer;
          {
#line 5091
          if (prefix_count == 0U) {
#line 5091
            goto case_0___15;
          }
#line 5091
          if (prefix_count == 1U) {
#line 5091
            goto case_1___16;
          }
#line 5091
          if (prefix_count == 2U) {
#line 5091
            goto case_2___16;
          }
#line 5091
          goto switch_default___17;
          case_0___15: /* CIL Label */ 
          {
#line 5091
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, arg___16, & count);
          }
#line 5091
          goto switch_break___18;
          case_1___16: /* CIL Label */ 
          {
#line 5091
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], arg___16,
                              & count);
          }
#line 5091
          goto switch_break___18;
          case_2___16: /* CIL Label */ 
          {
#line 5091
          retcount = snprintf((char */* __restrict  */)(result + length), maxlen,
                              (char const   */* __restrict  */)buf, prefixes[0], prefixes[1],
                              arg___16, & count);
          }
#line 5091
          goto switch_break___18;
          switch_default___17: /* CIL Label */ 
          {
#line 5091
          abort();
          }
          switch_break___18: /* CIL Label */ ;
          }
#line 5093
          goto switch_break___1;
          switch_default___18: /* CIL Label */ 
          {
#line 5095
          abort();
          }
          switch_break___1: /* CIL Label */ ;
          }
#line 5103
          if (count >= 0) {
#line 5107
            if ((size_t )count < maxlen) {
#line 5107
              if ((int )*((result + length) + count) != 0) {
                {
#line 5109
                abort();
                }
              }
            }
#line 5111
            if (retcount > count) {
#line 5112
              count = retcount;
            }
          } else
#line 5118
          if ((int )*(fbp + 1) != 0) {
#line 5122
            *(fbp + 1) = (char )'\000';
#line 5123
            goto __Cont;
          } else
#line 5128
          if (! (retcount < 0)) {
#line 5171
            count = retcount;
          }
#line 5177
          if (count < 0) {
            {
#line 5181
            tmp___41 = __errno_location();
#line 5181
            saved_errno = *tmp___41;
            }
#line 5182
            if (saved_errno == 0) {
#line 5184
              if ((int )dp->conversion == 99) {
#line 5185
                saved_errno = 84;
              } else
#line 5184
              if ((int )dp->conversion == 115) {
#line 5185
                saved_errno = 84;
              } else {
#line 5187
                saved_errno = 22;
              }
            }
#line 5190
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5190
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
                {
#line 5191
                free((void *)result);
                }
              }
            }
#line 5192
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
              {
#line 5193
              free((void *)buf_malloced);
              }
            }
#line 5194
            if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
              {
#line 5194
              free((void *)d.dir);
              }
            }
#line 5194
            if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
              {
#line 5194
              free((void *)a.arg);
              }
            }
            {
#line 5196
            tmp___42 = __errno_location();
#line 5196
            *tmp___42 = saved_errno;
            }
#line 5197
            return ((char *)((void *)0));
          }
#line 5206
          if ((size_t )((unsigned int )count + 1U) >= maxlen) {
#line 5211
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5212
              goto overflow;
            } else {
#line 5224
              if (allocated <= 9223372036854775807UL) {
#line 5224
                tmp___43 = allocated * 2UL;
              } else {
#line 5224
                tmp___43 = 0xffffffffffffffffUL;
              }
              {
#line 5224
              tmp___44 = xsum(length, (((unsigned long )((unsigned int )count + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 5224
              tmp___45 = xmax((size_t )tmp___44, tmp___43);
#line 5224
              n___2 = (size_t )tmp___45;
              }
#line 5231
              if (n___2 > allocated) {
#line 5231
                if (allocated > 0UL) {
#line 5231
                  if (allocated <= 9223372036854775807UL) {
#line 5231
                    tmp___46 = allocated * 2UL;
                  } else {
#line 5231
                    tmp___46 = 0xffffffffffffffffUL;
                  }
#line 5231
                  allocated = tmp___46;
                } else {
#line 5231
                  allocated = (size_t )12;
                }
#line 5231
                if (n___2 > allocated) {
#line 5231
                  allocated = n___2;
                }
#line 5231
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5231
                  memory_size___2 = allocated * sizeof(char );
                } else {
#line 5231
                  memory_size___2 = 0xffffffffffffffffUL;
                }
#line 5231
                if (memory_size___2 == 0xffffffffffffffffUL) {
#line 5231
                  goto out_of_memory;
                }
#line 5231
                if ((unsigned long )result == (unsigned long )resultbuf) {
                  {
#line 5231
                  tmp___47 = malloc(memory_size___2);
#line 5231
                  memory___2 = (char *)tmp___47;
                  }
                } else
#line 5231
                if ((unsigned long )result == (unsigned long )((void *)0)) {
                  {
#line 5231
                  tmp___47 = malloc(memory_size___2);
#line 5231
                  memory___2 = (char *)tmp___47;
                  }
                } else {
                  {
#line 5231
                  tmp___48 = realloc((void *)result, memory_size___2);
#line 5231
                  memory___2 = (char *)tmp___48;
                  }
                }
#line 5231
                if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 5231
                  goto out_of_memory;
                }
#line 5231
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5231
                  if (length > 0UL) {
                    {
#line 5231
                    memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)result,
                           length);
                    }
                  }
                }
#line 5231
                result = memory___2;
              }
#line 5232
              goto __Cont;
            }
          }
#line 5528
          length += (size_t )count;
#line 5529
          goto while_break___3;
          __Cont: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 5531
        tmp___49 = __errno_location();
#line 5531
        *tmp___49 = orig_errno;
        }
      }
    }
#line 1870
    cp = dp->dir_end;
#line 1870
    i ++;
#line 1870
    dp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5539
  tmp___55 = xsum(length, (size_t )1);
  }
#line 5539
  if (tmp___55 > (size_t __attribute__((__pure__))  )allocated) {
#line 5539
    if (allocated > 0UL) {
#line 5539
      if (allocated <= 9223372036854775807UL) {
#line 5539
        tmp___50 = allocated * 2UL;
      } else {
#line 5539
        tmp___50 = 0xffffffffffffffffUL;
      }
#line 5539
      allocated = tmp___50;
    } else {
#line 5539
      allocated = (size_t )12;
    }
    {
#line 5539
    tmp___52 = xsum(length, (size_t )1);
    }
#line 5539
    if (tmp___52 > (size_t __attribute__((__pure__))  )allocated) {
      {
#line 5539
      tmp___51 = xsum(length, (size_t )1);
#line 5539
      allocated = (size_t )tmp___51;
      }
    }
#line 5539
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5539
      memory_size___3 = allocated * sizeof(char );
    } else {
#line 5539
      memory_size___3 = 0xffffffffffffffffUL;
    }
#line 5539
    if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5539
      goto out_of_memory;
    }
#line 5539
    if ((unsigned long )result == (unsigned long )resultbuf) {
      {
#line 5539
      tmp___53 = malloc(memory_size___3);
#line 5539
      memory___3 = (char *)tmp___53;
      }
    } else
#line 5539
    if ((unsigned long )result == (unsigned long )((void *)0)) {
      {
#line 5539
      tmp___53 = malloc(memory_size___3);
#line 5539
      memory___3 = (char *)tmp___53;
      }
    } else {
      {
#line 5539
      tmp___54 = realloc((void *)result, memory_size___3);
#line 5539
      memory___3 = (char *)tmp___54;
      }
    }
#line 5539
    if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5539
      goto out_of_memory;
    }
#line 5539
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5539
      if (length > 0UL) {
        {
#line 5539
        memcpy((void */* __restrict  */)memory___3, (void const   */* __restrict  */)result,
               length);
        }
      }
    }
#line 5539
    result = memory___3;
  }
#line 5540
  *(result + length) = (char )'\000';
#line 5542
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5542
    if (length + 1UL < allocated) {
      {
#line 5547
      tmp___56 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5547
      memory___4 = (char *)tmp___56;
      }
#line 5548
      if ((unsigned long )memory___4 != (unsigned long )((void *)0)) {
#line 5549
        result = memory___4;
      }
    }
  }
#line 5552
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5553
    free((void *)buf_malloced);
    }
  }
#line 5554
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5554
    free((void *)d.dir);
    }
  }
#line 5554
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5554
    free((void *)a.arg);
    }
  }
#line 5555
  *lengthp = length;
#line 5560
  return (result);
  overflow: 
#line 5564
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5564
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5565
      free((void *)result);
      }
    }
  }
#line 5566
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5567
    free((void *)buf_malloced);
    }
  }
#line 5568
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5568
    free((void *)d.dir);
    }
  }
#line 5568
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5568
    free((void *)a.arg);
    }
  }
  {
#line 5569
  tmp___57 = __errno_location();
#line 5569
  *tmp___57 = 75;
  }
#line 5570
  return ((char *)((void *)0));
  out_of_memory: 
#line 5574
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5574
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
      {
#line 5575
      free((void *)result);
      }
    }
  }
#line 5576
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
    {
#line 5577
    free((void *)buf_malloced);
    }
  }
  out_of_memory_1: 
#line 5579
  if ((unsigned long )d.dir != (unsigned long )(d.direct_alloc_dir)) {
    {
#line 5579
    free((void *)d.dir);
    }
  }
#line 5579
  if ((unsigned long )a.arg != (unsigned long )(a.direct_alloc_arg)) {
    {
#line 5579
    free((void *)a.arg);
    }
  }
  {
#line 5580
  tmp___58 = __errno_location();
#line 5580
  *tmp___58 = 12;
  }
#line 5581
  return ((char *)((void *)0));
}
}
#line 21 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.h"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 22
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 23
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
#line 205 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 210
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd ,
                                                                                                char const   *__path ,
                                                                                                struct timespec  const  *__times ,
                                                                                                int __flags ) ;
#line 368
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimens)(int __fd ,
                                                                               struct timespec  const  *__times ) ;
#line 1016 "./sys/stat.h"
int ( __attribute__((__nonnull__(2))) rpl_utimensat)(int fd , char const   *file ,
                                                     struct timespec  const  *times ,
                                                     int flag ) ;
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 41 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.h"
__inline int lutimensat(int dir , char const   *file , struct timespec  const  *times ) 
{ 
  int tmp ;

  {
  {
#line 44
  tmp = rpl_utimensat(dir, file, times, 256);
  }
#line 44
  return (tmp);
}
}
#line 47
#pragma GCC diagnostic pop
#line 135 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 151
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimesat)(int __fd ,
                                                                                char const   *__file ,
                                                                                struct timeval  const  *__tvp ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 57 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline long __attribute__((__pure__))  get_stat_atime_ns(struct stat  const  *st ) 
{ 


  {
#line 61
  return ((long __attribute__((__pure__))  )st->st_atim.tv_nsec);
}
}
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline long __attribute__((__pure__))  get_stat_ctime_ns(struct stat  const  *st ) 
{ 


  {
#line 74
  return ((long __attribute__((__pure__))  )st->st_ctim.tv_nsec);
}
}
#line 83 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline long __attribute__((__pure__))  get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 87
  return ((long __attribute__((__pure__))  )st->st_mtim.tv_nsec);
}
}
#line 96 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline long __attribute__((__pure__))  get_stat_birthtime_ns(struct stat  const  *st ) 
{ 


  {
#line 106
  return ((long __attribute__((__pure__))  )0);
}
}
#line 111 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_atime(struct stat  const  *st ) 
{ 


  {
#line 115
  return ((struct timespec  __attribute__((__pure__)) )st->st_atim);
}
}
#line 125 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_ctime(struct stat  const  *st ) 
{ 


  {
#line 129
  return ((struct timespec  __attribute__((__pure__)) )st->st_ctim);
}
}
#line 139 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_mtime(struct stat  const  *st ) 
{ 


  {
#line 143
  return ((struct timespec  __attribute__((__pure__)) )st->st_mtim);
}
}
#line 154 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
__inline struct timespec  __attribute__((__pure__)) get_stat_birthtime(struct stat  const  *st ) 
{ 
  struct timespec t ;

  {
#line 173
  t.tv_sec = (__time_t )-1;
#line 174
  t.tv_nsec = (__syscall_slong_t )-1;
#line 194
  return ((struct timespec  __attribute__((__pure__)) )t);
}
}
#line 197
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 40 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
__inline struct timespec make_timespec(time_t s , long ns ) 
{ 
  struct timespec r ;

  {
#line 44
  r.tv_sec = s;
#line 45
  r.tv_nsec = ns;
#line 46
  return (r);
}
}
#line 77 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
__inline int __attribute__((__pure__))  timespec_cmp(struct timespec a , struct timespec b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 80
  if (a.tv_sec < b.tv_sec) {
#line 80
    tmp___0 = -1;
  } else {
#line 80
    if (a.tv_sec > b.tv_sec) {
#line 80
      tmp = 1;
    } else {
#line 80
      tmp = (int )(a.tv_nsec - b.tv_nsec);
    }
#line 80
    tmp___0 = tmp;
  }
#line 80
  return ((int __attribute__((__pure__))  )tmp___0);
}
}
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
__inline int __attribute__((__pure__))  timespec_sign(struct timespec a ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 90
  if (a.tv_sec < 0L) {
#line 90
    tmp___0 = -1;
  } else {
#line 90
    if (a.tv_sec) {
#line 90
      tmp = 1;
    } else
#line 90
    if (a.tv_nsec) {
#line 90
      tmp = 1;
    } else {
#line 90
      tmp = 0;
    }
#line 90
    tmp___0 = tmp;
  }
#line 90
  return ((int __attribute__((__pure__))  )tmp___0);
}
}
#line 101 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
__inline double timespectod(struct timespec a ) 
{ 


  {
#line 104
  return ((double )a.tv_sec + (double )a.tv_nsec / 1e9);
}
}
#line 107
void gettime(struct timespec *ts ) ;
#line 110
#pragma GCC diagnostic pop
#line 73 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
static int utimensat_works_really  ;
#line 74 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
static int lutimensat_works_really  ;
#line 84 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
static int validate_timespec(struct timespec *timespec ) 
{ 
  int result ;
  int utime_omit_count ;
  int *tmp ;

  {
#line 87
  result = 0;
#line 88
  utime_omit_count = 0;
#line 89
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
#line 89
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
#line 89
      if (0L <= (timespec + 0)->tv_nsec) {
#line 89
        if ((timespec + 0)->tv_nsec < 1000000000L) {
#line 89
          goto _L___0;
        } else {
          {
#line 98
          tmp = __errno_location();
#line 98
          *tmp = 22;
          }
#line 99
          return (-1);
        }
      } else {
        {
#line 98
        tmp = __errno_location();
#line 98
        *tmp = 22;
        }
#line 99
        return (-1);
      }
    } else {
#line 89
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 89
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
#line 89
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
#line 89
      if (0L <= (timespec + 1)->tv_nsec) {
#line 89
        if (! ((timespec + 1)->tv_nsec < 1000000000L)) {
          {
#line 98
          tmp = __errno_location();
#line 98
          *tmp = 22;
          }
#line 99
          return (-1);
        }
      } else {
        {
#line 98
        tmp = __errno_location();
#line 98
        *tmp = 22;
        }
#line 99
        return (-1);
      }
    }
  }
#line 105
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 105
    goto _L___1;
  } else
#line 105
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    _L___1: /* CIL Label */ 
#line 108
    (timespec + 0)->tv_sec = (__time_t )0;
#line 109
    result = 1;
#line 110
    if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 111
      utime_omit_count ++;
    }
  }
#line 113
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 113
    goto _L___2;
  } else
#line 113
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    _L___2: /* CIL Label */ 
#line 116
    (timespec + 1)->tv_sec = (__time_t )0;
#line 117
    result = 1;
#line 118
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 119
      utime_omit_count ++;
    }
  }
#line 121
  return (result + (utime_omit_count == 1));
}
}
#line 130 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ 
  struct timespec *timespec ;
  struct timespec  __attribute__((__pure__)) tmp ;
  struct timespec  __attribute__((__pure__)) tmp___0 ;

  {
#line 133
  timespec = *ts;
#line 134
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 134
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 136
      return ((_Bool)1);
    }
  }
#line 137
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 137
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 140
      *ts = (struct timespec *)((void *)0);
#line 141
      return ((_Bool)0);
    }
  }
#line 144
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
    {
#line 145
    tmp = get_stat_atime(statbuf);
#line 145
    *(timespec + 0) = (struct timespec )tmp;
    }
  } else
#line 146
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
    {
#line 147
    gettime(timespec + 0);
    }
  }
#line 149
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
    {
#line 150
    tmp___0 = get_stat_mtime(statbuf);
#line 150
    *(timespec + 1) = (struct timespec )tmp___0;
    }
  } else
#line 151
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
    {
#line 152
    gettime(timespec + 1);
    }
  }
#line 154
  return ((_Bool)0);
}
}
#line 167 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
int fdutimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct timespec  __attribute__((__pure__)) tmp___4 ;
  struct timespec  __attribute__((__pure__)) tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  struct timeval timeval[2] ;
  struct timeval *t ;
  int tmp___14 ;
  _Bool abig ;
  _Bool mbig ;
  time_t adiff ;
  time_t mdiff ;
  struct timeval *tt ;
  struct timeval truncated_timeval[2] ;
  long __attribute__((__pure__))  tmp___15 ;
  long __attribute__((__pure__))  tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 171
  if (timespec) {
#line 171
    tmp = adjusted_timespec;
  } else {
#line 171
    tmp = (struct timespec *)((void *)0);
  }
#line 171
  ts = tmp;
#line 172
  adjustment_needed = 0;
#line 175
  if (ts) {
    {
#line 177
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 178
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 179
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 181
  if (adjustment_needed < 0) {
#line 182
    return (-1);
  }
#line 187
  if (fd < 0) {
#line 187
    if (! file) {
      {
#line 189
      tmp___0 = __errno_location();
#line 189
      *tmp___0 = 9;
      }
#line 190
      return (-1);
    }
  }
#line 216
  if (0 <= utimensat_works_really) {
#line 232
    if (adjustment_needed == 2) {
#line 234
      if (fd < 0) {
        {
#line 234
        tmp___1 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 234
        tmp___3 = tmp___1;
        }
      } else {
        {
#line 234
        tmp___2 = fstat(fd, & st);
#line 234
        tmp___3 = tmp___2;
        }
      }
#line 234
      if (tmp___3) {
#line 235
        return (-1);
      }
#line 236
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 237
        tmp___4 = get_stat_atime((struct stat  const  *)(& st));
#line 237
        *(ts + 0) = (struct timespec )tmp___4;
        }
      } else
#line 238
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 239
        tmp___5 = get_stat_mtime((struct stat  const  *)(& st));
#line 239
        *(ts + 1) = (struct timespec )tmp___5;
        }
      }
#line 241
      adjustment_needed ++;
    }
#line 245
    if (fd < 0) {
      {
#line 247
      result = utimensat(-100, file, (struct timespec  const  *)ts, 0);
      }
#line 256
      if (0 < result) {
        {
#line 257
        tmp___6 = __errno_location();
#line 257
        *tmp___6 = 38;
        }
      }
#line 259
      if (result == 0) {
#line 261
        utimensat_works_really = 1;
#line 262
        return (result);
      } else {
        {
#line 259
        tmp___7 = __errno_location();
        }
#line 259
        if (*tmp___7 != 38) {
#line 261
          utimensat_works_really = 1;
#line 262
          return (result);
        }
      }
    }
#line 267
    if (0 <= fd) {
      {
#line 269
      result = futimens(fd, (struct timespec  const  *)ts);
      }
#line 272
      if (0 < result) {
        {
#line 273
        tmp___8 = __errno_location();
#line 273
        *tmp___8 = 38;
        }
      }
#line 275
      if (result == 0) {
#line 277
        utimensat_works_really = 1;
#line 278
        return (result);
      } else {
        {
#line 275
        tmp___9 = __errno_location();
        }
#line 275
        if (*tmp___9 != 38) {
#line 277
          utimensat_works_really = 1;
#line 278
          return (result);
        }
      }
    }
  }
#line 283
  utimensat_works_really = -1;
#line 284
  lutimensat_works_really = -1;
#line 291
  if (adjustment_needed) {
#line 291
    goto _L;
  } else
#line 291
  if (0) {
    _L: /* CIL Label */ 
#line 293
    if (adjustment_needed != 3) {
#line 293
      if (fd < 0) {
        {
#line 293
        tmp___10 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
#line 293
        tmp___12 = tmp___10;
        }
      } else {
        {
#line 293
        tmp___11 = fstat(fd, & st);
#line 293
        tmp___12 = tmp___11;
        }
      }
#line 293
      if (tmp___12) {
#line 295
        return (-1);
      }
    }
#line 296
    if (ts) {
      {
#line 296
      tmp___13 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 296
      if (tmp___13) {
#line 297
        return (0);
      }
    }
  }
#line 304
  if (ts) {
#line 306
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 307
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 308
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 309
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 310
    t = timeval;
  } else {
#line 313
    t = (struct timeval *)((void *)0);
  }
#line 315
  if (fd < 0) {
    {
#line 318
    tmp___14 = futimesat(-100, file, (struct timeval  const  *)t);
    }
#line 318
    return (tmp___14);
  } else {
    {
#line 339
    tmp___18 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
    }
#line 339
    if (tmp___18 == 0) {
#line 347
      if (t) {
#line 349
        abig = (_Bool )(500000L <= (t + 0)->tv_usec);
#line 350
        mbig = (_Bool )(500000L <= (t + 1)->tv_usec);
#line 351
        if ((int )abig | (int )mbig) {
          {
#line 351
          tmp___17 = fstat(fd, & st);
          }
#line 351
          if (tmp___17 == 0) {
#line 355
            adiff = st.st_atim.tv_sec - (t + 0)->tv_sec;
#line 356
            mdiff = st.st_mtim.tv_sec - (t + 1)->tv_sec;
#line 358
            tt = (struct timeval *)((void *)0);
#line 360
            truncated_timeval[0] = *(t + 0);
#line 361
            truncated_timeval[1] = *(t + 1);
#line 362
            if (abig) {
#line 362
              if (adiff == 1L) {
                {
#line 362
                tmp___15 = get_stat_atime_ns((struct stat  const  *)(& st));
                }
#line 362
                if (tmp___15 == (long __attribute__((__pure__))  )0) {
#line 364
                  tt = truncated_timeval;
#line 365
                  (tt + 0)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 367
            if (mbig) {
#line 367
              if (mdiff == 1L) {
                {
#line 367
                tmp___16 = get_stat_mtime_ns((struct stat  const  *)(& st));
                }
#line 367
                if (tmp___16 == (long __attribute__((__pure__))  )0) {
#line 369
                  tt = truncated_timeval;
#line 370
                  (tt + 1)->tv_usec = (__suseconds_t )0;
                }
              }
            }
#line 372
            if (tt) {
              {
#line 373
              futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)tt);
              }
            }
          }
        }
      }
#line 378
      return (0);
    }
  }
#line 384
  if (! file) {
#line 390
    return (-1);
  }
  {
#line 394
  tmp___19 = utimes(file, (struct timeval  const  *)t);
  }
#line 394
  return (tmp___19);
}
}
#line 416 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
  {
#line 419
  tmp = fdutimens(-1, file, timespec);
  }
#line 419
  return (tmp);
}
}
#line 426 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.c"
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  struct timespec  __attribute__((__pure__)) tmp___1 ;
  struct timespec  __attribute__((__pure__)) tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 430
  if (timespec) {
#line 430
    tmp = adjusted_timespec;
  } else {
#line 430
    tmp = (struct timespec *)((void *)0);
  }
#line 430
  ts = tmp;
#line 431
  adjustment_needed = 0;
#line 434
  if (ts) {
    {
#line 436
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 437
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 438
    adjustment_needed = validate_timespec((struct timespec *)ts);
    }
  }
#line 440
  if (adjustment_needed < 0) {
#line 441
    return (-1);
  }
#line 449
  if (0 <= lutimensat_works_really) {
#line 465
    if (adjustment_needed == 2) {
      {
#line 467
      tmp___0 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 467
      if (tmp___0) {
#line 468
        return (-1);
      }
#line 469
      if ((ts + 0)->tv_nsec == (1L << 30) - 2L) {
        {
#line 470
        tmp___1 = get_stat_atime((struct stat  const  *)(& st));
#line 470
        *(ts + 0) = (struct timespec )tmp___1;
        }
      } else
#line 471
      if ((ts + 1)->tv_nsec == (1L << 30) - 2L) {
        {
#line 472
        tmp___2 = get_stat_mtime((struct stat  const  *)(& st));
#line 472
        *(ts + 1) = (struct timespec )tmp___2;
        }
      }
#line 474
      adjustment_needed ++;
    }
    {
#line 477
    result = utimensat(-100, file, (struct timespec  const  *)ts, 256);
    }
#line 486
    if (0 < result) {
      {
#line 487
      tmp___3 = __errno_location();
#line 487
      *tmp___3 = 38;
      }
    }
#line 489
    if (result == 0) {
#line 491
      utimensat_works_really = 1;
#line 492
      lutimensat_works_really = 1;
#line 493
      return (result);
    } else {
      {
#line 489
      tmp___4 = __errno_location();
      }
#line 489
      if (*tmp___4 != 38) {
#line 491
        utimensat_works_really = 1;
#line 492
        lutimensat_works_really = 1;
#line 493
        return (result);
      }
    }
  }
#line 496
  lutimensat_works_really = -1;
#line 503
  if (adjustment_needed) {
#line 503
    goto _L;
  } else
#line 503
  if (0) {
    _L: /* CIL Label */ 
#line 505
    if (adjustment_needed != 3) {
      {
#line 505
      tmp___5 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
      }
#line 505
      if (tmp___5) {
#line 506
        return (-1);
      }
    }
#line 507
    if (ts) {
      {
#line 507
      tmp___6 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
      }
#line 507
      if (tmp___6) {
#line 508
        return (0);
      }
    }
  }
#line 536
  if (! adjustment_needed) {
    {
#line 536
    tmp___7 = lstat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
    }
#line 536
    if (tmp___7) {
#line 537
      return (-1);
    }
  }
#line 538
  if (! ((st.st_mode & 61440U) == 40960U)) {
    {
#line 539
    tmp___8 = fdutimens(-1, file, (struct timespec  const  *)ts);
    }
#line 539
    return (tmp___8);
  }
  {
#line 540
  tmp___9 = __errno_location();
#line 540
  *tmp___9 = 38;
  }
#line 541
  return (-1);
}
}
#line 234 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 299
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fchmodat)(int __fd ,
                                                                                               char const   *__file ,
                                                                                               __mode_t __mode ,
                                                                                               int __flag ) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 47
#pragma GCC diagnostic pop
#line 42 "/home/khheo/project/benchmark/tar-1.29/gnu/utimensat.c"
static int local_utimensat(int fd , char const   *file , struct timespec  const  *ts ,
                           int flag ) ;
#line 56 "/home/khheo/project/benchmark/tar-1.29/gnu/utimensat.c"
static int utimensat_works_really___0  ;
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/utimensat.c"
int ( __attribute__((__nonnull__(2))) rpl_utimensat)(int fd , char const   *file ,
                                                     struct timespec  const  *times ,
                                                     int flag ) 
{ 
  struct timespec ts[2] ;
  int result ;
  struct stat st ;
  int tmp ;
  struct timespec  __attribute__((__pure__)) tmp___0 ;
  struct timespec  __attribute__((__pure__)) tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 57
  if (0 <= utimensat_works_really___0) {
#line 74
    if (times) {
#line 74
      if ((times + 0)->tv_nsec == (__syscall_slong_t const   )((1L << 30) - 2L)) {
#line 74
        goto _L;
      } else
#line 74
      if ((times + 1)->tv_nsec == (__syscall_slong_t const   )((1L << 30) - 2L)) {
        _L: /* CIL Label */ 
        {
#line 77
        tmp = fstatat(fd, (char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st),
                      flag);
        }
#line 77
        if (tmp) {
#line 78
          return (-1);
        }
#line 79
        if ((times + 0)->tv_nsec == (__syscall_slong_t const   )((1L << 30) - 2L)) {
#line 79
          if ((times + 1)->tv_nsec == (__syscall_slong_t const   )((1L << 30) - 2L)) {
#line 80
            return (0);
          }
        }
#line 81
        if ((times + 0)->tv_nsec == (__syscall_slong_t const   )((1L << 30) - 2L)) {
          {
#line 82
          tmp___0 = get_stat_atime((struct stat  const  *)(& st));
#line 82
          ts[0] = (struct timespec )tmp___0;
          }
        } else {
#line 84
          ts[0] = (struct timespec )*(times + 0);
        }
#line 85
        if ((times + 1)->tv_nsec == (__syscall_slong_t const   )((1L << 30) - 2L)) {
          {
#line 86
          tmp___1 = get_stat_mtime((struct stat  const  *)(& st));
#line 86
          ts[1] = (struct timespec )tmp___1;
          }
        } else {
#line 88
          ts[1] = (struct timespec )*(times + 1);
        }
#line 89
        times = (struct timespec  const  *)(ts);
      }
    }
    {
#line 107
    result = utimensat(fd, file, times, flag);
    }
#line 113
    if (result == -1) {
      {
#line 113
      tmp___2 = __errno_location();
      }
#line 113
      if (*tmp___2 == 22) {
#line 113
        if (flag & -257) {
#line 114
          return (result);
        }
      }
    }
#line 115
    if (result == 0) {
#line 117
      utimensat_works_really___0 = 1;
#line 118
      return (result);
    } else {
      {
#line 115
      tmp___3 = __errno_location();
      }
#line 115
      if (*tmp___3 != 38) {
        {
#line 115
        tmp___4 = __errno_location();
        }
#line 115
        if (*tmp___4 != 22) {
#line 117
          utimensat_works_really___0 = 1;
#line 118
          return (result);
        }
      }
    }
  }
#line 125
  if (0 <= utimensat_works_really___0) {
    {
#line 125
    tmp___5 = __errno_location();
    }
#line 125
    if (*tmp___5 == 38) {
#line 126
      utimensat_works_really___0 = -1;
    }
  }
  {
#line 127
  tmp___6 = local_utimensat(fd, file, times, flag);
  }
#line 127
  return (tmp___6);
}
}
#line 494 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fchownat)(int __fd ,
                                                                                               char const   *__file ,
                                                                                               __uid_t __owner ,
                                                                                               __gid_t __group ,
                                                                                               int __flag ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 48
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 49
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 61 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
__inline int chownat(int fd , char const   *file , uid_t owner , gid_t group ) 
{ 
  int tmp ;

  {
  {
#line 64
  tmp = fchownat(fd, file, owner, group, 0);
  }
#line 64
  return (tmp);
}
}
#line 67 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
__inline int lchownat(int fd , char const   *file , uid_t owner , gid_t group ) 
{ 
  int tmp ;

  {
  {
#line 70
  tmp = fchownat(fd, file, owner, group, 256);
  }
#line 70
  return (tmp);
}
}
#line 81 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
__inline int chmodat(int fd , char const   *file , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 84
  tmp = fchmodat(fd, file, mode, 0);
  }
#line 84
  return (tmp);
}
}
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
__inline int lchmodat(int fd , char const   *file , mode_t mode ) 
{ 
  int tmp ;

  {
  {
#line 90
  tmp = fchmodat(fd, file, mode, 256);
  }
#line 90
  return (tmp);
}
}
#line 101 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
__inline int statat(int fd , char const   *name , struct stat *st ) 
{ 
  int tmp ;

  {
  {
#line 104
  tmp = fstatat(fd, (char const   */* __restrict  */)name, (struct stat */* __restrict  */)st,
                0);
  }
#line 104
  return (tmp);
}
}
#line 107 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
__inline int lstatat(int fd , char const   *name , struct stat *st ) 
{ 
  int tmp ;

  {
  {
#line 110
  tmp = fstatat(fd, (char const   */* __restrict  */)name, (struct stat */* __restrict  */)st,
                256);
  }
#line 110
  return (tmp);
}
}
#line 121
#pragma GCC diagnostic pop
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/openat-priv.h"
char *openat_proc_name(char *buf , int fd , char const   *file ) ;
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/save-cwd.h"
int save_cwd(struct saved_cwd *cwd___0 ) ;
#line 31
int restore_cwd(struct saved_cwd  const  *cwd___0 ) ;
#line 32
void free_cwd(struct saved_cwd *cwd___0 ) ;
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/at-func.c"
static int local_utimensat(int fd , char const   *file , struct timespec  const  *ts ,
                           int flag ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___3 ;
  int proc_result ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int proc_errno ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  int *tmp___20 ;

  {
#line 72
  if (flag & -257) {
    {
#line 72
    tmp = __errno_location();
#line 72
    *tmp = 22;
    }
#line 72
    return (-1);
  }
#line 74
  if (fd == -100) {
#line 74
    goto _L___0;
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
#line 74
    goto _L___0;
  } else
#line 74
  if (0) {
    _L___0: /* CIL Label */ 
#line 75
    if (flag == 256) {
      {
#line 75
      tmp___0 = lutimens(file, ts);
#line 75
      tmp___2 = tmp___0;
      }
    } else {
      {
#line 75
      tmp___1 = utimens(file, ts);
#line 75
      tmp___2 = tmp___1;
      }
    }
#line 75
    return (tmp___2);
  }
  {
#line 90
  tmp___3 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___3;
  }
#line 91
  if (proc_file) {
#line 93
    if (flag == 256) {
      {
#line 93
      tmp___4 = lutimens((char const   *)proc_file, ts);
#line 93
      tmp___6 = tmp___4;
      }
    } else {
      {
#line 93
      tmp___5 = utimens((char const   *)proc_file, ts);
#line 93
      tmp___6 = tmp___5;
      }
    }
    {
#line 93
    proc_result = tmp___6;
#line 94
    tmp___7 = __errno_location();
#line 94
    proc_errno = *tmp___7;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___8 = __errno_location();
#line 104
                *tmp___8 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___10 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___10 != 0) {
    {
#line 111
    tmp___9 = __errno_location();
#line 111
    openat_save_fail(*tmp___9);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___11 = __errno_location();
#line 118
      *tmp___11 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___14 = fchdir(fd);
  }
#line 122
  if (tmp___14 != 0) {
    {
#line 124
    tmp___12 = __errno_location();
#line 124
    saved_errno = *tmp___12;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
    }
#line 127
    return (-1);
  }
#line 130
  if (flag == 256) {
    {
#line 130
    tmp___15 = lutimens(file, ts);
#line 130
    err = tmp___15;
    }
  } else {
    {
#line 130
    tmp___16 = utimens(file, ts);
#line 130
    err = tmp___16;
    }
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___17 = __errno_location();
#line 131
    saved_errno = *tmp___17;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___19 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___19 != 0) {
    {
#line 134
    tmp___18 = __errno_location();
#line 134
    openat_restore_fail(*tmp___18);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___20 = __errno_location();
#line 139
    *tmp___20 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/priv-set.h"
#pragma GCC diagnostic push
#line 23
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 23
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 50 "/home/khheo/project/benchmark/tar-1.29/gnu/priv-set.h"
__inline int priv_set_remove_linkdir(void) 
{ 


  {
#line 53
  return (-1);
}
}
#line 64
#pragma GCC diagnostic pop
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 137 "/home/khheo/project/benchmark/tar-1.29/gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 46 "/home/khheo/project/benchmark/tar-1.29/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf ) ;
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf ) 
{ 
  char *p ;

  {
#line 38
  p = buf + ((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL;
#line 39
  *p = (char)0;
#line 41
  if (i < 0UL) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48UL - i % 10UL);
#line 43
      i /= 10UL;
#line 43
      if (! (i != 0UL)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48UL + i % 10UL);
#line 51
      i /= 10UL;
#line 51
      if (! (i != 0UL)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 22
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 45 "/home/khheo/project/benchmark/tar-1.29/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf ) ;
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf ) 
{ 
  char *p ;

  {
#line 38
  p = buf + ((sizeof(unsigned int ) * 8UL) * 146UL + 484UL) / 485UL;
#line 39
  *p = (char)0;
#line 41
  if (i < 0U) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48U - i % 10U);
#line 43
      i /= 10U;
#line 43
      if (! (i != 0U)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48U + i % 10U);
#line 51
      i /= 10U;
#line 51
      if (! (i != 0U)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 95
struct timespec timespec_sub(struct timespec a , struct timespec b )  __attribute__((__const__)) ;
#line 110
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec-sub.c"
struct timespec timespec_sub(struct timespec a , struct timespec b )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec-sub.c"
struct timespec timespec_sub(struct timespec a , struct timespec b ) 
{ 
  time_t rs ;
  time_t bs ;
  int ns ;
  int rns ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct timespec tmp___3 ;

  {
#line 32
  rs = a.tv_sec;
#line 33
  bs = b.tv_sec;
#line 34
  ns = (int )(a.tv_nsec - b.tv_nsec);
#line 35
  rns = ns;
#line 37
  if (ns < 0) {
#line 39
    rns = ns + 1000000000;
#line 40
    if (rs == ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) {
#line 42
      if (bs <= 0L) {
#line 43
        goto low_overflow;
      }
#line 44
      bs --;
    } else {
#line 47
      rs --;
    }
  }
#line 50
  if (-1L - (((1L << (sizeof(rs) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 50
    if (bs < 0L) {
#line 50
      tmp = (((1L << (sizeof(rs) * 8UL - 2UL)) - 1L) * 2L + 1L) + bs < rs;
    } else {
#line 50
      tmp = rs < (-1L - (((1L << (sizeof(rs) * 8UL - 2UL)) - 1L) * 2L + 1L)) + bs;
    }
#line 50
    tmp___2 = tmp;
  } else {
#line 50
    if (rs < 0L) {
#line 50
      tmp___1 = 1;
    } else {
#line 50
      if (bs < 0L) {
#line 50
        tmp___0 = rs - bs <= rs;
      } else {
#line 50
        tmp___0 = rs < bs;
      }
#line 50
      tmp___1 = tmp___0;
    }
#line 50
    tmp___2 = tmp___1;
  }
#line 50
  if (tmp___2) {
#line 52
    if (rs < 0L) {
      low_overflow: 
#line 55
      rs = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 56
      rns = 0;
    } else {
#line 60
      rs = ((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 61
      rns = 999999999;
    }
  } else {
#line 65
    rs -= bs;
  }
  {
#line 67
  tmp___3 = make_timespec(rs, (long )rns);
  }
#line 67
  return (tmp___3);
}
}
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 128 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   * __restrict  __timer ,
                                                                                      struct tm * __restrict  __tp ) ;
#line 133
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 170
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) tzset)(void) ;
#line 196
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) timegm)(struct tm *__tp ) ;
#line 441 "./time.h"
time_t ( __attribute__((__nonnull__(1))) rpl_mktime)(struct tm *tp ) ;
#line 550
timezone_t tzalloc(char const   *name ) ;
#line 552
void tzfree(timezone_t tz ) ;
#line 554
struct tm *( __attribute__((__nonnull__(2,3))) localtime_rz)(timezone_t tz , time_t const   * __restrict  t ,
                                                             struct tm * __restrict  tm ) ;
#line 560
time_t ( __attribute__((__nonnull__(2))) mktime_z)(timezone_t tz , struct tm * __restrict  tm ) ;
#line 631 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 650
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 654
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 50 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static char const   TZ[3]  = {      (char const   )'T',      (char const   )'Z',      (char const   )'\000'};
#line 55 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static struct tm_zone * const  local_tz  =    (timezone_t const   )((timezone_t )1);
#line 61 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static _Bool isdst_differ(int a , int b ) 
{ 
  int tmp ;

  {
#line 64
  if (! a != ! b) {
#line 64
    if (0 <= a) {
#line 64
      if (0 <= b) {
#line 64
        tmp = 1;
      } else {
#line 64
        tmp = 0;
      }
    } else {
#line 64
      tmp = 0;
    }
  } else {
#line 64
    tmp = 0;
  }
#line 64
  return ((_Bool )tmp);
}
}
#line 68 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static int equal_tm(struct tm  const  *a , struct tm  const  *b ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
  {
#line 71
  tmp = isdst_differ((int )a->tm_isdst, (int )b->tm_isdst);
  }
#line 71
  if (((((((a->tm_sec ^ b->tm_sec) | (a->tm_min ^ b->tm_min)) | (a->tm_hour ^ b->tm_hour)) | (a->tm_mday ^ b->tm_mday)) | (a->tm_mon ^ b->tm_mon)) | (a->tm_year ^ b->tm_year)) | (int const   )tmp) {
#line 71
    tmp___0 = 0;
  } else {
#line 71
    tmp___0 = 1;
  }
#line 71
  return (tmp___0);
}
}
#line 85 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static void extend_abbrs(char *abbrs , char const   *abbr , size_t abbr_size ) 
{ 


  {
  {
#line 88
  memcpy((void */* __restrict  */)abbrs, (void const   */* __restrict  */)abbr, abbr_size);
#line 89
  *(abbrs + abbr_size) = (char )'\000';
  }
#line 90
  return;
}
}
#line 95 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
timezone_t tzalloc(char const   *name ) 
{ 
  size_t name_size ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t abbr_size ;
  size_t tmp___1 ;
  timezone_t tz ;
  void *tmp___2 ;

  {
#line 98
  if (name) {
    {
#line 98
    tmp = strlen(name);
#line 98
    tmp___0 = tmp + 1UL;
    }
  } else {
#line 98
    tmp___0 = (size_t )0;
  }
#line 98
  name_size = tmp___0;
#line 99
  if (name_size < 119UL) {
#line 99
    tmp___1 = (size_t )119;
  } else {
#line 99
    tmp___1 = name_size + 1UL;
  }
  {
#line 99
  abbr_size = tmp___1;
#line 100
  tmp___2 = malloc((unsigned long )(& ((struct tm_zone *)0)->abbrs) + abbr_size);
#line 100
  tz = (timezone_t )tmp___2;
  }
#line 101
  if (tz) {
#line 103
    tz->next = (struct tm_zone *)((void *)0);
#line 107
    tz->tz_is_set = (char )(! (! name));
#line 108
    tz->abbrs[0] = (char )'\000';
#line 109
    if (name) {
      {
#line 110
      extend_abbrs(tz->abbrs, name, name_size);
      }
    }
  }
#line 112
  return (tz);
}
}
#line 119 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static _Bool save_abbr(timezone_t tz , struct tm *tm ) 
{ 
  char const   *zone ;
  char *zone_copy ;
  size_t zone_size ;
  size_t tmp ;
  struct tm_zone *tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 123
  zone = (char const   *)((void *)0);
#line 124
  zone_copy = (char *)"";
#line 131
  zone = tm->tm_zone;
#line 143
  if (! zone) {
#line 144
    return ((_Bool)1);
  } else
#line 143
  if ((unsigned long )((char *)tm) <= (unsigned long )zone) {
#line 143
    if ((unsigned long )zone < (unsigned long )((char *)(tm + 1))) {
#line 144
      return ((_Bool)1);
    }
  }
#line 146
  if (*zone) {
#line 148
    zone_copy = tz->abbrs;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 150
      tmp___2 = strcmp((char const   *)zone_copy, zone);
      }
#line 150
      if (! (tmp___2 != 0)) {
#line 150
        goto while_break;
      }
#line 152
      if (! *zone_copy) {
#line 152
        if ((unsigned long )zone_copy == (unsigned long )(tz->abbrs)) {
#line 152
          if (! tz->tz_is_set) {
#line 152
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 154
          tmp = strlen(zone);
#line 154
          zone_size = tmp + 1UL;
          }
#line 155
          if (zone_size < (size_t )((tz->abbrs + 119) - zone_copy)) {
            {
#line 156
            extend_abbrs(zone_copy, zone, zone_size);
            }
          } else {
            {
#line 159
            tmp___0 = tzalloc(zone);
#line 159
            tz->next = tmp___0;
#line 159
            tz = tmp___0;
            }
#line 160
            if (! tz) {
#line 161
              return ((_Bool)0);
            }
#line 162
            tz->tz_is_set = (char)0;
#line 163
            zone_copy = tz->abbrs;
          }
#line 165
          goto while_break;
        }
      }
      {
#line 168
      tmp___1 = strlen((char const   *)zone_copy);
#line 168
      zone_copy += tmp___1 + 1UL;
      }
#line 169
      if (! *zone_copy) {
#line 169
        if (tz->next) {
#line 171
          tz = tz->next;
#line 172
          zone_copy = tz->abbrs;
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 179
  tm->tm_zone = (char const   *)zone_copy;
#line 186
  return ((_Bool)1);
}
}
#line 190 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
void tzfree(timezone_t tz ) 
{ 
  timezone_t next ;

  {
#line 193
  if ((unsigned long )tz != (unsigned long )local_tz) {
    {
#line 194
    while (1) {
      while_continue: /* CIL Label */ ;
#line 194
      if (! tz) {
#line 194
        goto while_break;
      }
      {
#line 196
      next = tz->next;
#line 197
      free((void *)tz);
#line 198
      tz = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 200
  return;
}
}
#line 206 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static char *getenv_TZ(void) 
{ 
  char *tmp ;

  {
  {
#line 209
  tmp = getenv(TZ);
  }
#line 209
  return (tmp);
}
}
#line 214 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static int setenv_TZ(char const   *tz ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 217
  if (tz) {
    {
#line 217
    tmp = setenv(TZ, tz, 1);
#line 217
    tmp___1 = tmp;
    }
  } else {
    {
#line 217
    tmp___0 = unsetenv(TZ);
#line 217
    tmp___1 = tmp___0;
    }
  }
#line 217
  return (tmp___1);
}
}
#line 223 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static _Bool change_env(timezone_t tz ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 226
  if (tz->tz_is_set) {
#line 226
    tmp = tz->abbrs;
  } else {
#line 226
    tmp = (char *)((void *)0);
  }
  {
#line 226
  tmp___0 = setenv_TZ((char const   *)tmp);
  }
#line 226
  if (tmp___0 != 0) {
#line 227
    return ((_Bool)0);
  }
  {
#line 228
  tzset();
  }
#line 229
  return ((_Bool)1);
}
}
#line 236 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static timezone_t set_tz(timezone_t tz ) 
{ 
  char *env_tz ;
  char *tmp ;
  timezone_t old_tz ;
  timezone_t tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 239
  tmp = getenv_TZ();
#line 239
  env_tz = tmp;
  }
#line 240
  if (env_tz) {
#line 240
    if (tz->tz_is_set) {
      {
#line 240
      tmp___4 = strcmp((char const   *)(tz->abbrs), (char const   *)env_tz);
      }
#line 240
      if (tmp___4 == 0) {
#line 240
        tmp___5 = 1;
      } else {
#line 240
        tmp___5 = 0;
      }
    } else {
#line 240
      tmp___5 = 0;
    }
#line 240
    tmp___6 = tmp___5;
  } else {
#line 240
    tmp___6 = ! tz->tz_is_set;
  }
#line 240
  if (tmp___6) {
#line 243
    return ((timezone_t )local_tz);
  } else {
    {
#line 246
    tmp___0 = tzalloc((char const   *)env_tz);
#line 246
    old_tz = tmp___0;
    }
#line 247
    if (! old_tz) {
#line 248
      return (old_tz);
    }
    {
#line 249
    tmp___3 = change_env(tz);
    }
#line 249
    if (! tmp___3) {
      {
#line 251
      tmp___1 = __errno_location();
#line 251
      saved_errno = *tmp___1;
#line 252
      tzfree(old_tz);
#line 253
      tmp___2 = __errno_location();
#line 253
      *tmp___2 = saved_errno;
      }
#line 254
      return ((timezone_t )((void *)0));
    }
#line 256
    return (old_tz);
  }
}
}
#line 263 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
static _Bool revert_tz(timezone_t tz ) 
{ 
  int saved_errno ;
  int *tmp ;
  _Bool ok ;
  _Bool tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 266
  if ((unsigned long )tz == (unsigned long )local_tz) {
#line 267
    return ((_Bool)1);
  } else {
    {
#line 270
    tmp = __errno_location();
#line 270
    saved_errno = *tmp;
#line 271
    tmp___0 = change_env(tz);
#line 271
    ok = tmp___0;
    }
#line 272
    if (! ok) {
      {
#line 273
      tmp___1 = __errno_location();
#line 273
      saved_errno = *tmp___1;
      }
    }
    {
#line 274
    tzfree(tz);
#line 275
    tmp___2 = __errno_location();
#line 275
    *tmp___2 = saved_errno;
    }
#line 276
    return (ok);
  }
}
}
#line 281 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
struct tm *( __attribute__((__nonnull__(2,3))) localtime_rz)(timezone_t tz , time_t const   * __restrict  t ,
                                                             struct tm * __restrict  tm ) 
{ 
  struct tm *tmp ;
  timezone_t old_tz ;
  timezone_t tmp___0 ;
  struct tm *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
#line 284
  if (! tz) {
    {
#line 285
    tmp = gmtime_r(t, tm);
    }
#line 285
    return (tmp);
  } else {
    {
#line 288
    tmp___0 = set_tz(tz);
#line 288
    old_tz = tmp___0;
    }
#line 289
    if (old_tz) {
      {
#line 291
      tmp___1 = localtime_r(t, tm);
#line 291
      tm = (struct tm */* __restrict  */)tmp___1;
      }
#line 292
      if (tm) {
        {
#line 292
        tmp___2 = save_abbr(tz, (struct tm *)tm);
        }
#line 292
        if (! tmp___2) {
#line 293
          tm = (struct tm */* __restrict  */)((void *)0);
        }
      }
      {
#line 294
      tmp___3 = revert_tz(old_tz);
      }
#line 294
      if (tmp___3) {
#line 295
        return ((struct tm *)tm);
      }
    }
#line 297
    return ((struct tm *)((void *)0));
  }
}
}
#line 302 "/home/khheo/project/benchmark/tar-1.29/gnu/time_rz.c"
time_t ( __attribute__((__nonnull__(2))) mktime_z)(timezone_t tz , struct tm * __restrict  tm ) 
{ 
  time_t tmp ;
  timezone_t old_tz ;
  timezone_t tmp___0 ;
  time_t t ;
  time_t tmp___1 ;
  time_t badtime ;
  struct tm tm_1 ;
  struct tm *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
#line 305
  if (! tz) {
    {
#line 306
    tmp = timegm((struct tm *)tm);
    }
#line 306
    return (tmp);
  } else {
    {
#line 309
    tmp___0 = set_tz(tz);
#line 309
    old_tz = tmp___0;
    }
#line 310
    if (old_tz) {
      {
#line 312
      tmp___1 = rpl_mktime((struct tm *)tm);
#line 312
      t = tmp___1;
#line 314
      badtime = (time_t )-1;
      }
#line 316
      if (t != badtime) {
#line 316
        goto _L;
      } else {
        {
#line 316
        tmp___2 = localtime_r((time_t const   */* __restrict  */)(& t), (struct tm */* __restrict  */)(& tm_1));
        }
#line 316
        if (tmp___2) {
          {
#line 316
          tmp___3 = equal_tm((struct tm  const  *)tm, (struct tm  const  *)(& tm_1));
          }
#line 316
          if (tmp___3) {
            _L: /* CIL Label */ 
            {
#line 316
            tmp___4 = save_abbr(tz, (struct tm *)tm);
            }
#line 316
            if (! tmp___4) {
#line 319
              t = badtime;
            }
          }
        }
      }
      {
#line 321
      tmp___5 = revert_tz(old_tz);
      }
#line 321
      if (tmp___5) {
#line 322
        return (t);
      }
    }
#line 324
    return ((time_t )-1);
  }
}
}
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 58
int try_tempname(char *tmpl , int suffixlen , void *args___0 , int (*tryfunc)(char * ,
                                                                              void * ) ) ;
#line 63 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 157 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 317 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 177 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
static char const   letters[63]  = 
#line 177 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 186 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
static uint64_t value  ;
#line 180 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
int try_tempname(char *tmpl , int suffixlen , void *args___0 , int (*tryfunc)(char * ,
                                                                              void * ) ) 
{ 
  int len ;
  char *XXXXXX ;
  uint64_t random_time_bits ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  unsigned int attempts ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  struct timeval tv ;
  __pid_t tmp___3 ;
  uint64_t v ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 189
  fd = -1;
#line 190
  tmp = __errno_location();
#line 190
  save_errno = *tmp;
#line 205
  attempts = 238328U;
#line 208
  tmp___0 = strlen((char const   *)tmpl);
#line 208
  len = (int )tmp___0;
  }
#line 209
  if (len < 6 + suffixlen) {
    {
#line 211
    tmp___1 = __errno_location();
#line 211
    *tmp___1 = 22;
    }
#line 212
    return (-1);
  } else {
    {
#line 209
    tmp___2 = memcmp((void const   *)(tmpl + ((len - 6) - suffixlen)), (void const   *)"XXXXXX",
                     (size_t )6);
    }
#line 209
    if (tmp___2) {
      {
#line 211
      tmp___1 = __errno_location();
#line 211
      *tmp___1 = 22;
      }
#line 212
      return (-1);
    }
  }
  {
#line 216
  XXXXXX = tmpl + ((len - 6) - suffixlen);
#line 224
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 225
  random_time_bits = ((uint64_t )tv.tv_usec << 16) ^ (unsigned long )tv.tv_sec;
#line 228
  tmp___3 = getpid();
#line 228
  value += random_time_bits ^ (unsigned long )tmp___3;
#line 230
  count = 0U;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (count < attempts)) {
#line 230
      goto while_break;
    }
    {
#line 232
    v = value;
#line 235
    *(XXXXXX + 0) = (char )letters[v % 62UL];
#line 236
    v /= 62UL;
#line 237
    *(XXXXXX + 1) = (char )letters[v % 62UL];
#line 238
    v /= 62UL;
#line 239
    *(XXXXXX + 2) = (char )letters[v % 62UL];
#line 240
    v /= 62UL;
#line 241
    *(XXXXXX + 3) = (char )letters[v % 62UL];
#line 242
    v /= 62UL;
#line 243
    *(XXXXXX + 4) = (char )letters[v % 62UL];
#line 244
    v /= 62UL;
#line 245
    *(XXXXXX + 5) = (char )letters[v % 62UL];
#line 247
    fd = (*tryfunc)(tmpl, args___0);
    }
#line 248
    if (fd >= 0) {
      {
#line 250
      tmp___4 = __errno_location();
#line 250
      *tmp___4 = save_errno;
      }
#line 251
      return (fd);
    } else {
      {
#line 253
      tmp___5 = __errno_location();
      }
#line 253
      if (*tmp___5 != 17) {
#line 254
        return (-1);
      }
    }
#line 230
    value += 7777UL;
#line 230
    count ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 258
  tmp___6 = __errno_location();
#line 258
  *tmp___6 = 17;
  }
#line 259
  return (-1);
}
}
#line 262 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
static int try_file(char *tmpl , void *flags ) 
{ 
  int *openflags ;
  int tmp ;

  {
  {
#line 265
  openflags = (int *)flags;
#line 266
  tmp = open((char const   *)tmpl, (((*openflags & -4) | 2) | 64) | 128, 384);
  }
#line 266
  return (tmp);
}
}
#line 271 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
static int try_dir(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  int tmp ;

  {
  {
#line 274
  tmp = mkdir((char const   *)tmpl, (__mode_t )448);
  }
#line 274
  return (tmp);
}
}
#line 277 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
static int try_nocreate(char *tmpl , void *flags  __attribute__((__unused__)) ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 282
  tmp___0 = lstat((char const   */* __restrict  */)tmpl, (struct stat */* __restrict  */)(& st));
  }
#line 282
  if (tmp___0 == 0) {
    {
#line 283
    tmp = __errno_location();
#line 283
    *tmp = 17;
    }
  }
  {
#line 284
  tmp___3 = __errno_location();
  }
#line 284
  if (*tmp___3 == 2) {
#line 284
    tmp___2 = 0;
  } else {
#line 284
    tmp___2 = -1;
  }
#line 284
  return (tmp___2);
}
}
#line 300 "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int (*tryfunc)(char * , void * ) ;
  int tmp ;

  {
  {
#line 307
  if (kind == 0) {
#line 307
    goto case_0;
  }
#line 311
  if (kind == 1) {
#line 311
    goto case_1;
  }
#line 315
  if (kind == 2) {
#line 315
    goto case_2;
  }
#line 319
  goto switch_default;
  case_0: /* CIL Label */ 
#line 308
  tryfunc = & try_file;
#line 309
  goto switch_break;
  case_1: /* CIL Label */ 
#line 312
  tryfunc = & try_dir;
#line 313
  goto switch_break;
  case_2: /* CIL Label */ 
#line 316
  tryfunc = & try_nocreate;
#line 317
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 320
  __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/khheo/project/benchmark/tar-1.29/gnu/tempname.c",
                320U, "gen_tempname");
#line 321
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 323
  tmp = try_tempname(tmpl, suffixlen, (void *)(& flags), tryfunc);
  }
#line 323
  return (tmp);
}
}
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 90 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen )  __attribute__((__pure__)) ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
  }
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 44 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname.h"
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 46
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 48
_Bool strip_trailing_slashes(char *file ) ;
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
  {
#line 33
  tmp = last_component((char const   *)file);
#line 33
  base = tmp;
  }
#line 39
  if (! *base) {
#line 40
    base = file;
  }
  {
#line 41
  tmp___0 = base_len((char const   *)base);
#line 41
  base_lim = base + tmp___0;
#line 42
  had_slash = (_Bool )((int )*base_lim != 0);
#line 43
  *base_lim = (char )'\000';
  }
#line 44
  return (had_slash);
}
}
#line 88 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 timezone_t tz , int ns ) ;
#line 122 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c ) ;
#line 125
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c ) ;
#line 307 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    tmp___0 = len;
#line 311
    len --;
#line 311
    if (! (tmp___0 > 0UL)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp = tolower((int )((unsigned char )*(src + len)));
#line 312
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return (dest);
}
}
#line 316 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 320
    tmp___0 = len;
#line 320
    len --;
#line 320
    if (! (tmp___0 > 0UL)) {
#line 320
      goto while_break;
    }
    {
#line 321
    tmp = toupper((int )((unsigned char )*(src + len)));
#line 321
    *(dest + len) = (char )tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  return (dest);
}
}
#line 363 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 369
  big_enough_multiple_of_7 = 378;
#line 370
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 407 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
static size_t strftime_case_(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                             struct tm  const  *tp , timezone_t tz , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  int century ;
  int tmp___13 ;
  int tmp___14 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___15 ;
  size_t _incr___3 ;
  size_t tmp___16 ;
  size_t _delta___3 ;
  int padding ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___17 ;
  size_t _incr___4 ;
  size_t tmp___18 ;
  size_t _delta___4 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___19 ;
  size_t _incr___5 ;
  size_t tmp___20 ;
  size_t _delta___5 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___21 ;
  size_t _incr___6 ;
  size_t tmp___22 ;
  size_t _delta___6 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___23 ;
  size_t _incr___7 ;
  size_t tmp___24 ;
  size_t _delta___7 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___25 ;
  size_t _incr___8 ;
  size_t tmp___26 ;
  size_t _delta___8 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___27 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___28 ;
  size_t _incr___9 ;
  size_t tmp___29 ;
  size_t _delta___9 ;
  int year ;
  int tmp___30 ;
  int year_adjust ;
  int days ;
  int tmp___31 ;
  int tmp___32 ;
  int d___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int yy ;
  int tmp___35 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___36 ;
  size_t _w___10 ;
  int tmp___37 ;
  size_t _incr___10 ;
  size_t tmp___38 ;
  size_t _delta___10 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___39 ;
  size_t _incr___11 ;
  size_t tmp___40 ;
  size_t _delta___11 ;

  {
#line 420
  hour12 = (int )tp->tm_hour;
#line 448
  i = (size_t )0;
#line 449
  p = s;
#line 460
  copy = *tp;
#line 461
  tp = (struct tm  const  *)(& copy);
#line 464
  zone = (char const   *)((void *)0);
#line 472
  zone = (char const   *)tp->tm_zone;
#line 496
  if (! zone) {
#line 497
    zone = "";
  }
#line 499
  if (hour12 > 12) {
#line 500
    hour12 -= 12;
  } else
#line 502
  if (hour12 == 0) {
#line 503
    hour12 = 12;
  }
#line 505
  f = format;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! ((int const   )*f != 0)) {
#line 505
      goto while_break;
    }
#line 507
    pad = 0;
#line 509
    digits = 0;
#line 523
    width = -1;
#line 524
    to_lowcase = (_Bool)0;
#line 525
    to_uppcase = upcase;
#line 527
    change_case = (_Bool)0;
#line 610
    if ((int const   )*f != 37) {
      {
#line 612
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 612
        _n = (size_t )1;
#line 612
        if (width < 0) {
#line 612
          tmp = 0;
        } else {
#line 612
          tmp = width;
        }
#line 612
        _w = (size_t )tmp;
#line 612
        if (_n < _w) {
#line 612
          tmp___0 = _w;
        } else {
#line 612
          tmp___0 = _n;
        }
#line 612
        _incr = tmp___0;
#line 612
        if (_incr >= maxsize - i) {
#line 612
          return ((size_t )0);
        }
#line 612
        if (p) {
#line 612
          if (digits == 0) {
#line 612
            if (_n < _w) {
#line 612
              _delta = (size_t )width - _n;
#line 612
              if (pad == 48) {
                {
#line 612
                memset((void *)p, '0', _delta);
#line 612
                p += _delta;
                }
              } else {
                {
#line 612
                memset((void *)p, ' ', _delta);
#line 612
                p += _delta;
                }
              }
            }
          }
#line 612
          *p = (char )*f;
#line 612
          p += _n;
        }
#line 612
        i += _incr;
#line 612
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 613
      goto __Cont;
    }
    {
#line 619
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 621
      f ++;
      {
#line 626
      if ((int const   )*f == 48) {
#line 626
        goto case_48;
      }
#line 626
      if ((int const   )*f == 45) {
#line 626
        goto case_48;
      }
#line 626
      if ((int const   )*f == 95) {
#line 626
        goto case_48;
      }
#line 631
      if ((int const   )*f == 94) {
#line 631
        goto case_94;
      }
#line 634
      if ((int const   )*f == 35) {
#line 634
        goto case_35;
      }
#line 638
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 627
      pad = (int )*f;
#line 628
      goto while_continue___1;
      case_94: /* CIL Label */ 
#line 632
      to_uppcase = (_Bool)1;
#line 633
      goto while_continue___1;
      case_35: /* CIL Label */ 
#line 635
      change_case = (_Bool)1;
#line 636
      goto while_continue___1;
      switch_default: /* CIL Label */ 
#line 639
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 641
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 645
    if ((unsigned int )*f - 48U <= 9U) {
#line 647
      width = 0;
      {
#line 648
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 650
        if (width > 214748364) {
#line 653
          width = 2147483647;
        } else
#line 650
        if (width == 214748364) {
#line 650
          if ((int const   )*f - 48 > 7) {
#line 653
            width = 2147483647;
          } else {
#line 656
            width *= 10;
#line 657
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 656
          width *= 10;
#line 657
          width += (int )((int const   )*f - 48);
        }
#line 659
        f ++;
#line 648
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 648
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 668
    if ((int const   )*f == 79) {
#line 668
      goto case_79;
    }
#line 668
    if ((int const   )*f == 69) {
#line 668
      goto case_79;
    }
#line 672
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 669
    tmp___1 = f;
#line 669
    f ++;
#line 669
    modifier = (int )*tmp___1;
#line 670
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 673
    modifier = 0;
#line 674
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 678
    format_char = (int )*f;
    {
#line 721
    if (format_char == 37) {
#line 721
      goto case_37;
    }
#line 727
    if (format_char == 97) {
#line 727
      goto case_97;
    }
#line 742
    if (format_char == 65) {
#line 742
      goto case_65;
    }
#line 758
    if (format_char == 104) {
#line 758
      goto case_104;
    }
#line 758
    if (format_char == 98) {
#line 758
      goto case_104;
    }
#line 773
    if (format_char == 66) {
#line 773
      goto case_66;
    }
#line 788
    if (format_char == 99) {
#line 788
      goto case_99;
    }
#line 847
    if (format_char == 67) {
#line 847
      goto case_67;
    }
#line 876
    if (format_char == 120) {
#line 876
      goto case_120;
    }
#line 889
    if (format_char == 68) {
#line 889
      goto case_68;
    }
#line 895
    if (format_char == 100) {
#line 895
      goto case_100;
    }
#line 901
    if (format_char == 101) {
#line 901
      goto case_101;
    }
#line 1027
    if (format_char == 70) {
#line 1027
      goto case_70;
    }
#line 1033
    if (format_char == 72) {
#line 1033
      goto case_72;
    }
#line 1039
    if (format_char == 73) {
#line 1039
      goto case_73;
    }
#line 1045
    if (format_char == 107) {
#line 1045
      goto case_107;
    }
#line 1051
    if (format_char == 108) {
#line 1051
      goto case_108;
    }
#line 1057
    if (format_char == 106) {
#line 1057
      goto case_106;
    }
#line 1063
    if (format_char == 77) {
#line 1063
      goto case_77;
    }
#line 1069
    if (format_char == 109) {
#line 1069
      goto case_109;
    }
#line 1076
    if (format_char == 78) {
#line 1076
      goto case_78;
    }
#line 1094
    if (format_char == 110) {
#line 1094
      goto case_110;
    }
#line 1098
    if (format_char == 80) {
#line 1098
      goto case_80;
    }
#line 1105
    if (format_char == 112) {
#line 1105
      goto case_112;
    }
#line 1118
    if (format_char == 82) {
#line 1118
      goto case_82;
    }
#line 1122
    if (format_char == 114) {
#line 1122
      goto case_114;
    }
#line 1133
    if (format_char == 83) {
#line 1133
      goto case_83;
    }
#line 1139
    if (format_char == 115) {
#line 1139
      goto case_115;
    }
#line 1166
    if (format_char == 88) {
#line 1166
      goto case_88;
    }
#line 1179
    if (format_char == 84) {
#line 1179
      goto case_84;
    }
#line 1183
    if (format_char == 116) {
#line 1183
      goto case_116;
    }
#line 1187
    if (format_char == 117) {
#line 1187
      goto case_117;
    }
#line 1190
    if (format_char == 85) {
#line 1190
      goto case_85;
    }
#line 1198
    if (format_char == 71) {
#line 1198
      goto case_71;
    }
#line 1198
    if (format_char == 103) {
#line 1198
      goto case_71;
    }
#line 1198
    if (format_char == 86) {
#line 1198
      goto case_71;
    }
#line 1254
    if (format_char == 87) {
#line 1254
      goto case_87;
    }
#line 1260
    if (format_char == 119) {
#line 1260
      goto case_119;
    }
#line 1266
    if (format_char == 89) {
#line 1266
      goto case_89;
    }
#line 1290
    if (format_char == 121) {
#line 1290
      goto case_121;
    }
#line 1313
    if (format_char == 90) {
#line 1313
      goto case_90;
    }
#line 1334
    if (format_char == 58) {
#line 1334
      goto case_58;
    }
#line 1344
    if (format_char == 122) {
#line 1344
      goto case_122;
    }
#line 1422
    if (format_char == 0) {
#line 1422
      goto case_0___0;
    }
#line 1425
    goto bad_format;
    case_37: /* CIL Label */ 
#line 722
    if (modifier != 0) {
#line 723
      goto bad_format;
    }
    {
#line 724
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 724
      _n___0 = (size_t )1;
#line 724
      if (width < 0) {
#line 724
        tmp___2 = 0;
      } else {
#line 724
        tmp___2 = width;
      }
#line 724
      _w___0 = (size_t )tmp___2;
#line 724
      if (_n___0 < _w___0) {
#line 724
        tmp___3 = _w___0;
      } else {
#line 724
        tmp___3 = _n___0;
      }
#line 724
      _incr___0 = tmp___3;
#line 724
      if (_incr___0 >= maxsize - i) {
#line 724
        return ((size_t )0);
      }
#line 724
      if (p) {
#line 724
        if (digits == 0) {
#line 724
          if (_n___0 < _w___0) {
#line 724
            _delta___0 = (size_t )width - _n___0;
#line 724
            if (pad == 48) {
              {
#line 724
              memset((void *)p, '0', _delta___0);
#line 724
              p += _delta___0;
              }
            } else {
              {
#line 724
              memset((void *)p, ' ', _delta___0);
#line 724
              p += _delta___0;
              }
            }
          }
        }
#line 724
        *p = (char )*f;
#line 724
        p += _n___0;
      }
#line 724
      i += _incr___0;
#line 724
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 725
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 728
    if (modifier != 0) {
#line 729
      goto bad_format;
    }
#line 730
    if (change_case) {
#line 732
      to_uppcase = (_Bool)1;
#line 733
      to_lowcase = (_Bool)0;
    }
#line 739
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 743
    if (modifier != 0) {
#line 744
      goto bad_format;
    }
#line 745
    if (change_case) {
#line 747
      to_uppcase = (_Bool)1;
#line 748
      to_lowcase = (_Bool)0;
    }
#line 754
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 759
    if (change_case) {
#line 761
      to_uppcase = (_Bool)1;
#line 762
      to_lowcase = (_Bool)0;
    }
#line 764
    if (modifier != 0) {
#line 765
      goto bad_format;
    }
#line 770
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 774
    if (modifier != 0) {
#line 775
      goto bad_format;
    }
#line 776
    if (change_case) {
#line 778
      to_uppcase = (_Bool)1;
#line 779
      to_lowcase = (_Bool)0;
    }
#line 785
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 789
    if (modifier == 79) {
#line 790
      goto bad_format;
    }
#line 799
    goto underlying_strftime;
    subformat: 
    {
#line 804
    tmp___4 = strftime_case_(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                             tp, tz, ns);
#line 804
    len = tmp___4;
    }
    {
#line 808
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 808
      _n___1 = len;
#line 808
      if (width < 0) {
#line 808
        tmp___5 = 0;
      } else {
#line 808
        tmp___5 = width;
      }
#line 808
      _w___1 = (size_t )tmp___5;
#line 808
      if (_n___1 < _w___1) {
#line 808
        tmp___6 = _w___1;
      } else {
#line 808
        tmp___6 = _n___1;
      }
#line 808
      _incr___1 = tmp___6;
#line 808
      if (_incr___1 >= maxsize - i) {
#line 808
        return ((size_t )0);
      }
#line 808
      if (p) {
#line 808
        if (digits == 0) {
#line 808
          if (_n___1 < _w___1) {
#line 808
            _delta___1 = (size_t )width - _n___1;
#line 808
            if (pad == 48) {
              {
#line 808
              memset((void *)p, '0', _delta___1);
#line 808
              p += _delta___1;
              }
            } else {
              {
#line 808
              memset((void *)p, ' ', _delta___1);
#line 808
              p += _delta___1;
              }
            }
          }
        }
        {
#line 808
        strftime_case_(to_uppcase, p, maxsize - i, subfmt, tp, tz, ns);
#line 808
        p += _n___1;
        }
      }
#line 808
      i += _incr___1;
#line 808
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 813
    goto switch_break___1;
    underlying_strftime: 
#line 821
    u = ufmt;
#line 834
    tmp___7 = u;
#line 834
    u ++;
#line 834
    *tmp___7 = (char )' ';
#line 835
    tmp___8 = u;
#line 835
    u ++;
#line 835
    *tmp___8 = (char )'%';
#line 836
    if (modifier != 0) {
#line 837
      tmp___9 = u;
#line 837
      u ++;
#line 837
      *tmp___9 = (char )modifier;
    }
    {
#line 838
    tmp___10 = u;
#line 838
    u ++;
#line 838
    *tmp___10 = (char )format_char;
#line 839
    *u = (char )'\000';
#line 840
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 841
    if (len___0 != 0UL) {
      {
#line 842
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 842
        _n___2 = len___0 - 1UL;
#line 842
        if (width < 0) {
#line 842
          tmp___11 = 0;
        } else {
#line 842
          tmp___11 = width;
        }
#line 842
        _w___2 = (size_t )tmp___11;
#line 842
        if (_n___2 < _w___2) {
#line 842
          tmp___12 = _w___2;
        } else {
#line 842
          tmp___12 = _n___2;
        }
#line 842
        _incr___2 = tmp___12;
#line 842
        if (_incr___2 >= maxsize - i) {
#line 842
          return ((size_t )0);
        }
#line 842
        if (p) {
#line 842
          if (digits == 0) {
#line 842
            if (_n___2 < _w___2) {
#line 842
              _delta___2 = (size_t )width - _n___2;
#line 842
              if (pad == 48) {
                {
#line 842
                memset((void *)p, '0', _delta___2);
#line 842
                p += _delta___2;
                }
              } else {
                {
#line 842
                memset((void *)p, ' ', _delta___2);
#line 842
                p += _delta___2;
                }
              }
            }
          }
#line 842
          if (to_lowcase) {
            {
#line 842
            memcpy_lowcase(p, (char const   *)(ubuf + 1), _n___2);
            }
          } else
#line 842
          if (to_uppcase) {
            {
#line 842
            memcpy_uppcase(p, (char const   *)(ubuf + 1), _n___2);
            }
          } else {
            {
#line 842
            memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(ubuf + 1)),
                   _n___2);
            }
          }
#line 842
          p += _n___2;
        }
#line 842
        i += _incr___2;
#line 842
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
#line 844
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 848
    if (modifier == 79) {
#line 849
      goto bad_format;
    }
#line 850
    if (modifier == 69) {
#line 866
      goto underlying_strftime;
    }
#line 871
    century = (int )(tp->tm_year / 100 + 19);
#line 872
    if (tp->tm_year % 100 < 0) {
#line 872
      if (0 < century) {
#line 872
        tmp___13 = 1;
      } else {
#line 872
        tmp___13 = 0;
      }
    } else {
#line 872
      tmp___13 = 0;
    }
#line 872
    century -= tmp___13;
    {
#line 873
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 873
      digits = 2;
#line 873
      negative_number = (_Bool )(tp->tm_year < -1900);
#line 873
      u_number_value = (unsigned int )century;
#line 873
      goto do_signed_number;
#line 873
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
    case_120: /* CIL Label */ 
#line 877
    if (modifier == 79) {
#line 878
      goto bad_format;
    }
#line 887
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 890
    if (modifier != 0) {
#line 891
      goto bad_format;
    }
#line 892
    subfmt = "%m/%d/%y";
#line 893
    goto subformat;
    case_100: /* CIL Label */ 
#line 896
    if (modifier == 69) {
#line 897
      goto bad_format;
    }
    {
#line 899
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 899
      digits = 2;
#line 899
      number_value = (int )tp->tm_mday;
#line 899
      goto do_number;
#line 899
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    case_101: /* CIL Label */ 
#line 902
    if (modifier == 69) {
#line 903
      goto bad_format;
    }
    {
#line 905
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 905
      digits = 2;
#line 905
      number_value = (int )tp->tm_mday;
#line 905
      goto do_number_spacepad;
#line 905
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
    do_tz_offset: 
#line 911
    always_output_a_sign = (_Bool)1;
#line 912
    goto do_number_body;
    do_number_spacepad: 
#line 916
    if (pad != 48) {
#line 916
      if (pad != 45) {
#line 917
        pad = '_';
      }
    }
    do_number: 
#line 921
    negative_number = (_Bool )(number_value < 0);
#line 922
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 925
    always_output_a_sign = (_Bool)0;
#line 926
    tz_colon_mask = 0;
    do_number_body: 
#line 934
    if (modifier == 79) {
#line 934
      if (! negative_number) {
#line 952
        goto underlying_strftime;
      }
    }
#line 956
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 958
    if (negative_number) {
#line 959
      u_number_value = - u_number_value;
    }
    {
#line 961
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 963
      if (tz_colon_mask & 1) {
#line 964
        bufp --;
#line 964
        *bufp = (char )':';
      }
#line 965
      tz_colon_mask >>= 1;
#line 966
      bufp --;
#line 966
      *bufp = (char )(u_number_value % 10U + 48U);
#line 967
      u_number_value /= 10U;
#line 961
      if (! (u_number_value != 0U)) {
#line 961
        if (! (tz_colon_mask != 0)) {
#line 961
          goto while_break___9;
        }
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 972
    if (digits < width) {
#line 973
      digits = width;
    }
#line 975
    if (negative_number) {
#line 975
      sign_char = (char )'-';
    } else {
#line 975
      if (always_output_a_sign) {
#line 975
        tmp___14 = '+';
      } else {
#line 975
        tmp___14 = 0;
      }
#line 975
      sign_char = (char )tmp___14;
    }
#line 979
    if (pad == 45) {
#line 981
      if (sign_char) {
        {
#line 982
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 982
          _n___3 = (size_t )1;
#line 982
          if (width < 0) {
#line 982
            tmp___15 = 0;
          } else {
#line 982
            tmp___15 = width;
          }
#line 982
          _w___3 = (size_t )tmp___15;
#line 982
          if (_n___3 < _w___3) {
#line 982
            tmp___16 = _w___3;
          } else {
#line 982
            tmp___16 = _n___3;
          }
#line 982
          _incr___3 = tmp___16;
#line 982
          if (_incr___3 >= maxsize - i) {
#line 982
            return ((size_t )0);
          }
#line 982
          if (p) {
#line 982
            if (digits == 0) {
#line 982
              if (_n___3 < _w___3) {
#line 982
                _delta___3 = (size_t )width - _n___3;
#line 982
                if (pad == 48) {
                  {
#line 982
                  memset((void *)p, '0', _delta___3);
#line 982
                  p += _delta___3;
                  }
                } else {
                  {
#line 982
                  memset((void *)p, ' ', _delta___3);
#line 982
                  p += _delta___3;
                  }
                }
              }
            }
#line 982
            *p = sign_char;
#line 982
            p += _n___3;
          }
#line 982
          i += _incr___3;
#line 982
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
    } else {
#line 986
      padding = (int )(((long )digits - ((buf + sizeof(buf) / sizeof(buf[0])) - bufp)) - (long )(! (! sign_char)));
#line 989
      if (padding > 0) {
#line 991
        if (pad == 95) {
#line 993
          if ((size_t )padding >= maxsize - i) {
#line 994
            return ((size_t )0);
          }
#line 996
          if (p) {
            {
#line 997
            memset((void *)p, ' ', (size_t )padding);
#line 997
            p += padding;
            }
          }
#line 998
          i += (size_t )padding;
#line 999
          if (width > padding) {
#line 999
            width -= padding;
          } else {
#line 999
            width = 0;
          }
#line 1000
          if (sign_char) {
            {
#line 1001
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 1001
              _n___4 = (size_t )1;
#line 1001
              if (width < 0) {
#line 1001
                tmp___17 = 0;
              } else {
#line 1001
                tmp___17 = width;
              }
#line 1001
              _w___4 = (size_t )tmp___17;
#line 1001
              if (_n___4 < _w___4) {
#line 1001
                tmp___18 = _w___4;
              } else {
#line 1001
                tmp___18 = _n___4;
              }
#line 1001
              _incr___4 = tmp___18;
#line 1001
              if (_incr___4 >= maxsize - i) {
#line 1001
                return ((size_t )0);
              }
#line 1001
              if (p) {
#line 1001
                if (digits == 0) {
#line 1001
                  if (_n___4 < _w___4) {
#line 1001
                    _delta___4 = (size_t )width - _n___4;
#line 1001
                    if (pad == 48) {
                      {
#line 1001
                      memset((void *)p, '0', _delta___4);
#line 1001
                      p += _delta___4;
                      }
                    } else {
                      {
#line 1001
                      memset((void *)p, ' ', _delta___4);
#line 1001
                      p += _delta___4;
                      }
                    }
                  }
                }
#line 1001
                *p = sign_char;
#line 1001
                p += _n___4;
              }
#line 1001
              i += _incr___4;
#line 1001
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
        } else {
#line 1005
          if ((size_t )digits >= maxsize - i) {
#line 1006
            return ((size_t )0);
          }
#line 1008
          if (sign_char) {
            {
#line 1009
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 1009
              _n___5 = (size_t )1;
#line 1009
              if (width < 0) {
#line 1009
                tmp___19 = 0;
              } else {
#line 1009
                tmp___19 = width;
              }
#line 1009
              _w___5 = (size_t )tmp___19;
#line 1009
              if (_n___5 < _w___5) {
#line 1009
                tmp___20 = _w___5;
              } else {
#line 1009
                tmp___20 = _n___5;
              }
#line 1009
              _incr___5 = tmp___20;
#line 1009
              if (_incr___5 >= maxsize - i) {
#line 1009
                return ((size_t )0);
              }
#line 1009
              if (p) {
#line 1009
                if (digits == 0) {
#line 1009
                  if (_n___5 < _w___5) {
#line 1009
                    _delta___5 = (size_t )width - _n___5;
#line 1009
                    if (pad == 48) {
                      {
#line 1009
                      memset((void *)p, '0', _delta___5);
#line 1009
                      p += _delta___5;
                      }
                    } else {
                      {
#line 1009
                      memset((void *)p, ' ', _delta___5);
#line 1009
                      p += _delta___5;
                      }
                    }
                  }
                }
#line 1009
                *p = sign_char;
#line 1009
                p += _n___5;
              }
#line 1009
              i += _incr___5;
#line 1009
              goto while_break___12;
            }
            while_break___12: /* CIL Label */ ;
            }
          }
#line 1011
          if (p) {
            {
#line 1012
            memset((void *)p, '0', (size_t )padding);
#line 1012
            p += padding;
            }
          }
#line 1013
          i += (size_t )padding;
#line 1014
          width = 0;
        }
      } else
#line 1019
      if (sign_char) {
        {
#line 1020
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 1020
          _n___6 = (size_t )1;
#line 1020
          if (width < 0) {
#line 1020
            tmp___21 = 0;
          } else {
#line 1020
            tmp___21 = width;
          }
#line 1020
          _w___6 = (size_t )tmp___21;
#line 1020
          if (_n___6 < _w___6) {
#line 1020
            tmp___22 = _w___6;
          } else {
#line 1020
            tmp___22 = _n___6;
          }
#line 1020
          _incr___6 = tmp___22;
#line 1020
          if (_incr___6 >= maxsize - i) {
#line 1020
            return ((size_t )0);
          }
#line 1020
          if (p) {
#line 1020
            if (digits == 0) {
#line 1020
              if (_n___6 < _w___6) {
#line 1020
                _delta___6 = (size_t )width - _n___6;
#line 1020
                if (pad == 48) {
                  {
#line 1020
                  memset((void *)p, '0', _delta___6);
#line 1020
                  p += _delta___6;
                  }
                } else {
                  {
#line 1020
                  memset((void *)p, ' ', _delta___6);
#line 1020
                  p += _delta___6;
                  }
                }
              }
            }
#line 1020
            *p = sign_char;
#line 1020
            p += _n___6;
          }
#line 1020
          i += _incr___6;
#line 1020
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
    {
#line 1024
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1024
      _n___7 = (size_t )((buf + sizeof(buf) / sizeof(buf[0])) - bufp);
#line 1024
      if (width < 0) {
#line 1024
        tmp___23 = 0;
      } else {
#line 1024
        tmp___23 = width;
      }
#line 1024
      _w___7 = (size_t )tmp___23;
#line 1024
      if (_n___7 < _w___7) {
#line 1024
        tmp___24 = _w___7;
      } else {
#line 1024
        tmp___24 = _n___7;
      }
#line 1024
      _incr___7 = tmp___24;
#line 1024
      if (_incr___7 >= maxsize - i) {
#line 1024
        return ((size_t )0);
      }
#line 1024
      if (p) {
#line 1024
        if (digits == 0) {
#line 1024
          if (_n___7 < _w___7) {
#line 1024
            _delta___7 = (size_t )width - _n___7;
#line 1024
            if (pad == 48) {
              {
#line 1024
              memset((void *)p, '0', _delta___7);
#line 1024
              p += _delta___7;
              }
            } else {
              {
#line 1024
              memset((void *)p, ' ', _delta___7);
#line 1024
              p += _delta___7;
              }
            }
          }
        }
#line 1024
        if (to_lowcase) {
          {
#line 1024
          memcpy_lowcase(p, (char const   *)bufp, _n___7);
          }
        } else
#line 1024
        if (to_uppcase) {
          {
#line 1024
          memcpy_uppcase(p, (char const   *)bufp, _n___7);
          }
        } else {
          {
#line 1024
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)bufp),
                 _n___7);
          }
        }
#line 1024
        p += _n___7;
      }
#line 1024
      i += _incr___7;
#line 1024
      goto while_break___14;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1025
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 1028
    if (modifier != 0) {
#line 1029
      goto bad_format;
    }
#line 1030
    subfmt = "%Y-%m-%d";
#line 1031
    goto subformat;
    case_72: /* CIL Label */ 
#line 1034
    if (modifier == 69) {
#line 1035
      goto bad_format;
    }
    {
#line 1037
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 1037
      digits = 2;
#line 1037
      number_value = (int )tp->tm_hour;
#line 1037
      goto do_number;
#line 1037
      goto while_break___15;
    }
    while_break___15: /* CIL Label */ ;
    }
    case_73: /* CIL Label */ 
#line 1040
    if (modifier == 69) {
#line 1041
      goto bad_format;
    }
    {
#line 1043
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1043
      digits = 2;
#line 1043
      number_value = hour12;
#line 1043
      goto do_number;
#line 1043
      goto while_break___16;
    }
    while_break___16: /* CIL Label */ ;
    }
    case_107: /* CIL Label */ 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
    {
#line 1049
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 1049
      digits = 2;
#line 1049
      number_value = (int )tp->tm_hour;
#line 1049
      goto do_number_spacepad;
#line 1049
      goto while_break___17;
    }
    while_break___17: /* CIL Label */ ;
    }
    case_108: /* CIL Label */ 
#line 1052
    if (modifier == 69) {
#line 1053
      goto bad_format;
    }
    {
#line 1055
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1055
      digits = 2;
#line 1055
      number_value = hour12;
#line 1055
      goto do_number_spacepad;
#line 1055
      goto while_break___18;
    }
    while_break___18: /* CIL Label */ ;
    }
    case_106: /* CIL Label */ 
#line 1058
    if (modifier == 69) {
#line 1059
      goto bad_format;
    }
    {
#line 1061
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 1061
      digits = 3;
#line 1061
      negative_number = (_Bool )(tp->tm_yday < -1);
#line 1061
      u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1061
      goto do_signed_number;
#line 1061
      goto while_break___19;
    }
    while_break___19: /* CIL Label */ ;
    }
    case_77: /* CIL Label */ 
#line 1064
    if (modifier == 69) {
#line 1065
      goto bad_format;
    }
    {
#line 1067
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1067
      digits = 2;
#line 1067
      number_value = (int )tp->tm_min;
#line 1067
      goto do_number;
#line 1067
      goto while_break___20;
    }
    while_break___20: /* CIL Label */ ;
    }
    case_109: /* CIL Label */ 
#line 1070
    if (modifier == 69) {
#line 1071
      goto bad_format;
    }
    {
#line 1073
    while (1) {
      while_continue___21: /* CIL Label */ ;
#line 1073
      digits = 2;
#line 1073
      negative_number = (_Bool )(tp->tm_mon < -1);
#line 1073
      u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1073
      goto do_signed_number;
#line 1073
      goto while_break___21;
    }
    while_break___21: /* CIL Label */ ;
    }
    case_78: /* CIL Label */ 
#line 1077
    if (modifier == 69) {
#line 1078
      goto bad_format;
    }
#line 1080
    number_value = ns;
#line 1081
    if (width == -1) {
#line 1082
      width = 9;
    } else {
#line 1087
      j = width;
      {
#line 1087
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 1087
        if (! (j < 9)) {
#line 1087
          goto while_break___22;
        }
#line 1088
        number_value /= 10;
#line 1087
        j ++;
      }
      while_break___22: /* CIL Label */ ;
      }
    }
    {
#line 1091
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 1091
      digits = width;
#line 1091
      number_value = number_value;
#line 1091
      goto do_number;
#line 1091
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    case_110: /* CIL Label */ 
    {
#line 1095
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 1095
      _n___8 = (size_t )1;
#line 1095
      if (width < 0) {
#line 1095
        tmp___25 = 0;
      } else {
#line 1095
        tmp___25 = width;
      }
#line 1095
      _w___8 = (size_t )tmp___25;
#line 1095
      if (_n___8 < _w___8) {
#line 1095
        tmp___26 = _w___8;
      } else {
#line 1095
        tmp___26 = _n___8;
      }
#line 1095
      _incr___8 = tmp___26;
#line 1095
      if (_incr___8 >= maxsize - i) {
#line 1095
        return ((size_t )0);
      }
#line 1095
      if (p) {
#line 1095
        if (digits == 0) {
#line 1095
          if (_n___8 < _w___8) {
#line 1095
            _delta___8 = (size_t )width - _n___8;
#line 1095
            if (pad == 48) {
              {
#line 1095
              memset((void *)p, '0', _delta___8);
#line 1095
              p += _delta___8;
              }
            } else {
              {
#line 1095
              memset((void *)p, ' ', _delta___8);
#line 1095
              p += _delta___8;
              }
            }
          }
        }
#line 1095
        *p = (char )'\n';
#line 1095
        p += _n___8;
      }
#line 1095
      i += _incr___8;
#line 1095
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 1096
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1099
    to_lowcase = (_Bool)1;
#line 1101
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1106
    if (change_case) {
#line 1108
      to_uppcase = (_Bool)0;
#line 1109
      to_lowcase = (_Bool)1;
    }
#line 1115
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1119
    subfmt = "%H:%M";
#line 1120
    goto subformat;
    case_114: /* CIL Label */ 
#line 1130
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1134
    if (modifier == 69) {
#line 1135
      goto bad_format;
    }
    {
#line 1137
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 1137
      digits = 2;
#line 1137
      number_value = (int )tp->tm_sec;
#line 1137
      goto do_number;
#line 1137
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    case_115: /* CIL Label */ 
    {
#line 1144
    ltm = (struct tm )*tp;
#line 1145
    t = mktime_z(tz, (struct tm */* __restrict  */)(& ltm));
#line 1150
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 1151
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1153
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1155
      d = (int )(t % 10L);
#line 1156
      t /= 10L;
#line 1157
      bufp --;
#line 1157
      if (negative_number) {
#line 1157
        tmp___27 = - d;
      } else {
#line 1157
        tmp___27 = d;
      }
#line 1157
      *bufp = (char )(tmp___27 + 48);
#line 1153
      if (! (t != 0L)) {
#line 1153
        goto while_break___26;
      }
    }
    while_break___26: /* CIL Label */ ;
    }
#line 1161
    digits = 1;
#line 1162
    always_output_a_sign = (_Bool)0;
#line 1163
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1167
    if (modifier == 79) {
#line 1168
      goto bad_format;
    }
#line 1177
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1180
    subfmt = "%H:%M:%S";
#line 1181
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1184
    while (1) {
      while_continue___27: /* CIL Label */ ;
#line 1184
      _n___9 = (size_t )1;
#line 1184
      if (width < 0) {
#line 1184
        tmp___28 = 0;
      } else {
#line 1184
        tmp___28 = width;
      }
#line 1184
      _w___9 = (size_t )tmp___28;
#line 1184
      if (_n___9 < _w___9) {
#line 1184
        tmp___29 = _w___9;
      } else {
#line 1184
        tmp___29 = _n___9;
      }
#line 1184
      _incr___9 = tmp___29;
#line 1184
      if (_incr___9 >= maxsize - i) {
#line 1184
        return ((size_t )0);
      }
#line 1184
      if (p) {
#line 1184
        if (digits == 0) {
#line 1184
          if (_n___9 < _w___9) {
#line 1184
            _delta___9 = (size_t )width - _n___9;
#line 1184
            if (pad == 48) {
              {
#line 1184
              memset((void *)p, '0', _delta___9);
#line 1184
              p += _delta___9;
              }
            } else {
              {
#line 1184
              memset((void *)p, ' ', _delta___9);
#line 1184
              p += _delta___9;
              }
            }
          }
        }
#line 1184
        *p = (char )'\t';
#line 1184
        p += _n___9;
      }
#line 1184
      i += _incr___9;
#line 1184
      goto while_break___27;
    }
    while_break___27: /* CIL Label */ ;
    }
#line 1185
    goto switch_break___1;
    case_117: /* CIL Label */ 
    {
#line 1188
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1188
      digits = 1;
#line 1188
      number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1188
      goto do_number;
#line 1188
      goto while_break___28;
    }
    while_break___28: /* CIL Label */ ;
    }
    case_85: /* CIL Label */ 
#line 1191
    if (modifier == 69) {
#line 1192
      goto bad_format;
    }
    {
#line 1194
    while (1) {
      while_continue___29: /* CIL Label */ ;
#line 1194
      digits = 2;
#line 1194
      number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1194
      goto do_number;
#line 1194
      goto while_break___29;
    }
    while_break___29: /* CIL Label */ ;
    }
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1199
    if (modifier == 69) {
#line 1200
      goto bad_format;
    }
#line 1206
    if (tp->tm_year < 0) {
#line 1206
      tmp___30 = 300;
    } else {
#line 1206
      tmp___30 = -100;
    }
    {
#line 1206
    year = (int )(tp->tm_year + (int const   )tmp___30);
#line 1210
    year_adjust = 0;
#line 1211
    tmp___31 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1211
    days = tmp___31;
    }
#line 1213
    if (days < 0) {
#line 1216
      year_adjust = -1;
#line 1217
      if ((year - 1) % 4 == 0) {
#line 1217
        if ((year - 1) % 100 != 0) {
#line 1217
          tmp___32 = 1;
        } else
#line 1217
        if ((year - 1) % 400 == 0) {
#line 1217
          tmp___32 = 1;
        } else {
#line 1217
          tmp___32 = 0;
        }
      } else {
#line 1217
        tmp___32 = 0;
      }
      {
#line 1217
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___32)), (int )tp->tm_wday);
      }
    } else {
#line 1222
      if (year % 4 == 0) {
#line 1222
        if (year % 100 != 0) {
#line 1222
          tmp___33 = 1;
        } else
#line 1222
        if (year % 400 == 0) {
#line 1222
          tmp___33 = 1;
        } else {
#line 1222
          tmp___33 = 0;
        }
      } else {
#line 1222
        tmp___33 = 0;
      }
      {
#line 1222
      tmp___34 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___33)),
                               (int )tp->tm_wday);
#line 1222
      d___0 = tmp___34;
      }
#line 1224
      if (0 <= d___0) {
#line 1227
        year_adjust = 1;
#line 1228
        days = d___0;
      }
    }
    {
#line 1234
    if ((int const   )*f == 103) {
#line 1234
      goto case_103___0;
    }
#line 1244
    if ((int const   )*f == 71) {
#line 1244
      goto case_71___0;
    }
#line 1249
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1236
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
    {
#line 1237
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 1237
      digits = 2;
#line 1237
      if (0 <= yy) {
#line 1237
        number_value = yy;
      } else {
#line 1237
        if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1237
          tmp___35 = - yy;
        } else {
#line 1237
          tmp___35 = yy + 100;
        }
#line 1237
        number_value = tmp___35;
      }
#line 1237
      goto do_number;
#line 1237
      goto while_break___30;
    }
    while_break___30: /* CIL Label */ ;
    }
    case_71___0: /* CIL Label */ 
    {
#line 1245
    while (1) {
      while_continue___31: /* CIL Label */ ;
#line 1245
      digits = 4;
#line 1245
      negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1245
      u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1245
      goto do_signed_number;
#line 1245
      goto while_break___31;
    }
    while_break___31: /* CIL Label */ ;
    }
    switch_default___1: /* CIL Label */ 
    {
#line 1250
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 1250
      digits = 2;
#line 1250
      number_value = days / 7 + 1;
#line 1250
      goto do_number;
#line 1250
      goto while_break___32;
    }
    while_break___32: /* CIL Label */ ;
    }
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1255
    if (modifier == 69) {
#line 1256
      goto bad_format;
    }
    {
#line 1258
    while (1) {
      while_continue___33: /* CIL Label */ ;
#line 1258
      digits = 2;
#line 1258
      number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1258
      goto do_number;
#line 1258
      goto while_break___33;
    }
    while_break___33: /* CIL Label */ ;
    }
    case_119: /* CIL Label */ 
#line 1261
    if (modifier == 69) {
#line 1262
      goto bad_format;
    }
    {
#line 1264
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 1264
      digits = 1;
#line 1264
      number_value = (int )tp->tm_wday;
#line 1264
      goto do_number;
#line 1264
      goto while_break___34;
    }
    while_break___34: /* CIL Label */ ;
    }
    case_89: /* CIL Label */ 
#line 1267
    if (modifier == 69) {
#line 1281
      goto underlying_strftime;
    }
#line 1284
    if (modifier == 79) {
#line 1285
      goto bad_format;
    }
    {
#line 1287
    while (1) {
      while_continue___35: /* CIL Label */ ;
#line 1287
      digits = 4;
#line 1287
      negative_number = (_Bool )(tp->tm_year < -1900);
#line 1287
      u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1287
      goto do_signed_number;
#line 1287
      goto while_break___35;
    }
    while_break___35: /* CIL Label */ ;
    }
    case_121: /* CIL Label */ 
#line 1291
    if (modifier == 69) {
#line 1302
      goto underlying_strftime;
    }
#line 1307
    yy___0 = (int )(tp->tm_year % 100);
#line 1308
    if (yy___0 < 0) {
#line 1309
      if (tp->tm_year < -1900) {
#line 1309
        yy___0 = - yy___0;
      } else {
#line 1309
        yy___0 += 100;
      }
    }
    {
#line 1310
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 1310
      digits = 2;
#line 1310
      number_value = yy___0;
#line 1310
      goto do_number;
#line 1310
      goto while_break___36;
    }
    while_break___36: /* CIL Label */ ;
    }
    case_90: /* CIL Label */ 
#line 1314
    if (change_case) {
#line 1316
      to_uppcase = (_Bool)0;
#line 1317
      to_lowcase = (_Bool)1;
    }
    {
#line 1330
    while (1) {
      while_continue___37: /* CIL Label */ ;
      {
#line 1330
      tmp___36 = strlen(zone);
#line 1330
      _n___10 = tmp___36;
      }
#line 1330
      if (width < 0) {
#line 1330
        tmp___37 = 0;
      } else {
#line 1330
        tmp___37 = width;
      }
#line 1330
      _w___10 = (size_t )tmp___37;
#line 1330
      if (_n___10 < _w___10) {
#line 1330
        tmp___38 = _w___10;
      } else {
#line 1330
        tmp___38 = _n___10;
      }
#line 1330
      _incr___10 = tmp___38;
#line 1330
      if (_incr___10 >= maxsize - i) {
#line 1330
        return ((size_t )0);
      }
#line 1330
      if (p) {
#line 1330
        if (digits == 0) {
#line 1330
          if (_n___10 < _w___10) {
#line 1330
            _delta___10 = (size_t )width - _n___10;
#line 1330
            if (pad == 48) {
              {
#line 1330
              memset((void *)p, '0', _delta___10);
#line 1330
              p += _delta___10;
              }
            } else {
              {
#line 1330
              memset((void *)p, ' ', _delta___10);
#line 1330
              p += _delta___10;
              }
            }
          }
        }
#line 1330
        if (to_lowcase) {
          {
#line 1330
          memcpy_lowcase(p, zone, _n___10);
          }
        } else
#line 1330
        if (to_uppcase) {
          {
#line 1330
          memcpy_uppcase(p, zone, _n___10);
          }
        } else {
          {
#line 1330
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)zone),
                 _n___10);
          }
        }
#line 1330
        p += _n___10;
      }
#line 1330
      i += _incr___10;
#line 1330
      goto while_break___37;
    }
    while_break___37: /* CIL Label */ ;
    }
#line 1332
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1337
    colons = (size_t )1;
    {
#line 1337
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 1337
      if (! ((int const   )*(f + colons) == 58)) {
#line 1337
        goto while_break___38;
      }
#line 1338
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1337
      colons ++;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 1339
    if ((int const   )*(f + colons) != 122) {
#line 1340
      goto bad_format;
    }
#line 1341
    f += colons;
#line 1342
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1345
    colons = (size_t )0;
    do_z_conversion: 
#line 1348
    if (tp->tm_isdst < 0) {
#line 1349
      goto switch_break___1;
    }
#line 1357
    diff = (int )tp->tm_gmtoff;
#line 1394
    hour_diff = (diff / 60) / 60;
#line 1395
    min_diff = (diff / 60) % 60;
#line 1396
    sec_diff = diff % 60;
    {
#line 1400
    if (colons == 0UL) {
#line 1400
      goto case_0;
    }
#line 1403
    if (colons == 1UL) {
#line 1403
      goto tz_hh_mm;
    }
#line 1406
    if (colons == 2UL) {
#line 1406
      goto tz_hh_mm_ss;
    }
#line 1410
    if (colons == 3UL) {
#line 1410
      goto case_3;
    }
#line 1417
    goto switch_default___2;
    case_0: /* CIL Label */ 
    {
#line 1401
    while (1) {
      while_continue___39: /* CIL Label */ ;
#line 1401
      digits = 5;
#line 1401
      negative_number = (_Bool )(diff < 0);
#line 1401
      tz_colon_mask = 0;
#line 1401
      u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1401
      goto do_tz_offset;
#line 1401
      goto while_break___39;
    }
    while_break___39: /* CIL Label */ ;
    }
    tz_hh_mm: 
    case_1: /* CIL Label */ 
    {
#line 1404
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 1404
      digits = 6;
#line 1404
      negative_number = (_Bool )(diff < 0);
#line 1404
      tz_colon_mask = 4;
#line 1404
      u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1404
      goto do_tz_offset;
#line 1404
      goto while_break___40;
    }
    while_break___40: /* CIL Label */ ;
    }
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
    {
#line 1407
    while (1) {
      while_continue___41: /* CIL Label */ ;
#line 1407
      digits = 9;
#line 1407
      negative_number = (_Bool )(diff < 0);
#line 1407
      tz_colon_mask = 20;
#line 1407
      u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1407
      goto do_tz_offset;
#line 1407
      goto while_break___41;
    }
    while_break___41: /* CIL Label */ ;
    }
    case_3: /* CIL Label */ 
#line 1411
    if (sec_diff != 0) {
#line 1412
      goto tz_hh_mm_ss;
    }
#line 1413
    if (min_diff != 0) {
#line 1414
      goto tz_hh_mm;
    }
    {
#line 1415
    while (1) {
      while_continue___42: /* CIL Label */ ;
#line 1415
      digits = 3;
#line 1415
      negative_number = (_Bool )(diff < 0);
#line 1415
      tz_colon_mask = 0;
#line 1415
      u_number_value = (unsigned int )hour_diff;
#line 1415
      goto do_tz_offset;
#line 1415
      goto while_break___42;
    }
    while_break___42: /* CIL Label */ ;
    }
    switch_default___2: /* CIL Label */ 
#line 1418
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1423
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1432
    flen = 1;
    {
#line 1432
    while (1) {
      while_continue___43: /* CIL Label */ ;
#line 1432
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1432
        goto while_break___43;
      }
#line 1433
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1432
      flen ++;
    }
    while_break___43: /* CIL Label */ ;
    }
    {
#line 1434
    while (1) {
      while_continue___44: /* CIL Label */ ;
#line 1434
      _n___11 = (size_t )flen;
#line 1434
      if (width < 0) {
#line 1434
        tmp___39 = 0;
      } else {
#line 1434
        tmp___39 = width;
      }
#line 1434
      _w___11 = (size_t )tmp___39;
#line 1434
      if (_n___11 < _w___11) {
#line 1434
        tmp___40 = _w___11;
      } else {
#line 1434
        tmp___40 = _n___11;
      }
#line 1434
      _incr___11 = tmp___40;
#line 1434
      if (_incr___11 >= maxsize - i) {
#line 1434
        return ((size_t )0);
      }
#line 1434
      if (p) {
#line 1434
        if (digits == 0) {
#line 1434
          if (_n___11 < _w___11) {
#line 1434
            _delta___11 = (size_t )width - _n___11;
#line 1434
            if (pad == 48) {
              {
#line 1434
              memset((void *)p, '0', _delta___11);
#line 1434
              p += _delta___11;
              }
            } else {
              {
#line 1434
              memset((void *)p, ' ', _delta___11);
#line 1434
              p += _delta___11;
              }
            }
          }
        }
#line 1434
        if (to_lowcase) {
          {
#line 1434
          memcpy_lowcase(p, f + (1 - flen), _n___11);
          }
        } else
#line 1434
        if (to_uppcase) {
          {
#line 1434
          memcpy_uppcase(p, f + (1 - flen), _n___11);
          }
        } else {
          {
#line 1434
          memcpy((void */* __restrict  */)((void *)p), (void const   */* __restrict  */)((void const   *)(f + (1 - flen))),
                 _n___11);
          }
        }
#line 1434
        p += _n___11;
      }
#line 1434
      i += _incr___11;
#line 1434
      goto while_break___44;
    }
    while_break___44: /* CIL Label */ ;
    }
#line 1436
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 505
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1441
  if (p) {
#line 1441
    if (maxsize != 0UL) {
#line 1442
      *p = (char )'\000';
    }
  }
#line 1445
  return (i);
}
}
#line 1454 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 timezone_t tz , int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1459
  tmp = strftime_case_((_Bool)0, s, maxsize, format, tp, tz, ns);
  }
#line 1459
  return (tmp);
}
}
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 280 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 293
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/acl.h"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 66 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 295
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) ;
#line 302
#pragma GCC diagnostic pop
#line 758 "/home/khheo/project/benchmark/tar-1.29/gnu/set-permissions.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 761
  if (desc != -1) {
    {
#line 762
    tmp = fchmod(desc, mode);
    }
#line 762
    return (tmp);
  } else {
    {
#line 764
    tmp___0 = chmod(name, mode);
    }
#line 764
    return (tmp___0);
  }
}
}
#line 774 "/home/khheo/project/benchmark/tar-1.29/gnu/set-permissions.c"
int set_permissions(struct permission_context *ctx , char const   *name , int desc ) 
{ 
  _Bool acls_set  __attribute__((__unused__)) ;
  _Bool early_chmod ;
  _Bool must_chmod ;
  int ret ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 777
  acls_set = (_Bool)0;
#line 779
  must_chmod = (_Bool)0;
#line 780
  ret = 0;
#line 800
  early_chmod = (_Bool)1;
#line 803
  if (early_chmod) {
    {
#line 805
    ret = chmod_or_fchmod(name, desc, ctx->mode);
    }
#line 806
    if (ret != 0) {
#line 807
      return (-1);
    }
  }
#line 832
  if (must_chmod) {
#line 832
    if (! early_chmod) {
#line 834
      if (ret) {
        {
#line 834
        tmp = __errno_location();
#line 834
        tmp___0 = *tmp;
        }
      } else {
#line 834
        tmp___0 = 0;
      }
      {
#line 834
      saved_errno = tmp___0;
#line 836
      ret = chmod_or_fchmod(name, desc, ctx->mode);
      }
#line 838
      if (saved_errno) {
        {
#line 840
        tmp___1 = __errno_location();
#line 840
        *tmp___1 = saved_errno;
#line 841
        ret = -1;
        }
      }
    }
  }
#line 845
  return (ret);
}
}
#line 38 "./selinux/selinux.h"
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 38
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 71 "./selinux/selinux.h"
__inline int getcon(security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 73
  tmp = __errno_location();
#line 73
  *tmp = 95;
  }
#line 73
  return (-1);
}
}
#line 74 "./selinux/selinux.h"
__inline void freecon(security_context_t con  __attribute__((__unused__)) ) 
{ 


  {
#line 75
  return;
}
}
#line 80 "./selinux/selinux.h"
__inline int setfscreatecon(security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 82
  tmp = __errno_location();
#line 82
  *tmp = 95;
  }
#line 82
  return (-1);
}
}
#line 83 "./selinux/selinux.h"
__inline int matchpathcon(char const   *file  __attribute__((__unused__)) , mode_t m  __attribute__((__unused__)) ,
                          security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 87
  tmp = __errno_location();
#line 87
  *tmp = 95;
  }
#line 87
  return (-1);
}
}
#line 88 "./selinux/selinux.h"
__inline int getfilecon(char const   *file  __attribute__((__unused__)) , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 91
  tmp = __errno_location();
#line 91
  *tmp = 95;
  }
#line 91
  return (-1);
}
}
#line 96 "./selinux/selinux.h"
__inline int fgetfilecon(int fd , security_context_t *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 98
  tmp = __errno_location();
#line 98
  *tmp = 95;
  }
#line 98
  return (-1);
}
}
#line 99 "./selinux/selinux.h"
__inline int setfilecon(char const   *file  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 102
  tmp = __errno_location();
#line 102
  *tmp = 95;
  }
#line 102
  return (-1);
}
}
#line 107 "./selinux/selinux.h"
__inline int fsetfilecon(int fd  __attribute__((__unused__)) , security_context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  *tmp = 95;
  }
#line 110
  return (-1);
}
}
#line 121 "./selinux/selinux.h"
__inline int security_compute_create(security_context_t scon  __attribute__((__unused__)) ,
                                     security_context_t tcon  __attribute__((__unused__)) ,
                                     security_class_t tclass  __attribute__((__unused__)) ,
                                     security_context_t *newcon  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 126
  tmp = __errno_location();
#line 126
  *tmp = 95;
  }
#line 126
  return (-1);
}
}
#line 127 "./selinux/selinux.h"
__inline security_class_t string_to_security_class(char const   *name ) 
{ 
  int *tmp ;

  {
  {
#line 129
  tmp = __errno_location();
#line 129
  *tmp = 95;
  }
#line 129
  return ((security_class_t )0);
}
}
#line 130 "./selinux/selinux.h"
__inline int matchpathcon_init_prefix(char const   *path  __attribute__((__unused__)) ,
                                      char const   *prefix  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 133
  tmp = __errno_location();
#line 133
  *tmp = 95;
  }
#line 133
  return (-1);
}
}
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 38
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 10 "./selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "./selinux/context.h"
__inline context_t context_new(char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 39
  tmp = __errno_location();
#line 39
  *tmp = 95;
  }
#line 39
  return (0);
}
}
#line 40 "./selinux/context.h"
__inline char *context_str(context_t con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 41
  tmp = __errno_location();
#line 41
  *tmp = 95;
  }
#line 41
  return ((char *)((void *)0));
}
}
#line 42 "./selinux/context.h"
__inline void context_free(context_t c  __attribute__((__unused__)) ) 
{ 


  {
#line 42
  return;
}
}
#line 44 "./selinux/context.h"
__inline int context_user_set(context_t sc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
  {
#line 46
  tmp = __errno_location();
#line 46
  *tmp = 95;
  }
#line 46
  return (-1);
}
}
#line 65
#pragma GCC diagnostic pop
#line 34 "/home/khheo/project/benchmark/tar-1.29/gnu/selinux-at.h"
int getfileconat(int fd , char const   *file , security_context_t *con ) ;
#line 39
int lgetfileconat(int fd , char const   *file , security_context_t *con ) ;
#line 45
int setfileconat(int fd , char const   *file , security_context_t con ) ;
#line 52
int lsetfileconat(int fd , char const   *file , security_context_t con ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/at-func.c"
int getfileconat(int fd , char const   *file , security_context_t *con ) 
{ 
  int tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = getfilecon(file, con);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = getfilecon(file, con);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = getfilecon((char const   *)proc_file, con);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return (-1);
  }
  {
#line 130
  err = getfilecon(file, con);
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/at-func.c"
int lgetfileconat(int fd , char const   *file , security_context_t *con ) 
{ 
  int tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = getfilecon(file, con);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = getfilecon(file, con);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = getfilecon((char const   *)proc_file, con);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return (-1);
  }
  {
#line 130
  err = getfilecon(file, con);
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/at-func.c"
int setfileconat(int fd , char const   *file , security_context_t con ) 
{ 
  int tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = setfilecon(file, con);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = setfilecon(file, con);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = setfilecon((char const   *)proc_file, con);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return (-1);
  }
  {
#line 130
  err = setfilecon(file, con);
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/at-func.c"
int lsetfileconat(int fd , char const   *file , security_context_t con ) 
{ 
  int tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = setfilecon(file, con);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = setfilecon(file, con);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = setfilecon((char const   *)proc_file, con);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return (-1);
  }
  {
#line 130
  err = setfilecon(file, con);
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 10 "./selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 65
#pragma GCC diagnostic pop
#line 149 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.h"
char *streamsavedir(DIR *dirp , enum savedir_option option ) ;
#line 39
char *savedir(char const   *dir , enum savedir_option option ) ;
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 827 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 451 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 50 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
static int direntry_cmp_name(void const   *a , void const   *b ) 
{ 
  direntry_t const   *dea ;
  direntry_t const   *deb ;
  int tmp ;

  {
  {
#line 53
  dea = (direntry_t const   *)a;
#line 54
  deb = (direntry_t const   *)b;
#line 56
  tmp = strcmp((char const   *)dea->name, (char const   *)deb->name);
  }
#line 56
  return (tmp);
}
}
#line 62 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
static int direntry_cmp_inode(void const   *a , void const   *b ) 
{ 
  direntry_t const   *dea ;
  direntry_t const   *deb ;
  int tmp ;

  {
#line 65
  dea = (direntry_t const   *)a;
#line 66
  deb = (direntry_t const   *)b;
#line 68
  if (dea->ino < deb->ino) {
#line 68
    tmp = -1;
  } else {
#line 68
    tmp = dea->ino > deb->ino;
  }
#line 68
  return (tmp);
}
}
#line 74 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
static comparison_function const   comparison_function_table[3]  = {      (comparison_function const   )0,      (comparison_function const   )(& direntry_cmp_name),      (comparison_function const   )(& direntry_cmp_inode)};
#line 90 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
char *streamsavedir(DIR *dirp , enum savedir_option option ) 
{ 
  char *name_space ;
  size_t allocated ;
  direntry_t *entries ;
  size_t entries_allocated ;
  size_t entries_used ;
  size_t used ;
  int readdir_errno ;
  int (*cmp)(void const   * , void const   * ) ;
  struct dirent  const  *dp ;
  char const   *entry___0 ;
  int *tmp ;
  struct dirent *tmp___0 ;
  size_t entry_size ;
  size_t tmp___1 ;
  size_t n ;
  void *tmp___2 ;
  size_t n___0 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t i ;
  void *tmp___8 ;
  char *dest ;
  char *tmp___9 ;
  void *tmp___10 ;

  {
#line 93
  name_space = (char *)((void *)0);
#line 94
  allocated = (size_t )0;
#line 95
  entries = (direntry_t *)((void *)0);
#line 96
  entries_allocated = (size_t )0;
#line 97
  entries_used = (size_t )0;
#line 98
  used = (size_t )0;
#line 100
  cmp = (int (*)(void const   * , void const   * ))comparison_function_table[option];
#line 102
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 103
    return ((char *)((void *)0));
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 110
    tmp = __errno_location();
#line 110
    *tmp = 0;
#line 111
    tmp___0 = readdir(dirp);
#line 111
    dp = (struct dirent  const  *)tmp___0;
    }
#line 112
    if (! dp) {
#line 113
      goto while_break;
    }
#line 117
    entry___0 = (char const   *)(dp->d_name);
#line 118
    if ((int const   )*(entry___0 + 0) != 46) {
#line 118
      tmp___5 = 0;
    } else {
#line 118
      if ((int const   )*(entry___0 + 1) != 46) {
#line 118
        tmp___4 = 1;
      } else {
#line 118
        tmp___4 = 2;
      }
#line 118
      tmp___5 = tmp___4;
    }
#line 118
    if ((int const   )*(entry___0 + tmp___5) != 0) {
      {
#line 120
      tmp___1 = strlen((char const   *)(dp->d_name));
#line 120
      entry_size = tmp___1 + 1UL;
      }
#line 121
      if (cmp) {
#line 123
        if (entries_allocated == entries_used) {
          {
#line 125
          n = entries_allocated;
#line 126
          tmp___2 = x2nrealloc((void *)entries, & n, sizeof(*entries));
#line 126
          entries = (direntry_t *)tmp___2;
#line 127
          entries_allocated = n;
          }
        }
        {
#line 129
        (entries + entries_used)->name = xstrdup(entry___0);
#line 131
        (entries + entries_used)->ino = (ino_t )dp->d_ino;
#line 133
        entries_used ++;
        }
      } else {
#line 137
        if (allocated - used <= entry_size) {
#line 139
          n___0 = used + entry_size;
#line 140
          if (n___0 < used) {
            {
#line 141
            xalloc_die();
            }
          }
          {
#line 142
          tmp___3 = x2nrealloc((void *)name_space, & n___0, (size_t )1);
#line 142
          name_space = (char *)tmp___3;
#line 143
          allocated = n___0;
          }
        }
        {
#line 145
        memcpy((void */* __restrict  */)(name_space + used), (void const   */* __restrict  */)entry___0,
               entry_size);
        }
      }
#line 147
      used += entry_size;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 151
  tmp___6 = __errno_location();
#line 151
  readdir_errno = *tmp___6;
  }
#line 152
  if (readdir_errno != 0) {
    {
#line 154
    free((void *)entries);
#line 155
    free((void *)name_space);
#line 156
    tmp___7 = __errno_location();
#line 156
    *tmp___7 = readdir_errno;
    }
#line 157
    return ((char *)((void *)0));
  }
#line 160
  if (cmp) {
#line 164
    if (entries_used) {
      {
#line 165
      qsort((void *)entries, entries_used, sizeof(*entries), cmp);
      }
    }
    {
#line 166
    tmp___8 = xmalloc(used + 1UL);
#line 166
    name_space = (char *)tmp___8;
#line 167
    used = (size_t )0;
#line 168
    i = (size_t )0;
    }
    {
#line 168
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 168
      if (! (i < entries_used)) {
#line 168
        goto while_break___0;
      }
      {
#line 170
      dest = name_space + used;
#line 171
      tmp___9 = stpcpy((char */* __restrict  */)dest, (char const   */* __restrict  */)(entries + i)->name);
#line 171
      used += (size_t )((tmp___9 - dest) + 1L);
#line 172
      free((void *)(entries + i)->name);
#line 168
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 174
    free((void *)entries);
    }
  } else
#line 176
  if (used == allocated) {
    {
#line 177
    tmp___10 = xrealloc((void *)name_space, used + 1UL);
#line 177
    name_space = (char *)tmp___10;
    }
  }
#line 179
  *(name_space + used) = (char )'\000';
#line 180
  return (name_space);
}
}
#line 188 "/home/khheo/project/benchmark/tar-1.29/gnu/savedir.c"
char *savedir(char const   *dir , enum savedir_option option ) 
{ 
  DIR *dirp ;
  DIR *tmp ;
  char *name_space ;
  char *tmp___0 ;
  int closedir_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 191
  tmp = opendir_safer(dir);
#line 191
  dirp = tmp;
  }
#line 192
  if (! dirp) {
#line 193
    return ((char *)((void *)0));
  } else {
    {
#line 196
    tmp___0 = streamsavedir(dirp, option);
#line 196
    name_space = tmp___0;
#line 197
    tmp___3 = closedir(dirp);
    }
#line 197
    if (tmp___3 != 0) {
      {
#line 199
      tmp___1 = __errno_location();
#line 199
      closedir_errno = *tmp___1;
#line 200
      free((void *)name_space);
#line 201
      tmp___2 = __errno_location();
#line 201
      *tmp___2 = closedir_errno;
      }
#line 202
      return ((char *)((void *)0));
    }
#line 204
    return (name_space);
  }
}
}
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.h"
int chdir_long(char *dir ) ;
#line 21 "/home/khheo/project/benchmark/tar-1.29/gnu/unistd-safer.h"
int fd_safer(int fd ) ;
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/cloexec.h"
int set_cloexec_flag(int desc , _Bool value___0 ) ;
#line 62 "/home/khheo/project/benchmark/tar-1.29/gnu/save-cwd.c"
int save_cwd(struct saved_cwd *cwd___0 ) 
{ 
  int tmp ;

  {
  {
#line 65
  cwd___0->name = (char *)((void *)0);
#line 67
  cwd___0->desc = open(".", 0);
#line 69
  cwd___0->desc = fd_safer(cwd___0->desc);
  }
#line 70
  if (cwd___0->desc < 0) {
    {
#line 72
    cwd___0->name = getcwd((char *)((void *)0), (size_t )0);
    }
#line 73
    if (cwd___0->name) {
#line 73
      tmp = 0;
    } else {
#line 73
      tmp = -1;
    }
#line 73
    return (tmp);
  }
  {
#line 76
  set_cloexec_flag(cwd___0->desc, (_Bool)1);
  }
#line 77
  return (0);
}
}
#line 84 "/home/khheo/project/benchmark/tar-1.29/gnu/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 87
  if (0 <= (int )cwd___0->desc) {
    {
#line 88
    tmp = fchdir((int )cwd___0->desc);
    }
#line 88
    return (tmp);
  } else {
    {
#line 90
    tmp___0 = chdir_long((char *)cwd___0->name);
    }
#line 90
    return (tmp___0);
  }
}
}
#line 93 "/home/khheo/project/benchmark/tar-1.29/gnu/save-cwd.c"
void free_cwd(struct saved_cwd *cwd___0 ) 
{ 


  {
#line 96
  if (cwd___0->desc >= 0) {
    {
#line 97
    close(cwd___0->desc);
    }
  }
  {
#line 98
  free((void *)cwd___0->name);
  }
#line 99
  return;
}
}
#line 37 "/home/khheo/project/benchmark/tar-1.29/gnu/safe-write.h"
size_t safe_write(int fd , void const   *buf , size_t count ) ;
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/tar-1.29/gnu/safe-read.c"
size_t safe_write(int fd , void const   *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = write(fd, buf, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 42 "/home/khheo/project/benchmark/tar-1.29/gnu/safe-read.h"
size_t safe_read(int fd , void *buf , size_t count ) ;
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 55 "/home/khheo/project/benchmark/tar-1.29/gnu/safe-read.c"
size_t safe_read(int fd , void *buf , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    tmp = read(fd, buf, count);
#line 66
    result = tmp;
    }
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
      {
#line 70
      tmp___1 = __errno_location();
      }
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
        {
#line 72
        tmp___0 = __errno_location();
        }
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=pure"
#line 236 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 237
enum quoting_style  const  quoting_style_vals[8] ;
#line 247
struct quoting_options *clone_quoting_options(struct quoting_options *o___0 ) ;
#line 250
enum quoting_style get_quoting_style(struct quoting_options *o___0 ) ;
#line 254
void set_quoting_style(struct quoting_options *o___0 , enum quoting_style s ) ;
#line 263
int set_char_quoting(struct quoting_options *o___0 , char c , int i ) ;
#line 269
int set_quoting_flags(struct quoting_options *o___0 , int i ) ;
#line 280
void set_custom_quoting(struct quoting_options *o___0 , char const   *left_quote ,
                        char const   *right_quote ) ;
#line 295
size_t quotearg_buffer(char *buffer___1 , size_t buffersize , char const   *arg___0 ,
                       size_t argsize , struct quoting_options  const  *o___0 ) ;
#line 302
char *quotearg_alloc(char const   *arg___0 , size_t argsize , struct quoting_options  const  *o___0 ) ;
#line 311
char *quotearg_alloc_mem(char const   *arg___0 , size_t argsize , size_t *size , struct quoting_options  const  *o___0 ) ;
#line 321
char *quotearg_n(int n , char const   *arg___0 ) ;
#line 324
char *quotearg(char const   *arg___0 ) ;
#line 329
char *quotearg_n_mem(int n , char const   *arg___0 , size_t argsize ) ;
#line 332
char *quotearg_mem(char const   *arg___0 , size_t argsize ) ;
#line 337
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg___0 ) ;
#line 342
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg___0 ,
                           size_t argsize ) ;
#line 346
char *quotearg_style(enum quoting_style s , char const   *arg___0 ) ;
#line 349
char *quotearg_style_mem(enum quoting_style s , char const   *arg___0 , size_t argsize ) ;
#line 354
char *quotearg_char(char const   *arg___0 , char ch ) ;
#line 357
char *quotearg_char_mem(char const   *arg___0 , size_t argsize , char ch ) ;
#line 360
char *quotearg_colon(char const   *arg___0 ) ;
#line 363
char *quotearg_colon_mem(char const   *arg___0 , size_t argsize ) ;
#line 369
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg___0 ) ;
#line 374
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg___0 , size_t argsize ) ;
#line 379
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg___0 ) ;
#line 384
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg___0 ,
                          size_t argsize ) ;
#line 389
void quotearg_free(void) ;
#line 25 "/home/khheo/project/benchmark/tar-1.29/gnu/quote.h"
struct quoting_options quote_quoting_options ;
#line 31
char const   *quote_n_mem(int n , char const   *arg___0 , size_t argsize ) ;
#line 36
char const   *quote_mem(char const   *arg___0 , size_t argsize ) ;
#line 40
char const   *quote_n(int n , char const   *arg___0 ) ;
#line 44
char const   *quote(char const   *arg___0 ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 42 "/home/khheo/project/benchmark/tar-1.29/gnu/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/localcharset.h"
char const   *locale_charset(void) ;
#line 97 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 292 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 296
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 120 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 75 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 75 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
  {      (char const   */* const  */)"literal",      (char const   */* const  */)"shell",      (char const   */* const  */)"shell-always",      (char const   */* const  */)"c", 
        (char const   */* const  */)"c-maybe",      (char const   */* const  */)"escape",      (char const   */* const  */)"locale",      (char const   */* const  */)"clocale", 
        (char const   */* const  */)0};
#line 89 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 89
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 102 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 107 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o___0 ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 110
  tmp = __errno_location();
#line 110
  e = *tmp;
  }
#line 111
  if (o___0) {
#line 111
    tmp___0 = o___0;
  } else {
#line 111
    tmp___0 = & default_quoting_options;
  }
  {
#line 111
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o___0));
#line 111
  p = (struct quoting_options *)tmp___1;
#line 113
  tmp___2 = __errno_location();
#line 113
  *tmp___2 = e;
  }
#line 114
  return (p);
}
}
#line 118 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o___0 ) 
{ 
  struct quoting_options *tmp ;

  {
#line 121
  if (o___0) {
#line 121
    tmp = o___0;
  } else {
#line 121
    tmp = & default_quoting_options;
  }
#line 121
  return (tmp->style);
}
}
#line 126 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
void set_quoting_style(struct quoting_options *o___0 , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 129
  if (o___0) {
#line 129
    tmp = o___0;
  } else {
#line 129
    tmp = & default_quoting_options;
  }
#line 129
  tmp->style = s;
#line 130
  return;
}
}
#line 137 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
int set_char_quoting(struct quoting_options *o___0 , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 140
  uc = (unsigned char )c;
#line 141
  if (o___0) {
#line 141
    tmp = o___0;
  } else {
#line 141
    tmp = & default_quoting_options;
  }
#line 141
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 143
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 144
  r = (int )((*p >> shift) & 1U);
#line 145
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 146
  return (r);
}
}
#line 153 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
int set_quoting_flags(struct quoting_options *o___0 , int i ) 
{ 
  int r ;

  {
#line 157
  if (! o___0) {
#line 158
    o___0 = & default_quoting_options;
  }
#line 159
  r = o___0->flags;
#line 160
  o___0->flags = i;
#line 161
  return (r);
}
}
#line 164 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
void set_custom_quoting(struct quoting_options *o___0 , char const   *left_quote ,
                        char const   *right_quote ) 
{ 


  {
#line 168
  if (! o___0) {
#line 169
    o___0 = & default_quoting_options;
  }
#line 170
  o___0->style = (enum quoting_style )8;
#line 171
  if (! left_quote) {
    {
#line 172
    abort();
    }
  } else
#line 171
  if (! right_quote) {
    {
#line 172
    abort();
    }
  }
#line 173
  o___0->left_quote = left_quote;
#line 174
  o___0->right_quote = right_quote;
#line 175
  return;
}
}
#line 178 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o___0 ;
  unsigned int tmp ;

  {
#line 181
  o___0.style = (enum quoting_style )0;
#line 181
  o___0.flags = 0;
#line 181
  o___0.quote_these_too[0] = 0U;
#line 181
  tmp = 1U;
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (tmp >= 8U) {
#line 181
      goto while_break;
    }
#line 181
    o___0.quote_these_too[tmp] = 0U;
#line 181
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 181
  o___0.left_quote = (char const   *)((void *)0);
#line 181
  o___0.right_quote = (char const   *)((void *)0);
#line 182
  if ((unsigned int )style == 8U) {
    {
#line 183
    abort();
    }
  }
#line 184
  o___0.style = style;
#line 185
  return (o___0);
}
}
#line 192 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 195
  tmp = gettext(msgid);
#line 195
  translation = (char const   *)tmp;
  }
#line 198
  if ((unsigned long )translation != (unsigned long )msgid) {
#line 199
    return (translation);
  }
  {
#line 219
  locale_code = locale_charset();
#line 220
  tmp___1 = c_strcasecmp(locale_code, "UTF-8");
  }
#line 220
  if (tmp___1 == 0) {
#line 221
    if ((int const   )*(msgid + 0) == 96) {
#line 221
      tmp___0 = "\342\200\230";
    } else {
#line 221
      tmp___0 = "\342\200\231";
    }
#line 221
    return (tmp___0);
  }
  {
#line 222
  tmp___3 = c_strcasecmp(locale_code, "GB18030");
  }
#line 222
  if (tmp___3 == 0) {
#line 223
    if ((int const   )*(msgid + 0) == 96) {
#line 223
      tmp___2 = "\241\ae";
    } else {
#line 223
      tmp___2 = "\241\257";
    }
#line 223
    return (tmp___2);
  }
#line 225
  if ((unsigned int )s == 7U) {
#line 225
    tmp___4 = "\"";
  } else {
#line 225
    tmp___4 = "\'";
  }
#line 225
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer___1 , size_t buffersize , char const   *arg___0 ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___3 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___4 ;
  size_t j ;
  int tmp___5 ;
  int tmp___6 ;
  size_t ilim ;
  int tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 250
  len = (size_t )0;
#line 251
  quote_string = (char const   *)0;
#line 252
  quote_string_len = (size_t )0;
#line 253
  backslash_escapes = (_Bool)0;
#line 254
  tmp = __ctype_get_mb_cur_max();
#line 254
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 255
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
  }
  {
#line 268
  if ((unsigned int )quoting_style == 4U) {
#line 268
    goto case_4;
  }
#line 272
  if ((unsigned int )quoting_style == 3U) {
#line 272
    goto case_3;
  }
#line 280
  if ((unsigned int )quoting_style == 5U) {
#line 280
    goto case_5;
  }
#line 287
  if ((unsigned int )quoting_style == 8U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 7U) {
#line 287
    goto case_8;
  }
#line 287
  if ((unsigned int )quoting_style == 6U) {
#line 287
    goto case_8;
  }
#line 324
  if ((unsigned int )quoting_style == 1U) {
#line 324
    goto case_1;
  }
#line 328
  if ((unsigned int )quoting_style == 2U) {
#line 328
    goto case_2;
  }
#line 335
  if ((unsigned int )quoting_style == 0U) {
#line 335
    goto case_0;
  }
#line 339
  goto switch_default;
  case_4: /* CIL Label */ 
#line 269
  quoting_style = (enum quoting_style )3;
#line 270
  elide_outer_quotes = (_Bool)1;
  case_3: /* CIL Label */ 
#line 273
  if (! elide_outer_quotes) {
    {
#line 274
    while (1) {
      while_continue: /* CIL Label */ ;
#line 274
      if (len < buffersize) {
#line 274
        *(buffer___1 + len) = (char )'\"';
      }
#line 274
      len ++;
#line 274
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 275
  backslash_escapes = (_Bool)1;
#line 276
  quote_string = "\"";
#line 277
  quote_string_len = (size_t )1;
#line 278
  goto switch_break;
  case_5: /* CIL Label */ 
#line 281
  backslash_escapes = (_Bool)1;
#line 282
  elide_outer_quotes = (_Bool)0;
#line 283
  goto switch_break;
  case_8: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 289
  if ((unsigned int )quoting_style != 8U) {
    {
#line 312
    left_quote = gettext_quote("`", quoting_style);
#line 313
    right_quote = gettext_quote("\'", quoting_style);
    }
  }
#line 315
  if (! elide_outer_quotes) {
#line 316
    quote_string = left_quote;
    {
#line 316
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 316
      if (! *quote_string) {
#line 316
        goto while_break___0;
      }
      {
#line 317
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 317
        if (len < buffersize) {
#line 317
          *(buffer___1 + len) = (char )*quote_string;
        }
#line 317
        len ++;
#line 317
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 316
      quote_string ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 318
  backslash_escapes = (_Bool)1;
#line 319
  quote_string = right_quote;
#line 320
  quote_string_len = strlen(quote_string);
  }
#line 322
  goto switch_break;
  case_1: /* CIL Label */ 
#line 325
  quoting_style = (enum quoting_style )2;
#line 326
  elide_outer_quotes = (_Bool)1;
  case_2: /* CIL Label */ 
#line 329
  if (! elide_outer_quotes) {
    {
#line 330
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 330
      if (len < buffersize) {
#line 330
        *(buffer___1 + len) = (char )'\'';
      }
#line 330
      len ++;
#line 330
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 331
  quote_string = "\'";
#line 332
  quote_string_len = (size_t )1;
#line 333
  goto switch_break;
  case_0: /* CIL Label */ 
#line 336
  elide_outer_quotes = (_Bool)0;
#line 337
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 340
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 343
  i = (size_t )0;
  {
#line 343
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 343
    if (argsize == 0xffffffffffffffffUL) {
#line 343
      tmp___7 = (int const   )*(arg___0 + i) == 0;
    } else {
#line 343
      tmp___7 = i == argsize;
    }
#line 343
    if (tmp___7) {
#line 343
      goto while_break___3;
    }
#line 347
    is_right_quote = (_Bool)0;
#line 349
    if (backslash_escapes) {
#line 349
      if (quote_string_len) {
#line 349
        if (argsize == 0xffffffffffffffffUL) {
#line 349
          if (1UL < quote_string_len) {
            {
#line 349
            argsize = strlen(arg___0);
#line 349
            tmp___0 = argsize;
            }
          } else {
#line 349
            tmp___0 = argsize;
          }
        } else {
#line 349
          tmp___0 = argsize;
        }
#line 349
        if (i + quote_string_len <= tmp___0) {
          {
#line 349
          tmp___1 = memcmp((void const   *)(arg___0 + i), (void const   *)quote_string,
                           quote_string_len);
          }
#line 349
          if (tmp___1 == 0) {
#line 359
            if (elide_outer_quotes) {
#line 360
              goto force_outer_quoting_style;
            }
#line 361
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 364
    c = (unsigned char )*(arg___0 + i);
    {
#line 367
    if ((int )c == 0) {
#line 367
      goto case_0___0;
    }
#line 393
    if ((int )c == 63) {
#line 393
      goto case_63;
    }
#line 431
    if ((int )c == 7) {
#line 431
      goto case_7___0;
    }
#line 432
    if ((int )c == 8) {
#line 432
      goto case_8___0;
    }
#line 433
    if ((int )c == 12) {
#line 433
      goto case_12;
    }
#line 434
    if ((int )c == 10) {
#line 434
      goto case_10;
    }
#line 435
    if ((int )c == 13) {
#line 435
      goto case_13;
    }
#line 436
    if ((int )c == 9) {
#line 436
      goto case_9;
    }
#line 437
    if ((int )c == 11) {
#line 437
      goto case_11;
    }
#line 438
    if ((int )c == 92) {
#line 438
      goto case_92;
    }
#line 457
    if ((int )c == 125) {
#line 457
      goto case_125;
    }
#line 457
    if ((int )c == 123) {
#line 457
      goto case_125;
    }
#line 461
    if ((int )c == 126) {
#line 461
      goto case_126;
    }
#line 461
    if ((int )c == 35) {
#line 461
      goto case_126;
    }
#line 473
    if ((int )c == 124) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 96) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 94) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 91) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 62) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 61) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 60) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 59) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 42) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 41) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 40) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 38) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 36) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 34) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 33) {
#line 473
      goto case_124;
    }
#line 473
    if ((int )c == 32) {
#line 473
      goto case_124;
    }
#line 483
    if ((int )c == 39) {
#line 483
      goto case_39___0;
    }
#line 505
    if ((int )c == 122) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 121) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 120) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 119) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 118) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 117) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 116) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 115) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 114) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 113) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 112) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 111) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 110) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 109) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 108) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 107) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 106) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 105) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 104) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 103) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 102) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 101) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 100) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 99) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 98) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 97) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 95) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 93) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 90) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 89) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 88) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 87) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 86) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 85) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 84) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 83) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 82) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 81) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 80) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 79) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 78) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 77) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 76) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 75) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 74) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 73) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 72) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 71) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 70) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 69) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 68) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 67) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 66) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 65) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 58) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 57) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 56) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 55) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 54) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 53) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 52) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 51) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 50) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 49) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 48) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 47) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 46) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 45) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 44) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 43) {
#line 505
      goto case_122;
    }
#line 505
    if ((int )c == 37) {
#line 505
      goto case_122;
    }
#line 518
    goto switch_default___2;
    case_0___0: /* CIL Label */ 
#line 368
    if (backslash_escapes) {
#line 370
      if (elide_outer_quotes) {
#line 371
        goto force_outer_quoting_style;
      }
      {
#line 372
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 372
        if (len < buffersize) {
#line 372
          *(buffer___1 + len) = (char )'\\';
        }
#line 372
        len ++;
#line 372
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 378
      if (i + 1UL < argsize) {
#line 378
        if (48 <= (int )*(arg___0 + (i + 1UL))) {
#line 378
          if ((int const   )*(arg___0 + (i + 1UL)) <= 57) {
            {
#line 380
            while (1) {
              while_continue___5: /* CIL Label */ ;
#line 380
              if (len < buffersize) {
#line 380
                *(buffer___1 + len) = (char )'0';
              }
#line 380
              len ++;
#line 380
              goto while_break___5;
            }
            while_break___5: /* CIL Label */ ;
            }
            {
#line 381
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 381
              if (len < buffersize) {
#line 381
                *(buffer___1 + len) = (char )'0';
              }
#line 381
              len ++;
#line 381
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 383
      c = (unsigned char )'0';
    } else
#line 389
    if (flags & 1) {
#line 390
      goto __Cont;
    }
#line 391
    goto switch_break___0;
    case_63: /* CIL Label */ 
    {
#line 396
    if ((unsigned int )quoting_style == 2U) {
#line 396
      goto case_2___0;
    }
#line 401
    if ((unsigned int )quoting_style == 3U) {
#line 401
      goto case_3___0;
    }
#line 426
    goto switch_default___1;
    case_2___0: /* CIL Label */ 
#line 397
    if (elide_outer_quotes) {
#line 398
      goto force_outer_quoting_style;
    }
#line 399
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
#line 402
    if (flags & 4) {
#line 402
      if (i + 2UL < argsize) {
#line 402
        if ((int const   )*(arg___0 + (i + 1UL)) == 63) {
          {
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 62) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 61) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 60) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 47) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 45) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 41) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 40) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 39) {
#line 408
            goto case_62;
          }
#line 408
          if ((int const   )*(arg___0 + (i + 2UL)) == 33) {
#line 408
            goto case_62;
          }
#line 421
          goto switch_default___0;
          case_62: /* CIL Label */ 
          case_61: /* CIL Label */ 
          case_60: /* CIL Label */ 
          case_47: /* CIL Label */ 
          case_45: /* CIL Label */ 
          case_41: /* CIL Label */ 
          case_40: /* CIL Label */ 
          case_39: /* CIL Label */ 
          case_33: /* CIL Label */ 
#line 411
          if (elide_outer_quotes) {
#line 412
            goto force_outer_quoting_style;
          }
#line 413
          c = (unsigned char )*(arg___0 + (i + 2UL));
#line 414
          i += 2UL;
          {
#line 415
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 415
            if (len < buffersize) {
#line 415
              *(buffer___1 + len) = (char )'?';
            }
#line 415
            len ++;
#line 415
            goto while_break___7;
          }
          while_break___7: /* CIL Label */ ;
          }
          {
#line 416
          while (1) {
            while_continue___8: /* CIL Label */ ;
#line 416
            if (len < buffersize) {
#line 416
              *(buffer___1 + len) = (char )'\"';
            }
#line 416
            len ++;
#line 416
            goto while_break___8;
          }
          while_break___8: /* CIL Label */ ;
          }
          {
#line 417
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 417
            if (len < buffersize) {
#line 417
              *(buffer___1 + len) = (char )'\"';
            }
#line 417
            len ++;
#line 417
            goto while_break___9;
          }
          while_break___9: /* CIL Label */ ;
          }
          {
#line 418
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 418
            if (len < buffersize) {
#line 418
              *(buffer___1 + len) = (char )'?';
            }
#line 418
            len ++;
#line 418
            goto while_break___10;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 419
          goto switch_break___2;
          switch_default___0: /* CIL Label */ 
#line 422
          goto switch_break___2;
          switch_break___2: /* CIL Label */ ;
          }
        }
      }
    }
#line 424
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 427
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 429
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
#line 431
    esc = (unsigned char )'a';
#line 431
    goto c_escape;
    case_8___0: /* CIL Label */ 
#line 432
    esc = (unsigned char )'b';
#line 432
    goto c_escape;
    case_12: /* CIL Label */ 
#line 433
    esc = (unsigned char )'f';
#line 433
    goto c_escape;
    case_10: /* CIL Label */ 
#line 434
    esc = (unsigned char )'n';
#line 434
    goto c_and_shell_escape;
    case_13: /* CIL Label */ 
#line 435
    esc = (unsigned char )'r';
#line 435
    goto c_and_shell_escape;
    case_9: /* CIL Label */ 
#line 436
    esc = (unsigned char )'t';
#line 436
    goto c_and_shell_escape;
    case_11: /* CIL Label */ 
#line 437
    esc = (unsigned char )'v';
#line 437
    goto c_escape;
    case_92: /* CIL Label */ 
#line 438
    esc = c;
#line 441
    if (backslash_escapes) {
#line 441
      if (elide_outer_quotes) {
#line 441
        if (quote_string_len) {
#line 442
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 445
    if ((unsigned int )quoting_style == 2U) {
#line 445
      if (elide_outer_quotes) {
#line 447
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 450
    if (backslash_escapes) {
#line 452
      c = esc;
#line 453
      goto store_escape;
    }
#line 455
    goto switch_break___0;
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
#line 458
    if (argsize == 0xffffffffffffffffUL) {
#line 458
      tmp___2 = (int const   )*(arg___0 + 1) == 0;
    } else {
#line 458
      tmp___2 = argsize == 1UL;
    }
#line 458
    if (! tmp___2) {
#line 459
      goto switch_break___0;
    }
    case_126: /* CIL Label */ 
    case_35: /* CIL Label */ 
#line 462
    if (i != 0UL) {
#line 463
      goto switch_break___0;
    }
    case_124: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_62___0: /* CIL Label */ 
    case_61___0: /* CIL Label */ 
    case_60___0: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41___0: /* CIL Label */ 
    case_40___0: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33___0: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 478
    if ((unsigned int )quoting_style == 2U) {
#line 478
      if (elide_outer_quotes) {
#line 480
        goto force_outer_quoting_style;
      }
    }
#line 481
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
#line 484
    if ((unsigned int )quoting_style == 2U) {
#line 486
      if (elide_outer_quotes) {
#line 487
        goto force_outer_quoting_style;
      }
      {
#line 488
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 488
        if (len < buffersize) {
#line 488
          *(buffer___1 + len) = (char )'\'';
        }
#line 488
        len ++;
#line 488
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 489
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 489
        if (len < buffersize) {
#line 489
          *(buffer___1 + len) = (char )'\\';
        }
#line 489
        len ++;
#line 489
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
      {
#line 490
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 490
        if (len < buffersize) {
#line 490
          *(buffer___1 + len) = (char )'\'';
        }
#line 490
        len ++;
#line 490
        goto while_break___13;
      }
      while_break___13: /* CIL Label */ ;
      }
    }
#line 492
    goto switch_break___0;
    case_122: /* CIL Label */ 
    case_121: /* CIL Label */ 
    case_120: /* CIL Label */ 
    case_119: /* CIL Label */ 
    case_118: /* CIL Label */ 
    case_117: /* CIL Label */ 
    case_116: /* CIL Label */ 
    case_115: /* CIL Label */ 
    case_114: /* CIL Label */ 
    case_113: /* CIL Label */ 
    case_112: /* CIL Label */ 
    case_111: /* CIL Label */ 
    case_110: /* CIL Label */ 
    case_109: /* CIL Label */ 
    case_108: /* CIL Label */ 
    case_107: /* CIL Label */ 
    case_106: /* CIL Label */ 
    case_105: /* CIL Label */ 
    case_104: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_102: /* CIL Label */ 
    case_101: /* CIL Label */ 
    case_100: /* CIL Label */ 
    case_99: /* CIL Label */ 
    case_98: /* CIL Label */ 
    case_97: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_90: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_88: /* CIL Label */ 
    case_87: /* CIL Label */ 
    case_86: /* CIL Label */ 
    case_85: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_83: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_81: /* CIL Label */ 
    case_80: /* CIL Label */ 
    case_79: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_77: /* CIL Label */ 
    case_76: /* CIL Label */ 
    case_75: /* CIL Label */ 
    case_74: /* CIL Label */ 
    case_73: /* CIL Label */ 
    case_72: /* CIL Label */ 
    case_71: /* CIL Label */ 
    case_70: /* CIL Label */ 
    case_69: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_67: /* CIL Label */ 
    case_66: /* CIL Label */ 
    case_65: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_47___0: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45___0: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_37: /* CIL Label */ 
#line 516
    goto switch_break___0;
    switch_default___2: /* CIL Label */ 
#line 530
    if (unibyte_locale) {
      {
#line 532
      m = (size_t )1;
#line 533
      tmp___3 = __ctype_b_loc();
#line 533
      printable = (_Bool )(((int const   )*(*tmp___3 + (int )c) & 16384) != 0);
      }
    } else {
      {
#line 538
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 540
      m = (size_t )0;
#line 541
      printable = (_Bool)1;
      }
#line 542
      if (argsize == 0xffffffffffffffffUL) {
        {
#line 543
        argsize = strlen(arg___0);
        }
      }
      {
#line 545
      while (1) {
        while_continue___14: /* CIL Label */ ;
        {
#line 548
        tmp___4 = mbrtowc((wchar_t */* __restrict  */)(& w), (char const   */* __restrict  */)(arg___0 + (i + m)),
                          argsize - (i + m), (mbstate_t */* __restrict  */)(& mbstate));
#line 548
        bytes = tmp___4;
        }
#line 550
        if (bytes == 0UL) {
#line 551
          goto while_break___14;
        } else
#line 552
        if (bytes == 0xffffffffffffffffUL) {
#line 554
          printable = (_Bool)0;
#line 555
          goto while_break___14;
        } else
#line 557
        if (bytes == 0xfffffffffffffffeUL) {
#line 559
          printable = (_Bool)0;
          {
#line 560
          while (1) {
            while_continue___15: /* CIL Label */ ;
#line 560
            if (i + m < argsize) {
#line 560
              if (! *(arg___0 + (i + m))) {
#line 560
                goto while_break___15;
              }
            } else {
#line 560
              goto while_break___15;
            }
#line 561
            m ++;
          }
          while_break___15: /* CIL Label */ ;
          }
#line 562
          goto while_break___14;
        } else {
#line 570
          if (elide_outer_quotes) {
#line 570
            if ((unsigned int )quoting_style == 2U) {
#line 574
              j = (size_t )1;
              {
#line 574
              while (1) {
                while_continue___16: /* CIL Label */ ;
#line 574
                if (! (j < bytes)) {
#line 574
                  goto while_break___16;
                }
                {
#line 578
                if ((int const   )*(arg___0 + ((i + m) + j)) == 124) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg___0 + ((i + m) + j)) == 96) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg___0 + ((i + m) + j)) == 94) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg___0 + ((i + m) + j)) == 92) {
#line 578
                  goto case_124___0;
                }
#line 578
                if ((int const   )*(arg___0 + ((i + m) + j)) == 91) {
#line 578
                  goto case_124___0;
                }
#line 581
                goto switch_default___3;
                case_124___0: /* CIL Label */ 
                case_96___0: /* CIL Label */ 
                case_94___0: /* CIL Label */ 
                case_92___0: /* CIL Label */ 
                case_91___0: /* CIL Label */ 
#line 579
                goto force_outer_quoting_style;
                switch_default___3: /* CIL Label */ 
#line 582
                goto switch_break___3;
                switch_break___3: /* CIL Label */ ;
                }
#line 574
                j ++;
              }
              while_break___16: /* CIL Label */ ;
              }
            }
          }
          {
#line 586
          tmp___5 = iswprint((wint_t )w);
          }
#line 586
          if (! tmp___5) {
#line 587
            printable = (_Bool)0;
          }
#line 588
          m += bytes;
        }
        {
#line 545
        tmp___6 = mbsinit((mbstate_t const   *)(& mbstate));
        }
#line 545
        if (tmp___6) {
#line 545
          goto while_break___14;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 594
    if (1UL < m) {
#line 594
      goto _L___0;
    } else
#line 594
    if (backslash_escapes) {
#line 594
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 598
        ilim = i + m;
        {
#line 600
        while (1) {
          while_continue___17: /* CIL Label */ ;
#line 602
          if (backslash_escapes) {
#line 602
            if (! printable) {
#line 604
              if (elide_outer_quotes) {
#line 605
                goto force_outer_quoting_style;
              }
              {
#line 606
              while (1) {
                while_continue___18: /* CIL Label */ ;
#line 606
                if (len < buffersize) {
#line 606
                  *(buffer___1 + len) = (char )'\\';
                }
#line 606
                len ++;
#line 606
                goto while_break___18;
              }
              while_break___18: /* CIL Label */ ;
              }
              {
#line 607
              while (1) {
                while_continue___19: /* CIL Label */ ;
#line 607
                if (len < buffersize) {
#line 607
                  *(buffer___1 + len) = (char )(48 + ((int )c >> 6));
                }
#line 607
                len ++;
#line 607
                goto while_break___19;
              }
              while_break___19: /* CIL Label */ ;
              }
              {
#line 608
              while (1) {
                while_continue___20: /* CIL Label */ ;
#line 608
                if (len < buffersize) {
#line 608
                  *(buffer___1 + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 608
                len ++;
#line 608
                goto while_break___20;
              }
              while_break___20: /* CIL Label */ ;
              }
#line 609
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 602
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 611
          if (is_right_quote) {
            {
#line 613
            while (1) {
              while_continue___21: /* CIL Label */ ;
#line 613
              if (len < buffersize) {
#line 613
                *(buffer___1 + len) = (char )'\\';
              }
#line 613
              len ++;
#line 613
              goto while_break___21;
            }
            while_break___21: /* CIL Label */ ;
            }
#line 614
            is_right_quote = (_Bool)0;
          }
#line 616
          if (ilim <= i + 1UL) {
#line 617
            goto while_break___17;
          }
          {
#line 618
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 618
            if (len < buffersize) {
#line 618
              *(buffer___1 + len) = (char )c;
            }
#line 618
            len ++;
#line 618
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
#line 619
          i ++;
#line 619
          c = (unsigned char )*(arg___0 + i);
        }
        while_break___17: /* CIL Label */ ;
        }
#line 622
        goto store_c;
      }
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 627
    if (backslash_escapes) {
#line 627
      goto _L___3;
    } else
#line 627
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 627
      if (quote_these_too) {
#line 627
        if (! ((*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) >> (unsigned long )c % (sizeof(int ) * 8UL)) & 1U)) {
#line 627
          goto _L___2;
        }
      } else {
#line 627
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 627
    if (! is_right_quote) {
#line 631
      goto store_c;
    }
    store_escape: 
#line 634
    if (elide_outer_quotes) {
#line 635
      goto force_outer_quoting_style;
    }
    {
#line 636
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 636
      if (len < buffersize) {
#line 636
        *(buffer___1 + len) = (char )'\\';
      }
#line 636
      len ++;
#line 636
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    store_c: 
    {
#line 639
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 639
      if (len < buffersize) {
#line 639
        *(buffer___1 + len) = (char )c;
      }
#line 639
      len ++;
#line 639
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 343
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 642
  if (len == 0UL) {
#line 642
    if ((unsigned int )quoting_style == 2U) {
#line 642
      if (elide_outer_quotes) {
#line 644
        goto force_outer_quoting_style;
      }
    }
  }
#line 646
  if (quote_string) {
#line 646
    if (! elide_outer_quotes) {
      {
#line 647
      while (1) {
        while_continue___25: /* CIL Label */ ;
#line 647
        if (! *quote_string) {
#line 647
          goto while_break___25;
        }
        {
#line 648
        while (1) {
          while_continue___26: /* CIL Label */ ;
#line 648
          if (len < buffersize) {
#line 648
            *(buffer___1 + len) = (char )*quote_string;
          }
#line 648
          len ++;
#line 648
          goto while_break___26;
        }
        while_break___26: /* CIL Label */ ;
        }
#line 647
        quote_string ++;
      }
      while_break___25: /* CIL Label */ ;
      }
    }
  }
#line 650
  if (len < buffersize) {
#line 651
    *(buffer___1 + len) = (char )'\000';
  }
#line 652
  return (len);
  force_outer_quoting_style: 
  {
#line 657
  tmp___8 = quotearg_buffer_restyled(buffer___1, buffersize, arg___0, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
  }
#line 657
  return (tmp___8);
}
}
#line 672 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
size_t quotearg_buffer(char *buffer___1 , size_t buffersize , char const   *arg___0 ,
                       size_t argsize , struct quoting_options  const  *o___0 ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 677
  if (o___0) {
#line 677
    tmp = o___0;
  } else {
#line 677
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 677
  p = tmp;
#line 678
  tmp___0 = __errno_location();
#line 678
  e = *tmp___0;
#line 679
  tmp___1 = quotearg_buffer_restyled(buffer___1, buffersize, arg___0, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 679
  r = tmp___1;
#line 682
  tmp___2 = __errno_location();
#line 682
  *tmp___2 = e;
  }
#line 683
  return (r);
}
}
#line 687 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_alloc(char const   *arg___0 , size_t argsize , struct quoting_options  const  *o___0 ) 
{ 
  char *tmp ;

  {
  {
#line 691
  tmp = quotearg_alloc_mem(arg___0, argsize, (size_t *)((void *)0), o___0);
  }
#line 691
  return (tmp);
}
}
#line 700 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_alloc_mem(char const   *arg___0 , size_t argsize , size_t *size , struct quoting_options  const  *o___0 ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *buf ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 704
  if (o___0) {
#line 704
    tmp = o___0;
  } else {
#line 704
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
  {
#line 704
  p = tmp;
#line 705
  tmp___0 = __errno_location();
#line 705
  e = *tmp___0;
  }
#line 707
  if (size) {
#line 707
    tmp___1 = 0;
  } else {
#line 707
    tmp___1 = 1;
  }
  {
#line 707
  flags = (int )(p->flags | (int const   )tmp___1);
#line 708
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg___0, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 708
  bufsize = tmp___2 + 1UL;
#line 712
  tmp___3 = xcharalloc(bufsize);
#line 712
  buf = tmp___3;
#line 713
  quotearg_buffer_restyled(buf, bufsize, arg___0, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 716
  tmp___4 = __errno_location();
#line 716
  *tmp___4 = e;
  }
#line 717
  if (size) {
#line 718
    *size = bufsize - 1UL;
  }
#line 719
  return (buf);
}
}
#line 731 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static char slot0[256]  ;
#line 732 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static unsigned int nslots  =    1U;
#line 733 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 734 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 736 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 739
  sv = slotvec;
#line 741
  i = 1U;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! (i < nslots)) {
#line 741
      goto while_break;
    }
    {
#line 742
    free((void *)(sv + i)->val);
#line 741
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 743
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
    {
#line 745
    free((void *)(sv + 0)->val);
#line 746
    slotvec0.size = sizeof(slot0);
#line 747
    slotvec0.val = slot0;
    }
  }
#line 749
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
    {
#line 751
    free((void *)sv);
#line 752
    slotvec = & slotvec0;
    }
  }
#line 754
  nslots = 1U;
#line 755
  return;
}
}
#line 765 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg___0 , size_t argsize , struct quoting_options  const  *options___0 ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val___0 ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 769
  tmp = __errno_location();
#line 769
  e = *tmp;
#line 771
  n0 = (unsigned int )n;
#line 772
  sv = slotvec;
  }
#line 774
  if (n < 0) {
    {
#line 775
    abort();
    }
  }
#line 777
  if (nslots <= n0) {
#line 784
    n1 = (size_t )(n0 + 1U);
#line 785
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 787
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 787
      tmp___0 = -1;
    } else {
#line 787
      tmp___0 = -2;
    }
#line 787
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
      {
#line 788
      xalloc_die();
      }
    }
#line 790
    if (preallocated) {
#line 790
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 790
      tmp___1 = sv;
    }
    {
#line 790
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 790
    sv = (struct slotvec *)tmp___2;
#line 790
    slotvec = sv;
    }
#line 791
    if (preallocated) {
#line 792
      *sv = slotvec0;
    }
    {
#line 793
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 794
    nslots = (unsigned int )n1;
    }
  }
  {
#line 798
  size = (sv + n)->size;
#line 799
  val___0 = (sv + n)->val;
#line 801
  flags = (int )(options___0->flags | 1);
#line 802
  tmp___3 = quotearg_buffer_restyled(val___0, size, arg___0, argsize, (enum quoting_style )options___0->style,
                                     flags, (unsigned int const   *)(options___0->quote_these_too),
                                     (char const   *)options___0->left_quote, (char const   *)options___0->right_quote);
#line 802
  qsize = tmp___3;
  }
#line 808
  if (size <= qsize) {
#line 810
    size = qsize + 1UL;
#line 810
    (sv + n)->size = size;
#line 811
    if ((unsigned long )val___0 != (unsigned long )(slot0)) {
      {
#line 812
      free((void *)val___0);
      }
    }
    {
#line 813
    val___0 = xcharalloc(size);
#line 813
    (sv + n)->val = val___0;
#line 814
    quotearg_buffer_restyled(val___0, size, arg___0, argsize, (enum quoting_style )options___0->style,
                             flags, (unsigned int const   *)(options___0->quote_these_too),
                             (char const   *)options___0->left_quote, (char const   *)options___0->right_quote);
    }
  }
  {
#line 820
  tmp___4 = __errno_location();
#line 820
  *tmp___4 = e;
  }
#line 821
  return (val___0);
}
}
#line 825 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_n(int n , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 828
  tmp = quotearg_n_options(n, arg___0, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 828
  return (tmp);
}
}
#line 831 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 834
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& default_quoting_options));
  }
#line 834
  return (tmp);
}
}
#line 837 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 840
  tmp = quotearg_n(0, arg___0);
  }
#line 840
  return (tmp);
}
}
#line 843 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 846
  tmp = quotearg_n_mem(0, arg___0, argsize);
  }
#line 846
  return (tmp);
}
}
#line 849 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg___0 ) 
{ 
  struct quoting_options o___0 ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 852
  tmp = quoting_options_from_style(s);
#line 852
  o___0 = tmp;
#line 853
  tmp___0 = quotearg_n_options(n, arg___0, (size_t )-1, (struct quoting_options  const  *)(& o___0));
  }
#line 853
  return (tmp___0);
}
}
#line 856 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg___0 ,
                           size_t argsize ) 
{ 
  struct quoting_options o___0 ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
  {
#line 860
  tmp = quoting_options_from_style(s);
#line 860
  o___0 = tmp;
#line 861
  tmp___0 = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& o___0));
  }
#line 861
  return (tmp___0);
}
}
#line 864 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 867
  tmp = quotearg_n_style(0, s, arg___0);
  }
#line 867
  return (tmp);
}
}
#line 870 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 873
  tmp = quotearg_n_style_mem(0, s, arg___0, argsize);
  }
#line 873
  return (tmp);
}
}
#line 876 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_char_mem(char const   *arg___0 , size_t argsize , char ch ) 
{ 
  struct quoting_options options___0 ;
  char *tmp ;

  {
  {
#line 880
  options___0 = default_quoting_options;
#line 881
  set_char_quoting(& options___0, ch, 1);
#line 882
  tmp = quotearg_n_options(0, arg___0, argsize, (struct quoting_options  const  *)(& options___0));
  }
#line 882
  return (tmp);
}
}
#line 885 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_char(char const   *arg___0 , char ch ) 
{ 
  char *tmp ;

  {
  {
#line 888
  tmp = quotearg_char_mem(arg___0, (size_t )-1, ch);
  }
#line 888
  return (tmp);
}
}
#line 891 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_colon(char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 894
  tmp = quotearg_char(arg___0, (char )':');
  }
#line 894
  return (tmp);
}
}
#line 897 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_colon_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 900
  tmp = quotearg_char_mem(arg___0, argsize, (char )':');
  }
#line 900
  return (tmp);
}
}
#line 903 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 907
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg___0, (size_t )-1);
  }
#line 907
  return (tmp);
}
}
#line 911 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg___0 , size_t argsize ) 
{ 
  struct quoting_options o___0 ;
  char *tmp ;

  {
  {
#line 916
  o___0 = default_quoting_options;
#line 917
  set_custom_quoting(& o___0, left_quote, right_quote);
#line 918
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& o___0));
  }
#line 918
  return (tmp);
}
}
#line 921 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg___0 ) 
{ 
  char *tmp ;

  {
  {
#line 925
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg___0);
  }
#line 925
  return (tmp);
}
}
#line 928 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg___0 ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 932
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg___0, argsize);
  }
#line 932
  return (tmp);
}
}
#line 938 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
struct quoting_options quote_quoting_options  =    {(enum quoting_style )6, 0, {0U}, (char const   *)((void *)0), (char const   *)((void *)0)};
#line 946 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char const   *quote_n_mem(int n , char const   *arg___0 , size_t argsize ) 
{ 
  char *tmp ;

  {
  {
#line 949
  tmp = quotearg_n_options(n, arg___0, argsize, (struct quoting_options  const  *)(& quote_quoting_options));
  }
#line 949
  return ((char const   *)tmp);
}
}
#line 952 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char const   *quote_mem(char const   *arg___0 , size_t argsize ) 
{ 
  char const   *tmp ;

  {
  {
#line 955
  tmp = quote_n_mem(0, arg___0, argsize);
  }
#line 955
  return (tmp);
}
}
#line 958 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char const   *quote_n(int n , char const   *arg___0 ) 
{ 
  char const   *tmp ;

  {
  {
#line 961
  tmp = quote_n_mem(n, arg___0, (size_t )-1);
  }
#line 961
  return (tmp);
}
}
#line 964 "/home/khheo/project/benchmark/tar-1.29/gnu/quotearg.c"
char const   *quote(char const   *arg___0 ) 
{ 
  char const   *tmp ;

  {
  {
#line 967
  tmp = quote_n(0, arg___0);
  }
#line 967
  return (tmp);
}
}
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/progname.h"
char const   *program_name ;
#line 37
void set_program_name(char const   *argv0 ) ;
#line 45 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 46
extern char *program_invocation_short_name ;
#line 137 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 626
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 139 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 252
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 51
  if ((unsigned long )argv0 == (unsigned long )((void *)0)) {
    {
#line 54
    fputs((char const   */* __restrict  */)"A NULL argv[0] was passed through an exec system call.\n",
          (FILE */* __restrict  */)stderr);
#line 56
    abort();
    }
  }
  {
#line 59
  tmp = strrchr(argv0, '/');
#line 59
  slash = (char const   *)tmp;
  }
#line 60
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 60
    base = slash + 1;
  } else {
#line 60
    base = argv0;
  }
#line 61
  if (base - argv0 >= 7L) {
    {
#line 61
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
    }
#line 61
    if (tmp___1 == 0) {
      {
#line 63
      argv0 = base;
#line 64
      tmp___0 = strncmp(base, "lt-", (size_t )3);
      }
#line 64
      if (tmp___0 == 0) {
#line 66
        argv0 = base + 3;
#line 70
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 84
  program_name = argv0;
#line 90
  program_invocation_name = (char *)argv0;
#line 92
  return;
}
}
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/priv-set.h"
#pragma GCC diagnostic push
#line 23
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 23
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 64
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/xsize.h"
#pragma GCC diagnostic push
#line 33
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 33
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 115
#pragma GCC diagnostic pop
#line 82 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  char c ;
  char const   *tmp ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___2 ;
  size_t __attribute__((__pure__))  tmp___3 ;
  size_t tmp___4 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  size_t tmp___9 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___10 ;
  size_t __attribute__((__pure__))  tmp___11 ;
  size_t tmp___12 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  size_t tmp___17 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___18 ;
  size_t tmp___19 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  size_t tmp___24 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___25 ;
  void *tmp___26 ;
  void *tmp___27 ;
  int *tmp___28 ;
  int *tmp___29 ;

  {
#line 85
  cp = format;
#line 86
  arg_posn = (size_t )0;
#line 89
  max_width_length = (size_t )0;
#line 90
  max_precision_length = (size_t )0;
#line 92
  d->count = (size_t )0;
#line 93
  d_allocated = (size_t )7;
#line 94
  d->dir = d->direct_alloc_dir;
#line 96
  a->count = (size_t )0;
#line 97
  a_allocated = (size_t )7;
#line 98
  a->arg = a->direct_alloc_arg;
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((int const   )*cp != 0)) {
#line 134
      goto while_break;
    }
#line 136
    tmp = cp;
#line 136
    cp ++;
#line 136
    c = (char )*tmp;
#line 137
    if ((int )c == 37) {
#line 139
      arg_index = ~ ((size_t )0);
#line 140
      dp = d->dir + d->count;
#line 143
      dp->dir_start = cp - 1;
#line 144
      dp->flags = 0;
#line 145
      dp->width_start = (char const   *)((void *)0);
#line 146
      dp->width_end = (char const   *)((void *)0);
#line 147
      dp->width_arg_index = ~ ((size_t )0);
#line 148
      dp->precision_start = (char const   *)((void *)0);
#line 149
      dp->precision_end = (char const   *)((void *)0);
#line 150
      dp->precision_arg_index = ~ ((size_t )0);
#line 151
      dp->arg_index = ~ ((size_t )0);
#line 154
      if ((int const   )*cp >= 48) {
#line 154
        if ((int const   )*cp <= 57) {
#line 158
          np = cp;
          {
#line 158
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 158
            if ((int const   )*np >= 48) {
#line 158
              if (! ((int const   )*np <= 57)) {
#line 158
                goto while_break___0;
              }
            } else {
#line 158
              goto while_break___0;
            }
#line 158
            np ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 160
          if ((int const   )*np == 36) {
#line 162
            n = (size_t )0;
#line 164
            np = cp;
            {
#line 164
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 164
              if ((int const   )*np >= 48) {
#line 164
                if (! ((int const   )*np <= 57)) {
#line 164
                  goto while_break___1;
                }
              } else {
#line 164
                goto while_break___1;
              }
#line 165
              if (n <= 1844674407370955161UL) {
#line 165
                tmp___0 = n * 10UL;
              } else {
#line 165
                tmp___0 = 0xffffffffffffffffUL;
              }
              {
#line 165
              tmp___1 = xsum(tmp___0, (size_t )((int const   )*np - 48));
#line 165
              n = (size_t )tmp___1;
#line 164
              np ++;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
#line 166
            if (n == 0UL) {
#line 168
              goto error;
            }
#line 169
            if (n == 0xffffffffffffffffUL) {
#line 171
              goto error;
            }
#line 172
            arg_index = n - 1UL;
#line 173
            cp = np + 1;
          }
        }
      }
      {
#line 178
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 180
        if ((int const   )*cp == 39) {
#line 182
          dp->flags |= 1;
#line 183
          cp ++;
        } else
#line 185
        if ((int const   )*cp == 45) {
#line 187
          dp->flags |= 2;
#line 188
          cp ++;
        } else
#line 190
        if ((int const   )*cp == 43) {
#line 192
          dp->flags |= 4;
#line 193
          cp ++;
        } else
#line 195
        if ((int const   )*cp == 32) {
#line 197
          dp->flags |= 8;
#line 198
          cp ++;
        } else
#line 200
        if ((int const   )*cp == 35) {
#line 202
          dp->flags |= 16;
#line 203
          cp ++;
        } else
#line 205
        if ((int const   )*cp == 48) {
#line 207
          dp->flags |= 32;
#line 208
          cp ++;
        } else
#line 211
        if ((int const   )*cp == 73) {
#line 213
          dp->flags |= 64;
#line 214
          cp ++;
        } else {
#line 218
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 222
      if ((int const   )*cp == 42) {
#line 224
        dp->width_start = cp;
#line 225
        cp ++;
#line 226
        dp->width_end = cp;
#line 227
        if (max_width_length < 1UL) {
#line 228
          max_width_length = (size_t )1;
        }
#line 231
        if ((int const   )*cp >= 48) {
#line 231
          if ((int const   )*cp <= 57) {
#line 235
            np___0 = cp;
            {
#line 235
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 235
              if ((int const   )*np___0 >= 48) {
#line 235
                if (! ((int const   )*np___0 <= 57)) {
#line 235
                  goto while_break___3;
                }
              } else {
#line 235
                goto while_break___3;
              }
#line 235
              np___0 ++;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 237
            if ((int const   )*np___0 == 36) {
#line 239
              n___0 = (size_t )0;
#line 241
              np___0 = cp;
              {
#line 241
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 241
                if ((int const   )*np___0 >= 48) {
#line 241
                  if (! ((int const   )*np___0 <= 57)) {
#line 241
                    goto while_break___4;
                  }
                } else {
#line 241
                  goto while_break___4;
                }
#line 242
                if (n___0 <= 1844674407370955161UL) {
#line 242
                  tmp___2 = n___0 * 10UL;
                } else {
#line 242
                  tmp___2 = 0xffffffffffffffffUL;
                }
                {
#line 242
                tmp___3 = xsum(tmp___2, (size_t )((int const   )*np___0 - 48));
#line 242
                n___0 = (size_t )tmp___3;
#line 241
                np___0 ++;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 243
              if (n___0 == 0UL) {
#line 245
                goto error;
              }
#line 246
              if (n___0 == 0xffffffffffffffffUL) {
#line 248
                goto error;
              }
#line 249
              dp->width_arg_index = n___0 - 1UL;
#line 250
              cp = np___0 + 1;
            }
          }
        }
#line 253
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 255
          tmp___4 = arg_posn;
#line 255
          arg_posn ++;
#line 255
          dp->width_arg_index = tmp___4;
#line 256
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 258
            goto error;
          }
        }
#line 260
        n___1 = dp->width_arg_index;
#line 260
        if (n___1 >= a_allocated) {
#line 260
          if (a_allocated <= 9223372036854775807UL) {
#line 260
            a_allocated *= 2UL;
          } else {
#line 260
            a_allocated = 0xffffffffffffffffUL;
          }
#line 260
          if (a_allocated <= n___1) {
            {
#line 260
            tmp___5 = xsum(n___1, (size_t )1);
#line 260
            a_allocated = (size_t )tmp___5;
            }
          }
#line 260
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 260
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 260
            memory_size = 0xffffffffffffffffUL;
          }
#line 260
          if (memory_size == 0xffffffffffffffffUL) {
#line 260
            goto out_of_memory;
          }
#line 260
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 260
            tmp___6 = realloc((void *)a->arg, memory_size);
#line 260
            tmp___8 = tmp___6;
            }
          } else {
            {
#line 260
            tmp___7 = malloc(memory_size);
#line 260
            tmp___8 = tmp___7;
            }
          }
#line 260
          memory = (argument *)tmp___8;
#line 260
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 260
            goto out_of_memory;
          }
#line 260
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 260
            memcpy((void */* __restrict  */)memory, (void const   */* __restrict  */)a->arg,
                   a->count * sizeof(argument ));
            }
          }
#line 260
          a->arg = memory;
        }
        {
#line 260
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 260
          if (! (a->count <= n___1)) {
#line 260
            goto while_break___5;
          }
#line 260
          tmp___9 = a->count;
#line 260
          (a->count) ++;
#line 260
          (a->arg + tmp___9)->type = (arg_type )0;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 260
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 260
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 260
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 260
          goto error;
        }
      } else
#line 262
      if ((int const   )*cp >= 48) {
#line 262
        if ((int const   )*cp <= 57) {
#line 266
          dp->width_start = cp;
          {
#line 267
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 267
            if ((int const   )*cp >= 48) {
#line 267
              if (! ((int const   )*cp <= 57)) {
#line 267
                goto while_break___6;
              }
            } else {
#line 267
              goto while_break___6;
            }
#line 267
            cp ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 269
          dp->width_end = cp;
#line 270
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 271
          if (max_width_length < width_length) {
#line 272
            max_width_length = width_length;
          }
        }
      }
#line 276
      if ((int const   )*cp == 46) {
#line 278
        cp ++;
#line 279
        if ((int const   )*cp == 42) {
#line 281
          dp->precision_start = cp - 1;
#line 282
          cp ++;
#line 283
          dp->precision_end = cp;
#line 284
          if (max_precision_length < 2UL) {
#line 285
            max_precision_length = (size_t )2;
          }
#line 288
          if ((int const   )*cp >= 48) {
#line 288
            if ((int const   )*cp <= 57) {
#line 292
              np___1 = cp;
              {
#line 292
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 292
                if ((int const   )*np___1 >= 48) {
#line 292
                  if (! ((int const   )*np___1 <= 57)) {
#line 292
                    goto while_break___7;
                  }
                } else {
#line 292
                  goto while_break___7;
                }
#line 292
                np___1 ++;
              }
              while_break___7: /* CIL Label */ ;
              }
#line 294
              if ((int const   )*np___1 == 36) {
#line 296
                n___2 = (size_t )0;
#line 298
                np___1 = cp;
                {
#line 298
                while (1) {
                  while_continue___8: /* CIL Label */ ;
#line 298
                  if ((int const   )*np___1 >= 48) {
#line 298
                    if (! ((int const   )*np___1 <= 57)) {
#line 298
                      goto while_break___8;
                    }
                  } else {
#line 298
                    goto while_break___8;
                  }
#line 299
                  if (n___2 <= 1844674407370955161UL) {
#line 299
                    tmp___10 = n___2 * 10UL;
                  } else {
#line 299
                    tmp___10 = 0xffffffffffffffffUL;
                  }
                  {
#line 299
                  tmp___11 = xsum(tmp___10, (size_t )((int const   )*np___1 - 48));
#line 299
                  n___2 = (size_t )tmp___11;
#line 298
                  np___1 ++;
                  }
                }
                while_break___8: /* CIL Label */ ;
                }
#line 300
                if (n___2 == 0UL) {
#line 302
                  goto error;
                }
#line 303
                if (n___2 == 0xffffffffffffffffUL) {
#line 306
                  goto error;
                }
#line 307
                dp->precision_arg_index = n___2 - 1UL;
#line 308
                cp = np___1 + 1;
              }
            }
          }
#line 311
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 313
            tmp___12 = arg_posn;
#line 313
            arg_posn ++;
#line 313
            dp->precision_arg_index = tmp___12;
#line 314
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 316
              goto error;
            }
          }
#line 318
          n___3 = dp->precision_arg_index;
#line 318
          if (n___3 >= a_allocated) {
#line 318
            if (a_allocated <= 9223372036854775807UL) {
#line 318
              a_allocated *= 2UL;
            } else {
#line 318
              a_allocated = 0xffffffffffffffffUL;
            }
#line 318
            if (a_allocated <= n___3) {
              {
#line 318
              tmp___13 = xsum(n___3, (size_t )1);
#line 318
              a_allocated = (size_t )tmp___13;
              }
            }
#line 318
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 318
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 318
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 318
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 318
              goto out_of_memory;
            }
#line 318
            if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
              {
#line 318
              tmp___14 = realloc((void *)a->arg, memory_size___0);
#line 318
              tmp___16 = tmp___14;
              }
            } else {
              {
#line 318
              tmp___15 = malloc(memory_size___0);
#line 318
              tmp___16 = tmp___15;
              }
            }
#line 318
            memory___0 = (argument *)tmp___16;
#line 318
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 318
              goto out_of_memory;
            }
#line 318
            if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
              {
#line 318
              memcpy((void */* __restrict  */)memory___0, (void const   */* __restrict  */)a->arg,
                     a->count * sizeof(argument ));
              }
            }
#line 318
            a->arg = memory___0;
          }
          {
#line 318
          while (1) {
            while_continue___9: /* CIL Label */ ;
#line 318
            if (! (a->count <= n___3)) {
#line 318
              goto while_break___9;
            }
#line 318
            tmp___17 = a->count;
#line 318
            (a->count) ++;
#line 318
            (a->arg + tmp___17)->type = (arg_type )0;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 318
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 318
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 318
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 318
            goto error;
          }
        } else {
#line 324
          dp->precision_start = cp - 1;
          {
#line 325
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 325
            if ((int const   )*cp >= 48) {
#line 325
              if (! ((int const   )*cp <= 57)) {
#line 325
                goto while_break___10;
              }
            } else {
#line 325
              goto while_break___10;
            }
#line 325
            cp ++;
          }
          while_break___10: /* CIL Label */ ;
          }
#line 327
          dp->precision_end = cp;
#line 328
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 329
          if (max_precision_length < precision_length) {
#line 330
            max_precision_length = precision_length;
          }
        }
      }
#line 339
      flags = 0;
      {
#line 341
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 343
        if ((int const   )*cp == 104) {
#line 345
          flags |= 1 << (flags & 1);
#line 346
          cp ++;
        } else
#line 348
        if ((int const   )*cp == 76) {
#line 350
          flags |= 4;
#line 351
          cp ++;
        } else
#line 353
        if ((int const   )*cp == 108) {
#line 355
          flags += 8;
#line 356
          cp ++;
        } else
#line 358
        if ((int const   )*cp == 106) {
#line 360
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 363
            flags += 16;
          } else
#line 365
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 368
            flags += 8;
          }
#line 370
          cp ++;
        } else
#line 372
        if ((int const   )*cp == 122) {
#line 372
          goto _L;
        } else
#line 372
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 377
          if (sizeof(size_t ) > sizeof(long )) {
#line 380
            flags += 16;
          } else
#line 382
          if (sizeof(size_t ) > sizeof(int )) {
#line 385
            flags += 8;
          }
#line 387
          cp ++;
        } else
#line 389
        if ((int const   )*cp == 116) {
#line 391
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 394
            flags += 16;
          } else
#line 396
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 399
            flags += 8;
          }
#line 401
          cp ++;
        } else {
#line 442
          goto while_break___11;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
#line 446
      tmp___18 = cp;
#line 446
      cp ++;
#line 446
      c = (char )*tmp___18;
      {
#line 449
      if ((int )c == 105) {
#line 449
        goto case_105;
      }
#line 449
      if ((int )c == 100) {
#line 449
        goto case_105;
      }
#line 467
      if ((int )c == 88) {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 120) {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 117) {
#line 467
        goto case_88;
      }
#line 467
      if ((int )c == 111) {
#line 467
        goto case_88;
      }
#line 486
      if ((int )c == 65) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 97) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 71) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 103) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 69) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 101) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 70) {
#line 486
        goto case_65;
      }
#line 486
      if ((int )c == 102) {
#line 486
        goto case_65;
      }
#line 492
      if ((int )c == 99) {
#line 492
        goto case_99;
      }
#line 503
      if ((int )c == 67) {
#line 503
        goto case_67;
      }
#line 508
      if ((int )c == 115) {
#line 508
        goto case_115;
      }
#line 519
      if ((int )c == 83) {
#line 519
        goto case_83;
      }
#line 524
      if ((int )c == 112) {
#line 524
        goto case_112;
      }
#line 527
      if ((int )c == 110) {
#line 527
        goto case_110;
      }
#line 556
      if ((int )c == 37) {
#line 556
        goto case_37;
      }
#line 559
      goto switch_default;
      case_105: /* CIL Label */ 
      case_100: /* CIL Label */ 
#line 452
      if (flags >= 16) {
#line 453
        type = (arg_type )9;
      } else
#line 452
      if (flags & 4) {
#line 453
        type = (arg_type )9;
      } else
#line 458
      if (flags >= 8) {
#line 459
        type = (arg_type )7;
      } else
#line 460
      if (flags & 2) {
#line 461
        type = (arg_type )1;
      } else
#line 462
      if (flags & 1) {
#line 463
        type = (arg_type )3;
      } else {
#line 465
        type = (arg_type )5;
      }
#line 466
      goto switch_break;
      case_88: /* CIL Label */ 
      case_120: /* CIL Label */ 
      case_117: /* CIL Label */ 
      case_111: /* CIL Label */ 
#line 470
      if (flags >= 16) {
#line 471
        type = (arg_type )10;
      } else
#line 470
      if (flags & 4) {
#line 471
        type = (arg_type )10;
      } else
#line 476
      if (flags >= 8) {
#line 477
        type = (arg_type )8;
      } else
#line 478
      if (flags & 2) {
#line 479
        type = (arg_type )2;
      } else
#line 480
      if (flags & 1) {
#line 481
        type = (arg_type )4;
      } else {
#line 483
        type = (arg_type )6;
      }
#line 484
      goto switch_break;
      case_65: /* CIL Label */ 
      case_97: /* CIL Label */ 
      case_71: /* CIL Label */ 
      case_103: /* CIL Label */ 
      case_69: /* CIL Label */ 
      case_101: /* CIL Label */ 
      case_70: /* CIL Label */ 
      case_102: /* CIL Label */ 
#line 487
      if (flags >= 16) {
#line 488
        type = (arg_type )12;
      } else
#line 487
      if (flags & 4) {
#line 488
        type = (arg_type )12;
      } else {
#line 490
        type = (arg_type )11;
      }
#line 491
      goto switch_break;
      case_99: /* CIL Label */ 
#line 493
      if (flags >= 8) {
#line 495
        type = (arg_type )14;
      } else {
#line 500
        type = (arg_type )13;
      }
#line 501
      goto switch_break;
      case_67: /* CIL Label */ 
#line 504
      type = (arg_type )14;
#line 505
      c = (char )'c';
#line 506
      goto switch_break;
      case_115: /* CIL Label */ 
#line 509
      if (flags >= 8) {
#line 511
        type = (arg_type )16;
      } else {
#line 516
        type = (arg_type )15;
      }
#line 517
      goto switch_break;
      case_83: /* CIL Label */ 
#line 520
      type = (arg_type )16;
#line 521
      c = (char )'s';
#line 522
      goto switch_break;
      case_112: /* CIL Label */ 
#line 525
      type = (arg_type )17;
#line 526
      goto switch_break;
      case_110: /* CIL Label */ 
#line 530
      if (flags >= 16) {
#line 531
        type = (arg_type )22;
      } else
#line 530
      if (flags & 4) {
#line 531
        type = (arg_type )22;
      } else
#line 536
      if (flags >= 8) {
#line 537
        type = (arg_type )21;
      } else
#line 538
      if (flags & 2) {
#line 539
        type = (arg_type )18;
      } else
#line 540
      if (flags & 1) {
#line 541
        type = (arg_type )19;
      } else {
#line 543
        type = (arg_type )20;
      }
#line 544
      goto switch_break;
      case_37: /* CIL Label */ 
#line 557
      type = (arg_type )0;
#line 558
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 561
      goto error;
      switch_break: /* CIL Label */ ;
      }
#line 565
      if ((unsigned int )type != 0U) {
#line 567
        dp->arg_index = arg_index;
#line 568
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 570
          tmp___19 = arg_posn;
#line 570
          arg_posn ++;
#line 570
          dp->arg_index = tmp___19;
#line 571
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 573
            goto error;
          }
        }
#line 575
        n___4 = dp->arg_index;
#line 575
        if (n___4 >= a_allocated) {
#line 575
          if (a_allocated <= 9223372036854775807UL) {
#line 575
            a_allocated *= 2UL;
          } else {
#line 575
            a_allocated = 0xffffffffffffffffUL;
          }
#line 575
          if (a_allocated <= n___4) {
            {
#line 575
            tmp___20 = xsum(n___4, (size_t )1);
#line 575
            a_allocated = (size_t )tmp___20;
            }
          }
#line 575
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 575
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 575
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 575
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 575
            goto out_of_memory;
          }
#line 575
          if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
            {
#line 575
            tmp___21 = realloc((void *)a->arg, memory_size___1);
#line 575
            tmp___23 = tmp___21;
            }
          } else {
            {
#line 575
            tmp___22 = malloc(memory_size___1);
#line 575
            tmp___23 = tmp___22;
            }
          }
#line 575
          memory___1 = (argument *)tmp___23;
#line 575
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 575
            goto out_of_memory;
          }
#line 575
          if ((unsigned long )a->arg == (unsigned long )(a->direct_alloc_arg)) {
            {
#line 575
            memcpy((void */* __restrict  */)memory___1, (void const   */* __restrict  */)a->arg,
                   a->count * sizeof(argument ));
            }
          }
#line 575
          a->arg = memory___1;
        }
        {
#line 575
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 575
          if (! (a->count <= n___4)) {
#line 575
            goto while_break___12;
          }
#line 575
          tmp___24 = a->count;
#line 575
          (a->count) ++;
#line 575
          (a->arg + tmp___24)->type = (arg_type )0;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 575
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 575
          (a->arg + n___4)->type = type;
        } else
#line 575
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 575
          goto error;
        }
      }
#line 577
      dp->conversion = c;
#line 578
      dp->dir_end = cp;
#line 581
      (d->count) ++;
#line 582
      if (d->count >= d_allocated) {
#line 587
        if (d_allocated <= 9223372036854775807UL) {
#line 587
          d_allocated *= 2UL;
        } else {
#line 587
          d_allocated = 0xffffffffffffffffUL;
        }
#line 588
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 588
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 588
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 589
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 591
          goto out_of_memory;
        }
#line 592
        if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
          {
#line 592
          tmp___25 = realloc((void *)d->dir, memory_size___2);
#line 592
          tmp___27 = tmp___25;
          }
        } else {
          {
#line 592
          tmp___26 = malloc(memory_size___2);
#line 592
          tmp___27 = tmp___26;
          }
        }
#line 592
        memory___2 = (char_directive *)tmp___27;
#line 595
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 597
          goto out_of_memory;
        }
#line 598
        if ((unsigned long )d->dir == (unsigned long )(d->direct_alloc_dir)) {
          {
#line 599
          memcpy((void */* __restrict  */)memory___2, (void const   */* __restrict  */)d->dir,
                 d->count * sizeof(char_directive ));
          }
        }
#line 600
        d->dir = memory___2;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  (d->dir + d->count)->dir_start = cp;
#line 613
  d->max_width_length = max_width_length;
#line 614
  d->max_precision_length = max_precision_length;
#line 615
  return (0);
  error: 
#line 618
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 619
    free((void *)a->arg);
    }
  }
#line 620
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 621
    free((void *)d->dir);
    }
  }
  {
#line 622
  tmp___28 = __errno_location();
#line 622
  *tmp___28 = 22;
  }
#line 623
  return (-1);
  out_of_memory: 
#line 626
  if ((unsigned long )a->arg != (unsigned long )(a->direct_alloc_arg)) {
    {
#line 627
    free((void *)a->arg);
    }
  }
#line 628
  if ((unsigned long )d->dir != (unsigned long )(d->direct_alloc_dir)) {
    {
#line 629
    free((void *)d->dir);
    }
  }
  {
#line 630
  tmp___29 = __errno_location();
#line 630
  *tmp___29 = 12;
  }
#line 631
  return (-1);
}
}
#line 112 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/printf-args.c"
int printf_fetchargs(va_list args___0 , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;

  {
#line 41
  i = (size_t )0;
#line 41
  ap = a->arg + 0;
  {
#line 41
  while (1) {
    while_continue: /* CIL Label */ ;
#line 41
    if (! (i < a->count)) {
#line 41
      goto while_break;
    }
    {
#line 44
    if ((unsigned int )ap->type == 1U) {
#line 44
      goto case_1;
    }
#line 47
    if ((unsigned int )ap->type == 2U) {
#line 47
      goto case_2;
    }
#line 50
    if ((unsigned int )ap->type == 3U) {
#line 50
      goto case_3;
    }
#line 53
    if ((unsigned int )ap->type == 4U) {
#line 53
      goto case_4;
    }
#line 56
    if ((unsigned int )ap->type == 5U) {
#line 56
      goto case_5;
    }
#line 59
    if ((unsigned int )ap->type == 6U) {
#line 59
      goto case_6;
    }
#line 62
    if ((unsigned int )ap->type == 7U) {
#line 62
      goto case_7;
    }
#line 65
    if ((unsigned int )ap->type == 8U) {
#line 65
      goto case_8;
    }
#line 69
    if ((unsigned int )ap->type == 9U) {
#line 69
      goto case_9;
    }
#line 72
    if ((unsigned int )ap->type == 10U) {
#line 72
      goto case_10;
    }
#line 76
    if ((unsigned int )ap->type == 11U) {
#line 76
      goto case_11;
    }
#line 79
    if ((unsigned int )ap->type == 12U) {
#line 79
      goto case_12;
    }
#line 82
    if ((unsigned int )ap->type == 13U) {
#line 82
      goto case_13;
    }
#line 86
    if ((unsigned int )ap->type == 14U) {
#line 86
      goto case_14;
    }
#line 96
    if ((unsigned int )ap->type == 15U) {
#line 96
      goto case_15;
    }
#line 105
    if ((unsigned int )ap->type == 16U) {
#line 105
      goto case_16;
    }
#line 123
    if ((unsigned int )ap->type == 17U) {
#line 123
      goto case_17;
    }
#line 126
    if ((unsigned int )ap->type == 18U) {
#line 126
      goto case_18;
    }
#line 129
    if ((unsigned int )ap->type == 19U) {
#line 129
      goto case_19;
    }
#line 132
    if ((unsigned int )ap->type == 20U) {
#line 132
      goto case_20;
    }
#line 135
    if ((unsigned int )ap->type == 21U) {
#line 135
      goto case_21;
    }
#line 139
    if ((unsigned int )ap->type == 22U) {
#line 139
      goto case_22;
    }
#line 182
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 45
    tmp = __builtin_va_arg(args___0, int );
#line 45
    ap->a.a_schar = tmp;
    }
#line 46
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 48
    tmp___0 = __builtin_va_arg(args___0, int );
#line 48
    ap->a.a_uchar = tmp___0;
    }
#line 49
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 51
    tmp___1 = __builtin_va_arg(args___0, int );
#line 51
    ap->a.a_short = tmp___1;
    }
#line 52
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 54
    tmp___2 = __builtin_va_arg(args___0, int );
#line 54
    ap->a.a_ushort = tmp___2;
    }
#line 55
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 57
    tmp___3 = __builtin_va_arg(args___0, int );
#line 57
    ap->a.a_int = tmp___3;
    }
#line 58
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 60
    tmp___4 = __builtin_va_arg(args___0, unsigned int );
#line 60
    ap->a.a_uint = tmp___4;
    }
#line 61
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 63
    tmp___5 = __builtin_va_arg(args___0, long );
#line 63
    ap->a.a_longint = tmp___5;
    }
#line 64
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 66
    tmp___6 = __builtin_va_arg(args___0, unsigned long );
#line 66
    ap->a.a_ulongint = tmp___6;
    }
#line 67
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 70
    tmp___7 = __builtin_va_arg(args___0, long long );
#line 70
    ap->a.a_longlongint = tmp___7;
    }
#line 71
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 73
    tmp___8 = __builtin_va_arg(args___0, unsigned long long );
#line 73
    ap->a.a_ulonglongint = tmp___8;
    }
#line 74
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 77
    tmp___9 = __builtin_va_arg(args___0, double );
#line 77
    ap->a.a_double = tmp___9;
    }
#line 78
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 80
    tmp___10 = __builtin_va_arg(args___0, long double );
#line 80
    ap->a.a_longdouble = tmp___10;
    }
#line 81
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 83
    tmp___11 = __builtin_va_arg(args___0, int );
#line 83
    ap->a.a_char = tmp___11;
    }
#line 84
    goto switch_break;
    case_14: /* CIL Label */ 
#line 90
    if (sizeof(wint_t ) < sizeof(int )) {
      {
#line 90
      tmp___13 = __builtin_va_arg(args___0, int );
#line 90
      ap->a.a_wide_char = (wint_t )tmp___13;
      }
    } else {
      {
#line 90
      tmp___15 = __builtin_va_arg(args___0, wint_t );
#line 90
      ap->a.a_wide_char = tmp___15;
      }
    }
#line 94
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 97
    tmp___16 = __builtin_va_arg(args___0, char const   *);
#line 97
    ap->a.a_string = tmp___16;
    }
#line 101
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 102
      ap->a.a_string = "(NULL)";
    }
#line 103
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 106
    tmp___17 = __builtin_va_arg(args___0, wchar_t const   *);
#line 106
    ap->a.a_wide_string = tmp___17;
    }
#line 110
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 119
      ap->a.a_wide_string = wide_null_string;
    }
#line 121
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 124
    tmp___18 = __builtin_va_arg(args___0, void *);
#line 124
    ap->a.a_pointer = tmp___18;
    }
#line 125
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 127
    tmp___19 = __builtin_va_arg(args___0, signed char *);
#line 127
    ap->a.a_count_schar_pointer = tmp___19;
    }
#line 128
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 130
    tmp___20 = __builtin_va_arg(args___0, short *);
#line 130
    ap->a.a_count_short_pointer = tmp___20;
    }
#line 131
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 133
    tmp___21 = __builtin_va_arg(args___0, int *);
#line 133
    ap->a.a_count_int_pointer = tmp___21;
    }
#line 134
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 136
    tmp___22 = __builtin_va_arg(args___0, long *);
#line 136
    ap->a.a_count_longint_pointer = tmp___22;
    }
#line 137
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 140
    tmp___23 = __builtin_va_arg(args___0, long long *);
#line 140
    ap->a.a_count_longlongint_pointer = tmp___23;
    }
#line 141
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 184
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 41
    i ++;
#line 41
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return (0);
}
}
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 34
  tmp___1 = pipe(fd);
  }
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
    {
#line 37
    while (1) {
      while_continue: /* CIL Label */ ;
#line 37
      if (! (i < 2)) {
#line 37
        goto while_break;
      }
      {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
      }
#line 40
      if (*(fd + i) < 0) {
        {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
        }
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 123 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/parse-datetime.h"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 123 "./c-ctype.h"
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 131
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 136
int c_toupper(int c )  __attribute__((__const__)) ;
#line 320 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 837 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 119 "./parse-datetime.y"
static unsigned char to_uchar(char ch ) 
{ 


  {
#line 119
  return ((unsigned char )ch);
}
}
#line 217
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 218
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 219
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 224 "./parse-datetime.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 227
  if (pc->dates_seen) {
#line 227
    if (! pc->year.digits) {
#line 227
      if (! pc->rels_seen) {
#line 227
        if (pc->times_seen) {
#line 229
          pc->year = text_int;
        } else
#line 227
        if (2UL < text_int.digits) {
#line 229
          pc->year = text_int;
        } else {
#line 227
          goto _L___1;
        }
      } else {
#line 227
        goto _L___1;
      }
    } else {
#line 227
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 232
  if (4UL < text_int.digits) {
#line 234
    (pc->dates_seen) ++;
#line 235
    pc->day = text_int.value % 100L;
#line 236
    pc->month = (text_int.value / 100L) % 100L;
#line 237
    pc->year.value = text_int.value / 10000L;
#line 238
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 242
    (pc->times_seen) ++;
#line 243
    if (text_int.digits <= 2UL) {
#line 245
      pc->hour = text_int.value;
#line 246
      pc->minutes = 0L;
    } else {
#line 250
      pc->hour = text_int.value / 100L;
#line 251
      pc->minutes = text_int.value % 100L;
    }
#line 253
    pc->seconds.tv_sec = (__time_t )0;
#line 254
    pc->seconds.tv_nsec = (__syscall_slong_t )0;
#line 255
    pc->meridian = 2;
  }
#line 258
  return;
}
}
#line 261 "./parse-datetime.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 264
  pc->rel.ns += (long )factor * rel.ns;
#line 265
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
#line 266
  pc->rel.minutes += (long )factor * rel.minutes;
#line 267
  pc->rel.hour += (long )factor * rel.hour;
#line 268
  pc->rel.day += (long )factor * rel.day;
#line 269
  pc->rel.month += (long )factor * rel.month;
#line 270
  pc->rel.year += (long )factor * rel.year;
#line 271
  pc->rels_seen = (_Bool)1;
#line 272
  return;
}
}
#line 275 "./parse-datetime.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 


  {
#line 279
  pc->hour = hour;
#line 280
  pc->minutes = minutes;
#line 281
  pc->seconds.tv_sec = sec;
#line 282
  pc->seconds.tv_nsec = nsec;
#line 283
  return;
}
}
#line 705 "parse-datetime.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 705 "parse-datetime.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )25,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 831 "parse-datetime.c"
static yytype_uint8 const   yyr1[92]  = 
#line 831
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )53};
#line 846 "parse-datetime.c"
static yytype_uint8 const   yyr2[92]  = 
#line 846
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2};
#line 863 "parse-datetime.c"
static yytype_uint8 const   yydefact[114]  = 
#line 863
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )85,      (yytype_uint8 const   )87,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )86,      (yytype_uint8 const   )4,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )73,      (yytype_uint8 const   )62,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )35,      (yytype_uint8 const   )28,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )16,      (yytype_uint8 const   )8,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )13,      (yytype_uint8 const   )52,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )39,      (yytype_uint8 const   )36,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )77,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )64,      (yytype_uint8 const   )67,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )18,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )33, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )51,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )43,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )46,      (yytype_uint8 const   )91, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )90,      (yytype_uint8 const   )0,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )26,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )25};
#line 880 "parse-datetime.c"
static yytype_int8 const   yydefgoto[26]  = 
#line 880
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33,      (yytype_int8 const   )34, 
        (yytype_int8 const   )35,      (yytype_int8 const   )103,      (yytype_int8 const   )104,      (yytype_int8 const   )36, 
        (yytype_int8 const   )37,      (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )40, 
        (yytype_int8 const   )41,      (yytype_int8 const   )42,      (yytype_int8 const   )43,      (yytype_int8 const   )44, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )45, 
        (yytype_int8 const   )46,      (yytype_int8 const   )93};
#line 890 "parse-datetime.c"
static yytype_int8 const   yypact[114]  = 
#line 890
  {      (yytype_int8 const   )38,      (yytype_int8 const   )27,      (yytype_int8 const   )77,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )62,      (yytype_int8 const   )-93,      (yytype_int8 const   )82,      (yytype_int8 const   )-3, 
        (yytype_int8 const   )66,      (yytype_int8 const   )3,      (yytype_int8 const   )74,      (yytype_int8 const   )-4, 
        (yytype_int8 const   )83,      (yytype_int8 const   )84,      (yytype_int8 const   )75,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-93,      (yytype_int8 const   )93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )78,      (yytype_int8 const   )72,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )25, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )21, 
        (yytype_int8 const   )19,      (yytype_int8 const   )79,      (yytype_int8 const   )80,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )81,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )85, 
        (yytype_int8 const   )86,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-6,      (yytype_int8 const   )76, 
        (yytype_int8 const   )17,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )87,      (yytype_int8 const   )69,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )88,      (yytype_int8 const   )89,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )18,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )69,      (yytype_int8 const   )91};
#line 907 "parse-datetime.c"
static yytype_int8 const   yypgoto[26]  = 
#line 907
  {      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )20,      (yytype_int8 const   )-68,      (yytype_int8 const   )-27,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )60,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )-93,      (yytype_int8 const   )-92,      (yytype_int8 const   )-93, 
        (yytype_int8 const   )-93,      (yytype_int8 const   )43};
#line 918 "parse-datetime.c"
static yytype_uint8 const   yytable[113]  = 
#line 918
  {      (yytype_uint8 const   )79,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68,      (yytype_uint8 const   )69, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )100,      (yytype_uint8 const   )107,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )101,      (yytype_uint8 const   )110,      (yytype_uint8 const   )76, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )101,      (yytype_uint8 const   )102, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )77,      (yytype_uint8 const   )59,      (yytype_uint8 const   )78, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )101,      (yytype_uint8 const   )101,      (yytype_uint8 const   )92,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )106,      (yytype_uint8 const   )112, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )111,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )88,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )1,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )79,      (yytype_uint8 const   )30,      (yytype_uint8 const   )51, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )12,      (yytype_uint8 const   )57,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )60,      (yytype_uint8 const   )48,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )6,      (yytype_uint8 const   )83,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )82,      (yytype_uint8 const   )26,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )94, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )89,      (yytype_uint8 const   )105, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )101,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88};
#line 940 "parse-datetime.c"
static yytype_int8 const   yycheck[113]  = 
#line 940
  {      (yytype_int8 const   )27,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )4, 
        (yytype_int8 const   )12,      (yytype_int8 const   )15,      (yytype_int8 const   )102,      (yytype_int8 const   )15, 
        (yytype_int8 const   )16,      (yytype_int8 const   )19,      (yytype_int8 const   )15,      (yytype_int8 const   )19, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )25, 
        (yytype_int8 const   )112,      (yytype_int8 const   )25,      (yytype_int8 const   )19,      (yytype_int8 const   )27, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )107, 
        (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )25,      (yytype_int8 const   )25, 
        (yytype_int8 const   )25,      (yytype_int8 const   )113,      (yytype_int8 const   )19,      (yytype_int8 const   )20, 
        (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )25,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )23,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )96,      (yytype_int8 const   )24,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )0,      (yytype_int8 const   )12,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )4,      (yytype_int8 const   )27, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )30,      (yytype_int8 const   )22, 
        (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )19,      (yytype_int8 const   )24, 
        (yytype_int8 const   )3,      (yytype_int8 const   )19,      (yytype_int8 const   )26,      (yytype_int8 const   )20, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )59,      (yytype_int8 const   )27, 
        (yytype_int8 const   )84,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )19,      (yytype_int8 const   )-1, 
        (yytype_int8 const   )25};
#line 958 "parse-datetime.c"
static yytype_uint8 const   yystos[114]  = 
#line 958
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )24,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )27,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )9,      (yytype_uint8 const   )9,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )53,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )53,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )36,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )50};
#line 1496 "parse-datetime.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 


  {
#line 1510
  if (! yymsg) {
#line 1511
    yymsg = "Deleting";
  }
  {
#line 1517
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1518
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1520
  return;
}
}
#line 1532
int yyparse(parser_control *pc ) ;
#line 1556 "parse-datetime.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;
  int tmp___1 ;

  {
#line 1616
  yylen = 0;
#line 1618
  yytoken = 0;
#line 1619
  yyss = yyssa;
#line 1620
  yyvs = yyvsa;
#line 1621
  yystacksize = 20UL;
#line 1625
  yystate = 0;
#line 1626
  yyerrstatus = 0;
#line 1627
  yynerrs = 0;
#line 1628
  yychar = -2;
#line 1634
  yyssp = yyss;
#line 1635
  yyvsp = yyvs;
#line 1637
  goto yysetstate;
  yynewstate: 
#line 1645
  yyssp ++;
  yysetstate: 
#line 1648
  *yyssp = (yytype_int16 )yystate;
#line 1650
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1653
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1680
    if (20UL <= yystacksize) {
#line 1681
      goto yyexhaustedlab;
    }
#line 1682
    yystacksize *= 2UL;
#line 1683
    if (20UL < yystacksize) {
#line 1684
      yystacksize = 20UL;
    }
    {
#line 1687
    yyss1 = yyss;
#line 1688
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1688
    yyptr = (union yyalloc *)tmp;
    }
#line 1690
    if (! yyptr) {
#line 1691
      goto yyexhaustedlab;
    }
    {
#line 1692
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1692
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1692
      yyss = & yyptr->yyss_alloc;
#line 1692
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1692
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1692
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1693
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1693
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1693
      yyvs = & yyptr->yyvs_alloc;
#line 1693
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1693
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1693
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1695
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1696
      free((void *)yyss1);
      }
    }
#line 1701
    yyssp = (yyss + yysize) - 1;
#line 1702
    yyvsp = (yyvs + yysize) - 1;
#line 1707
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1708
      goto yyabortlab;
    }
  }
#line 1713
  if (yystate == 12) {
#line 1714
    goto yyacceptlab;
  }
#line 1716
  goto yybackup;
  yybackup: 
#line 1727
  yyn = (int )yypact[yystate];
#line 1728
  if (yyn == -93) {
#line 1729
    goto yydefault;
  }
#line 1734
  if (yychar == -2) {
    {
#line 1737
    yychar = yylex(& yylval, pc);
    }
  }
#line 1740
  if (yychar <= 0) {
#line 1742
    yytoken = 0;
#line 1742
    yychar = yytoken;
  } else
#line 1747
  if ((unsigned int )yychar <= 277U) {
#line 1747
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1747
    yytoken = 2;
  }
#line 1753
  yyn += yytoken;
#line 1754
  if (yyn < 0) {
#line 1755
    goto yydefault;
  } else
#line 1754
  if (112 < yyn) {
#line 1755
    goto yydefault;
  } else
#line 1754
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1755
    goto yydefault;
  }
#line 1756
  yyn = (int )yytable[yyn];
#line 1757
  if (yyn <= 0) {
#line 1761
    yyn = - yyn;
#line 1762
    goto yyreduce;
  }
#line 1767
  if (yyerrstatus) {
#line 1768
    yyerrstatus --;
  }
#line 1774
  yychar = -2;
#line 1776
  yystate = yyn;
#line 1777
  yyvsp ++;
#line 1777
  *yyvsp = yylval;
#line 1779
  goto yynewstate;
  yydefault: 
#line 1786
  yyn = (int )yydefact[yystate];
#line 1787
  if (yyn == 0) {
#line 1788
    goto yyerrlab;
  }
#line 1789
  goto yyreduce;
  yyreduce: 
#line 1797
  yylen = (int )yyr2[yyn];
#line 1807
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1813
  if (yyn == 4) {
#line 1813
    goto case_4;
  }
#line 336
  if (yyn == 7) {
#line 336 "./parse-datetime.y"
    goto case_7;
  }
#line 346
  if (yyn == 8) {
#line 346
    goto case_8;
  }
#line 348
  if (yyn == 9) {
#line 348
    goto case_9;
  }
#line 350
  if (yyn == 10) {
#line 350
    goto case_10;
  }
#line 352
  if (yyn == 11) {
#line 352
    goto case_11;
  }
#line 354
  if (yyn == 12) {
#line 354
    goto case_12;
  }
#line 356
  if (yyn == 18) {
#line 356
    goto case_18;
  }
#line 375
  if (yyn == 19) {
#line 375
    goto case_19;
  }
#line 380
  if (yyn == 20) {
#line 380
    goto case_20;
  }
#line 385
  if (yyn == 22) {
#line 385
    goto case_22;
  }
#line 394
  if (yyn == 23) {
#line 394
    goto case_23;
  }
#line 399
  if (yyn == 24) {
#line 399
    goto case_24;
  }
#line 404
  if (yyn == 27) {
#line 404
    goto case_27;
  }
#line 417
  if (yyn == 28) {
#line 417
    goto case_28;
  }
#line 425
  if (yyn == 29) {
#line 425
    goto case_29;
  }
#line 430
  if (yyn == 30) {
#line 430
    goto case_30;
  }
#line 437
  if (yyn == 31) {
#line 437
    goto case_31;
  }
#line 439
  if (yyn == 32) {
#line 439
    goto case_32;
  }
#line 442
  if (yyn == 33) {
#line 442
    goto case_33;
  }
#line 445
  if (yyn == 34) {
#line 445
    goto case_34;
  }
#line 447
  if (yyn == 35) {
#line 447
    goto case_35;
  }
#line 449
  if (yyn == 36) {
#line 449
    goto case_36;
  }
#line 451
  if (yyn == 37) {
#line 451
    goto case_37;
  }
#line 459
  if (yyn == 38) {
#line 459
    goto case_38;
  }
#line 464
  if (yyn == 39) {
#line 464
    goto case_39;
  }
#line 469
  if (yyn == 40) {
#line 469
    goto case_40;
  }
#line 474
  if (yyn == 41) {
#line 474
    goto case_41;
  }
#line 482
  if (yyn == 42) {
#line 482
    goto case_42;
  }
#line 502
  if (yyn == 43) {
#line 502
    goto case_43;
  }
#line 510
  if (yyn == 44) {
#line 510
    goto case_44;
  }
#line 518
  if (yyn == 45) {
#line 518
    goto case_45;
  }
#line 523
  if (yyn == 46) {
#line 523
    goto case_46;
  }
#line 529
  if (yyn == 47) {
#line 529
    goto case_47;
  }
#line 534
  if (yyn == 48) {
#line 534
    goto case_48;
  }
#line 540
  if (yyn == 50) {
#line 540
    goto case_50;
  }
#line 551
  if (yyn == 51) {
#line 551
    goto case_51;
  }
#line 556
  if (yyn == 52) {
#line 556
    goto case_52;
  }
#line 558
  if (yyn == 53) {
#line 558
    goto case_53;
  }
#line 560
  if (yyn == 54) {
#line 560
    goto case_54;
  }
#line 565
  if (yyn == 55) {
#line 565
    goto case_55;
  }
#line 567
  if (yyn == 56) {
#line 567
    goto case_56;
  }
#line 569
  if (yyn == 57) {
#line 569
    goto case_57;
  }
#line 571
  if (yyn == 58) {
#line 571
    goto case_58;
  }
#line 573
  if (yyn == 59) {
#line 573
    goto case_59;
  }
#line 575
  if (yyn == 60) {
#line 575
    goto case_60;
  }
#line 577
  if (yyn == 61) {
#line 577
    goto case_61;
  }
#line 579
  if (yyn == 62) {
#line 579
    goto case_62;
  }
#line 581
  if (yyn == 63) {
#line 581
    goto case_63;
  }
#line 583
  if (yyn == 64) {
#line 583
    goto case_64;
  }
#line 585
  if (yyn == 65) {
#line 585
    goto case_65;
  }
#line 587
  if (yyn == 66) {
#line 587
    goto case_66;
  }
#line 589
  if (yyn == 67) {
#line 589
    goto case_67;
  }
#line 591
  if (yyn == 68) {
#line 591
    goto case_68;
  }
#line 593
  if (yyn == 69) {
#line 593
    goto case_69;
  }
#line 595
  if (yyn == 70) {
#line 595
    goto case_70;
  }
#line 597
  if (yyn == 71) {
#line 597
    goto case_71;
  }
#line 599
  if (yyn == 72) {
#line 599
    goto case_72;
  }
#line 601
  if (yyn == 73) {
#line 601
    goto case_73;
  }
#line 603
  if (yyn == 75) {
#line 603
    goto case_75;
  }
#line 609
  if (yyn == 76) {
#line 609
    goto case_76;
  }
#line 611
  if (yyn == 77) {
#line 611
    goto case_77;
  }
#line 613
  if (yyn == 78) {
#line 613
    goto case_78;
  }
#line 615
  if (yyn == 79) {
#line 615
    goto case_79;
  }
#line 617
  if (yyn == 80) {
#line 617
    goto case_80;
  }
#line 619
  if (yyn == 81) {
#line 619
    goto case_81;
  }
#line 624
  if (yyn == 85) {
#line 624
    goto case_85;
  }
#line 632
  if (yyn == 87) {
#line 632
    goto case_87;
  }
#line 638
  if (yyn == 88) {
#line 638
    goto case_88;
  }
#line 643
  if (yyn == 89) {
#line 643
    goto case_89;
  }
#line 653
  if (yyn == 90) {
#line 653
    goto case_90;
  }
#line 658
  if (yyn == 91) {
#line 658
    goto case_91;
  }
#line 2422 "parse-datetime.c"
  goto switch_default;
  case_4: /* CIL Label */ 
#line 331 "./parse-datetime.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 332
  pc->timespec_seen = (_Bool)1;
#line 334
  goto switch_break;
  case_7: /* CIL Label */ 
#line 343
  (pc->times_seen) ++;
#line 343
  (pc->dates_seen) ++;
#line 344
  goto switch_break;
  case_8: /* CIL Label */ 
#line 345
  (pc->times_seen) ++;
#line 346
  goto switch_break;
  case_9: /* CIL Label */ 
#line 347
  (pc->local_zones_seen) ++;
#line 348
  goto switch_break;
  case_10: /* CIL Label */ 
#line 349
  (pc->zones_seen) ++;
#line 350
  goto switch_break;
  case_11: /* CIL Label */ 
#line 351
  (pc->dates_seen) ++;
#line 352
  goto switch_break;
  case_12: /* CIL Label */ 
#line 353
  (pc->days_seen) ++;
#line 354
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 370
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 371
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 373
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 375
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 376
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 378
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 380
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 381
  pc->meridian = (int )(yyvsp + 0)->intval;
  }
#line 383
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 389
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 390
  pc->meridian = 2;
  }
#line 392
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 394
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 395
  pc->meridian = 2;
  }
#line 397
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 399
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 400
  pc->meridian = 2;
  }
#line 402
  goto switch_break;
  case_27: /* CIL Label */ 
  {
#line 412
  (pc->zones_seen) ++;
#line 413
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
  }
#line 415
  goto switch_break;
  case_28: /* CIL Label */ 
#line 420
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 421
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
#line 423
  goto switch_break;
  case_29: /* CIL Label */ 
#line 425
  pc->local_isdst = 1;
#line 426
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
#line 428
  goto switch_break;
  case_30: /* CIL Label */ 
#line 434
  pc->time_zone = (yyvsp + 0)->intval;
#line 435
  goto switch_break;
  case_31: /* CIL Label */ 
#line 436
  pc->time_zone = 420L;
#line 437
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 438
  pc->time_zone = (yyvsp + -1)->intval;
#line 439
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 440
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 441
  pc->time_zone = 420L;
#line 442
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 443
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 444
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 444
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
  }
#line 445
  goto switch_break;
  case_35: /* CIL Label */ 
#line 446
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 447
  goto switch_break;
  case_36: /* CIL Label */ 
#line 448
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 449
  goto switch_break;
  case_37: /* CIL Label */ 
#line 454
  pc->day_ordinal = 0L;
#line 455
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 457
  goto switch_break;
  case_38: /* CIL Label */ 
#line 459
  pc->day_ordinal = 0L;
#line 460
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 462
  goto switch_break;
  case_39: /* CIL Label */ 
#line 464
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 465
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 467
  goto switch_break;
  case_40: /* CIL Label */ 
#line 469
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 470
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 472
  goto switch_break;
  case_41: /* CIL Label */ 
#line 477
  pc->month = (yyvsp + -2)->textintval.value;
#line 478
  pc->day = (yyvsp + 0)->textintval.value;
#line 480
  goto switch_break;
  case_42: /* CIL Label */ 
#line 487
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 489
    pc->year = (yyvsp + -4)->textintval;
#line 490
    pc->month = (yyvsp + -2)->textintval.value;
#line 491
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 495
    pc->month = (yyvsp + -4)->textintval.value;
#line 496
    pc->day = (yyvsp + -2)->textintval.value;
#line 497
    pc->year = (yyvsp + 0)->textintval;
  }
#line 500
  goto switch_break;
  case_43: /* CIL Label */ 
#line 503
  pc->day = (yyvsp + -2)->textintval.value;
#line 504
  pc->month = (yyvsp + -1)->intval;
#line 505
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 506
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 508
  goto switch_break;
  case_44: /* CIL Label */ 
#line 511
  pc->month = (yyvsp + -2)->intval;
#line 512
  pc->day = - (yyvsp + -1)->textintval.value;
#line 513
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 514
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 516
  goto switch_break;
  case_45: /* CIL Label */ 
#line 518
  pc->month = (yyvsp + -1)->intval;
#line 519
  pc->day = (yyvsp + 0)->textintval.value;
#line 521
  goto switch_break;
  case_46: /* CIL Label */ 
#line 523
  pc->month = (yyvsp + -3)->intval;
#line 524
  pc->day = (yyvsp + -2)->textintval.value;
#line 525
  pc->year = (yyvsp + 0)->textintval;
#line 527
  goto switch_break;
  case_47: /* CIL Label */ 
#line 529
  pc->day = (yyvsp + -1)->textintval.value;
#line 530
  pc->month = (yyvsp + 0)->intval;
#line 532
  goto switch_break;
  case_48: /* CIL Label */ 
#line 534
  pc->day = (yyvsp + -2)->textintval.value;
#line 535
  pc->month = (yyvsp + -1)->intval;
#line 536
  pc->year = (yyvsp + 0)->textintval;
#line 538
  goto switch_break;
  case_50: /* CIL Label */ 
#line 545
  pc->year = (yyvsp + -2)->textintval;
#line 546
  pc->month = - (yyvsp + -1)->textintval.value;
#line 547
  pc->day = - (yyvsp + 0)->textintval.value;
#line 549
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 553
  apply_relative_time(pc, (yyvsp + -1)->rel, (int )(yyvsp + 0)->intval);
  }
#line 554
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 555
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 556
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 557
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 558
  goto switch_break;
  case_54: /* CIL Label */ 
#line 562
  __constr_expr_0.year = 0L;
#line 562
  __constr_expr_0.month = 0L;
#line 562
  __constr_expr_0.day = 0L;
#line 562
  __constr_expr_0.hour = 0L;
#line 562
  __constr_expr_0.minutes = 0L;
#line 562
  __constr_expr_0.seconds = (long_time_t )0;
#line 562
  __constr_expr_0.ns = 0L;
#line 562
  yyval.rel = __constr_expr_0;
#line 562
  yyval.rel.year = (yyvsp + -1)->intval;
#line 563
  goto switch_break;
  case_55: /* CIL Label */ 
#line 564
  __constr_expr_1.year = 0L;
#line 564
  __constr_expr_1.month = 0L;
#line 564
  __constr_expr_1.day = 0L;
#line 564
  __constr_expr_1.hour = 0L;
#line 564
  __constr_expr_1.minutes = 0L;
#line 564
  __constr_expr_1.seconds = (long_time_t )0;
#line 564
  __constr_expr_1.ns = 0L;
#line 564
  yyval.rel = __constr_expr_1;
#line 564
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 565
  goto switch_break;
  case_56: /* CIL Label */ 
#line 566
  __constr_expr_2.year = 0L;
#line 566
  __constr_expr_2.month = 0L;
#line 566
  __constr_expr_2.day = 0L;
#line 566
  __constr_expr_2.hour = 0L;
#line 566
  __constr_expr_2.minutes = 0L;
#line 566
  __constr_expr_2.seconds = (long_time_t )0;
#line 566
  __constr_expr_2.ns = 0L;
#line 566
  yyval.rel = __constr_expr_2;
#line 566
  yyval.rel.year = 1L;
#line 567
  goto switch_break;
  case_57: /* CIL Label */ 
#line 568
  __constr_expr_3.year = 0L;
#line 568
  __constr_expr_3.month = 0L;
#line 568
  __constr_expr_3.day = 0L;
#line 568
  __constr_expr_3.hour = 0L;
#line 568
  __constr_expr_3.minutes = 0L;
#line 568
  __constr_expr_3.seconds = (long_time_t )0;
#line 568
  __constr_expr_3.ns = 0L;
#line 568
  yyval.rel = __constr_expr_3;
#line 568
  yyval.rel.month = (yyvsp + -1)->intval;
#line 569
  goto switch_break;
  case_58: /* CIL Label */ 
#line 570
  __constr_expr_4.year = 0L;
#line 570
  __constr_expr_4.month = 0L;
#line 570
  __constr_expr_4.day = 0L;
#line 570
  __constr_expr_4.hour = 0L;
#line 570
  __constr_expr_4.minutes = 0L;
#line 570
  __constr_expr_4.seconds = (long_time_t )0;
#line 570
  __constr_expr_4.ns = 0L;
#line 570
  yyval.rel = __constr_expr_4;
#line 570
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 571
  goto switch_break;
  case_59: /* CIL Label */ 
#line 572
  __constr_expr_5.year = 0L;
#line 572
  __constr_expr_5.month = 0L;
#line 572
  __constr_expr_5.day = 0L;
#line 572
  __constr_expr_5.hour = 0L;
#line 572
  __constr_expr_5.minutes = 0L;
#line 572
  __constr_expr_5.seconds = (long_time_t )0;
#line 572
  __constr_expr_5.ns = 0L;
#line 572
  yyval.rel = __constr_expr_5;
#line 572
  yyval.rel.month = 1L;
#line 573
  goto switch_break;
  case_60: /* CIL Label */ 
#line 574
  __constr_expr_6.year = 0L;
#line 574
  __constr_expr_6.month = 0L;
#line 574
  __constr_expr_6.day = 0L;
#line 574
  __constr_expr_6.hour = 0L;
#line 574
  __constr_expr_6.minutes = 0L;
#line 574
  __constr_expr_6.seconds = (long_time_t )0;
#line 574
  __constr_expr_6.ns = 0L;
#line 574
  yyval.rel = __constr_expr_6;
#line 574
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 575
  goto switch_break;
  case_61: /* CIL Label */ 
#line 576
  __constr_expr_7.year = 0L;
#line 576
  __constr_expr_7.month = 0L;
#line 576
  __constr_expr_7.day = 0L;
#line 576
  __constr_expr_7.hour = 0L;
#line 576
  __constr_expr_7.minutes = 0L;
#line 576
  __constr_expr_7.seconds = (long_time_t )0;
#line 576
  __constr_expr_7.ns = 0L;
#line 576
  yyval.rel = __constr_expr_7;
#line 576
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 577
  goto switch_break;
  case_62: /* CIL Label */ 
#line 578
  __constr_expr_8.year = 0L;
#line 578
  __constr_expr_8.month = 0L;
#line 578
  __constr_expr_8.day = 0L;
#line 578
  __constr_expr_8.hour = 0L;
#line 578
  __constr_expr_8.minutes = 0L;
#line 578
  __constr_expr_8.seconds = (long_time_t )0;
#line 578
  __constr_expr_8.ns = 0L;
#line 578
  yyval.rel = __constr_expr_8;
#line 578
  yyval.rel.day = (yyvsp + 0)->intval;
#line 579
  goto switch_break;
  case_63: /* CIL Label */ 
#line 580
  __constr_expr_9.year = 0L;
#line 580
  __constr_expr_9.month = 0L;
#line 580
  __constr_expr_9.day = 0L;
#line 580
  __constr_expr_9.hour = 0L;
#line 580
  __constr_expr_9.minutes = 0L;
#line 580
  __constr_expr_9.seconds = (long_time_t )0;
#line 580
  __constr_expr_9.ns = 0L;
#line 580
  yyval.rel = __constr_expr_9;
#line 580
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 581
  goto switch_break;
  case_64: /* CIL Label */ 
#line 582
  __constr_expr_10.year = 0L;
#line 582
  __constr_expr_10.month = 0L;
#line 582
  __constr_expr_10.day = 0L;
#line 582
  __constr_expr_10.hour = 0L;
#line 582
  __constr_expr_10.minutes = 0L;
#line 582
  __constr_expr_10.seconds = (long_time_t )0;
#line 582
  __constr_expr_10.ns = 0L;
#line 582
  yyval.rel = __constr_expr_10;
#line 582
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 583
  goto switch_break;
  case_65: /* CIL Label */ 
#line 584
  __constr_expr_11.year = 0L;
#line 584
  __constr_expr_11.month = 0L;
#line 584
  __constr_expr_11.day = 0L;
#line 584
  __constr_expr_11.hour = 0L;
#line 584
  __constr_expr_11.minutes = 0L;
#line 584
  __constr_expr_11.seconds = (long_time_t )0;
#line 584
  __constr_expr_11.ns = 0L;
#line 584
  yyval.rel = __constr_expr_11;
#line 584
  yyval.rel.hour = 1L;
#line 585
  goto switch_break;
  case_66: /* CIL Label */ 
#line 586
  __constr_expr_12.year = 0L;
#line 586
  __constr_expr_12.month = 0L;
#line 586
  __constr_expr_12.day = 0L;
#line 586
  __constr_expr_12.hour = 0L;
#line 586
  __constr_expr_12.minutes = 0L;
#line 586
  __constr_expr_12.seconds = (long_time_t )0;
#line 586
  __constr_expr_12.ns = 0L;
#line 586
  yyval.rel = __constr_expr_12;
#line 586
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 587
  goto switch_break;
  case_67: /* CIL Label */ 
#line 588
  __constr_expr_13.year = 0L;
#line 588
  __constr_expr_13.month = 0L;
#line 588
  __constr_expr_13.day = 0L;
#line 588
  __constr_expr_13.hour = 0L;
#line 588
  __constr_expr_13.minutes = 0L;
#line 588
  __constr_expr_13.seconds = (long_time_t )0;
#line 588
  __constr_expr_13.ns = 0L;
#line 588
  yyval.rel = __constr_expr_13;
#line 588
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 589
  goto switch_break;
  case_68: /* CIL Label */ 
#line 590
  __constr_expr_14.year = 0L;
#line 590
  __constr_expr_14.month = 0L;
#line 590
  __constr_expr_14.day = 0L;
#line 590
  __constr_expr_14.hour = 0L;
#line 590
  __constr_expr_14.minutes = 0L;
#line 590
  __constr_expr_14.seconds = (long_time_t )0;
#line 590
  __constr_expr_14.ns = 0L;
#line 590
  yyval.rel = __constr_expr_14;
#line 590
  yyval.rel.minutes = 1L;
#line 591
  goto switch_break;
  case_69: /* CIL Label */ 
#line 592
  __constr_expr_15.year = 0L;
#line 592
  __constr_expr_15.month = 0L;
#line 592
  __constr_expr_15.day = 0L;
#line 592
  __constr_expr_15.hour = 0L;
#line 592
  __constr_expr_15.minutes = 0L;
#line 592
  __constr_expr_15.seconds = (long_time_t )0;
#line 592
  __constr_expr_15.ns = 0L;
#line 592
  yyval.rel = __constr_expr_15;
#line 592
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 593
  goto switch_break;
  case_70: /* CIL Label */ 
#line 594
  __constr_expr_16.year = 0L;
#line 594
  __constr_expr_16.month = 0L;
#line 594
  __constr_expr_16.day = 0L;
#line 594
  __constr_expr_16.hour = 0L;
#line 594
  __constr_expr_16.minutes = 0L;
#line 594
  __constr_expr_16.seconds = (long_time_t )0;
#line 594
  __constr_expr_16.ns = 0L;
#line 594
  yyval.rel = __constr_expr_16;
#line 594
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 595
  goto switch_break;
  case_71: /* CIL Label */ 
#line 596
  __constr_expr_17.year = 0L;
#line 596
  __constr_expr_17.month = 0L;
#line 596
  __constr_expr_17.day = 0L;
#line 596
  __constr_expr_17.hour = 0L;
#line 596
  __constr_expr_17.minutes = 0L;
#line 596
  __constr_expr_17.seconds = (long_time_t )0;
#line 596
  __constr_expr_17.ns = 0L;
#line 596
  yyval.rel = __constr_expr_17;
#line 596
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 596
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 597
  goto switch_break;
  case_72: /* CIL Label */ 
#line 598
  __constr_expr_18.year = 0L;
#line 598
  __constr_expr_18.month = 0L;
#line 598
  __constr_expr_18.day = 0L;
#line 598
  __constr_expr_18.hour = 0L;
#line 598
  __constr_expr_18.minutes = 0L;
#line 598
  __constr_expr_18.seconds = (long_time_t )0;
#line 598
  __constr_expr_18.ns = 0L;
#line 598
  yyval.rel = __constr_expr_18;
#line 598
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 598
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 599
  goto switch_break;
  case_73: /* CIL Label */ 
#line 600
  __constr_expr_19.year = 0L;
#line 600
  __constr_expr_19.month = 0L;
#line 600
  __constr_expr_19.day = 0L;
#line 600
  __constr_expr_19.hour = 0L;
#line 600
  __constr_expr_19.minutes = 0L;
#line 600
  __constr_expr_19.seconds = (long_time_t )0;
#line 600
  __constr_expr_19.ns = 0L;
#line 600
  yyval.rel = __constr_expr_19;
#line 600
  yyval.rel.seconds = (long_time_t )1;
#line 601
  goto switch_break;
  case_75: /* CIL Label */ 
#line 606
  __constr_expr_20.year = 0L;
#line 606
  __constr_expr_20.month = 0L;
#line 606
  __constr_expr_20.day = 0L;
#line 606
  __constr_expr_20.hour = 0L;
#line 606
  __constr_expr_20.minutes = 0L;
#line 606
  __constr_expr_20.seconds = (long_time_t )0;
#line 606
  __constr_expr_20.ns = 0L;
#line 606
  yyval.rel = __constr_expr_20;
#line 606
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 607
  goto switch_break;
  case_76: /* CIL Label */ 
#line 608
  __constr_expr_21.year = 0L;
#line 608
  __constr_expr_21.month = 0L;
#line 608
  __constr_expr_21.day = 0L;
#line 608
  __constr_expr_21.hour = 0L;
#line 608
  __constr_expr_21.minutes = 0L;
#line 608
  __constr_expr_21.seconds = (long_time_t )0;
#line 608
  __constr_expr_21.ns = 0L;
#line 608
  yyval.rel = __constr_expr_21;
#line 608
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 609
  goto switch_break;
  case_77: /* CIL Label */ 
#line 610
  __constr_expr_22.year = 0L;
#line 610
  __constr_expr_22.month = 0L;
#line 610
  __constr_expr_22.day = 0L;
#line 610
  __constr_expr_22.hour = 0L;
#line 610
  __constr_expr_22.minutes = 0L;
#line 610
  __constr_expr_22.seconds = (long_time_t )0;
#line 610
  __constr_expr_22.ns = 0L;
#line 610
  yyval.rel = __constr_expr_22;
#line 610
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 611
  goto switch_break;
  case_78: /* CIL Label */ 
#line 612
  __constr_expr_23.year = 0L;
#line 612
  __constr_expr_23.month = 0L;
#line 612
  __constr_expr_23.day = 0L;
#line 612
  __constr_expr_23.hour = 0L;
#line 612
  __constr_expr_23.minutes = 0L;
#line 612
  __constr_expr_23.seconds = (long_time_t )0;
#line 612
  __constr_expr_23.ns = 0L;
#line 612
  yyval.rel = __constr_expr_23;
#line 612
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 613
  goto switch_break;
  case_79: /* CIL Label */ 
#line 614
  __constr_expr_24.year = 0L;
#line 614
  __constr_expr_24.month = 0L;
#line 614
  __constr_expr_24.day = 0L;
#line 614
  __constr_expr_24.hour = 0L;
#line 614
  __constr_expr_24.minutes = 0L;
#line 614
  __constr_expr_24.seconds = (long_time_t )0;
#line 614
  __constr_expr_24.ns = 0L;
#line 614
  yyval.rel = __constr_expr_24;
#line 614
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 615
  goto switch_break;
  case_80: /* CIL Label */ 
#line 616
  __constr_expr_25.year = 0L;
#line 616
  __constr_expr_25.month = 0L;
#line 616
  __constr_expr_25.day = 0L;
#line 616
  __constr_expr_25.hour = 0L;
#line 616
  __constr_expr_25.minutes = 0L;
#line 616
  __constr_expr_25.seconds = (long_time_t )0;
#line 616
  __constr_expr_25.ns = 0L;
#line 616
  yyval.rel = __constr_expr_25;
#line 616
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 617
  goto switch_break;
  case_81: /* CIL Label */ 
#line 621
  __constr_expr_26.year = 0L;
#line 621
  __constr_expr_26.month = 0L;
#line 621
  __constr_expr_26.day = 0L;
#line 621
  __constr_expr_26.hour = 0L;
#line 621
  __constr_expr_26.minutes = 0L;
#line 621
  __constr_expr_26.seconds = (long_time_t )0;
#line 621
  __constr_expr_26.ns = 0L;
#line 621
  yyval.rel = __constr_expr_26;
#line 621
  yyval.rel.day = (yyvsp + 0)->intval;
#line 622
  goto switch_break;
  case_85: /* CIL Label */ 
#line 629
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 629
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 630
  goto switch_break;
  case_87: /* CIL Label */ 
#line 635
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 635
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 636
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 640
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
  }
#line 641
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 648
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 649
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
  }
#line 651
  goto switch_break;
  case_90: /* CIL Label */ 
#line 655
  yyval.intval = -1L;
#line 656
  goto switch_break;
  case_91: /* CIL Label */ 
#line 657
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 658
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2422 "parse-datetime.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2437
  yyvsp -= yylen;
#line 2437
  yyssp -= yylen;
#line 2438
  yylen = 0;
#line 2441
  yyvsp ++;
#line 2441
  *yyvsp = yyval;
#line 2447
  yyn = (int )yyr1[yyn];
#line 2449
  yystate = (int )((int const   )yypgoto[yyn - 28] + (int const   )*yyssp);
#line 2450
  if (0 <= yystate) {
#line 2450
    if (yystate <= 112) {
#line 2450
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2451
        yystate = (int )yytable[yystate];
      } else {
#line 2453
        yystate = (int )yydefgoto[yyn - 28];
      }
    } else {
#line 2453
      yystate = (int )yydefgoto[yyn - 28];
    }
  } else {
#line 2453
    yystate = (int )yydefgoto[yyn - 28];
  }
#line 2455
  goto yynewstate;
  yyerrlab: 
#line 2464
  if (yychar == -2) {
#line 2464
    yytoken = -2;
  } else {
#line 2464
    if ((unsigned int )yychar <= 277U) {
#line 2464
      tmp___1 = (int const   )yytranslate[yychar];
    } else {
#line 2464
      tmp___1 = (int const   )2;
    }
#line 2464
    yytoken = (int )tmp___1;
  }
#line 2467
  if (! yyerrstatus) {
    {
#line 2469
    yynerrs ++;
#line 2471
    yyerror((parser_control const   *)pc, "syntax error");
    }
  }
#line 2508
  if (yyerrstatus == 3) {
#line 2513
    if (yychar <= 0) {
#line 2516
      if (yychar == 0) {
#line 2517
        goto yyabortlab;
      }
    } else {
      {
#line 2521
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2523
      yychar = -2;
      }
    }
  }
#line 2529
  goto yyerrlab1;
#line 2545
  yyvsp -= yylen;
#line 2545
  yyssp -= yylen;
#line 2546
  yylen = 0;
#line 2548
  yystate = (int )*yyssp;
#line 2549
  goto yyerrlab1;
  yyerrlab1: 
#line 2556
  yyerrstatus = 3;
  {
#line 2558
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2560
    yyn = (int )yypact[yystate];
#line 2561
    if (! (yyn == -93)) {
#line 2563
      yyn ++;
#line 2564
      if (0 <= yyn) {
#line 2564
        if (yyn <= 112) {
#line 2564
          if ((int const   )yycheck[yyn] == 1) {
#line 2566
            yyn = (int )yytable[yyn];
#line 2567
            if (0 < yyn) {
#line 2568
              goto while_break___1;
            }
          }
        }
      }
    }
#line 2573
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2574
      goto yyabortlab;
    }
    {
#line 2577
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2579
    yyvsp --;
#line 2579
    yyssp --;
#line 2580
    yystate = (int )*yyssp;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2584
  yyvsp ++;
#line 2584
  *yyvsp = yylval;
#line 2590
  yystate = yyn;
#line 2591
  goto yynewstate;
  yyacceptlab: 
#line 2598
  yyresult = 0;
#line 2599
  goto yyreturn;
  yyabortlab: 
#line 2605
  yyresult = 1;
#line 2606
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 2613
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2614
  yyresult = 2;
  }
  yyreturn: 
#line 2619
  if (yychar != -2) {
#line 2623
    if ((unsigned int )yychar <= 277U) {
#line 2623
      yytoken = (int )yytranslate[yychar];
    } else {
#line 2623
      yytoken = 2;
    }
    {
#line 2624
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
    }
  }
#line 2629
  yyvsp -= yylen;
#line 2629
  yyssp -= yylen;
  {
#line 2631
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2631
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 2631
      goto while_break___2;
    }
    {
#line 2633
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2635
    yyvsp --;
#line 2635
    yyssp --;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2638
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 2639
    free((void *)yyss);
    }
  }
#line 2646
  return (yyresult);
}
}
#line 662 "./parse-datetime.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 671 "./parse-datetime.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 676 "./parse-datetime.y"
static table const   month_and_day_table[25]  = 
#line 676
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 705 "./parse-datetime.y"
static table const   time_units_table[11]  = 
#line 705
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 721 "./parse-datetime.y"
static table const   relative_time_table[21]  = 
#line 721
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, -1}, 
        {"HENCE", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 750 "./parse-datetime.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 763 "./parse-datetime.y"
static table const   time_zone_table[48]  = 
#line 763
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 819 "./parse-datetime.y"
static table const   military_table[26]  = 
#line 819
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 'T', 0}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 858 "./parse-datetime.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 865
  if (s.digits <= 2UL) {
#line 865
    if (mm < 0L) {
#line 866
      s.value *= 100L;
    }
  }
#line 868
  if (mm < 0L) {
#line 869
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 871
    if (s.negative) {
#line 871
      tmp = - mm;
    } else {
#line 871
      tmp = mm;
    }
#line 871
    n_minutes = s.value * 60L + tmp;
  }
  {
#line 876
  tmp___0 = abs((int )n_minutes);
  }
#line 876
  if (1440 < tmp___0) {
#line 877
    (pc->zones_seen) ++;
  }
#line 879
  return (n_minutes);
}
}
#line 882 "./parse-datetime.y"
static int to_hour(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 890
  if (meridian == 0) {
#line 890
    goto case_0;
  }
#line 892
  if (meridian == 1) {
#line 892
    goto case_1;
  }
#line 887
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 889
  if (0L <= hours) {
#line 889
    if (hours < 24L) {
#line 889
      tmp = hours;
    } else {
#line 889
      tmp = -1L;
    }
  } else {
#line 889
    tmp = -1L;
  }
#line 889
  return ((int )tmp);
  case_0: /* CIL Label */ 
#line 891
  if (0L < hours) {
#line 891
    if (hours < 12L) {
#line 891
      tmp___1 = hours;
    } else {
#line 891
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 891
    if (hours == 12L) {
#line 891
      tmp___0 = 0;
    } else {
#line 891
      tmp___0 = -1;
    }
#line 891
    tmp___1 = (long )tmp___0;
  }
#line 891
  return ((int )tmp___1);
  case_1: /* CIL Label */ 
#line 893
  if (0L < hours) {
#line 893
    if (hours < 12L) {
#line 893
      tmp___3 = hours + 12L;
    } else {
#line 893
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 893
    if (hours == 12L) {
#line 893
      tmp___2 = 12;
    } else {
#line 893
      tmp___2 = -1;
    }
#line 893
    tmp___3 = (long )tmp___2;
  }
#line 893
  return ((int )tmp___3);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 897 "./parse-datetime.y"
static long to_year(textint textyear ) 
{ 
  long year ;
  int tmp ;

  {
#line 900
  year = textyear.value;
#line 902
  if (year < 0L) {
#line 903
    year = - year;
  } else
#line 907
  if (textyear.digits == 2UL) {
#line 908
    if (year < 69L) {
#line 908
      tmp = 2000;
    } else {
#line 908
      tmp = 1900;
    }
#line 908
    year += (long )tmp;
  }
#line 910
  return (year);
}
}
#line 913 "./parse-datetime.y"
static table const   * __attribute__((__pure__)) lookup_zone(parser_control const   *pc ,
                                                             char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 918
  tp = universal_time_zone_table;
  {
#line 918
  while (1) {
    while_continue: /* CIL Label */ ;
#line 918
    if (! tp->name) {
#line 918
      goto while_break;
    }
    {
#line 919
    tmp = strcmp(name, (char const   *)tp->name);
    }
#line 919
    if (tmp == 0) {
#line 920
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 918
    tp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  tp = (table const   *)(pc->local_time_zone_table);
  {
#line 924
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 924
    if (! tp->name) {
#line 924
      goto while_break___0;
    }
    {
#line 925
    tmp___0 = strcmp(name, (char const   *)tp->name);
    }
#line 925
    if (tmp___0 == 0) {
#line 926
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 924
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 928
  tp = time_zone_table;
  {
#line 928
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 928
    if (! tp->name) {
#line 928
      goto while_break___1;
    }
    {
#line 929
    tmp___1 = strcmp(name, (char const   *)tp->name);
    }
#line 929
    if (tmp___1 == 0) {
#line 930
      return ((table const   */* __attribute__((__pure__)) */)tp);
    }
#line 928
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 932
  return ((table const   */* __attribute__((__pure__)) */)((void *)0));
}
}
#line 962 "./parse-datetime.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  table const   * __attribute__((__pure__)) tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char tmp___10 ;
  table const   * __attribute__((__pure__)) tmp___11 ;

  {
#line 973
  p = word;
  {
#line 973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 973
    if (! *p) {
#line 973
      goto while_break;
    }
    {
#line 975
    ch = (unsigned char )*p;
#line 976
    tmp = c_toupper((int )ch);
#line 976
    *p = (char )tmp;
#line 973
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 979
  tp = meridian_table;
  {
#line 979
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 979
    if (! tp->name) {
#line 979
      goto while_break___0;
    }
    {
#line 980
    tmp___0 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 980
    if (tmp___0 == 0) {
#line 981
      return (tp);
    }
#line 979
    tp ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 984
  wordlen = strlen((char const   *)word);
  }
#line 985
  if (wordlen == 3UL) {
#line 985
    tmp___1 = 1;
  } else
#line 985
  if (wordlen == 4UL) {
#line 985
    if ((int )*(word + 3) == 46) {
#line 985
      tmp___1 = 1;
    } else {
#line 985
      tmp___1 = 0;
    }
  } else {
#line 985
    tmp___1 = 0;
  }
#line 985
  abbrev = (_Bool )tmp___1;
#line 987
  tp = month_and_day_table;
  {
#line 987
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 987
    if (! tp->name) {
#line 987
      goto while_break___1;
    }
#line 988
    if (abbrev) {
      {
#line 988
      tmp___2 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 988
      tmp___4 = tmp___2;
      }
    } else {
      {
#line 988
      tmp___3 = strcmp((char const   *)word, (char const   *)tp->name);
#line 988
      tmp___4 = tmp___3;
      }
    }
#line 988
    if (tmp___4 == 0) {
#line 989
      return (tp);
    }
#line 987
    tp ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 991
  tmp___5 = lookup_zone(pc, (char const   *)word);
#line 991
  tp = (table const   *)tmp___5;
  }
#line 991
  if (tp) {
#line 992
    return (tp);
  }
  {
#line 994
  tmp___6 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
  }
#line 994
  if (tmp___6 == 0) {
#line 995
    return (dst_table);
  }
#line 997
  tp = time_units_table;
  {
#line 997
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 997
    if (! tp->name) {
#line 997
      goto while_break___2;
    }
    {
#line 998
    tmp___7 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 998
    if (tmp___7 == 0) {
#line 999
      return (tp);
    }
#line 997
    tp ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1002
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 1004
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 1005
    tp = time_units_table;
    {
#line 1005
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1005
      if (! tp->name) {
#line 1005
        goto while_break___3;
      }
      {
#line 1006
      tmp___8 = strcmp((char const   *)word, (char const   *)tp->name);
      }
#line 1006
      if (tmp___8 == 0) {
#line 1007
        return (tp);
      }
#line 1005
      tp ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1008
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 1011
  tp = relative_time_table;
  {
#line 1011
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1011
    if (! tp->name) {
#line 1011
      goto while_break___4;
    }
    {
#line 1012
    tmp___9 = strcmp((char const   *)word, (char const   *)tp->name);
    }
#line 1012
    if (tmp___9 == 0) {
#line 1013
      return (tp);
    }
#line 1011
    tp ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 1016
  if (wordlen == 1UL) {
#line 1017
    tp = military_table;
    {
#line 1017
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1017
      if (! tp->name) {
#line 1017
        goto while_break___5;
      }
#line 1018
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 1019
        return (tp);
      }
#line 1017
      tp ++;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 1022
  period_found = (_Bool)0;
#line 1022
  q = word;
#line 1022
  p = q;
  {
#line 1022
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1022
    tmp___10 = *q;
#line 1022
    *p = tmp___10;
#line 1022
    if (! tmp___10) {
#line 1022
      goto while_break___6;
    }
#line 1023
    if ((int )*q == 46) {
#line 1024
      period_found = (_Bool)1;
    } else {
#line 1026
      p ++;
    }
#line 1022
    q ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1027
  if (period_found) {
    {
#line 1027
    tmp___11 = lookup_zone(pc, (char const   *)word);
#line 1027
    tp = (table const   *)tmp___11;
    }
#line 1027
    if (tp) {
#line 1028
      return (tp);
    }
  }
#line 1030
  return ((table const   *)((void *)0));
}
}
#line 1033 "./parse-datetime.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  unsigned long value___0 ;
  _Bool tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  unsigned char tmp___9 ;
  char const   *tmp___10 ;

  {
  {
#line 1039
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1041
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1041
      c = (unsigned char )*(pc->input);
#line 1041
      tmp = c_isspace((int )c);
      }
#line 1041
      if (! tmp) {
#line 1041
        goto while_break___0;
      }
#line 1042
      (pc->input) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1044
    if ((unsigned int )c - 48U <= 9U) {
#line 1044
      goto _L___2;
    } else
#line 1044
    if ((int )c == 45) {
#line 1044
      goto _L___2;
    } else
#line 1044
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1049
      if ((int )c == 45) {
#line 1049
        goto _L;
      } else
#line 1049
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1051
        if ((int )c == 45) {
#line 1051
          sign = -1;
        } else {
#line 1051
          sign = 1;
        }
        {
#line 1052
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1052
          (pc->input) ++;
#line 1052
          c = (unsigned char )*(pc->input);
#line 1052
          tmp___0 = c_isspace((int )c);
          }
#line 1052
          if (! tmp___0) {
#line 1052
            goto while_break___1;
          }
#line 1053
          goto while_continue___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1054
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1056
          goto __Cont;
        }
      } else {
#line 1059
        sign = 0;
      }
#line 1060
      p = pc->input;
#line 1061
      value___0 = 0UL;
      {
#line 1061
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1063
        value1 = value___0 + (unsigned long )((int )c - 48);
#line 1064
        if (value1 < value___0) {
#line 1065
          return ('?');
        }
#line 1066
        value___0 = value1;
#line 1067
        p ++;
#line 1067
        c = (unsigned char )*p;
#line 1068
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1069
          goto while_break___2;
        }
#line 1070
        if (1844674407370955161UL < value___0) {
#line 1071
          return ('?');
        }
#line 1061
        value___0 *= 10UL;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1073
      if ((int )c == 46) {
#line 1073
        goto _L___1;
      } else
#line 1073
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
#line 1073
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1081
          if (sign < 0) {
#line 1083
            s = (time_t )(- value___0);
#line 1084
            if (0L < s) {
#line 1085
              return ('?');
            }
#line 1086
            value1___0 = (unsigned long )(- s);
          } else {
#line 1090
            s = (time_t )value___0;
#line 1091
            if (s < 0L) {
#line 1092
              return ('?');
            }
#line 1093
            value1___0 = (unsigned long )s;
          }
#line 1095
          if (value___0 != value1___0) {
#line 1096
            return ('?');
          }
#line 1099
          p ++;
#line 1100
          tmp___1 = p;
#line 1100
          p ++;
#line 1100
          ns = (int )((int const   )*tmp___1 - 48);
#line 1101
          digits = 2;
          {
#line 1101
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1101
            if (! (digits <= 9)) {
#line 1101
              goto while_break___3;
            }
#line 1103
            ns *= 10;
#line 1104
            if ((unsigned int )*p - 48U <= 9U) {
#line 1105
              tmp___2 = p;
#line 1105
              p ++;
#line 1105
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1101
            digits ++;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1109
          if (sign < 0) {
            {
#line 1110
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1110
              if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1110
                goto while_break___4;
              }
#line 1111
              if ((int const   )*p != 48) {
#line 1113
                ns ++;
#line 1114
                goto while_break___4;
              }
#line 1110
              p ++;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
          {
#line 1116
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1116
            if (! ((unsigned int )*p - 48U <= 9U)) {
#line 1116
              goto while_break___5;
            }
#line 1117
            p ++;
          }
          while_break___5: /* CIL Label */ ;
          }
#line 1122
          if (sign < 0) {
#line 1122
            if (ns) {
#line 1124
              s --;
#line 1125
              if (! (s < 0L)) {
#line 1126
                return ('?');
              }
#line 1127
              ns = 1000000000 - ns;
            }
          }
#line 1130
          lvalp->timespec.tv_sec = s;
#line 1131
          lvalp->timespec.tv_nsec = (__syscall_slong_t )ns;
#line 1132
          pc->input = p;
#line 1133
          if (sign) {
#line 1133
            tmp___3 = 276;
          } else {
#line 1133
            tmp___3 = 277;
          }
#line 1133
          return (tmp___3);
        } else {
#line 1073
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1137
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1138
        if (sign < 0) {
#line 1140
          lvalp->textintval.value = (long )(- value___0);
#line 1141
          if (0L < lvalp->textintval.value) {
#line 1142
            return ('?');
          }
        } else {
#line 1146
          lvalp->textintval.value = (long )value___0;
#line 1147
          if (lvalp->textintval.value < 0L) {
#line 1148
            return ('?');
          }
        }
#line 1150
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1151
        pc->input = p;
#line 1152
        if (sign) {
#line 1152
          tmp___4 = 274;
        } else {
#line 1152
          tmp___4 = 275;
        }
#line 1152
        return (tmp___4);
      }
    }
    {
#line 1156
    tmp___7 = c_isalpha((int )c);
    }
#line 1156
    if (tmp___7) {
#line 1159
      p___0 = buff;
      {
#line 1162
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1164
        if ((unsigned long )p___0 < (unsigned long )((buff + sizeof(buff)) - 1)) {
#line 1165
          tmp___5 = p___0;
#line 1165
          p___0 ++;
#line 1165
          *tmp___5 = (char )c;
        }
        {
#line 1166
        (pc->input) ++;
#line 1166
        c = (unsigned char )*(pc->input);
#line 1162
        tmp___6 = c_isalpha((int )c);
        }
#line 1162
        if (! tmp___6) {
#line 1162
          if (! ((int )c == 46)) {
#line 1162
            goto while_break___6;
          }
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1170
      *p___0 = (char )'\000';
#line 1171
      tp = lookup_word((parser_control const   *)pc, buff);
      }
#line 1172
      if (! tp) {
#line 1173
        return ('?');
      }
#line 1174
      lvalp->intval = (long )tp->value;
#line 1175
      return ((int )tp->type);
    }
#line 1178
    if ((int )c != 40) {
      {
#line 1179
      tmp___8 = pc->input;
#line 1179
      (pc->input) ++;
#line 1179
      tmp___9 = to_uchar((char )*tmp___8);
      }
#line 1179
      return ((int )tmp___9);
    }
#line 1181
    count = (size_t )0;
    {
#line 1182
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1184
      tmp___10 = pc->input;
#line 1184
      (pc->input) ++;
#line 1184
      c = (unsigned char )*tmp___10;
#line 1185
      if ((int )c == 0) {
#line 1186
        return ((int )c);
      }
#line 1187
      if ((int )c == 40) {
#line 1188
        count ++;
      } else
#line 1189
      if ((int )c == 41) {
#line 1190
        count --;
      }
#line 1182
      if (! (count != 0UL)) {
#line 1182
        goto while_break___7;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1197 "./parse-datetime.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1201
  return (0);
}
}
#line 1208 "./parse-datetime.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ 
  struct tm *tmp ;

  {
#line 1211
  if (t == -1L) {
    {
#line 1216
    tmp = localtime((time_t const   *)(& t));
#line 1216
    tm1 = (struct tm  const  *)tmp;
    }
#line 1217
    if (! tm1) {
#line 1218
      return ((_Bool)0);
    }
  }
#line 1221
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1235 "./parse-datetime.y"
static char *get_tz(char *tzbuf ) 
{ 
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1238
  tmp = getenv("TZ");
#line 1238
  tz = tmp;
  }
#line 1239
  if (tz) {
    {
#line 1241
    tmp___0 = strlen((char const   *)tz);
#line 1241
    tzsize = tmp___0 + 1UL;
    }
#line 1242
    if (tzsize <= 100UL) {
      {
#line 1242
      tmp___1 = memcpy((void */* __restrict  */)tzbuf, (void const   */* __restrict  */)tz,
                       tzsize);
#line 1242
      tz = (char *)tmp___1;
      }
    } else {
      {
#line 1242
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1242
      tz = (char *)tmp___2;
      }
    }
  }
#line 1246
  return (tz);
}
}
#line 1253 "./parse-datetime.y"
_Bool parse_datetime(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ 
  time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  relative_time __constr_expr_27 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___11 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  int year ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1265
  tz_was_altered = (_Bool)0;
#line 1266
  tz0 = (char *)((void *)0);
#line 1268
  ok = (_Bool)1;
#line 1270
  if (! now) {
    {
#line 1272
    gettime(& gettime_buffer);
#line 1273
    now = (struct timespec  const  *)(& gettime_buffer);
    }
  }
  {
#line 1276
  Start = (time_t )now->tv_sec;
#line 1277
  Start_ns = (long )now->tv_nsec;
#line 1279
  tmp___0 = localtime(& now->tv_sec);
#line 1279
  tmp = (struct tm  const  *)tmp___0;
  }
#line 1280
  if (! tmp) {
#line 1281
    return ((_Bool)0);
  }
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1283
    c = (unsigned char )*p;
#line 1283
    tmp___1 = c_isspace((int )c);
    }
#line 1283
    if (! tmp___1) {
#line 1283
      goto while_break;
    }
#line 1284
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1286
  tmp___6 = strncmp(p, "TZ=\"", (size_t )4);
  }
#line 1286
  if (tmp___6 == 0) {
#line 1288
    tzbase = p + 4;
#line 1289
    tzsize = (size_t )1;
#line 1292
    s = tzbase;
    {
#line 1292
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1292
      if (! *s) {
#line 1292
        goto while_break___0;
      }
#line 1293
      if ((int const   )*s == 92) {
#line 1295
        s ++;
#line 1296
        if (! ((int const   )*s == 92)) {
#line 1296
          if (! ((int const   )*s == 34)) {
#line 1297
            goto while_break___0;
          }
        }
      } else
#line 1299
      if ((int const   )*s == 34) {
        {
#line 1304
        large_tz = (_Bool )(100UL < tzsize);
#line 1306
        tz0 = get_tz((char *)(tz0buf));
        }
#line 1307
        if (large_tz) {
          {
#line 1307
          tmp___2 = xmalloc(tzsize);
#line 1307
          tz1 = (char *)tmp___2;
          }
        } else {
#line 1307
          tz1 = tz1buf;
        }
#line 1307
        z = tz1;
#line 1308
        s = tzbase;
        {
#line 1308
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1308
          if (! ((int const   )*s != 34)) {
#line 1308
            goto while_break___1;
          }
#line 1309
          tmp___3 = z;
#line 1309
          z ++;
#line 1309
          s += (int const   )*s == 92;
#line 1309
          *tmp___3 = (char )*s;
#line 1308
          s ++;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 1310
        *z = (char )'\000';
#line 1311
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
#line 1311
        setenv_ok = (_Bool )(tmp___4 == 0);
        }
#line 1312
        if (large_tz) {
          {
#line 1313
          free((void *)tz1);
          }
        }
#line 1314
        if (! setenv_ok) {
#line 1315
          goto fail;
        }
#line 1316
        tz_was_altered = (_Bool)1;
#line 1318
        p = s + 1;
        {
#line 1319
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1319
          c = (unsigned char )*p;
#line 1319
          tmp___5 = c_isspace((int )c);
          }
#line 1319
          if (! tmp___5) {
#line 1319
            goto while_break___2;
          }
#line 1320
          p ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1322
        goto while_break___0;
      }
#line 1292
      s ++;
#line 1292
      tzsize ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1329
  if ((int const   )*p == 0) {
#line 1330
    p = "0";
  }
#line 1332
  pc.input = p;
#line 1333
  pc.year.value = (long )tmp->tm_year;
#line 1334
  pc.year.value += 1900L;
#line 1335
  pc.year.digits = (size_t )0;
#line 1336
  pc.month = (long )(tmp->tm_mon + 1);
#line 1337
  pc.day = (long )tmp->tm_mday;
#line 1338
  pc.hour = (long )tmp->tm_hour;
#line 1339
  pc.minutes = (long )tmp->tm_min;
#line 1340
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1341
  pc.seconds.tv_nsec = Start_ns;
#line 1342
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1344
  pc.meridian = 2;
#line 1345
  __constr_expr_27.year = 0L;
#line 1345
  __constr_expr_27.month = 0L;
#line 1345
  __constr_expr_27.day = 0L;
#line 1345
  __constr_expr_27.hour = 0L;
#line 1345
  __constr_expr_27.minutes = 0L;
#line 1345
  __constr_expr_27.seconds = (long_time_t )0;
#line 1345
  __constr_expr_27.ns = 0L;
#line 1345
  pc.rel = __constr_expr_27;
#line 1346
  pc.timespec_seen = (_Bool)0;
#line 1347
  pc.rels_seen = (_Bool)0;
#line 1348
  pc.dates_seen = (size_t )0;
#line 1349
  pc.days_seen = (size_t )0;
#line 1350
  pc.times_seen = (size_t )0;
#line 1351
  pc.local_zones_seen = (size_t )0;
#line 1352
  pc.dsts_seen = (size_t )0;
#line 1353
  pc.zones_seen = (size_t )0;
#line 1356
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
#line 1357
  pc.local_time_zone_table[0].type = 269;
#line 1358
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
#line 1359
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1365
  quarter = 1;
  {
#line 1365
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1365
    if (! (quarter <= 3)) {
#line 1365
      goto while_break___3;
    }
    {
#line 1367
    probe = Start + (time_t )(quarter * 7776000);
#line 1368
    tmp___7 = localtime((time_t const   *)(& probe));
#line 1368
    probe_tm = (struct tm  const  *)tmp___7;
    }
#line 1369
    if (probe_tm) {
#line 1369
      if (probe_tm->tm_zone) {
#line 1369
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
#line 1373
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
#line 1374
          pc.local_time_zone_table[1].type = 269;
#line 1375
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
#line 1376
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1378
          goto while_break___3;
        }
      }
    }
#line 1365
    quarter ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1402
  if (pc.local_time_zone_table[0].name) {
#line 1402
    if (pc.local_time_zone_table[1].name) {
      {
#line 1402
      tmp___8 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
      }
#line 1402
      if (! tmp___8) {
#line 1409
        pc.local_time_zone_table[0].value = -1;
#line 1410
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
  {
#line 1413
  tmp___9 = yyparse(& pc);
  }
#line 1413
  if (tmp___9 != 0) {
#line 1414
    goto fail;
  }
#line 1416
  if (pc.timespec_seen) {
#line 1417
    *result = pc.seconds;
  } else {
#line 1420
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1422
      goto fail;
    }
    {
#line 1424
    tmp___10 = to_year(pc.year);
#line 1424
    tm.tm_year = (int )(tmp___10 - 1900L);
#line 1425
    tm.tm_mon = (int )(pc.month - 1L);
#line 1426
    tm.tm_mday = (int )pc.day;
    }
#line 1427
    if (pc.times_seen) {
#line 1427
      goto _L;
    } else
#line 1427
    if (pc.rels_seen) {
#line 1427
      if (! pc.dates_seen) {
#line 1427
        if (! pc.days_seen) {
          _L: /* CIL Label */ 
          {
#line 1429
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
          }
#line 1430
          if (tm.tm_hour < 0) {
#line 1431
            goto fail;
          }
#line 1432
          tm.tm_min = (int )pc.minutes;
#line 1433
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
#line 1437
          tm.tm_sec = 0;
#line 1437
          tm.tm_min = tm.tm_sec;
#line 1437
          tm.tm_hour = tm.tm_min;
#line 1438
          pc.seconds.tv_nsec = (__syscall_slong_t )0;
        }
      } else {
#line 1437
        tm.tm_sec = 0;
#line 1437
        tm.tm_min = tm.tm_sec;
#line 1437
        tm.tm_hour = tm.tm_min;
#line 1438
        pc.seconds.tv_nsec = (__syscall_slong_t )0;
      }
    } else {
#line 1437
      tm.tm_sec = 0;
#line 1437
      tm.tm_min = tm.tm_sec;
#line 1437
      tm.tm_hour = tm.tm_min;
#line 1438
      pc.seconds.tv_nsec = (__syscall_slong_t )0;
    }
#line 1442
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1443
      tm.tm_isdst = -1;
    }
#line 1447
    if (pc.local_zones_seen) {
#line 1448
      tm.tm_isdst = pc.local_isdst;
    }
    {
#line 1450
    tm0 = tm;
#line 1452
    Start = rpl_mktime(& tm);
#line 1454
    tmp___14 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
    }
#line 1454
    if (! tmp___14) {
#line 1456
      if (! pc.zones_seen) {
#line 1457
        goto fail;
      } else {
#line 1470
        time_zone = pc.time_zone;
#line 1471
        if (time_zone < 0L) {
#line 1471
          tmp___11 = - time_zone;
        } else {
#line 1471
          tmp___11 = time_zone;
        }
#line 1471
        abs_time_zone = tmp___11;
#line 1472
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1473
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1476
        if (! tz_was_altered) {
          {
#line 1477
          tz0 = get_tz((char *)(tz0buf));
          }
        }
        {
#line 1478
        sprintf((char */* __restrict  */)(tz1buf___0), (char const   */* __restrict  */)"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
#line 1480
        tmp___12 = setenv("TZ", (char const   *)(tz1buf___0), 1);
        }
#line 1480
        if (tmp___12 != 0) {
#line 1481
          goto fail;
        }
        {
#line 1482
        tz_was_altered = (_Bool)1;
#line 1483
        tm = tm0;
#line 1484
        Start = rpl_mktime(& tm);
#line 1485
        tmp___13 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
        }
#line 1485
        if (! tmp___13) {
#line 1486
          goto fail;
        }
      }
    }
#line 1490
    if (pc.days_seen) {
#line 1490
      if (! pc.dates_seen) {
#line 1492
        if (0L < pc.day_ordinal) {
#line 1492
          if (tm.tm_wday != pc.day_number) {
#line 1492
            tmp___15 = 1;
          } else {
#line 1492
            tmp___15 = 0;
          }
        } else {
#line 1492
          tmp___15 = 0;
        }
        {
#line 1492
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___15)));
#line 1496
        tm.tm_isdst = -1;
#line 1497
        Start = rpl_mktime(& tm);
        }
#line 1498
        if (Start == -1L) {
#line 1499
          goto fail;
        }
      }
    }
#line 1503
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1505
      year = (int )((long )tm.tm_year + pc.rel.year);
#line 1506
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1507
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1508
      if ((((year < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1511
        goto fail;
      }
      {
#line 1512
      tm.tm_year = year;
#line 1513
      tm.tm_mon = month;
#line 1514
      tm.tm_mday = day;
#line 1515
      tm.tm_hour = tm0.tm_hour;
#line 1516
      tm.tm_min = tm0.tm_min;
#line 1517
      tm.tm_sec = tm0.tm_sec;
#line 1518
      tm.tm_isdst = tm0.tm_isdst;
#line 1519
      Start = rpl_mktime(& tm);
      }
#line 1520
      if (Start == -1L) {
#line 1521
        goto fail;
      }
    }
#line 1526
    if (pc.zones_seen) {
#line 1528
      delta = pc.time_zone * 60L;
#line 1531
      delta -= tm.tm_gmtoff;
#line 1539
      t1 = Start - delta;
#line 1540
      if ((Start < t1) != (delta < 0L)) {
#line 1541
        goto fail;
      }
#line 1542
      Start = t1;
    }
#line 1553
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1554
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1555
    t0 = Start;
#line 1556
    d1 = 3600L * pc.rel.hour;
#line 1557
    t1___0 = t0 + d1;
#line 1558
    d2 = 60L * pc.rel.minutes;
#line 1559
    t2 = t1___0 + d2;
#line 1560
    d3 = pc.rel.seconds;
#line 1561
    t3 = t2 + d3;
#line 1562
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1563
    t4 = t3 + d4;
#line 1564
    t5 = t4;
#line 1566
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
#line 1573
      goto fail;
    }
#line 1575
    result->tv_sec = t5;
#line 1576
    result->tv_nsec = normalized_ns;
  }
#line 1580
  goto done;
  fail: 
#line 1583
  ok = (_Bool)0;
  done: 
#line 1585
  if (tz_was_altered) {
#line 1586
    if (tz0) {
      {
#line 1586
      tmp___16 = setenv("TZ", (char const   *)tz0, 1);
#line 1586
      tmp___18 = tmp___16;
      }
    } else {
      {
#line 1586
      tmp___17 = unsetenv("TZ");
#line 1586
      tmp___18 = tmp___17;
      }
    }
#line 1586
    ok = (_Bool )((int )ok & (tmp___18 == 0));
  }
#line 1587
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
    {
#line 1588
    free((void *)tz0);
    }
  }
#line 1589
  return (ok);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 141
extern DIR *fdopendir(int __fd ) ;
#line 224
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 20 "/home/khheo/project/benchmark/tar-1.29/gnu/unistd-safer.h"
int dup_safer(int fd ) ;
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
  }
#line 35
  if (dp) {
    {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
    }
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
        {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
        }
#line 53
        if (f < 0) {
          {
#line 55
          tmp___2 = __errno_location();
#line 55
          e = *tmp___2;
#line 56
          newdp = (DIR *)((void *)0);
          }
        } else {
          {
#line 60
          newdp = fdopendir(f);
#line 61
          tmp___3 = __errno_location();
#line 61
          e = *tmp___3;
          }
#line 62
          if (! newdp) {
            {
#line 63
            close(f);
            }
          }
        }
        {
#line 69
        closedir(dp);
#line 70
        tmp___4 = __errno_location();
#line 70
        *tmp___4 = e;
#line 71
        dp = newdp;
        }
      }
    }
  }
#line 75
  return (dp);
}
}
#line 290 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 50 "/home/khheo/project/benchmark/tar-1.29/gnu/openat-proc.c"
static int proc_status  =    0;
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/openat-proc.c"
char *openat_proc_name(char *buf , int fd , char const   *file ) 
{ 
  int proc_self_fd ;
  int tmp ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + (sizeof("../fd") - 1UL)) + 1UL] ;
  int tmp___1 ;
  size_t bufsize ;
  size_t tmp___2 ;
  char *result ;
  void *tmp___3 ;

  {
#line 53
  if (! *file) {
#line 55
    *(buf + 0) = (char )'\000';
#line 56
    return ((char *)buf);
  }
#line 59
  if (! proc_status) {
    {
#line 69
    tmp = open("/proc/self/fd", 67840);
#line 69
    proc_self_fd = tmp;
    }
#line 71
    if (proc_self_fd < 0) {
#line 72
      proc_status = -1;
    } else {
      {
#line 81
      sprintf((char */* __restrict  */)(dotdot_buf), (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
              proc_self_fd, "../fd");
#line 82
      tmp___1 = access((char const   *)(dotdot_buf), 0);
      }
#line 82
      if (tmp___1) {
#line 82
        proc_status = -1;
      } else {
#line 82
        proc_status = 1;
      }
      {
#line 83
      close(proc_self_fd);
      }
    }
  }
#line 87
  if (proc_status < 0) {
#line 88
    return ((char *)((void *)0));
  } else {
    {
#line 91
    tmp___2 = strlen(file);
#line 91
    bufsize = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) + tmp___2) + 1UL;
#line 92
    result = (char *)buf;
    }
#line 93
    if (4032UL < bufsize) {
      {
#line 95
      tmp___3 = malloc(bufsize);
#line 95
      result = (char *)tmp___3;
      }
#line 96
      if (! result) {
#line 97
        return ((char *)((void *)0));
      }
    }
    {
#line 99
    sprintf((char */* __restrict  */)result, (char const   */* __restrict  */)"/proc/self/fd/%d/%s",
            fd, file);
    }
#line 100
    return (result);
  }
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/openat-die.c"
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 33 "/home/khheo/project/benchmark/tar-1.29/gnu/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 37
  tmp = gettext("unable to record current working directory");
#line 37
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 44
  abort();
  }
}
}
#line 52
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;

  {
  {
#line 56
  tmp = gettext("failed to return to initial working directory");
#line 56
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 61
  abort();
  }
}
}
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 44 "/home/khheo/project/benchmark/tar-1.29/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf ) ;
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf ) 
{ 
  char *p ;

  {
#line 38
  p = buf + (((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0L) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48L - i % 10L);
#line 43
      i /= 10L;
#line 43
      if (! (i != 0L)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48L + i % 10L);
#line 51
      i /= 10L;
#line 51
      if (! (i != 0L)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 198 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.h"
void _obstack_newchunk(struct obstack *h , size_t length ) ;
#line 199
void _obstack_free(struct obstack *h , void *obj ) ;
#line 200
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) ;
#line 203
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg___0 ) ;
#line 207
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 215
void (*obstack_alloc_failed_handler)(void) ;
#line 614 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 83 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
static void *call_chunkfun(struct obstack *h , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 86
  if (h->use_extra_arg) {
    {
#line 87
    tmp = (*(h->chunkfun.extra))(h->extra_arg, size);
    }
#line 87
    return (tmp);
  } else {
    {
#line 89
    tmp___0 = (*(h->chunkfun.plain))(size);
    }
#line 89
    return (tmp___0);
  }
}
}
#line 92 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
static void call_freefun(struct obstack *h , void *old_chunk ) 
{ 


  {
#line 95
  if (h->use_extra_arg) {
    {
#line 96
    (*(h->freefun.extra))(h->extra_arg, old_chunk);
    }
  } else {
    {
#line 98
    (*(h->freefun.plain))(old_chunk);
    }
  }
#line 99
  return;
}
}
#line 108 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
static int _obstack_begin_worker(struct obstack *h , size_t size , size_t alignment ) 
{ 
  struct _obstack_chunk *chunk ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  int extra ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  unsigned long tmp___5 ;
  unsigned long tmp___7 ;
  unsigned long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  unsigned long tmp___15 ;
  unsigned long tmp___16 ;
  unsigned long tmp___17 ;
  struct _obstack_chunk *tmp___18 ;
  void *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 114
  if (alignment == 0UL) {
#line 115
    if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
      tmp___1 = __alignof__(uintmax_t );
    } else {
#line 115
      tmp___1 = __alignof__(void *);
    }
#line 115
    if (__alignof__(long double ) > tmp___1) {
#line 115
      alignment = __alignof__(long double );
    } else {
#line 115
      if (__alignof__(uintmax_t ) > __alignof__(void *)) {
#line 115
        tmp___0 = __alignof__(uintmax_t );
      } else {
#line 115
        tmp___0 = __alignof__(void *);
      }
#line 115
      alignment = tmp___0;
    }
  }
#line 116
  if (size == 0UL) {
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___5 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___5 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___5) {
#line 127
      tmp___4 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___3 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___3 = sizeof(void *);
      }
#line 127
      tmp___4 = tmp___3;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___9 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___9 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___9) {
#line 127
      tmp___8 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___7 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___7 = sizeof(void *);
      }
#line 127
      tmp___8 = tmp___7;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___13 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___13 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___13) {
#line 127
      tmp___12 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___11 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___11 = sizeof(void *);
      }
#line 127
      tmp___12 = tmp___11;
    }
#line 127
    if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
      tmp___17 = sizeof(uintmax_t );
    } else {
#line 127
      tmp___17 = sizeof(void *);
    }
#line 127
    if (sizeof(long double ) > tmp___17) {
#line 127
      tmp___16 = sizeof(long double );
    } else {
#line 127
      if (sizeof(uintmax_t ) > sizeof(void *)) {
#line 127
        tmp___15 = sizeof(uintmax_t );
      } else {
#line 127
        tmp___15 = sizeof(void *);
      }
#line 127
      tmp___16 = tmp___15;
    }
#line 127
    extra = (int )(((((((12UL + tmp___4) - 1UL) & ~ (tmp___8 - 1UL)) + 4UL) + tmp___12) - 1UL) & ~ (tmp___16 - 1UL));
#line 130
    size = (size_t )(4096 - extra);
  }
  {
#line 133
  h->chunk_size = size;
#line 134
  h->alignment_mask = alignment - 1UL;
#line 136
  tmp___19 = call_chunkfun(h, h->chunk_size);
#line 136
  tmp___18 = (struct _obstack_chunk *)tmp___19;
#line 136
  h->chunk = tmp___18;
#line 136
  chunk = tmp___18;
  }
#line 137
  if (! chunk) {
    {
#line 138
    (*obstack_alloc_failed_handler)();
    }
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___21 = (char *)chunk;
  } else {
#line 139
    tmp___21 = (char *)0;
  }
#line 139
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 139
    tmp___22 = (char *)chunk;
  } else {
#line 139
    tmp___22 = (char *)0;
  }
#line 139
  tmp___20 = tmp___21 + (((size_t )(chunk->contents - tmp___22) + (alignment - 1UL)) & ~ (alignment - 1UL));
#line 139
  h->object_base = tmp___20;
#line 139
  h->next_free = tmp___20;
#line 141
  tmp___23 = (char *)chunk + h->chunk_size;
#line 141
  chunk->limit = tmp___23;
#line 141
  h->chunk_limit = tmp___23;
#line 142
  chunk->prev = (struct _obstack_chunk *)0;
#line 144
  h->maybe_empty_object = 0U;
#line 145
  h->alloc_failed = 0U;
#line 146
  return (1);
}
}
#line 149 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
int _obstack_begin(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(size_t  ) ,
                   void (*freefun)(void * ) ) 
{ 
  int tmp ;

  {
  {
#line 155
  h->chunkfun.plain = chunkfun;
#line 156
  h->freefun.plain = freefun;
#line 157
  h->use_extra_arg = 0U;
#line 158
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 158
  return (tmp);
}
}
#line 161 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
int _obstack_begin_1(struct obstack *h , size_t size , size_t alignment , void *(*chunkfun)(void * ,
                                                                                            size_t  ) ,
                     void (*freefun)(void * , void * ) , void *arg___0 ) 
{ 
  int tmp ;

  {
  {
#line 168
  h->chunkfun.extra = chunkfun;
#line 169
  h->freefun.extra = freefun;
#line 170
  h->extra_arg = arg___0;
#line 171
  h->use_extra_arg = 1U;
#line 172
  tmp = _obstack_begin_worker(h, size, alignment);
  }
#line 172
  return (tmp);
}
}
#line 181 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
void _obstack_newchunk(struct obstack *h , size_t length ) 
{ 
  struct _obstack_chunk *old_chunk ;
  struct _obstack_chunk *new_chunk ;
  size_t obj_size ;
  char *object_base ;
  size_t sum1 ;
  size_t sum2 ;
  size_t new_size ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 184
  old_chunk = h->chunk;
#line 185
  new_chunk = (struct _obstack_chunk *)0;
#line 186
  obj_size = (size_t )(h->next_free - h->object_base);
#line 190
  sum1 = obj_size + length;
#line 191
  sum2 = sum1 + h->alignment_mask;
#line 192
  new_size = (sum2 + (obj_size >> 3)) + 100UL;
#line 193
  if (new_size < sum2) {
#line 194
    new_size = sum2;
  }
#line 195
  if (new_size < h->chunk_size) {
#line 196
    new_size = h->chunk_size;
  }
#line 199
  if (obj_size <= sum1) {
#line 199
    if (sum1 <= sum2) {
      {
#line 200
      tmp = call_chunkfun(h, new_size);
#line 200
      new_chunk = (struct _obstack_chunk *)tmp;
      }
    }
  }
#line 201
  if (! new_chunk) {
    {
#line 202
    (*obstack_alloc_failed_handler)();
    }
  }
#line 203
  h->chunk = new_chunk;
#line 204
  new_chunk->prev = old_chunk;
#line 205
  tmp___0 = (char *)new_chunk + new_size;
#line 205
  h->chunk_limit = tmp___0;
#line 205
  new_chunk->limit = tmp___0;
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___1 = (char *)new_chunk;
  } else {
#line 208
    tmp___1 = (char *)0;
  }
#line 208
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 208
    tmp___2 = (char *)new_chunk;
  } else {
#line 208
    tmp___2 = (char *)0;
  }
  {
#line 208
  object_base = tmp___1 + (((size_t )(new_chunk->contents - tmp___2) + h->alignment_mask) & ~ h->alignment_mask);
#line 212
  memcpy((void */* __restrict  */)object_base, (void const   */* __restrict  */)h->object_base,
         obj_size);
  }
#line 217
  if (! h->maybe_empty_object) {
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___3 = (char *)old_chunk;
    } else {
#line 217
      tmp___3 = (char *)0;
    }
#line 217
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 217
      tmp___4 = (char *)old_chunk;
    } else {
#line 217
      tmp___4 = (char *)0;
    }
#line 217
    if ((unsigned long )h->object_base == (unsigned long )(tmp___3 + (((size_t )(old_chunk->contents - tmp___4) + h->alignment_mask) & ~ h->alignment_mask))) {
      {
#line 222
      new_chunk->prev = old_chunk->prev;
#line 223
      call_freefun(h, (void *)old_chunk);
      }
    }
  }
#line 226
  h->object_base = object_base;
#line 227
  h->next_free = h->object_base + obj_size;
#line 229
  h->maybe_empty_object = 0U;
#line 230
  return;
}
}
#line 238
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240
int _obstack_allocated_p(struct obstack *h , void *obj )  __attribute__((__pure__)) ;
#line 240 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
int _obstack_allocated_p(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;

  {
#line 246
  lp = h->chunk;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 250
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 250
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 250
          goto while_break;
        }
      }
    } else {
#line 250
      goto while_break;
    }
#line 252
    plp = lp->prev;
#line 253
    lp = plp;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0));
}
}
#line 261 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
void _obstack_free(struct obstack *h , void *obj ) 
{ 
  struct _obstack_chunk *lp ;
  struct _obstack_chunk *plp ;
  char *tmp ;

  {
#line 267
  lp = h->chunk;
  {
#line 271
  while (1) {
    while_continue: /* CIL Label */ ;
#line 271
    if ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0)) {
#line 271
      if (! ((unsigned long )((void *)lp) >= (unsigned long )obj)) {
#line 271
        if (! ((unsigned long )((void *)lp->limit) < (unsigned long )obj)) {
#line 271
          goto while_break;
        }
      }
    } else {
#line 271
      goto while_break;
    }
    {
#line 273
    plp = lp->prev;
#line 274
    call_freefun(h, (void *)lp);
#line 275
    lp = plp;
#line 278
    h->maybe_empty_object = 1U;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  if (lp) {
#line 282
    tmp = (char *)obj;
#line 282
    h->next_free = tmp;
#line 282
    h->object_base = tmp;
#line 283
    h->chunk_limit = lp->limit;
#line 284
    h->chunk = lp;
  } else
#line 286
  if ((unsigned long )obj != (unsigned long )((void *)0)) {
    {
#line 288
    abort();
    }
  }
#line 289
  return;
}
}
#line 291
size_t _obstack_memory_used(struct obstack *h )  __attribute__((__pure__)) ;
#line 291 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
size_t _obstack_memory_used(struct obstack *h ) 
{ 
  struct _obstack_chunk *lp ;
  size_t nbytes ;

  {
#line 295
  nbytes = (size_t )0;
#line 297
  lp = h->chunk;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! ((unsigned long )lp != (unsigned long )((struct _obstack_chunk *)0))) {
#line 297
      goto while_break;
    }
#line 299
    nbytes += (size_t )(lp->limit - (char *)lp);
#line 297
    lp = lp->prev;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  return (nbytes);
}
}
#line 329
static  __attribute__((__noreturn__)) void print_and_abort(void) ;
#line 329 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
static void print_and_abort(void) 
{ 
  char *tmp ;

  {
  {
#line 340
  tmp = gettext("memory exhausted");
#line 340
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          tmp);
#line 342
  exit((int )exit_failure);
  }
}
}
#line 351 "/home/khheo/project/benchmark/tar-1.29/gnu/obstack.c"
void (*obstack_alloc_failed_handler)(void)  =    & print_and_abort;
#line 25 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.h"
struct mode_change *mode_compile(char const   *mode_string ) ;
#line 26
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
#line 27
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 53 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.c"
static mode_t octal_to_mode(unsigned int octal ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 58
  if (256 >> 3 == 32) {
#line 58
    if (128 >> 3 == 16) {
#line 58
      if (64 >> 3 == 8) {
#line 58
        if ((256 >> 3) >> 3 == 4) {
#line 58
          if ((128 >> 3) >> 3 == 2) {
#line 58
            if ((64 >> 3) >> 3 == 1) {
#line 58
              tmp___11 = octal;
            } else {
#line 58
              goto _L___3;
            }
          } else {
#line 58
            goto _L___3;
          }
        } else {
#line 58
          goto _L___3;
        }
      } else {
#line 58
        goto _L___3;
      }
    } else {
#line 58
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 58
    if (octal & 2048U) {
#line 58
      tmp = 2048;
    } else {
#line 58
      tmp = 0;
    }
#line 58
    if (octal & 1024U) {
#line 58
      tmp___0 = 1024;
    } else {
#line 58
      tmp___0 = 0;
    }
#line 58
    if (octal & 512U) {
#line 58
      tmp___1 = 512;
    } else {
#line 58
      tmp___1 = 0;
    }
#line 58
    if (octal & 256U) {
#line 58
      tmp___2 = 256;
    } else {
#line 58
      tmp___2 = 0;
    }
#line 58
    if (octal & 128U) {
#line 58
      tmp___3 = 128;
    } else {
#line 58
      tmp___3 = 0;
    }
#line 58
    if (octal & 64U) {
#line 58
      tmp___4 = 64;
    } else {
#line 58
      tmp___4 = 0;
    }
#line 58
    if (octal & 32U) {
#line 58
      tmp___5 = 256 >> 3;
    } else {
#line 58
      tmp___5 = 0;
    }
#line 58
    if (octal & 16U) {
#line 58
      tmp___6 = 128 >> 3;
    } else {
#line 58
      tmp___6 = 0;
    }
#line 58
    if (octal & 8U) {
#line 58
      tmp___7 = 64 >> 3;
    } else {
#line 58
      tmp___7 = 0;
    }
#line 58
    if (octal & 4U) {
#line 58
      tmp___8 = (256 >> 3) >> 3;
    } else {
#line 58
      tmp___8 = 0;
    }
#line 58
    if (octal & 2U) {
#line 58
      tmp___9 = (128 >> 3) >> 3;
    } else {
#line 58
      tmp___9 = 0;
    }
#line 58
    if (octal & 1U) {
#line 58
      tmp___10 = (64 >> 3) >> 3;
    } else {
#line 58
      tmp___10 = 0;
    }
#line 58
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
#line 58
  return (tmp___11);
}
}
#line 111 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.c"
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) 
{ 
  struct mode_change *p ;
  void *tmp ;

  {
  {
#line 114
  tmp = xmalloc(2UL * sizeof(*p));
#line 114
  p = (struct mode_change *)tmp;
#line 115
  p->op = (char )'=';
#line 116
  p->flag = (char)1;
#line 117
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 118
  p->value = new_mode;
#line 119
  p->mentioned = mentioned;
#line 120
  (p + 1)->flag = (char)0;
  }
#line 121
  return (p);
}
}
#line 133 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.c"
struct mode_change *mode_compile(char const   *mode_string ) 
{ 
  struct mode_change *mc ;
  size_t used ;
  char const   *p ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const   *tmp ;
  struct mode_change *tmp___0 ;
  size_t needed ;
  int tmp___1 ;
  void *tmp___2 ;
  mode_t affected ;
  char op ;
  char const   *tmp___3 ;
  mode_t value___0 ;
  mode_t mentioned___0 ;
  char flag ;
  struct mode_change *change ;
  unsigned int octal_mode___0 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 138
  used = (size_t )0;
#line 141
  if (48 <= (int )*mode_string) {
#line 141
    if ((int const   )*mode_string < 56) {
#line 143
      octal_mode = 0U;
#line 147
      p = mode_string;
      {
#line 148
      while (1) {
        while_continue: /* CIL Label */ ;
#line 150
        tmp = p;
#line 150
        p ++;
#line 150
        octal_mode = (8U * octal_mode + (unsigned int )*tmp) - 48U;
#line 151
        if (4095U < octal_mode) {
#line 152
          return ((struct mode_change *)((void *)0));
        }
#line 148
        if (48 <= (int )*p) {
#line 148
          if (! ((int const   )*p < 56)) {
#line 148
            goto while_break;
          }
        } else {
#line 148
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 156
      if (*p) {
#line 157
        return ((struct mode_change *)((void *)0));
      }
      {
#line 159
      mode = octal_to_mode(octal_mode);
      }
#line 160
      if (p - mode_string < 5L) {
#line 160
        mentioned = ((mode & 3072U) | 512U) | (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
      } else {
#line 160
        mentioned = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
      }
      {
#line 163
      tmp___0 = make_node_op_equals(mode, mentioned);
      }
#line 163
      return (tmp___0);
    }
  }
#line 168
  needed = (size_t )1;
#line 169
  p = mode_string;
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 169
    if (! *p) {
#line 169
      goto while_break___0;
    }
#line 170
    if ((int const   )*p == 61) {
#line 170
      tmp___1 = 1;
    } else
#line 170
    if ((int const   )*p == 43) {
#line 170
      tmp___1 = 1;
    } else
#line 170
    if ((int const   )*p == 45) {
#line 170
      tmp___1 = 1;
    } else {
#line 170
      tmp___1 = 0;
    }
#line 170
    needed += (size_t )tmp___1;
#line 169
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 171
  tmp___2 = xnmalloc(needed, sizeof(*mc));
#line 171
  mc = (struct mode_change *)tmp___2;
#line 176
  p = mode_string;
  }
  {
#line 176
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 179
    affected = (mode_t )0;
    {
#line 182
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 187
      if ((int const   )*p == 117) {
#line 187
        goto case_117;
      }
#line 190
      if ((int const   )*p == 103) {
#line 190
        goto case_103;
      }
#line 193
      if ((int const   )*p == 111) {
#line 193
        goto case_111;
      }
#line 196
      if ((int const   )*p == 97) {
#line 196
        goto case_97;
      }
#line 199
      if ((int const   )*p == 45) {
#line 199
        goto case_45;
      }
#line 199
      if ((int const   )*p == 43) {
#line 199
        goto case_45;
      }
#line 199
      if ((int const   )*p == 61) {
#line 199
        goto case_45;
      }
#line 185
      goto switch_default;
      switch_default: /* CIL Label */ 
#line 186
      goto invalid;
      case_117: /* CIL Label */ 
#line 188
      affected |= 2496U;
#line 189
      goto switch_break;
      case_103: /* CIL Label */ 
#line 191
      affected |= (unsigned int )(1024 | (448 >> 3));
#line 192
      goto switch_break;
      case_111: /* CIL Label */ 
#line 194
      affected |= (unsigned int )(512 | ((448 >> 3) >> 3));
#line 195
      goto switch_break;
      case_97: /* CIL Label */ 
#line 197
      affected |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 198
      goto switch_break;
      case_45: /* CIL Label */ 
      case_43: /* CIL Label */ 
      case_61: /* CIL Label */ 
#line 200
      goto no_more_affected;
      switch_break: /* CIL Label */ ;
      }
#line 182
      p ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    no_more_affected: ;
    {
#line 204
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 206
      tmp___3 = p;
#line 206
      p ++;
#line 206
      op = (char )*tmp___3;
#line 208
      mentioned___0 = (mode_t )0;
#line 209
      flag = (char)3;
      {
#line 215
      if ((int const   )*p == 55) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 54) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 53) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 52) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 51) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 50) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 49) {
#line 215
        goto case_55;
      }
#line 215
      if ((int const   )*p == 48) {
#line 215
        goto case_55;
      }
#line 235
      if ((int const   )*p == 117) {
#line 235
        goto case_117___0;
      }
#line 241
      if ((int const   )*p == 103) {
#line 241
        goto case_103___0;
      }
#line 247
      if ((int const   )*p == 111) {
#line 247
        goto case_111___0;
      }
#line 254
      goto switch_default___0;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 217
      octal_mode___0 = 0U;
      {
#line 219
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 221
        tmp___4 = p;
#line 221
        p ++;
#line 221
        octal_mode___0 = (8U * octal_mode___0 + (unsigned int )*tmp___4) - 48U;
#line 222
        if (4095U < octal_mode___0) {
#line 223
          goto invalid;
        }
#line 219
        if (48 <= (int )*p) {
#line 219
          if (! ((int const   )*p < 56)) {
#line 219
            goto while_break___4;
          }
        } else {
#line 219
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 227
      if (affected) {
#line 228
        goto invalid;
      } else
#line 227
      if (*p) {
#line 227
        if ((int const   )*p != 44) {
#line 228
          goto invalid;
        }
      }
      {
#line 229
      mentioned___0 = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 229
      affected = mentioned___0;
#line 230
      value___0 = octal_to_mode(octal_mode___0);
#line 231
      flag = (char)1;
      }
#line 232
      goto switch_break___0;
      case_117___0: /* CIL Label */ 
#line 238
      value___0 = (mode_t )448;
#line 239
      p ++;
#line 240
      goto switch_break___0;
      case_103___0: /* CIL Label */ 
#line 244
      value___0 = (mode_t )(448 >> 3);
#line 245
      p ++;
#line 246
      goto switch_break___0;
      case_111___0: /* CIL Label */ 
#line 250
      value___0 = (mode_t )((448 >> 3) >> 3);
#line 251
      p ++;
#line 252
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 255
      value___0 = (mode_t )0;
#line 256
      flag = (char)1;
      {
#line 258
      while (1) {
        while_continue___5: /* CIL Label */ ;
        {
#line 261
        if ((int const   )*p == 114) {
#line 261
          goto case_114;
        }
#line 264
        if ((int const   )*p == 119) {
#line 264
          goto case_119;
        }
#line 267
        if ((int const   )*p == 120) {
#line 267
          goto case_120;
        }
#line 270
        if ((int const   )*p == 88) {
#line 270
          goto case_88;
        }
#line 273
        if ((int const   )*p == 115) {
#line 273
          goto case_115;
        }
#line 277
        if ((int const   )*p == 116) {
#line 277
          goto case_116;
        }
#line 281
        goto switch_default___1;
        case_114: /* CIL Label */ 
#line 262
        value___0 |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 263
        goto switch_break___1;
        case_119: /* CIL Label */ 
#line 265
        value___0 |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3));
#line 266
        goto switch_break___1;
        case_120: /* CIL Label */ 
#line 268
        value___0 |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
#line 269
        goto switch_break___1;
        case_88: /* CIL Label */ 
#line 271
        flag = (char)2;
#line 272
        goto switch_break___1;
        case_115: /* CIL Label */ 
#line 275
        value___0 |= 3072U;
#line 276
        goto switch_break___1;
        case_116: /* CIL Label */ 
#line 279
        value___0 |= 512U;
#line 280
        goto switch_break___1;
        switch_default___1: /* CIL Label */ 
#line 282
        goto no_more_values;
        switch_break___1: /* CIL Label */ ;
        }
#line 258
        p ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      no_more_values: ;
      switch_break___0: /* CIL Label */ ;
      }
#line 287
      tmp___5 = used;
#line 287
      used ++;
#line 287
      change = mc + tmp___5;
#line 288
      change->op = op;
#line 289
      change->flag = flag;
#line 290
      change->affected = affected;
#line 291
      change->value = value___0;
#line 292
      if (mentioned___0) {
#line 292
        change->mentioned = mentioned___0;
      } else {
#line 292
        if (affected) {
#line 292
          tmp___6 = affected & value___0;
        } else {
#line 292
          tmp___6 = value___0;
        }
#line 292
        change->mentioned = tmp___6;
      }
#line 204
      if (! ((int const   )*p == 61)) {
#line 204
        if (! ((int const   )*p == 43)) {
#line 204
          if (! ((int const   )*p == 45)) {
#line 204
            goto while_break___3;
          }
        }
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 297
    if ((int const   )*p != 44) {
#line 298
      goto while_break___1;
    }
#line 176
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 301
  if ((int const   )*p == 0) {
#line 303
    (mc + used)->flag = (char)0;
#line 304
    return (mc);
  }
  invalid: 
  {
#line 308
  free((void *)mc);
  }
#line 309
  return ((struct mode_change *)((void *)0));
}
}
#line 315 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.c"
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ 
  struct stat ref_stats ;
  int tmp ;
  struct mode_change *tmp___0 ;

  {
  {
#line 320
  tmp = stat((char const   */* __restrict  */)ref_file, (struct stat */* __restrict  */)(& ref_stats));
  }
#line 320
  if (tmp != 0) {
#line 321
    return ((struct mode_change *)((void *)0));
  }
  {
#line 322
  tmp___0 = make_node_op_equals(ref_stats.st_mode, (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
  }
#line 322
  return (tmp___0);
}
}
#line 338 "/home/khheo/project/benchmark/tar-1.29/gnu/modechange.c"
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) 
{ 
  mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  int tmp ;
  mode_t value___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  mode_t preserved ;
  mode_t tmp___4 ;

  {
#line 343
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 346
  mode_bits = (mode_t )0;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! ((int const   )changes->flag != 0)) {
#line 348
      goto while_break;
    }
#line 350
    affected = (mode_t )changes->affected;
#line 351
    if (dir) {
#line 351
      tmp = 3072;
    } else {
#line 351
      tmp = 0;
    }
#line 351
    omit_change = (mode_t )((unsigned int const   )tmp & ~ changes->mentioned);
#line 353
    value___0 = (mode_t )changes->value;
    {
#line 357
    if ((int const   )changes->flag == 1) {
#line 357
      goto case_1;
    }
#line 360
    if ((int const   )changes->flag == 3) {
#line 360
      goto case_3;
    }
#line 373
    if ((int const   )changes->flag == 2) {
#line 373
      goto case_2;
    }
#line 355
    goto switch_break;
    case_1: /* CIL Label */ 
#line 358
    goto switch_break;
    case_3: /* CIL Label */ 
#line 362
    value___0 &= newmode;
#line 365
    if (value___0 & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
#line 365
      tmp___0 = (256 | (256 >> 3)) | ((256 >> 3) >> 3);
    } else {
#line 365
      tmp___0 = 0;
    }
#line 365
    if (value___0 & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) {
#line 365
      tmp___1 = (128 | (128 >> 3)) | ((128 >> 3) >> 3);
    } else {
#line 365
      tmp___1 = 0;
    }
#line 365
    if (value___0 & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 365
      tmp___2 = (64 | (64 >> 3)) | ((64 >> 3) >> 3);
    } else {
#line 365
      tmp___2 = 0;
    }
#line 365
    value___0 |= (unsigned int )((tmp___0 | tmp___1) | tmp___2);
#line 371
    goto switch_break;
    case_2: /* CIL Label */ 
#line 376
    if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) | (unsigned int )dir) {
#line 377
      value___0 |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
    }
#line 378
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 384
    if (affected) {
#line 384
      tmp___3 = affected;
    } else {
#line 384
      tmp___3 = ~ umask_value;
    }
#line 384
    value___0 &= tmp___3 & ~ omit_change;
    {
#line 388
    if ((int const   )changes->op == 61) {
#line 388
      goto case_61;
    }
#line 399
    if ((int const   )changes->op == 43) {
#line 399
      goto case_43;
    }
#line 404
    if ((int const   )changes->op == 45) {
#line 404
      goto case_45;
    }
#line 386
    goto switch_break___0;
    case_61: /* CIL Label */ 
#line 393
    if (affected) {
#line 393
      tmp___4 = ~ affected;
    } else {
#line 393
      tmp___4 = (mode_t )0;
    }
#line 393
    preserved = tmp___4 | omit_change;
#line 394
    mode_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ preserved;
#line 395
    newmode = (newmode & preserved) | value___0;
#line 396
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 400
    mode_bits |= value___0;
#line 401
    newmode |= value___0;
#line 402
    goto switch_break___0;
    case_45: /* CIL Label */ 
#line 405
    mode_bits |= value___0;
#line 406
    newmode &= ~ value___0;
#line 407
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 348
    changes ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  if (pmode_bits) {
#line 412
    *pmode_bits = mode_bits;
  }
#line 413
  return (newmode);
}
}
#line 64 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
#pragma GCC optimize ("wrapv")
#line 145 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static int leapyear(long_int year ) 
{ 
  int tmp ;

  {
#line 150
  if ((year & 3L) == 0L) {
#line 150
    if (year % 100L != 0L) {
#line 150
      tmp = 1;
    } else
#line 150
    if ((year / 100L & 3L) == 1L) {
#line 150
      tmp = 1;
    } else {
#line 150
      tmp = 0;
    }
  } else {
#line 150
    tmp = 0;
  }
#line 150
  return (tmp);
}
}
#line 158 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static unsigned short const   __mon_yday[2][13]  = { {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )59,        (unsigned short const   )90, 
            (unsigned short const   )120,        (unsigned short const   )151,        (unsigned short const   )181,        (unsigned short const   )212, 
            (unsigned short const   )243,        (unsigned short const   )273,        (unsigned short const   )304,        (unsigned short const   )334, 
            (unsigned short const   )365}, 
   {        (unsigned short const   )0,        (unsigned short const   )31,        (unsigned short const   )60,        (unsigned short const   )91, 
            (unsigned short const   )121,        (unsigned short const   )152,        (unsigned short const   )182,        (unsigned short const   )213, 
            (unsigned short const   )244,        (unsigned short const   )274,        (unsigned short const   )305,        (unsigned short const   )335, 
            (unsigned short const   )366}};
#line 2 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime-internal.h"
time_t mktime_internal(struct tm *tp , struct tm *(*convert)(time_t const   * , struct tm * ) ,
                       time_t *offset ) ;
#line 182 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static int isdst_differ___0(int a , int b ) 
{ 
  int tmp ;

  {
#line 185
  if (! a != ! b) {
#line 185
    if (0 <= a) {
#line 185
      if (0 <= b) {
#line 185
        tmp = 1;
      } else {
#line 185
        tmp = 0;
      }
    } else {
#line 185
      tmp = 0;
    }
  } else {
#line 185
    tmp = 0;
  }
#line 185
  return (tmp);
}
}
#line 199 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static time_t ydhms_diff(long_int year1 , long_int yday1 , int hour1 , int min1 ,
                         int sec1 , int year0 , int yday0 , int hour0 , int min0 ,
                         int sec0 ) 
{ 
  int a4 ;
  long_int tmp ;
  int tmp___0 ;
  int b4 ;
  int tmp___1 ;
  int tmp___2 ;
  int a100 ;
  int b100 ;
  int a400 ;
  int tmp___3 ;
  int b400 ;
  int tmp___4 ;
  int intervening_leap_days ;
  time_t tyear1 ;
  time_t years ;
  time_t days ;
  time_t hours ;
  time_t minutes ;
  time_t seconds ;

  {
#line 207
  if (-1 >> 1 == -1) {
#line 207
    if (-1L >> 1 == -1L) {
#line 207
      if (-1L >> 1 == -1L) {
#line 207
        tmp = year1 >> 2;
      } else {
#line 207
        tmp = year1 / (long_int )(1 << 2) - (long_int )(year1 % (long )(1 << 2) < 0L);
      }
    } else {
#line 207
      tmp = year1 / (long_int )(1 << 2) - (long_int )(year1 % (long )(1 << 2) < 0L);
    }
  } else {
#line 207
    tmp = year1 / (long_int )(1 << 2) - (long_int )(year1 % (long )(1 << 2) < 0L);
  }
#line 207
  if (-1 >> 1 == -1) {
#line 207
    if (-1L >> 1 == -1L) {
#line 207
      if (-1L >> 1 == -1L) {
#line 207
        tmp___0 = 1900 >> 2;
      } else {
#line 207
        tmp___0 = 1900 / (1 << 2) - (1900 % (1 << 2) < 0);
      }
    } else {
#line 207
      tmp___0 = 1900 / (1 << 2) - (1900 % (1 << 2) < 0);
    }
  } else {
#line 207
    tmp___0 = 1900 / (1 << 2) - (1900 % (1 << 2) < 0);
  }
#line 207
  a4 = (int )((tmp + (long_int )tmp___0) - (long_int )(! (year1 & 3L)));
#line 208
  if (-1 >> 1 == -1) {
#line 208
    if (-1L >> 1 == -1L) {
#line 208
      if (-1L >> 1 == -1L) {
#line 208
        tmp___1 = year0 >> 2;
      } else {
#line 208
        tmp___1 = year0 / (1 << 2) - (year0 % (1 << 2) < 0);
      }
    } else {
#line 208
      tmp___1 = year0 / (1 << 2) - (year0 % (1 << 2) < 0);
    }
  } else {
#line 208
    tmp___1 = year0 / (1 << 2) - (year0 % (1 << 2) < 0);
  }
#line 208
  if (-1 >> 1 == -1) {
#line 208
    if (-1L >> 1 == -1L) {
#line 208
      if (-1L >> 1 == -1L) {
#line 208
        tmp___2 = 1900 >> 2;
      } else {
#line 208
        tmp___2 = 1900 / (1 << 2) - (1900 % (1 << 2) < 0);
      }
    } else {
#line 208
      tmp___2 = 1900 / (1 << 2) - (1900 % (1 << 2) < 0);
    }
  } else {
#line 208
    tmp___2 = 1900 / (1 << 2) - (1900 % (1 << 2) < 0);
  }
#line 208
  b4 = (tmp___1 + tmp___2) - ! (year0 & 3);
#line 209
  a100 = a4 / 25 - (a4 % 25 < 0);
#line 210
  b100 = b4 / 25 - (b4 % 25 < 0);
#line 211
  if (-1 >> 1 == -1) {
#line 211
    if (-1L >> 1 == -1L) {
#line 211
      if (-1L >> 1 == -1L) {
#line 211
        tmp___3 = a100 >> 2;
      } else {
#line 211
        tmp___3 = a100 / (1 << 2) - (a100 % (1 << 2) < 0);
      }
    } else {
#line 211
      tmp___3 = a100 / (1 << 2) - (a100 % (1 << 2) < 0);
    }
  } else {
#line 211
    tmp___3 = a100 / (1 << 2) - (a100 % (1 << 2) < 0);
  }
#line 211
  a400 = tmp___3;
#line 212
  if (-1 >> 1 == -1) {
#line 212
    if (-1L >> 1 == -1L) {
#line 212
      if (-1L >> 1 == -1L) {
#line 212
        tmp___4 = b100 >> 2;
      } else {
#line 212
        tmp___4 = b100 / (1 << 2) - (b100 % (1 << 2) < 0);
      }
    } else {
#line 212
      tmp___4 = b100 / (1 << 2) - (b100 % (1 << 2) < 0);
    }
  } else {
#line 212
    tmp___4 = b100 / (1 << 2) - (b100 % (1 << 2) < 0);
  }
#line 212
  b400 = tmp___4;
#line 213
  intervening_leap_days = ((a4 - b4) - (a100 - b100)) + (a400 - b400);
#line 217
  tyear1 = year1;
#line 218
  years = tyear1 - (time_t )year0;
#line 219
  days = ((365L * years + yday1) - (time_t )yday0) + (time_t )intervening_leap_days;
#line 220
  hours = (24L * days + (time_t )hour1) - (time_t )hour0;
#line 221
  minutes = (60L * hours + (time_t )min1) - (time_t )min0;
#line 222
  seconds = (60L * minutes + (time_t )sec1) - (time_t )sec0;
#line 223
  return (seconds);
}
}
#line 227 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static time_t time_t_avg(time_t a , time_t b ) 
{ 
  time_t tmp ;
  time_t tmp___0 ;

  {
#line 230
  if (-1 >> 1 == -1) {
#line 230
    if (-1L >> 1 == -1L) {
#line 230
      if (-1L >> 1 == -1L) {
#line 230
        tmp = a >> 1;
      } else {
#line 230
        tmp = a / (time_t )(1 << 1) - (time_t )(a % (long )(1 << 1) < 0L);
      }
    } else {
#line 230
      tmp = a / (time_t )(1 << 1) - (time_t )(a % (long )(1 << 1) < 0L);
    }
  } else {
#line 230
    tmp = a / (time_t )(1 << 1) - (time_t )(a % (long )(1 << 1) < 0L);
  }
#line 230
  if (-1 >> 1 == -1) {
#line 230
    if (-1L >> 1 == -1L) {
#line 230
      if (-1L >> 1 == -1L) {
#line 230
        tmp___0 = b >> 1;
      } else {
#line 230
        tmp___0 = b / (time_t )(1 << 1) - (time_t )(b % (long )(1 << 1) < 0L);
      }
    } else {
#line 230
      tmp___0 = b / (time_t )(1 << 1) - (time_t )(b % (long )(1 << 1) < 0L);
    }
  } else {
#line 230
    tmp___0 = b / (time_t )(1 << 1) - (time_t )(b % (long )(1 << 1) < 0L);
  }
#line 230
  return ((tmp + tmp___0) + ((a & b) & 1L));
}
}
#line 236 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static int time_t_add_ok(time_t a , time_t b ) 
{ 
  time_t sum___0 ;

  {
#line 246
  sum___0 = a + b;
#line 247
  return ((sum___0 < a) == (b < 0L));
}
}
#line 257 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static int time_t_int_add_ok(time_t a , int b ) 
{ 
  time_t sum ;

  {
#line 263
  sum = a + (time_t )b;
#line 264
  return ((sum < a) == (b < 0));
}
}
#line 280 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static time_t guess_time_tm(long_int year , long_int yday , int hour , int min , int sec ,
                            time_t const   *t , struct tm  const  *tp ) 
{ 
  time_t d ;
  time_t tmp ;
  int tmp___0 ;
  time_t tmp___2 ;
  time_t tmp___3 ;
  time_t tmp___4 ;
  time_t tmp___5 ;

  {
#line 284
  if (tp) {
    {
#line 286
    tmp = ydhms_diff(year, yday, hour, min, sec, (int )tp->tm_year, (int )tp->tm_yday,
                     (int )tp->tm_hour, (int )tp->tm_min, (int )tp->tm_sec);
#line 286
    d = tmp;
#line 289
    tmp___0 = time_t_add_ok((time_t )*t, d);
    }
#line 289
    if (tmp___0) {
#line 290
      return ((time_t )(*t + (time_t const   )d));
    }
  }
#line 298
  if (-1 >> 1 == -1) {
#line 298
    if (-1L >> 1 == -1L) {
#line 298
      if (-1L >> 1 == -1L) {
#line 298
        tmp___5 = (~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) >> 1;
      } else {
#line 298
        tmp___5 = (~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) / (time_t )(1 << 1) - (time_t )((~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) % (long )(1 << 1) < 0L);
      }
    } else {
#line 298
      tmp___5 = (~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) / (time_t )(1 << 1) - (time_t )((~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) % (long )(1 << 1) < 0L);
    }
  } else {
#line 298
    tmp___5 = (~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) / (time_t )(1 << 1) - (time_t )((~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) % (long )(1 << 1) < 0L);
  }
#line 298
  if (*t < (time_t const   )(tmp___5 + 1L)) {
#line 298
    if (*t <= (time_t const   )(~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) + 1L)) {
#line 298
      tmp___2 = *t + 1L;
    } else {
#line 298
      tmp___2 = (time_t const   )(~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
    }
#line 298
    tmp___4 = tmp___2;
  } else {
#line 298
    if ((((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) - 1L <= (time_t )*t) {
#line 298
      tmp___3 = *t - 1L;
    } else {
#line 298
      tmp___3 = (time_t const   )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
    }
#line 298
    tmp___4 = tmp___3;
  }
#line 298
  return ((time_t )tmp___4);
}
}
#line 306 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static struct tm *ranged_convert(struct tm *(*convert)(time_t const   * , struct tm * ) ,
                                 time_t *t , struct tm *tp ) 
{ 
  struct tm *r ;
  struct tm *tmp ;
  time_t bad ;
  time_t ok ;
  time_t mid ;
  time_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 310
  tmp = (*convert)((time_t const   *)t, tp);
#line 310
  r = tmp;
  }
#line 312
  if (! r) {
#line 312
    if (*t) {
#line 314
      bad = *t;
#line 315
      ok = (time_t )0;
      {
#line 320
      while (1) {
        while_continue: /* CIL Label */ ;
#line 320
        if (bad < 0L) {
#line 320
          tmp___1 = -1;
        } else {
#line 320
          tmp___1 = 1;
        }
#line 320
        if (! (bad != ok + (time_t )tmp___1)) {
#line 320
          goto while_break;
        }
        {
#line 322
        tmp___0 = time_t_avg(ok, bad);
#line 322
        *t = tmp___0;
#line 322
        mid = tmp___0;
#line 323
        r = (*convert)((time_t const   *)t, tp);
        }
#line 324
        if (r) {
#line 325
          ok = mid;
        } else {
#line 327
          bad = mid;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 330
      if (! r) {
#line 330
        if (ok) {
          {
#line 334
          *t = ok;
#line 335
          r = (*convert)((time_t const   *)t, tp);
          }
        }
      }
    }
  }
#line 339
  return (r);
}
}
#line 349 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
time_t mktime_internal(struct tm *tp , struct tm *(*convert)(time_t const   * , struct tm * ) ,
                       time_t *offset ) 
{ 
  time_t t ;
  time_t gt ;
  time_t t0 ;
  time_t t1 ;
  time_t t2 ;
  struct tm tm ;
  int remaining_probes ;
  int sec ;
  int min ;
  int hour ;
  int mday ;
  int mon ;
  int year_requested ;
  int isdst ;
  int dst2 ;
  int mon_remainder ;
  int negative_mon_remainder ;
  int mon_years ;
  long_int lyear_requested ;
  long_int year ;
  int mon_yday ;
  int tmp ;
  long_int lmday ;
  long_int yday ;
  time_t guessed_offset ;
  int sec_requested ;
  int ALOG2_SECONDS_PER_BIENNIUM ;
  int ALOG2_MINUTES_PER_BIENNIUM ;
  int ALOG2_HOURS_PER_BIENNIUM ;
  int ALOG2_DAYS_PER_BIENNIUM ;
  int LOG2_YEARS_PER_BIENNIUM ;
  int approx_requested_biennia ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int approx_biennia ;
  time_t tmp___6 ;
  int diff ;
  int approx_abs_diff ;
  int tmp___7 ;
  time_t time_t_max ;
  time_t time_t_min ;
  time_t overflow_threshold ;
  time_t repaired_t0 ;
  int tmp___8 ;
  struct tm *tmp___9 ;
  int stride ;
  int duration_max ;
  int delta_bound ;
  int delta ;
  int direction ;
  time_t ot ;
  struct tm otm ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int sec_adjustment ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct tm *tmp___16 ;

  {
  {
#line 361
  remaining_probes = 6;
#line 365
  sec = tp->tm_sec;
#line 366
  min = tp->tm_min;
#line 367
  hour = tp->tm_hour;
#line 368
  mday = tp->tm_mday;
#line 369
  mon = tp->tm_mon;
#line 370
  year_requested = tp->tm_year;
#line 371
  isdst = tp->tm_isdst;
#line 377
  mon_remainder = mon % 12;
#line 378
  negative_mon_remainder = mon_remainder < 0;
#line 379
  mon_years = mon / 12 - negative_mon_remainder;
#line 380
  lyear_requested = (long_int )year_requested;
#line 381
  year = lyear_requested + (long_int )mon_years;
#line 390
  tmp = leapyear(year);
#line 390
  mon_yday = (int )((int const   )__mon_yday[tmp][mon_remainder + 12 * negative_mon_remainder] - 1);
#line 393
  lmday = (long_int )mday;
#line 394
  yday = (long_int )mon_yday + lmday;
#line 396
  guessed_offset = *offset;
#line 398
  sec_requested = sec;
  }
#line 404
  if (sec < 0) {
#line 405
    sec = 0;
  }
#line 406
  if (59 < sec) {
#line 407
    sec = 59;
  }
  {
#line 413
  t0 = ydhms_diff(year, yday, hour, min, sec, 70, 0, 0, 0, (int )(- guessed_offset));
  }
#line 416
  if ((((((((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) / 2147483647L) / 366L) / 24L) / 60L) / 60L < 3L) {
#line 430
    ALOG2_SECONDS_PER_BIENNIUM = 26;
#line 431
    ALOG2_MINUTES_PER_BIENNIUM = 20;
#line 432
    ALOG2_HOURS_PER_BIENNIUM = 14;
#line 433
    ALOG2_DAYS_PER_BIENNIUM = 10;
#line 434
    LOG2_YEARS_PER_BIENNIUM = 1;
#line 436
    if (-1 >> 1 == -1) {
#line 436
      if (-1L >> 1 == -1L) {
#line 436
        if (-1L >> 1 == -1L) {
#line 436
          tmp___0 = year_requested >> LOG2_YEARS_PER_BIENNIUM;
        } else {
#line 436
          tmp___0 = year_requested / (1 << LOG2_YEARS_PER_BIENNIUM) - (year_requested % (1 << LOG2_YEARS_PER_BIENNIUM) < 0);
        }
      } else {
#line 436
        tmp___0 = year_requested / (1 << LOG2_YEARS_PER_BIENNIUM) - (year_requested % (1 << LOG2_YEARS_PER_BIENNIUM) < 0);
      }
    } else {
#line 436
      tmp___0 = year_requested / (1 << LOG2_YEARS_PER_BIENNIUM) - (year_requested % (1 << LOG2_YEARS_PER_BIENNIUM) < 0);
    }
#line 436
    if (-1 >> 1 == -1) {
#line 436
      if (-1L >> 1 == -1L) {
#line 436
        if (-1L >> 1 == -1L) {
#line 436
          tmp___1 = 70 >> LOG2_YEARS_PER_BIENNIUM;
        } else {
#line 436
          tmp___1 = 70 / (1 << LOG2_YEARS_PER_BIENNIUM) - (70 % (1 << LOG2_YEARS_PER_BIENNIUM) < 0);
        }
      } else {
#line 436
        tmp___1 = 70 / (1 << LOG2_YEARS_PER_BIENNIUM) - (70 % (1 << LOG2_YEARS_PER_BIENNIUM) < 0);
      }
    } else {
#line 436
      tmp___1 = 70 / (1 << LOG2_YEARS_PER_BIENNIUM) - (70 % (1 << LOG2_YEARS_PER_BIENNIUM) < 0);
    }
#line 436
    if (-1 >> 1 == -1) {
#line 436
      if (-1L >> 1 == -1L) {
#line 436
        if (-1L >> 1 == -1L) {
#line 436
          tmp___2 = mday >> ALOG2_DAYS_PER_BIENNIUM;
        } else {
#line 436
          tmp___2 = mday / (1 << ALOG2_DAYS_PER_BIENNIUM) - (mday % (1 << ALOG2_DAYS_PER_BIENNIUM) < 0);
        }
      } else {
#line 436
        tmp___2 = mday / (1 << ALOG2_DAYS_PER_BIENNIUM) - (mday % (1 << ALOG2_DAYS_PER_BIENNIUM) < 0);
      }
    } else {
#line 436
      tmp___2 = mday / (1 << ALOG2_DAYS_PER_BIENNIUM) - (mday % (1 << ALOG2_DAYS_PER_BIENNIUM) < 0);
    }
#line 436
    if (-1 >> 1 == -1) {
#line 436
      if (-1L >> 1 == -1L) {
#line 436
        if (-1L >> 1 == -1L) {
#line 436
          tmp___3 = hour >> ALOG2_HOURS_PER_BIENNIUM;
        } else {
#line 436
          tmp___3 = hour / (1 << ALOG2_HOURS_PER_BIENNIUM) - (hour % (1 << ALOG2_HOURS_PER_BIENNIUM) < 0);
        }
      } else {
#line 436
        tmp___3 = hour / (1 << ALOG2_HOURS_PER_BIENNIUM) - (hour % (1 << ALOG2_HOURS_PER_BIENNIUM) < 0);
      }
    } else {
#line 436
      tmp___3 = hour / (1 << ALOG2_HOURS_PER_BIENNIUM) - (hour % (1 << ALOG2_HOURS_PER_BIENNIUM) < 0);
    }
#line 436
    if (-1 >> 1 == -1) {
#line 436
      if (-1L >> 1 == -1L) {
#line 436
        if (-1L >> 1 == -1L) {
#line 436
          tmp___4 = min >> ALOG2_MINUTES_PER_BIENNIUM;
        } else {
#line 436
          tmp___4 = min / (1 << ALOG2_MINUTES_PER_BIENNIUM) - (min % (1 << ALOG2_MINUTES_PER_BIENNIUM) < 0);
        }
      } else {
#line 436
        tmp___4 = min / (1 << ALOG2_MINUTES_PER_BIENNIUM) - (min % (1 << ALOG2_MINUTES_PER_BIENNIUM) < 0);
      }
    } else {
#line 436
      tmp___4 = min / (1 << ALOG2_MINUTES_PER_BIENNIUM) - (min % (1 << ALOG2_MINUTES_PER_BIENNIUM) < 0);
    }
#line 436
    approx_requested_biennia = (((tmp___0 - tmp___1) + tmp___2) + tmp___3) + tmp___4;
#line 446
    if (-1 >> 1 == -1) {
#line 446
      if (-1L >> 1 == -1L) {
#line 446
        if (-1L >> 1 == -1L) {
#line 446
          tmp___6 = t0 >> ALOG2_SECONDS_PER_BIENNIUM;
        } else {
#line 446
          tmp___6 = t0 / (time_t )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (time_t )(t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L);
        }
      } else {
#line 446
        tmp___6 = t0 / (time_t )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (time_t )(t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L);
      }
    } else {
#line 446
      tmp___6 = t0 / (time_t )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (time_t )(t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L);
    }
#line 446
    approx_biennia = (int )tmp___6;
#line 447
    diff = approx_biennia - approx_requested_biennia;
#line 448
    if (diff < 0) {
#line 448
      tmp___7 = -1 - diff;
    } else {
#line 448
      tmp___7 = diff;
    }
#line 448
    approx_abs_diff = tmp___7;
#line 454
    time_t_max = ((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 455
    time_t_min = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 456
    overflow_threshold = (time_t_max / 3L - time_t_min / 3L) >> ALOG2_SECONDS_PER_BIENNIUM;
#line 459
    if (overflow_threshold < (time_t )approx_abs_diff) {
#line 463
      repaired_t0 = -1L - t0;
#line 464
      if (-1 >> 1 == -1) {
#line 464
        if (-1L >> 1 == -1L) {
#line 464
          if (-1L >> 1 == -1L) {
#line 464
            approx_biennia = (int )(repaired_t0 >> ALOG2_SECONDS_PER_BIENNIUM);
          } else {
#line 464
            approx_biennia = (int )(repaired_t0 / (time_t )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (time_t )(repaired_t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L));
          }
        } else {
#line 464
          approx_biennia = (int )(repaired_t0 / (time_t )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (time_t )(repaired_t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L));
        }
      } else {
#line 464
        approx_biennia = (int )(repaired_t0 / (time_t )(1 << ALOG2_SECONDS_PER_BIENNIUM) - (time_t )(repaired_t0 % (long )(1 << ALOG2_SECONDS_PER_BIENNIUM) < 0L));
      }
#line 465
      diff = approx_biennia - approx_requested_biennia;
#line 466
      if (diff < 0) {
#line 466
        approx_abs_diff = -1 - diff;
      } else {
#line 466
        approx_abs_diff = diff;
      }
#line 467
      if (overflow_threshold < (time_t )approx_abs_diff) {
#line 468
        return ((time_t )-1);
      }
#line 469
      guessed_offset += repaired_t0 - t0;
#line 470
      t0 = repaired_t0;
    }
  }
#line 476
  t2 = t0;
#line 476
  t1 = t2;
#line 476
  t = t1;
#line 476
  dst2 = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 476
    tmp___9 = ranged_convert(convert, & t, & tm);
#line 476
    gt = guess_time_tm(year, yday, hour, min, sec, (time_t const   *)(& t), (struct tm  const  *)tmp___9);
    }
#line 476
    if (! (t != gt)) {
#line 476
      goto while_break;
    }
#line 481
    if (t == t1) {
#line 481
      if (t != t2) {
#line 481
        if (tm.tm_isdst < 0) {
#line 495
          goto offset_found;
        } else {
#line 481
          if (isdst < 0) {
#line 481
            tmp___8 = dst2 <= (tm.tm_isdst != 0);
          } else {
#line 481
            tmp___8 = (isdst != 0) != (tm.tm_isdst != 0);
          }
#line 481
          if (tmp___8) {
#line 495
            goto offset_found;
          } else {
#line 481
            goto _L___0;
          }
        }
      } else {
#line 481
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 496
      remaining_probes --;
#line 496
      if (remaining_probes == 0) {
#line 497
        return ((time_t )-1);
      }
    }
#line 476
    t1 = t2;
#line 476
    t2 = t;
#line 476
    t = gt;
#line 476
    dst2 = tm.tm_isdst != 0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 501
  tmp___12 = isdst_differ___0(isdst, tm.tm_isdst);
  }
#line 501
  if (tmp___12) {
#line 517
    stride = 601200;
#line 524
    duration_max = 536454000;
#line 528
    delta_bound = duration_max / 2 + stride;
#line 532
    delta = stride;
    {
#line 532
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 532
      if (! (delta < delta_bound)) {
#line 532
        goto while_break___0;
      }
#line 533
      direction = -1;
      {
#line 533
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 533
        if (! (direction <= 1)) {
#line 533
          goto while_break___1;
        }
        {
#line 534
        tmp___11 = time_t_int_add_ok(t, delta * direction);
        }
#line 534
        if (tmp___11) {
          {
#line 536
          ot = t + (time_t )(delta * direction);
#line 538
          ranged_convert(convert, & ot, & otm);
#line 539
          tmp___10 = isdst_differ___0(isdst, otm.tm_isdst);
          }
#line 539
          if (! tmp___10) {
            {
#line 543
            t = guess_time_tm(year, yday, hour, min, sec, (time_t const   *)(& ot),
                              (struct tm  const  *)(& otm));
#line 544
            ranged_convert(convert, & t, & tm);
            }
#line 545
            goto offset_found;
          }
        }
#line 533
        direction += 2;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 532
      delta += stride;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  offset_found: 
#line 551
  *offset = (guessed_offset + t) - t0;
#line 553
  if (sec_requested != tm.tm_sec) {
#line 557
    if (sec == 0) {
#line 557
      if (tm.tm_sec == 60) {
#line 557
        tmp___13 = 1;
      } else {
#line 557
        tmp___13 = 0;
      }
    } else {
#line 557
      tmp___13 = 0;
    }
    {
#line 557
    sec_adjustment = tmp___13 - sec;
#line 558
    tmp___14 = time_t_int_add_ok(t, sec_requested);
    }
#line 558
    if (! tmp___14) {
#line 559
      return ((time_t )-1);
    }
    {
#line 560
    t1 = t + (time_t )sec_requested;
#line 561
    tmp___15 = time_t_int_add_ok(t1, sec_adjustment);
    }
#line 561
    if (! tmp___15) {
#line 562
      return ((time_t )-1);
    }
    {
#line 563
    t2 = t1 + (time_t )sec_adjustment;
#line 564
    tmp___16 = (*convert)((time_t const   *)(& t2), & tm);
    }
#line 564
    if (! tmp___16) {
#line 565
      return ((time_t )-1);
    }
#line 566
    t = t2;
  }
#line 569
  *tp = tm;
#line 570
  return (t);
}
}
#line 578 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
static time_t localtime_offset  ;
#line 581 "/home/khheo/project/benchmark/tar-1.29/gnu/mktime.c"
time_t ( __attribute__((__nonnull__(1))) rpl_mktime)(struct tm *tp ) 
{ 
  time_t tmp ;

  {
  {
#line 591
  tmp = mktime_internal(tp, (struct tm *(*)(time_t const   * , struct tm * ))(& localtime_r),
                        & localtime_offset);
  }
#line 591
  return (tmp);
}
}
#line 367 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 104 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 246 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
__inline int mb_width_aux(wint_t wc ) 
{ 
  int w ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 249
  tmp = wcwidth((wchar_t )wc);
#line 249
  w = tmp;
  }
#line 252
  if (w >= 0) {
#line 252
    tmp___3 = w;
  } else {
    {
#line 252
    tmp___2 = iswcntrl(wc);
    }
#line 252
    if (tmp___2) {
#line 252
      tmp___1 = 0;
    } else {
#line 252
      tmp___1 = 1;
    }
#line 252
    tmp___3 = tmp___1;
  }
#line 252
  return (tmp___3);
}
}
#line 267 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
__inline void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 270
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
    {
#line 272
    memcpy((void */* __restrict  */)(& new_mbc->buf[0]), (void const   */* __restrict  */)(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 273
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
    }
  } else {
#line 276
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 277
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 278
  tmp = (_Bool )old_mbc->wc_valid;
#line 278
  new_mbc->wc_valid = tmp;
#line 278
  if (tmp) {
#line 279
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 280
  return;
}
}
#line 313
unsigned int const   is_basic_table[8] ;
#line 315 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
__inline _Bool is_basic(char c ) 
{ 


  {
#line 318
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 131 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
__inline void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
#line 134
  if (iter->next_done) {
#line 135
    return;
  }
#line 136
  if (iter->in_shift) {
#line 137
    goto with_shift;
  }
  {
#line 139
  tmp___8 = is_basic((char )*(iter->cur.ptr));
  }
#line 139
  if (tmp___8) {
#line 144
    iter->cur.bytes = (size_t )1;
#line 145
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 146
    iter->cur.wc_valid = (_Bool)1;
  } else {
    {
#line 150
    tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
    }
#line 150
    if (! tmp___2) {
      {
#line 150
      __assert_fail("mbsinit (&iter->state)", "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h",
                    150U, "mbuiter_multi_next");
      }
    }
#line 151
    iter->in_shift = (_Bool)1;
    with_shift: 
    {
#line 153
    tmp___3 = __ctype_get_mb_cur_max();
#line 153
    tmp___4 = strnlen1(iter->cur.ptr, tmp___3);
#line 153
    iter->cur.bytes = mbrtowc((wchar_t */* __restrict  */)(& iter->cur.wc), (char const   */* __restrict  */)iter->cur.ptr,
                              tmp___4, (mbstate_t */* __restrict  */)(& iter->state));
    }
#line 156
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 159
      iter->cur.bytes = (size_t )1;
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 164
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
      {
#line 167
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 168
      iter->cur.wc_valid = (_Bool)0;
      }
    } else {
#line 174
      if (iter->cur.bytes == 0UL) {
#line 177
        iter->cur.bytes = (size_t )1;
#line 178
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
          {
#line 178
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h",
                        178U, "mbuiter_multi_next");
          }
        }
#line 179
        if (! (iter->cur.wc == 0)) {
          {
#line 179
          __assert_fail("iter->cur.wc == 0", "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h",
                        179U, "mbuiter_multi_next");
          }
        }
      }
      {
#line 181
      iter->cur.wc_valid = (_Bool)1;
#line 185
      tmp___7 = mbsinit((mbstate_t const   *)(& iter->state));
      }
#line 185
      if (tmp___7) {
#line 186
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 189
  iter->next_done = (_Bool)1;
#line 190
  return;
}
}
#line 192 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
__inline void mbuiter_multi_reloc(struct mbuiter_multi *iter , ptrdiff_t ptrdiff ) 
{ 


  {
#line 195
  iter->cur.ptr += ptrdiff;
#line 196
  return;
}
}
#line 198 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
__inline void mbuiter_multi_copy(struct mbuiter_multi *new_iter , struct mbuiter_multi  const  *old_iter ) 
{ 
  _Bool tmp ;

  {
#line 201
  tmp = (_Bool )old_iter->in_shift;
#line 201
  new_iter->in_shift = tmp;
#line 201
  if (tmp) {
    {
#line 202
    memcpy((void */* __restrict  */)(& new_iter->state), (void const   */* __restrict  */)(& old_iter->state),
           sizeof(mbstate_t ));
    }
  } else {
    {
#line 204
    memset((void *)(& new_iter->state), 0, sizeof(mbstate_t ));
    }
  }
  {
#line 205
  new_iter->next_done = (_Bool )old_iter->next_done;
#line 206
  mb_copy(& new_iter->cur, & old_iter->cur);
  }
#line 207
  return;
}
}
#line 230
#pragma GCC diagnostic pop
#line 1137 "./string.h"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 166 "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/tar-1.29/gnu/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/tar-1.29/gnu/mbscasecmp.c"
int ( __attribute__((__nonnull__(1,2))) mbscasecmp)(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
  {
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
  }
#line 45
  if (tmp___25 > 1UL) {
    {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
    }
    {
#line 53
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 53
      mbuiter_multi_next(& iter1);
      }
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
        {
#line 53
        mbuiter_multi_next(& iter2);
        }
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          goto while_break;
        }
      } else {
#line 53
        goto while_break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
          {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
          }
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
            {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
            }
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
              {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
              }
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
              {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
              }
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 63
    mbuiter_multi_next(& iter1);
    }
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
    {
#line 66
    mbuiter_multi_next(& iter2);
    }
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
    {
#line 77
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 79
      tmp___19 = __ctype_b_loc();
      }
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
        {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
        }
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
      {
#line 80
      tmp___22 = __ctype_b_loc();
      }
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
        {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
        }
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        goto while_break___0;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 162 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 63 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.h"
void *mmalloca(size_t n ) ;
#line 67
void freea(void *p ) ;
#line 69 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.c"
static void *mmalloca_results[257]  ;
#line 73 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  void *p ;
  void *tmp ;
  size_t slot ;
  union header *h ;

  {
#line 79
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 81
  if (nplus >= n) {
    {
#line 83
    tmp = malloc(nplus);
#line 83
    p = tmp;
    }
#line 85
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 88
      h = (union header *)p;
#line 90
      p = (void *)(h + 1);
#line 93
      h->magic.word = 336984906;
#line 96
      slot = (uintptr_t )p % 257UL;
#line 97
      h->next = mmalloca_results[slot];
#line 98
      mmalloca_results[slot] = p;
#line 100
      return (p);
    }
  }
#line 104
  return ((void *)0);
}
}
#line 115 "/home/khheo/project/benchmark/tar-1.29/gnu/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  union header *h ;
  union header *p_begin ;

  {
#line 119
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 125
    if (*((int *)p + -1) == 336984906) {
#line 129
      slot = (uintptr_t )p % 257UL;
#line 130
      chain = & mmalloca_results[slot];
      {
#line 131
      while (1) {
        while_continue: /* CIL Label */ ;
#line 131
        if (! ((unsigned long )*chain != (unsigned long )((void *)0))) {
#line 131
          goto while_break;
        }
#line 133
        h = (union header *)p;
#line 134
        if ((unsigned long )*chain == (unsigned long )p) {
          {
#line 137
          p_begin = h - 1;
#line 138
          *chain = p_begin->next;
#line 139
          free((void *)p_begin);
          }
#line 140
          return;
        }
#line 142
        h = (union header *)*chain;
#line 143
        chain = & (h + -1)->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 148
  return;
}
}
#line 199 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 265
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 377
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 495
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) ;
#line 639
extern int ungetc(int __c , FILE *__stream ) ;
#line 121 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 661 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 120 "/home/khheo/project/benchmark/tar-1.29/gnu/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 123 "/home/khheo/project/benchmark/tar-1.29/gnu/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___0 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 128
  cp = (char const   *)charset_aliases;
#line 129
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
    {
#line 133
    base = "charset.alias";
#line 138
    tmp = getenv("CHARSETALIASDIR");
#line 138
    dir = (char const   *)tmp;
    }
#line 139
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 140
      dir = "/usr/local/lib";
    } else
#line 139
    if ((int const   )*(dir + 0) == 0) {
#line 140
      dir = "/usr/local/lib";
    }
    {
#line 144
    tmp___0 = strlen(dir);
#line 144
    dir_len___0 = tmp___0;
#line 145
    tmp___1 = strlen(base);
#line 145
    base_len___0 = tmp___1;
    }
#line 146
    if (dir_len___0 > 0UL) {
#line 146
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 146
        tmp___2 = 1;
      } else {
#line 146
        tmp___2 = 0;
      }
    } else {
#line 146
      tmp___2 = 0;
    }
    {
#line 146
    add_slash = tmp___2;
#line 147
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 147
    file_name___0 = (char *)tmp___3;
    }
#line 148
    if ((unsigned long )file_name___0 != (unsigned long )((void *)0)) {
      {
#line 150
      memcpy((void */* __restrict  */)file_name___0, (void const   */* __restrict  */)dir,
             dir_len___0);
      }
#line 151
      if (add_slash) {
#line 152
        *(file_name___0 + dir_len___0) = (char )'/';
      }
      {
#line 153
      memcpy((void */* __restrict  */)((file_name___0 + dir_len___0) + add_slash),
             (void const   */* __restrict  */)base, base_len___0 + 1UL);
      }
    }
#line 157
    if ((unsigned long )file_name___0 == (unsigned long )((void *)0)) {
#line 159
      cp = "";
    } else {
      {
#line 171
      fd = open((char const   *)file_name___0, 131072);
      }
#line 173
      if (fd < 0) {
#line 175
        cp = "";
      } else {
        {
#line 180
        fp = fdopen(fd, "r");
        }
#line 181
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
          {
#line 184
          close(fd);
#line 185
          cp = "";
          }
        } else {
#line 190
          res_ptr = (char *)((void *)0);
#line 191
          res_size = (size_t )0;
          {
#line 193
          while (1) {
            while_continue: /* CIL Label */ ;
            {
#line 201
            c = getc_unlocked(fp);
            }
#line 202
            if (c == -1) {
#line 203
              goto while_break;
            }
#line 204
            if (c == 10) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 32) {
#line 205
              goto __Cont;
            } else
#line 204
            if (c == 9) {
#line 205
              goto __Cont;
            }
#line 206
            if (c == 35) {
              {
#line 209
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 210
                c = getc_unlocked(fp);
                }
#line 209
                if (c == -1) {
#line 209
                  goto while_break___0;
                } else
#line 209
                if (c == 10) {
#line 209
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 212
              if (c == -1) {
#line 213
                goto while_break;
              }
#line 214
              goto __Cont;
            }
            {
#line 216
            ungetc(c, fp);
#line 217
            tmp___4 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%50s %50s",
                             buf1, buf2);
            }
#line 217
            if (tmp___4 < 2) {
#line 218
              goto while_break;
            }
            {
#line 219
            l1 = strlen((char const   *)(buf1));
#line 220
            l2 = strlen((char const   *)(buf2));
#line 221
            old_res_ptr = res_ptr;
            }
#line 222
            if (res_size == 0UL) {
              {
#line 224
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 225
              tmp___5 = malloc(res_size + 1UL);
#line 225
              res_ptr = (char *)tmp___5;
              }
            } else {
              {
#line 229
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 230
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 230
              res_ptr = (char *)tmp___6;
              }
            }
#line 232
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
              {
#line 235
              res_size = (size_t )0;
#line 236
              free((void *)old_res_ptr);
              }
#line 237
              goto while_break;
            }
            {
#line 239
            strcpy((char */* __restrict  */)(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   */* __restrict  */)(buf1));
#line 240
            strcpy((char */* __restrict  */)((res_ptr + res_size) - (l2 + 1UL)), (char const   */* __restrict  */)(buf2));
            }
            __Cont: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 242
          fclose(fp);
          }
#line 243
          if (res_size == 0UL) {
#line 244
            cp = "";
          } else {
#line 247
            *(res_ptr + res_size) = (char )'\000';
#line 248
            cp = (char const   *)res_ptr;
          }
        }
      }
      {
#line 253
      free((void *)file_name___0);
      }
    }
#line 377
    charset_aliases = (char const   */* volatile  */)cp;
  }
#line 380
  return (cp);
}
}
#line 392 "/home/khheo/project/benchmark/tar-1.29/gnu/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 403
  tmp = nl_langinfo(14);
#line 403
  codeset = (char const   *)tmp;
  }
#line 584
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 586
    codeset = "";
  }
  {
#line 589
  aliases = get_charset_aliases();
  }
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 589
    if (! ((int const   )*aliases != 0)) {
#line 589
      goto while_break;
    }
    {
#line 592
    tmp___3 = strcmp(codeset, aliases);
    }
#line 592
    if (tmp___3 == 0) {
      {
#line 595
      tmp___2 = strlen(aliases);
#line 595
      codeset = (aliases + tmp___2) + 1;
      }
#line 596
      goto while_break;
    } else
#line 592
    if ((int const   )*(aliases + 0) == 42) {
#line 592
      if ((int const   )*(aliases + 1) == 0) {
        {
#line 595
        tmp___2 = strlen(aliases);
#line 595
        codeset = (aliases + tmp___2) + 1;
        }
#line 596
        goto while_break;
      }
    }
    {
#line 589
    tmp___0 = strlen(aliases);
#line 589
    aliases += tmp___0 + 1UL;
#line 589
    tmp___1 = strlen(aliases);
#line 589
    aliases += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  if ((int const   )*(codeset + 0) == 0) {
#line 603
    codeset = "ASCII";
  }
#line 612
  return (codeset);
}
}
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 43 "/home/khheo/project/benchmark/tar-1.29/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf ) ;
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
char *( __attribute__((__warn_unused_result__)) inttostr)(int i , char *buf ) 
{ 
  char *p ;

  {
#line 38
  p = buf + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48 - i % 10);
#line 43
      i /= 10;
#line 43
      if (! (i != 0)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48 + i % 10);
#line 51
      i /= 10;
#line 51
      if (! (i != 0)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 22
#pragma GCC diagnostic ignored "-Wtype-limits"
#line 42 "/home/khheo/project/benchmark/tar-1.29/gnu/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf ) ;
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/anytostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf ) 
{ 
  char *p ;

  {
#line 38
  p = buf + (((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL);
#line 39
  *p = (char)0;
#line 41
  if (i < 0L) {
    {
#line 43
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      p --;
#line 44
      *p = (char )(48L - i % 10L);
#line 43
      i /= 10L;
#line 43
      if (! (i != 0L)) {
#line 43
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 47
    p --;
#line 47
    *p = (char )'-';
  } else {
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 52
      p --;
#line 52
      *p = (char )(48L + i % 10L);
#line 51
      i /= 10L;
#line 51
      if (! (i != 0L)) {
#line 51
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 56
  return (p);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 79 "/home/khheo/project/benchmark/tar-1.29/gnu/human.h"
char *human_readable(uintmax_t n , char *buf , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
#line 81
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) ;
#line 125 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) struct lconv *( __attribute__((__leaf__)) localeconv)(void) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 46 "./argmatch.h"
ptrdiff_t argmatch(char const   *arg___0 , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 36 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static char const   power_letter[9]  = 
#line 36 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
#line 53 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static long double adjust_value(int inexact_style , long double value___0 ) 
{ 
  uintmax_t u ;
  int tmp ;

  {
#line 60
  if (inexact_style != 1) {
#line 60
    if (value___0 < (long double )0xffffffffffffffffUL) {
#line 62
      u = (uintmax_t )value___0;
#line 63
      if (inexact_style == 0) {
#line 63
        if ((long double )u != value___0) {
#line 63
          tmp = 1;
        } else {
#line 63
          tmp = 0;
        }
      } else {
#line 63
        tmp = 0;
      }
#line 63
      value___0 = (long double )(u + (uintmax_t )tmp);
    }
  }
#line 66
  return (value___0);
}
}
#line 78 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static char *group_number(char *number , size_t numberlen , char const   *grouping ,
                          char const   *thousands_sep ) 
{ 
  register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL) + 1UL] ;
  unsigned char g ;

  {
  {
#line 83
  grouplen = 0xffffffffffffffffUL;
#line 84
  tmp = strlen(thousands_sep);
#line 84
  thousands_seplen = tmp;
#line 85
  i = numberlen;
#line 91
  memcpy((void */* __restrict  */)(buf), (void const   */* __restrict  */)number,
         numberlen);
#line 92
  d = number + numberlen;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    g = (unsigned char )*grouping;
#line 98
    if (g) {
#line 100
      if ((int )g < 127) {
#line 100
        grouplen = (size_t )g;
      } else {
#line 100
        grouplen = i;
      }
#line 101
      grouping ++;
    }
#line 104
    if (i < grouplen) {
#line 105
      grouplen = i;
    }
    {
#line 107
    d -= grouplen;
#line 108
    i -= grouplen;
#line 109
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)(buf + i),
           grouplen);
    }
#line 110
    if (i == 0UL) {
#line 111
      return (d);
    }
    {
#line 113
    d -= thousands_seplen;
#line 114
    memcpy((void */* __restrict  */)d, (void const   */* __restrict  */)thousands_sep,
           thousands_seplen);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 152 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
char *human_readable(uintmax_t n , char *buf , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) 
{ 
  int inexact_style ;
  unsigned int base ;
  int tmp ;
  uintmax_t amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const   *integerlim ;
  int rounding ;
  char const   *decimal_point ;
  size_t decimal_pointlen ;
  char const   *grouping ;
  char const   *thousands_sep ;
  struct lconv  const  *l ;
  struct lconv *tmp___0 ;
  size_t pointlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uintmax_t multiplier ;
  uintmax_t divisor ;
  uintmax_t r10 ;
  uintmax_t r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double tmp___3 ;
  long double e ;
  long double tmp___4 ;
  long double tmp___5 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int digit ;
  uintmax_t power ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 156
  inexact_style = opts & 3;
#line 158
  if (opts & 32) {
#line 158
    tmp = 1024;
  } else {
#line 158
    tmp = 1000;
  }
  {
#line 158
  base = (unsigned int )tmp;
#line 161
  exponent = -1;
#line 162
  exponent_max = (int )(sizeof(power_letter) - 1UL);
#line 173
  decimal_point = ".";
#line 174
  decimal_pointlen = (size_t )1;
#line 175
  grouping = "";
#line 176
  thousands_sep = "";
#line 177
  tmp___0 = localeconv();
#line 177
  l = (struct lconv  const  *)tmp___0;
#line 178
  tmp___1 = strlen((char const   *)l->decimal_point);
#line 178
  pointlen = tmp___1;
  }
#line 179
  if (0UL < pointlen) {
#line 179
    if (pointlen <= 16UL) {
#line 181
      decimal_point = (char const   *)l->decimal_point;
#line 182
      decimal_pointlen = pointlen;
    }
  }
  {
#line 184
  grouping = (char const   *)l->grouping;
#line 185
  tmp___2 = strlen((char const   *)l->thousands_sep);
  }
#line 185
  if (tmp___2 <= 16UL) {
#line 186
    thousands_sep = (char const   *)l->thousands_sep;
  }
#line 188
  psuffix = (buf + (((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL)) - 3;
#line 189
  p = psuffix;
#line 194
  if (to_block_size <= from_block_size) {
#line 196
    if (from_block_size % to_block_size == 0UL) {
#line 198
      multiplier = from_block_size / to_block_size;
#line 199
      amt = n * multiplier;
#line 200
      if (amt / multiplier == n) {
#line 202
        tenths = 0;
#line 203
        rounding = 0;
#line 204
        goto use_integer_arithmetic;
      }
    }
  } else
#line 208
  if (from_block_size != 0UL) {
#line 208
    if (to_block_size % from_block_size == 0UL) {
#line 210
      divisor = to_block_size / from_block_size;
#line 211
      r10 = (n % divisor) * 10UL;
#line 212
      r2 = (r10 % divisor) * 2UL;
#line 213
      amt = n / divisor;
#line 214
      tenths = (int )(r10 / divisor);
#line 215
      if (r2 < divisor) {
#line 215
        rounding = 0UL < r2;
      } else {
#line 215
        rounding = 2 + (divisor < r2);
      }
#line 216
      goto use_integer_arithmetic;
    }
  }
#line 224
  dto_block_size = (long double )to_block_size;
#line 225
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
#line 229
  if (! (opts & 16)) {
    {
#line 231
    tmp___3 = adjust_value(inexact_style, damt);
#line 231
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%.0Lf",
            tmp___3);
#line 232
    buflen = strlen((char const   *)buf);
#line 233
    nonintegerlen = (size_t )0;
    }
  } else {
#line 237
    e = (long double )1;
#line 238
    exponent = 0;
    {
#line 240
    while (1) {
      while_continue: /* CIL Label */ ;
#line 242
      e *= (long double )base;
#line 243
      exponent ++;
#line 240
      if (e * (long double )base <= damt) {
#line 240
        if (! (exponent < exponent_max)) {
#line 240
          goto while_break;
        }
      } else {
#line 240
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 247
    damt /= e;
#line 249
    tmp___4 = adjust_value(inexact_style, damt);
#line 249
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%.1Lf",
            tmp___4);
#line 250
    buflen = strlen((char const   *)buf);
#line 251
    nonintegerlen = decimal_pointlen + 1UL;
    }
#line 253
    if ((1UL + nonintegerlen) + (size_t )(! (opts & 32)) < buflen) {
      {
#line 257
      tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 257
      sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%.0Lf",
              tmp___5 / (long double )10);
#line 259
      buflen = strlen((char const   *)buf);
#line 260
      nonintegerlen = (size_t )0;
      }
    } else
#line 253
    if (opts & 8) {
#line 253
      if ((int )*(buf + (buflen - 1UL)) == 48) {
        {
#line 257
        tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 257
        sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%.0Lf",
                tmp___5 / (long double )10);
#line 259
        buflen = strlen((char const   *)buf);
#line 260
        nonintegerlen = (size_t )0;
        }
      }
    }
  }
  {
#line 264
  p = psuffix - buflen;
#line 265
  memmove((void *)p, (void const   *)buf, buflen);
#line 266
  integerlim = (char const   *)((p + buflen) - nonintegerlen);
  }
#line 268
  goto do_grouping;
  use_integer_arithmetic: 
#line 277
  if (opts & 16) {
#line 279
    exponent = 0;
#line 281
    if ((uintmax_t )base <= amt) {
      {
#line 283
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 285
        r10___0 = (unsigned int )((amt % (unsigned long )base) * 10UL + (unsigned long )tenths);
#line 286
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
#line 287
        amt /= (uintmax_t )base;
#line 288
        tenths = (int )(r10___0 / base);
#line 289
        if (r2___0 < base) {
#line 289
          rounding = r2___0 + (unsigned int )rounding != 0U;
        } else {
#line 289
          rounding = 2 + (base < r2___0 + (unsigned int )rounding);
        }
#line 292
        exponent ++;
#line 283
        if ((uintmax_t )base <= amt) {
#line 283
          if (! (exponent < exponent_max)) {
#line 283
            goto while_break___0;
          }
        } else {
#line 283
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 296
      if (amt < 10UL) {
#line 298
        if (inexact_style == 1) {
#line 298
          tmp___7 = 2 < rounding + (tenths & 1);
        } else {
#line 298
          if (inexact_style == 0) {
#line 298
            if (0 < rounding) {
#line 298
              tmp___6 = 1;
            } else {
#line 298
              tmp___6 = 0;
            }
          } else {
#line 298
            tmp___6 = 0;
          }
#line 298
          tmp___7 = tmp___6;
        }
#line 298
        if (tmp___7) {
#line 302
          tenths ++;
#line 303
          rounding = 0;
#line 305
          if (tenths == 10) {
#line 307
            amt ++;
#line 308
            tenths = 0;
          }
        }
#line 312
        if (amt < 10UL) {
#line 312
          if (tenths) {
#line 312
            goto _L;
          } else
#line 312
          if (! (opts & 8)) {
            _L: /* CIL Label */ 
            {
#line 315
            p --;
#line 315
            *p = (char )(48 + tenths);
#line 316
            p -= decimal_pointlen;
#line 317
            memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)decimal_point,
                   decimal_pointlen);
#line 318
            rounding = 0;
#line 318
            tenths = rounding;
            }
          }
        }
      }
    }
  }
#line 324
  if (inexact_style == 1) {
#line 324
    tmp___9 = 5 < tenths + (0UL < (unsigned long )rounding + (amt & 1UL));
  } else {
#line 324
    if (inexact_style == 0) {
#line 324
      if (0 < tenths + rounding) {
#line 324
        tmp___8 = 1;
      } else {
#line 324
        tmp___8 = 0;
      }
    } else {
#line 324
      tmp___8 = 0;
    }
#line 324
    tmp___9 = tmp___8;
  }
#line 324
  if (tmp___9) {
#line 328
    amt ++;
#line 330
    if (opts & 16) {
#line 330
      if (amt == (uintmax_t )base) {
#line 330
        if (exponent < exponent_max) {
#line 333
          exponent ++;
#line 334
          if (! (opts & 8)) {
            {
#line 336
            p --;
#line 336
            *p = (char )'0';
#line 337
            p -= decimal_pointlen;
#line 338
            memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)decimal_point,
                   decimal_pointlen);
            }
          }
#line 340
          amt = (uintmax_t )1;
        }
      }
    }
  }
#line 344
  integerlim = (char const   *)p;
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 348
    digit = (int )(amt % 10UL);
#line 349
    p --;
#line 349
    *p = (char )(digit + 48);
#line 346
    amt /= 10UL;
#line 346
    if (! (amt != 0UL)) {
#line 346
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  do_grouping: 
#line 355
  if (opts & 4) {
    {
#line 356
    p = group_number(p, (size_t )(integerlim - (char const   *)p), grouping, thousands_sep);
    }
  }
#line 358
  if (opts & 128) {
#line 360
    if (exponent < 0) {
#line 363
      exponent = 0;
#line 364
      power = (uintmax_t )1;
      {
#line 364
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 364
        if (! (power < to_block_size)) {
#line 364
          goto while_break___2;
        }
#line 365
        exponent ++;
#line 365
        if (exponent == exponent_max) {
#line 366
          goto while_break___2;
        }
#line 364
        power *= (uintmax_t )base;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 369
    if (exponent | (opts & 256)) {
#line 369
      if (opts & 64) {
#line 370
        tmp___10 = psuffix;
#line 370
        psuffix ++;
#line 370
        *tmp___10 = (char )' ';
      }
    }
#line 372
    if (exponent) {
#line 373
      tmp___11 = psuffix;
#line 373
      psuffix ++;
#line 373
      if (! (opts & 32)) {
#line 373
        if (exponent == 1) {
#line 373
          *tmp___11 = (char )'k';
        } else {
#line 373
          *tmp___11 = (char )power_letter[exponent];
        }
      } else {
#line 373
        *tmp___11 = (char )power_letter[exponent];
      }
    }
#line 377
    if (opts & 256) {
#line 379
      if (opts & 32) {
#line 379
        if (exponent) {
#line 380
          tmp___12 = psuffix;
#line 380
          psuffix ++;
#line 380
          *tmp___12 = (char )'i';
        }
      }
#line 381
      tmp___13 = psuffix;
#line 381
      psuffix ++;
#line 381
      *tmp___13 = (char )'B';
    }
  }
#line 385
  *psuffix = (char )'\000';
#line 387
  return (p);
}
}
#line 397 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static char const   * const  block_size_args[3]  = {      (char const   */* const  */)"human-readable",      (char const   */* const  */)"si",      (char const   */* const  */)0};
#line 398 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static int const   block_size_opts[2]  = {      (int const   )176,      (int const   )144};
#line 404 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static uintmax_t default_block_size(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 407
  tmp___1 = getenv("POSIXLY_CORRECT");
  }
#line 407
  if (tmp___1) {
#line 407
    tmp___0 = 512;
  } else {
#line 407
    tmp___0 = 1024;
  }
#line 407
  return ((uintmax_t )tmp___0);
}
}
#line 410 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
static strtol_error humblock(char const   *spec , uintmax_t *block_size , int *options___0 ) 
{ 
  int i ;
  int opts ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 414
  opts = 0;
#line 416
  if (! spec) {
    {
#line 416
    tmp___1 = getenv("BLOCK_SIZE");
#line 416
    spec = (char const   *)tmp___1;
    }
#line 416
    if (spec) {
#line 416
      goto _L___0;
    } else {
      {
#line 416
      tmp___2 = getenv("BLOCKSIZE");
#line 416
      spec = (char const   *)tmp___2;
      }
#line 416
      if (spec) {
#line 416
        goto _L___0;
      } else {
        {
#line 419
        *block_size = default_block_size();
        }
      }
    }
  } else {
    _L___0: /* CIL Label */ 
#line 422
    if ((int const   )*spec == 39) {
#line 424
      opts |= 4;
#line 425
      spec ++;
    }
    {
#line 428
    tmp___0 = argmatch(spec, block_size_args, (char const   *)(block_size_opts), sizeof(block_size_opts[0]));
#line 428
    i = (int )tmp___0;
    }
#line 428
    if (0 <= i) {
#line 430
      opts |= (int )block_size_opts[i];
#line 431
      *block_size = (uintmax_t )1;
    } else {
      {
#line 436
      tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
#line 436
      e = tmp;
      }
#line 438
      if ((unsigned int )e != 0U) {
#line 440
        *options___0 = 0;
#line 441
        return (e);
      }
      {
#line 443
      while (1) {
        while_continue: /* CIL Label */ ;
#line 443
        if (48 <= (int )*spec) {
#line 443
          if ((int const   )*spec <= 57) {
#line 443
            goto while_break;
          }
        }
#line 444
        if ((unsigned long )spec == (unsigned long )ptr) {
#line 446
          opts |= 128;
#line 447
          if ((int )*(ptr + -1) == 66) {
#line 448
            opts |= 256;
          }
#line 449
          if ((int )*(ptr + -1) != 66) {
#line 450
            opts |= 32;
          } else
#line 449
          if ((int )*(ptr + -2) == 105) {
#line 450
            opts |= 32;
          }
#line 451
          goto while_break;
        }
#line 443
        spec ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 456
  *options___0 = opts;
#line 457
  return ((strtol_error )0);
}
}
#line 460 "/home/khheo/project/benchmark/tar-1.29/gnu/human.c"
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) 
{ 
  strtol_error e ;
  strtol_error tmp ;

  {
  {
#line 463
  tmp = humblock(spec, block_size, opts);
#line 463
  e = tmp;
  }
#line 464
  if (*block_size == 0UL) {
    {
#line 466
    *block_size = default_block_size();
#line 467
    e = (strtol_error )4;
    }
  }
#line 469
  return (e);
}
}
#line 72 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 73
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 74
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 75
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 76
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 77
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 78
void *hash_lookup(Hash_table const   *table , void const   *entry___0 ) ;
#line 81
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 82
void *hash_get_next(Hash_table const   *table , void const   *entry___0 ) ;
#line 83
size_t hash_get_entries(Hash_table const   *table , void **buffer___1 , size_t buffer_size ) ;
#line 84
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 87
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 88
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 89
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 92
void hash_clear(Hash_table *table ) ;
#line 93
void hash_free(Hash_table *table ) ;
#line 96
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 97
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry___0 ) ;
#line 99
int hash_insert_if_absent(Hash_table *table , void const   *entry___0 , void const   **matched_ent ) ;
#line 101
void *hash_delete(Hash_table *table , void const   *entry___0 ) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint64_t rotl64(uint64_t x , int n ) 
{ 


  {
#line 41
  return (((x << n) | (x >> (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint64_t rotr64(uint64_t x , int n ) 
{ 


  {
#line 50
  return (((x >> n) | (x << (64 - n))) & 0xffffffffffffffffUL);
}
}
#line 57 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint32_t rotl32(uint32_t x , int n ) 
{ 


  {
#line 60
  return (((x << n) | (x >> (32 - n))) & 4294967295U);
}
}
#line 66 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint32_t rotr32(uint32_t x , int n ) 
{ 


  {
#line 69
  return (((x >> n) | (x << (32 - n))) & 4294967295U);
}
}
#line 75 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline size_t rotl_sz(size_t x , int n ) 
{ 


  {
#line 78
  return (((x << n) | (x >> (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 84 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 87
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 95 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint16_t rotl16(uint16_t x , int n ) 
{ 


  {
#line 98
  return ((uint16_t )((((int )x << n) | ((int )x >> (16 - n))) & 65535));
}
}
#line 106 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint16_t rotr16(uint16_t x , int n ) 
{ 


  {
#line 109
  return ((uint16_t )((((int )x >> n) | ((int )x << (16 - n))) & 65535));
}
}
#line 117 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint8_t rotl8(uint8_t x , int n ) 
{ 


  {
#line 120
  return ((uint8_t )((((int )x << n) | ((int )x >> (8 - n))) & 255));
}
}
#line 128 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
__inline uint8_t rotr8(uint8_t x , int n ) 
{ 


  {
#line 131
  return ((uint8_t )((((int )x >> n) | ((int )x << (8 - n))) & 255));
}
}
#line 134
#pragma GCC diagnostic pop
#line 130 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static struct hash_tuning  const  default_tuning  =    {0.0f, 1.0f, 0.8f, 1.414f, (_Bool)0};
#line 149
size_t hash_get_n_buckets(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 149 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 152
  return ((size_t )table->n_buckets);
}
}
#line 157
size_t hash_get_n_buckets_used(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 157 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 160
  return ((size_t )table->n_buckets_used);
}
}
#line 165
size_t hash_get_n_entries(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 165 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 168
  return ((size_t )table->n_entries);
}
}
#line 173
size_t hash_get_max_bucket_length(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 173 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 177
  max_bucket_length = (size_t )0;
#line 179
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 179
      goto while_break;
    }
#line 181
    if (bucket->data) {
#line 183
      cursor = bucket;
#line 184
      bucket_length = (size_t )1;
      {
#line 186
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 186
        cursor = (struct hash_entry  const  *)cursor->next;
#line 186
        if (! cursor) {
#line 186
          goto while_break___0;
        }
#line 187
        bucket_length ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 189
      if (bucket_length > max_bucket_length) {
#line 190
        max_bucket_length = bucket_length;
      }
    }
#line 179
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (max_bucket_length);
}
}
#line 200
_Bool hash_table_ok(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 200 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 204
  n_buckets_used = (size_t )0;
#line 205
  n_entries = (size_t )0;
#line 207
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 207
      goto while_break;
    }
#line 209
    if (bucket->data) {
#line 211
      cursor = bucket;
#line 214
      n_buckets_used ++;
#line 215
      n_entries ++;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        cursor = (struct hash_entry  const  *)cursor->next;
#line 218
        if (! cursor) {
#line 218
          goto while_break___0;
        }
#line 219
        n_entries ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 207
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 223
    if (n_entries == (size_t )table->n_entries) {
#line 224
      return ((_Bool)1);
    }
  }
#line 226
  return ((_Bool)0);
}
}
#line 229 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
  {
#line 232
  tmp = hash_get_n_entries(table);
#line 232
  n_entries = tmp;
#line 233
  tmp___0 = hash_get_n_buckets(table);
#line 233
  n_buckets = tmp___0;
#line 234
  tmp___1 = hash_get_n_buckets_used(table);
#line 234
  n_buckets_used = tmp___1;
#line 235
  tmp___2 = hash_get_max_bucket_length(table);
#line 235
  max_bucket_length = tmp___2;
#line 237
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# entries:         %lu\n",
          n_entries);
#line 238
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets:         %lu\n",
          n_buckets);
#line 239
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 242
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"max bucket length: %lu\n",
          max_bucket_length);
  }
#line 244
  return;
}
}
#line 248 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static struct hash_entry *safe_hasher(Hash_table const   *table , void const   *key ) 
{ 
  size_t n ;
  size_t tmp ;

  {
  {
#line 251
  tmp = (*(table->hasher))(key, (size_t )table->n_buckets);
#line 251
  n = tmp;
  }
#line 252
  if (! (n < (size_t )table->n_buckets)) {
    {
#line 253
    abort();
    }
  }
#line 254
  return ((struct hash_entry *)(table->bucket + n));
}
}
#line 260 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry___0 ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
  {
#line 263
  tmp = safe_hasher(table, entry___0);
#line 263
  bucket = (struct hash_entry  const  *)tmp;
  }
#line 266
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 267
    return ((void *)0);
  }
#line 269
  cursor = bucket;
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! cursor) {
#line 269
      goto while_break;
    }
#line 270
    if ((unsigned long )entry___0 == (unsigned long )cursor->data) {
#line 271
      return ((void *)cursor->data);
    } else {
      {
#line 270
      tmp___0 = (*(table->comparator))(entry___0, (void const   *)cursor->data);
      }
#line 270
      if (tmp___0) {
#line 271
        return ((void *)cursor->data);
      }
    }
#line 269
    cursor = (struct hash_entry  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return ((void *)0);
}
}
#line 287
void *hash_get_first(Hash_table const   *table )  __attribute__((__pure__)) ;
#line 287 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 292
  if (table->n_entries == 0UL) {
#line 293
    return ((void *)0);
  }
#line 295
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 295
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
      {
#line 297
      abort();
      }
    } else
#line 298
    if (bucket->data) {
#line 299
      return ((void *)bucket->data);
    }
#line 295
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 306 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry___0 ) 
{ 
  struct hash_entry  const  *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry  const  *cursor ;

  {
  {
#line 309
  tmp = safe_hasher(table, entry___0);
#line 309
  bucket = (struct hash_entry  const  *)tmp;
#line 313
  cursor = bucket;
  }
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 316
    if ((unsigned long )cursor->data == (unsigned long )entry___0) {
#line 316
      if (cursor->next) {
#line 317
        return ((cursor->next)->data);
      }
    }
#line 318
    cursor = (struct hash_entry  const  *)cursor->next;
#line 314
    if (! ((unsigned long )cursor != (unsigned long )((void *)0))) {
#line 314
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 323
    bucket ++;
#line 323
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 323
      goto while_break___0;
    }
#line 324
    if (bucket->data) {
#line 325
      return ((void *)bucket->data);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 328
  return ((void *)0);
}
}
#line 335 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer___1 , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 339
  counter = (size_t )0;
#line 343
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 343
      goto while_break;
    }
#line 345
    if (bucket->data) {
#line 347
      cursor = bucket;
      {
#line 347
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 347
        if (! cursor) {
#line 347
          goto while_break___0;
        }
#line 349
        if (counter >= buffer_size) {
#line 350
          return (counter);
        }
#line 351
        tmp = counter;
#line 351
        counter ++;
#line 351
        *(buffer___1 + tmp) = (void *)cursor->data;
#line 347
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 343
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  return (counter);
}
}
#line 367 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 371
  counter = (size_t )0;
#line 375
  bucket = (struct hash_entry  const  *)table->bucket;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 375
      goto while_break;
    }
#line 377
    if (bucket->data) {
#line 379
      cursor = bucket;
      {
#line 379
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 379
        if (! cursor) {
#line 379
          goto while_break___0;
        }
        {
#line 381
        tmp = (*processor)((void *)cursor->data, processor_data);
        }
#line 381
        if (! tmp) {
#line 382
          return (counter);
        }
#line 383
        counter ++;
#line 379
        cursor = (struct hash_entry  const  *)cursor->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 375
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 388
  return (counter);
}
}
#line 427
size_t hash_string(char const   *string , size_t n_buckets )  __attribute__((__pure__)) ;
#line 427 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value___0 ;
  unsigned char ch ;

  {
#line 430
  value___0 = (size_t )0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    ch = (unsigned char )*string;
#line 433
    if (! ch) {
#line 433
      goto while_break;
    }
#line 434
    value___0 = (value___0 * 31UL + (size_t )ch) % n_buckets;
#line 433
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 435
  return (value___0);
}
}
#line 443
static _Bool is_prime(size_t candidate )  __attribute__((__const__)) ;
#line 443 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 446
  divisor = (size_t )3;
#line 447
  square = divisor * divisor;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (square < candidate) {
#line 449
      if (! (candidate % divisor)) {
#line 449
        goto while_break;
      }
    } else {
#line 449
      goto while_break;
    }
#line 451
    divisor ++;
#line 452
    square += 4UL * divisor;
#line 453
    divisor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  if (candidate % divisor) {
#line 456
    tmp = 1;
  } else {
#line 456
    tmp = 0;
  }
#line 456
  return ((_Bool )tmp);
}
}
#line 462
static size_t next_prime(size_t candidate )  __attribute__((__const__)) ;
#line 462 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 466
  if (candidate < 10UL) {
#line 467
    candidate = (size_t )10;
  }
#line 470
  candidate |= 1UL;
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    if (0xffffffffffffffffUL != candidate) {
      {
#line 472
      tmp = is_prime(candidate);
      }
#line 472
      if (tmp) {
#line 472
        goto while_break;
      }
    } else {
#line 472
      goto while_break;
    }
#line 473
    candidate += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (candidate);
}
}
#line 478 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 481
  *tuning = (Hash_tuning )default_tuning;
#line 482
  return;
}
}
#line 485 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val___0 ;
  size_t tmp ;

  {
  {
#line 493
  tmp = rotr_sz((size_t )data, 3);
#line 493
  val___0 = tmp;
  }
#line 494
  return (val___0 % n);
}
}
#line 498 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 501
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 511 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 514
  tuning = table->tuning;
#line 516
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 517
    return ((_Bool)1);
  }
#line 524
  epsilon = 0.1f;
#line 526
  if (epsilon < (float )tuning->growth_threshold) {
#line 526
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 526
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 526
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 526
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 526
            if (tuning->shrink_factor <= (float const   )1) {
#line 526
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 533
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 535
  table->tuning = & default_tuning;
#line 536
  return ((_Bool)0);
}
}
#line 543 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static size_t __attribute__((__pure__))  compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 546
  if (! tuning->is_n_buckets) {
#line 548
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 549
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 550
      return ((size_t __attribute__((__pure__))  )0);
    }
#line 551
    candidate = (size_t )new_candidate;
  }
  {
#line 553
  candidate = next_prime(candidate);
  }
#line 554
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 554
    tmp = -1;
  } else {
#line 554
    tmp = -2;
  }
#line 554
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 555
    return ((size_t __attribute__((__pure__))  )0);
  }
#line 556
  return ((size_t __attribute__((__pure__))  )candidate);
}
}
#line 593 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;
  void *tmp___2 ;

  {
#line 600
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 601
    hasher = & raw_hasher;
  }
#line 602
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 603
    comparator = & raw_comparator;
  }
  {
#line 605
  tmp = malloc(sizeof(*table));
#line 605
  table = (Hash_table *)tmp;
  }
#line 606
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 607
    return ((Hash_table *)((void *)0));
  }
#line 609
  if (! tuning) {
#line 610
    tuning = & default_tuning;
  }
  {
#line 611
  table->tuning = tuning;
#line 612
  tmp___0 = check_tuning(table);
  }
#line 612
  if (! tmp___0) {
#line 619
    goto fail;
  }
  {
#line 622
  tmp___1 = compute_bucket_size(candidate, tuning);
#line 622
  table->n_buckets = (size_t )tmp___1;
  }
#line 623
  if (! table->n_buckets) {
#line 624
    goto fail;
  }
  {
#line 626
  tmp___2 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 626
  table->bucket = (struct hash_entry *)tmp___2;
  }
#line 627
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 628
    goto fail;
  }
#line 629
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 630
  table->n_buckets_used = (size_t )0;
#line 631
  table->n_entries = (size_t )0;
#line 633
  table->hasher = hasher;
#line 634
  table->comparator = comparator;
#line 635
  table->data_freer = data_freer;
#line 637
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 641
  return (table);
  fail: 
  {
#line 644
  free((void *)table);
  }
#line 645
  return ((Hash_table *)((void *)0));
}
}
#line 652 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 657
  bucket = table->bucket;
  {
#line 657
  while (1) {
    while_continue: /* CIL Label */ ;
#line 657
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 657
      goto while_break;
    }
#line 659
    if (bucket->data) {
#line 665
      cursor = bucket->next;
      {
#line 665
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 665
        if (! cursor) {
#line 665
          goto while_break___0;
        }
#line 667
        if (table->data_freer) {
          {
#line 668
          (*(table->data_freer))(cursor->data);
          }
        }
#line 669
        cursor->data = (void *)0;
#line 671
        next = cursor->next;
#line 674
        cursor->next = table->free_entry_list;
#line 675
        table->free_entry_list = cursor;
#line 665
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 679
      if (table->data_freer) {
        {
#line 680
        (*(table->data_freer))(bucket->data);
        }
      }
#line 681
      bucket->data = (void *)0;
#line 682
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 657
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 686
  table->n_buckets_used = (size_t )0;
#line 687
  table->n_entries = (size_t )0;
#line 688
  return;
}
}
#line 695 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 703
  if (table->data_freer) {
#line 703
    if (table->n_entries) {
#line 705
      bucket = table->bucket;
      {
#line 705
      while (1) {
        while_continue: /* CIL Label */ ;
#line 705
        if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 705
          goto while_break;
        }
#line 707
        if (bucket->data) {
#line 709
          cursor = bucket;
          {
#line 709
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 709
            if (! cursor) {
#line 709
              goto while_break___0;
            }
            {
#line 710
            (*(table->data_freer))(cursor->data);
#line 709
            cursor = cursor->next;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 705
        bucket ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 722
  bucket = table->bucket;
  {
#line 722
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 722
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 722
      goto while_break___1;
    }
#line 724
    cursor = bucket->next;
    {
#line 724
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 724
      if (! cursor) {
#line 724
        goto while_break___2;
      }
      {
#line 726
      next = cursor->next;
#line 727
      free((void *)cursor);
#line 724
      cursor = next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 722
    bucket ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 732
  cursor = table->free_entry_list;
  {
#line 732
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 732
    if (! cursor) {
#line 732
      goto while_break___3;
    }
    {
#line 734
    next = cursor->next;
#line 735
    free((void *)cursor);
#line 732
    cursor = next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 741
  free((void *)table->bucket);
#line 742
  free((void *)table);
  }
#line 743
  return;
}
}
#line 750 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 755
  if (table->free_entry_list) {
#line 757
    new = table->free_entry_list;
#line 758
    table->free_entry_list = new->next;
  } else {
    {
#line 765
    tmp = malloc(sizeof(*new));
#line 765
    new = (struct hash_entry *)tmp;
    }
  }
#line 769
  return (new);
}
}
#line 775 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry___0 ) 
{ 


  {
#line 778
  entry___0->data = (void *)0;
#line 779
  entry___0->next = table->free_entry_list;
#line 780
  table->free_entry_list = entry___0;
#line 781
  return;
}
}
#line 789 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry___0 , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
  {
#line 793
  tmp = safe_hasher((Hash_table const   *)table, entry___0);
#line 793
  bucket = tmp;
#line 796
  *bucket_head = bucket;
  }
#line 799
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 800
    return ((void *)0);
  }
#line 803
  if ((unsigned long )entry___0 == (unsigned long )bucket->data) {
#line 803
    goto _L;
  } else {
    {
#line 803
    tmp___0 = (*(table->comparator))(entry___0, (void const   *)bucket->data);
    }
#line 803
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 805
      data = bucket->data;
#line 807
      if (delete) {
#line 809
        if (bucket->next) {
          {
#line 811
          next = bucket->next;
#line 815
          *bucket = *next;
#line 816
          free_entry(table, next);
          }
        } else {
#line 820
          bucket->data = (void *)0;
        }
      }
#line 824
      return (data);
    }
  }
#line 828
  cursor = bucket;
  {
#line 828
  while (1) {
    while_continue: /* CIL Label */ ;
#line 828
    if (! cursor->next) {
#line 828
      goto while_break;
    }
#line 830
    if ((unsigned long )entry___0 == (unsigned long )(cursor->next)->data) {
#line 830
      goto _L___0;
    } else {
      {
#line 830
      tmp___1 = (*(table->comparator))(entry___0, (void const   *)(cursor->next)->data);
      }
#line 830
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 833
        data___0 = (cursor->next)->data;
#line 835
        if (delete) {
          {
#line 837
          next___0 = cursor->next;
#line 841
          cursor->next = next___0->next;
#line 842
          free_entry(table, next___0);
          }
        }
#line 845
        return (data___0);
      }
    }
#line 828
    cursor = cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 850
  return ((void *)0);
}
}
#line 859 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp ;

  {
#line 865
  bucket = src->bucket;
  {
#line 865
  while (1) {
    while_continue: /* CIL Label */ ;
#line 865
    if (! ((unsigned long )bucket < (unsigned long )src->bucket_limit)) {
#line 865
      goto while_break;
    }
#line 866
    if (bucket->data) {
#line 877
      cursor = bucket->next;
      {
#line 877
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 877
        if (! cursor) {
#line 877
          goto while_break___0;
        }
        {
#line 879
        data = cursor->data;
#line 880
        new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
#line 882
        next = cursor->next;
        }
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
          {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
          }
        }
#line 877
        cursor = next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
      {
#line 907
      new_bucket = safe_hasher((Hash_table const   *)dst, (void const   *)data);
      }
#line 909
      if (new_bucket->data) {
        {
#line 913
        tmp = allocate_entry(dst);
#line 913
        new_entry = tmp;
        }
#line 915
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 916
          return ((_Bool)0);
        }
#line 918
        new_entry->data = data;
#line 919
        new_entry->next = new_bucket->next;
#line 920
        new_bucket->next = new_entry;
      } else {
#line 925
        new_bucket->data = data;
#line 926
        (dst->n_buckets_used) ++;
      }
#line 928
      bucket->data = (void *)0;
#line 929
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 865
    bucket ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return ((_Bool)1);
}
}
#line 942 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t __attribute__((__pure__))  tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 947
  tmp = compute_bucket_size(candidate, table->tuning);
#line 947
  new_size = (size_t )tmp;
  }
#line 949
  if (! new_size) {
#line 950
    return ((_Bool)0);
  }
#line 951
  if (new_size == table->n_buckets) {
#line 952
    return ((_Bool)1);
  }
  {
#line 953
  new_table = & storage;
#line 954
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 954
  new_table->bucket = (struct hash_entry *)tmp___0;
  }
#line 955
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 956
    return ((_Bool)0);
  }
  {
#line 957
  new_table->n_buckets = new_size;
#line 958
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 959
  new_table->n_buckets_used = (size_t )0;
#line 960
  new_table->n_entries = (size_t )0;
#line 961
  new_table->tuning = table->tuning;
#line 962
  new_table->hasher = table->hasher;
#line 963
  new_table->comparator = table->comparator;
#line 964
  new_table->data_freer = table->data_freer;
#line 984
  new_table->free_entry_list = table->free_entry_list;
#line 986
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
  }
#line 986
  if (tmp___1) {
    {
#line 989
    free((void *)table->bucket);
#line 990
    table->bucket = new_table->bucket;
#line 991
    table->bucket_limit = new_table->bucket_limit;
#line 992
    table->n_buckets = new_table->n_buckets;
#line 993
    table->n_buckets_used = new_table->n_buckets_used;
#line 994
    table->free_entry_list = new_table->free_entry_list;
    }
#line 996
    return ((_Bool)1);
  }
  {
#line 1012
  table->free_entry_list = new_table->free_entry_list;
#line 1013
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
  }
#line 1013
  if (tmp___2) {
    {
#line 1013
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
    }
#line 1013
    if (! tmp___3) {
      {
#line 1015
      abort();
      }
    }
  } else {
    {
#line 1015
    abort();
    }
  }
  {
#line 1017
  free((void *)new_table->bucket);
  }
#line 1018
  return ((_Bool)0);
}
}
#line 1037 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
int hash_insert_if_absent(Hash_table *table , void const   *entry___0 , void const   **matched_ent ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1047
  if (! entry___0) {
    {
#line 1048
    abort();
    }
  }
  {
#line 1051
  data = hash_find_entry(table, entry___0, & bucket, (_Bool)0);
  }
#line 1051
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1053
    if (matched_ent) {
#line 1054
      *matched_ent = (void const   *)data;
    }
#line 1055
    return (0);
  }
#line 1063
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
    {
#line 1068
    check_tuning(table);
    }
#line 1069
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1072
      tuning = table->tuning;
#line 1073
      if (tuning->is_n_buckets) {
#line 1073
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1073
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1073
      candidate = (float )tmp;
#line 1079
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1080
        return (-1);
      }
      {
#line 1083
      tmp___0 = hash_rehash(table, (size_t )candidate);
      }
#line 1083
      if (! tmp___0) {
#line 1084
        return (-1);
      }
      {
#line 1087
      tmp___1 = hash_find_entry(table, entry___0, & bucket, (_Bool)0);
      }
#line 1087
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
        {
#line 1088
        abort();
        }
      }
    }
  }
#line 1094
  if (bucket->data) {
    {
#line 1096
    tmp___2 = allocate_entry(table);
#line 1096
    new_entry = tmp___2;
    }
#line 1098
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1099
      return (-1);
    }
#line 1103
    new_entry->data = (void *)entry___0;
#line 1104
    new_entry->next = bucket->next;
#line 1105
    bucket->next = new_entry;
#line 1106
    (table->n_entries) ++;
#line 1107
    return (1);
  }
#line 1112
  bucket->data = (void *)entry___0;
#line 1113
  (table->n_entries) ++;
#line 1114
  (table->n_buckets_used) ++;
#line 1116
  return (1);
}
}
#line 1125 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry___0 ) 
{ 
  void const   *matched_ent ;
  int err ;
  int tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1129
  tmp = hash_insert_if_absent(table, entry___0, & matched_ent);
#line 1129
  err = tmp;
  }
#line 1130
  if (err == -1) {
#line 1130
    tmp___1 = (void *)0;
  } else {
#line 1130
    if (err == 0) {
#line 1130
      tmp___0 = matched_ent;
    } else {
#line 1130
      tmp___0 = entry___0;
    }
#line 1130
    tmp___1 = (void *)tmp___0;
  }
#line 1130
  return (tmp___1);
}
}
#line 1139 "/home/khheo/project/benchmark/tar-1.29/gnu/hash.c"
void *hash_delete(Hash_table *table , void const   *entry___0 ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
  {
#line 1145
  data = hash_find_entry(table, entry___0, & bucket, (_Bool)1);
  }
#line 1146
  if (! data) {
#line 1147
    return ((void *)0);
  }
#line 1149
  (table->n_entries) --;
#line 1150
  if (! bucket->data) {
#line 1152
    (table->n_buckets_used) --;
#line 1157
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
      {
#line 1162
      check_tuning(table);
      }
#line 1163
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1166
        tuning = table->tuning;
#line 1167
        if (tuning->is_n_buckets) {
#line 1167
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1167
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
        {
#line 1167
        candidate = (size_t )tmp;
#line 1173
        tmp___0 = hash_rehash(table, candidate);
        }
#line 1173
        if (! tmp___0) {
#line 1181
          cursor = table->free_entry_list;
          {
#line 1183
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1183
            if (! cursor) {
#line 1183
              goto while_break;
            }
            {
#line 1185
            next = cursor->next;
#line 1186
            free((void *)cursor);
#line 1187
            cursor = next;
            }
          }
          while_break: /* CIL Label */ ;
          }
#line 1189
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1196
  return (data);
}
}
#line 219 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int tmp ;
  struct timeval tv ;

  {
  {
#line 36
  tmp = clock_gettime(0, ts);
  }
#line 36
  if (tmp == 0) {
#line 37
    return;
  }
  {
#line 42
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
  }
#line 48
  return;
}
}
#line 66 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 294
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) ;
#line 302
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/get-permissions.c"
int get_permissions(char const   *name , int desc , mode_t mode , struct permission_context *ctx ) 
{ 


  {
  {
#line 36
  memset((void *)ctx, 0, sizeof(*ctx));
#line 37
  ctx->mode = mode;
  }
#line 289
  return (0);
}
}
#line 150 "./getopt.h"
char *rpl_optarg  ;
#line 164
int rpl_optind ;
#line 169
int rpl_opterr ;
#line 173
int rpl_optopt ;
#line 243
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt)(int argc ,
                                                                                            char * const  *argv ,
                                                                                            char const   *optstring ) ;
#line 517 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt_int.h"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) ;
#line 118
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) ;
#line 82 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
int rpl_optind  =    1;
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
int rpl_opterr  =    1;
#line 93 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
int rpl_optopt  =    '?';
#line 97 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
static struct _getopt_data getopt_data  ;
#line 143 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
static void exchange(char **argv , struct _getopt_data *d ) 
{ 
  int bottom ;
  int middle ;
  int top ;
  char *tem ;
  int len ;
  register int i ;
  int len___0 ;
  register int i___0 ;

  {
#line 146
  bottom = d->__first_nonopt;
#line 147
  middle = d->__last_nonopt;
#line 148
  top = d->rpl_optind;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (top > middle) {
#line 178
      if (! (middle > bottom)) {
#line 178
        goto while_break;
      }
    } else {
#line 178
      goto while_break;
    }
#line 180
    if (top - middle > middle - bottom) {
#line 183
      len = middle - bottom;
#line 187
      i = 0;
      {
#line 187
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 187
        if (! (i < len)) {
#line 187
          goto while_break___0;
        }
#line 189
        tem = *(argv + (bottom + i));
#line 190
        *(argv + (bottom + i)) = *(argv + ((top - (middle - bottom)) + i));
#line 191
        *(argv + ((top - (middle - bottom)) + i)) = tem;
#line 187
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 195
      top -= len;
    } else {
#line 200
      len___0 = top - middle;
#line 204
      i___0 = 0;
      {
#line 204
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 204
        if (! (i___0 < len___0)) {
#line 204
          goto while_break___1;
        }
#line 206
        tem = *(argv + (bottom + i___0));
#line 207
        *(argv + (bottom + i___0)) = *(argv + (middle + i___0));
#line 208
        *(argv + (middle + i___0)) = tem;
#line 204
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 212
      bottom += len___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  d->__first_nonopt += d->rpl_optind - d->__last_nonopt;
#line 219
  d->__last_nonopt = d->rpl_optind;
#line 220
  return;
}
}
#line 224 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
static char const   *_getopt_initialize(int argc  __attribute__((__unused__)) , char **argv  __attribute__((__unused__)) ,
                                        char const   *optstring , struct _getopt_data *d ,
                                        int posixly_correct ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 233
  tmp = d->rpl_optind;
#line 233
  d->__last_nonopt = tmp;
#line 233
  d->__first_nonopt = tmp;
#line 235
  d->__nextchar = (char *)((void *)0);
#line 237
  if (posixly_correct) {
#line 237
    tmp___1 = 1;
  } else {
    {
#line 237
    tmp___0 = getenv("POSIXLY_CORRECT");
    }
#line 237
    if (tmp___0) {
#line 237
      tmp___1 = 1;
    } else {
#line 237
      tmp___1 = 0;
    }
  }
#line 237
  d->__posixly_correct = tmp___1;
#line 241
  if ((int const   )*(optstring + 0) == 45) {
#line 243
    d->__ordering = (enum __ord )2;
#line 244
    optstring ++;
  } else
#line 246
  if ((int const   )*(optstring + 0) == 43) {
#line 248
    d->__ordering = (enum __ord )0;
#line 249
    optstring ++;
  } else
#line 251
  if (d->__posixly_correct) {
#line 252
    d->__ordering = (enum __ord )0;
  } else {
#line 254
    d->__ordering = (enum __ord )1;
  }
#line 286
  return (optstring);
}
}
#line 345 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
int _getopt_internal_r(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                       int *longind , int long_only , struct _getopt_data *d , int posixly_correct ) 
{ 
  int print_errors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *nameend ;
  unsigned int namelen ;
  struct rpl_option  const  *p ;
  struct rpl_option  const  *pfound ;
  struct option_list *ambig_list ;
  int exact ;
  int ambig ;
  int indfound ;
  int option_index ;
  struct option_list *newp ;
  void *tmp___2 ;
  struct option_list *pn ;
  size_t tmp___3 ;
  int tmp___4 ;
  struct option_list first ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  struct option_list *pn___0 ;
  struct option_list *pn___1 ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  size_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char c ;
  char *tmp___20 ;
  char const   *temp ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *nameend___0 ;
  struct rpl_option  const  *p___0 ;
  struct rpl_option  const  *pfound___0 ;
  int exact___0 ;
  int ambig___0 ;
  int indfound___0 ;
  int option_index___0 ;
  char *tmp___23 ;
  int tmp___24 ;
  size_t tmp___25 ;
  int tmp___26 ;
  char *tmp___27 ;
  size_t tmp___28 ;
  char *tmp___29 ;
  size_t tmp___30 ;
  int tmp___31 ;
  char *tmp___32 ;
  size_t tmp___33 ;
  int tmp___34 ;
  size_t tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;

  {
#line 350
  print_errors = d->rpl_opterr;
#line 352
  if (argc < 1) {
#line 353
    return (-1);
  }
#line 355
  d->rpl_optarg = (char *)((void *)0);
#line 357
  if (d->rpl_optind == 0) {
#line 357
    goto _L;
  } else
#line 357
  if (! d->__initialized) {
    _L: /* CIL Label */ 
#line 359
    if (d->rpl_optind == 0) {
#line 360
      d->rpl_optind = 1;
    }
    {
#line 361
    optstring = _getopt_initialize(argc, argv, optstring, d, posixly_correct);
#line 363
    d->__initialized = 1;
    }
  } else
#line 365
  if ((int const   )*(optstring + 0) == 45) {
#line 366
    optstring ++;
  } else
#line 365
  if ((int const   )*(optstring + 0) == 43) {
#line 366
    optstring ++;
  }
#line 367
  if ((int const   )*(optstring + 0) == 58) {
#line 368
    print_errors = 0;
  }
#line 382
  if ((unsigned long )d->__nextchar == (unsigned long )((void *)0)) {
#line 382
    goto _L___3;
  } else
#line 382
  if ((int )*(d->__nextchar) == 0) {
    _L___3: /* CIL Label */ 
#line 388
    if (d->__last_nonopt > d->rpl_optind) {
#line 389
      d->__last_nonopt = d->rpl_optind;
    }
#line 390
    if (d->__first_nonopt > d->rpl_optind) {
#line 391
      d->__first_nonopt = d->rpl_optind;
    }
#line 393
    if ((unsigned int )d->__ordering == 1U) {
#line 398
      if (d->__first_nonopt != d->__last_nonopt) {
#line 398
        if (d->__last_nonopt != d->rpl_optind) {
          {
#line 400
          exchange(argv, d);
          }
        } else {
#line 398
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 401
      if (d->__last_nonopt != d->rpl_optind) {
#line 402
        d->__first_nonopt = d->rpl_optind;
      }
      {
#line 407
      while (1) {
        while_continue: /* CIL Label */ ;
#line 407
        if (d->rpl_optind < argc) {
#line 407
          if (! ((int )*(*(argv + d->rpl_optind) + 0) != 45)) {
#line 407
            if (! ((int )*(*(argv + d->rpl_optind) + 1) == 0)) {
#line 407
              goto while_break;
            }
          }
        } else {
#line 407
          goto while_break;
        }
#line 408
        (d->rpl_optind) ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 409
      d->__last_nonopt = d->rpl_optind;
    }
#line 417
    if (d->rpl_optind != argc) {
      {
#line 417
      tmp = strcmp((char const   *)*(argv + d->rpl_optind), "--");
      }
#line 417
      if (! tmp) {
#line 419
        (d->rpl_optind) ++;
#line 421
        if (d->__first_nonopt != d->__last_nonopt) {
#line 421
          if (d->__last_nonopt != d->rpl_optind) {
            {
#line 423
            exchange(argv, d);
            }
          } else {
#line 421
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 424
        if (d->__first_nonopt == d->__last_nonopt) {
#line 425
          d->__first_nonopt = d->rpl_optind;
        }
#line 426
        d->__last_nonopt = argc;
#line 428
        d->rpl_optind = argc;
      }
    }
#line 434
    if (d->rpl_optind == argc) {
#line 438
      if (d->__first_nonopt != d->__last_nonopt) {
#line 439
        d->rpl_optind = d->__first_nonopt;
      }
#line 440
      return (-1);
    }
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 0) != 45) {
#line 446
      goto _L___2;
    } else
#line 446
    if ((int )*(*(argv + d->rpl_optind) + 1) == 0) {
      _L___2: /* CIL Label */ 
#line 448
      if ((unsigned int )d->__ordering == 0U) {
#line 449
        return (-1);
      }
#line 450
      tmp___0 = d->rpl_optind;
#line 450
      (d->rpl_optind) ++;
#line 450
      d->rpl_optarg = *(argv + tmp___0);
#line 451
      return (1);
    }
#line 457
    if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 457
      if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 457
        tmp___1 = 1;
      } else {
#line 457
        tmp___1 = 0;
      }
    } else {
#line 457
      tmp___1 = 0;
    }
#line 457
    d->__nextchar = (*(argv + d->rpl_optind) + 1) + tmp___1;
  }
#line 476
  if ((unsigned long )longopts != (unsigned long )((void *)0)) {
#line 476
    if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 476
      goto _L___9;
    } else
#line 476
    if (long_only) {
#line 476
      if (*(*(argv + d->rpl_optind) + 2)) {
#line 476
        goto _L___9;
      } else {
        {
#line 476
        tmp___19 = strchr(optstring, (int )*(*(argv + d->rpl_optind) + 1));
        }
#line 476
        if (! tmp___19) {
          _L___9: /* CIL Label */ 
#line 484
          pfound = (struct rpl_option  const  *)((void *)0);
#line 485
          ambig_list = (struct option_list *)((void *)0);
#line 502
          exact = 0;
#line 503
          ambig = 0;
#line 504
          indfound = -1;
#line 507
          nameend = d->__nextchar;
          {
#line 507
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 507
            if (*nameend) {
#line 507
              if (! ((int )*nameend != 61)) {
#line 507
                goto while_break___0;
              }
            } else {
#line 507
              goto while_break___0;
            }
#line 507
            nameend ++;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 509
          namelen = (unsigned int )(nameend - d->__nextchar);
#line 513
          p = longopts;
#line 513
          option_index = 0;
          {
#line 513
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 513
            if (! p->name) {
#line 513
              goto while_break___1;
            }
            {
#line 514
            tmp___4 = strncmp((char const   *)p->name, (char const   *)d->__nextchar,
                              (size_t )namelen);
            }
#line 514
            if (! tmp___4) {
              {
#line 516
              tmp___3 = strlen((char const   *)p->name);
              }
#line 516
              if (namelen == (unsigned int )tmp___3) {
#line 519
                pfound = p;
#line 520
                indfound = option_index;
#line 521
                exact = 1;
#line 522
                goto while_break___1;
              } else
#line 524
              if ((unsigned long )pfound == (unsigned long )((void *)0)) {
#line 527
                pfound = p;
#line 528
                indfound = option_index;
              } else
#line 530
              if (! ambig) {
#line 532
                if (long_only) {
#line 532
                  goto _L___4;
                } else
#line 532
                if (pfound->has_arg != p->has_arg) {
#line 532
                  goto _L___4;
                } else
#line 532
                if ((unsigned long )pfound->flag != (unsigned long )p->flag) {
#line 532
                  goto _L___4;
                } else
#line 532
                if (pfound->val != p->val) {
                  _L___4: /* CIL Label */ 
                  {
#line 541
                  tmp___2 = malloc(sizeof(*newp));
#line 541
                  newp = (struct option_list *)tmp___2;
                  }
#line 542
                  if ((unsigned long )newp == (unsigned long )((void *)0)) {
                    {
#line 544
                    while (1) {
                      while_continue___2: /* CIL Label */ ;
#line 544
                      if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 544
                        goto while_break___2;
                      }
                      {
#line 544
                      pn = ambig_list->next;
#line 544
                      free((void *)ambig_list);
#line 544
                      ambig_list = pn;
                      }
                    }
                    while_break___2: /* CIL Label */ ;
                    }
#line 545
                    ambig_list = (struct option_list *)((void *)0);
#line 546
                    ambig = 1;
                  } else {
#line 551
                    newp->p = p;
#line 552
                    newp->next = ambig_list;
#line 553
                    ambig_list = newp;
                  }
                }
              }
            }
#line 513
            p ++;
#line 513
            option_index ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 558
          if (ambig) {
#line 558
            goto _L___6;
          } else
#line 558
          if (ambig_list) {
            _L___6: /* CIL Label */ 
#line 558
            if (! exact) {
#line 560
              if (print_errors) {
#line 560
                if (ambig_list) {
                  {
#line 563
                  first.p = pfound;
#line 564
                  first.next = ambig_list;
#line 565
                  ambig_list = & first;
#line 603
                  tmp___5 = gettext("%s: option \'%s\' is ambiguous; possibilities:");
#line 603
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5,
                          *(argv + 0), *(argv + d->rpl_optind));
                  }
                  {
#line 606
                  while (1) {
                    while_continue___3: /* CIL Label */ ;
                    {
#line 608
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" \'--%s\'",
                            (ambig_list->p)->name);
#line 609
                    ambig_list = ambig_list->next;
                    }
#line 606
                    if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 606
                      goto while_break___3;
                    }
                  }
                  while_break___3: /* CIL Label */ ;
                  }
                  {
#line 613
                  fputc('\n', stderr);
                  }
                } else {
#line 560
                  goto _L___5;
                }
              } else
              _L___5: /* CIL Label */ 
#line 616
              if (print_errors) {
#line 616
                if (ambig) {
                  {
#line 618
                  tmp___6 = gettext("%s: option \'%s\' is ambiguous\n");
#line 618
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6,
                          *(argv + 0), *(argv + d->rpl_optind));
                  }
                }
              }
              {
#line 622
              tmp___7 = strlen((char const   *)d->__nextchar);
#line 622
              d->__nextchar += tmp___7;
#line 623
              (d->rpl_optind) ++;
#line 624
              d->rpl_optopt = 0;
              }
              {
#line 625
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 625
                if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 625
                  goto while_break___4;
                }
                {
#line 625
                pn___0 = ambig_list->next;
#line 625
                free((void *)ambig_list);
#line 625
                ambig_list = pn___0;
                }
              }
              while_break___4: /* CIL Label */ ;
              }
#line 626
              return ('?');
            }
          }
          {
#line 629
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 629
            if (! ((unsigned long )ambig_list != (unsigned long )((void *)0))) {
#line 629
              goto while_break___5;
            }
            {
#line 629
            pn___1 = ambig_list->next;
#line 629
            free((void *)ambig_list);
#line 629
            ambig_list = pn___1;
            }
          }
          while_break___5: /* CIL Label */ ;
          }
#line 631
          if ((unsigned long )pfound != (unsigned long )((void *)0)) {
#line 633
            option_index = indfound;
#line 634
            (d->rpl_optind) ++;
#line 635
            if (*nameend) {
#line 639
              if (pfound->has_arg) {
#line 640
                d->rpl_optarg = nameend + 1;
              } else {
#line 643
                if (print_errors) {
#line 650
                  if ((int )*(*(argv + (d->rpl_optind - 1)) + 1) == 45) {
                    {
#line 658
                    tmp___8 = gettext("%s: option \'--%s\' doesn\'t allow an argument\n");
#line 658
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___8,
                            *(argv + 0), pfound->name);
                    }
                  } else {
                    {
#line 672
                    tmp___9 = gettext("%s: option \'%c%s\' doesn\'t allow an argument\n");
#line 672
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___9,
                            *(argv + 0), (int )*(*(argv + (d->rpl_optind - 1)) + 0),
                            pfound->name);
                    }
                  }
                }
                {
#line 698
                tmp___10 = strlen((char const   *)d->__nextchar);
#line 698
                d->__nextchar += tmp___10;
#line 700
                d->rpl_optopt = (int )pfound->val;
                }
#line 701
                return ('?');
              }
            } else
#line 704
            if (pfound->has_arg == 1) {
#line 706
              if (d->rpl_optind < argc) {
#line 707
                tmp___11 = d->rpl_optind;
#line 707
                (d->rpl_optind) ++;
#line 707
                d->rpl_optarg = *(argv + tmp___11);
              } else {
#line 710
                if (print_errors) {
                  {
#line 733
                  tmp___12 = gettext("%s: option \'--%s\' requires an argument\n");
#line 733
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___12,
                          *(argv + 0), pfound->name);
                  }
                }
                {
#line 738
                tmp___13 = strlen((char const   *)d->__nextchar);
#line 738
                d->__nextchar += tmp___13;
#line 739
                d->rpl_optopt = (int )pfound->val;
                }
#line 740
                if ((int const   )*(optstring + 0) == 58) {
#line 740
                  tmp___14 = ':';
                } else {
#line 740
                  tmp___14 = '?';
                }
#line 740
                return (tmp___14);
              }
            }
            {
#line 743
            tmp___15 = strlen((char const   *)d->__nextchar);
#line 743
            d->__nextchar += tmp___15;
            }
#line 744
            if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 745
              *longind = option_index;
            }
#line 746
            if (pfound->flag) {
#line 748
              *(pfound->flag) = (int )pfound->val;
#line 749
              return (0);
            }
#line 751
            return ((int )pfound->val);
          }
#line 758
          if (! long_only) {
#line 758
            goto _L___7;
          } else
#line 758
          if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
#line 758
            goto _L___7;
          } else {
            {
#line 758
            tmp___18 = strchr(optstring, (int )*(d->__nextchar));
            }
#line 758
            if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
              _L___7: /* CIL Label */ 
#line 761
              if (print_errors) {
#line 768
                if ((int )*(*(argv + d->rpl_optind) + 1) == 45) {
                  {
#line 775
                  tmp___16 = gettext("%s: unrecognized option \'--%s\'\n");
#line 775
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___16,
                          *(argv + 0), d->__nextchar);
                  }
                } else {
                  {
#line 786
                  tmp___17 = gettext("%s: unrecognized option \'%c%s\'\n");
#line 786
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___17,
                          *(argv + 0), (int )*(*(argv + d->rpl_optind) + 0), d->__nextchar);
                  }
                }
              }
#line 808
              d->__nextchar = (char *)"";
#line 809
              (d->rpl_optind) ++;
#line 810
              d->rpl_optopt = 0;
#line 811
              return ('?');
            }
          }
        }
      }
    }
  }
  {
#line 818
  tmp___20 = d->__nextchar;
#line 818
  (d->__nextchar) ++;
#line 818
  c = *tmp___20;
#line 819
  tmp___21 = strchr(optstring, (int )c);
#line 819
  temp = (char const   *)tmp___21;
  }
#line 822
  if ((int )*(d->__nextchar) == 0) {
#line 823
    (d->rpl_optind) ++;
  }
#line 825
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
#line 825
    goto _L___10;
  } else
#line 825
  if ((int )c == 58) {
#line 825
    goto _L___10;
  } else
#line 825
  if ((int )c == 59) {
    _L___10: /* CIL Label */ 
#line 827
    if (print_errors) {
      {
#line 838
      tmp___22 = gettext("%s: invalid option -- \'%c\'\n");
#line 838
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___22,
              *(argv + 0), (int )c);
      }
    }
#line 858
    d->rpl_optopt = (int )c;
#line 859
    return ('?');
  }
#line 862
  if ((int const   )*(temp + 0) == 87) {
#line 862
    if ((int const   )*(temp + 1) == 59) {
#line 866
      pfound___0 = (struct rpl_option  const  *)((void *)0);
#line 867
      exact___0 = 0;
#line 868
      ambig___0 = 0;
#line 869
      indfound___0 = 0;
#line 872
      if ((unsigned long )longopts == (unsigned long )((void *)0)) {
#line 873
        goto no_longs;
      }
#line 876
      if ((int )*(d->__nextchar) != 0) {
#line 878
        d->rpl_optarg = d->__nextchar;
#line 881
        (d->rpl_optind) ++;
      } else
#line 883
      if (d->rpl_optind == argc) {
#line 885
        if (print_errors) {
          {
#line 907
          tmp___23 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 907
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___23,
                  *(argv + 0), (int )c);
          }
        }
#line 912
        d->rpl_optopt = (int )c;
#line 913
        if ((int const   )*(optstring + 0) == 58) {
#line 914
          c = (char )':';
        } else {
#line 916
          c = (char )'?';
        }
#line 917
        return ((int )c);
      } else {
#line 922
        tmp___24 = d->rpl_optind;
#line 922
        (d->rpl_optind) ++;
#line 922
        d->rpl_optarg = *(argv + tmp___24);
      }
#line 927
      nameend___0 = d->rpl_optarg;
#line 927
      d->__nextchar = nameend___0;
      {
#line 927
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 927
        if (*nameend___0) {
#line 927
          if (! ((int )*nameend___0 != 61)) {
#line 927
            goto while_break___6;
          }
        } else {
#line 927
          goto while_break___6;
        }
#line 927
        nameend___0 ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 933
      p___0 = longopts;
#line 933
      option_index___0 = 0;
      {
#line 933
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 933
        if (! p___0->name) {
#line 933
          goto while_break___7;
        }
        {
#line 934
        tmp___26 = strncmp((char const   *)p___0->name, (char const   *)d->__nextchar,
                           (size_t )(nameend___0 - d->__nextchar));
        }
#line 934
        if (! tmp___26) {
          {
#line 936
          tmp___25 = strlen((char const   *)p___0->name);
          }
#line 936
          if ((size_t )((unsigned int )(nameend___0 - d->__nextchar)) == tmp___25) {
#line 939
            pfound___0 = p___0;
#line 940
            indfound___0 = option_index___0;
#line 941
            exact___0 = 1;
#line 942
            goto while_break___7;
          } else
#line 944
          if ((unsigned long )pfound___0 == (unsigned long )((void *)0)) {
#line 947
            pfound___0 = p___0;
#line 948
            indfound___0 = option_index___0;
          } else
#line 950
          if (long_only) {
#line 955
            ambig___0 = 1;
          } else
#line 950
          if (pfound___0->has_arg != p___0->has_arg) {
#line 955
            ambig___0 = 1;
          } else
#line 950
          if ((unsigned long )pfound___0->flag != (unsigned long )p___0->flag) {
#line 955
            ambig___0 = 1;
          } else
#line 950
          if (pfound___0->val != p___0->val) {
#line 955
            ambig___0 = 1;
          }
        }
#line 933
        p___0 ++;
#line 933
        option_index___0 ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 957
      if (ambig___0) {
#line 957
        if (! exact___0) {
#line 959
          if (print_errors) {
            {
#line 980
            tmp___27 = gettext("%s: option \'-W %s\' is ambiguous\n");
#line 980
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___27,
                    *(argv + 0), d->rpl_optarg);
            }
          }
          {
#line 984
          tmp___28 = strlen((char const   *)d->__nextchar);
#line 984
          d->__nextchar += tmp___28;
#line 985
          (d->rpl_optind) ++;
          }
#line 986
          return ('?');
        }
      }
#line 988
      if ((unsigned long )pfound___0 != (unsigned long )((void *)0)) {
#line 990
        option_index___0 = indfound___0;
#line 991
        if (*nameend___0) {
#line 995
          if (pfound___0->has_arg) {
#line 996
            d->rpl_optarg = nameend___0 + 1;
          } else {
#line 999
            if (print_errors) {
              {
#line 1022
              tmp___29 = gettext("%s: option \'-W %s\' doesn\'t allow an argument\n");
#line 1022
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___29,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1028
            tmp___30 = strlen((char const   *)d->__nextchar);
#line 1028
            d->__nextchar += tmp___30;
            }
#line 1029
            return ('?');
          }
        } else
#line 1032
        if (pfound___0->has_arg == 1) {
#line 1034
          if (d->rpl_optind < argc) {
#line 1035
            tmp___31 = d->rpl_optind;
#line 1035
            (d->rpl_optind) ++;
#line 1035
            d->rpl_optarg = *(argv + tmp___31);
          } else {
#line 1038
            if (print_errors) {
              {
#line 1061
              tmp___32 = gettext("%s: option \'-W %s\' requires an argument\n");
#line 1061
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___32,
                      *(argv + 0), pfound___0->name);
              }
            }
            {
#line 1066
            tmp___33 = strlen((char const   *)d->__nextchar);
#line 1066
            d->__nextchar += tmp___33;
            }
#line 1067
            if ((int const   )*(optstring + 0) == 58) {
#line 1067
              tmp___34 = ':';
            } else {
#line 1067
              tmp___34 = '?';
            }
#line 1067
            return (tmp___34);
          }
        } else {
#line 1071
          d->rpl_optarg = (char *)((void *)0);
        }
        {
#line 1072
        tmp___35 = strlen((char const   *)d->__nextchar);
#line 1072
        d->__nextchar += tmp___35;
        }
#line 1073
        if ((unsigned long )longind != (unsigned long )((void *)0)) {
#line 1074
          *longind = option_index___0;
        }
#line 1075
        if (pfound___0->flag) {
#line 1077
          *(pfound___0->flag) = (int )pfound___0->val;
#line 1078
          return (0);
        }
#line 1080
        return ((int )pfound___0->val);
      }
      no_longs: 
#line 1084
      d->__nextchar = (char *)((void *)0);
#line 1085
      return ('W');
    }
  }
#line 1087
  if ((int const   )*(temp + 1) == 58) {
#line 1089
    if ((int const   )*(temp + 2) == 58) {
#line 1092
      if ((int )*(d->__nextchar) != 0) {
#line 1094
        d->rpl_optarg = d->__nextchar;
#line 1095
        (d->rpl_optind) ++;
      } else {
#line 1098
        d->rpl_optarg = (char *)((void *)0);
      }
#line 1099
      d->__nextchar = (char *)((void *)0);
    } else {
#line 1104
      if ((int )*(d->__nextchar) != 0) {
#line 1106
        d->rpl_optarg = d->__nextchar;
#line 1109
        (d->rpl_optind) ++;
      } else
#line 1111
      if (d->rpl_optind == argc) {
#line 1113
        if (print_errors) {
          {
#line 1135
          tmp___36 = gettext("%s: option requires an argument -- \'%c\'\n");
#line 1135
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___36,
                  *(argv + 0), (int )c);
          }
        }
#line 1140
        d->rpl_optopt = (int )c;
#line 1141
        if ((int const   )*(optstring + 0) == 58) {
#line 1142
          c = (char )':';
        } else {
#line 1144
          c = (char )'?';
        }
      } else {
#line 1149
        tmp___37 = d->rpl_optind;
#line 1149
        (d->rpl_optind) ++;
#line 1149
        d->rpl_optarg = *(argv + tmp___37);
      }
#line 1150
      d->__nextchar = (char *)((void *)0);
    }
  }
#line 1153
  return ((int )c);
}
}
#line 1157 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
int rpl_getopt_internal(int argc , char **argv , char const   *optstring , struct rpl_option  const  *longopts ,
                        int *longind , int long_only , int posixly_correct ) 
{ 
  int result ;

  {
  {
#line 1164
  getopt_data.rpl_optind = rpl_optind;
#line 1165
  getopt_data.rpl_opterr = rpl_opterr;
#line 1167
  result = _getopt_internal_r(argc, argv, optstring, longopts, longind, long_only,
                              & getopt_data, posixly_correct);
#line 1171
  rpl_optind = getopt_data.rpl_optind;
#line 1172
  rpl_optarg = getopt_data.rpl_optarg;
#line 1173
  rpl_optopt = getopt_data.rpl_optopt;
  }
#line 1175
  return (result);
}
}
#line 1186
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt)(int argc ,
                                                                                            char * const  *argv ,
                                                                                            char const   *optstring ) ;
#line 1186 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt)(int argc , char * const  *argv ,
                                                              char const   *optstring ) 
{ 
  int tmp ;

  {
  {
#line 1189
  tmp = rpl_getopt_internal(argc, (char **)argv, optstring, (struct rpl_option  const  *)0,
                            (int *)0, 0, 1);
  }
#line 1189
  return (tmp);
}
}
#line 247 "./getopt.h"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt_long)(int argc ,
                                                                                                 char **argv ,
                                                                                                 char const   *options___0 ,
                                                                                                 struct rpl_option  const  *long_options ,
                                                                                                 int *opt_index ) ;
#line 251
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt_long_only)(int argc ,
                                                                                                      char **argv ,
                                                                                                      char const   *options___0 ,
                                                                                                      struct rpl_option  const  *long_options ,
                                                                                                      int *opt_index ) ;
#line 124 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt_int.h"
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) ;
#line 129
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) ;
#line 39 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt1.c"
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt_long)(int argc ,
                                                                                                 char **argv ,
                                                                                                 char const   *options___0 ,
                                                                                                 struct rpl_option  const  *long_options ,
                                                                                                 int *opt_index ) ;
#line 39 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt1.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt_long)(int argc , char **argv ,
                                                                   char const   *options___0 ,
                                                                   struct rpl_option  const  *long_options ,
                                                                   int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 43
  tmp = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index, 0, 0);
  }
#line 43
  return (tmp);
}
}
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt1.c"
int _getopt_long_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                   int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 52
  tmp = _getopt_internal_r(argc, argv, options___0, long_options, opt_index, 0, d,
                           0);
  }
#line 52
  return (tmp);
}
}
#line 61
 __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt_long_only)(int argc ,
                                                                                                      char **argv ,
                                                                                                      char const   *options___0 ,
                                                                                                      struct rpl_option  const  *long_options ,
                                                                                                      int *opt_index ) ;
#line 61 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt1.c"
int ( __attribute__((__nonnull__(2,3), __leaf__)) rpl_getopt_long_only)(int argc ,
                                                                        char **argv ,
                                                                        char const   *options___0 ,
                                                                        struct rpl_option  const  *long_options ,
                                                                        int *opt_index ) 
{ 
  int tmp ;

  {
  {
#line 66
  tmp = rpl_getopt_internal(argc, argv, options___0, long_options, opt_index, 1, 0);
  }
#line 66
  return (tmp);
}
}
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/getopt1.c"
int _getopt_long_only_r(int argc , char **argv , char const   *options___0 , struct rpl_option  const  *long_options ,
                        int *opt_index , struct _getopt_data *d ) 
{ 
  int tmp ;

  {
  {
#line 75
  tmp = _getopt_internal_r(argc, argv, options___0, long_options, opt_index, 1, d,
                           0);
  }
#line 75
  return (tmp);
}
}
#line 712 "./sys/stat.h"
int rpl_futimens(int fd , struct timespec  const  *times ) ;
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 47
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/futimens.c"
int rpl_futimens(int fd , struct timespec  const  *times ) 
{ 
  int tmp ;

  {
  {
#line 36
  tmp = fdutimens(fd, (char const   *)((void *)0), times);
  }
#line 36
  return (tmp);
}
}
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/full-write.h"
size_t full_write(int fd , void const   *buf , size_t count ) ;
#line 57 "/home/khheo/project/benchmark/tar-1.29/gnu/full-write.c"
size_t full_write(int fd , void const   *buf , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 60
  total = (size_t )0;
#line 61
  ptr = (char const   *)buf;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (count > 0UL)) {
#line 63
      goto while_break;
    }
    {
#line 65
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 65
    n_rw = tmp;
    }
#line 66
    if (n_rw == 0xffffffffffffffffUL) {
#line 67
      goto while_break;
    }
#line 68
    if (n_rw == 0UL) {
      {
#line 70
      tmp___0 = __errno_location();
#line 70
      *tmp___0 = 28;
      }
#line 71
      goto while_break;
    }
#line 73
    total += n_rw;
#line 74
    ptr += n_rw;
#line 75
    count -= n_rw;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return (total);
}
}
#line 652 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , timezone_t tz ,
                   int ns ) ;
#line 287 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    tmp___0 = len;
#line 290
    len --;
#line 290
    if (! (tmp___0 > 0UL)) {
#line 290
      goto while_break;
    }
    {
#line 292
    tmp = tolower((int )((unsigned char )*src));
#line 292
    fputc(tmp, fp);
#line 293
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 295
  return;
}
}
#line 297 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    tmp___0 = len;
#line 300
    len --;
#line 300
    if (! (tmp___0 > 0UL)) {
#line 300
      goto while_break;
    }
    {
#line 302
    tmp = toupper((int )((unsigned char )*src));
#line 302
    fputc(tmp, fp);
#line 303
    src ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return;
}
}
#line 407 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
static size_t strftime_case____0(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                                 timezone_t tz , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  struct tm copy ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  size_t _n ;
  size_t _w ;
  int tmp ;
  size_t _incr ;
  size_t tmp___0 ;
  size_t _delta ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___1 ;
  size_t _n___0 ;
  size_t _w___0 ;
  int tmp___2 ;
  size_t _incr___0 ;
  size_t tmp___3 ;
  size_t _delta___0 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___4 ;
  size_t _n___1 ;
  size_t _w___1 ;
  int tmp___5 ;
  size_t _incr___1 ;
  size_t tmp___6 ;
  size_t _delta___1 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  size_t _n___2 ;
  size_t _w___2 ;
  int tmp___11 ;
  size_t _incr___2 ;
  size_t tmp___12 ;
  size_t _delta___2 ;
  size_t _i___5 ;
  size_t _i___6 ;
  int century ;
  int tmp___13 ;
  int tmp___14 ;
  size_t _n___3 ;
  size_t _w___3 ;
  int tmp___15 ;
  size_t _incr___3 ;
  size_t tmp___16 ;
  size_t _delta___3 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  size_t _n___4 ;
  size_t _w___4 ;
  int tmp___17 ;
  size_t _incr___4 ;
  size_t tmp___18 ;
  size_t _delta___4 ;
  size_t _i___10 ;
  size_t _i___11 ;
  size_t _n___5 ;
  size_t _w___5 ;
  int tmp___19 ;
  size_t _incr___5 ;
  size_t tmp___20 ;
  size_t _delta___5 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  size_t _n___6 ;
  size_t _w___6 ;
  int tmp___21 ;
  size_t _incr___6 ;
  size_t tmp___22 ;
  size_t _delta___6 ;
  size_t _i___15 ;
  size_t _i___16 ;
  size_t _n___7 ;
  size_t _w___7 ;
  int tmp___23 ;
  size_t _incr___7 ;
  size_t tmp___24 ;
  size_t _delta___7 ;
  size_t _i___17 ;
  size_t _i___18 ;
  int j ;
  size_t _n___8 ;
  size_t _w___8 ;
  int tmp___25 ;
  size_t _incr___8 ;
  size_t tmp___26 ;
  size_t _delta___8 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___27 ;
  size_t _n___9 ;
  size_t _w___9 ;
  int tmp___28 ;
  size_t _incr___9 ;
  size_t tmp___29 ;
  size_t _delta___9 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year ;
  int tmp___30 ;
  int year_adjust ;
  int days ;
  int tmp___31 ;
  int tmp___32 ;
  int d___0 ;
  int tmp___33 ;
  int tmp___34 ;
  int yy ;
  int tmp___35 ;
  int yy___0 ;
  size_t _n___10 ;
  size_t tmp___36 ;
  size_t _w___10 ;
  int tmp___37 ;
  size_t _incr___10 ;
  size_t tmp___38 ;
  size_t _delta___10 ;
  size_t _i___23 ;
  size_t _i___24 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  size_t _n___11 ;
  size_t _w___11 ;
  int tmp___39 ;
  size_t _incr___11 ;
  size_t tmp___40 ;
  size_t _delta___11 ;
  size_t _i___25 ;
  size_t _i___26 ;

  {
#line 417
  maxsize = (size_t )-1;
#line 420
  hour12 = (int )tp->tm_hour;
#line 448
  i = (size_t )0;
#line 449
  p = s;
#line 460
  copy = *tp;
#line 461
  tp = (struct tm  const  *)(& copy);
#line 464
  zone = (char const   *)((void *)0);
#line 472
  zone = (char const   *)tp->tm_zone;
#line 496
  if (! zone) {
#line 497
    zone = "";
  }
#line 499
  if (hour12 > 12) {
#line 500
    hour12 -= 12;
  } else
#line 502
  if (hour12 == 0) {
#line 503
    hour12 = 12;
  }
#line 505
  f = format;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! ((int const   )*f != 0)) {
#line 505
      goto while_break;
    }
#line 507
    pad = 0;
#line 509
    digits = 0;
#line 523
    width = -1;
#line 524
    to_lowcase = (_Bool)0;
#line 525
    to_uppcase = upcase;
#line 527
    change_case = (_Bool)0;
#line 610
    if ((int const   )*f != 37) {
      {
#line 612
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 612
        _n = (size_t )1;
#line 612
        if (width < 0) {
#line 612
          tmp = 0;
        } else {
#line 612
          tmp = width;
        }
#line 612
        _w = (size_t )tmp;
#line 612
        if (_n < _w) {
#line 612
          tmp___0 = _w;
        } else {
#line 612
          tmp___0 = _n;
        }
#line 612
        _incr = tmp___0;
#line 612
        if (_incr >= maxsize - i) {
#line 612
          return ((size_t )0);
        }
#line 612
        if (p) {
#line 612
          if (digits == 0) {
#line 612
            if (_n < _w) {
#line 612
              _delta = (size_t )width - _n;
#line 612
              if (pad == 48) {
                {
#line 612
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 612
                  _i = (size_t )0;
                  {
#line 612
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 612
                    if (! (_i < _delta)) {
#line 612
                      goto while_break___2;
                    }
                    {
#line 612
                    fputc('0', p);
#line 612
                    _i ++;
                    }
                  }
                  while_break___2: /* CIL Label */ ;
                  }
#line 612
                  goto while_break___1;
                }
                while_break___1: /* CIL Label */ ;
                }
              } else {
                {
#line 612
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 612
                  _i___0 = (size_t )0;
                  {
#line 612
                  while (1) {
                    while_continue___4: /* CIL Label */ ;
#line 612
                    if (! (_i___0 < _delta)) {
#line 612
                      goto while_break___4;
                    }
                    {
#line 612
                    fputc(' ', p);
#line 612
                    _i___0 ++;
                    }
                  }
                  while_break___4: /* CIL Label */ ;
                  }
#line 612
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 612
          fputc((int )*f, p);
          }
        }
#line 612
        i += _incr;
#line 612
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 613
      goto __Cont;
    }
    {
#line 619
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 621
      f ++;
      {
#line 626
      if ((int const   )*f == 48) {
#line 626
        goto case_48;
      }
#line 626
      if ((int const   )*f == 45) {
#line 626
        goto case_48;
      }
#line 626
      if ((int const   )*f == 95) {
#line 626
        goto case_48;
      }
#line 631
      if ((int const   )*f == 94) {
#line 631
        goto case_94;
      }
#line 634
      if ((int const   )*f == 35) {
#line 634
        goto case_35;
      }
#line 638
      goto switch_default;
      case_48: /* CIL Label */ 
      case_45: /* CIL Label */ 
      case_95: /* CIL Label */ 
#line 627
      pad = (int )*f;
#line 628
      goto while_continue___5;
      case_94: /* CIL Label */ 
#line 632
      to_uppcase = (_Bool)1;
#line 633
      goto while_continue___5;
      case_35: /* CIL Label */ 
#line 635
      change_case = (_Bool)1;
#line 636
      goto while_continue___5;
      switch_default: /* CIL Label */ 
#line 639
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 641
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 645
    if ((unsigned int )*f - 48U <= 9U) {
#line 647
      width = 0;
      {
#line 648
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 650
        if (width > 214748364) {
#line 653
          width = 2147483647;
        } else
#line 650
        if (width == 214748364) {
#line 650
          if ((int const   )*f - 48 > 7) {
#line 653
            width = 2147483647;
          } else {
#line 656
            width *= 10;
#line 657
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 656
          width *= 10;
#line 657
          width += (int )((int const   )*f - 48);
        }
#line 659
        f ++;
#line 648
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 648
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
    {
#line 668
    if ((int const   )*f == 79) {
#line 668
      goto case_79;
    }
#line 668
    if ((int const   )*f == 69) {
#line 668
      goto case_79;
    }
#line 672
    goto switch_default___0;
    case_79: /* CIL Label */ 
    case_69: /* CIL Label */ 
#line 669
    tmp___1 = f;
#line 669
    f ++;
#line 669
    modifier = (int )*tmp___1;
#line 670
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 673
    modifier = 0;
#line 674
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 678
    format_char = (int )*f;
    {
#line 721
    if (format_char == 37) {
#line 721
      goto case_37;
    }
#line 727
    if (format_char == 97) {
#line 727
      goto case_97;
    }
#line 742
    if (format_char == 65) {
#line 742
      goto case_65;
    }
#line 758
    if (format_char == 104) {
#line 758
      goto case_104;
    }
#line 758
    if (format_char == 98) {
#line 758
      goto case_104;
    }
#line 773
    if (format_char == 66) {
#line 773
      goto case_66;
    }
#line 788
    if (format_char == 99) {
#line 788
      goto case_99;
    }
#line 847
    if (format_char == 67) {
#line 847
      goto case_67;
    }
#line 876
    if (format_char == 120) {
#line 876
      goto case_120;
    }
#line 889
    if (format_char == 68) {
#line 889
      goto case_68;
    }
#line 895
    if (format_char == 100) {
#line 895
      goto case_100;
    }
#line 901
    if (format_char == 101) {
#line 901
      goto case_101;
    }
#line 1027
    if (format_char == 70) {
#line 1027
      goto case_70;
    }
#line 1033
    if (format_char == 72) {
#line 1033
      goto case_72;
    }
#line 1039
    if (format_char == 73) {
#line 1039
      goto case_73;
    }
#line 1045
    if (format_char == 107) {
#line 1045
      goto case_107;
    }
#line 1051
    if (format_char == 108) {
#line 1051
      goto case_108;
    }
#line 1057
    if (format_char == 106) {
#line 1057
      goto case_106;
    }
#line 1063
    if (format_char == 77) {
#line 1063
      goto case_77;
    }
#line 1069
    if (format_char == 109) {
#line 1069
      goto case_109;
    }
#line 1076
    if (format_char == 78) {
#line 1076
      goto case_78;
    }
#line 1094
    if (format_char == 110) {
#line 1094
      goto case_110;
    }
#line 1098
    if (format_char == 80) {
#line 1098
      goto case_80;
    }
#line 1105
    if (format_char == 112) {
#line 1105
      goto case_112;
    }
#line 1118
    if (format_char == 82) {
#line 1118
      goto case_82;
    }
#line 1122
    if (format_char == 114) {
#line 1122
      goto case_114;
    }
#line 1133
    if (format_char == 83) {
#line 1133
      goto case_83;
    }
#line 1139
    if (format_char == 115) {
#line 1139
      goto case_115;
    }
#line 1166
    if (format_char == 88) {
#line 1166
      goto case_88;
    }
#line 1179
    if (format_char == 84) {
#line 1179
      goto case_84;
    }
#line 1183
    if (format_char == 116) {
#line 1183
      goto case_116;
    }
#line 1187
    if (format_char == 117) {
#line 1187
      goto case_117;
    }
#line 1190
    if (format_char == 85) {
#line 1190
      goto case_85;
    }
#line 1198
    if (format_char == 71) {
#line 1198
      goto case_71;
    }
#line 1198
    if (format_char == 103) {
#line 1198
      goto case_71;
    }
#line 1198
    if (format_char == 86) {
#line 1198
      goto case_71;
    }
#line 1254
    if (format_char == 87) {
#line 1254
      goto case_87;
    }
#line 1260
    if (format_char == 119) {
#line 1260
      goto case_119;
    }
#line 1266
    if (format_char == 89) {
#line 1266
      goto case_89;
    }
#line 1290
    if (format_char == 121) {
#line 1290
      goto case_121;
    }
#line 1313
    if (format_char == 90) {
#line 1313
      goto case_90;
    }
#line 1334
    if (format_char == 58) {
#line 1334
      goto case_58;
    }
#line 1344
    if (format_char == 122) {
#line 1344
      goto case_122;
    }
#line 1422
    if (format_char == 0) {
#line 1422
      goto case_0___0;
    }
#line 1425
    goto bad_format;
    case_37: /* CIL Label */ 
#line 722
    if (modifier != 0) {
#line 723
      goto bad_format;
    }
    {
#line 724
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 724
      _n___0 = (size_t )1;
#line 724
      if (width < 0) {
#line 724
        tmp___2 = 0;
      } else {
#line 724
        tmp___2 = width;
      }
#line 724
      _w___0 = (size_t )tmp___2;
#line 724
      if (_n___0 < _w___0) {
#line 724
        tmp___3 = _w___0;
      } else {
#line 724
        tmp___3 = _n___0;
      }
#line 724
      _incr___0 = tmp___3;
#line 724
      if (_incr___0 >= maxsize - i) {
#line 724
        return ((size_t )0);
      }
#line 724
      if (p) {
#line 724
        if (digits == 0) {
#line 724
          if (_n___0 < _w___0) {
#line 724
            _delta___0 = (size_t )width - _n___0;
#line 724
            if (pad == 48) {
              {
#line 724
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 724
                _i___1 = (size_t )0;
                {
#line 724
                while (1) {
                  while_continue___9: /* CIL Label */ ;
#line 724
                  if (! (_i___1 < _delta___0)) {
#line 724
                    goto while_break___9;
                  }
                  {
#line 724
                  fputc('0', p);
#line 724
                  _i___1 ++;
                  }
                }
                while_break___9: /* CIL Label */ ;
                }
#line 724
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
            } else {
              {
#line 724
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 724
                _i___2 = (size_t )0;
                {
#line 724
                while (1) {
                  while_continue___11: /* CIL Label */ ;
#line 724
                  if (! (_i___2 < _delta___0)) {
#line 724
                    goto while_break___11;
                  }
                  {
#line 724
                  fputc(' ', p);
#line 724
                  _i___2 ++;
                  }
                }
                while_break___11: /* CIL Label */ ;
                }
#line 724
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 724
        fputc((int )*f, p);
        }
      }
#line 724
      i += _incr___0;
#line 724
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 725
    goto switch_break___1;
    case_97: /* CIL Label */ 
#line 728
    if (modifier != 0) {
#line 729
      goto bad_format;
    }
#line 730
    if (change_case) {
#line 732
      to_uppcase = (_Bool)1;
#line 733
      to_lowcase = (_Bool)0;
    }
#line 739
    goto underlying_strftime;
    case_65: /* CIL Label */ 
#line 743
    if (modifier != 0) {
#line 744
      goto bad_format;
    }
#line 745
    if (change_case) {
#line 747
      to_uppcase = (_Bool)1;
#line 748
      to_lowcase = (_Bool)0;
    }
#line 754
    goto underlying_strftime;
    case_104: /* CIL Label */ 
    case_98: /* CIL Label */ 
#line 759
    if (change_case) {
#line 761
      to_uppcase = (_Bool)1;
#line 762
      to_lowcase = (_Bool)0;
    }
#line 764
    if (modifier != 0) {
#line 765
      goto bad_format;
    }
#line 770
    goto underlying_strftime;
    case_66: /* CIL Label */ 
#line 774
    if (modifier != 0) {
#line 775
      goto bad_format;
    }
#line 776
    if (change_case) {
#line 778
      to_uppcase = (_Bool)1;
#line 779
      to_lowcase = (_Bool)0;
    }
#line 785
    goto underlying_strftime;
    case_99: /* CIL Label */ 
#line 789
    if (modifier == 79) {
#line 790
      goto bad_format;
    }
#line 799
    goto underlying_strftime;
    subformat: 
    {
#line 804
    tmp___4 = strftime_case____0(to_uppcase, (FILE *)((void *)0), subfmt, tp, tz,
                                 ns);
#line 804
    len = tmp___4;
    }
    {
#line 808
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 808
      _n___1 = len;
#line 808
      if (width < 0) {
#line 808
        tmp___5 = 0;
      } else {
#line 808
        tmp___5 = width;
      }
#line 808
      _w___1 = (size_t )tmp___5;
#line 808
      if (_n___1 < _w___1) {
#line 808
        tmp___6 = _w___1;
      } else {
#line 808
        tmp___6 = _n___1;
      }
#line 808
      _incr___1 = tmp___6;
#line 808
      if (_incr___1 >= maxsize - i) {
#line 808
        return ((size_t )0);
      }
#line 808
      if (p) {
#line 808
        if (digits == 0) {
#line 808
          if (_n___1 < _w___1) {
#line 808
            _delta___1 = (size_t )width - _n___1;
#line 808
            if (pad == 48) {
              {
#line 808
              while (1) {
                while_continue___13: /* CIL Label */ ;
#line 808
                _i___3 = (size_t )0;
                {
#line 808
                while (1) {
                  while_continue___14: /* CIL Label */ ;
#line 808
                  if (! (_i___3 < _delta___1)) {
#line 808
                    goto while_break___14;
                  }
                  {
#line 808
                  fputc('0', p);
#line 808
                  _i___3 ++;
                  }
                }
                while_break___14: /* CIL Label */ ;
                }
#line 808
                goto while_break___13;
              }
              while_break___13: /* CIL Label */ ;
              }
            } else {
              {
#line 808
              while (1) {
                while_continue___15: /* CIL Label */ ;
#line 808
                _i___4 = (size_t )0;
                {
#line 808
                while (1) {
                  while_continue___16: /* CIL Label */ ;
#line 808
                  if (! (_i___4 < _delta___1)) {
#line 808
                    goto while_break___16;
                  }
                  {
#line 808
                  fputc(' ', p);
#line 808
                  _i___4 ++;
                  }
                }
                while_break___16: /* CIL Label */ ;
                }
#line 808
                goto while_break___15;
              }
              while_break___15: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 808
        strftime_case____0(to_uppcase, p, subfmt, tp, tz, ns);
        }
      }
#line 808
      i += _incr___1;
#line 808
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 813
    goto switch_break___1;
    underlying_strftime: 
#line 821
    u = ufmt;
#line 834
    tmp___7 = u;
#line 834
    u ++;
#line 834
    *tmp___7 = (char )' ';
#line 835
    tmp___8 = u;
#line 835
    u ++;
#line 835
    *tmp___8 = (char )'%';
#line 836
    if (modifier != 0) {
#line 837
      tmp___9 = u;
#line 837
      u ++;
#line 837
      *tmp___9 = (char )modifier;
    }
    {
#line 838
    tmp___10 = u;
#line 838
    u ++;
#line 838
    *tmp___10 = (char )format_char;
#line 839
    *u = (char )'\000';
#line 840
    len___0 = strftime((char */* __restrict  */)(ubuf), sizeof(ubuf), (char const   */* __restrict  */)(ufmt),
                       (struct tm  const  */* __restrict  */)tp);
    }
#line 841
    if (len___0 != 0UL) {
      {
#line 842
      while (1) {
        while_continue___17: /* CIL Label */ ;
#line 842
        _n___2 = len___0 - 1UL;
#line 842
        if (width < 0) {
#line 842
          tmp___11 = 0;
        } else {
#line 842
          tmp___11 = width;
        }
#line 842
        _w___2 = (size_t )tmp___11;
#line 842
        if (_n___2 < _w___2) {
#line 842
          tmp___12 = _w___2;
        } else {
#line 842
          tmp___12 = _n___2;
        }
#line 842
        _incr___2 = tmp___12;
#line 842
        if (_incr___2 >= maxsize - i) {
#line 842
          return ((size_t )0);
        }
#line 842
        if (p) {
#line 842
          if (digits == 0) {
#line 842
            if (_n___2 < _w___2) {
#line 842
              _delta___2 = (size_t )width - _n___2;
#line 842
              if (pad == 48) {
                {
#line 842
                while (1) {
                  while_continue___18: /* CIL Label */ ;
#line 842
                  _i___5 = (size_t )0;
                  {
#line 842
                  while (1) {
                    while_continue___19: /* CIL Label */ ;
#line 842
                    if (! (_i___5 < _delta___2)) {
#line 842
                      goto while_break___19;
                    }
                    {
#line 842
                    fputc('0', p);
#line 842
                    _i___5 ++;
                    }
                  }
                  while_break___19: /* CIL Label */ ;
                  }
#line 842
                  goto while_break___18;
                }
                while_break___18: /* CIL Label */ ;
                }
              } else {
                {
#line 842
                while (1) {
                  while_continue___20: /* CIL Label */ ;
#line 842
                  _i___6 = (size_t )0;
                  {
#line 842
                  while (1) {
                    while_continue___21: /* CIL Label */ ;
#line 842
                    if (! (_i___6 < _delta___2)) {
#line 842
                      goto while_break___21;
                    }
                    {
#line 842
                    fputc(' ', p);
#line 842
                    _i___6 ++;
                    }
                  }
                  while_break___21: /* CIL Label */ ;
                  }
#line 842
                  goto while_break___20;
                }
                while_break___20: /* CIL Label */ ;
                }
              }
            }
          }
          {
#line 842
          while (1) {
            while_continue___22: /* CIL Label */ ;
#line 842
            if (to_lowcase) {
              {
#line 842
              fwrite_lowcase(p, (char const   *)(ubuf + 1), _n___2);
              }
            } else
#line 842
            if (to_uppcase) {
              {
#line 842
              fwrite_uppcase(p, (char const   *)(ubuf + 1), _n___2);
              }
            } else {
              {
#line 842
              fwrite((void const   */* __restrict  */)(ubuf + 1), _n___2, (size_t )1,
                     (FILE */* __restrict  */)p);
              }
            }
#line 842
            goto while_break___22;
          }
          while_break___22: /* CIL Label */ ;
          }
        }
#line 842
        i += _incr___2;
#line 842
        goto while_break___17;
      }
      while_break___17: /* CIL Label */ ;
      }
    }
#line 844
    goto switch_break___1;
    case_67: /* CIL Label */ 
#line 848
    if (modifier == 79) {
#line 849
      goto bad_format;
    }
#line 850
    if (modifier == 69) {
#line 866
      goto underlying_strftime;
    }
#line 871
    century = (int )(tp->tm_year / 100 + 19);
#line 872
    if (tp->tm_year % 100 < 0) {
#line 872
      if (0 < century) {
#line 872
        tmp___13 = 1;
      } else {
#line 872
        tmp___13 = 0;
      }
    } else {
#line 872
      tmp___13 = 0;
    }
#line 872
    century -= tmp___13;
    {
#line 873
    while (1) {
      while_continue___23: /* CIL Label */ ;
#line 873
      digits = 2;
#line 873
      negative_number = (_Bool )(tp->tm_year < -1900);
#line 873
      u_number_value = (unsigned int )century;
#line 873
      goto do_signed_number;
#line 873
      goto while_break___23;
    }
    while_break___23: /* CIL Label */ ;
    }
    case_120: /* CIL Label */ 
#line 877
    if (modifier == 79) {
#line 878
      goto bad_format;
    }
#line 887
    goto underlying_strftime;
    case_68: /* CIL Label */ 
#line 890
    if (modifier != 0) {
#line 891
      goto bad_format;
    }
#line 892
    subfmt = "%m/%d/%y";
#line 893
    goto subformat;
    case_100: /* CIL Label */ 
#line 896
    if (modifier == 69) {
#line 897
      goto bad_format;
    }
    {
#line 899
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 899
      digits = 2;
#line 899
      number_value = (int )tp->tm_mday;
#line 899
      goto do_number;
#line 899
      goto while_break___24;
    }
    while_break___24: /* CIL Label */ ;
    }
    case_101: /* CIL Label */ 
#line 902
    if (modifier == 69) {
#line 903
      goto bad_format;
    }
    {
#line 905
    while (1) {
      while_continue___25: /* CIL Label */ ;
#line 905
      digits = 2;
#line 905
      number_value = (int )tp->tm_mday;
#line 905
      goto do_number_spacepad;
#line 905
      goto while_break___25;
    }
    while_break___25: /* CIL Label */ ;
    }
    do_tz_offset: 
#line 911
    always_output_a_sign = (_Bool)1;
#line 912
    goto do_number_body;
    do_number_spacepad: 
#line 916
    if (pad != 48) {
#line 916
      if (pad != 45) {
#line 917
        pad = '_';
      }
    }
    do_number: 
#line 921
    negative_number = (_Bool )(number_value < 0);
#line 922
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 925
    always_output_a_sign = (_Bool)0;
#line 926
    tz_colon_mask = 0;
    do_number_body: 
#line 934
    if (modifier == 79) {
#line 934
      if (! negative_number) {
#line 952
        goto underlying_strftime;
      }
    }
#line 956
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 958
    if (negative_number) {
#line 959
      u_number_value = - u_number_value;
    }
    {
#line 961
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 963
      if (tz_colon_mask & 1) {
#line 964
        bufp --;
#line 964
        *bufp = (char )':';
      }
#line 965
      tz_colon_mask >>= 1;
#line 966
      bufp --;
#line 966
      *bufp = (char )(u_number_value % 10U + 48U);
#line 967
      u_number_value /= 10U;
#line 961
      if (! (u_number_value != 0U)) {
#line 961
        if (! (tz_colon_mask != 0)) {
#line 961
          goto while_break___26;
        }
      }
    }
    while_break___26: /* CIL Label */ ;
    }
    do_number_sign_and_padding: 
#line 972
    if (digits < width) {
#line 973
      digits = width;
    }
#line 975
    if (negative_number) {
#line 975
      sign_char = (char )'-';
    } else {
#line 975
      if (always_output_a_sign) {
#line 975
        tmp___14 = '+';
      } else {
#line 975
        tmp___14 = 0;
      }
#line 975
      sign_char = (char )tmp___14;
    }
#line 979
    if (pad == 45) {
#line 981
      if (sign_char) {
        {
#line 982
        while (1) {
          while_continue___27: /* CIL Label */ ;
#line 982
          _n___3 = (size_t )1;
#line 982
          if (width < 0) {
#line 982
            tmp___15 = 0;
          } else {
#line 982
            tmp___15 = width;
          }
#line 982
          _w___3 = (size_t )tmp___15;
#line 982
          if (_n___3 < _w___3) {
#line 982
            tmp___16 = _w___3;
          } else {
#line 982
            tmp___16 = _n___3;
          }
#line 982
          _incr___3 = tmp___16;
#line 982
          if (_incr___3 >= maxsize - i) {
#line 982
            return ((size_t )0);
          }
#line 982
          if (p) {
#line 982
            if (digits == 0) {
#line 982
              if (_n___3 < _w___3) {
#line 982
                _delta___3 = (size_t )width - _n___3;
#line 982
                if (pad == 48) {
                  {
#line 982
                  while (1) {
                    while_continue___28: /* CIL Label */ ;
#line 982
                    _i___7 = (size_t )0;
                    {
#line 982
                    while (1) {
                      while_continue___29: /* CIL Label */ ;
#line 982
                      if (! (_i___7 < _delta___3)) {
#line 982
                        goto while_break___29;
                      }
                      {
#line 982
                      fputc('0', p);
#line 982
                      _i___7 ++;
                      }
                    }
                    while_break___29: /* CIL Label */ ;
                    }
#line 982
                    goto while_break___28;
                  }
                  while_break___28: /* CIL Label */ ;
                  }
                } else {
                  {
#line 982
                  while (1) {
                    while_continue___30: /* CIL Label */ ;
#line 982
                    _i___8 = (size_t )0;
                    {
#line 982
                    while (1) {
                      while_continue___31: /* CIL Label */ ;
#line 982
                      if (! (_i___8 < _delta___3)) {
#line 982
                        goto while_break___31;
                      }
                      {
#line 982
                      fputc(' ', p);
#line 982
                      _i___8 ++;
                      }
                    }
                    while_break___31: /* CIL Label */ ;
                    }
#line 982
                    goto while_break___30;
                  }
                  while_break___30: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 982
            fputc((int )sign_char, p);
            }
          }
#line 982
          i += _incr___3;
#line 982
          goto while_break___27;
        }
        while_break___27: /* CIL Label */ ;
        }
      }
    } else {
#line 986
      padding = (int )(((long )digits - ((buf + sizeof(buf) / sizeof(buf[0])) - bufp)) - (long )(! (! sign_char)));
#line 989
      if (padding > 0) {
#line 991
        if (pad == 95) {
#line 993
          if ((size_t )padding >= maxsize - i) {
#line 994
            return ((size_t )0);
          }
#line 996
          if (p) {
            {
#line 997
            while (1) {
              while_continue___32: /* CIL Label */ ;
#line 997
              _i___9 = (size_t )0;
              {
#line 997
              while (1) {
                while_continue___33: /* CIL Label */ ;
#line 997
                if (! (_i___9 < (size_t )padding)) {
#line 997
                  goto while_break___33;
                }
                {
#line 997
                fputc(' ', p);
#line 997
                _i___9 ++;
                }
              }
              while_break___33: /* CIL Label */ ;
              }
#line 997
              goto while_break___32;
            }
            while_break___32: /* CIL Label */ ;
            }
          }
#line 998
          i += (size_t )padding;
#line 999
          if (width > padding) {
#line 999
            width -= padding;
          } else {
#line 999
            width = 0;
          }
#line 1000
          if (sign_char) {
            {
#line 1001
            while (1) {
              while_continue___34: /* CIL Label */ ;
#line 1001
              _n___4 = (size_t )1;
#line 1001
              if (width < 0) {
#line 1001
                tmp___17 = 0;
              } else {
#line 1001
                tmp___17 = width;
              }
#line 1001
              _w___4 = (size_t )tmp___17;
#line 1001
              if (_n___4 < _w___4) {
#line 1001
                tmp___18 = _w___4;
              } else {
#line 1001
                tmp___18 = _n___4;
              }
#line 1001
              _incr___4 = tmp___18;
#line 1001
              if (_incr___4 >= maxsize - i) {
#line 1001
                return ((size_t )0);
              }
#line 1001
              if (p) {
#line 1001
                if (digits == 0) {
#line 1001
                  if (_n___4 < _w___4) {
#line 1001
                    _delta___4 = (size_t )width - _n___4;
#line 1001
                    if (pad == 48) {
                      {
#line 1001
                      while (1) {
                        while_continue___35: /* CIL Label */ ;
#line 1001
                        _i___10 = (size_t )0;
                        {
#line 1001
                        while (1) {
                          while_continue___36: /* CIL Label */ ;
#line 1001
                          if (! (_i___10 < _delta___4)) {
#line 1001
                            goto while_break___36;
                          }
                          {
#line 1001
                          fputc('0', p);
#line 1001
                          _i___10 ++;
                          }
                        }
                        while_break___36: /* CIL Label */ ;
                        }
#line 1001
                        goto while_break___35;
                      }
                      while_break___35: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 1001
                      while (1) {
                        while_continue___37: /* CIL Label */ ;
#line 1001
                        _i___11 = (size_t )0;
                        {
#line 1001
                        while (1) {
                          while_continue___38: /* CIL Label */ ;
#line 1001
                          if (! (_i___11 < _delta___4)) {
#line 1001
                            goto while_break___38;
                          }
                          {
#line 1001
                          fputc(' ', p);
#line 1001
                          _i___11 ++;
                          }
                        }
                        while_break___38: /* CIL Label */ ;
                        }
#line 1001
                        goto while_break___37;
                      }
                      while_break___37: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 1001
                fputc((int )sign_char, p);
                }
              }
#line 1001
              i += _incr___4;
#line 1001
              goto while_break___34;
            }
            while_break___34: /* CIL Label */ ;
            }
          }
        } else {
#line 1005
          if ((size_t )digits >= maxsize - i) {
#line 1006
            return ((size_t )0);
          }
#line 1008
          if (sign_char) {
            {
#line 1009
            while (1) {
              while_continue___39: /* CIL Label */ ;
#line 1009
              _n___5 = (size_t )1;
#line 1009
              if (width < 0) {
#line 1009
                tmp___19 = 0;
              } else {
#line 1009
                tmp___19 = width;
              }
#line 1009
              _w___5 = (size_t )tmp___19;
#line 1009
              if (_n___5 < _w___5) {
#line 1009
                tmp___20 = _w___5;
              } else {
#line 1009
                tmp___20 = _n___5;
              }
#line 1009
              _incr___5 = tmp___20;
#line 1009
              if (_incr___5 >= maxsize - i) {
#line 1009
                return ((size_t )0);
              }
#line 1009
              if (p) {
#line 1009
                if (digits == 0) {
#line 1009
                  if (_n___5 < _w___5) {
#line 1009
                    _delta___5 = (size_t )width - _n___5;
#line 1009
                    if (pad == 48) {
                      {
#line 1009
                      while (1) {
                        while_continue___40: /* CIL Label */ ;
#line 1009
                        _i___12 = (size_t )0;
                        {
#line 1009
                        while (1) {
                          while_continue___41: /* CIL Label */ ;
#line 1009
                          if (! (_i___12 < _delta___5)) {
#line 1009
                            goto while_break___41;
                          }
                          {
#line 1009
                          fputc('0', p);
#line 1009
                          _i___12 ++;
                          }
                        }
                        while_break___41: /* CIL Label */ ;
                        }
#line 1009
                        goto while_break___40;
                      }
                      while_break___40: /* CIL Label */ ;
                      }
                    } else {
                      {
#line 1009
                      while (1) {
                        while_continue___42: /* CIL Label */ ;
#line 1009
                        _i___13 = (size_t )0;
                        {
#line 1009
                        while (1) {
                          while_continue___43: /* CIL Label */ ;
#line 1009
                          if (! (_i___13 < _delta___5)) {
#line 1009
                            goto while_break___43;
                          }
                          {
#line 1009
                          fputc(' ', p);
#line 1009
                          _i___13 ++;
                          }
                        }
                        while_break___43: /* CIL Label */ ;
                        }
#line 1009
                        goto while_break___42;
                      }
                      while_break___42: /* CIL Label */ ;
                      }
                    }
                  }
                }
                {
#line 1009
                fputc((int )sign_char, p);
                }
              }
#line 1009
              i += _incr___5;
#line 1009
              goto while_break___39;
            }
            while_break___39: /* CIL Label */ ;
            }
          }
#line 1011
          if (p) {
            {
#line 1012
            while (1) {
              while_continue___44: /* CIL Label */ ;
#line 1012
              _i___14 = (size_t )0;
              {
#line 1012
              while (1) {
                while_continue___45: /* CIL Label */ ;
#line 1012
                if (! (_i___14 < (size_t )padding)) {
#line 1012
                  goto while_break___45;
                }
                {
#line 1012
                fputc('0', p);
#line 1012
                _i___14 ++;
                }
              }
              while_break___45: /* CIL Label */ ;
              }
#line 1012
              goto while_break___44;
            }
            while_break___44: /* CIL Label */ ;
            }
          }
#line 1013
          i += (size_t )padding;
#line 1014
          width = 0;
        }
      } else
#line 1019
      if (sign_char) {
        {
#line 1020
        while (1) {
          while_continue___46: /* CIL Label */ ;
#line 1020
          _n___6 = (size_t )1;
#line 1020
          if (width < 0) {
#line 1020
            tmp___21 = 0;
          } else {
#line 1020
            tmp___21 = width;
          }
#line 1020
          _w___6 = (size_t )tmp___21;
#line 1020
          if (_n___6 < _w___6) {
#line 1020
            tmp___22 = _w___6;
          } else {
#line 1020
            tmp___22 = _n___6;
          }
#line 1020
          _incr___6 = tmp___22;
#line 1020
          if (_incr___6 >= maxsize - i) {
#line 1020
            return ((size_t )0);
          }
#line 1020
          if (p) {
#line 1020
            if (digits == 0) {
#line 1020
              if (_n___6 < _w___6) {
#line 1020
                _delta___6 = (size_t )width - _n___6;
#line 1020
                if (pad == 48) {
                  {
#line 1020
                  while (1) {
                    while_continue___47: /* CIL Label */ ;
#line 1020
                    _i___15 = (size_t )0;
                    {
#line 1020
                    while (1) {
                      while_continue___48: /* CIL Label */ ;
#line 1020
                      if (! (_i___15 < _delta___6)) {
#line 1020
                        goto while_break___48;
                      }
                      {
#line 1020
                      fputc('0', p);
#line 1020
                      _i___15 ++;
                      }
                    }
                    while_break___48: /* CIL Label */ ;
                    }
#line 1020
                    goto while_break___47;
                  }
                  while_break___47: /* CIL Label */ ;
                  }
                } else {
                  {
#line 1020
                  while (1) {
                    while_continue___49: /* CIL Label */ ;
#line 1020
                    _i___16 = (size_t )0;
                    {
#line 1020
                    while (1) {
                      while_continue___50: /* CIL Label */ ;
#line 1020
                      if (! (_i___16 < _delta___6)) {
#line 1020
                        goto while_break___50;
                      }
                      {
#line 1020
                      fputc(' ', p);
#line 1020
                      _i___16 ++;
                      }
                    }
                    while_break___50: /* CIL Label */ ;
                    }
#line 1020
                    goto while_break___49;
                  }
                  while_break___49: /* CIL Label */ ;
                  }
                }
              }
            }
            {
#line 1020
            fputc((int )sign_char, p);
            }
          }
#line 1020
          i += _incr___6;
#line 1020
          goto while_break___46;
        }
        while_break___46: /* CIL Label */ ;
        }
      }
    }
    {
#line 1024
    while (1) {
      while_continue___51: /* CIL Label */ ;
#line 1024
      _n___7 = (size_t )((buf + sizeof(buf) / sizeof(buf[0])) - bufp);
#line 1024
      if (width < 0) {
#line 1024
        tmp___23 = 0;
      } else {
#line 1024
        tmp___23 = width;
      }
#line 1024
      _w___7 = (size_t )tmp___23;
#line 1024
      if (_n___7 < _w___7) {
#line 1024
        tmp___24 = _w___7;
      } else {
#line 1024
        tmp___24 = _n___7;
      }
#line 1024
      _incr___7 = tmp___24;
#line 1024
      if (_incr___7 >= maxsize - i) {
#line 1024
        return ((size_t )0);
      }
#line 1024
      if (p) {
#line 1024
        if (digits == 0) {
#line 1024
          if (_n___7 < _w___7) {
#line 1024
            _delta___7 = (size_t )width - _n___7;
#line 1024
            if (pad == 48) {
              {
#line 1024
              while (1) {
                while_continue___52: /* CIL Label */ ;
#line 1024
                _i___17 = (size_t )0;
                {
#line 1024
                while (1) {
                  while_continue___53: /* CIL Label */ ;
#line 1024
                  if (! (_i___17 < _delta___7)) {
#line 1024
                    goto while_break___53;
                  }
                  {
#line 1024
                  fputc('0', p);
#line 1024
                  _i___17 ++;
                  }
                }
                while_break___53: /* CIL Label */ ;
                }
#line 1024
                goto while_break___52;
              }
              while_break___52: /* CIL Label */ ;
              }
            } else {
              {
#line 1024
              while (1) {
                while_continue___54: /* CIL Label */ ;
#line 1024
                _i___18 = (size_t )0;
                {
#line 1024
                while (1) {
                  while_continue___55: /* CIL Label */ ;
#line 1024
                  if (! (_i___18 < _delta___7)) {
#line 1024
                    goto while_break___55;
                  }
                  {
#line 1024
                  fputc(' ', p);
#line 1024
                  _i___18 ++;
                  }
                }
                while_break___55: /* CIL Label */ ;
                }
#line 1024
                goto while_break___54;
              }
              while_break___54: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1024
        while (1) {
          while_continue___56: /* CIL Label */ ;
#line 1024
          if (to_lowcase) {
            {
#line 1024
            fwrite_lowcase(p, (char const   *)bufp, _n___7);
            }
          } else
#line 1024
          if (to_uppcase) {
            {
#line 1024
            fwrite_uppcase(p, (char const   *)bufp, _n___7);
            }
          } else {
            {
#line 1024
            fwrite((void const   */* __restrict  */)bufp, _n___7, (size_t )1, (FILE */* __restrict  */)p);
            }
          }
#line 1024
          goto while_break___56;
        }
        while_break___56: /* CIL Label */ ;
        }
      }
#line 1024
      i += _incr___7;
#line 1024
      goto while_break___51;
    }
    while_break___51: /* CIL Label */ ;
    }
#line 1025
    goto switch_break___1;
    case_70: /* CIL Label */ 
#line 1028
    if (modifier != 0) {
#line 1029
      goto bad_format;
    }
#line 1030
    subfmt = "%Y-%m-%d";
#line 1031
    goto subformat;
    case_72: /* CIL Label */ 
#line 1034
    if (modifier == 69) {
#line 1035
      goto bad_format;
    }
    {
#line 1037
    while (1) {
      while_continue___57: /* CIL Label */ ;
#line 1037
      digits = 2;
#line 1037
      number_value = (int )tp->tm_hour;
#line 1037
      goto do_number;
#line 1037
      goto while_break___57;
    }
    while_break___57: /* CIL Label */ ;
    }
    case_73: /* CIL Label */ 
#line 1040
    if (modifier == 69) {
#line 1041
      goto bad_format;
    }
    {
#line 1043
    while (1) {
      while_continue___58: /* CIL Label */ ;
#line 1043
      digits = 2;
#line 1043
      number_value = hour12;
#line 1043
      goto do_number;
#line 1043
      goto while_break___58;
    }
    while_break___58: /* CIL Label */ ;
    }
    case_107: /* CIL Label */ 
#line 1046
    if (modifier == 69) {
#line 1047
      goto bad_format;
    }
    {
#line 1049
    while (1) {
      while_continue___59: /* CIL Label */ ;
#line 1049
      digits = 2;
#line 1049
      number_value = (int )tp->tm_hour;
#line 1049
      goto do_number_spacepad;
#line 1049
      goto while_break___59;
    }
    while_break___59: /* CIL Label */ ;
    }
    case_108: /* CIL Label */ 
#line 1052
    if (modifier == 69) {
#line 1053
      goto bad_format;
    }
    {
#line 1055
    while (1) {
      while_continue___60: /* CIL Label */ ;
#line 1055
      digits = 2;
#line 1055
      number_value = hour12;
#line 1055
      goto do_number_spacepad;
#line 1055
      goto while_break___60;
    }
    while_break___60: /* CIL Label */ ;
    }
    case_106: /* CIL Label */ 
#line 1058
    if (modifier == 69) {
#line 1059
      goto bad_format;
    }
    {
#line 1061
    while (1) {
      while_continue___61: /* CIL Label */ ;
#line 1061
      digits = 3;
#line 1061
      negative_number = (_Bool )(tp->tm_yday < -1);
#line 1061
      u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1061
      goto do_signed_number;
#line 1061
      goto while_break___61;
    }
    while_break___61: /* CIL Label */ ;
    }
    case_77: /* CIL Label */ 
#line 1064
    if (modifier == 69) {
#line 1065
      goto bad_format;
    }
    {
#line 1067
    while (1) {
      while_continue___62: /* CIL Label */ ;
#line 1067
      digits = 2;
#line 1067
      number_value = (int )tp->tm_min;
#line 1067
      goto do_number;
#line 1067
      goto while_break___62;
    }
    while_break___62: /* CIL Label */ ;
    }
    case_109: /* CIL Label */ 
#line 1070
    if (modifier == 69) {
#line 1071
      goto bad_format;
    }
    {
#line 1073
    while (1) {
      while_continue___63: /* CIL Label */ ;
#line 1073
      digits = 2;
#line 1073
      negative_number = (_Bool )(tp->tm_mon < -1);
#line 1073
      u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1073
      goto do_signed_number;
#line 1073
      goto while_break___63;
    }
    while_break___63: /* CIL Label */ ;
    }
    case_78: /* CIL Label */ 
#line 1077
    if (modifier == 69) {
#line 1078
      goto bad_format;
    }
#line 1080
    number_value = ns;
#line 1081
    if (width == -1) {
#line 1082
      width = 9;
    } else {
#line 1087
      j = width;
      {
#line 1087
      while (1) {
        while_continue___64: /* CIL Label */ ;
#line 1087
        if (! (j < 9)) {
#line 1087
          goto while_break___64;
        }
#line 1088
        number_value /= 10;
#line 1087
        j ++;
      }
      while_break___64: /* CIL Label */ ;
      }
    }
    {
#line 1091
    while (1) {
      while_continue___65: /* CIL Label */ ;
#line 1091
      digits = width;
#line 1091
      number_value = number_value;
#line 1091
      goto do_number;
#line 1091
      goto while_break___65;
    }
    while_break___65: /* CIL Label */ ;
    }
    case_110: /* CIL Label */ 
    {
#line 1095
    while (1) {
      while_continue___66: /* CIL Label */ ;
#line 1095
      _n___8 = (size_t )1;
#line 1095
      if (width < 0) {
#line 1095
        tmp___25 = 0;
      } else {
#line 1095
        tmp___25 = width;
      }
#line 1095
      _w___8 = (size_t )tmp___25;
#line 1095
      if (_n___8 < _w___8) {
#line 1095
        tmp___26 = _w___8;
      } else {
#line 1095
        tmp___26 = _n___8;
      }
#line 1095
      _incr___8 = tmp___26;
#line 1095
      if (_incr___8 >= maxsize - i) {
#line 1095
        return ((size_t )0);
      }
#line 1095
      if (p) {
#line 1095
        if (digits == 0) {
#line 1095
          if (_n___8 < _w___8) {
#line 1095
            _delta___8 = (size_t )width - _n___8;
#line 1095
            if (pad == 48) {
              {
#line 1095
              while (1) {
                while_continue___67: /* CIL Label */ ;
#line 1095
                _i___19 = (size_t )0;
                {
#line 1095
                while (1) {
                  while_continue___68: /* CIL Label */ ;
#line 1095
                  if (! (_i___19 < _delta___8)) {
#line 1095
                    goto while_break___68;
                  }
                  {
#line 1095
                  fputc('0', p);
#line 1095
                  _i___19 ++;
                  }
                }
                while_break___68: /* CIL Label */ ;
                }
#line 1095
                goto while_break___67;
              }
              while_break___67: /* CIL Label */ ;
              }
            } else {
              {
#line 1095
              while (1) {
                while_continue___69: /* CIL Label */ ;
#line 1095
                _i___20 = (size_t )0;
                {
#line 1095
                while (1) {
                  while_continue___70: /* CIL Label */ ;
#line 1095
                  if (! (_i___20 < _delta___8)) {
#line 1095
                    goto while_break___70;
                  }
                  {
#line 1095
                  fputc(' ', p);
#line 1095
                  _i___20 ++;
                  }
                }
                while_break___70: /* CIL Label */ ;
                }
#line 1095
                goto while_break___69;
              }
              while_break___69: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1095
        fputc('\n', p);
        }
      }
#line 1095
      i += _incr___8;
#line 1095
      goto while_break___66;
    }
    while_break___66: /* CIL Label */ ;
    }
#line 1096
    goto switch_break___1;
    case_80: /* CIL Label */ 
#line 1099
    to_lowcase = (_Bool)1;
#line 1101
    format_char = 'p';
    case_112: /* CIL Label */ 
#line 1106
    if (change_case) {
#line 1108
      to_uppcase = (_Bool)0;
#line 1109
      to_lowcase = (_Bool)1;
    }
#line 1115
    goto underlying_strftime;
    case_82: /* CIL Label */ 
#line 1119
    subfmt = "%H:%M";
#line 1120
    goto subformat;
    case_114: /* CIL Label */ 
#line 1130
    goto underlying_strftime;
    case_83: /* CIL Label */ 
#line 1134
    if (modifier == 69) {
#line 1135
      goto bad_format;
    }
    {
#line 1137
    while (1) {
      while_continue___71: /* CIL Label */ ;
#line 1137
      digits = 2;
#line 1137
      number_value = (int )tp->tm_sec;
#line 1137
      goto do_number;
#line 1137
      goto while_break___71;
    }
    while_break___71: /* CIL Label */ ;
    }
    case_115: /* CIL Label */ 
    {
#line 1144
    ltm = (struct tm )*tp;
#line 1145
    t = mktime_z(tz, (struct tm */* __restrict  */)(& ltm));
#line 1150
    bufp = buf + sizeof(buf) / sizeof(buf[0]);
#line 1151
    negative_number = (_Bool )(t < 0L);
    }
    {
#line 1153
    while (1) {
      while_continue___72: /* CIL Label */ ;
#line 1155
      d = (int )(t % 10L);
#line 1156
      t /= 10L;
#line 1157
      bufp --;
#line 1157
      if (negative_number) {
#line 1157
        tmp___27 = - d;
      } else {
#line 1157
        tmp___27 = d;
      }
#line 1157
      *bufp = (char )(tmp___27 + 48);
#line 1153
      if (! (t != 0L)) {
#line 1153
        goto while_break___72;
      }
    }
    while_break___72: /* CIL Label */ ;
    }
#line 1161
    digits = 1;
#line 1162
    always_output_a_sign = (_Bool)0;
#line 1163
    goto do_number_sign_and_padding;
    case_88: /* CIL Label */ 
#line 1167
    if (modifier == 79) {
#line 1168
      goto bad_format;
    }
#line 1177
    goto underlying_strftime;
    case_84: /* CIL Label */ 
#line 1180
    subfmt = "%H:%M:%S";
#line 1181
    goto subformat;
    case_116: /* CIL Label */ 
    {
#line 1184
    while (1) {
      while_continue___73: /* CIL Label */ ;
#line 1184
      _n___9 = (size_t )1;
#line 1184
      if (width < 0) {
#line 1184
        tmp___28 = 0;
      } else {
#line 1184
        tmp___28 = width;
      }
#line 1184
      _w___9 = (size_t )tmp___28;
#line 1184
      if (_n___9 < _w___9) {
#line 1184
        tmp___29 = _w___9;
      } else {
#line 1184
        tmp___29 = _n___9;
      }
#line 1184
      _incr___9 = tmp___29;
#line 1184
      if (_incr___9 >= maxsize - i) {
#line 1184
        return ((size_t )0);
      }
#line 1184
      if (p) {
#line 1184
        if (digits == 0) {
#line 1184
          if (_n___9 < _w___9) {
#line 1184
            _delta___9 = (size_t )width - _n___9;
#line 1184
            if (pad == 48) {
              {
#line 1184
              while (1) {
                while_continue___74: /* CIL Label */ ;
#line 1184
                _i___21 = (size_t )0;
                {
#line 1184
                while (1) {
                  while_continue___75: /* CIL Label */ ;
#line 1184
                  if (! (_i___21 < _delta___9)) {
#line 1184
                    goto while_break___75;
                  }
                  {
#line 1184
                  fputc('0', p);
#line 1184
                  _i___21 ++;
                  }
                }
                while_break___75: /* CIL Label */ ;
                }
#line 1184
                goto while_break___74;
              }
              while_break___74: /* CIL Label */ ;
              }
            } else {
              {
#line 1184
              while (1) {
                while_continue___76: /* CIL Label */ ;
#line 1184
                _i___22 = (size_t )0;
                {
#line 1184
                while (1) {
                  while_continue___77: /* CIL Label */ ;
#line 1184
                  if (! (_i___22 < _delta___9)) {
#line 1184
                    goto while_break___77;
                  }
                  {
#line 1184
                  fputc(' ', p);
#line 1184
                  _i___22 ++;
                  }
                }
                while_break___77: /* CIL Label */ ;
                }
#line 1184
                goto while_break___76;
              }
              while_break___76: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1184
        fputc('\t', p);
        }
      }
#line 1184
      i += _incr___9;
#line 1184
      goto while_break___73;
    }
    while_break___73: /* CIL Label */ ;
    }
#line 1185
    goto switch_break___1;
    case_117: /* CIL Label */ 
    {
#line 1188
    while (1) {
      while_continue___78: /* CIL Label */ ;
#line 1188
      digits = 1;
#line 1188
      number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1188
      goto do_number;
#line 1188
      goto while_break___78;
    }
    while_break___78: /* CIL Label */ ;
    }
    case_85: /* CIL Label */ 
#line 1191
    if (modifier == 69) {
#line 1192
      goto bad_format;
    }
    {
#line 1194
    while (1) {
      while_continue___79: /* CIL Label */ ;
#line 1194
      digits = 2;
#line 1194
      number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1194
      goto do_number;
#line 1194
      goto while_break___79;
    }
    while_break___79: /* CIL Label */ ;
    }
    case_71: /* CIL Label */ 
    case_103: /* CIL Label */ 
    case_86: /* CIL Label */ 
#line 1199
    if (modifier == 69) {
#line 1200
      goto bad_format;
    }
#line 1206
    if (tp->tm_year < 0) {
#line 1206
      tmp___30 = 300;
    } else {
#line 1206
      tmp___30 = -100;
    }
    {
#line 1206
    year = (int )(tp->tm_year + (int const   )tmp___30);
#line 1210
    year_adjust = 0;
#line 1211
    tmp___31 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1211
    days = tmp___31;
    }
#line 1213
    if (days < 0) {
#line 1216
      year_adjust = -1;
#line 1217
      if ((year - 1) % 4 == 0) {
#line 1217
        if ((year - 1) % 100 != 0) {
#line 1217
          tmp___32 = 1;
        } else
#line 1217
        if ((year - 1) % 400 == 0) {
#line 1217
          tmp___32 = 1;
        } else {
#line 1217
          tmp___32 = 0;
        }
      } else {
#line 1217
        tmp___32 = 0;
      }
      {
#line 1217
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___32)), (int )tp->tm_wday);
      }
    } else {
#line 1222
      if (year % 4 == 0) {
#line 1222
        if (year % 100 != 0) {
#line 1222
          tmp___33 = 1;
        } else
#line 1222
        if (year % 400 == 0) {
#line 1222
          tmp___33 = 1;
        } else {
#line 1222
          tmp___33 = 0;
        }
      } else {
#line 1222
        tmp___33 = 0;
      }
      {
#line 1222
      tmp___34 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___33)),
                               (int )tp->tm_wday);
#line 1222
      d___0 = tmp___34;
      }
#line 1224
      if (0 <= d___0) {
#line 1227
        year_adjust = 1;
#line 1228
        days = d___0;
      }
    }
    {
#line 1234
    if ((int const   )*f == 103) {
#line 1234
      goto case_103___0;
    }
#line 1244
    if ((int const   )*f == 71) {
#line 1244
      goto case_71___0;
    }
#line 1249
    goto switch_default___1;
    case_103___0: /* CIL Label */ 
#line 1236
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
    {
#line 1237
    while (1) {
      while_continue___80: /* CIL Label */ ;
#line 1237
      digits = 2;
#line 1237
      if (0 <= yy) {
#line 1237
        number_value = yy;
      } else {
#line 1237
        if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1237
          tmp___35 = - yy;
        } else {
#line 1237
          tmp___35 = yy + 100;
        }
#line 1237
        number_value = tmp___35;
      }
#line 1237
      goto do_number;
#line 1237
      goto while_break___80;
    }
    while_break___80: /* CIL Label */ ;
    }
    case_71___0: /* CIL Label */ 
    {
#line 1245
    while (1) {
      while_continue___81: /* CIL Label */ ;
#line 1245
      digits = 4;
#line 1245
      negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1245
      u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1245
      goto do_signed_number;
#line 1245
      goto while_break___81;
    }
    while_break___81: /* CIL Label */ ;
    }
    switch_default___1: /* CIL Label */ 
    {
#line 1250
    while (1) {
      while_continue___82: /* CIL Label */ ;
#line 1250
      digits = 2;
#line 1250
      number_value = days / 7 + 1;
#line 1250
      goto do_number;
#line 1250
      goto while_break___82;
    }
    while_break___82: /* CIL Label */ ;
    }
    switch_break___2: /* CIL Label */ ;
    }
    case_87: /* CIL Label */ 
#line 1255
    if (modifier == 69) {
#line 1256
      goto bad_format;
    }
    {
#line 1258
    while (1) {
      while_continue___83: /* CIL Label */ ;
#line 1258
      digits = 2;
#line 1258
      number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1258
      goto do_number;
#line 1258
      goto while_break___83;
    }
    while_break___83: /* CIL Label */ ;
    }
    case_119: /* CIL Label */ 
#line 1261
    if (modifier == 69) {
#line 1262
      goto bad_format;
    }
    {
#line 1264
    while (1) {
      while_continue___84: /* CIL Label */ ;
#line 1264
      digits = 1;
#line 1264
      number_value = (int )tp->tm_wday;
#line 1264
      goto do_number;
#line 1264
      goto while_break___84;
    }
    while_break___84: /* CIL Label */ ;
    }
    case_89: /* CIL Label */ 
#line 1267
    if (modifier == 69) {
#line 1281
      goto underlying_strftime;
    }
#line 1284
    if (modifier == 79) {
#line 1285
      goto bad_format;
    }
    {
#line 1287
    while (1) {
      while_continue___85: /* CIL Label */ ;
#line 1287
      digits = 4;
#line 1287
      negative_number = (_Bool )(tp->tm_year < -1900);
#line 1287
      u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1287
      goto do_signed_number;
#line 1287
      goto while_break___85;
    }
    while_break___85: /* CIL Label */ ;
    }
    case_121: /* CIL Label */ 
#line 1291
    if (modifier == 69) {
#line 1302
      goto underlying_strftime;
    }
#line 1307
    yy___0 = (int )(tp->tm_year % 100);
#line 1308
    if (yy___0 < 0) {
#line 1309
      if (tp->tm_year < -1900) {
#line 1309
        yy___0 = - yy___0;
      } else {
#line 1309
        yy___0 += 100;
      }
    }
    {
#line 1310
    while (1) {
      while_continue___86: /* CIL Label */ ;
#line 1310
      digits = 2;
#line 1310
      number_value = yy___0;
#line 1310
      goto do_number;
#line 1310
      goto while_break___86;
    }
    while_break___86: /* CIL Label */ ;
    }
    case_90: /* CIL Label */ 
#line 1314
    if (change_case) {
#line 1316
      to_uppcase = (_Bool)0;
#line 1317
      to_lowcase = (_Bool)1;
    }
    {
#line 1330
    while (1) {
      while_continue___87: /* CIL Label */ ;
      {
#line 1330
      tmp___36 = strlen(zone);
#line 1330
      _n___10 = tmp___36;
      }
#line 1330
      if (width < 0) {
#line 1330
        tmp___37 = 0;
      } else {
#line 1330
        tmp___37 = width;
      }
#line 1330
      _w___10 = (size_t )tmp___37;
#line 1330
      if (_n___10 < _w___10) {
#line 1330
        tmp___38 = _w___10;
      } else {
#line 1330
        tmp___38 = _n___10;
      }
#line 1330
      _incr___10 = tmp___38;
#line 1330
      if (_incr___10 >= maxsize - i) {
#line 1330
        return ((size_t )0);
      }
#line 1330
      if (p) {
#line 1330
        if (digits == 0) {
#line 1330
          if (_n___10 < _w___10) {
#line 1330
            _delta___10 = (size_t )width - _n___10;
#line 1330
            if (pad == 48) {
              {
#line 1330
              while (1) {
                while_continue___88: /* CIL Label */ ;
#line 1330
                _i___23 = (size_t )0;
                {
#line 1330
                while (1) {
                  while_continue___89: /* CIL Label */ ;
#line 1330
                  if (! (_i___23 < _delta___10)) {
#line 1330
                    goto while_break___89;
                  }
                  {
#line 1330
                  fputc('0', p);
#line 1330
                  _i___23 ++;
                  }
                }
                while_break___89: /* CIL Label */ ;
                }
#line 1330
                goto while_break___88;
              }
              while_break___88: /* CIL Label */ ;
              }
            } else {
              {
#line 1330
              while (1) {
                while_continue___90: /* CIL Label */ ;
#line 1330
                _i___24 = (size_t )0;
                {
#line 1330
                while (1) {
                  while_continue___91: /* CIL Label */ ;
#line 1330
                  if (! (_i___24 < _delta___10)) {
#line 1330
                    goto while_break___91;
                  }
                  {
#line 1330
                  fputc(' ', p);
#line 1330
                  _i___24 ++;
                  }
                }
                while_break___91: /* CIL Label */ ;
                }
#line 1330
                goto while_break___90;
              }
              while_break___90: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1330
        while (1) {
          while_continue___92: /* CIL Label */ ;
#line 1330
          if (to_lowcase) {
            {
#line 1330
            fwrite_lowcase(p, zone, _n___10);
            }
          } else
#line 1330
          if (to_uppcase) {
            {
#line 1330
            fwrite_uppcase(p, zone, _n___10);
            }
          } else {
            {
#line 1330
            fwrite((void const   */* __restrict  */)zone, _n___10, (size_t )1, (FILE */* __restrict  */)p);
            }
          }
#line 1330
          goto while_break___92;
        }
        while_break___92: /* CIL Label */ ;
        }
      }
#line 1330
      i += _incr___10;
#line 1330
      goto while_break___87;
    }
    while_break___87: /* CIL Label */ ;
    }
#line 1332
    goto switch_break___1;
    case_58: /* CIL Label */ 
#line 1337
    colons = (size_t )1;
    {
#line 1337
    while (1) {
      while_continue___93: /* CIL Label */ ;
#line 1337
      if (! ((int const   )*(f + colons) == 58)) {
#line 1337
        goto while_break___93;
      }
#line 1338
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1337
      colons ++;
    }
    while_break___93: /* CIL Label */ ;
    }
#line 1339
    if ((int const   )*(f + colons) != 122) {
#line 1340
      goto bad_format;
    }
#line 1341
    f += colons;
#line 1342
    goto do_z_conversion;
    case_122: /* CIL Label */ 
#line 1345
    colons = (size_t )0;
    do_z_conversion: 
#line 1348
    if (tp->tm_isdst < 0) {
#line 1349
      goto switch_break___1;
    }
#line 1357
    diff = (int )tp->tm_gmtoff;
#line 1394
    hour_diff = (diff / 60) / 60;
#line 1395
    min_diff = (diff / 60) % 60;
#line 1396
    sec_diff = diff % 60;
    {
#line 1400
    if (colons == 0UL) {
#line 1400
      goto case_0;
    }
#line 1403
    if (colons == 1UL) {
#line 1403
      goto tz_hh_mm;
    }
#line 1406
    if (colons == 2UL) {
#line 1406
      goto tz_hh_mm_ss;
    }
#line 1410
    if (colons == 3UL) {
#line 1410
      goto case_3;
    }
#line 1417
    goto switch_default___2;
    case_0: /* CIL Label */ 
    {
#line 1401
    while (1) {
      while_continue___94: /* CIL Label */ ;
#line 1401
      digits = 5;
#line 1401
      negative_number = (_Bool )(diff < 0);
#line 1401
      tz_colon_mask = 0;
#line 1401
      u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1401
      goto do_tz_offset;
#line 1401
      goto while_break___94;
    }
    while_break___94: /* CIL Label */ ;
    }
    tz_hh_mm: 
    case_1: /* CIL Label */ 
    {
#line 1404
    while (1) {
      while_continue___95: /* CIL Label */ ;
#line 1404
      digits = 6;
#line 1404
      negative_number = (_Bool )(diff < 0);
#line 1404
      tz_colon_mask = 4;
#line 1404
      u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1404
      goto do_tz_offset;
#line 1404
      goto while_break___95;
    }
    while_break___95: /* CIL Label */ ;
    }
    tz_hh_mm_ss: 
    case_2: /* CIL Label */ 
    {
#line 1407
    while (1) {
      while_continue___96: /* CIL Label */ ;
#line 1407
      digits = 9;
#line 1407
      negative_number = (_Bool )(diff < 0);
#line 1407
      tz_colon_mask = 20;
#line 1407
      u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1407
      goto do_tz_offset;
#line 1407
      goto while_break___96;
    }
    while_break___96: /* CIL Label */ ;
    }
    case_3: /* CIL Label */ 
#line 1411
    if (sec_diff != 0) {
#line 1412
      goto tz_hh_mm_ss;
    }
#line 1413
    if (min_diff != 0) {
#line 1414
      goto tz_hh_mm;
    }
    {
#line 1415
    while (1) {
      while_continue___97: /* CIL Label */ ;
#line 1415
      digits = 3;
#line 1415
      negative_number = (_Bool )(diff < 0);
#line 1415
      tz_colon_mask = 0;
#line 1415
      u_number_value = (unsigned int )hour_diff;
#line 1415
      goto do_tz_offset;
#line 1415
      goto while_break___97;
    }
    while_break___97: /* CIL Label */ ;
    }
    switch_default___2: /* CIL Label */ 
#line 1418
    goto bad_format;
    switch_break___3: /* CIL Label */ ;
    }
    case_0___0: /* CIL Label */ 
#line 1423
    f --;
    bad_format: 
    switch_default___3: /* CIL Label */ 
#line 1432
    flen = 1;
    {
#line 1432
    while (1) {
      while_continue___98: /* CIL Label */ ;
#line 1432
      if (! ((int const   )*(f + (1 - flen)) != 37)) {
#line 1432
        goto while_break___98;
      }
#line 1433
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1432
      flen ++;
    }
    while_break___98: /* CIL Label */ ;
    }
    {
#line 1434
    while (1) {
      while_continue___99: /* CIL Label */ ;
#line 1434
      _n___11 = (size_t )flen;
#line 1434
      if (width < 0) {
#line 1434
        tmp___39 = 0;
      } else {
#line 1434
        tmp___39 = width;
      }
#line 1434
      _w___11 = (size_t )tmp___39;
#line 1434
      if (_n___11 < _w___11) {
#line 1434
        tmp___40 = _w___11;
      } else {
#line 1434
        tmp___40 = _n___11;
      }
#line 1434
      _incr___11 = tmp___40;
#line 1434
      if (_incr___11 >= maxsize - i) {
#line 1434
        return ((size_t )0);
      }
#line 1434
      if (p) {
#line 1434
        if (digits == 0) {
#line 1434
          if (_n___11 < _w___11) {
#line 1434
            _delta___11 = (size_t )width - _n___11;
#line 1434
            if (pad == 48) {
              {
#line 1434
              while (1) {
                while_continue___100: /* CIL Label */ ;
#line 1434
                _i___25 = (size_t )0;
                {
#line 1434
                while (1) {
                  while_continue___101: /* CIL Label */ ;
#line 1434
                  if (! (_i___25 < _delta___11)) {
#line 1434
                    goto while_break___101;
                  }
                  {
#line 1434
                  fputc('0', p);
#line 1434
                  _i___25 ++;
                  }
                }
                while_break___101: /* CIL Label */ ;
                }
#line 1434
                goto while_break___100;
              }
              while_break___100: /* CIL Label */ ;
              }
            } else {
              {
#line 1434
              while (1) {
                while_continue___102: /* CIL Label */ ;
#line 1434
                _i___26 = (size_t )0;
                {
#line 1434
                while (1) {
                  while_continue___103: /* CIL Label */ ;
#line 1434
                  if (! (_i___26 < _delta___11)) {
#line 1434
                    goto while_break___103;
                  }
                  {
#line 1434
                  fputc(' ', p);
#line 1434
                  _i___26 ++;
                  }
                }
                while_break___103: /* CIL Label */ ;
                }
#line 1434
                goto while_break___102;
              }
              while_break___102: /* CIL Label */ ;
              }
            }
          }
        }
        {
#line 1434
        while (1) {
          while_continue___104: /* CIL Label */ ;
#line 1434
          if (to_lowcase) {
            {
#line 1434
            fwrite_lowcase(p, f + (1 - flen), _n___11);
            }
          } else
#line 1434
          if (to_uppcase) {
            {
#line 1434
            fwrite_uppcase(p, f + (1 - flen), _n___11);
            }
          } else {
            {
#line 1434
            fwrite((void const   */* __restrict  */)(f + (1 - flen)), _n___11, (size_t )1,
                   (FILE */* __restrict  */)p);
            }
          }
#line 1434
          goto while_break___104;
        }
        while_break___104: /* CIL Label */ ;
        }
      }
#line 1434
      i += _incr___11;
#line 1434
      goto while_break___99;
    }
    while_break___99: /* CIL Label */ ;
    }
#line 1436
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 505
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1445
  return (i);
}
}
#line 1454 "/home/khheo/project/benchmark/tar-1.29/gnu/strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , timezone_t tz ,
                   int ns ) 
{ 
  size_t tmp ;

  {
  {
#line 1459
  tmp = strftime_case____0((_Bool)0, s, format, tp, tz, ns);
  }
#line 1459
  return (tmp);
}
}
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/filenamecat.h"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 377 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/khheo/project/benchmark/tar-1.29/gnu/filenamecat-lgpl.c"
static char const   * __attribute__((__pure__)) longest_relative_suffix(char const   *f ) 
{ 


  {
#line 40
  f += 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! ((int const   )*f == 47)) {
#line 40
      goto while_break;
    }
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 42
  return ((char const   */* __attribute__((__pure__)) */)f);
}
}
#line 60 "/home/khheo/project/benchmark/tar-1.29/gnu/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   * __attribute__((__pure__)) tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
  }
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
  {
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = (char const   *)tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
  }
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
  {
#line 77
  tmp___5 = mempcpy((void */* __restrict  */)p_concat, (void const   */* __restrict  */)dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
  }
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
  {
#line 84
  tmp___7 = mempcpy((void */* __restrict  */)p, (void const   */* __restrict  */)base,
                    baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
  }
#line 87
  return (p_concat);
}
}
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/file-has-acl.c"
#pragma GCC diagnostic ignored "-Wsuggest-attribute=const"
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/acl.h"
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
#line 66 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 302
#pragma GCC diagnostic pop
#line 44 "/home/khheo/project/benchmark/tar-1.29/gnu/file-has-acl.c"
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 


  {
#line 502
  return (0);
}
}
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/utimens.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 37
int fdutimensat(int fd , int dir , char const   *file , struct timespec  const  *ts ,
                int atflag ) ;
#line 47
#pragma GCC diagnostic pop
#line 42 "/home/khheo/project/benchmark/tar-1.29/gnu/fdutimensat.c"
int fdutimensat(int fd , int dir , char const   *file , struct timespec  const  *ts ,
                int atflag ) 
{ 
  int result ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 46
  result = 1;
#line 47
  if (0 <= fd) {
    {
#line 48
    result = rpl_futimens(fd, ts);
    }
  }
#line 49
  if (file) {
#line 49
    if (fd < 0) {
      {
#line 50
      result = rpl_utimensat(dir, file, ts, atflag);
      }
    } else
#line 49
    if (result == -1) {
      {
#line 49
      tmp = __errno_location();
      }
#line 49
      if (*tmp == 38) {
        {
#line 50
        result = rpl_utimensat(dir, file, ts, atflag);
        }
      }
    }
  }
#line 51
  if (result == 1) {
    {
#line 53
    tmp___0 = __errno_location();
#line 53
    *tmp___0 = 9;
#line 54
    result = -1;
    }
  }
#line 56
  return (result);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/tar-1.29/gnu/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 39
  if (0 <= fd) {
#line 39
    if (fd <= 2) {
      {
#line 41
      tmp = dup_safer(fd);
#line 41
      f = tmp;
#line 42
      tmp___0 = __errno_location();
#line 42
      e = *tmp___0;
#line 43
      close(fd);
#line 44
      tmp___1 = __errno_location();
#line 44
      *tmp___1 = e;
#line 45
      fd = f;
      }
    }
  }
#line 48
  return (fd);
}
}
#line 147 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 403 "./fcntl.h"
int rpl_fcntl(int fd , int action  , ...) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 248 "/home/khheo/project/benchmark/tar-1.29/gnu/fcntl.c"
static int have_dupfd_cloexec  =    0;
#line 184 "/home/khheo/project/benchmark/tar-1.29/gnu/fcntl.c"
int rpl_fcntl(int fd , int action  , ...) 
{ 
  va_list arg___0 ;
  int result ;
  int target ;
  int tmp___0 ;
  int *tmp___1 ;
  int flags ;
  int tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *p ;
  void *tmp___7 ;

  {
  {
#line 188
  result = -1;
#line 189
  __builtin_va_start(arg___0, action);
  }
  {
#line 233
  if (action == 1030) {
#line 233
    goto case_1030;
  }
#line 314
  goto switch_default;
  case_1030: /* CIL Label */ 
  {
#line 235
  tmp___0 = __builtin_va_arg(arg___0, int );
#line 235
  target = tmp___0;
  }
#line 249
  if (0 <= have_dupfd_cloexec) {
    {
#line 251
    result = fcntl(fd, action, target);
    }
#line 252
    if (0 <= result) {
#line 254
      have_dupfd_cloexec = 1;
    } else {
      {
#line 252
      tmp___1 = __errno_location();
      }
#line 252
      if (*tmp___1 != 22) {
#line 254
        have_dupfd_cloexec = 1;
      } else {
        {
#line 262
        result = rpl_fcntl(fd, 0, target);
        }
#line 263
        if (result < 0) {
#line 264
          goto switch_break;
        }
#line 265
        have_dupfd_cloexec = -1;
      }
    }
  } else {
    {
#line 269
    result = rpl_fcntl(fd, 0, target);
    }
  }
#line 270
  if (0 <= result) {
#line 270
    if (have_dupfd_cloexec == -1) {
      {
#line 272
      tmp___2 = fcntl(result, 1);
#line 272
      flags = tmp___2;
      }
#line 273
      if (flags < 0) {
#line 273
        goto _L;
      } else {
        {
#line 273
        tmp___5 = fcntl(result, 2, flags | 1);
        }
#line 273
        if (tmp___5 == -1) {
          _L: /* CIL Label */ 
          {
#line 275
          tmp___3 = __errno_location();
#line 275
          saved_errno = *tmp___3;
#line 276
          close(result);
#line 277
          tmp___4 = __errno_location();
#line 277
          *tmp___4 = saved_errno;
#line 278
          result = -1;
          }
        }
      }
    }
  }
#line 281
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 317
  tmp___7 = __builtin_va_arg(arg___0, void *);
#line 317
  p = tmp___7;
#line 318
  result = fcntl(fd, action, p);
  }
#line 322
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 325
  __builtin_va_end(arg___0);
  }
#line 326
  return (result);
}
}
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 135 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 232
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 767
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 68 "./wctype.h"
#pragma GCC diagnostic push
#line 68
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 68
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 813
#pragma GCC diagnostic pop
#line 645 "./regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 649
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 657
extern void regfree(regex_t *__preg ) ;
#line 49 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options___0 )  __attribute__((__pure__)) ;
#line 51
struct exclude *new_exclude(void) ;
#line 52
void free_exclude(struct exclude *ex ) ;
#line 53
void add_exclude(struct exclude *ex , char const   *pattern , int options___0 ) ;
#line 54
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___0 , int options___0 ,
                     char line_end ) ;
#line 56
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options___0 , char line_end ,
                   void *data ) ;
#line 58
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 59
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) ;
#line 60
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options___0 ) ;
#line 162 "/home/khheo/project/benchmark/tar-1.29/gnu/mbchar.h"
#pragma GCC diagnostic push
#line 162
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 162
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 358
#pragma GCC diagnostic pop
#line 112 "/home/khheo/project/benchmark/tar-1.29/gnu/mbuiter.h"
#pragma GCC diagnostic push
#line 112
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 112
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 230
#pragma GCC diagnostic pop
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 131 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
void exclude_add_pattern_buffer(struct exclude *ex , char *buf ) 
{ 
  struct pattern_buffer *pbuf ;
  void *tmp ;

  {
  {
#line 134
  tmp = xmalloc(sizeof(*pbuf));
#line 134
  pbuf = (struct pattern_buffer *)tmp;
#line 135
  pbuf->base = buf;
#line 136
  pbuf->next = ex->patbuf;
#line 137
  ex->patbuf = pbuf;
  }
#line 138
  return;
}
}
#line 142
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options___0 )  __attribute__((__pure__)) ;
#line 142 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options___0 ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 147
    tmp = str;
#line 147
    str ++;
    {
#line 153
    if ((int const   )*tmp == 41) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 40) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 125) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 123) {
#line 153
      goto case_41;
    }
#line 153
    if ((int const   )*tmp == 46) {
#line 153
      goto case_41;
    }
#line 158
    if ((int const   )*tmp == 92) {
#line 158
      goto case_92;
    }
#line 165
    if ((int const   )*tmp == 33) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 64) {
#line 165
      goto case_33;
    }
#line 165
    if ((int const   )*tmp == 43) {
#line 165
      goto case_33;
    }
#line 170
    if ((int const   )*tmp == 91) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 42) {
#line 170
      goto case_91;
    }
#line 170
    if ((int const   )*tmp == 63) {
#line 170
      goto case_91;
    }
#line 173
    if ((int const   )*tmp == 0) {
#line 173
      goto case_0;
    }
#line 147
    goto switch_break;
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_46: /* CIL Label */ 
#line 154
    if (options___0 & (1 << 27)) {
#line 155
      return ((_Bool)1);
    }
#line 156
    goto switch_break;
    case_92: /* CIL Label */ 
#line 159
    if (options___0 & (1 << 27)) {
#line 160
      goto while_continue;
    } else {
#line 162
      if (! (options___0 & (1 << 1))) {
#line 162
        if (*str) {
#line 162
          tmp___0 = 1;
        } else {
#line 162
          tmp___0 = 0;
        }
      } else {
#line 162
        tmp___0 = 0;
      }
#line 162
      str += tmp___0;
    }
#line 163
    goto switch_break;
    case_33: /* CIL Label */ 
    case_64: /* CIL Label */ 
    case_43: /* CIL Label */ 
#line 166
    if (options___0 & (1 << 5)) {
#line 166
      if ((int const   )*str == 40) {
#line 167
        return ((_Bool)1);
      }
    }
#line 168
    goto switch_break;
    case_91: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_63: /* CIL Label */ 
#line 171
    return ((_Bool)1);
    case_0: /* CIL Label */ 
#line 174
    return ((_Bool)0);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 179 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static void unescape_pattern(char *str ) 
{ 
  char const   *q ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 182
  q = (char const   *)str;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if ((int const   )*q == 92) {
#line 184
      if (*(q + 1)) {
#line 184
        tmp = 1;
      } else {
#line 184
        tmp = 0;
      }
    } else {
#line 184
      tmp = 0;
    }
#line 184
    q += tmp;
#line 183
    tmp___0 = str;
#line 183
    str ++;
#line 183
    tmp___2 = q;
#line 183
    q ++;
#line 183
    tmp___1 = (char )*tmp___2;
#line 183
    *tmp___0 = tmp___1;
#line 183
    if (! tmp___1) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 190 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
  {
#line 193
  tmp___0 = xzalloc(sizeof(*tmp));
  }
#line 193
  return ((struct exclude *)tmp___0);
}
}
#line 197 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
  {
#line 200
  p = (char const   *)data;
#line 201
  tmp = hash_string(p, n_buckets);
  }
#line 201
  return (tmp);
}
}
#line 205 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value___0 ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
  {
#line 208
  p = (char const   *)data;
#line 210
  value___0 = (size_t )0;
#line 212
  iter.cur.ptr = p;
#line 212
  iter.in_shift = (_Bool)0;
#line 212
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 212
  iter.next_done = (_Bool)0;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 212
    mbuiter_multi_next(& iter);
    }
#line 212
    if (iter.cur.wc_valid) {
#line 212
      if (iter.cur.wc == 0) {
#line 212
        tmp___0 = 0;
      } else {
#line 212
        tmp___0 = 1;
      }
    } else {
#line 212
      tmp___0 = 1;
    }
#line 212
    if (! tmp___0) {
#line 212
      goto while_break;
    }
#line 214
    m = iter.cur;
#line 217
    if (m.wc_valid) {
      {
#line 218
      tmp = towlower((wint_t )m.wc);
#line 218
      wc = (wchar_t )tmp;
      }
    } else {
#line 220
      wc = (wchar_t )*(m.ptr);
    }
#line 222
    value___0 = (value___0 * 31UL + (size_t )wc) % n_buckets;
#line 212
    iter.cur.ptr += iter.cur.bytes;
#line 212
    iter.next_done = (_Bool)0;
  }
  while_break: /* CIL Label */ ;
  }
#line 225
  return (value___0);
}
}
#line 229 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 232
  p1 = (char const   *)data1;
#line 233
  p2 = (char const   *)data2;
#line 234
  tmp = strcmp(p1, p2);
  }
#line 234
  return ((_Bool )(tmp == 0));
}
}
#line 238 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
  {
#line 241
  p1 = (char const   *)data1;
#line 242
  p2 = (char const   *)data2;
#line 243
  tmp = mbscasecmp(p1, p2);
  }
#line 243
  return ((_Bool )(tmp == 0));
}
}
#line 246 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static void string_free(void *data ) 
{ 


  {
  {
#line 249
  free(data);
  }
#line 250
  return;
}
}
#line 254 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static void new_exclude_segment(struct exclude *ex , enum exclude_type type , int options___0 ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
  {
#line 257
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 257
  sp = (struct exclude_segment *)tmp;
#line 258
  sp->type = type;
#line 259
  sp->options = options___0;
  }
  {
#line 262
  if ((unsigned int )type == 1U) {
#line 262
    goto case_1;
  }
#line 265
  if ((unsigned int )type == 0U) {
#line 265
    goto case_0;
  }
#line 260
  goto switch_break;
  case_1: /* CIL Label */ 
#line 263
  goto switch_break;
  case_0: /* CIL Label */ 
#line 266
  if (options___0 & (1 << 4)) {
#line 266
    tmp___0 = & string_compare_ci;
  } else {
#line 266
    tmp___0 = & string_compare;
  }
#line 266
  if (options___0 & (1 << 4)) {
#line 266
    tmp___1 = & string_hasher_ci;
  } else {
#line 266
    tmp___1 = & string_hasher;
  }
  {
#line 266
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
  }
#line 274
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 276
  sp->next = ex->head;
#line 277
  ex->head = sp;
#line 278
  return;
}
}
#line 281 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 
  size_t i ;

  {
  {
#line 288
  if ((unsigned int )seg->type == 1U) {
#line 288
    goto case_1;
  }
#line 297
  if ((unsigned int )seg->type == 0U) {
#line 297
    goto case_0;
  }
#line 286
  goto switch_break;
  case_1: /* CIL Label */ 
#line 289
  i = (size_t )0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < seg->v.pat.exclude_count)) {
#line 289
      goto while_break;
    }
#line 291
    if ((seg->v.pat.exclude + i)->options & (1 << 27)) {
      {
#line 292
      regfree(& (seg->v.pat.exclude + i)->v.re);
      }
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 294
  free((void *)seg->v.pat.exclude);
  }
#line 295
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 298
  hash_free(seg->v.table);
  }
#line 299
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 301
  free((void *)seg);
  }
#line 302
  return;
}
}
#line 305 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 
  struct exclude_segment *seg ;
  struct pattern_buffer *pbuf ;
  struct exclude_segment *next ;
  struct pattern_buffer *next___0 ;

  {
#line 311
  seg = ex->head;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
#line 311
    if (! seg) {
#line 311
      goto while_break;
    }
    {
#line 313
    next = seg->next;
#line 314
    free_exclude_segment(seg);
#line 315
    seg = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  pbuf = ex->patbuf;
  {
#line 318
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 318
    if (! pbuf) {
#line 318
      goto while_break___0;
    }
    {
#line 320
    next___0 = pbuf->next;
#line 321
    free((void *)pbuf->base);
#line 322
    free((void *)pbuf);
#line 323
    pbuf = next___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 326
  free((void *)ex);
  }
#line 327
  return;
}
}
#line 332 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 335
  if (! (options___0 & (1 << 3))) {
#line 336
    if (options___0 & (1 << 4)) {
      {
#line 336
      tmp = mbscasecmp(pattern, f);
#line 336
      tmp___1 = tmp;
      }
    } else {
      {
#line 336
      tmp___0 = strcmp(pattern, f);
#line 336
      tmp___1 = tmp___0;
      }
    }
#line 336
    return (tmp___1);
  } else
#line 339
  if (! (options___0 & (1 << 4))) {
    {
#line 341
    tmp___2 = strlen(pattern);
#line 341
    patlen = tmp___2;
#line 342
    tmp___3 = strncmp(pattern, f, patlen);
#line 342
    r = tmp___3;
    }
#line 343
    if (! r) {
#line 345
      r = (int )*(f + patlen);
#line 346
      if (r == 47) {
#line 347
        r = 0;
      }
    }
#line 349
    return (r);
  } else {
    {
#line 360
    tmp___4 = xstrdup(f);
#line 360
    fcopy = tmp___4;
#line 363
    p = fcopy;
    }
    {
#line 363
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 365
      p = strchr((char const   *)p, '/');
      }
#line 366
      if (p) {
#line 367
        *p = (char )'\000';
      }
      {
#line 368
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
      }
#line 369
      if (! p) {
#line 370
        goto while_break;
      } else
#line 369
      if (r___0 <= 0) {
#line 370
        goto while_break;
      }
#line 363
      tmp___5 = p;
#line 363
      p ++;
#line 363
      *tmp___5 = (char )'/';
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 372
    free((void *)fcopy);
    }
#line 373
    return (r___0);
  }
}
}
#line 377 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options___0 ) 
{ 
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 380
  if (options___0 & (1 << 28)) {
#line 380
    tmp = & fnmatch;
  } else {
#line 380
    tmp = & fnmatch_no_wildcards;
  }
  {
#line 380
  matcher = tmp;
#line 384
  tmp___0 = (*matcher)(pattern, f, options___0);
#line 384
  matched = (_Bool )(tmp___0 == 0);
  }
#line 387
  if (! (options___0 & (1 << 30))) {
#line 388
    p = f;
    {
#line 388
    while (1) {
      while_continue: /* CIL Label */ ;
#line 388
      if (*p) {
#line 388
        if (! (! matched)) {
#line 388
          goto while_break;
        }
      } else {
#line 388
        goto while_break;
      }
#line 389
      if ((int const   )*p == 47) {
#line 389
        if ((int const   )*(p + 1) != 47) {
          {
#line 390
          tmp___1 = (*matcher)(pattern, p + 1, options___0);
#line 390
          matched = (_Bool )(tmp___1 == 0);
          }
        }
      }
#line 388
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 392
  return (matched);
}
}
#line 395 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static _Bool exclude_patopts(struct patopts  const  *opts , char const   *f ) 
{ 
  int options___0 ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 398
  options___0 = (int )opts->options;
#line 400
  if (options___0 & (1 << 27)) {
    {
#line 400
    tmp = regexec((regex_t const   */* __restrict  */)(& opts->v.re), (char const   */* __restrict  */)f,
                  (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 400
    tmp___1 = tmp == 0;
    }
  } else {
    {
#line 400
    tmp___0 = exclude_fnmatch((char const   *)opts->v.pattern, f, options___0);
#line 400
    tmp___1 = (int )tmp___0;
    }
  }
#line 400
  return ((_Bool )tmp___1);
}
}
#line 407 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static _Bool file_pattern_matches(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude ;
  size_t i ;
  _Bool tmp ;

  {
#line 410
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 411
  exclude = (struct patopts  const  *)seg->v.pat.exclude;
#line 414
  i = (size_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < exclude_count)) {
#line 414
      goto while_break;
    }
    {
#line 416
    tmp = exclude_patopts(exclude + i, f);
    }
#line 416
    if (tmp) {
#line 417
      return ((_Bool)1);
    }
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 419
  return ((_Bool)0);
}
}
#line 425 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static _Bool file_name_matches(struct exclude_segment  const  *seg , char const   *f ,
                               char *buffer___1 ) 
{ 
  int options___0 ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 429
  options___0 = (int )seg->options;
#line 430
  table = (Hash_table *)seg->v.table;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 435
    strcpy((char */* __restrict  */)buffer___1, (char const   */* __restrict  */)f);
    }
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 439
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer___1);
      }
#line 439
      if (tmp) {
#line 440
        return ((_Bool)1);
      }
#line 441
      if (options___0 & (1 << 3)) {
        {
#line 443
        tmp___0 = strrchr((char const   *)buffer___1, '/');
#line 443
        p = tmp___0;
        }
#line 444
        if (p) {
#line 446
          *p = (char)0;
#line 447
          goto while_continue___0;
        }
      }
#line 450
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 453
    if (! (options___0 & (1 << 30))) {
      {
#line 455
      tmp___1 = strchr(f, '/');
#line 455
      f = (char const   *)tmp___1;
      }
#line 456
      if (f) {
#line 457
        f ++;
      }
    } else {
#line 460
      goto while_break;
    }
#line 432
    if (! f) {
#line 432
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 464
  return ((_Bool)0);
}
}
#line 469 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  struct exclude_segment *seg ;
  _Bool invert ;
  char *filename ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
#line 473
  invert = (_Bool)0;
#line 474
  filename = (char *)((void *)0);
#line 477
  if (! ex->head) {
#line 478
    return ((_Bool)0);
  }
#line 483
  seg = (struct exclude_segment *)ex->head;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if ((unsigned int )seg->type == 0U) {
#line 487
      if (! filename) {
        {
#line 488
        tmp = strlen(f);
#line 488
        tmp___0 = xmalloc(tmp + 1UL);
#line 488
        filename = (char *)tmp___0;
        }
      }
      {
#line 489
      tmp___1 = file_name_matches((struct exclude_segment  const  *)seg, f, filename);
      }
#line 489
      if (tmp___1) {
#line 490
        goto while_break;
      }
    } else {
      {
#line 494
      tmp___2 = file_pattern_matches((struct exclude_segment  const  *)seg, f);
      }
#line 494
      if (tmp___2) {
#line 495
        goto while_break;
      }
    }
#line 498
    if (! seg->next) {
#line 506
      invert = (_Bool)1;
#line 507
      goto while_break;
    }
#line 483
    seg = seg->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 511
  free((void *)filename);
  }
#line 512
  return ((_Bool )((int )invert ^ ! (seg->options & (1 << 29))));
}
}
#line 517 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options___0 ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  int rc ;
  int cflags ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t len ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *str ;
  char *p ;
  int exclude_hash_flags ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 524
  if (options___0 & ((1 << 27) | (1 << 28))) {
    {
#line 524
    tmp___7 = fnmatch_pattern_has_wildcards(pattern, options___0);
    }
#line 524
    if (tmp___7) {
#line 527
      if (ex->head) {
#line 527
        if ((unsigned int )(ex->head)->type == 1U) {
#line 527
          if (! (((ex->head)->options & (1 << 29)) == (options___0 & (1 << 29)))) {
            {
#line 530
            new_exclude_segment(ex, (enum exclude_type )1, options___0);
            }
          }
        } else {
          {
#line 530
          new_exclude_segment(ex, (enum exclude_type )1, options___0);
          }
        }
      } else {
        {
#line 530
        new_exclude_segment(ex, (enum exclude_type )1, options___0);
        }
      }
#line 532
      seg = ex->head;
#line 534
      pat = & seg->v.pat;
#line 535
      if (pat->exclude_count == pat->exclude_alloc) {
        {
#line 536
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 536
        pat->exclude = (struct patopts *)tmp;
        }
      }
#line 538
      tmp___0 = pat->exclude_count;
#line 538
      (pat->exclude_count) ++;
#line 538
      patopts = pat->exclude + tmp___0;
#line 540
      patopts->options = options___0;
#line 541
      if (options___0 & (1 << 27)) {
#line 544
        if (options___0 & (1 << 4)) {
#line 544
          tmp___1 = 1 << 1;
        } else {
#line 544
          tmp___1 = 0;
        }
#line 544
        cflags = ((1 << 3) | 1) | tmp___1;
#line 547
        if (options___0 & (1 << 3)) {
          {
#line 550
          tmp___3 = strlen(pattern);
#line 550
          len = tmp___3;
          }
          {
#line 552
          while (1) {
            while_continue: /* CIL Label */ ;
#line 552
            if (len > 0UL) {
#line 552
              if (! ((int const   )*(pattern + (len - 1UL)) == 47)) {
#line 552
                goto while_break;
              }
            } else {
#line 552
              goto while_break;
            }
#line 553
            len --;
          }
          while_break: /* CIL Label */ ;
          }
#line 555
          if (len == 0UL) {
#line 556
            rc = 1;
          } else {
            {
#line 559
            tmp___4 = xmalloc(len + 7UL);
#line 559
            tmp___2 = (char *)tmp___4;
#line 560
            memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)pattern,
                   len);
#line 561
            strcpy((char */* __restrict  */)(tmp___2 + len), (char const   */* __restrict  */)"(/.*)?");
#line 562
            rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)tmp___2,
                         cflags);
#line 563
            free((void *)tmp___2);
            }
          }
        } else {
          {
#line 567
          rc = regcomp((regex_t */* __restrict  */)(& patopts->v.re), (char const   */* __restrict  */)pattern,
                       cflags);
          }
        }
#line 569
        if (rc) {
#line 571
          (pat->exclude_count) --;
#line 572
          return;
        }
      } else {
#line 577
        if (options___0 & (1 << 26)) {
          {
#line 579
          tmp___5 = xstrdup(pattern);
#line 579
          pattern = (char const   *)tmp___5;
#line 580
          exclude_add_pattern_buffer(ex, (char *)pattern);
          }
        }
#line 582
        patopts->v.pattern = pattern;
      }
    } else {
#line 524
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 588
    exclude_hash_flags = (((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4);
#line 590
    if (ex->head) {
#line 590
      if ((unsigned int )(ex->head)->type == 0U) {
#line 590
        if (! (((ex->head)->options & exclude_hash_flags) == (options___0 & exclude_hash_flags))) {
          {
#line 593
          new_exclude_segment(ex, (enum exclude_type )0, options___0);
          }
        }
      } else {
        {
#line 593
        new_exclude_segment(ex, (enum exclude_type )0, options___0);
        }
      }
    } else {
      {
#line 593
      new_exclude_segment(ex, (enum exclude_type )0, options___0);
      }
    }
    {
#line 594
    seg = ex->head;
#line 596
    str = xstrdup(pattern);
    }
#line 597
    if ((options___0 & ((1 << 28) | (1 << 1))) == 1 << 28) {
      {
#line 598
      unescape_pattern(str);
      }
    }
    {
#line 599
    tmp___6 = hash_insert(seg->v.table, (void const   *)str);
#line 599
    p = (char *)tmp___6;
    }
#line 600
    if ((unsigned long )p != (unsigned long )str) {
      {
#line 601
      free((void *)str);
      }
    }
  }
#line 603
  return;
}
}
#line 610 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
int add_exclude_fp(void (*add_func)(struct exclude * , char const   * , int  , void * ) ,
                   struct exclude *ex , FILE *fp , int options___0 , char line_end ,
                   void *data ) 
{ 
  char *buf ;
  char *p ;
  char *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  char *pattern_end ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;

  {
#line 616
  buf = (char *)((void *)0);
#line 620
  buf_alloc = (size_t )0;
#line 621
  buf_count = (size_t )0;
#line 623
  e = 0;
  {
#line 625
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 625
    c = getc_unlocked(fp);
    }
#line 625
    if (! (c != -1)) {
#line 625
      goto while_break;
    }
#line 627
    if (buf_count == buf_alloc) {
      {
#line 628
      tmp = x2realloc((void *)buf, & buf_alloc);
#line 628
      buf = (char *)tmp;
      }
    }
#line 629
    tmp___0 = buf_count;
#line 629
    buf_count ++;
#line 629
    *(buf + tmp___0) = (char )c;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  tmp___2 = ferror_unlocked(fp);
  }
#line 632
  if (tmp___2) {
    {
#line 633
    tmp___1 = __errno_location();
#line 633
    e = *tmp___1;
    }
  }
  {
#line 635
  tmp___3 = xrealloc((void *)buf, buf_count + 1UL);
#line 635
  buf = (char *)tmp___3;
#line 636
  *(buf + buf_count) = line_end;
  }
#line 637
  if (buf_count == 0UL) {
#line 637
    tmp___4 = 0;
  } else
#line 637
  if ((int )*(buf + (buf_count - 1UL)) == (int )line_end) {
#line 637
    tmp___4 = 0;
  } else {
#line 637
    tmp___4 = 1;
  }
  {
#line 637
  lim = (char const   *)((buf + buf_count) + tmp___4);
#line 639
  exclude_add_pattern_buffer(ex, buf);
#line 641
  pattern = buf;
#line 643
  p = buf;
  }
  {
#line 643
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 643
    if (! ((unsigned long )p < (unsigned long )lim)) {
#line 643
      goto while_break___0;
    }
#line 644
    if ((int )*p == (int )line_end) {
      {
#line 646
      pattern_end = p;
#line 648
      tmp___6 = __ctype_b_loc();
      }
#line 648
      if ((int const   )*(*tmp___6 + (int )((unsigned char )line_end)) & 8192) {
        {
#line 650
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 651
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 652
            goto next_pattern;
          } else {
            {
#line 653
            tmp___5 = __ctype_b_loc();
            }
#line 653
            if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 654
              goto while_break___1;
            }
          }
#line 650
          pattern_end --;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 657
      *pattern_end = (char )'\000';
#line 658
      (*add_func)(ex, (char const   *)pattern, options___0, data);
      }
      next_pattern: 
#line 661
      pattern = p + 1;
    }
#line 643
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 664
  tmp___7 = __errno_location();
#line 664
  *tmp___7 = e;
  }
#line 665
  if (e) {
#line 665
    tmp___8 = -1;
  } else {
#line 665
    tmp___8 = 0;
  }
#line 665
  return (tmp___8);
}
}
#line 668 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
static void call_addfn(struct exclude *ex , char const   *pattern , int options___0 ,
                       void *data ) 
{ 
  void (**addfnptr)(struct exclude * , char const   * , int  ) ;

  {
  {
#line 671
  addfnptr = (void (**)(struct exclude * , char const   * , int  ))data;
#line 672
  (*(*addfnptr))(ex, pattern, options___0);
  }
#line 673
  return;
}
}
#line 675 "/home/khheo/project/benchmark/tar-1.29/gnu/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___0 , int options___0 ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  int rc ;
  int tmp___0 ;

  {
#line 680
  if ((int const   )*(file_name___0 + 0) == 45) {
#line 680
    if (! *(file_name___0 + 1)) {
#line 680
      tmp = 1;
    } else {
#line 680
      tmp = 0;
    }
  } else {
#line 680
    tmp = 0;
  }
#line 680
  use_stdin = (_Bool )tmp;
#line 682
  rc = 0;
#line 684
  if (use_stdin) {
#line 685
    in = stdin;
  } else {
    {
#line 686
    in = fopen((char const   */* __restrict  */)file_name___0, (char const   */* __restrict  */)"r");
    }
#line 686
    if (! in) {
#line 687
      return (-1);
    }
  }
  {
#line 689
  rc = add_exclude_fp(& call_addfn, ex, in, options___0, line_end, (void *)(& add_func));
  }
#line 691
  if (! use_stdin) {
    {
#line 691
    tmp___0 = fclose(in);
    }
#line 691
    if (tmp___0 != 0) {
#line 692
      rc = -1;
    }
  }
#line 694
  return (rc);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
  {
#line 33
  tmp = rpl_fcntl(fd, 0, 3);
  }
#line 33
  return (tmp);
}
}
#line 40 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname.h"
char *dir_name(char const   *file ) ;
#line 43
char *mdir_name(char const   *file ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *tmp ;

  {
  {
#line 34
  tmp = mdir_name(file);
#line 34
  result = tmp;
  }
#line 35
  if (! result) {
    {
#line 36
    xalloc_die();
    }
  }
#line 37
  return (result);
}
}
#line 45 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname.h"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname-lgpl.c"
size_t dir_len(char const   *file )  __attribute__((__pure__)) ;
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
  {
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (prefix_length < length)) {
#line 48
      goto while_break;
    }
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      goto while_break;
    }
#line 48
    length --;
  }
  while_break: /* CIL Label */ ;
  }
#line 52
  return (length);
}
}
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
  }
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
  {
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
  }
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
  {
#line 81
  memcpy((void */* __restrict  */)dir, (void const   */* __restrict  */)file, length);
  }
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 135 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.h"
int c_tolower(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  } else
#line 33
  if (n == 0UL) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
#line 41
    n --;
    }
#line 41
    if (n == 0UL) {
#line 42
      goto while_break;
    } else
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 )  __attribute__((__pure__)) ;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 29
  p1 = (unsigned char const   *)s1;
#line 30
  p2 = (unsigned char const   *)s2;
#line 33
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 34
    return (0);
  }
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = c_tolower((int )*p1);
#line 38
    c1 = (unsigned char )tmp;
#line 39
    tmp___0 = c_tolower((int )*p2);
#line 39
    c2 = (unsigned char )tmp___0;
    }
#line 41
    if ((int )c1 == 0) {
#line 42
      goto while_break;
    }
#line 44
    p1 ++;
#line 45
    p2 ++;
#line 36
    if (! ((int )c1 == (int )c2)) {
#line 36
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return ((int )c1 - (int )c2);
}
}
#line 2 "/home/khheo/project/benchmark/tar-1.29/gnu/close-stream.h"
int close_stream(FILE *stream ) ;
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 55 "/home/khheo/project/benchmark/tar-1.29/gnu/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 58
  tmp = __fpending(stream);
#line 58
  some_pending = (_Bool )(tmp != 0UL);
#line 59
  tmp___0 = ferror_unlocked(stream);
#line 59
  prev_fail = (_Bool )(tmp___0 != 0);
#line 60
  tmp___1 = fclose(stream);
#line 60
  fclose_fail = (_Bool )(tmp___1 != 0);
  }
#line 70
  if (prev_fail) {
#line 70
    goto _L___0;
  } else
#line 70
  if (fclose_fail) {
#line 70
    if (some_pending) {
#line 70
      goto _L___0;
    } else {
      {
#line 70
      tmp___3 = __errno_location();
      }
#line 70
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 72
        if (! fclose_fail) {
          {
#line 73
          tmp___2 = __errno_location();
#line 73
          *tmp___2 = 0;
          }
        }
#line 74
        return (-1);
      }
    }
  }
#line 77
  return (0);
}
}
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 30
void close_stdout(void) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 36 "/home/khheo/project/benchmark/tar-1.29/gnu/closeout.c"
static char const   *file_name  ;
#line 40 "/home/khheo/project/benchmark/tar-1.29/gnu/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 43
  file_name = file;
#line 44
  return;
}
}
#line 46 "/home/khheo/project/benchmark/tar-1.29/gnu/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/khheo/project/benchmark/tar-1.29/gnu/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/khheo/project/benchmark/tar-1.29/gnu/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error___0 ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 109
  tmp___3 = close_stream(stdout);
  }
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
      {
#line 109
      tmp___4 = __errno_location();
      }
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 112
      tmp = gettext("write error");
#line 112
      write_error___0 = (char const   *)tmp;
      }
#line 113
      if (file_name) {
        {
#line 114
        tmp___0 = quotearg_colon(file_name);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error___0);
        }
      } else {
        {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error___0);
        }
      }
      {
#line 119
      _exit((int )exit_failure);
      }
    }
  }
  {
#line 122
  tmp___5 = close_stream(stderr);
  }
#line 122
  if (tmp___5 != 0) {
    {
#line 123
    _exit((int )exit_failure);
    }
  }
#line 124
  return;
}
}
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/cloexec.h"
int dup_cloexec(int fd ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 38 "/home/khheo/project/benchmark/tar-1.29/gnu/cloexec.c"
int set_cloexec_flag(int desc , _Bool value___0 ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 43
  tmp = rpl_fcntl(desc, 1, 0);
#line 43
  flags = tmp;
  }
#line 45
  if (0 <= flags) {
#line 47
    if (value___0) {
#line 47
      tmp___0 = flags | 1;
    } else {
#line 47
      tmp___0 = flags & -2;
    }
#line 47
    newflags = tmp___0;
#line 49
    if (flags == newflags) {
#line 51
      return (0);
    } else {
      {
#line 49
      tmp___1 = rpl_fcntl(desc, 2, newflags);
      }
#line 49
      if (tmp___1 != -1) {
#line 51
        return (0);
      }
    }
  }
#line 54
  return (-1);
}
}
#line 79 "/home/khheo/project/benchmark/tar-1.29/gnu/cloexec.c"
int dup_cloexec(int fd ) 
{ 
  int tmp ;

  {
  {
#line 82
  tmp = rpl_fcntl(fd, 1030, 0);
  }
#line 82
  return (tmp);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 500 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 181 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 114 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 276
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 46 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 49
  cdb->fd = -100;
#line 50
  return;
}
}
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
  {
#line 55
  tmp = fchdir((int )cdb->fd);
  }
#line 55
  return (tmp);
}
}
#line 58 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 61
  if (0 <= (int )cdb->fd) {
    {
#line 63
    tmp = close((int )cdb->fd);
#line 63
    close_fail = (_Bool )tmp;
    }
#line 64
    if (! (! close_fail)) {
      {
#line 64
      __assert_fail("! close_fail", "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c",
                    64U, "cdb_free");
      }
    }
  }
#line 66
  return;
}
}
#line 72 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
  {
#line 75
  tmp = openat(cdb->fd, dir, 67840);
#line 75
  new_fd = tmp;
  }
#line 77
  if (new_fd < 0) {
#line 78
    return (-1);
  }
  {
#line 80
  cdb_free((struct cd_buf  const  *)cdb);
#line 81
  cdb->fd = new_fd;
  }
#line 83
  return (0);
}
}
#line 87 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
static char * __attribute__((__pure__)) find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
  {
#line 90
  tmp = strspn(s, "/");
#line 90
  n_slash = tmp;
  }
#line 91
  return ((char */* __attribute__((__pure__)) */)((char *)s + n_slash));
}
}
#line 109 "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___4 ;
  int *tmp___5 ;
  char * __attribute__((__pure__)) tmp___6 ;
  int tmp___7 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___10 ;
  int *tmp___11 ;
  char * __attribute__((__pure__)) tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int saved_errno ;
  int *tmp___16 ;
  int *tmp___17 ;

  {
  {
#line 112
  tmp = chdir((char const   *)dir);
#line 112
  e = tmp;
  }
#line 113
  if (e == 0) {
#line 114
    return (e);
  } else {
    {
#line 113
    tmp___0 = __errno_location();
    }
#line 113
    if (*tmp___0 != 36) {
#line 114
      return (e);
    }
  }
  {
#line 117
  tmp___1 = strlen((char const   *)dir);
#line 117
  len = tmp___1;
#line 118
  dir_end = dir + len;
#line 122
  cdb_init(& cdb);
  }
#line 126
  if (! (0UL < len)) {
    {
#line 126
    __assert_fail("0 < len", "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c",
                  126U, "chdir_long");
    }
  }
#line 127
  if (! (4096UL <= len)) {
    {
#line 127
    __assert_fail("4096 <= len", "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c",
                  127U, "chdir_long");
    }
  }
  {
#line 130
  n_leading_slash = strspn((char const   *)dir, "/");
  }
#line 137
  if (n_leading_slash == 2UL) {
    {
#line 142
    tmp___4 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 142
    slash = (char *)tmp___4;
    }
#line 143
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
      {
#line 145
      tmp___5 = __errno_location();
#line 145
      *tmp___5 = 36;
      }
#line 146
      return (-1);
    }
    {
#line 148
    *slash = (char )'\000';
#line 149
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 150
    *slash = (char )'/';
    }
#line 151
    if (err != 0) {
#line 152
      goto Fail;
    }
    {
#line 153
    tmp___6 = find_non_slash((char const   *)(slash + 1));
#line 153
    dir = (char *)tmp___6;
    }
  } else
#line 155
  if (n_leading_slash) {
    {
#line 157
    tmp___7 = cdb_advance_fd(& cdb, "/");
    }
#line 157
    if (tmp___7 != 0) {
#line 158
      goto Fail;
    }
#line 159
    dir += n_leading_slash;
  }
#line 162
  if (! ((int )*dir != 47)) {
    {
#line 162
    __assert_fail("*dir != \'/\'", "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c",
                  162U, "chdir_long");
    }
  }
#line 163
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
    {
#line 163
    __assert_fail("dir <= dir_end", "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c",
                  163U, "chdir_long");
    }
  }
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (! (4096L <= dir_end - dir)) {
#line 165
      goto while_break;
    }
    {
#line 171
    tmp___10 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 171
    slash___0 = (char *)tmp___10;
    }
#line 172
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
      {
#line 174
      tmp___11 = __errno_location();
#line 174
      *tmp___11 = 36;
      }
#line 175
      return (-1);
    }
#line 178
    *slash___0 = (char )'\000';
#line 179
    if (! (slash___0 - dir < 4096L)) {
      {
#line 179
      __assert_fail("slash - dir < 4096", "/home/khheo/project/benchmark/tar-1.29/gnu/chdir-long.c",
                    179U, "chdir_long");
      }
    }
    {
#line 180
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 181
    *slash___0 = (char )'/';
    }
#line 182
    if (err___0 != 0) {
#line 183
      goto Fail;
    }
    {
#line 185
    tmp___13 = find_non_slash((char const   *)(slash___0 + 1));
#line 185
    dir = (char *)tmp___13;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  if ((unsigned long )dir < (unsigned long )dir_end) {
    {
#line 190
    tmp___14 = cdb_advance_fd(& cdb, (char const   *)dir);
    }
#line 190
    if (tmp___14 != 0) {
#line 191
      goto Fail;
    }
  }
  {
#line 194
  tmp___15 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
  }
#line 194
  if (tmp___15 != 0) {
#line 195
    goto Fail;
  }
  {
#line 197
  cdb_free((struct cd_buf  const  *)(& cdb));
  }
#line 198
  return (0);
  Fail: 
  {
#line 202
  tmp___16 = __errno_location();
#line 202
  saved_errno = *tmp___16;
#line 203
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 204
  tmp___17 = __errno_location();
#line 204
  *tmp___17 = saved_errno;
  }
#line 205
  return (-1);
}
}
#line 120 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.h"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 122
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 124
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 125
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 126
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 127
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 128
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 129
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 130
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 132
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 133
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isascii(int c )  __attribute__((__const__)) ;
#line 26 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 29
  if (c >= 0) {
#line 29
    if (c <= 127) {
#line 29
      tmp = 1;
    } else {
#line 29
      tmp = 0;
    }
  } else {
#line 29
    tmp = 0;
  }
#line 29
  return ((_Bool )tmp);
}
}
#line 32
_Bool c_isalnum(int c )  __attribute__((__const__)) ;
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 38
  if (c >= 48) {
#line 38
    if (c <= 57) {
#line 38
      tmp = 1;
    } else {
#line 38
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 38
  if ((c & -33) >= 65) {
#line 38
    if ((c & -33) <= 90) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
  } else {
#line 38
    tmp = 0;
  }
#line 38
  return ((_Bool )tmp);
}
}
#line 67
_Bool c_isalpha(int c )  __attribute__((__const__)) ;
#line 67 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 72
  if ((c & -33) >= 65) {
#line 72
    if ((c & -33) <= 90) {
#line 72
      tmp = 1;
    } else {
#line 72
      tmp = 0;
    }
  } else {
#line 72
    tmp = 0;
  }
#line 72
  return ((_Bool )tmp);
}
}
#line 96
_Bool c_isblank(int c )  __attribute__((__const__)) ;
#line 96 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 99
  if (c == 32) {
#line 99
    tmp = 1;
  } else
#line 99
  if (c == 9) {
#line 99
    tmp = 1;
  } else {
#line 99
    tmp = 0;
  }
#line 99
  return ((_Bool )tmp);
}
}
#line 102
_Bool c_iscntrl(int c )  __attribute__((__const__)) ;
#line 102 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 106
  if ((c & -32) == 0) {
#line 106
    tmp = 1;
  } else
#line 106
  if (c == 127) {
#line 106
    tmp = 1;
  } else {
#line 106
    tmp = 0;
  }
#line 106
  return ((_Bool )tmp);
}
}
#line 136
_Bool c_isdigit(int c )  __attribute__((__const__)) ;
#line 136 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 140
  if (c >= 48) {
#line 140
    if (c <= 57) {
#line 140
      tmp = 1;
    } else {
#line 140
      tmp = 0;
    }
  } else {
#line 140
    tmp = 0;
  }
#line 140
  return ((_Bool )tmp);
}
}
#line 153
_Bool c_islower(int c )  __attribute__((__const__)) ;
#line 153 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 157
  if (c >= 97) {
#line 157
    if (c <= 122) {
#line 157
      tmp = 1;
    } else {
#line 157
      tmp = 0;
    }
  } else {
#line 157
    tmp = 0;
  }
#line 157
  return ((_Bool )tmp);
}
}
#line 173
_Bool c_isgraph(int c )  __attribute__((__const__)) ;
#line 173 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 177
  if (c >= 33) {
#line 177
    if (c <= 126) {
#line 177
      tmp = 1;
    } else {
#line 177
      tmp = 0;
    }
  } else {
#line 177
    tmp = 0;
  }
#line 177
  return ((_Bool )tmp);
}
}
#line 207
_Bool c_isprint(int c )  __attribute__((__const__)) ;
#line 207 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 211
  if (c >= 32) {
#line 211
    if (c <= 126) {
#line 211
      tmp = 1;
    } else {
#line 211
      tmp = 0;
    }
  } else {
#line 211
    tmp = 0;
  }
#line 211
  return ((_Bool )tmp);
}
}
#line 241
_Bool c_ispunct(int c )  __attribute__((__const__)) ;
#line 241 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 245
  if (c >= 33) {
#line 245
    if (c <= 126) {
#line 245
      if (c >= 48) {
#line 245
        if (c <= 57) {
#line 245
          tmp = 0;
        } else {
#line 245
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 245
      if ((c & -33) >= 65) {
#line 245
        if ((c & -33) <= 90) {
#line 245
          tmp = 0;
        } else {
#line 245
          tmp = 1;
        }
      } else {
#line 245
        tmp = 1;
      }
    } else {
#line 245
      tmp = 0;
    }
  } else {
#line 245
    tmp = 0;
  }
#line 245
  return ((_Bool )tmp);
}
}
#line 265
_Bool c_isspace(int c )  __attribute__((__const__)) ;
#line 265 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 268
  if (c == 32) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 9) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 10) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 11) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 12) {
#line 268
    tmp = 1;
  } else
#line 268
  if (c == 13) {
#line 268
    tmp = 1;
  } else {
#line 268
    tmp = 0;
  }
#line 268
  return ((_Bool )tmp);
}
}
#line 272
_Bool c_isupper(int c )  __attribute__((__const__)) ;
#line 272 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 276
  if (c >= 65) {
#line 276
    if (c <= 90) {
#line 276
      tmp = 1;
    } else {
#line 276
      tmp = 0;
    }
  } else {
#line 276
    tmp = 0;
  }
#line 276
  return ((_Bool )tmp);
}
}
#line 292
_Bool c_isxdigit(int c )  __attribute__((__const__)) ;
#line 292 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 298
  if (c >= 48) {
#line 298
    if (c <= 57) {
#line 298
      tmp = 1;
    } else {
#line 298
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 298
  if ((c & -33) >= 65) {
#line 298
    if ((c & -33) <= 70) {
#line 298
      tmp = 1;
    } else {
#line 298
      tmp = 0;
    }
  } else {
#line 298
    tmp = 0;
  }
#line 298
  return ((_Bool )tmp);
}
}
#line 319
int c_tolower(int c )  __attribute__((__const__)) ;
#line 319 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 323
  if (c >= 65) {
#line 323
    if (c <= 90) {
#line 323
      tmp = (c - 65) + 97;
    } else {
#line 323
      tmp = c;
    }
  } else {
#line 323
    tmp = c;
  }
#line 323
  return (tmp);
}
}
#line 358
int c_toupper(int c )  __attribute__((__const__)) ;
#line 358 "/home/khheo/project/benchmark/tar-1.29/gnu/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 362
  if (c >= 97) {
#line 362
    if (c <= 122) {
#line 362
      tmp = (c - 97) + 65;
    } else {
#line 362
      tmp = c;
    }
  } else {
#line 362
    tmp = c;
  }
#line 362
  return (tmp);
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 49 "/home/khheo/project/benchmark/tar-1.29/gnu/careadlinkat.h"
char *careadlinkat(int fd , char const   *filename , char *buffer___1 , size_t buffer_size ,
                   struct allocator  const  *alloc , ssize_t (*preadlinkat)(int  ,
                                                                            char const   * ,
                                                                            char * ,
                                                                            size_t  ) ) ;
#line 56 "/home/khheo/project/benchmark/tar-1.29/gnu/allocator.h"
struct allocator  const  stdlib_allocator ;
#line 63 "/home/khheo/project/benchmark/tar-1.29/gnu/careadlinkat.c"
char *careadlinkat(int fd , char const   *filename , char *buffer___1 , size_t buffer_size ,
                   struct allocator  const  *alloc , ssize_t (*preadlinkat)(int  ,
                                                                            char const   * ,
                                                                            char * ,
                                                                            size_t  ) ) 
{ 
  char *buf ;
  size_t buf_size ;
  size_t buf_size_max ;
  char stack_buf[1024] ;
  ssize_t link_length ;
  ssize_t tmp ;
  size_t link_size ;
  int readlinkat_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  size_t tmp___2 ;
  char *b ;
  void *tmp___3 ;
  char *b___0 ;
  void *tmp___4 ;
  int *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;

  {
#line 71
  buf_size_max = 0x8000000000000000UL;
#line 75
  if (! alloc) {
#line 76
    alloc = & stdlib_allocator;
  }
#line 78
  if (! buffer_size) {
#line 84
    buffer___1 = stack_buf;
#line 85
    buffer_size = sizeof(stack_buf);
  }
#line 88
  buf = buffer___1;
#line 89
  buf_size = buffer_size;
  {
#line 91
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    tmp = (*preadlinkat)(fd, filename, buf, buf_size);
#line 94
    link_length = tmp;
    }
#line 96
    if (link_length < 0L) {
      {
#line 100
      tmp___0 = __errno_location();
#line 100
      readlinkat_errno = *tmp___0;
      }
#line 101
      if (readlinkat_errno != 34) {
#line 103
        if ((unsigned long )buf != (unsigned long )buffer___1) {
          {
#line 105
          (*(alloc->free))((void *)buf);
#line 106
          tmp___1 = __errno_location();
#line 106
          *tmp___1 = readlinkat_errno;
          }
        }
#line 108
        return ((char *)((void *)0));
      }
    }
#line 112
    link_size = (size_t )link_length;
#line 114
    if (link_size < buf_size) {
#line 116
      tmp___2 = link_size;
#line 116
      link_size ++;
#line 116
      *(buf + tmp___2) = (char )'\000';
#line 118
      if ((unsigned long )buf == (unsigned long )(stack_buf)) {
        {
#line 120
        tmp___3 = (*(alloc->allocate))(link_size);
#line 120
        b = (char *)tmp___3;
#line 121
        buf_size = link_size;
        }
#line 122
        if (! b) {
#line 123
          goto while_break;
        }
        {
#line 124
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)buf, link_size);
#line 125
        buf = b;
        }
      } else
#line 127
      if (link_size < buf_size) {
#line 127
        if ((unsigned long )buf != (unsigned long )buffer___1) {
#line 127
          if (alloc->reallocate) {
            {
#line 130
            tmp___4 = (*(alloc->reallocate))((void *)buf, link_size);
#line 130
            b___0 = (char *)tmp___4;
            }
#line 131
            if (b___0) {
#line 132
              buf = b___0;
            }
          }
        }
      }
#line 135
      return (buf);
    }
#line 138
    if ((unsigned long )buf != (unsigned long )buffer___1) {
      {
#line 139
      (*(alloc->free))((void *)buf);
      }
    }
#line 141
    if (buf_size <= buf_size_max / 2UL) {
#line 142
      buf_size *= 2UL;
    } else
#line 143
    if (buf_size < buf_size_max) {
#line 144
      buf_size = buf_size_max;
    } else
#line 145
    if (buf_size_max < 0xffffffffffffffffUL) {
      {
#line 147
      tmp___5 = __errno_location();
#line 147
      *tmp___5 = 36;
      }
#line 148
      return ((char *)((void *)0));
    } else {
#line 151
      goto while_break;
    }
    {
#line 152
    tmp___6 = (*(alloc->allocate))(buf_size);
#line 152
    buf = (char *)tmp___6;
    }
#line 91
    if (! buf) {
#line 91
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  if (alloc->die) {
    {
#line 157
    (*(alloc->die))(buf_size);
    }
  }
  {
#line 158
  tmp___7 = __errno_location();
#line 158
  *tmp___7 = 12;
  }
#line 159
  return ((char *)((void *)0));
}
}
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/bitrotate.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 134
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/tar-1.29/gnu/dirname.h"
char *base_name(char const   *name ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
  {
#line 30
  tmp = last_component(name);
#line 30
  base = (char const   *)tmp;
  }
#line 35
  if (! *base) {
    {
#line 36
    tmp___0 = base_len(name);
#line 36
    tmp___1 = xstrndup(name, tmp___0);
    }
#line 36
    return (tmp___1);
  }
  {
#line 39
  length = base_len(base);
  }
#line 40
  if ((int const   )*(base + length) == 47) {
#line 41
    length ++;
  }
  {
#line 57
  tmp___3 = xstrndup(base, length);
  }
#line 57
  return (tmp___3);
}
}
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/basename-lgpl.c"
char *last_component(char const   *name )  __attribute__((__pure__)) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((int const   )*base == 47)) {
#line 36
      goto while_break;
    }
#line 37
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 39
  p = base;
  {
#line 39
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 39
    if (! *p) {
#line 39
      goto while_break___0;
    }
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 50
  return ((char *)base);
}
}
#line 57
size_t base_len(char const   *name )  __attribute__((__pure__)) ;
#line 57 "/home/khheo/project/benchmark/tar-1.29/gnu/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        goto while_break;
      }
    } else {
#line 63
      goto while_break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return (len);
}
}
#line 47 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 56 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.h"
void (*argmatch_die)(void) ;
#line 83
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg___0 , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 615 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 83 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 91 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ 
  char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;

  {
  {
#line 94
  tmp = last_component((char const   *)file);
#line 94
  base = tmp;
#line 95
  tmp___0 = base_len((char const   *)base);
#line 95
  baselen = tmp___0;
#line 96
  baselen_max = (size_t )255;
  }
#line 98
  if (14UL < baselen) {
    {
#line 106
    memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
           sizeof("."));
#line 107
    strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 108
    tmp___2 = __errno_location();
#line 108
    *tmp___2 = 0;
#line 109
    name_max = pathconf((char const   *)file, 3);
    }
#line 110
    if (0L <= name_max) {
#line 110
      goto _L;
    } else {
      {
#line 110
      tmp___3 = __errno_location();
      }
#line 110
      if (*tmp___3 == 0) {
        _L: /* CIL Label */ 
#line 112
        baselen_max = (size_t )name_max;
#line 112
        size = (long )baselen_max;
#line 113
        if (name_max != size) {
#line 114
          baselen_max = (size_t )-1;
        }
      }
    }
    {
#line 116
    memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
           sizeof("."));
    }
  }
#line 134
  if (baselen_max < baselen) {
#line 136
    baselen = (size_t )((file + filelen) - base);
#line 137
    if (baselen_max <= baselen) {
#line 138
      baselen = baselen_max - 1UL;
    }
#line 139
    *(base + baselen) = e;
#line 140
    *(base + (baselen + 1UL)) = (char )'\000';
  }
#line 142
  return;
}
}
#line 171 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer___1 , size_t buffer_size ,
                                                   size_t filelen ) 
{ 
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 174
  result = (enum numbered_backup_result )2;
#line 177
  buf = *buffer___1;
#line 178
  versionlenmax = (size_t )1;
#line 179
  tmp = last_component((char const   *)buf);
#line 179
  base = tmp;
#line 180
  base_offset = (size_t )(base - buf);
#line 181
  tmp___0 = base_len((char const   *)base);
#line 181
  baselen = tmp___0;
#line 186
  memcpy((void */* __restrict  */)(tmp___1), (void const   */* __restrict  */)base,
         sizeof("."));
#line 187
  strcpy((char */* __restrict  */)base, (char const   */* __restrict  */)".");
#line 188
  dirp = opendir_safer((char const   *)buf);
#line 189
  memcpy((void */* __restrict  */)base, (void const   */* __restrict  */)(tmp___1),
         sizeof("."));
#line 190
  strcpy((char */* __restrict  */)(base + baselen), (char const   */* __restrict  */)".~1~");
  }
#line 192
  if (! dirp) {
#line 193
    return (result);
  }
  {
#line 195
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 195
    dp = readdir(dirp);
    }
#line 195
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 195
      goto while_break;
    }
#line 203
    if (! (dp->d_ino != 0UL)) {
#line 204
      goto while_continue;
    } else {
      {
#line 203
      tmp___2 = strlen((char const   *)(dp->d_name));
      }
#line 203
      if (tmp___2 < baselen + 4UL) {
#line 204
        goto while_continue;
      }
    }
    {
#line 206
    tmp___3 = memcmp((void const   *)(buf + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
    }
#line 206
    if (tmp___3 != 0) {
#line 207
      goto while_continue;
    }
#line 209
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 215
    if (49 <= (int )*p) {
#line 215
      if (! ((int const   )*p <= 57)) {
#line 216
        goto while_continue;
      }
    } else {
#line 216
      goto while_continue;
    }
#line 217
    all_9s = (_Bool )((int const   )*p == 57);
#line 218
    versionlen = (size_t )1;
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! ((unsigned int )*(p + versionlen) - 48U <= 9U)) {
#line 218
        goto while_break___0;
      }
#line 219
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 218
      versionlen ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 221
    if ((int const   )*(p + versionlen) == 126) {
#line 221
      if (! *(p + (versionlen + 1UL))) {
#line 221
        if (! (versionlenmax < versionlen)) {
#line 221
          if (versionlenmax == versionlen) {
            {
#line 221
            tmp___4 = memcmp((void const   *)((buf + filelen) + 2), (void const   *)p,
                             versionlen);
            }
#line 221
            if (! (tmp___4 <= 0)) {
#line 225
              goto while_continue;
            }
          } else {
#line 225
            goto while_continue;
          }
        }
      } else {
#line 225
        goto while_continue;
      }
    } else {
#line 225
      goto while_continue;
    }
#line 231
    versionlenmax = (size_t )all_9s + versionlen;
#line 232
    if (all_9s) {
#line 232
      result = (enum numbered_backup_result )1;
    } else {
#line 232
      result = (enum numbered_backup_result )0;
    }
#line 233
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 234
    if (buffer_size <= new_buflen) {
      {
#line 236
      tmp___5 = xnrealloc((void *)buf, (size_t )2, new_buflen);
#line 236
      buf = (char *)tmp___5;
#line 237
      buffer_size = new_buflen * 2UL;
      }
    }
    {
#line 239
    q = buf + filelen;
#line 240
    tmp___6 = q;
#line 240
    q ++;
#line 240
    *tmp___6 = (char )'.';
#line 241
    tmp___7 = q;
#line 241
    q ++;
#line 241
    *tmp___7 = (char )'~';
#line 242
    *q = (char )'0';
#line 243
    q += (int )all_9s;
#line 244
    memcpy((void */* __restrict  */)q, (void const   */* __restrict  */)p, versionlen + 2UL);
#line 248
    q += versionlen;
    }
    {
#line 249
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 249
      q --;
#line 249
      if (! ((int )*q == 57)) {
#line 249
        goto while_break___1;
      }
#line 250
      *q = (char )'0';
    }
    while_break___1: /* CIL Label */ ;
    }
#line 251
    *q = (char )((int )*q + 1);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  closedir(dirp);
#line 255
  *buffer___1 = buf;
  }
#line 256
  return (result);
}
}
#line 263 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type___0 ) 
{ 
  size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;

  {
  {
#line 266
  tmp = strlen(file);
#line 266
  filelen = tmp;
#line 269
  simple = (_Bool)1;
#line 273
  tmp___0 = strlen(simple_backup_suffix);
#line 273
  simple_backup_suffix_size = tmp___0 + 1UL;
#line 274
  backup_suffix_size_guess = simple_backup_suffix_size;
  }
#line 276
  if (backup_suffix_size_guess < 9UL) {
#line 277
    backup_suffix_size_guess = (size_t )9;
  }
  {
#line 279
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
#line 280
  tmp___1 = xmalloc(ssize);
#line 280
  s = (char *)tmp___1;
#line 281
  memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)file, filelen + 1UL);
  }
#line 283
  if ((unsigned int )backup_type___0 != 1U) {
    {
#line 284
    tmp___2 = numbered_backup(& s, ssize, filelen);
    }
    {
#line 286
    if ((unsigned int )tmp___2 == 0U) {
#line 286
      goto case_0;
    }
#line 289
    if ((unsigned int )tmp___2 == 1U) {
#line 289
      goto case_1;
    }
#line 293
    if ((unsigned int )tmp___2 == 2U) {
#line 293
      goto case_2;
    }
#line 284
    goto switch_break;
    case_0: /* CIL Label */ 
#line 287
    return (s);
    case_1: /* CIL Label */ 
#line 290
    simple = (_Bool)0;
#line 291
    goto switch_break;
    case_2: /* CIL Label */ 
#line 294
    simple = (_Bool )((unsigned int )backup_type___0 == 2U);
#line 295
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 298
  if (simple) {
    {
#line 299
    memcpy((void */* __restrict  */)(s + filelen), (void const   */* __restrict  */)simple_backup_suffix,
           simple_backup_suffix_size);
    }
  }
  {
#line 300
  check_extension(s, filelen, (char )'~');
  }
#line 301
  return (s);
}
}
#line 304 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
static char const   * const  backup_args[9]  = 
#line 304
  {      (char const   */* const  */)"none",      (char const   */* const  */)"off",      (char const   */* const  */)"simple",      (char const   */* const  */)"never", 
        (char const   */* const  */)"existing",      (char const   */* const  */)"nil",      (char const   */* const  */)"numbered",      (char const   */* const  */)"t", 
        (char const   */* const  */)((void *)0)};
#line 315 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 315
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 332 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ 
  ptrdiff_t tmp ;

  {
#line 335
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 336
    return ((enum backup_type )2);
  } else
#line 335
  if ((int const   )*version == 0) {
#line 336
    return ((enum backup_type )2);
  } else {
    {
#line 338
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               sizeof(backup_types[0]), argmatch_die);
    }
#line 338
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 348 "/home/khheo/project/benchmark/tar-1.29/gnu/backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ 
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;

  {
#line 351
  if (version) {
#line 351
    if (*version) {
      {
#line 352
      tmp = get_version(context, version);
      }
#line 352
      return (tmp);
    } else {
      {
#line 354
      tmp___0 = getenv("VERSION_CONTROL");
#line 354
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
      }
#line 354
      return (tmp___1);
    }
  } else {
    {
#line 354
    tmp___0 = getenv("VERSION_CONTROL");
#line 354
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
    }
#line 354
    return (tmp___1);
  }
}
}
#line 70 "/home/khheo/project/benchmark/tar-1.29/gnu/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args___0 ;
  char *result ;

  {
  {
#line 30
  __builtin_va_start(args___0, format);
#line 31
  result = vasnprintf(resultbuf, lengthp, format, args___0);
#line 32
  __builtin_va_end(args___0);
  }
#line 33
  return (result);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 390 "/usr/include/x86_64-linux-gnu/bits/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 391
extern int __overflow(_IO_FILE * , int  ) ;
#line 433
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 434
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 327 "/usr/include/stdio.h"
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 333
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) ;
#line 484
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) ;
#line 496
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) ;
#line 506
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) ;
#line 524
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) ;
#line 537
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) ;
#line 545
__inline extern int ( __attribute__((__gnu_inline__)) putc_unlocked)(int __c , FILE *__stream ) ;
#line 546
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) ;
#line 603
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
#line 616
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 766
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                               __gnuc_va_list __arg ) 
{ 
  int tmp ;

  {
  {
#line 38
  tmp = vfprintf((FILE */* __restrict  */)stdout, __fmt, __arg);
  }
#line 38
  return (tmp);
}
}
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar)(void) 
{ 
  int tmp ;

  {
  {
#line 46
  tmp = _IO_getc(stdin);
  }
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fgetc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 55
  if (tmp___3) {
    {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
    }
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 62 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
extern int ( __attribute__((__gnu_inline__)) getc_unlocked)(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 65
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
  }
#line 65
  if (tmp___3) {
    {
#line 65
    tmp___0 = __uflow(__fp);
#line 65
    tmp___2 = tmp___0;
    }
  } else {
#line 65
    tmp___1 = __fp->_IO_read_ptr;
#line 65
    (__fp->_IO_read_ptr) ++;
#line 65
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 65
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) getchar_unlocked)(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
  }
#line 72
  if (tmp___3) {
    {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
    }
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar)(int __c ) 
{ 
  int tmp ;

  {
  {
#line 81
  tmp = _IO_putc(__c, stdout);
  }
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) fputc_unlocked)(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
  }
#line 90
  if (tmp___4) {
    {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
    }
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__gnu_inline__)) putchar_unlocked)(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
  }
#line 107
  if (tmp___4) {
    {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
    }
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern __ssize_t ( __attribute__((__gnu_inline__)) getline)(char ** __restrict  __lineptr ,
                                                                     size_t * __restrict  __n ,
                                                                     FILE * __restrict  __stream ) 
{ 
  __ssize_t tmp ;

  {
  {
#line 117
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  }
#line 117
  return (tmp);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__leaf__, __gnu_inline__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
extern int ( __attribute__((__leaf__, __gnu_inline__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 73 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__,
__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 74
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__,
__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 75
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__leaf__, __gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                                   unsigned int __minor )  __attribute__((__const__)) ;
#line 79
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__,
__gnu_inline__)) gnu_dev_major)(__dev_t __dev )  __attribute__((__const__)) ;
#line 79 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__, __gnu_inline__)) gnu_dev_major)(__dev_t __dev ) 
{ 
  unsigned int __major ;

  {
#line 79
  __major = (unsigned int )((__dev & 1048320UL) >> 8);
#line 79
  __major = (unsigned int )((unsigned long )__major | ((__dev & 0xfffff00000000000UL) >> 32));
#line 79
  return (__major);
}
}
#line 80
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__,
__gnu_inline__)) gnu_dev_minor)(__dev_t __dev )  __attribute__((__const__)) ;
#line 80 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__, __gnu_inline__)) gnu_dev_minor)(__dev_t __dev ) 
{ 
  unsigned int __minor ;

  {
#line 80
  __minor = (unsigned int )(__dev & 255UL);
#line 80
  __minor = (unsigned int )((unsigned long )__minor | ((__dev & 17592184995840UL) >> 12));
#line 80
  return (__minor);
}
}
#line 81
__inline extern  __attribute__((__nothrow__)) __dev_t ( __attribute__((__leaf__, __gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                                   unsigned int __minor )  __attribute__((__const__)) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern __dev_t ( __attribute__((__leaf__, __gnu_inline__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                     unsigned int __minor ) 
{ 
  __dev_t __dev ;

  {
#line 81
  __dev = (__dev_t )(__major & 4095U) << 8;
#line 81
  __dev |= (__dev_t )(__major & 4294963200U) << 32;
#line 81
  __dev |= (__dev_t )(__minor & 255U);
#line 81
  __dev |= (__dev_t )(__minor & 4294967040U) << 12;
#line 81
  return (__dev);
}
}
#line 81 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 83
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__const__)) ;
#line 206
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c ) ;
#line 206 "/usr/include/ctype.h"
extern int ( __attribute__((__leaf__, __gnu_inline__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 209
  if (__c >= -128) {
#line 209
    if (__c < 256) {
      {
#line 209
      tmp = __ctype_tolower_loc();
#line 209
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 209
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 209
    tmp___0 = (__int32_t const   )__c;
  }
#line 209
  return ((int )tmp___0);
}
}
#line 212
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c ) ;
#line 212 "/usr/include/ctype.h"
extern int ( __attribute__((__leaf__, __gnu_inline__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 215
  if (__c >= -128) {
#line 215
    if (__c < 256) {
      {
#line 215
      tmp = __ctype_toupper_loc();
#line 215
      tmp___0 = *(*tmp + __c);
      }
    } else {
#line 215
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 215
    tmp___0 = (__int32_t const   )__c;
  }
#line 215
  return ((int )tmp___0);
}
}
#line 515 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) ;
#line 585
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 616 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
__inline void argp_usage(struct argp_state  const  *__state ) 
{ 


  {
  {
#line 619
  argp_state_help((struct argp_state  const  */* __restrict  */)__state, (FILE */* __restrict  */)stderr,
                  262U);
  }
#line 620
  return;
}
}
#line 622
__inline  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) _option_is_short)(struct argp_option  const  *__opt ) ;
#line 622 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
__inline int ( __attribute__((__leaf__)) _option_is_short)(struct argp_option  const  *__opt ) 
{ 
  int __key ;
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
#line 625
  if (__opt->flags & 8) {
#line 626
    return (0);
  } else {
#line 629
    __key = (int )__opt->key;
#line 630
    if (__key > 0) {
#line 630
      if (__key <= 255) {
        {
#line 630
        tmp = __ctype_b_loc();
        }
#line 630
        if ((int const   )*(*tmp + __key) & 16384) {
#line 630
          tmp___0 = 1;
        } else {
#line 630
          tmp___0 = 0;
        }
      } else {
#line 630
        tmp___0 = 0;
      }
    } else {
#line 630
      tmp___0 = 0;
    }
#line 630
    return (tmp___0);
  }
}
}
#line 634
__inline  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) _option_is_end)(struct argp_option  const  *__opt ) ;
#line 634 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
__inline int ( __attribute__((__leaf__)) _option_is_end)(struct argp_option  const  *__opt ) 
{ 
  int tmp ;

  {
#line 637
  if (! __opt->key) {
#line 637
    if (! __opt->name) {
#line 637
      if (! __opt->doc) {
#line 637
        if (! __opt->group) {
#line 637
          tmp = 1;
        } else {
#line 637
          tmp = 0;
        }
      } else {
#line 637
        tmp = 0;
      }
    } else {
#line 637
      tmp = 0;
    }
  } else {
#line 637
    tmp = 0;
  }
#line 637
  return (tmp);
}
}
#line 645
#pragma GCC diagnostic pop
#line 451 "./argp.h"
void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ) ;
#line 585
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 34 "./argp-version-etc.h"
void argp_version_setup(char const   *name , char const   * const  *authors ) ;
#line 22 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-version-etc.c"
static char const   *program_canonical_name  ;
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-version-etc.c"
static char const   * const  *program_authors  ;
#line 25 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-version-etc.c"
static void version_etc_hook(FILE *stream , struct argp_state *state ) 
{ 


  {
  {
#line 28
  version_etc_ar(stream, program_canonical_name, "GNU tar", "1.29", program_authors);
  }
#line 30
  return;
}
}
#line 32 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-version-etc.c"
void argp_version_setup(char const   *name , char const   * const  *authors ) 
{ 


  {
#line 35
  argp_program_version_hook = (void (*)(FILE * __restrict  __stream , struct argp_state * __restrict  __state ))(& version_etc_hook);
#line 36
  program_canonical_name = name;
#line 37
  program_authors = authors;
#line 38
  return;
}
}
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-pv.c"
char const   *argp_program_version  ;
#line 585 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-pvh.c"
void (*argp_program_version_hook)(FILE * __restrict  __stream , struct argp_state * __restrict  __state )  =    (void (*)(FILE * __restrict  stream ,
             struct argp_state * __restrict  state ))((void *)0);
#line 104 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 447 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 44 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dgettext)(char const   *__domainname ,
                                                                                 char const   *__msgid )  __attribute__((__format_arg__(2))) ;
#line 415 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input ) ;
#line 531
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) ;
#line 568
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) _argp_input)(struct argp  const  * __restrict  argp___0 ,
                                                                             struct argp_state  const  * __restrict  state ) ;
#line 585
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 73 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static int volatile   _argp_hang  ;
#line 79 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static struct argp_option  const  argp_default_options[5]  = {      {"help", '?', (char const   *)0, 0, "give this help list", -1}, 
        {"usage", -3, (char const   *)0, 0, "give a short usage message", 0}, 
        {"program-name", -2, "NAME", 2, "set the program name", 0}, 
        {"HANG", -4, "SECS", 3, "hang for SECS seconds (default 3600)", 0}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 89 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t argp_default_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char const   *tmp ;
  int tmp___0 ;
  int volatile   tmp___1 ;

  {
  {
#line 94
  if (key == 63) {
#line 94
    goto case_63;
  }
#line 97
  if (key == -3) {
#line 97
    goto case_neg_3;
  }
#line 102
  if (key == -2) {
#line 102
    goto case_neg_2;
  }
#line 124
  if (key == -4) {
#line 124
    goto case_neg_4;
  }
#line 130
  goto switch_default;
  case_63: /* CIL Label */ 
  {
#line 95
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  634U);
  }
#line 96
  goto switch_break;
  case_neg_3: /* CIL Label */ 
  {
#line 98
  argp_state_help((struct argp_state  const  */* __restrict  */)state, (FILE */* __restrict  */)state->out_stream,
                  513U);
  }
#line 100
  goto switch_break;
  case_neg_2: /* CIL Label */ 
  {
#line 104
  program_invocation_name = arg___0;
#line 111
  state->name = last_component((char const   *)arg___0);
#line 114
  program_invocation_short_name = state->name;
  }
#line 117
  if ((state->flags & 3U) == 1U) {
#line 120
    *(state->argv + 0) = arg___0;
  }
#line 122
  goto switch_break;
  case_neg_4: /* CIL Label */ 
#line 125
  if (arg___0) {
#line 125
    tmp = (char const   *)arg___0;
  } else {
#line 125
    tmp = "3600";
  }
  {
#line 125
  tmp___0 = atoi(tmp);
#line 125
  _argp_hang = (int volatile   )tmp___0;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    tmp___1 = _argp_hang;
#line 126
    _argp_hang -= (int volatile   )1;
#line 126
    if (! (tmp___1 > (int volatile   )0)) {
#line 126
      goto while_break;
    }
    {
#line 127
    sleep(1U);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 131
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 133
  return (0);
}
}
#line 136 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static struct argp  const  argp_default_argp  =    {argp_default_options, & argp_default_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 140 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static struct argp_option  const  argp_version_options[2]  = {      {"version", 'V', (char const   *)0, 0, "print program version", -1}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)((void *)0),
      0}};
#line 146 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t argp_version_parser(int key , char *arg___0 , struct argp_state *state ) 
{ 
  char *tmp ;

  {
  {
#line 151
  if (key == 86) {
#line 151
    goto case_86;
  }
#line 163
  goto switch_default;
  case_86: /* CIL Label */ 
#line 152
  if (argp_program_version_hook) {
    {
#line 153
    (*argp_program_version_hook)((FILE */* __restrict  */)state->out_stream, (struct argp_state */* __restrict  */)state);
    }
  } else
#line 154
  if (argp_program_version) {
    {
#line 155
    fprintf((FILE */* __restrict  */)state->out_stream, (char const   */* __restrict  */)"%s\n",
            argp_program_version);
    }
  } else {
    {
#line 157
    tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "(PROGRAM ERROR) No version known!?");
#line 157
    argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)"%s",
               tmp);
    }
  }
#line 160
  if (! (state->flags & 32U)) {
    {
#line 161
    exit(0);
    }
  }
#line 162
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 164
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 166
  return (0);
}
}
#line 169 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static struct argp  const  argp_version_argp  =    {argp_version_options, & argp_version_parser, (char const   *)((void *)0), (char const   *)((void *)0),
    (struct argp_child  const  *)((void *)0), (char *(*)(int __key , char const   *__text ,
                                                         void *__input ))((void *)0),
    "libc"};
#line 175 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static int find_long_option(struct rpl_option *long_options , char const   *name ) 
{ 
  struct rpl_option *l ;
  int tmp ;

  {
#line 178
  l = long_options;
  {
#line 179
  while (1) {
    while_continue: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )l->name != (unsigned long )((void *)0))) {
#line 179
      goto while_break;
    }
#line 180
    if ((unsigned long )name != (unsigned long )((void *)0)) {
      {
#line 180
      tmp = strcmp(l->name, name);
      }
#line 180
      if (tmp == 0) {
#line 181
        return ((int )(l - long_options));
      } else {
#line 183
        l ++;
      }
    } else {
#line 183
      l ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 185
    return ((int )(l - long_options));
  } else {
#line 187
    return (-1);
  }
}
}
#line 223 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t group_parse(struct group *group , struct argp_state *state , int key ,
                           char *arg___0 ) 
{ 
  error_t err ;

  {
#line 226
  if (group->parser) {
    {
#line 229
    state->hook = group->hook;
#line 230
    state->input = group->input;
#line 231
    state->child_inputs = group->child_inputs;
#line 232
    state->arg_num = group->args_processed;
#line 233
    err = (*(group->parser))(key, arg___0, state);
#line 234
    group->hook = state->hook;
    }
#line 235
    return (err);
  } else {
#line 238
    return (7);
  }
}
}
#line 288 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static struct group *convert_options(struct argp  const  *argp___0 , struct group *parent ,
                                     unsigned int parent_index , struct group *group ,
                                     struct parser_convert_state *cvt ) 
{ 
  struct argp_option  const  *real ;
  struct argp_child  const  *children ;
  struct argp_option  const  *opt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned int num_children ;
  struct group *tmp___7 ;
  unsigned int index___0 ;
  unsigned int tmp___8 ;
  struct argp_child  const  *tmp___9 ;

  {
#line 294
  real = (struct argp_option  const  *)argp___0->options;
#line 295
  children = (struct argp_child  const  *)argp___0->children;
#line 297
  if (real) {
#line 297
    goto _L;
  } else
#line 297
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 301
    if (real) {
#line 302
      opt = real;
      {
#line 302
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 302
        tmp___6 = _option_is_end(opt);
        }
#line 302
        if (tmp___6) {
#line 302
          goto while_break;
        }
#line 304
        if (! (opt->flags & 4)) {
#line 306
          real = opt;
        }
#line 308
        if (! (real->flags & 8)) {
          {
#line 311
          tmp___2 = _option_is_short(opt);
          }
#line 311
          if (tmp___2) {
#line 314
            tmp = cvt->short_end;
#line 314
            (cvt->short_end) ++;
#line 314
            *tmp = (char )opt->key;
#line 315
            if (real->arg) {
#line 317
              tmp___0 = cvt->short_end;
#line 317
              (cvt->short_end) ++;
#line 317
              *tmp___0 = (char )':';
#line 318
              if (real->flags & 1) {
#line 319
                tmp___1 = cvt->short_end;
#line 319
                (cvt->short_end) ++;
#line 319
                *tmp___1 = (char )':';
              }
            }
#line 321
            *(cvt->short_end) = (char )'\000';
          }
#line 324
          if (opt->name) {
            {
#line 324
            tmp___5 = find_long_option((cvt->parser)->long_opts, (char const   *)opt->name);
            }
#line 324
            if (tmp___5 < 0) {
#line 328
              (cvt->long_end)->name = (char const   *)opt->name;
#line 329
              if (real->arg) {
#line 329
                if (real->flags & 1) {
#line 329
                  tmp___3 = 2;
                } else {
#line 329
                  tmp___3 = 1;
                }
#line 329
                (cvt->long_end)->has_arg = tmp___3;
              } else {
#line 329
                (cvt->long_end)->has_arg = 0;
              }
#line 335
              (cvt->long_end)->flag = (int *)0;
#line 342
              if (opt->key) {
#line 342
                tmp___4 = opt->key;
              } else {
#line 342
                tmp___4 = real->key;
              }
#line 342
              (cvt->long_end)->val = (int )((long )(tmp___4 & (int const   )((1 << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)) - 1)) + (((group - (cvt->parser)->groups) + 1L) << (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL)));
#line 347
              (cvt->long_end) ++;
#line 347
              (cvt->long_end)->name = (char const   *)((void *)0);
            }
          }
        }
#line 302
        opt ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 352
    group->parser = (error_t (*)(int key , char *arg , struct argp_state *state ))argp___0->parser;
#line 353
    group->argp = argp___0;
#line 354
    group->short_end = cvt->short_end;
#line 355
    group->args_processed = 0U;
#line 356
    group->parent = parent;
#line 357
    group->parent_index = parent_index;
#line 358
    group->input = (void *)0;
#line 359
    group->hook = (void *)0;
#line 360
    group->child_inputs = (void **)0;
#line 362
    if (children) {
#line 366
      num_children = 0U;
      {
#line 367
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 367
        if (! (children + num_children)->argp) {
#line 367
          goto while_break___0;
        }
#line 368
        num_children ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 369
      group->child_inputs = cvt->child_inputs_end;
#line 370
      cvt->child_inputs_end += num_children;
    }
#line 373
    tmp___7 = group;
#line 373
    group ++;
#line 373
    parent = tmp___7;
  } else {
#line 376
    parent = (struct group *)0;
  }
#line 378
  if (children) {
#line 380
    index___0 = 0U;
    {
#line 381
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 381
      if (! children->argp) {
#line 381
        goto while_break___1;
      }
      {
#line 382
      tmp___8 = index___0;
#line 382
      index___0 ++;
#line 382
      tmp___9 = children;
#line 382
      children ++;
#line 382
      group = convert_options((struct argp  const  *)tmp___9->argp, parent, tmp___8,
                              group, cvt);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 386
  return (group);
}
}
#line 390 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static void parser_convert(struct parser *parser , struct argp  const  *argp___0 ,
                           int flags ) 
{ 
  struct parser_convert_state cvt ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 395
  cvt.parser = parser;
#line 396
  cvt.short_end = parser->short_opts;
#line 397
  cvt.long_end = parser->long_opts;
#line 398
  cvt.child_inputs_end = parser->child_inputs;
#line 400
  if (flags & 8) {
#line 401
    tmp = cvt.short_end;
#line 401
    (cvt.short_end) ++;
#line 401
    *tmp = (char )'-';
  } else
#line 402
  if (flags & 4) {
#line 403
    tmp___0 = cvt.short_end;
#line 403
    (cvt.short_end) ++;
#line 403
    *tmp___0 = (char )'+';
  }
#line 404
  *(cvt.short_end) = (char )'\000';
#line 406
  (cvt.long_end)->name = (char const   *)((void *)0);
#line 408
  parser->argp = argp___0;
#line 410
  if (argp___0) {
    {
#line 411
    parser->egroup = convert_options(argp___0, (struct group *)0, 0U, parser->groups,
                                     & cvt);
    }
  } else {
#line 413
    parser->egroup = parser->groups;
  }
#line 414
  return;
}
}
#line 429 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static void calc_sizes(struct argp  const  *argp___0 , struct parser_sizes *szs ) 
{ 
  struct argp_child  const  *child ;
  struct argp_option  const  *opt ;
  int num_opts ;
  struct argp_option  const  *tmp ;
  int tmp___0 ;
  struct argp_child  const  *tmp___1 ;

  {
#line 432
  child = (struct argp_child  const  *)argp___0->children;
#line 433
  opt = (struct argp_option  const  *)argp___0->options;
#line 435
  if (opt) {
#line 435
    goto _L;
  } else
#line 435
  if (argp___0->parser) {
    _L: /* CIL Label */ 
#line 437
    (szs->num_groups) ++;
#line 438
    if (opt) {
#line 440
      num_opts = 0;
      {
#line 441
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 441
        tmp = opt;
#line 441
        opt ++;
#line 441
        tmp___0 = _option_is_end(tmp);
        }
#line 441
        if (tmp___0) {
#line 441
          goto while_break;
        }
#line 442
        num_opts ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 443
      szs->short_len += (size_t )(num_opts * 3);
#line 444
      szs->long_len += (size_t )num_opts;
    }
  }
#line 448
  if (child) {
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! child->argp) {
#line 449
        goto while_break___0;
      }
      {
#line 451
      tmp___1 = child;
#line 451
      child ++;
#line 451
      calc_sizes((struct argp  const  *)tmp___1->argp, szs);
#line 452
      (szs->num_child_inputs) ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 454
  return;
}
}
#line 457 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t parser_init(struct parser *parser , struct argp  const  *argp___0 ,
                           int argc , char **argv , int flags , void *input ) 
{ 
  error_t err ;
  struct group *group ;
  struct parser_sizes szs ;
  struct _getopt_data opt_data ;
  char *storage ;
  size_t glen ;
  size_t gsum ;
  size_t clen ;
  size_t csum ;
  size_t llen ;
  size_t lsum ;
  size_t slen ;
  size_t ssum ;

  {
#line 461
  err = 0;
#line 464
  opt_data.rpl_optind = 1;
#line 464
  opt_data.rpl_opterr = 1;
#line 464
  opt_data.rpl_optopt = 0;
#line 464
  opt_data.rpl_optarg = (char *)0;
#line 464
  opt_data.__initialized = 0;
#line 464
  opt_data.__nextchar = (char *)0;
#line 464
  opt_data.__ordering = 0U;
#line 464
  opt_data.__posixly_correct = 0;
#line 464
  opt_data.__first_nonopt = 0;
#line 464
  opt_data.__last_nonopt = 0;
#line 471
  if (flags & 4) {
#line 471
    szs.short_len = (size_t )0;
  } else {
#line 471
    szs.short_len = (size_t )1;
  }
#line 472
  szs.long_len = (size_t )0;
#line 473
  szs.num_groups = (size_t )0;
#line 474
  szs.num_child_inputs = (size_t )0;
#line 476
  if (argp___0) {
    {
#line 477
    calc_sizes(argp___0, & szs);
    }
  }
  {
#line 480
  glen = (szs.num_groups + 1UL) * sizeof(struct group );
#line 481
  clen = szs.num_child_inputs * sizeof(void *);
#line 482
  llen = (szs.long_len + 1UL) * sizeof(struct rpl_option );
#line 483
  slen = szs.short_len + 1UL;
#line 490
  gsum = glen;
#line 491
  csum = ((((gsum + clen) + __alignof__(struct rpl_option )) - 1UL) / __alignof__(struct rpl_option )) * __alignof__(struct rpl_option );
#line 492
  lsum = csum + llen;
#line 493
  ssum = lsum + slen;
#line 495
  parser->storage = malloc(ssum);
  }
#line 496
  if (! parser->storage) {
#line 497
    return (12);
  }
  {
#line 499
  storage = (char *)parser->storage;
#line 500
  parser->groups = (struct group *)parser->storage;
#line 501
  parser->child_inputs = (void **)(storage + gsum);
#line 502
  parser->long_opts = (struct rpl_option *)(storage + csum);
#line 503
  parser->short_opts = storage + lsum;
#line 504
  parser->opt_data = opt_data;
#line 506
  memset((void *)parser->child_inputs, 0, clen);
#line 507
  parser_convert(parser, argp___0, flags);
#line 509
  memset((void *)(& parser->state), 0, sizeof(struct argp_state ));
#line 510
  parser->state.root_argp = parser->argp;
#line 511
  parser->state.argc = argc;
#line 512
  parser->state.argv = argv;
#line 513
  parser->state.flags = (unsigned int )flags;
#line 514
  parser->state.err_stream = stderr;
#line 515
  parser->state.out_stream = stdout;
#line 516
  parser->state.next = 0;
#line 517
  parser->state.pstate = (void *)parser;
#line 519
  parser->try_getopt = 1;
  }
#line 523
  if ((unsigned long )parser->groups < (unsigned long )parser->egroup) {
#line 524
    (parser->groups)->input = input;
  }
#line 525
  group = parser->groups;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 525
      if (! (! err)) {
#line 525
        if (! (err == 7)) {
#line 525
          goto while_break;
        }
      }
    } else {
#line 525
      goto while_break;
    }
#line 529
    if (group->parent) {
#line 531
      group->input = *((group->parent)->child_inputs + group->parent_index);
    }
#line 533
    if (! group->parser) {
#line 533
      if ((group->argp)->children) {
#line 533
        if (((group->argp)->children)->argp) {
#line 538
          *(group->child_inputs + 0) = group->input;
        }
      }
    }
    {
#line 540
    err = group_parse(group, & parser->state, 16777219, (char *)0);
#line 525
    group ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  if (err == 7) {
#line 543
    err = 0;
  }
#line 545
  if (err) {
#line 546
    return (err);
  }
#line 548
  if (parser->state.flags & 2U) {
#line 550
    parser->opt_data.rpl_opterr = 0;
#line 551
    if (parser->state.flags & 1U) {
#line 554
      (parser->state.argv) --;
#line 554
      (parser->state.argc) ++;
    }
  } else {
#line 557
    parser->opt_data.rpl_opterr = 1;
  }
#line 559
  if ((unsigned long )parser->state.argv == (unsigned long )argv) {
#line 559
    if (*(argv + 0)) {
      {
#line 561
      parser->state.name = last_component((char const   *)*(argv + 0));
      }
    } else {
#line 563
      parser->state.name = program_invocation_short_name;
    }
  } else {
#line 563
    parser->state.name = program_invocation_short_name;
  }
#line 565
  return (0);
}
}
#line 569 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t parser_finalize(struct parser *parser , error_t err , int arg_ebadkey ,
                               int *end_index ) 
{ 
  struct group *group ;
  char *tmp ;

  {
#line 575
  if (err == 7) {
#line 575
    if (arg_ebadkey) {
#line 577
      err = 0;
    }
  }
#line 579
  if (! err) {
#line 581
    if (parser->state.next == parser->state.argc) {
#line 585
      group = parser->groups;
      {
#line 585
      while (1) {
        while_continue: /* CIL Label */ ;
#line 585
        if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 585
          if (! (! err)) {
#line 585
            if (! (err == 7)) {
#line 585
              goto while_break;
            }
          }
        } else {
#line 585
          goto while_break;
        }
#line 588
        if (group->args_processed == 0U) {
          {
#line 589
          err = group_parse(group, & parser->state, 16777218, (char *)0);
          }
        }
#line 585
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 590
      group = parser->egroup - 1;
      {
#line 590
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 590
        if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 590
          if (! (! err)) {
#line 590
            if (! (err == 7)) {
#line 590
              goto while_break___0;
            }
          }
        } else {
#line 590
          goto while_break___0;
        }
        {
#line 593
        err = group_parse(group, & parser->state, 16777217, (char *)0);
#line 590
        group --;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 595
      if (err == 7) {
#line 596
        err = 0;
      }
#line 599
      if (end_index) {
#line 600
        *end_index = parser->state.next;
      }
    } else
#line 602
    if (end_index) {
#line 604
      *end_index = parser->state.next;
    } else {
#line 608
      if (! (parser->state.flags & 2U)) {
#line 608
        if (parser->state.err_stream) {
          {
#line 610
          tmp = dgettext((char const   *)(parser->argp)->argp_domain, "%s: Too many arguments\n");
#line 610
          fprintf((FILE */* __restrict  */)parser->state.err_stream, (char const   */* __restrict  */)tmp,
                  parser->state.name);
          }
        }
      }
#line 614
      err = 7;
    }
  }
#line 621
  if (err) {
#line 624
    if (err == 7) {
      {
#line 627
      argp_state_help((struct argp_state  const  */* __restrict  */)(& parser->state),
                      (FILE */* __restrict  */)parser->state.err_stream, 260U);
      }
    }
#line 631
    group = parser->groups;
    {
#line 631
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 631
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 631
        goto while_break___1;
      }
      {
#line 632
      group_parse(group, & parser->state, 16777221, (char *)0);
#line 631
      group ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 640
    group = parser->egroup - 1;
    {
#line 640
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 640
      if ((unsigned long )group >= (unsigned long )parser->groups) {
#line 640
        if (! (! err)) {
#line 640
          if (! (err == 7)) {
#line 640
            goto while_break___2;
          }
        }
      } else {
#line 640
        goto while_break___2;
      }
      {
#line 643
      err = group_parse(group, & parser->state, 16777220, (char *)0);
#line 640
      group --;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 644
    if (err == 7) {
#line 645
      err = 0;
    }
  }
#line 649
  group = parser->egroup - 1;
  {
#line 649
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 649
    if (! ((unsigned long )group >= (unsigned long )parser->groups)) {
#line 649
      goto while_break___3;
    }
    {
#line 650
    group_parse(group, & parser->state, 16777223, (char *)0);
#line 649
    group --;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 652
  if (err == 7) {
#line 653
    err = 22;
  }
  {
#line 655
  free(parser->storage);
  }
#line 657
  return (err);
}
}
#line 665 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t parser_parse_arg(struct parser *parser , char *val___0 ) 
{ 
  int index___0 ;
  error_t err ;
  struct group *group ;
  int key ;

  {
#line 670
  (parser->state.next) --;
#line 670
  index___0 = parser->state.next;
#line 671
  err = 7;
#line 673
  key = 0;
#line 676
  group = parser->groups;
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if ((unsigned long )group < (unsigned long )parser->egroup) {
#line 676
      if (! (err == 7)) {
#line 676
        goto while_break;
      }
    } else {
#line 676
      goto while_break;
    }
    {
#line 680
    (parser->state.next) ++;
#line 681
    key = 0;
#line 682
    err = group_parse(group, & parser->state, key, val___0);
    }
#line 684
    if (err == 7) {
      {
#line 687
      (parser->state.next) --;
#line 688
      key = 16777222;
#line 689
      err = group_parse(group, & parser->state, key, (char *)0);
      }
    }
#line 676
    group ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 693
  if (! err) {
#line 695
    if (key == 16777222) {
#line 699
      parser->state.next = parser->state.argc;
    }
#line 701
    if (parser->state.next > index___0) {
#line 705
      group --;
#line 705
      group->args_processed += (unsigned int )(parser->state.next - index___0);
    } else {
#line 708
      parser->try_getopt = 1;
    }
  }
#line 711
  return (err);
}
}
#line 754
static error_t parser_parse_opt(struct parser *parser , int opt , char *val___0 ) ;
#line 754 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static char const   bad_key_err[53]  = 
#line 754
  {      (char const   )'(',      (char const   )'P',      (char const   )'R',      (char const   )'O', 
        (char const   )'G',      (char const   )'R',      (char const   )'A',      (char const   )'M', 
        (char const   )' ',      (char const   )'E',      (char const   )'R',      (char const   )'R', 
        (char const   )'O',      (char const   )'R',      (char const   )')',      (char const   )' ', 
        (char const   )'O',      (char const   )'p',      (char const   )'t',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'s', 
        (char const   )'h',      (char const   )'o',      (char const   )'u',      (char const   )'l', 
        (char const   )'d',      (char const   )' ',      (char const   )'h',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )' ',      (char const   )'b', 
        (char const   )'e',      (char const   )'e',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'o', 
        (char const   )'g',      (char const   )'n',      (char const   )'i',      (char const   )'z', 
        (char const   )'e',      (char const   )'d',      (char const   )'!',      (char const   )'?', 
        (char const   )'\000'};
#line 716 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t parser_parse_opt(struct parser *parser , int opt , char *val___0 ) 
{ 
  int group_key ;
  error_t err ;
  struct group *group ;
  char *short_index ;
  char *tmp ;
  char *tmp___0 ;
  struct rpl_option *long_opt ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 721
  group_key = opt >> (sizeof(((struct rpl_option *)0)->val) * 8UL - 8UL);
#line 722
  err = 7;
#line 724
  if (group_key == 0) {
    {
#line 730
    tmp = strchr((char const   *)parser->short_opts, opt);
#line 730
    short_index = tmp;
    }
#line 732
    if (short_index) {
#line 733
      group = parser->groups;
      {
#line 733
      while (1) {
        while_continue: /* CIL Label */ ;
#line 733
        if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 733
          goto while_break;
        }
#line 734
        if ((unsigned long )group->short_end > (unsigned long )short_index) {
          {
#line 736
          err = group_parse(group, & parser->state, opt, parser->opt_data.rpl_optarg);
          }
#line 738
          goto while_break;
        }
#line 733
        group ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 744
    err = group_parse(parser->groups + (group_key - 1), & parser->state, (opt << 8) >> 8,
                      parser->opt_data.rpl_optarg);
    }
  }
#line 749
  if (err == 7) {
#line 756
    if (group_key == 0) {
      {
#line 757
      tmp___0 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
#line 757
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"-%c: %s", opt, tmp___0);
      }
    } else {
#line 761
      long_opt = parser->long_opts;
      {
#line 762
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 762
        if (long_opt->val != opt) {
#line 762
          if (! long_opt->name) {
#line 762
            goto while_break___0;
          }
        } else {
#line 762
          goto while_break___0;
        }
#line 763
        long_opt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 764
      tmp___1 = dgettext((char const   *)(parser->argp)->argp_domain, bad_key_err);
      }
#line 764
      if (long_opt->name) {
#line 764
        tmp___2 = long_opt->name;
      } else {
#line 764
        tmp___2 = "???";
      }
      {
#line 764
      argp_error((struct argp_state  const  */* __restrict  */)(& parser->state),
                 (char const   */* __restrict  */)"--%s: %s", tmp___2, tmp___1);
      }
    }
  }
#line 770
  return (err);
}
}
#line 777 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
static error_t parser_parse_next(struct parser *parser , int *arg_ebadkey ) 
{ 
  int opt ;
  error_t err ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 781
  err = 0;
#line 783
  if (parser->state.quoted) {
#line 783
    if (parser->state.next < parser->state.quoted) {
#line 788
      parser->state.quoted = 0;
    }
  }
#line 790
  if (parser->try_getopt) {
#line 790
    if (! parser->state.quoted) {
#line 794
      parser->opt_data.rpl_optind = parser->state.next;
#line 796
      parser->opt_data.rpl_optopt = -1;
#line 797
      if (parser->state.flags & 64U) {
        {
#line 798
        opt = _getopt_long_only_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                                  (struct rpl_option  const  *)parser->long_opts,
                                  (int *)0, & parser->opt_data);
        }
      } else {
        {
#line 802
        opt = _getopt_long_r(parser->state.argc, parser->state.argv, (char const   *)parser->short_opts,
                             (struct rpl_option  const  *)parser->long_opts, (int *)0,
                             & parser->opt_data);
        }
      }
#line 806
      parser->state.next = parser->opt_data.rpl_optind;
#line 808
      if (opt == -1) {
#line 812
        parser->try_getopt = 0;
#line 813
        if (parser->state.next > 1) {
          {
#line 813
          tmp = strcmp((char const   *)*(parser->state.argv + (parser->state.next - 1)),
                       "--");
          }
#line 813
          if (tmp == 0) {
#line 820
            parser->state.quoted = parser->state.next;
          }
        }
      } else
#line 822
      if (opt == 63) {
#line 822
        if (parser->opt_data.rpl_optopt != -1) {
#line 827
          *arg_ebadkey = 0;
#line 828
          return (7);
        }
      }
    } else {
#line 832
      opt = -1;
    }
  } else {
#line 832
    opt = -1;
  }
#line 834
  if (opt == -1) {
#line 837
    if (parser->state.next >= parser->state.argc) {
#line 841
      *arg_ebadkey = 1;
#line 842
      return (7);
    } else
#line 837
    if (parser->state.flags & 4U) {
#line 841
      *arg_ebadkey = 1;
#line 842
      return (7);
    } else {
#line 847
      opt = 1;
#line 848
      tmp___0 = parser->state.next;
#line 848
      (parser->state.next) ++;
#line 848
      parser->opt_data.rpl_optarg = *(parser->state.argv + tmp___0);
    }
  }
#line 852
  if (opt == 1) {
    {
#line 854
    err = parser_parse_arg(parser, parser->opt_data.rpl_optarg);
    }
  } else {
    {
#line 856
    err = parser_parse_opt(parser, opt, parser->opt_data.rpl_optarg);
    }
  }
#line 858
  if (err == 7) {
#line 859
    if (opt == -1) {
#line 859
      tmp___1 = 1;
    } else
#line 859
    if (opt == 1) {
#line 859
      tmp___1 = 1;
    } else {
#line 859
      tmp___1 = 0;
    }
#line 859
    *arg_ebadkey = tmp___1;
  }
#line 861
  return (err);
}
}
#line 869 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
error_t argp_parse(struct argp  const  * __restrict  argp___0 , int argc , char ** __restrict  argv ,
                   unsigned int flags , int * __restrict  end_index , void * __restrict  input ) 
{ 
  error_t err ;
  struct parser parser ;
  int arg_ebadkey ;
  struct argp_child *child ;
  void *tmp ;
  struct argp *top_argp ;
  void *tmp___0 ;
  struct argp_child *tmp___1 ;
  struct argp_child *tmp___2 ;
  struct argp_child *tmp___3 ;

  {
#line 878
  arg_ebadkey = 0;
#line 881
  if (! (flags & 1U)) {
#line 884
    if (! program_invocation_name) {
#line 885
      program_invocation_name = *(argv + 0);
    }
#line 888
    if (! program_invocation_short_name) {
      {
#line 889
      program_invocation_short_name = last_component((char const   *)*(argv + 0));
      }
    }
  }
#line 894
  if (! (flags & 16U)) {
    {
#line 897
    tmp = __builtin_alloca(4UL * sizeof(struct argp_child ));
#line 897
    child = (struct argp_child *)tmp;
#line 898
    tmp___0 = __builtin_alloca(sizeof(struct argp ));
#line 898
    top_argp = (struct argp *)tmp___0;
#line 902
    memset((void *)top_argp, 0, sizeof(*top_argp));
#line 903
    top_argp->children = (struct argp_child  const  *)child;
#line 905
    memset((void *)child, 0, 4UL * sizeof(struct argp_child ));
    }
#line 907
    if (argp___0) {
#line 908
      tmp___1 = child;
#line 908
      child ++;
#line 908
      tmp___1->argp = (struct argp  const  *)argp___0;
    }
#line 909
    tmp___2 = child;
#line 909
    child ++;
#line 909
    tmp___2->argp = & argp_default_argp;
#line 910
    if (argp_program_version) {
#line 911
      tmp___3 = child;
#line 911
      child ++;
#line 911
      tmp___3->argp = & argp_version_argp;
    } else
#line 910
    if (argp_program_version_hook) {
#line 911
      tmp___3 = child;
#line 911
      child ++;
#line 911
      tmp___3->argp = & argp_version_argp;
    }
#line 912
    child->argp = (struct argp  const  *)0;
#line 914
    argp___0 = (struct argp  const  */* __restrict  */)top_argp;
  }
  {
#line 918
  err = parser_init(& parser, (struct argp  const  *)argp___0, argc, (char **)argv,
                    (int )flags, (void *)input);
  }
#line 920
  if (! err) {
    {
#line 923
    while (1) {
      while_continue: /* CIL Label */ ;
#line 923
      if (! (! err)) {
#line 923
        goto while_break;
      }
      {
#line 924
      err = parser_parse_next(& parser, & arg_ebadkey);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 925
    err = parser_finalize(& parser, err, arg_ebadkey, (int *)end_index);
    }
  }
#line 928
  return (err);
}
}
#line 936
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) _argp_input)(struct argp  const  * __restrict  argp___0 ,
                                                                             struct argp_state  const  * __restrict  state ) ;
#line 936 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-parse.c"
void *( __attribute__((__leaf__)) _argp_input)(struct argp  const  * __restrict  argp___0 ,
                                               struct argp_state  const  * __restrict  state ) 
{ 
  struct group *group ;
  struct parser *parser ;

  {
#line 939
  if (state) {
#line 942
    parser = (struct parser *)state->pstate;
#line 944
    group = parser->groups;
    {
#line 944
    while (1) {
      while_continue: /* CIL Label */ ;
#line 944
      if (! ((unsigned long )group < (unsigned long )parser->egroup)) {
#line 944
        goto while_break;
      }
#line 945
      if ((unsigned long )group->argp == (unsigned long )argp___0) {
#line 946
        return (group->input);
      }
#line 944
      group ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 949
  return ((void *)0);
}
}
#line 265 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchrnul)(char const   *__s ,
                                                                                                  int __c )  __attribute__((__pure__)) ;
#line 396
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 420
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strerror_r)(int __errnum ,
                                                                                                   char *__buf ,
                                                                                                   size_t __buflen ) ;
#line 116 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 840 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) flockfile)(FILE *__stream ) ;
#line 847
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) funlockfile)(FILE *__stream ) ;
#line 460 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
char const   *argp_program_bug_address ;
#line 465
error_t argp_err_exit_status ;
#line 498
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) ;
#line 546
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) ;
#line 585
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 120 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) ;
#line 127
void argp_fmtstream_free(argp_fmtstream_t fs ) ;
#line 132
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) ;
#line 182
void _argp_fmtstream_update(argp_fmtstream_t fs ) ;
#line 184
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) ;
#line 203
#pragma GCC diagnostic push
#line 203
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 203
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 264 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_write(argp_fmtstream_t __fs , char const   *__str ,
                                     size_t __len ) 
{ 
  int tmp ;

  {
#line 268
  if ((unsigned long )(__fs->p + __len) <= (unsigned long )__fs->end) {
    {
#line 270
    memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
           __len);
#line 271
    __fs->p += __len;
    }
#line 272
    return (__len);
  } else {
    {
#line 268
    tmp = _argp_fmtstream_ensure(__fs, __len);
    }
#line 268
    if (tmp) {
      {
#line 270
      memcpy((void */* __restrict  */)__fs->p, (void const   */* __restrict  */)__str,
             __len);
#line 271
      __fs->p += __len;
      }
#line 272
      return (__len);
    } else {
#line 275
      return ((size_t )0);
    }
  }
}
}
#line 278 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline int argp_fmtstream_puts(argp_fmtstream_t __fs , char const   *__str ) 
{ 
  size_t __len ;
  size_t tmp ;
  size_t __wrote ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 281
  tmp = strlen(__str);
#line 281
  __len = tmp;
  }
#line 282
  if (__len) {
    {
#line 284
    tmp___0 = argp_fmtstream_write(__fs, __str, __len);
#line 284
    __wrote = tmp___0;
    }
#line 285
    if (__wrote == __len) {
#line 285
      tmp___1 = 0;
    } else {
#line 285
      tmp___1 = -1;
    }
#line 285
    return (tmp___1);
  } else {
#line 288
    return (0);
  }
}
}
#line 291 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline int argp_fmtstream_putc(argp_fmtstream_t __fs , int __ch ) 
{ 
  char *tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 294
  if ((unsigned long )__fs->p < (unsigned long )__fs->end) {
#line 295
    tmp = __fs->p;
#line 295
    (__fs->p) ++;
#line 295
    tmp___0 = (char )__ch;
#line 295
    *tmp = tmp___0;
#line 295
    return ((int )tmp___0);
  } else {
    {
#line 294
    tmp___1 = _argp_fmtstream_ensure(__fs, (size_t )1);
    }
#line 294
    if (tmp___1) {
#line 295
      tmp = __fs->p;
#line 295
      (__fs->p) ++;
#line 295
      tmp___0 = (char )__ch;
#line 295
      *tmp = tmp___0;
#line 295
      return ((int )tmp___0);
    } else {
#line 297
      return (-1);
    }
  }
}
}
#line 301 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_set_lmargin(argp_fmtstream_t __fs , size_t __lmargin ) 
{ 
  size_t __old ;

  {
#line 305
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 306
    _argp_fmtstream_update(__fs);
    }
  }
#line 307
  __old = __fs->lmargin;
#line 308
  __fs->lmargin = __lmargin;
#line 309
  return (__old);
}
}
#line 313 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_set_rmargin(argp_fmtstream_t __fs , size_t __rmargin ) 
{ 
  size_t __old ;

  {
#line 317
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 318
    _argp_fmtstream_update(__fs);
    }
  }
#line 319
  __old = __fs->rmargin;
#line 320
  __fs->rmargin = __rmargin;
#line 321
  return (__old);
}
}
#line 325 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_set_wmargin(argp_fmtstream_t __fs , size_t __wmargin ) 
{ 
  size_t __old ;

  {
#line 329
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 330
    _argp_fmtstream_update(__fs);
    }
  }
#line 331
  __old = (size_t )__fs->wmargin;
#line 332
  __fs->wmargin = (ssize_t )__wmargin;
#line 333
  return (__old);
}
}
#line 337 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
__inline size_t argp_fmtstream_point(argp_fmtstream_t __fs ) 
{ 
  ssize_t tmp ;

  {
#line 340
  if ((size_t )(__fs->p - __fs->buf) > __fs->point_offs) {
    {
#line 341
    _argp_fmtstream_update(__fs);
    }
  }
#line 342
  if (__fs->point_col >= 0L) {
#line 342
    tmp = __fs->point_col;
  } else {
#line 342
    tmp = (ssize_t )0;
  }
#line 342
  return ((size_t )tmp);
}
}
#line 355
#pragma GCC diagnostic pop
#line 104 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct uparams uparams  = 
#line 104 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
     {0, 1, 2, 6, 2, 29, 1, 12, 79, 0};
#line 120 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct uparam_name  const  uparam_names[10]  = 
#line 120
  {      {"dup-args", 1, (unsigned long )(& ((struct uparams *)0)->dup_args)}, 
        {"dup-args-note", 1, (unsigned long )(& ((struct uparams *)0)->dup_args_note)}, 
        {"short-opt-col",
      0, (unsigned long )(& ((struct uparams *)0)->short_opt_col)}, 
        {"long-opt-col", 0, (unsigned long )(& ((struct uparams *)0)->long_opt_col)}, 
        {"doc-opt-col",
      0, (unsigned long )(& ((struct uparams *)0)->doc_opt_col)}, 
        {"opt-doc-col", 0, (unsigned long )(& ((struct uparams *)0)->opt_doc_col)}, 
        {"header-col", 0, (unsigned long )(& ((struct uparams *)0)->header_col)}, 
        {"usage-indent", 0, (unsigned long )(& ((struct uparams *)0)->usage_indent)}, 
        {"rmargin",
      0, (unsigned long )(& ((struct uparams *)0)->rmargin)}, 
        {(char const   *)0, 0, 0UL}};
#line 134 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void validate_uparams(struct argp_state  const  *state , struct uparams *upptr ) 
{ 
  struct uparam_name  const  *up ;
  char *tmp ;

  {
#line 139
  up = uparam_names;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! up->name) {
#line 139
      goto while_break;
    }
#line 141
    if (up->is_bool) {
#line 143
      goto __Cont;
    } else
#line 141
    if (up->uparams_offs == (size_t const   )((unsigned long )(& ((struct uparams *)0)->rmargin))) {
#line 143
      goto __Cont;
    }
#line 144
    if (*((int *)((char *)upptr + up->uparams_offs)) >= upptr->rmargin) {
      {
#line 146
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "ARGP_HELP_FMT: %s value is less than or equal to %s");
#line 146
      argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp,
                   "rmargin", up->name);
      }
#line 151
      return;
    }
    __Cont: /* CIL Label */ 
#line 139
    up ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  uparams = *upptr;
#line 155
  uparams.valid = 1;
#line 156
  return;
}
}
#line 159 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void fill_in_uparams(struct argp_state  const  *state ) 
{ 
  char const   *var ;
  char *tmp ;
  struct uparams new_params ;
  unsigned short const   **tmp___0 ;
  size_t var_len ;
  struct uparam_name  const  *un ;
  int unspec ;
  int val___0 ;
  char const   *arg___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;

  {
  {
#line 162
  tmp = getenv("ARGP_HELP_FMT");
#line 162
  var = (char const   *)tmp;
#line 163
  new_params = uparams;
  }
#line 167
  if (var) {
    {
#line 170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 170
      if (! *var) {
#line 170
        goto while_break;
      }
      {
#line 172
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 172
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 172
          tmp___0 = __ctype_b_loc();
          }
#line 172
          if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*var)) & 8192)) {
#line 172
            goto while_break___1;
          }
#line 172
          var ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 172
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 174
      tmp___13 = __ctype_b_loc();
      }
#line 174
      if ((int const   )*(*tmp___13 + (int )((unsigned char )*var)) & 1024) {
#line 178
        unspec = 0;
#line 178
        val___0 = 0;
#line 179
        arg___0 = var;
        {
#line 181
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 181
          tmp___1 = __ctype_b_loc();
          }
#line 181
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*arg___0)) & 8)) {
#line 181
            if (! ((int const   )*arg___0 == 45)) {
#line 181
              if (! ((int const   )*arg___0 == 95)) {
#line 181
                goto while_break___2;
              }
            }
          }
#line 182
          arg___0 ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 183
        var_len = (size_t )(arg___0 - var);
        {
#line 185
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 185
          while (1) {
            while_continue___4: /* CIL Label */ ;
            {
#line 185
            tmp___2 = __ctype_b_loc();
            }
#line 185
            if (! ((int const   )*(*tmp___2 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 185
              goto while_break___4;
            }
#line 185
            arg___0 ++;
          }
          while_break___4: /* CIL Label */ ;
          }
#line 185
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 187
        if ((int const   )*arg___0 == 0) {
#line 188
          unspec = 1;
        } else
#line 187
        if ((int const   )*arg___0 == 44) {
#line 188
          unspec = 1;
        } else
#line 189
        if ((int const   )*arg___0 == 61) {
#line 191
          arg___0 ++;
          {
#line 192
          while (1) {
            while_continue___5: /* CIL Label */ ;
            {
#line 192
            while (1) {
              while_continue___6: /* CIL Label */ ;
              {
#line 192
              tmp___3 = __ctype_b_loc();
              }
#line 192
              if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 192
                goto while_break___6;
              }
#line 192
              arg___0 ++;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 192
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 195
        if (unspec) {
#line 197
          if ((int const   )*(var + 0) == 110) {
#line 197
            if ((int const   )*(var + 1) == 111) {
#line 197
              if ((int const   )*(var + 2) == 45) {
#line 199
                val___0 = 0;
#line 200
                var += 3;
#line 201
                var_len -= 3UL;
              } else {
#line 204
                val___0 = 1;
              }
            } else {
#line 204
              val___0 = 1;
            }
          } else {
#line 204
            val___0 = 1;
          }
        } else {
          {
#line 206
          tmp___6 = __ctype_b_loc();
          }
#line 206
          if ((int const   )*(*tmp___6 + (int )((unsigned char )*arg___0)) & 2048) {
            {
#line 208
            val___0 = atoi(arg___0);
            }
            {
#line 209
            while (1) {
              while_continue___7: /* CIL Label */ ;
              {
#line 209
              tmp___4 = __ctype_b_loc();
              }
#line 209
              if (! ((int const   )*(*tmp___4 + (int )((unsigned char )*arg___0)) & 2048)) {
#line 209
                goto while_break___7;
              }
#line 210
              arg___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
            {
#line 211
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 211
              while (1) {
                while_continue___9: /* CIL Label */ ;
                {
#line 211
                tmp___5 = __ctype_b_loc();
                }
#line 211
                if (! ((int const   )*(*tmp___5 + (int )((unsigned char )*arg___0)) & 8192)) {
#line 211
                  goto while_break___9;
                }
#line 211
                arg___0 ++;
              }
              while_break___9: /* CIL Label */ ;
              }
#line 211
              goto while_break___8;
            }
            while_break___8: /* CIL Label */ ;
            }
          }
        }
#line 214
        un = uparam_names;
        {
#line 214
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 214
          if (! un->name) {
#line 214
            goto while_break___10;
          }
          {
#line 215
          tmp___9 = strlen((char const   *)un->name);
          }
#line 215
          if (tmp___9 == var_len) {
            {
#line 215
            tmp___10 = strncmp(var, (char const   *)un->name, var_len);
            }
#line 215
            if (tmp___10 == 0) {
#line 218
              if (unspec) {
#line 218
                if (! un->is_bool) {
                  {
#line 219
                  tmp___7 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                     "%.*s: ARGP_HELP_FMT parameter requires a value");
#line 219
                  argp_failure((struct argp_state  const  */* __restrict  */)state,
                               0, 0, (char const   */* __restrict  */)tmp___7, (int )var_len,
                               var);
                  }
                } else {
#line 218
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 224
              if (val___0 < 0) {
                {
#line 225
                tmp___8 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                   "%.*s: ARGP_HELP_FMT parameter must be positive");
#line 225
                argp_failure((struct argp_state  const  */* __restrict  */)state,
                             0, 0, (char const   */* __restrict  */)tmp___8, (int )var_len,
                             var);
                }
              } else {
#line 231
                *((int *)((char *)(& new_params) + un->uparams_offs)) = val___0;
              }
#line 232
              goto while_break___10;
            }
          }
#line 214
          un ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 234
        if (! un->name) {
          {
#line 235
          tmp___11 = dgettext((char const   *)(state->root_argp)->argp_domain, "%.*s: Unknown ARGP_HELP_FMT parameter");
#line 235
          argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0,
                       (char const   */* __restrict  */)tmp___11, (int )var_len, var);
          }
        }
#line 240
        var = arg___0;
#line 241
        if ((int const   )*var == 44) {
#line 242
          var ++;
        }
      } else
#line 244
      if (*var) {
        {
#line 246
        tmp___12 = dgettext((char const   *)(state->root_argp)->argp_domain, "Garbage in ARGP_HELP_FMT: %s");
#line 246
        argp_failure((struct argp_state  const  */* __restrict  */)state, 0, 0, (char const   */* __restrict  */)tmp___12,
                     var);
        }
#line 249
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 252
    validate_uparams(state, & new_params);
    }
  }
#line 254
  return;
}
}
#line 340 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int find_char(char ch , char *beg , char *end ) 
{ 


  {
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! ((unsigned long )beg < (unsigned long )end)) {
#line 343
      goto while_break;
    }
#line 344
    if ((int )*beg == (int )ch) {
#line 345
      return (1);
    } else {
#line 347
      beg ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  return (0);
}
}
#line 432 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct hol *make_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  char *so ;
  struct argp_option  const  *o___0 ;
  struct argp_option  const  *opts ;
  struct hol_entry *entry___0 ;
  unsigned int num_short_options ;
  struct hol *hol ;
  void *tmp ;
  int cur_group ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 437
  opts = (struct argp_option  const  *)argp___0->options;
#line 439
  num_short_options = 0U;
#line 440
  tmp = malloc(sizeof(struct hol ));
#line 440
  hol = (struct hol *)tmp;
  }
#line 442
  if (! hol) {
    {
#line 442
    __assert_fail("hol", "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c",
                  442U, "make_hol");
    }
  }
#line 444
  hol->num_entries = 0U;
#line 445
  hol->clusters = (struct hol_cluster *)0;
#line 447
  if (opts) {
#line 449
    cur_group = 0;
#line 452
    if (! (! (opts->flags & 4))) {
      {
#line 452
      __assert_fail("! oalias (opts)", "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c",
                    452U, "make_hol");
      }
    }
#line 455
    o___0 = opts;
    {
#line 455
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 455
      tmp___3 = _option_is_end(o___0);
      }
#line 455
      if (tmp___3) {
#line 455
        goto while_break;
      }
#line 457
      if (! (o___0->flags & 4)) {
#line 458
        (hol->num_entries) ++;
      }
      {
#line 459
      tmp___2 = _option_is_short(o___0);
      }
#line 459
      if (tmp___2) {
#line 460
        num_short_options ++;
      }
#line 455
      o___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 463
    tmp___4 = malloc(sizeof(struct hol_entry ) * (unsigned long )hol->num_entries);
#line 463
    hol->entries = (struct hol_entry *)tmp___4;
#line 464
    tmp___5 = malloc((size_t )(num_short_options + 1U));
#line 464
    hol->short_options = (char *)tmp___5;
    }
#line 466
    if (hol->entries) {
#line 466
      if (! hol->short_options) {
        {
#line 466
        __assert_fail("hol->entries && hol->short_options", "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c",
                      466U, "make_hol");
        }
      }
    } else {
      {
#line 466
      __assert_fail("hol->entries && hol->short_options", "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c",
                    466U, "make_hol");
      }
    }
#line 471
    so = hol->short_options;
#line 472
    o___0 = opts;
#line 472
    entry___0 = hol->entries;
    {
#line 472
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 472
      tmp___13 = _option_is_end(o___0);
      }
#line 472
      if (tmp___13) {
#line 472
        goto while_break___0;
      }
#line 474
      entry___0->opt = o___0;
#line 475
      entry___0->num = 0U;
#line 476
      entry___0->short_options = so;
#line 477
      if (o___0->group) {
#line 477
        cur_group = (int )o___0->group;
      } else {
#line 477
        if (! o___0->name) {
#line 477
          if (! o___0->key) {
#line 477
            tmp___8 = cur_group + 1;
          } else {
#line 477
            tmp___8 = cur_group;
          }
        } else {
#line 477
          tmp___8 = cur_group;
        }
#line 477
        cur_group = tmp___8;
      }
#line 477
      entry___0->group = cur_group;
#line 483
      entry___0->cluster = cluster;
#line 484
      entry___0->argp = argp___0;
      {
#line 486
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 488
        (entry___0->num) ++;
#line 489
        tmp___10 = _option_is_short(o___0);
        }
#line 489
        if (tmp___10) {
          {
#line 489
          tmp___11 = find_char((char )o___0->key, hol->short_options, so);
          }
#line 489
          if (! tmp___11) {
#line 491
            tmp___9 = so;
#line 491
            so ++;
#line 491
            *tmp___9 = (char )o___0->key;
          }
        }
        {
#line 492
        o___0 ++;
#line 486
        tmp___12 = _option_is_end(o___0);
        }
#line 486
        if (tmp___12) {
#line 486
          goto while_break___1;
        } else
#line 486
        if (! (o___0->flags & 4)) {
#line 486
          goto while_break___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 472
      entry___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 496
    *so = (char )'\000';
  }
#line 499
  return (hol);
}
}
#line 505 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct hol_cluster *hol_add_cluster(struct hol *hol , int group , char const   *header ,
                                           int index___0 , struct hol_cluster *parent ,
                                           struct argp  const  *argp___0 ) 
{ 
  struct hol_cluster *cl ;
  void *tmp ;

  {
  {
#line 509
  tmp = malloc(sizeof(struct hol_cluster ));
#line 509
  cl = (struct hol_cluster *)tmp;
  }
#line 510
  if (cl) {
#line 512
    cl->group = group;
#line 513
    cl->header = header;
#line 515
    cl->index = index___0;
#line 516
    cl->parent = parent;
#line 517
    cl->argp = argp___0;
#line 518
    if (parent) {
#line 518
      cl->depth = parent->depth + 1;
    } else {
#line 518
      cl->depth = 0;
    }
#line 520
    cl->next = hol->clusters;
#line 521
    hol->clusters = cl;
  }
#line 523
  return (cl);
}
}
#line 527 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_free(struct hol *hol ) 
{ 
  struct hol_cluster *cl ;
  struct hol_cluster *next ;

  {
#line 530
  cl = hol->clusters;
  {
#line 532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 532
    if (! cl) {
#line 532
      goto while_break;
    }
    {
#line 534
    next = cl->next;
#line 535
    free((void *)cl);
#line 536
    cl = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  if (hol->num_entries > 0U) {
    {
#line 541
    free((void *)hol->entries);
#line 542
    free((void *)hol->short_options);
    }
  }
  {
#line 545
  free((void *)hol);
  }
#line 546
  return;
}
}
#line 548 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int hol_entry_short_iterate(struct hol_entry  const  *entry___0 , int (*func)(struct argp_option  const  *opt ,
                                                                                     struct argp_option  const  *real ,
                                                                                     char const   *domain ,
                                                                                     void *cookie ) ,
                                   char const   *domain , void *cookie ) 
{ 
  unsigned int nopts ;
  int val___0 ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;
  char *so ;
  int tmp ;

  {
#line 556
  val___0 = 0;
#line 557
  real = (struct argp_option  const  *)entry___0->opt;
#line 558
  so = (char *)entry___0->short_options;
#line 560
  opt = real;
#line 560
  nopts = (unsigned int )entry___0->num;
  {
#line 560
  while (1) {
    while_continue: /* CIL Label */ ;
#line 560
    if (nopts > 0U) {
#line 560
      if (! (! val___0)) {
#line 560
        goto while_break;
      }
    } else {
#line 560
      goto while_break;
    }
    {
#line 561
    tmp = _option_is_short(opt);
    }
#line 561
    if (tmp) {
#line 561
      if ((int )*so == (int )opt->key) {
#line 563
        if (! (opt->flags & 4)) {
#line 564
          real = opt;
        }
#line 565
        if (! (opt->flags & 2)) {
          {
#line 566
          val___0 = (*func)(opt, real, domain, cookie);
          }
        }
#line 567
        so ++;
      }
    }
#line 560
    opt ++;
#line 560
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return (val___0);
}
}
#line 573 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
__inline static int ( __attribute__((__always_inline__)) hol_entry_long_iterate)(struct hol_entry  const  *entry___0 ,
                                                                                 int (*func)(struct argp_option  const  *opt ,
                                                                                             struct argp_option  const  *real ,
                                                                                             char const   *domain ,
                                                                                             void *cookie ) ,
                                                                                 char const   *domain ,
                                                                                 void *cookie ) 
{ 
  unsigned int nopts ;
  int val___0 ;
  struct argp_option  const  *opt ;
  struct argp_option  const  *real ;

  {
#line 584
  val___0 = 0;
#line 585
  real = (struct argp_option  const  *)entry___0->opt;
#line 587
  opt = real;
#line 587
  nopts = (unsigned int )entry___0->num;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (nopts > 0U) {
#line 587
      if (! (! val___0)) {
#line 587
        goto while_break;
      }
    } else {
#line 587
      goto while_break;
    }
#line 588
    if (opt->name) {
#line 590
      if (! (opt->flags & 4)) {
#line 591
        real = opt;
      }
#line 592
      if (! (opt->flags & 2)) {
        {
#line 593
        val___0 = (*func)(opt, real, domain, cookie);
        }
      }
    }
#line 587
    opt ++;
#line 587
    nopts --;
  }
  while_break: /* CIL Label */ ;
  }
#line 596
  return (val___0);
}
}
#line 600 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int until_short(struct argp_option  const  *opt , struct argp_option  const  *real ,
                       char const   *domain , void *cookie ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 604
  tmp___1 = _option_is_short(opt);
  }
#line 604
  if (tmp___1) {
#line 604
    tmp___0 = opt->key;
  } else {
#line 604
    tmp___0 = (int const   )0;
  }
#line 604
  return ((int )tmp___0);
}
}
#line 608 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static char hol_entry_first_short(struct hol_entry  const  *entry___0 ) 
{ 
  int tmp ;

  {
  {
#line 611
  tmp = hol_entry_short_iterate(entry___0, & until_short, (char const   *)(entry___0->argp)->argp_domain,
                                (void *)0);
  }
#line 611
  return ((char )tmp);
}
}
#line 616 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static char const   *hol_entry_first_long(struct hol_entry  const  *entry___0 ) 
{ 
  struct argp_option  const  *opt ;
  unsigned int num ;

  {
#line 621
  opt = (struct argp_option  const  *)entry___0->opt;
#line 621
  num = (unsigned int )entry___0->num;
  {
#line 621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 621
    if (! (num > 0U)) {
#line 621
      goto while_break;
    }
#line 622
    if (opt->name) {
#line 622
      if (! (opt->flags & 2)) {
#line 623
        return ((char const   *)opt->name);
      }
    }
#line 621
    opt ++;
#line 621
    num --;
  }
  while_break: /* CIL Label */ ;
  }
#line 624
  return ((char const   *)0);
}
}
#line 629 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct hol_entry *hol_find_entry(struct hol *hol , char const   *name ) 
{ 
  struct hol_entry *entry___0 ;
  unsigned int num_entries ;
  struct argp_option  const  *opt ;
  unsigned int num_opts ;
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 632
  entry___0 = hol->entries;
#line 633
  num_entries = hol->num_entries;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 635
    tmp___1 = num_entries;
#line 635
    num_entries --;
#line 635
    if (! (tmp___1 > 0U)) {
#line 635
      goto while_break;
    }
#line 637
    opt = entry___0->opt;
#line 638
    num_opts = entry___0->num;
    {
#line 640
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 640
      tmp___0 = num_opts;
#line 640
      num_opts --;
#line 640
      if (! (tmp___0 > 0U)) {
#line 640
        goto while_break___0;
      }
#line 641
      if (opt->name) {
#line 641
        if (! (opt->flags & 2)) {
          {
#line 641
          tmp = strcmp((char const   *)opt->name, name);
          }
#line 641
          if (tmp == 0) {
#line 642
            return (entry___0);
          } else {
#line 644
            opt ++;
          }
        } else {
#line 644
          opt ++;
        }
      } else {
#line 644
        opt ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 646
    entry___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 649
  return ((struct hol_entry *)0);
}
}
#line 654 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_set_group(struct hol *hol , char const   *name , int group ) 
{ 
  struct hol_entry *entry___0 ;
  struct hol_entry *tmp ;

  {
  {
#line 657
  tmp = hol_find_entry(hol, name);
#line 657
  entry___0 = tmp;
  }
#line 658
  if (entry___0) {
#line 659
    entry___0->group = group;
  }
#line 660
  return;
}
}
#line 664 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int group_cmp(int group1 , int group2 , int eq ) 
{ 


  {
#line 667
  if (group1 == group2) {
#line 668
    return (eq);
  } else
#line 669
  if (group1 < 0) {
#line 669
    if (group2 < 0) {
#line 670
      return (group1 - group2);
    } else {
#line 669
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 669
  if (group1 >= 0) {
#line 669
    if (group2 >= 0) {
#line 670
      return (group1 - group2);
    } else {
#line 672
      return (group2 - group1);
    }
  } else {
#line 672
    return (group2 - group1);
  }
}
}
#line 677 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int hol_cluster_cmp(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 
  int tmp ;

  {
  {
#line 684
  while (1) {
    while_continue: /* CIL Label */ ;
#line 684
    if (! (cl1->depth > cl2->depth)) {
#line 684
      goto while_break;
    }
#line 685
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 686
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 686
    if (! (cl2->depth > cl1->depth)) {
#line 686
      goto while_break___0;
    }
#line 687
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 691
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 691
    if (! ((unsigned long )cl1->parent != (unsigned long )cl2->parent)) {
#line 691
      goto while_break___1;
    }
#line 692
    cl1 = (struct hol_cluster  const  *)cl1->parent;
#line 692
    cl2 = (struct hol_cluster  const  *)cl2->parent;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 694
  tmp = group_cmp((int )cl1->group, (int )cl2->group, (int )(cl2->index - cl1->index));
  }
#line 694
  return (tmp);
}
}
#line 699 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct hol_cluster *hol_cluster_base(struct hol_cluster *cl ) 
{ 


  {
  {
#line 702
  while (1) {
    while_continue: /* CIL Label */ ;
#line 702
    if (! cl->parent) {
#line 702
      goto while_break;
    }
#line 703
    cl = cl->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  return (cl);
}
}
#line 708 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int hol_cluster_is_child(struct hol_cluster  const  *cl1 , struct hol_cluster  const  *cl2 ) 
{ 


  {
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
#line 712
    if (cl1) {
#line 712
      if (! ((unsigned long )cl1 != (unsigned long )cl2)) {
#line 712
        goto while_break;
      }
    } else {
#line 712
      goto while_break;
    }
#line 713
    cl1 = (struct hol_cluster  const  *)cl1->parent;
  }
  while_break: /* CIL Label */ ;
  }
#line 714
  return ((unsigned long )cl1 == (unsigned long )cl2);
}
}
#line 720 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int canon_doc_option(char const   **name ) 
{ 
  int non_opt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 725
  if (! *name) {
#line 726
    non_opt = 1;
  } else {
    {
#line 730
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 730
      tmp = __ctype_b_loc();
      }
#line 730
      if (! ((int const   )*(*tmp + (int )((unsigned char )*(*name))) & 8192)) {
#line 730
        goto while_break;
      }
#line 731
      (*name) ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 733
    non_opt = (int const   )*(*name) != 45;
    {
#line 735
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 735
      if (*(*name)) {
        {
#line 735
        tmp___0 = __ctype_b_loc();
        }
#line 735
        if ((int const   )*(*tmp___0 + (int )((unsigned char )*(*name))) & 8) {
#line 735
          goto while_break___0;
        }
      } else {
#line 735
        goto while_break___0;
      }
#line 736
      (*name) ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 738
  return (non_opt);
}
}
#line 745 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int hol_entry_cmp(struct hol_entry  const  *entry1 , struct hol_entry  const  *entry2 ) 
{ 
  int group1 ;
  int group2 ;
  int rc ;
  struct hol_cluster *tmp ;
  int tmp___0 ;
  struct hol_cluster *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int short1 ;
  char tmp___5 ;
  int short2 ;
  char tmp___6 ;
  int doc1 ;
  int doc2 ;
  char const   *long1 ;
  char const   *tmp___7 ;
  char const   *long2 ;
  char const   *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned char first1 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned char first2 ;
  int tmp___13 ;
  int tmp___14 ;
  int lower_cmp ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;

  {
#line 751
  group1 = (int )entry1->group;
#line 751
  group2 = (int )entry2->group;
#line 754
  if ((unsigned long )entry1->cluster != (unsigned long )entry2->cluster) {
#line 758
    if (! entry1->cluster) {
      {
#line 763
      tmp = hol_cluster_base((struct hol_cluster *)entry2->cluster);
#line 763
      tmp___0 = group_cmp(group1, tmp->group, -1);
      }
#line 763
      return (tmp___0);
    } else
#line 764
    if (! entry2->cluster) {
      {
#line 766
      tmp___1 = hol_cluster_base((struct hol_cluster *)entry1->cluster);
#line 766
      tmp___2 = group_cmp(tmp___1->group, group2, 1);
      }
#line 766
      return (tmp___2);
    } else {
      {
#line 769
      rc = hol_cluster_cmp((struct hol_cluster  const  *)entry1->cluster, (struct hol_cluster  const  *)entry2->cluster);
      }
#line 769
      if (rc) {
#line 769
        tmp___4 = rc;
      } else {
#line 769
        if (entry1->ord < entry2->ord) {
#line 769
          tmp___3 = -1;
        } else {
#line 769
          tmp___3 = 1;
        }
#line 769
        tmp___4 = tmp___3;
      }
#line 769
      return (tmp___4);
    }
  } else
#line 772
  if (group1 == group2) {
    {
#line 776
    tmp___5 = hol_entry_first_short(entry1);
#line 776
    short1 = (int )tmp___5;
#line 777
    tmp___6 = hol_entry_first_short(entry2);
#line 777
    short2 = (int )tmp___6;
#line 778
    doc1 = (int )((entry1->opt)->flags & 8);
#line 779
    doc2 = (int )((entry2->opt)->flags & 8);
#line 780
    tmp___7 = hol_entry_first_long(entry1);
#line 780
    long1 = tmp___7;
#line 781
    tmp___8 = hol_entry_first_long(entry2);
#line 781
    long2 = tmp___8;
    }
#line 783
    if (doc1) {
      {
#line 784
      doc1 = canon_doc_option(& long1);
      }
    }
#line 785
    if (doc2) {
      {
#line 786
      doc2 = canon_doc_option(& long2);
      }
    }
#line 788
    if (doc1 != doc2) {
#line 791
      return (doc1 - doc2);
    } else
#line 792
    if (! short1) {
#line 792
      if (! short2) {
#line 792
        if (long1) {
#line 792
          if (long2) {
            {
#line 794
            rc = strcasecmp(long1, long2);
            }
#line 794
            if (rc) {
#line 794
              tmp___10 = rc;
            } else {
#line 794
              if (entry1->ord < entry2->ord) {
#line 794
                tmp___9 = -1;
              } else {
#line 794
                tmp___9 = 1;
              }
#line 794
              tmp___10 = tmp___9;
            }
#line 794
            return (tmp___10);
          } else {
#line 792
            goto _L___1;
          }
        } else {
#line 792
          goto _L___1;
        }
      } else {
#line 792
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 803
      if (short1) {
#line 803
        tmp___12 = short1;
      } else {
#line 803
        if (long1) {
#line 803
          tmp___11 = (int const   )*long1;
        } else {
#line 803
          tmp___11 = (int const   )0;
        }
#line 803
        tmp___12 = (int )tmp___11;
      }
#line 803
      first1 = (unsigned char )tmp___12;
#line 804
      if (short2) {
#line 804
        tmp___14 = short2;
      } else {
#line 804
        if (long2) {
#line 804
          tmp___13 = (int const   )*long2;
        } else {
#line 804
          tmp___13 = (int const   )0;
        }
#line 804
        tmp___14 = (int )tmp___13;
      }
      {
#line 804
      first2 = (unsigned char )tmp___14;
#line 807
      tmp___15 = tolower((int )first1);
#line 807
      tmp___16 = tolower((int )first2);
#line 807
      lower_cmp = tmp___15 - tmp___16;
      }
#line 810
      if (lower_cmp) {
#line 810
        tmp___19 = lower_cmp;
      } else {
#line 810
        rc = (int )first2 - (int )first1;
#line 810
        if (rc) {
#line 810
          tmp___18 = rc;
        } else {
#line 810
          if (entry1->ord < entry2->ord) {
#line 810
            tmp___17 = -1;
          } else {
#line 810
            tmp___17 = 1;
          }
#line 810
          tmp___18 = tmp___17;
        }
#line 810
        tmp___19 = tmp___18;
      }
#line 810
      return (tmp___19);
    }
  } else {
#line 818
    if (entry1->ord < entry2->ord) {
#line 818
      tmp___20 = -1;
    } else {
#line 818
      tmp___20 = 1;
    }
    {
#line 818
    tmp___21 = group_cmp(group1, group2, tmp___20);
    }
#line 818
    return (tmp___21);
  }
}
}
#line 822 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int hol_entry_qcmp(void const   *entry1_v , void const   *entry2_v ) 
{ 
  int tmp ;

  {
  {
#line 825
  tmp = hol_entry_cmp((struct hol_entry  const  *)entry1_v, (struct hol_entry  const  *)entry2_v);
  }
#line 825
  return (tmp);
}
}
#line 831 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_sort(struct hol *hol ) 
{ 
  unsigned int i ;
  struct hol_entry *e ;

  {
#line 834
  if (hol->num_entries > 0U) {
#line 838
    i = 0U;
#line 838
    e = hol->entries;
    {
#line 838
    while (1) {
      while_continue: /* CIL Label */ ;
#line 838
      if (! (i < hol->num_entries)) {
#line 838
        goto while_break;
      }
#line 839
      e->ord = i;
#line 838
      i ++;
#line 838
      e ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 840
    qsort((void *)hol->entries, (size_t )hol->num_entries, sizeof(struct hol_entry ),
          & hol_entry_qcmp);
    }
  }
#line 843
  return;
}
}
#line 847 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_append(struct hol *hol , struct hol *more ) 
{ 
  struct hol_cluster **cl_end ;
  unsigned int left ;
  char *so ;
  char *more_so ;
  struct hol_entry *e ;
  unsigned int num_entries ;
  struct hol_entry *entries ;
  void *tmp ;
  unsigned int hol_so_len ;
  size_t tmp___0 ;
  char *short_options ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___5 ;
  int opts_left ;
  struct argp_option  const  *opt ;
  int ch ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 850
  cl_end = & hol->clusters;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 853
    if (! *cl_end) {
#line 853
      goto while_break;
    }
#line 854
    cl_end = & (*cl_end)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 855
  *cl_end = more->clusters;
#line 856
  more->clusters = (struct hol_cluster *)0;
#line 859
  if (more->num_entries > 0U) {
#line 861
    if (hol->num_entries == 0U) {
#line 863
      hol->num_entries = more->num_entries;
#line 864
      hol->entries = more->entries;
#line 865
      hol->short_options = more->short_options;
#line 866
      more->num_entries = 0U;
    } else {
      {
#line 875
      num_entries = hol->num_entries + more->num_entries;
#line 876
      tmp = malloc((unsigned long )num_entries * sizeof(struct hol_entry ));
#line 876
      entries = (struct hol_entry *)tmp;
#line 878
      tmp___0 = strlen((char const   *)hol->short_options);
#line 878
      hol_so_len = (unsigned int )tmp___0;
#line 879
      tmp___1 = strlen((char const   *)more->short_options);
#line 879
      tmp___2 = malloc(((size_t )hol_so_len + tmp___1) + 1UL);
#line 879
      short_options = (char *)tmp___2;
      }
#line 882
      if (entries) {
#line 882
        if (! short_options) {
          {
#line 882
          __assert_fail("entries && short_options", "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c",
                        882U, "hol_append");
          }
        }
      } else {
        {
#line 882
        __assert_fail("entries && short_options", "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c",
                      882U, "hol_append");
        }
      }
      {
#line 886
      tmp___5 = mempcpy((void */* __restrict  */)entries, (void const   */* __restrict  */)hol->entries,
                        (unsigned long )hol->num_entries * sizeof(struct hol_entry ));
#line 886
      mempcpy((void */* __restrict  */)tmp___5, (void const   */* __restrict  */)more->entries,
              (unsigned long )more->num_entries * sizeof(struct hol_entry ));
#line 891
      mempcpy((void */* __restrict  */)short_options, (void const   */* __restrict  */)hol->short_options,
              (size_t )hol_so_len);
#line 894
      e = entries;
#line 894
      left = hol->num_entries;
      }
      {
#line 894
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 894
        if (! (left > 0U)) {
#line 894
          goto while_break___0;
        }
#line 895
        e->short_options = short_options + (e->short_options - hol->short_options);
#line 894
        e ++;
#line 894
        left --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 900
      so = short_options + hol_so_len;
#line 901
      more_so = more->short_options;
#line 902
      left = more->num_entries;
      {
#line 902
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 902
        if (! (left > 0U)) {
#line 902
          goto while_break___1;
        }
#line 907
        e->short_options = so;
#line 909
        opts_left = (int )e->num;
#line 909
        opt = e->opt;
        {
#line 909
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 909
          if (! opts_left) {
#line 909
            goto while_break___2;
          }
          {
#line 911
          ch = (int )*more_so;
#line 912
          tmp___8 = _option_is_short(opt);
          }
#line 912
          if (tmp___8) {
#line 912
            if (ch == (int )opt->key) {
              {
#line 915
              tmp___7 = find_char((char )ch, short_options, short_options + hol_so_len);
              }
#line 915
              if (! tmp___7) {
#line 919
                tmp___6 = so;
#line 919
                so ++;
#line 919
                *tmp___6 = (char )ch;
              }
#line 920
              more_so ++;
            }
          }
#line 909
          opt ++;
#line 909
          opts_left --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 902
        e ++;
#line 902
        left --;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 925
      *so = (char )'\000';
#line 927
      free((void *)hol->entries);
#line 928
      free((void *)hol->short_options);
#line 930
      hol->entries = entries;
#line 931
      hol->num_entries = num_entries;
#line 932
      hol->short_options = short_options;
      }
    }
  }
  {
#line 936
  hol_free(more);
  }
#line 937
  return;
}
}
#line 940 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void indent_to(argp_fmtstream_t stream , unsigned int col ) 
{ 
  int needed ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 943
  tmp = argp_fmtstream_point(stream);
#line 943
  needed = (int )((size_t )col - tmp);
  }
  {
#line 944
  while (1) {
    while_continue: /* CIL Label */ ;
#line 944
    tmp___0 = needed;
#line 944
    needed --;
#line 944
    if (! (tmp___0 > 0)) {
#line 944
      goto while_break;
    }
    {
#line 945
    argp_fmtstream_putc(stream, ' ');
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 946
  return;
}
}
#line 950 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void space(argp_fmtstream_t stream , size_t ensure ) 
{ 
  size_t tmp ;

  {
  {
#line 953
  tmp = argp_fmtstream_point(stream);
  }
#line 953
  if (tmp + ensure >= stream->rmargin) {
    {
#line 955
    argp_fmtstream_putc(stream, '\n');
    }
  } else {
    {
#line 957
    argp_fmtstream_putc(stream, ' ');
    }
  }
#line 958
  return;
}
}
#line 963 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void arg(struct argp_option  const  *real , char const   *req_fmt , char const   *opt_fmt ,
                char const   *domain , argp_fmtstream_t stream ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 967
  if (real->arg) {
#line 969
    if (real->flags & 1) {
      {
#line 970
      tmp = dgettext(domain, (char const   *)real->arg);
#line 970
      argp_fmtstream_printf(stream, opt_fmt, tmp);
      }
    } else {
      {
#line 973
      tmp___0 = dgettext(domain, (char const   *)real->arg);
#line 973
      argp_fmtstream_printf(stream, req_fmt, tmp___0);
      }
    }
  }
#line 976
  return;
}
}
#line 1012 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static char const   *filter_doc(char const   *doc___0 , int key , struct argp  const  *argp___0 ,
                                struct argp_state  const  *state ) 
{ 
  void *input ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1016
  if (argp___0->help_filter) {
    {
#line 1019
    tmp = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
#line 1019
    input = tmp;
#line 1020
    tmp___0 = (*(argp___0->help_filter))(key, doc___0, input);
    }
#line 1020
    return ((char const   *)tmp___0);
  } else {
#line 1024
    return (doc___0);
  }
}
}
#line 1032 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void print_header___0(char const   *str , struct argp  const  *argp___0 , struct pentry_state *pest ) 
{ 
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  char const   *tmp___0 ;

  {
  {
#line 1036
  tmp = dgettext((char const   *)argp___0->argp_domain, str);
#line 1036
  tstr = (char const   *)tmp;
#line 1037
  tmp___0 = filter_doc(tstr, 33554435, argp___0, pest->state);
#line 1037
  fstr = tmp___0;
  }
#line 1039
  if (fstr) {
#line 1041
    if (*fstr) {
#line 1043
      if ((pest->hhstate)->prev_entry) {
        {
#line 1045
        argp_fmtstream_putc(pest->stream, '\n');
        }
      }
      {
#line 1046
      indent_to(pest->stream, (unsigned int )uparams.header_col);
#line 1047
      argp_fmtstream_set_lmargin(pest->stream, (size_t )uparams.header_col);
#line 1048
      argp_fmtstream_set_wmargin(pest->stream, (size_t )uparams.header_col);
#line 1049
      argp_fmtstream_puts(pest->stream, fstr);
#line 1050
      argp_fmtstream_set_lmargin(pest->stream, (size_t )0);
#line 1051
      argp_fmtstream_putc(pest->stream, '\n');
      }
    }
#line 1054
    (pest->hhstate)->sep_groups = 1;
  }
#line 1057
  if ((unsigned long )fstr != (unsigned long )tstr) {
    {
#line 1058
    free((void *)((char *)fstr));
    }
  }
#line 1059
  return;
}
}
#line 1065 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void comma(unsigned int col , struct pentry_state *pest ) 
{ 
  struct hol_entry  const  *pe ;
  struct hol_cluster  const  *cl ;
  int old_wm ;
  int tmp ;

  {
#line 1068
  if (pest->first) {
#line 1070
    pe = (struct hol_entry  const  *)(pest->hhstate)->prev_entry;
#line 1071
    cl = (struct hol_cluster  const  *)(pest->entry)->cluster;
#line 1073
    if ((pest->hhstate)->sep_groups) {
#line 1073
      if (pe) {
#line 1073
        if ((pest->entry)->group != pe->group) {
          {
#line 1074
          argp_fmtstream_putc(pest->stream, '\n');
          }
        }
      }
    }
#line 1076
    if (cl) {
#line 1076
      if (cl->header) {
#line 1076
        if (*(cl->header)) {
#line 1076
          if (! pe) {
            {
#line 1085
            old_wm = (int )(pest->stream)->wmargin;
#line 1086
            print_header___0((char const   *)cl->header, (struct argp  const  *)cl->argp,
                             pest);
#line 1087
            argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
            }
          } else
#line 1076
          if ((unsigned long )pe->cluster != (unsigned long )cl) {
            {
#line 1076
            tmp = hol_cluster_is_child((struct hol_cluster  const  *)pe->cluster,
                                       cl);
            }
#line 1076
            if (! tmp) {
              {
#line 1085
              old_wm = (int )(pest->stream)->wmargin;
#line 1086
              print_header___0((char const   *)cl->header, (struct argp  const  *)cl->argp,
                               pest);
#line 1087
              argp_fmtstream_set_wmargin(pest->stream, (size_t )old_wm);
              }
            }
          }
        }
      }
    }
#line 1090
    pest->first = 0;
  } else {
    {
#line 1093
    argp_fmtstream_puts(pest->stream, ", ");
    }
  }
  {
#line 1095
  indent_to(pest->stream, col);
  }
#line 1096
  return;
}
}
#line 1099 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_entry_help(struct hol_entry *entry___0 , struct argp_state  const  *state ,
                           argp_fmtstream_t stream , struct hol_help_state *hhstate ) 
{ 
  unsigned int num ;
  struct argp_option  const  *real ;
  struct argp_option  const  *opt ;
  char *so ;
  int have_long_opt ;
  int old_lm ;
  size_t tmp ;
  int old_wm ;
  struct pentry_state pest ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int first_long_opt ;
  int tmp___3 ;
  char const   *tstr ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *fstr ;
  char const   *tmp___6 ;
  unsigned int col ;
  size_t tmp___7 ;

  {
  {
#line 1104
  real = entry___0->opt;
#line 1105
  so = entry___0->short_options;
#line 1106
  have_long_opt = 0;
#line 1108
  tmp = argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1108
  old_lm = (int )tmp;
#line 1109
  old_wm = (int )stream->wmargin;
#line 1114
  pest.entry = (struct hol_entry  const  *)entry___0;
#line 1115
  pest.stream = stream;
#line 1116
  pest.hhstate = hhstate;
#line 1117
  pest.first = 1;
#line 1118
  pest.state = state;
  }
#line 1120
  if (! (real->flags & 8)) {
#line 1121
    opt = real;
#line 1121
    num = entry___0->num;
    {
#line 1121
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1121
      if (! (num > 0U)) {
#line 1121
        goto while_break;
      }
#line 1122
      if (opt->name) {
#line 1122
        if (! (opt->flags & 2)) {
#line 1124
          have_long_opt = 1;
#line 1125
          goto while_break;
        }
      }
#line 1121
      opt ++;
#line 1121
      num --;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1129
  argp_fmtstream_set_wmargin(stream, (size_t )uparams.short_opt_col);
#line 1130
  opt = real;
#line 1130
  num = entry___0->num;
  }
  {
#line 1130
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1130
    if (! (num > 0U)) {
#line 1130
      goto while_break___0;
    }
    {
#line 1131
    tmp___0 = _option_is_short(opt);
    }
#line 1131
    if (tmp___0) {
#line 1131
      if (opt->key == (int const   )*so) {
#line 1134
        if (! (opt->flags & 2)) {
          {
#line 1136
          comma((unsigned int )uparams.short_opt_col, & pest);
#line 1137
          argp_fmtstream_putc(stream, '-');
#line 1138
          argp_fmtstream_putc(stream, (int )*so);
          }
#line 1139
          if (! have_long_opt) {
            {
#line 1140
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1139
          if (uparams.dup_args) {
            {
#line 1140
            arg(real, " %s", "[%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1141
          if (real->arg) {
#line 1142
            hhstate->suppressed_dup_arg = 1;
          }
        }
#line 1144
        so ++;
      }
    }
#line 1130
    opt ++;
#line 1130
    num --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1148
  if (real->flags & 8) {
    {
#line 1151
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.doc_opt_col);
#line 1152
    opt = real;
#line 1152
    num = entry___0->num;
    }
    {
#line 1152
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1152
      if (! (num > 0U)) {
#line 1152
        goto while_break___1;
      }
#line 1153
      if (opt->name) {
#line 1153
        if (*(opt->name)) {
#line 1153
          if (! (opt->flags & 2)) {
            {
#line 1155
            comma((unsigned int )uparams.doc_opt_col, & pest);
            }
#line 1159
            if (opt->flags & 32) {
#line 1159
              tmp___2 = opt->name;
            } else {
              {
#line 1159
              tmp___1 = dgettext((char const   *)(state->root_argp)->argp_domain,
                                 (char const   *)opt->name);
#line 1159
              tmp___2 = (char const   */* const  */)tmp___1;
              }
            }
            {
#line 1159
            argp_fmtstream_puts(stream, (char const   *)tmp___2);
            }
          }
        }
      }
#line 1152
      opt ++;
#line 1152
      num --;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1169
    first_long_opt = 1;
#line 1171
    argp_fmtstream_set_wmargin(stream, (size_t )uparams.long_opt_col);
#line 1172
    opt = real;
#line 1172
    num = entry___0->num;
    }
    {
#line 1172
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1172
      if (! (num > 0U)) {
#line 1172
        goto while_break___2;
      }
#line 1173
      if (opt->name) {
#line 1173
        if (! (opt->flags & 2)) {
          {
#line 1175
          comma((unsigned int )uparams.long_opt_col, & pest);
#line 1176
          argp_fmtstream_printf(stream, "--%s", opt->name);
          }
#line 1177
          if (first_long_opt) {
            {
#line 1178
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1177
          if (uparams.dup_args) {
            {
#line 1178
            arg(real, "=%s", "[=%s]", (char const   *)(state->root_argp)->argp_domain,
                stream);
            }
          } else
#line 1180
          if (real->arg) {
#line 1181
            hhstate->suppressed_dup_arg = 1;
          }
        }
      }
#line 1172
      opt ++;
#line 1172
      num --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1186
  argp_fmtstream_set_lmargin(stream, (size_t )0);
  }
#line 1188
  if (pest.first) {
    {
#line 1191
    tmp___3 = _option_is_short(real);
    }
#line 1191
    if (tmp___3) {
#line 1196
      goto cleanup;
    } else
#line 1191
    if (! real->name) {
      {
#line 1193
      print_header___0((char const   *)real->doc, entry___0->argp, & pest);
      }
    } else {
#line 1196
      goto cleanup;
    }
  } else {
#line 1200
    if (real->doc) {
      {
#line 1200
      tmp___4 = dgettext((char const   *)(state->root_argp)->argp_domain, (char const   *)real->doc);
#line 1200
      tmp___5 = tmp___4;
      }
    } else {
#line 1200
      tmp___5 = (char *)0;
    }
    {
#line 1200
    tstr = (char const   *)tmp___5;
#line 1202
    tmp___6 = filter_doc(tstr, (int )real->key, entry___0->argp, state);
#line 1202
    fstr = tmp___6;
    }
#line 1203
    if (fstr) {
#line 1203
      if (*fstr) {
        {
#line 1205
        tmp___7 = argp_fmtstream_point(stream);
#line 1205
        col = (unsigned int )tmp___7;
#line 1207
        argp_fmtstream_set_lmargin(stream, (size_t )uparams.opt_doc_col);
#line 1208
        argp_fmtstream_set_wmargin(stream, (size_t )uparams.opt_doc_col);
        }
#line 1210
        if (col > (unsigned int )(uparams.opt_doc_col + 3)) {
          {
#line 1211
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1212
        if (col >= (unsigned int )uparams.opt_doc_col) {
          {
#line 1213
          argp_fmtstream_puts(stream, "   ");
          }
        } else {
          {
#line 1215
          indent_to(stream, (unsigned int )uparams.opt_doc_col);
          }
        }
        {
#line 1217
        argp_fmtstream_puts(stream, fstr);
        }
      }
    }
#line 1219
    if (fstr) {
#line 1219
      if ((unsigned long )fstr != (unsigned long )tstr) {
        {
#line 1220
        free((void *)((char *)fstr));
        }
      }
    }
    {
#line 1223
    argp_fmtstream_set_lmargin(stream, (size_t )0);
#line 1224
    argp_fmtstream_putc(stream, '\n');
    }
  }
#line 1227
  hhstate->prev_entry = entry___0;
  cleanup: 
  {
#line 1230
  argp_fmtstream_set_lmargin(stream, (size_t )old_lm);
#line 1231
  argp_fmtstream_set_wmargin(stream, (size_t )old_wm);
  }
#line 1232
  return;
}
}
#line 1235 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_help(struct hol *hol , struct argp_state  const  *state , argp_fmtstream_t stream ) 
{ 
  unsigned int num ;
  struct hol_entry *entry___0 ;
  struct hol_help_state hhstate ;
  char const   *tstr ;
  char *tmp ;
  char const   *fstr ;
  struct argp  const  *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 1241
  hhstate.prev_entry = (struct hol_entry *)0;
#line 1241
  hhstate.sep_groups = 0;
#line 1241
  hhstate.suppressed_dup_arg = 0;
#line 1243
  entry___0 = hol->entries;
#line 1243
  num = hol->num_entries;
  {
#line 1243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1243
    if (! (num > 0U)) {
#line 1243
      goto while_break;
    }
    {
#line 1244
    hol_entry_help(entry___0, state, stream, & hhstate);
#line 1243
    entry___0 ++;
#line 1243
    num --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1246
  if (hhstate.suppressed_dup_arg) {
#line 1246
    if (uparams.dup_args_note) {
      {
#line 1248
      tmp = dgettext((char const   *)(state->root_argp)->argp_domain, "Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options.");
#line 1248
      tstr = (char const   *)tmp;
      }
#line 1251
      if (state) {
#line 1251
        tmp___0 = state->root_argp;
      } else {
#line 1251
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1251
      tmp___1 = filter_doc(tstr, 33554437, (struct argp  const  *)tmp___0, state);
#line 1251
      fstr = tmp___1;
      }
#line 1253
      if (fstr) {
#line 1253
        if (*fstr) {
          {
#line 1255
          argp_fmtstream_putc(stream, '\n');
#line 1256
          argp_fmtstream_puts(stream, fstr);
#line 1257
          argp_fmtstream_putc(stream, '\n');
          }
        }
      }
#line 1259
      if (fstr) {
#line 1259
        if ((unsigned long )fstr != (unsigned long )tstr) {
          {
#line 1260
          free((void *)((char *)fstr));
          }
        }
      }
    }
  }
#line 1262
  return;
}
}
#line 1268 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int add_argless_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                 char const   *domain , void *cookie ) 
{ 
  char **snao_end ;
  char *tmp ;

  {
#line 1273
  snao_end = (char **)cookie;
#line 1274
  if (! opt->arg) {
#line 1274
    if (! real->arg) {
#line 1274
      if (! ((opt->flags | real->flags) & 16)) {
#line 1276
        tmp = *snao_end;
#line 1276
        (*snao_end) ++;
#line 1276
        *tmp = (char )opt->key;
      }
    }
  }
#line 1277
  return (0);
}
}
#line 1282 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int usage_argful_short_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                                  char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 1287
  stream = (argp_fmtstream_t )cookie;
#line 1288
  arg___0 = (char const   *)opt->arg;
#line 1289
  flags = (int )(opt->flags | real->flags);
#line 1291
  if (! arg___0) {
#line 1292
    arg___0 = (char const   *)real->arg;
  }
#line 1294
  if (arg___0) {
#line 1294
    if (! (flags & 16)) {
      {
#line 1296
      tmp = dgettext(domain, arg___0);
#line 1296
      arg___0 = (char const   *)tmp;
      }
#line 1298
      if (flags & 1) {
        {
#line 1299
        argp_fmtstream_printf(stream, " [-%c[%s]]", opt->key, arg___0);
        }
      } else {
        {
#line 1304
        tmp___0 = strlen(arg___0);
#line 1304
        space(stream, 6UL + tmp___0);
#line 1305
        argp_fmtstream_printf(stream, "[-%c %s]", opt->key, arg___0);
        }
      }
    }
  }
#line 1309
  return (0);
}
}
#line 1314 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int usage_long_opt(struct argp_option  const  *opt , struct argp_option  const  *real ,
                          char const   *domain , void *cookie ) 
{ 
  argp_fmtstream_t stream ;
  char const   *arg___0 ;
  int flags ;
  char *tmp ;

  {
#line 1319
  stream = (argp_fmtstream_t )cookie;
#line 1320
  arg___0 = (char const   *)opt->arg;
#line 1321
  flags = (int )(opt->flags | real->flags);
#line 1323
  if (! arg___0) {
#line 1324
    arg___0 = (char const   *)real->arg;
  }
#line 1326
  if (! (flags & 16)) {
#line 1326
    if (! (opt->flags & 8)) {
#line 1328
      if (arg___0) {
        {
#line 1330
        tmp = dgettext(domain, arg___0);
#line 1330
        arg___0 = (char const   *)tmp;
        }
#line 1331
        if (flags & 1) {
          {
#line 1332
          argp_fmtstream_printf(stream, " [--%s[=%s]]", opt->name, arg___0);
          }
        } else {
          {
#line 1334
          argp_fmtstream_printf(stream, " [--%s=%s]", opt->name, arg___0);
          }
        }
      } else {
        {
#line 1337
        argp_fmtstream_printf(stream, " [--%s]", opt->name);
        }
      }
    }
  }
#line 1340
  return (0);
}
}
#line 1344 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void hol_usage(struct hol *hol , argp_fmtstream_t stream ) 
{ 
  unsigned int nentries ;
  struct hol_entry *entry___0 ;
  char *short_no_arg_opts ;
  size_t tmp ;
  void *tmp___0 ;
  char *snao_end ;
  char *tmp___1 ;

  {
#line 1347
  if (hol->num_entries > 0U) {
    {
#line 1351
    tmp = strlen((char const   *)hol->short_options);
#line 1351
    tmp___0 = __builtin_alloca(tmp + 1UL);
#line 1351
    short_no_arg_opts = (char *)tmp___0;
#line 1352
    snao_end = short_no_arg_opts;
#line 1355
    entry___0 = hol->entries;
#line 1355
    nentries = hol->num_entries;
    }
    {
#line 1355
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1355
      if (! (nentries > 0U)) {
#line 1355
        goto while_break;
      }
      {
#line 1358
      hol_entry_short_iterate((struct hol_entry  const  *)entry___0, & add_argless_short_opt,
                              (char const   *)(entry___0->argp)->argp_domain, (void *)(& snao_end));
#line 1355
      entry___0 ++;
#line 1355
      nentries --;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1360
    if ((unsigned long )snao_end > (unsigned long )short_no_arg_opts) {
      {
#line 1362
      tmp___1 = snao_end;
#line 1362
      snao_end ++;
#line 1362
      *tmp___1 = (char)0;
#line 1363
      argp_fmtstream_printf(stream, " [-%s]", short_no_arg_opts);
      }
    }
#line 1367
    entry___0 = hol->entries;
#line 1367
    nentries = hol->num_entries;
    {
#line 1367
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1367
      if (! (nentries > 0U)) {
#line 1367
        goto while_break___0;
      }
      {
#line 1370
      hol_entry_short_iterate((struct hol_entry  const  *)entry___0, & usage_argful_short_opt,
                              (char const   *)(entry___0->argp)->argp_domain, (void *)stream);
#line 1367
      entry___0 ++;
#line 1367
      nentries --;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1374
    entry___0 = hol->entries;
#line 1374
    nentries = hol->num_entries;
    {
#line 1374
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1374
      if (! (nentries > 0U)) {
#line 1374
        goto while_break___1;
      }
      {
#line 1377
      hol_entry_long_iterate((struct hol_entry  const  *)entry___0, & usage_long_opt,
                             (char const   *)(entry___0->argp)->argp_domain, (void *)stream);
#line 1374
      entry___0 ++;
#line 1374
      nentries --;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1380
  return;
}
}
#line 1384 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static struct hol *argp_hol(struct argp  const  *argp___0 , struct hol_cluster *cluster ) 
{ 
  struct argp_child  const  *child ;
  struct hol *hol ;
  struct hol *tmp ;
  struct hol_cluster *child_cluster ;
  struct hol_cluster *tmp___0 ;
  struct hol_cluster *tmp___1 ;
  struct hol *tmp___2 ;

  {
  {
#line 1387
  child = (struct argp_child  const  *)argp___0->children;
#line 1388
  tmp = make_hol(argp___0, cluster);
#line 1388
  hol = tmp;
  }
#line 1389
  if (child) {
    {
#line 1390
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1390
      if (! child->argp) {
#line 1390
        goto while_break;
      }
#line 1392
      if (child->group) {
        {
#line 1392
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1392
        tmp___1 = tmp___0;
        }
      } else
#line 1392
      if (child->header) {
        {
#line 1392
        tmp___0 = hol_add_cluster(hol, (int )child->group, (char const   *)child->header,
                                  (int )(child - (struct argp_child  const  *)argp___0->children),
                                  cluster, argp___0);
#line 1392
        tmp___1 = tmp___0;
        }
      } else {
#line 1392
        tmp___1 = cluster;
      }
      {
#line 1392
      child_cluster = tmp___1;
#line 1399
      tmp___2 = argp_hol((struct argp  const  *)child->argp, child_cluster);
#line 1399
      hol_append(hol, tmp___2);
#line 1400
      child ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1402
  return (hol);
}
}
#line 1407 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static size_t argp_args_levels(struct argp  const  *argp___0 ) 
{ 
  size_t levels ;
  struct argp_child  const  *child ;
  char *tmp ;
  struct argp_child  const  *tmp___0 ;
  size_t tmp___1 ;

  {
#line 1410
  levels = (size_t )0;
#line 1411
  child = (struct argp_child  const  *)argp___0->children;
#line 1413
  if (argp___0->args_doc) {
    {
#line 1413
    tmp = strchr((char const   *)argp___0->args_doc, '\n');
    }
#line 1413
    if (tmp) {
#line 1414
      levels ++;
    }
  }
#line 1416
  if (child) {
    {
#line 1417
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1417
      if (! child->argp) {
#line 1417
        goto while_break;
      }
      {
#line 1418
      tmp___0 = child;
#line 1418
      child ++;
#line 1418
      tmp___1 = argp_args_levels((struct argp  const  *)tmp___0->argp);
#line 1418
      levels += tmp___1;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1420
  return (levels);
}
}
#line 1428 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int argp_args_usage(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                           char **levels , int advance , argp_fmtstream_t stream ) 
{ 
  char *our_level ;
  int multiple ;
  struct argp_child  const  *child ;
  char const   *tdoc ;
  char *tmp ;
  char const   *nl ;
  char const   *fdoc ;
  char const   *tmp___0 ;
  char const   *cp ;
  char *tmp___1 ;
  int i ;
  char *tmp___2 ;
  struct argp_child  const  *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1432
  our_level = *levels;
#line 1433
  multiple = 0;
#line 1434
  child = (struct argp_child  const  *)argp___0->children;
#line 1435
  tmp = dgettext((char const   *)argp___0->argp_domain, (char const   *)argp___0->args_doc);
#line 1435
  tdoc = (char const   *)tmp;
#line 1435
  nl = (char const   *)0;
#line 1436
  tmp___0 = filter_doc(tdoc, 33554438, argp___0, state);
#line 1436
  fdoc = tmp___0;
  }
#line 1438
  if (fdoc) {
    {
#line 1440
    cp = fdoc;
#line 1441
    tmp___1 = strchrnul(cp, '\n');
#line 1441
    nl = (char const   *)tmp___1;
    }
#line 1442
    if ((int const   )*nl != 0) {
#line 1447
      multiple = 1;
#line 1448
      i = 0;
      {
#line 1448
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1448
        if (! (i < (int )*our_level)) {
#line 1448
          goto while_break;
        }
        {
#line 1449
        cp = nl + 1;
#line 1449
        tmp___2 = strchrnul(cp, '\n');
#line 1449
        nl = (char const   *)tmp___2;
#line 1448
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 1450
      (*levels) ++;
    }
    {
#line 1455
    space(stream, (size_t )((nl + 1) - cp));
#line 1457
    argp_fmtstream_write(stream, cp, (size_t )(nl - cp));
    }
  }
#line 1459
  if (fdoc) {
#line 1459
    if ((unsigned long )fdoc != (unsigned long )tdoc) {
      {
#line 1460
      free((void *)((char *)fdoc));
      }
    }
  }
#line 1462
  if (child) {
    {
#line 1463
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1463
      if (! child->argp) {
#line 1463
        goto while_break___0;
      }
      {
#line 1464
      tmp___3 = child;
#line 1464
      child ++;
#line 1464
      tmp___4 = argp_args_usage((struct argp  const  *)tmp___3->argp, state, levels,
                                advance, stream);
      }
#line 1464
      if (tmp___4) {
#line 1464
        tmp___5 = 0;
      } else {
#line 1464
        tmp___5 = 1;
      }
#line 1464
      advance = tmp___5;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1466
  if (advance) {
#line 1466
    if (multiple) {
#line 1469
      if (*nl) {
#line 1472
        *our_level = (char )((int )*our_level + 1);
#line 1473
        advance = 0;
      } else
#line 1475
      if ((int )*our_level > 0) {
#line 1477
        *our_level = (char)0;
      }
    }
  }
#line 1480
  return (! advance);
}
}
#line 1490 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static int argp_doc(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                    int post , int pre_blank , int first_only , argp_fmtstream_t stream ) 
{ 
  char const   *text ;
  char const   *inp_text ;
  size_t inp_text_len ;
  char const   *trans_text ;
  void *input ;
  int anything ;
  struct argp_child  const  *child ;
  char *vt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  struct argp_child  const  *tmp___8 ;
  int tmp___9 ;

  {
#line 1497
  inp_text_len = (size_t )0;
#line 1499
  input = (void *)0;
#line 1500
  anything = 0;
#line 1501
  child = (struct argp_child  const  *)argp___0->children;
#line 1503
  if (argp___0->doc) {
    {
#line 1505
    tmp = strchr((char const   *)argp___0->doc, '\v');
#line 1505
    vt = tmp;
    }
#line 1506
    if (vt) {
#line 1508
      if (post) {
#line 1510
        inp_text = (char const   *)(vt + 1);
#line 1511
        if (! *inp_text) {
#line 1512
          inp_text = (char const   *)0;
        }
      } else {
#line 1516
        inp_text_len = (size_t )(vt - (char *)argp___0->doc);
#line 1517
        if (inp_text_len) {
          {
#line 1517
          tmp___0 = strndup((char const   *)argp___0->doc, inp_text_len);
#line 1517
          inp_text = (char const   *)tmp___0;
          }
        } else {
#line 1517
          inp_text = (char const   *)0;
        }
      }
    } else
#line 1521
    if (post) {
#line 1521
      inp_text = (char const   *)0;
    } else {
#line 1521
      inp_text = (char const   *)argp___0->doc;
    }
#line 1522
    if (inp_text) {
      {
#line 1522
      tmp___1 = dgettext((char const   *)argp___0->argp_domain, inp_text);
#line 1522
      trans_text = (char const   *)tmp___1;
      }
    } else {
#line 1522
      trans_text = (char const   *)((void *)0);
    }
  } else {
#line 1525
    inp_text = (char const   *)0;
#line 1525
    trans_text = inp_text;
  }
#line 1527
  if (argp___0->help_filter) {
    {
#line 1530
    input = _argp_input((struct argp  const  */* __restrict  */)argp___0, (struct argp_state  const  */* __restrict  */)state);
    }
#line 1531
    if (post) {
#line 1531
      tmp___2 = 33554434;
    } else {
#line 1531
      tmp___2 = 33554433;
    }
    {
#line 1531
    tmp___3 = (*(argp___0->help_filter))(tmp___2, trans_text, input);
#line 1531
    text = (char const   *)tmp___3;
    }
  } else {
#line 1538
    text = trans_text;
  }
#line 1540
  if (text) {
#line 1542
    if (pre_blank) {
      {
#line 1543
      argp_fmtstream_putc(stream, '\n');
      }
    }
    {
#line 1545
    argp_fmtstream_puts(stream, text);
#line 1547
    tmp___4 = argp_fmtstream_point(stream);
    }
#line 1547
    if (tmp___4 > stream->lmargin) {
      {
#line 1548
      argp_fmtstream_putc(stream, '\n');
      }
    }
#line 1550
    anything = 1;
  }
#line 1553
  if (text) {
#line 1553
    if ((unsigned long )text != (unsigned long )trans_text) {
      {
#line 1554
      free((void *)((char *)text));
      }
    }
  }
#line 1556
  if (inp_text) {
#line 1556
    if (inp_text_len) {
      {
#line 1557
      free((void *)((char *)inp_text));
      }
    }
  }
#line 1559
  if (post) {
#line 1559
    if (argp___0->help_filter) {
      {
#line 1562
      tmp___5 = (*(argp___0->help_filter))(33554436, (char const   *)0, input);
#line 1562
      text = (char const   *)tmp___5;
      }
#line 1563
      if (text) {
#line 1565
        if (anything) {
          {
#line 1566
          argp_fmtstream_putc(stream, '\n');
          }
        } else
#line 1565
        if (pre_blank) {
          {
#line 1566
          argp_fmtstream_putc(stream, '\n');
          }
        }
        {
#line 1567
        argp_fmtstream_puts(stream, text);
#line 1568
        free((void *)((char *)text));
#line 1569
        tmp___6 = argp_fmtstream_point(stream);
        }
#line 1569
        if (tmp___6 > stream->lmargin) {
          {
#line 1571
          argp_fmtstream_putc(stream, '\n');
          }
        }
#line 1572
        anything = 1;
      }
    }
  }
#line 1576
  if (child) {
    {
#line 1577
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1577
      if (child->argp) {
#line 1577
        if (first_only) {
#line 1577
          if (anything) {
#line 1577
            goto while_break;
          }
        }
      } else {
#line 1577
        goto while_break;
      }
#line 1578
      if (anything) {
#line 1578
        tmp___7 = 1;
      } else
#line 1578
      if (pre_blank) {
#line 1578
        tmp___7 = 1;
      } else {
#line 1578
        tmp___7 = 0;
      }
      {
#line 1578
      tmp___8 = child;
#line 1578
      child ++;
#line 1578
      tmp___9 = argp_doc((struct argp  const  *)tmp___8->argp, state, post, tmp___7,
                         first_only, stream);
#line 1578
      anything |= tmp___9;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1583
  return (anything);
}
}
#line 1590 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
static void _help(struct argp  const  *argp___0 , struct argp_state  const  *state ,
                  FILE *stream , unsigned int flags , char *name ) 
{ 
  int anything ;
  struct hol *hol ;
  argp_fmtstream_t fs ;
  int first_pattern ;
  int more_patterns ;
  size_t num_pattern_levels ;
  size_t tmp ;
  char *pattern_levels ;
  void *tmp___0 ;
  int old_lm ;
  int old_wm ;
  size_t tmp___1 ;
  char *levels ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
#line 1594
  anything = 0;
#line 1595
  hol = (struct hol *)0;
#line 1598
  if (! stream) {
#line 1599
    return;
  }
  {
#line 1602
  flockfile(stream);
  }
#line 1605
  if (! uparams.valid) {
    {
#line 1606
    fill_in_uparams(state);
    }
  }
  {
#line 1608
  fs = argp_make_fmtstream(stream, (size_t )0, (size_t )uparams.rmargin, (ssize_t )0);
  }
#line 1609
  if (! fs) {
    {
#line 1612
    funlockfile(stream);
    }
#line 1614
    return;
  }
#line 1617
  if (flags & 11U) {
    {
#line 1619
    hol = argp_hol(argp___0, (struct hol_cluster *)0);
#line 1622
    hol_set_group(hol, "help", -1);
#line 1623
    hol_set_group(hol, "version", -1);
#line 1625
    hol_sort(hol);
    }
  }
#line 1628
  if (flags & 3U) {
    {
#line 1631
    first_pattern = 1;
#line 1632
    tmp = argp_args_levels(argp___0);
#line 1632
    num_pattern_levels = tmp;
#line 1633
    tmp___0 = __builtin_alloca(num_pattern_levels);
#line 1633
    pattern_levels = (char *)tmp___0;
#line 1635
    memset((void *)pattern_levels, 0, num_pattern_levels);
    }
    {
#line 1637
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1640
      tmp___1 = argp_fmtstream_set_wmargin(fs, (size_t )uparams.usage_indent);
#line 1640
      old_wm = (int )tmp___1;
#line 1641
      levels = pattern_levels;
      }
#line 1643
      if (first_pattern) {
        {
#line 1644
        tmp___2 = dgettext((char const   *)argp___0->argp_domain, "Usage:");
#line 1644
        argp_fmtstream_printf(fs, "%s %s", tmp___2, name);
        }
      } else {
        {
#line 1648
        tmp___3 = dgettext((char const   *)argp___0->argp_domain, "  or: ");
#line 1648
        argp_fmtstream_printf(fs, "%s %s", tmp___3, name);
        }
      }
      {
#line 1654
      tmp___4 = argp_fmtstream_set_lmargin(fs, (size_t )uparams.usage_indent);
#line 1654
      old_lm = (int )tmp___4;
      }
#line 1656
      if (flags & 2U) {
#line 1659
        if (hol->num_entries > 0U) {
          {
#line 1660
          tmp___5 = dgettext((char const   *)argp___0->argp_domain, " [OPTION...]");
#line 1660
          argp_fmtstream_puts(fs, (char const   *)tmp___5);
          }
        }
      } else {
        {
#line 1666
        hol_usage(hol, fs);
#line 1667
        flags |= 2U;
        }
      }
      {
#line 1670
      more_patterns = argp_args_usage(argp___0, state, & levels, 1, fs);
#line 1672
      argp_fmtstream_set_wmargin(fs, (size_t )old_wm);
#line 1673
      argp_fmtstream_set_lmargin(fs, (size_t )old_lm);
#line 1675
      argp_fmtstream_putc(fs, '\n');
#line 1676
      anything = 1;
#line 1678
      first_pattern = 0;
      }
#line 1637
      if (! more_patterns) {
#line 1637
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1683
  if (flags & 16U) {
    {
#line 1684
    tmp___6 = argp_doc(argp___0, state, 0, 0, 1, fs);
#line 1684
    anything |= tmp___6;
    }
  }
#line 1686
  if (flags & 4U) {
    {
#line 1688
    tmp___7 = dgettext((char const   *)argp___0->argp_domain, "Try \'%s --help\' or \'%s --usage\' for more information.\n");
#line 1688
    argp_fmtstream_printf(fs, (char const   *)tmp___7, name, name);
#line 1691
    anything = 1;
    }
  }
#line 1694
  if (flags & 8U) {
#line 1698
    if (hol->num_entries > 0U) {
#line 1700
      if (anything) {
        {
#line 1701
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1702
      hol_help(hol, state, fs);
#line 1703
      anything = 1;
      }
    }
  }
#line 1707
  if (flags & 32U) {
    {
#line 1709
    tmp___8 = argp_doc(argp___0, state, 1, anything, 0, fs);
#line 1709
    anything |= tmp___8;
    }
  }
#line 1711
  if (flags & 64U) {
#line 1711
    if (argp_program_bug_address) {
#line 1713
      if (anything) {
        {
#line 1714
        argp_fmtstream_putc(fs, '\n');
        }
      }
      {
#line 1715
      tmp___9 = dgettext((char const   *)argp___0->argp_domain, "Report bugs to %s.\n");
#line 1715
      argp_fmtstream_printf(fs, (char const   *)tmp___9, argp_program_bug_address);
#line 1718
      anything = 1;
      }
    }
  }
  {
#line 1722
  funlockfile(stream);
  }
#line 1725
  if (hol) {
    {
#line 1726
    hol_free(hol);
    }
  }
  {
#line 1728
  argp_fmtstream_free(fs);
  }
#line 1729
  return;
}
}
#line 1733 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
void argp_help(struct argp  const  * __restrict  argp___0 , FILE * __restrict  stream ,
               unsigned int flags , char * __restrict  name ) 
{ 
  struct argp_state state ;

  {
  {
#line 1737
  memset((void *)(& state), 0, sizeof(state));
#line 1738
  state.root_argp = (struct argp  const  *)argp___0;
#line 1739
  _help((struct argp  const  *)argp___0, (struct argp_state  const  *)(& state), (FILE *)stream,
        flags, (char *)name);
  }
#line 1740
  return;
}
}
#line 1765 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
void argp_state_help(struct argp_state  const  * __restrict  state , FILE * __restrict  stream ,
                     unsigned int flags ) 
{ 
  char *tmp ;
  struct argp  const  *tmp___0 ;

  {
#line 1768
  if (! state) {
#line 1768
    goto _L___0;
  } else
#line 1768
  if (! (state->flags & 2U)) {
    _L___0: /* CIL Label */ 
#line 1768
    if (stream) {
#line 1770
      if (state) {
#line 1770
        if (state->flags & 64U) {
#line 1771
          flags |= 128U;
        }
      }
#line 1773
      if (state) {
#line 1773
        tmp = state->name;
      } else {
#line 1773
        tmp = (char */* const  */)program_invocation_short_name;
      }
#line 1773
      if (state) {
#line 1773
        tmp___0 = state->root_argp;
      } else {
#line 1773
        tmp___0 = (struct argp  const  */* const  */)0;
      }
      {
#line 1773
      _help((struct argp  const  *)tmp___0, (struct argp_state  const  *)state, (FILE *)stream,
            flags, (char *)tmp);
      }
#line 1776
      if (! state) {
#line 1776
        goto _L;
      } else
#line 1776
      if (! (state->flags & 32U)) {
        _L: /* CIL Label */ 
#line 1778
        if (flags & 256U) {
          {
#line 1779
          exit(argp_err_exit_status);
          }
        }
#line 1780
        if (flags & 512U) {
          {
#line 1781
          exit(0);
          }
        }
      }
    }
  }
#line 1784
  return;
}
}
#line 1792 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
void ( /* format attribute */  argp_error)(struct argp_state  const  * __restrict  state ,
                                           char const   * __restrict  fmt  , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  va_list ap ;
  char *tmp___0 ;

  {
#line 1795
  if (! state) {
#line 1795
    goto _L;
  } else
#line 1795
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1797
    if (state) {
#line 1797
      tmp = state->err_stream;
    } else {
#line 1797
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1797
    stream = (FILE *)tmp;
#line 1799
    if (stream) {
      {
#line 1804
      flockfile(stream);
#line 1807
      __builtin_va_start(ap, fmt);
      }
#line 1826
      if (state) {
#line 1826
        tmp___0 = state->name;
      } else {
#line 1826
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1826
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
#line 1829
      fputc_unlocked(':', stream);
#line 1830
      fputc_unlocked(' ', stream);
#line 1832
      vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1834
      fputc_unlocked('\n', stream);
#line 1837
      argp_state_help(state, (FILE */* __restrict  */)stream, 260U);
#line 1839
      __builtin_va_end(ap);
#line 1842
      funlockfile(stream);
      }
    }
  }
#line 1846
  return;
}
}
#line 1859 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-help.c"
void ( /* format attribute */  argp_failure)(struct argp_state  const  * __restrict  state ,
                                             int status , int errnum , char const   * __restrict  fmt 
                                             , ...) 
{ 
  FILE *stream ;
  struct _IO_FILE *tmp ;
  char *tmp___0 ;
  va_list ap ;
  char buf[200] ;
  char const   *s ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1863
  if (! state) {
#line 1863
    goto _L;
  } else
#line 1863
  if (! (state->flags & 2U)) {
    _L: /* CIL Label */ 
#line 1865
    if (state) {
#line 1865
      tmp = state->err_stream;
    } else {
#line 1865
      tmp = (struct _IO_FILE */* const  */)stderr;
    }
#line 1865
    stream = (FILE *)tmp;
#line 1867
    if (stream) {
      {
#line 1870
      flockfile(stream);
      }
#line 1879
      if (state) {
#line 1879
        tmp___0 = state->name;
      } else {
#line 1879
        tmp___0 = (char */* const  */)program_invocation_short_name;
      }
      {
#line 1879
      fputs_unlocked((char const   */* __restrict  */)tmp___0, (FILE */* __restrict  */)stream);
      }
#line 1883
      if (fmt) {
        {
#line 1887
        __builtin_va_start(ap, fmt);
#line 1903
        fputc_unlocked(':', stream);
#line 1904
        fputc_unlocked(' ', stream);
#line 1906
        vfprintf((FILE */* __restrict  */)stream, fmt, ap);
#line 1909
        __builtin_va_end(ap);
        }
      }
#line 1912
      if (errnum) {
        {
#line 1923
        s = (char const   *)((void *)0);
#line 1924
        fputc_unlocked(':', stream);
#line 1925
        fputc_unlocked(' ', stream);
#line 1927
        tmp___1 = strerror_r(errnum, buf, sizeof(buf));
#line 1927
        s = (char const   *)tmp___1;
        }
#line 1933
        if (! s) {
          {
#line 1933
          tmp___3 = strerror(errnum);
#line 1933
          s = (char const   *)tmp___3;
          }
#line 1933
          if (! s) {
            {
#line 1934
            tmp___2 = dgettext((char const   *)(state->root_argp)->argp_domain, "Unknown system error");
#line 1934
            s = (char const   *)tmp___2;
            }
          }
        }
        {
#line 1937
        fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stream);
        }
      }
      {
#line 1946
      fputc_unlocked('\n', stream);
#line 1949
      funlockfile(stream);
      }
#line 1952
      if (status) {
#line 1952
        if (! state) {
          {
#line 1953
          exit(status);
          }
        } else
#line 1952
        if (! (state->flags & 32U)) {
          {
#line 1953
          exit(status);
          }
        }
      }
    }
  }
#line 1956
  return;
}
}
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 203 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
#pragma GCC diagnostic push
#line 203
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 203
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 355
#pragma GCC diagnostic pop
#line 344 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 675
extern size_t fwrite_unlocked(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                              FILE * __restrict  __stream ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 203 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.h"
#pragma GCC diagnostic push
#line 203
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 203
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 355
#pragma GCC diagnostic pop
#line 57 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.c"
argp_fmtstream_t argp_make_fmtstream(FILE *stream , size_t lmargin , size_t rmargin ,
                                     ssize_t wmargin ) 
{ 
  argp_fmtstream_t fs ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 63
  tmp = malloc(sizeof(struct argp_fmtstream ));
#line 63
  fs = (struct argp_fmtstream *)tmp;
  }
#line 64
  if ((unsigned long )fs != (unsigned long )((void *)0)) {
    {
#line 66
    fs->stream = stream;
#line 68
    fs->lmargin = lmargin;
#line 69
    fs->rmargin = rmargin;
#line 70
    fs->wmargin = wmargin;
#line 71
    fs->point_col = (ssize_t )0;
#line 72
    fs->point_offs = (size_t )0;
#line 74
    tmp___0 = malloc((size_t )200);
#line 74
    fs->buf = (char *)tmp___0;
    }
#line 75
    if (! fs->buf) {
      {
#line 77
      free((void *)fs);
#line 78
      fs = (argp_fmtstream_t )0;
      }
    } else {
#line 82
      fs->p = fs->buf;
#line 83
      fs->end = fs->buf + 200;
    }
  }
#line 87
  return (fs);
}
}
#line 97 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.c"
void argp_fmtstream_free(argp_fmtstream_t fs ) 
{ 


  {
  {
#line 100
  _argp_fmtstream_update(fs);
  }
#line 101
  if ((unsigned long )fs->p > (unsigned long )fs->buf) {
    {
#line 106
    fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                    (FILE */* __restrict  */)fs->stream);
    }
  }
  {
#line 109
  free((void *)fs->buf);
#line 110
  free((void *)fs);
  }
#line 111
  return;
}
}
#line 121 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.c"
void _argp_fmtstream_update(argp_fmtstream_t fs ) 
{ 
  char *buf ;
  char *nl ;
  size_t len ;
  size_t r ;
  size_t pad ;
  size_t i ;
  void *tmp ;
  char *p ;
  char *nextline ;
  int i___0 ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t mv ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 128
  buf = fs->buf + fs->point_offs;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (! ((unsigned long )buf < (unsigned long )fs->p)) {
#line 129
      goto while_break;
    }
#line 133
    if (fs->point_col == 0L) {
#line 133
      if (fs->lmargin != 0UL) {
#line 136
        pad = fs->lmargin;
#line 137
        if ((unsigned long )(fs->p + pad) < (unsigned long )fs->end) {
          {
#line 141
          memmove((void *)(buf + pad), (void const   *)buf, (size_t )(fs->p - buf));
#line 142
          fs->p += pad;
#line 143
          memset((void *)buf, ' ', pad);
#line 144
          buf += pad;
          }
        } else {
#line 150
          i = (size_t )0;
          {
#line 150
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 150
            if (! (i < pad)) {
#line 150
              goto while_break___0;
            }
            {
#line 157
            fputc_unlocked(' ', fs->stream);
#line 150
            i ++;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 160
        fs->point_col = (ssize_t )pad;
      }
    }
    {
#line 163
    len = (size_t )(fs->p - buf);
#line 164
    tmp = memchr((void const   *)buf, '\n', len);
#line 164
    nl = (char *)tmp;
    }
#line 166
    if (fs->point_col < 0L) {
#line 167
      fs->point_col = (ssize_t )0;
    }
#line 169
    if (! nl) {
#line 173
      if ((size_t )fs->point_col + len < fs->rmargin) {
#line 178
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 179
        goto while_break;
      } else {
#line 184
        nl = fs->p;
      }
    } else
#line 186
    if (fs->point_col + (nl - buf) < (ssize_t )fs->rmargin) {
#line 190
      fs->point_col = (ssize_t )0;
#line 191
      buf = nl + 1;
#line 192
      goto while_continue;
    }
#line 196
    r = fs->rmargin - 1UL;
#line 198
    if (fs->wmargin < 0L) {
#line 202
      if ((unsigned long )nl < (unsigned long )fs->p) {
        {
#line 204
        memmove((void *)(buf + (r - (size_t )fs->point_col)), (void const   *)nl,
                (size_t )(fs->p - nl));
#line 205
        fs->p -= (buf + (r - (size_t )fs->point_col)) - nl;
#line 207
        fs->point_col = (ssize_t )0;
#line 208
        buf += r + 1UL;
        }
      } else {
#line 215
        fs->point_col = (ssize_t )((size_t )fs->point_col + len);
#line 216
        fs->p -= (size_t )fs->point_col - r;
#line 217
        goto while_break;
      }
    } else {
#line 229
      p = buf + ((r + 1UL) - (size_t )fs->point_col);
      {
#line 230
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 230
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 230
          tmp___0 = __ctype_b_loc();
          }
#line 230
          if ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 1) {
#line 230
            goto while_break___1;
          }
        } else {
#line 230
          goto while_break___1;
        }
#line 231
        p --;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 232
      nextline = p + 1;
#line 234
      if ((unsigned long )nextline > (unsigned long )buf) {
#line 237
        if ((unsigned long )p >= (unsigned long )buf) {
          {
#line 238
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 239
            p --;
#line 238
            if ((unsigned long )p >= (unsigned long )buf) {
              {
#line 238
              tmp___1 = __ctype_b_loc();
              }
#line 238
              if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 1)) {
#line 238
                goto while_break___2;
              }
            } else {
#line 238
              goto while_break___2;
            }
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 241
        nl = p + 1;
      } else {
#line 247
        p = buf + ((r + 1UL) - (size_t )fs->point_col);
#line 249
        if ((unsigned long )p < (unsigned long )nl) {
          {
#line 250
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 251
            p ++;
#line 250
            if ((unsigned long )p < (unsigned long )nl) {
              {
#line 250
              tmp___2 = __ctype_b_loc();
              }
#line 250
              if ((int const   )*(*tmp___2 + (int )((unsigned char )*p)) & 1) {
#line 250
                goto while_break___3;
              }
            } else {
#line 250
              goto while_break___3;
            }
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 253
        if ((unsigned long )p == (unsigned long )nl) {
#line 256
          fs->point_col = (ssize_t )0;
#line 257
          buf = nl + 1;
#line 258
          goto while_continue;
        }
#line 261
        nl = p;
        {
#line 263
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 264
          p ++;
#line 263
          tmp___3 = __ctype_b_loc();
          }
#line 263
          if (! ((int const   )*(*tmp___3 + (int )((unsigned char )*p)) & 1)) {
#line 263
            goto while_break___4;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 267
        nextline = p;
      }
#line 275
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 275
        tmp___6 = fs->end - nl < fs->wmargin + 1L;
      } else {
#line 275
        tmp___6 = nextline - (nl + 1) < fs->wmargin;
      }
#line 275
      if (tmp___6) {
#line 275
        if ((unsigned long )fs->p > (unsigned long )nextline) {
#line 281
          if (fs->end - fs->p > fs->wmargin + 1L) {
            {
#line 284
            mv = (size_t )(fs->p - nextline);
#line 285
            memmove((void *)((nl + 1) + fs->wmargin), (void const   *)nextline, mv);
#line 286
            nextline = (nl + 1) + fs->wmargin;
#line 287
            len = (size_t )((nextline + mv) - buf);
#line 288
            tmp___4 = nl;
#line 288
            nl ++;
#line 288
            *tmp___4 = (char )'\n';
            }
          } else {
#line 297
            if ((unsigned long )nl > (unsigned long )fs->buf) {
              {
#line 298
              fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1,
                              (size_t )(nl - fs->buf), (FILE */* __restrict  */)fs->stream);
              }
            }
            {
#line 299
            fputc_unlocked('\n', fs->stream);
#line 302
            len += (size_t )(buf - fs->buf);
#line 303
            buf = fs->buf;
#line 303
            nl = buf;
            }
          }
        } else {
#line 309
          tmp___5 = nl;
#line 309
          nl ++;
#line 309
          *tmp___5 = (char )'\n';
        }
      } else {
#line 309
        tmp___5 = nl;
#line 309
        nl ++;
#line 309
        *tmp___5 = (char )'\n';
      }
#line 311
      if (nextline - nl >= fs->wmargin) {
#line 311
        goto _L;
      } else
#line 311
      if ((unsigned long )nextline == (unsigned long )((buf + len) + 1)) {
#line 311
        if (fs->end - nextline >= fs->wmargin) {
          _L: /* CIL Label */ 
#line 314
          i___0 = 0;
          {
#line 314
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 314
            if (! ((ssize_t )i___0 < fs->wmargin)) {
#line 314
              goto while_break___5;
            }
#line 315
            tmp___7 = nl;
#line 315
            nl ++;
#line 315
            *tmp___7 = (char )' ';
#line 314
            i___0 ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        } else {
#line 311
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 317
        i___0 = 0;
        {
#line 317
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 317
          if (! ((ssize_t )i___0 < fs->wmargin)) {
#line 317
            goto while_break___6;
          }
          {
#line 323
          fputc_unlocked(' ', fs->stream);
#line 317
          i___0 ++;
          }
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 327
      if ((unsigned long )nl < (unsigned long )nextline) {
        {
#line 328
        memmove((void *)nl, (void const   *)nextline, (size_t )((buf + len) - nextline));
        }
      }
#line 329
      len -= (size_t )(nextline - buf);
#line 332
      buf = nl;
#line 335
      fs->p = nl + len;
#line 340
      if (fs->wmargin) {
#line 340
        fs->point_col = fs->wmargin;
      } else {
#line 340
        fs->point_col = (ssize_t )-1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 345
  fs->point_offs = (size_t )(fs->p - fs->buf);
#line 346
  return;
}
}
#line 350 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.c"
int _argp_fmtstream_ensure(struct argp_fmtstream *fs , size_t amount ) 
{ 
  ssize_t wrote ;
  size_t tmp ;
  size_t old_size ;
  size_t new_size ;
  char *new_buf ;
  int *tmp___0 ;
  void *tmp___1 ;

  {
#line 353
  if ((size_t )(fs->end - fs->p) < amount) {
    {
#line 358
    _argp_fmtstream_update(fs);
#line 364
    tmp = fwrite_unlocked((void const   */* __restrict  */)fs->buf, (size_t )1, (size_t )(fs->p - fs->buf),
                          (FILE */* __restrict  */)fs->stream);
#line 364
    wrote = (ssize_t )tmp;
    }
#line 366
    if (wrote == fs->p - fs->buf) {
#line 368
      fs->p = fs->buf;
#line 369
      fs->point_offs = (size_t )0;
    } else {
      {
#line 373
      fs->p -= wrote;
#line 374
      fs->point_offs -= (size_t )wrote;
#line 375
      memmove((void *)fs->buf, (void const   *)(fs->buf + wrote), (size_t )(fs->p - fs->buf));
      }
#line 376
      return (0);
    }
#line 379
    if ((size_t )(fs->end - fs->buf) < amount) {
#line 382
      old_size = (size_t )(fs->end - fs->buf);
#line 383
      new_size = old_size + amount;
#line 386
      if (new_size < old_size) {
        {
#line 388
        tmp___0 = __errno_location();
#line 388
        *tmp___0 = 12;
        }
#line 389
        return (0);
      } else {
        {
#line 386
        tmp___1 = realloc((void *)fs->buf, new_size);
#line 386
        new_buf = (char *)tmp___1;
        }
#line 386
        if (! new_buf) {
          {
#line 388
          tmp___0 = __errno_location();
#line 388
          *tmp___0 = 12;
          }
#line 389
          return (0);
        }
      }
#line 392
      fs->buf = new_buf;
#line 393
      fs->end = new_buf + new_size;
#line 394
      fs->p = fs->buf;
    }
  }
#line 398
  return (1);
}
}
#line 401 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-fmtstream.c"
ssize_t ( /* format attribute */  argp_fmtstream_printf)(struct argp_fmtstream *fs ,
                                                         char const   *fmt  , ...) 
{ 
  int out ;
  size_t avail ;
  size_t size_guess ;
  va_list args___0 ;
  int tmp ;

  {
#line 406
  size_guess = (size_t )150;
  {
#line 408
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 412
    tmp = _argp_fmtstream_ensure(fs, size_guess);
    }
#line 412
    if (! tmp) {
#line 413
      return ((ssize_t )-1);
    }
    {
#line 415
    __builtin_va_start(args___0, fmt);
#line 416
    avail = (size_t )(fs->end - fs->p);
#line 417
    out = vsnprintf((char */* __restrict  */)fs->p, avail, (char const   */* __restrict  */)fmt,
                    args___0);
#line 418
    __builtin_va_end(args___0);
    }
#line 419
    if ((size_t )out >= avail) {
#line 420
      size_guess = (size_t )(out + 1);
    }
#line 408
    if (! ((size_t )out >= avail)) {
#line 408
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 424
  fs->p += out;
#line 426
  return ((ssize_t )out);
}
}
#line 585 "/home/khheo/project/benchmark/tar-1.29/gnu/argp.h"
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-eexst.c"
error_t argp_err_exit_status  =    64;
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/argp-ba.c"
char const   *argp_program_bug_address  ;
#line 60 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.h"
void argmatch_invalid(char const   *context , char const   *value___0 , ptrdiff_t problem ) ;
#line 72
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 98
char const   *argmatch_to_argument(char const   *value___0 , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 60 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
  {
#line 63
  exit((int )exit_failure);
  }
}
}
#line 68 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82
ptrdiff_t argmatch(char const   *arg___0 , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize )  __attribute__((__pure__)) ;
#line 82 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
ptrdiff_t argmatch(char const   *arg___0 , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen___0 ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen___0 = strlen(arg___0);
#line 94
  i = (size_t )0;
  }
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! *(arglist + i)) {
#line 94
      goto while_break;
    }
    {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg___0, arglen___0);
    }
#line 96
    if (! tmp___1) {
      {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
      }
#line 98
      if (tmp___0 == arglen___0) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
        {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
        }
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value___0 , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1L) {
    {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
    }
  } else {
    {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
    }
  }
  {
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value___0);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
  }
#line 138
  return;
}
}
#line 144 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  fputs_unlocked((char const   */* __restrict  */)tmp, (FILE */* __restrict  */)stderr);
#line 154
  i = (size_t )0;
  }
  {
#line 154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 154
    if (! *(arglist + i)) {
#line 154
      goto while_break;
    }
#line 155
    if (i == 0UL) {
      {
#line 158
      tmp___0 = quote((char const   *)*(arglist + i));
#line 158
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
              tmp___0);
#line 159
      last_val = vallist + valsize * i;
      }
    } else {
      {
#line 155
      tmp___2 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
      }
#line 155
      if (tmp___2) {
        {
#line 158
        tmp___0 = quote((char const   *)*(arglist + i));
#line 158
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n  - %s",
                tmp___0);
#line 159
        last_val = vallist + valsize * i;
        }
      } else {
        {
#line 163
        tmp___1 = quote((char const   *)*(arglist + i));
#line 163
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)", %s",
                tmp___1);
        }
      }
    }
#line 154
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  fputc_unlocked('\n', stderr);
  }
#line 166
  return;
}
}
#line 174 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg___0 , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
  {
#line 180
  tmp = argmatch(arg___0, arglist, vallist, valsize);
#line 180
  res = tmp;
  }
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
  {
#line 186
  argmatch_invalid(context, arg___0, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
  }
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195
char const   *argmatch_to_argument(char const   *value___0 , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize )  __attribute__((__pure__)) ;
#line 195 "/home/khheo/project/benchmark/tar-1.29/gnu/argmatch.c"
char const   *argmatch_to_argument(char const   *value___0 , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
  {
#line 202
  while (1) {
    while_continue: /* CIL Label */ ;
#line 202
    if (! *(arglist + i)) {
#line 202
      goto while_break;
    }
    {
#line 203
    tmp = memcmp((void const   *)value___0, (void const   *)(vallist + valsize * i),
                 valsize);
    }
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 24 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink.h"
char *areadlink_with_size(char const   *file , size_t size ) ;
#line 811 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 51 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink-with-size.c"
char *areadlink_with_size(char const   *file , size_t size ) 
{ 
  size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer___1 ;
  void *tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 57
  symlink_max = (size_t )1024;
#line 58
  INITIAL_LIMIT_BOUND = (size_t )8192;
#line 59
  if (symlink_max < INITIAL_LIMIT_BOUND) {
#line 59
    tmp = symlink_max + 1UL;
  } else {
#line 59
    tmp = INITIAL_LIMIT_BOUND;
  }
#line 59
  initial_limit = tmp;
#line 64
  if (size < initial_limit) {
#line 64
    tmp___0 = size + 1UL;
  } else {
#line 64
    tmp___0 = initial_limit;
  }
#line 64
  buf_size = tmp___0;
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    tmp___1 = malloc(buf_size);
#line 70
    buffer___1 = (char *)tmp___1;
    }
#line 72
    if ((unsigned long )buffer___1 == (unsigned long )((void *)0)) {
#line 73
      return ((char *)((void *)0));
    }
    {
#line 74
    r = readlink((char const   */* __restrict  */)file, (char */* __restrict  */)buffer___1,
                 buf_size);
#line 75
    link_length = (size_t )r;
    }
#line 79
    if (r < 0L) {
      {
#line 79
      tmp___4 = __errno_location();
      }
#line 79
      if (*tmp___4 != 34) {
        {
#line 81
        tmp___2 = __errno_location();
#line 81
        saved_errno = *tmp___2;
#line 82
        free((void *)buffer___1);
#line 83
        tmp___3 = __errno_location();
#line 83
        *tmp___3 = saved_errno;
        }
#line 84
        return ((char *)((void *)0));
      }
    }
#line 87
    if (link_length < buf_size) {
#line 89
      *(buffer___1 + link_length) = (char)0;
#line 90
      return (buffer___1);
    }
    {
#line 93
    free((void *)buffer___1);
    }
#line 94
    if (buf_size <= 4611686018427387903UL) {
#line 95
      buf_size *= 2UL;
    } else
#line 96
    if (buf_size < 9223372036854775807UL) {
#line 97
      buf_size = 9223372036854775807UL;
    } else {
      {
#line 100
      tmp___5 = __errno_location();
#line 100
      *tmp___5 = 12;
      }
#line 101
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 23 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink.h"
char *areadlink(char const   *filename ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 35 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink.c"
static ssize_t careadlinkatcwd(int fd , char const   *filename , char *buffer___1 ,
                               size_t buffer_size ) 
{ 
  ssize_t tmp ;

  {
#line 41
  if (fd != -100) {
    {
#line 42
    abort();
    }
  }
  {
#line 43
  tmp = readlink((char const   */* __restrict  */)filename, (char */* __restrict  */)buffer___1,
                 buffer_size);
  }
#line 43
  return (tmp);
}
}
#line 52 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink.c"
char *areadlink(char const   *filename ) 
{ 
  char *tmp ;

  {
  {
#line 55
  tmp = careadlinkat(-100, filename, (char *)((void *)0), (size_t )0, (struct allocator  const  *)((void *)0),
                     & careadlinkatcwd);
  }
#line 55
  return (tmp);
}
}
#line 31 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink.h"
char *areadlinkat_with_size(int fd , char const   *file , size_t size ) ;
#line 822 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int __fd ,
                                                                                                       char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 56 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlinkat-with-size.c"
char *areadlinkat_with_size(int fd , char const   *file , size_t size ) 
{ 
  size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer___1 ;
  void *tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 62
  symlink_max = (size_t )1024;
#line 63
  INITIAL_LIMIT_BOUND = (size_t )8192;
#line 64
  if (symlink_max < INITIAL_LIMIT_BOUND) {
#line 64
    tmp = symlink_max + 1UL;
  } else {
#line 64
    tmp = INITIAL_LIMIT_BOUND;
  }
#line 64
  initial_limit = tmp;
#line 69
  if (size < initial_limit) {
#line 69
    tmp___0 = size + 1UL;
  } else {
#line 69
    tmp___0 = initial_limit;
  }
#line 69
  buf_size = tmp___0;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    tmp___1 = malloc(buf_size);
#line 75
    buffer___1 = (char *)tmp___1;
    }
#line 77
    if ((unsigned long )buffer___1 == (unsigned long )((void *)0)) {
#line 78
      return ((char *)((void *)0));
    }
    {
#line 79
    r = readlinkat(fd, (char const   */* __restrict  */)file, (char */* __restrict  */)buffer___1,
                   buf_size);
#line 80
    link_length = (size_t )r;
    }
#line 84
    if (r < 0L) {
      {
#line 84
      tmp___4 = __errno_location();
      }
#line 84
      if (*tmp___4 != 34) {
        {
#line 86
        tmp___2 = __errno_location();
#line 86
        saved_errno = *tmp___2;
#line 87
        free((void *)buffer___1);
#line 88
        tmp___3 = __errno_location();
#line 88
        *tmp___3 = saved_errno;
        }
#line 89
        return ((char *)((void *)0));
      }
    }
#line 92
    if (link_length < buf_size) {
#line 94
      *(buffer___1 + link_length) = (char)0;
#line 95
      return (buffer___1);
    }
    {
#line 98
    free((void *)buffer___1);
    }
#line 99
    if (buf_size <= 4611686018427387903UL) {
#line 100
      buf_size *= 2UL;
    } else
#line 101
    if (buf_size < 9223372036854775807UL) {
#line 102
      buf_size = 9223372036854775807UL;
    } else {
      {
#line 105
      tmp___5 = __errno_location();
#line 105
      *tmp___5 = 12;
      }
#line 106
      return ((char *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 27 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlink.h"
char *areadlinkat(int fd , char const   *filename ) ;
#line 137 "./unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/tar-1.29/gnu/areadlinkat.c"
char *areadlinkat(int fd , char const   *filename ) 
{ 
  char *tmp ;

  {
  {
#line 42
  tmp = careadlinkat(fd, filename, (char *)((void *)0), (size_t )0, (struct allocator  const  *)((void *)0),
                     (ssize_t (*)(int  , char const   * , char * , size_t  ))(& readlinkat));
  }
#line 42
  return (tmp);
}
}
#line 5 "/home/khheo/project/benchmark/tar-1.29/gnu/allocator.c"
struct allocator  const  stdlib_allocator  =    {(void *(*)(size_t  ))(& malloc), (void *(*)(void * , size_t  ))(& realloc), (void (*)(void * ))(& free),
    (void (*)(size_t  ))((void *)0)};
#line 66 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.h"
#pragma GCC diagnostic push
#line 66
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 66
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 296
void free_permission_context(struct permission_context *ctx )  __attribute__((__const__)) ;
#line 302
#pragma GCC diagnostic pop
#line 478 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.c"
void free_permission_context(struct permission_context *ctx )  __attribute__((__const__)) ;
#line 478 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-internal.c"
void free_permission_context(struct permission_context *ctx ) 
{ 


  {
#line 507
  return;
}
}
#line 27 "./acl.h"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum )  __attribute__((__const__)) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/gnu/acl-errno-valid.c"
_Bool acl_errno_valid(int errnum ) 
{ 


  {
  {
#line 36
  if (errnum == 16) {
#line 36
    goto case_16;
  }
#line 37
  if (errnum == 22) {
#line 37
    goto case_22;
  }
#line 41
  if (errnum == 38) {
#line 41
    goto case_38;
  }
#line 49
  if (errnum == 95) {
#line 49
    goto case_95;
  }
#line 50
  goto switch_default;
  case_16: /* CIL Label */ 
#line 36
  return ((_Bool)0);
  case_22: /* CIL Label */ 
#line 37
  return ((_Bool)0);
  case_38: /* CIL Label */ 
#line 41
  return ((_Bool)0);
  case_95: /* CIL Label */ 
#line 49
  return ((_Bool)0);
  switch_default: /* CIL Label */ 
#line 50
  return ((_Bool)1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 41 "/usr/include/x86_64-linux-gnu/sys/xattr.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setxattr)(char const   *__path ,
                                                                               char const   *__name ,
                                                                               void const   *__value ,
                                                                               size_t __size ,
                                                                               int __flags ) ;
#line 48
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) lsetxattr)(char const   *__path ,
                                                                                char const   *__name ,
                                                                                void const   *__value ,
                                                                                size_t __size ,
                                                                                int __flags ) ;
#line 59
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) getxattr)(char const   *__path ,
                                                                                   char const   *__name ,
                                                                                   void *__value ,
                                                                                   size_t __size ) ;
#line 65
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) lgetxattr)(char const   *__path ,
                                                                                    char const   *__name ,
                                                                                    void *__value ,
                                                                                    size_t __size ) ;
#line 76
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) listxattr)(char const   *__path ,
                                                                                    char *__list ,
                                                                                    size_t __size ) ;
#line 82
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) llistxattr)(char const   *__path ,
                                                                                     char *__list ,
                                                                                     size_t __size ) ;
#line 43 "/home/khheo/project/benchmark/tar-1.29/lib/xattr-at.h"
int setxattrat(int fd , char const   *file , char const   *name , void const   *value___0 ,
               size_t size , int flags ) ;
#line 49
int lsetxattrat(int fd , char const   *file , char const   *name , void const   *value___0 ,
                size_t size , int flags ) ;
#line 56
ssize_t getxattrat(int fd , char const   *file , char const   *name , void *value___0 ,
                   size_t size ) ;
#line 62
ssize_t lgetxattrat(int fd , char const   *file , char const   *name , void *value___0 ,
                    size_t size ) ;
#line 67
ssize_t listxattrat(int fd , char const   *file , char *list , size_t size ) ;
#line 72
ssize_t llistxattrat(int fd , char const   *file , char *list , size_t size ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 32 "../gnu/openat.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 121
#pragma GCC diagnostic pop
#line 69 "../gnu/at-func.c"
int setxattrat(int fd , char const   *file , char const   *name , void const   *value___0 ,
               size_t size , int flags ) 
{ 
  int tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = setxattr(file, name, value___0, size, flags);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = setxattr(file, name, value___0, size, flags);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = setxattr((char const   *)proc_file, name, value___0, size, flags);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return (-1);
  }
  {
#line 130
  err = setxattr(file, name, value___0, size, flags);
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "../gnu/at-func.c"
int lsetxattrat(int fd , char const   *file , char const   *name , void const   *value___0 ,
                size_t size , int flags ) 
{ 
  int tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = lsetxattr(file, name, value___0, size, flags);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = lsetxattr(file, name, value___0, size, flags);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = lsetxattr((char const   *)proc_file, name, value___0, size, flags);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1 != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return (-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return (-1);
  }
  {
#line 130
  err = lsetxattr(file, name, value___0, size, flags);
  }
#line 131
  if (err == -1) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "../gnu/at-func.c"
ssize_t getxattrat(int fd , char const   *file , char const   *name , void *value___0 ,
                   size_t size ) 
{ 
  ssize_t tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  ssize_t err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  ssize_t proc_result ;
  ssize_t tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = getxattr(file, name, value___0, size);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = getxattr(file, name, value___0, size);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = getxattr((char const   *)proc_file, name, value___0, size);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1L != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return ((ssize_t )-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return ((ssize_t )-1);
  }
  {
#line 130
  err = getxattr(file, name, value___0, size);
  }
#line 131
  if (err == -1L) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "../gnu/at-func.c"
ssize_t lgetxattrat(int fd , char const   *file , char const   *name , void *value___0 ,
                    size_t size ) 
{ 
  ssize_t tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  ssize_t err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  ssize_t proc_result ;
  ssize_t tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = lgetxattr(file, name, value___0, size);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = lgetxattr(file, name, value___0, size);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = lgetxattr((char const   *)proc_file, name, value___0, size);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1L != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return ((ssize_t )-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return ((ssize_t )-1);
  }
  {
#line 130
  err = lgetxattr(file, name, value___0, size);
  }
#line 131
  if (err == -1L) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "../gnu/at-func.c"
ssize_t listxattrat(int fd , char const   *file , char *list , size_t size ) 
{ 
  ssize_t tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  ssize_t err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  ssize_t proc_result ;
  ssize_t tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = listxattr(file, list, size);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = listxattr(file, list, size);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = listxattr((char const   *)proc_file, list, size);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1L != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return ((ssize_t )-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return ((ssize_t )-1);
  }
  {
#line 130
  err = listxattr(file, list, size);
  }
#line 131
  if (err == -1L) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 69 "../gnu/at-func.c"
ssize_t llistxattrat(int fd , char const   *file , char *list , size_t size ) 
{ 
  ssize_t tmp ;
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  ssize_t err ;
  char proc_buf[4032] ;
  char *proc_file ;
  char *tmp___0 ;
  ssize_t proc_result ;
  ssize_t tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 74
  if (fd == -100) {
    {
#line 75
    tmp = llistxattr(file, list, size);
    }
#line 75
    return (tmp);
  } else
#line 74
  if ((int const   )*(file + 0) == 47) {
    {
#line 75
    tmp = llistxattr(file, list, size);
    }
#line 75
    return (tmp);
  }
  {
#line 90
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 90
  proc_file = tmp___0;
  }
#line 91
  if (proc_file) {
    {
#line 93
    tmp___1 = llistxattr((char const   *)proc_file, list, size);
#line 93
    proc_result = tmp___1;
#line 94
    tmp___2 = __errno_location();
#line 94
    proc_errno = *tmp___2;
    }
#line 95
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
      {
#line 96
      free((void *)proc_file);
      }
    }
#line 100
    if (-1L != proc_result) {
#line 101
      return (proc_result);
    }
#line 102
    if (! (proc_errno == 20)) {
#line 102
      if (! (proc_errno == 2)) {
#line 102
        if (! (proc_errno == 1)) {
#line 102
          if (! (proc_errno == 13)) {
#line 102
            if (! (proc_errno == 38)) {
#line 102
              if (! (proc_errno == 95)) {
                {
#line 104
                tmp___3 = __errno_location();
#line 104
                *tmp___3 = proc_errno;
                }
#line 105
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
  {
#line 110
  tmp___5 = save_cwd(& saved_cwd);
  }
#line 110
  if (tmp___5 != 0) {
    {
#line 111
    tmp___4 = __errno_location();
#line 111
    openat_save_fail(*tmp___4);
    }
  }
#line 112
  if (0 <= fd) {
#line 112
    if (fd == saved_cwd.desc) {
      {
#line 117
      free_cwd(& saved_cwd);
#line 118
      tmp___6 = __errno_location();
#line 118
      *tmp___6 = 9;
      }
#line 119
      return ((ssize_t )-1);
    }
  }
  {
#line 122
  tmp___9 = fchdir(fd);
  }
#line 122
  if (tmp___9 != 0) {
    {
#line 124
    tmp___7 = __errno_location();
#line 124
    saved_errno = *tmp___7;
#line 125
    free_cwd(& saved_cwd);
#line 126
    tmp___8 = __errno_location();
#line 126
    *tmp___8 = saved_errno;
    }
#line 127
    return ((ssize_t )-1);
  }
  {
#line 130
  err = llistxattr(file, list, size);
  }
#line 131
  if (err == -1L) {
    {
#line 131
    tmp___10 = __errno_location();
#line 131
    saved_errno = *tmp___10;
    }
  } else {
#line 131
    saved_errno = 0;
  }
  {
#line 133
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
  }
#line 133
  if (tmp___12 != 0) {
    {
#line 134
    tmp___11 = __errno_location();
#line 134
    openat_restore_fail(*tmp___11);
    }
  }
  {
#line 136
  free_cwd(& saved_cwd);
  }
#line 138
  if (saved_errno) {
    {
#line 139
    tmp___13 = __errno_location();
#line 139
    *tmp___13 = saved_errno;
    }
  }
#line 140
  return (err);
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 166 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 148 "./wordsplit.h"
int wordsplit(char const   *command , struct wordsplit *ws , int flags ) ;
#line 149
int wordsplit_len(char const   *command , size_t length , struct wordsplit *wsp ,
                  int flags ) ;
#line 151
void wordsplit_free(struct wordsplit *ws ) ;
#line 152
void wordsplit_free_words(struct wordsplit *ws ) ;
#line 154
int wordsplit_c_unquote_char(int c ) ;
#line 155
int wordsplit_c_quote_char(int c ) ;
#line 156
size_t wordsplit_c_quoted_length(char const   *str , int quote_hex , int *quote___0 ) ;
#line 158
void wordsplit_general_unquote_copy(char *dst , char const   *src , size_t n , char const   *escapable ) ;
#line 160
void wordsplit_sh_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 161
void wordsplit_c_unquote_copy(char *dst , char const   *src , size_t n ) ;
#line 162
void wordsplit_c_quote_copy(char *dst , char const   *src , int quote_hex ) ;
#line 164
void wordsplit_perror(struct wordsplit *wsp ) ;
#line 165
char const   *wordsplit_strerror(struct wordsplit *ws ) ;
#line 57 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void _wsplt_alloc_die(struct wordsplit *wsp ) 
{ 
  char *tmp ;

  {
  {
#line 60
  tmp = gettext("memory exhausted");
#line 60
  (*(wsp->ws_error))((char const   *)tmp);
#line 61
  abort();
  }
}
}
#line 64 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void ( /* format attribute */  _wsplt_error)(char const   *fmt  , ...) 
{ 
  va_list ap ;

  {
  {
#line 69
  __builtin_va_start(ap, fmt);
#line 70
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           ap);
#line 71
  __builtin_va_end(ap);
#line 72
  fputc('\n', stderr);
  }
#line 73
  return;
}
}
#line 75
static void wordsplit_free_nodes(struct wordsplit *wsp ) ;
#line 77 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int _wsplt_nomem(struct wordsplit *wsp ) 
{ 
  int *tmp ;

  {
  {
#line 80
  tmp = __errno_location();
#line 80
  *tmp = 12;
#line 81
  wsp->ws_errno = 2;
  }
#line 82
  if (wsp->ws_flags & 128) {
    {
#line 83
    (*(wsp->ws_alloc_die))(wsp);
    }
  }
#line 84
  if (wsp->ws_flags & 16) {
    {
#line 85
    wordsplit_perror(wsp);
    }
  }
#line 86
  if (! (wsp->ws_flags & 8)) {
    {
#line 87
    wordsplit_free(wsp);
    }
  }
  {
#line 88
  wordsplit_free_nodes(wsp);
  }
#line 89
  return (wsp->ws_errno);
}
}
#line 92 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wordsplit_init0(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *tmp ;

  {
#line 95
  if (wsp->ws_flags & 8) {
#line 97
    if (! (wsp->ws_flags & 1)) {
      {
#line 98
      wordsplit_free_words(wsp);
      }
    }
  } else {
#line 102
    wsp->ws_wordv = (char **)((void *)0);
#line 103
    wsp->ws_wordc = (size_t )0;
#line 104
    wsp->ws_wordn = (size_t )0;
  }
#line 107
  wsp->ws_errno = 0;
#line 108
  tmp = (struct wordsplit_node *)((void *)0);
#line 108
  wsp->ws_tail = tmp;
#line 108
  wsp->ws_head = tmp;
#line 109
  return;
}
}
#line 111 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wordsplit_init(struct wordsplit *wsp , char const   *input , size_t len ,
                          int flags ) 
{ 
  int *tmp ;
  int *tmp___0 ;

  {
#line 115
  wsp->ws_flags = flags;
#line 117
  if (! (wsp->ws_flags & 65536)) {
#line 118
    wsp->ws_alloc_die = & _wsplt_alloc_die;
  }
#line 119
  if (! (wsp->ws_flags & 131072)) {
#line 120
    wsp->ws_error = & _wsplt_error;
  }
#line 122
  if (! (wsp->ws_flags & 64)) {
#line 122
    if (! (wsp->ws_flags & 1572864)) {
      {
#line 125
      tmp = __errno_location();
#line 125
      *tmp = 22;
#line 126
      wsp->ws_errno = 4;
      }
#line 127
      if (wsp->ws_flags & 16) {
        {
#line 128
        wordsplit_perror(wsp);
        }
      }
#line 129
      return (wsp->ws_errno);
    }
  }
#line 132
  if (! (wsp->ws_flags & 4)) {
    {
#line 134
    tmp___0 = __errno_location();
#line 134
    *tmp___0 = 22;
#line 135
    wsp->ws_errno = 3;
    }
#line 136
    if (wsp->ws_flags & 16) {
      {
#line 137
      wordsplit_perror(wsp);
      }
    }
#line 138
    return (wsp->ws_errno);
  }
#line 141
  if (wsp->ws_flags & 2097152) {
#line 143
    if (! (wsp->ws_flags & 262144)) {
#line 145
      if (wsp->ws_flags & 131072) {
#line 146
        wsp->ws_debug = wsp->ws_error;
      } else
#line 147
      if (wsp->ws_flags & 16) {
#line 148
        wsp->ws_debug = & _wsplt_error;
      } else {
#line 150
        wsp->ws_flags &= -2097153;
      }
    }
  }
#line 154
  wsp->ws_input = input;
#line 155
  wsp->ws_len = len;
#line 157
  if (! (wsp->ws_flags & 2)) {
#line 158
    wsp->ws_offs = (size_t )0;
  }
#line 160
  if (! (wsp->ws_flags & 16384)) {
#line 161
    wsp->ws_delim = " \t\n";
  }
#line 163
  if (! (wsp->ws_flags & 32768)) {
#line 164
    wsp->ws_comment = (char const   *)((void *)0);
  }
#line 166
  if (! (wsp->ws_flags & 67108864)) {
#line 167
    wsp->ws_closure = (void *)0;
  }
  {
#line 169
  wsp->ws_endp = (size_t )0;
#line 171
  wordsplit_init0(wsp);
  }
#line 173
  return (0);
}
}
#line 176 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int alloc_space(struct wordsplit *wsp , size_t count ) 
{ 
  size_t offs ;
  size_t tmp ;
  char **ptr ;
  size_t newalloc ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 179
  if (wsp->ws_flags & 2) {
#line 179
    tmp = wsp->ws_offs;
  } else {
#line 179
    tmp = (size_t )0;
  }
#line 179
  offs = tmp;
#line 183
  if ((unsigned long )wsp->ws_wordv == (unsigned long )((void *)0)) {
#line 185
    if (offs + count > 128UL) {
#line 185
      newalloc = count;
    } else {
#line 185
      newalloc = (size_t )128;
    }
    {
#line 186
    tmp___0 = calloc(newalloc, sizeof(*(ptr + 0)));
#line 186
    ptr = (char **)tmp___0;
    }
  } else
#line 188
  if (wsp->ws_wordn < (offs + wsp->ws_wordc) + count) {
#line 190
    if (count > 128UL) {
#line 190
      tmp___1 = count;
    } else {
#line 190
      tmp___1 = (size_t )128;
    }
    {
#line 190
    newalloc = (offs + wsp->ws_wordc) + tmp___1;
#line 192
    tmp___2 = realloc((void *)wsp->ws_wordv, newalloc * sizeof(*(ptr + 0)));
#line 192
    ptr = (char **)tmp___2;
    }
  } else {
#line 195
    return (0);
  }
#line 197
  if (ptr) {
#line 199
    wsp->ws_wordn = newalloc;
#line 200
    wsp->ws_wordv = ptr;
  } else {
    {
#line 203
    tmp___3 = _wsplt_nomem(wsp);
    }
#line 203
    return (tmp___3);
  }
#line 204
  return (0);
}
}
#line 239 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static char retbuf[6]  ;
#line 236 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static char const   *wsnode_flagstr(int flags ) 
{ 
  char *p ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
#line 240
  p = retbuf;
#line 242
  if (flags & 2) {
#line 243
    tmp = p;
#line 243
    p ++;
#line 243
    *tmp = (char )'w';
  } else
#line 244
  if (flags & 1) {
#line 245
    tmp___0 = p;
#line 245
    p ++;
#line 245
    *tmp___0 = (char )'n';
  } else {
#line 247
    tmp___1 = p;
#line 247
    p ++;
#line 247
    *tmp___1 = (char )'-';
  }
#line 248
  if (flags & 4) {
#line 249
    tmp___2 = p;
#line 249
    p ++;
#line 249
    *tmp___2 = (char )'q';
  } else {
#line 251
    tmp___3 = p;
#line 251
    p ++;
#line 251
    *tmp___3 = (char )'-';
  }
#line 252
  if (flags & 8) {
#line 253
    tmp___4 = p;
#line 253
    p ++;
#line 253
    *tmp___4 = (char )'E';
  } else {
#line 255
    tmp___5 = p;
#line 255
    p ++;
#line 255
    *tmp___5 = (char )'-';
  }
#line 256
  if (flags & 16) {
#line 257
    tmp___6 = p;
#line 257
    p ++;
#line 257
    *tmp___6 = (char )'j';
  } else {
#line 259
    tmp___7 = p;
#line 259
    p ++;
#line 259
    *tmp___7 = (char )'-';
  }
#line 260
  if (flags & 32) {
#line 261
    tmp___8 = p;
#line 261
    p ++;
#line 261
    *tmp___8 = (char )'s';
  } else {
#line 263
    tmp___9 = p;
#line 263
    p ++;
#line 263
    *tmp___9 = (char )'-';
  }
#line 264
  *p = (char)0;
#line 265
  return ((char const   *)(retbuf));
}
}
#line 268 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static char const   *wsnode_ptr(struct wordsplit *wsp , struct wordsplit_node *p ) 
{ 


  {
#line 271
  if (p->flags & 1U) {
#line 272
    return ("");
  } else
#line 273
  if (p->flags & 2U) {
#line 274
    return ((char const   *)p->v.word);
  } else {
#line 276
    return (wsp->ws_input + p->v.segm.beg);
  }
}
}
#line 279 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static size_t wsnode_len(struct wordsplit_node *p ) 
{ 
  size_t tmp ;

  {
#line 282
  if (p->flags & 1U) {
#line 283
    return ((size_t )0);
  } else
#line 284
  if (p->flags & 2U) {
    {
#line 285
    tmp = strlen((char const   *)p->v.word);
    }
#line 285
    return (tmp);
  } else {
#line 287
    return (p->v.segm.end - p->v.segm.beg);
  }
}
}
#line 290 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wsnode_new(struct wordsplit *wsp , struct wordsplit_node **pnode ) 
{ 
  struct wordsplit_node *node ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 293
  tmp = calloc((size_t )1, sizeof(*node));
#line 293
  node = (struct wordsplit_node *)tmp;
  }
#line 294
  if (! node) {
    {
#line 295
    tmp___0 = _wsplt_nomem(wsp);
    }
#line 295
    return (tmp___0);
  }
#line 296
  *pnode = node;
#line 297
  return (0);
}
}
#line 300 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wsnode_free(struct wordsplit_node *p ) 
{ 


  {
#line 303
  if (p->flags & 2U) {
    {
#line 304
    free((void *)p->v.word);
    }
  }
  {
#line 305
  free((void *)p);
  }
#line 306
  return;
}
}
#line 308 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wsnode_append(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 


  {
#line 311
  node->next = (struct wordsplit_node *)((void *)0);
#line 312
  node->prev = wsp->ws_tail;
#line 313
  if (wsp->ws_tail) {
#line 314
    (wsp->ws_tail)->next = node;
  } else {
#line 316
    wsp->ws_head = node;
  }
#line 317
  wsp->ws_tail = node;
#line 318
  return;
}
}
#line 320 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wsnode_remove(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *tmp ;

  {
#line 325
  p = node->prev;
#line 326
  if (p) {
#line 328
    p->next = node->next;
#line 329
    if (! node->next) {
#line 330
      p->flags &= 4294967279U;
    }
  } else {
#line 333
    wsp->ws_head = node->next;
  }
#line 335
  p = node->next;
#line 336
  if (p) {
#line 337
    p->prev = node->prev;
  } else {
#line 339
    wsp->ws_tail = node->prev;
  }
#line 341
  tmp = (struct wordsplit_node *)((void *)0);
#line 341
  node->prev = tmp;
#line 341
  node->next = tmp;
#line 342
  return;
}
}
#line 344 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wsnode_insert(struct wordsplit *wsp , struct wordsplit_node *node , struct wordsplit_node *anchor ,
                          int before ) 
{ 
  struct wordsplit_node *tmp ;
  struct wordsplit_node *tmp___0 ;
  struct wordsplit_node *p ;

  {
#line 348
  if (! wsp->ws_head) {
#line 350
    tmp = (struct wordsplit_node *)((void *)0);
#line 350
    node->prev = tmp;
#line 350
    node->next = tmp;
#line 351
    tmp___0 = node;
#line 351
    wsp->ws_tail = tmp___0;
#line 351
    wsp->ws_head = tmp___0;
  } else
#line 353
  if (before) {
#line 355
    if (anchor->prev) {
      {
#line 356
      wsnode_insert(wsp, node, anchor->prev, 0);
      }
    } else {
#line 359
      node->prev = (struct wordsplit_node *)((void *)0);
#line 360
      node->next = anchor;
#line 361
      anchor->prev = node;
#line 362
      wsp->ws_head = node;
    }
  } else {
#line 369
    p = anchor->next;
#line 370
    if (p) {
#line 371
      p->prev = node;
    } else {
#line 373
      wsp->ws_tail = node;
    }
#line 374
    node->next = p;
#line 375
    node->prev = anchor;
#line 376
    anchor->next = node;
  }
#line 378
  return;
}
}
#line 380 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wordsplit_add_segm(struct wordsplit *wsp , size_t beg , size_t end , int flg ) 
{ 
  struct wordsplit_node *node ;
  int rc ;

  {
#line 386
  if (end == beg) {
#line 386
    if (! (flg & 256)) {
#line 387
      return (0);
    }
  }
  {
#line 388
  rc = wsnode_new(wsp, & node);
  }
#line 389
  if (rc) {
#line 390
    return (rc);
  }
  {
#line 391
  node->flags = (unsigned int )(flg & -259);
#line 392
  node->v.segm.beg = beg;
#line 393
  node->v.segm.end = end;
#line 394
  wsnode_append(wsp, node);
  }
#line 395
  return (0);
}
}
#line 398 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wordsplit_free_nodes(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *next ;
  struct wordsplit_node *tmp ;

  {
#line 403
  p = wsp->ws_head;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! p) {
#line 403
      goto while_break;
    }
    {
#line 405
    next = p->next;
#line 406
    wsnode_free(p);
#line 407
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 409
  tmp = (struct wordsplit_node *)((void *)0);
#line 409
  wsp->ws_tail = tmp;
#line 409
  wsp->ws_head = tmp;
#line 410
  return;
}
}
#line 412 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wordsplit_dump_nodes(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  int n ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 416
  n = 0;
#line 418
  p = wsp->ws_head;
#line 418
  n = 0;
  {
#line 418
  while (1) {
    while_continue: /* CIL Label */ ;
#line 418
    if (! p) {
#line 418
      goto while_break;
    }
#line 420
    if (p->flags & 2U) {
      {
#line 421
      tmp = wsnode_flagstr((int )p->flags);
#line 421
      (*(wsp->ws_debug))("%4d: %p: %#04x (%s):%s;", n, p, p->flags, tmp, p->v.word);
      }
    } else {
      {
#line 424
      tmp___0 = wsnode_flagstr((int )p->flags);
#line 424
      (*(wsp->ws_debug))("%4d: %p: %#04x (%s):%.*s;", n, p, p->flags, tmp___0, (int )(p->v.segm.end - p->v.segm.beg),
                         wsp->ws_input + p->v.segm.beg);
      }
    }
#line 418
    p = p->next;
#line 418
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 429
  return;
}
}
#line 431 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int coalesce_segment(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *end ;
  size_t len ;
  char *buf ;
  char *cur ;
  int stop ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct wordsplit_node *next ;
  char const   *str ;
  char const   *tmp___3 ;
  size_t slen ;
  size_t tmp___4 ;

  {
#line 435
  len = (size_t )0;
#line 439
  p = node;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (p) {
#line 439
      if (! (p->flags & 16U)) {
#line 439
        goto while_break;
      }
    } else {
#line 439
      goto while_break;
    }
    {
#line 441
    tmp = wsnode_len(p);
#line 441
    len += tmp;
#line 439
    p = p->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 443
  tmp___0 = wsnode_len(p);
#line 443
  len += tmp___0;
#line 444
  end = p;
#line 446
  tmp___1 = malloc(len + 1UL);
#line 446
  buf = (char *)tmp___1;
  }
#line 447
  if (! buf) {
    {
#line 448
    tmp___2 = _wsplt_nomem(wsp);
    }
#line 448
    return (tmp___2);
  }
#line 449
  cur = buf;
#line 451
  p = node;
#line 452
  stop = 0;
  {
#line 452
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 452
    if (! (! stop)) {
#line 452
      goto while_break___0;
    }
    {
#line 454
    next = p->next;
#line 455
    tmp___3 = wsnode_ptr(wsp, p);
#line 455
    str = tmp___3;
#line 456
    tmp___4 = wsnode_len(p);
#line 456
    slen = tmp___4;
#line 458
    memcpy((void */* __restrict  */)cur, (void const   */* __restrict  */)str, slen);
#line 459
    cur += slen;
    }
#line 460
    if ((unsigned long )p != (unsigned long )node) {
      {
#line 462
      wsnode_remove(wsp, p);
#line 463
      stop = (unsigned long )p == (unsigned long )end;
#line 464
      wsnode_free(p);
      }
    }
#line 466
    p = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 469
  *cur = (char)0;
#line 471
  node->flags &= 4294967279U;
#line 473
  if (node->flags & 2U) {
    {
#line 474
    free((void *)node->v.word);
    }
  } else {
#line 476
    node->flags |= 2U;
  }
#line 477
  node->v.word = buf;
#line 478
  return (0);
}
}
#line 481 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wsnode_quoteremoval(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  void (*uqfn)(char * , char const   * , size_t  ) ;
  void (*tmp)(char *dst , char const   *src , size_t n ) ;
  char const   *str ;
  char const   *tmp___0 ;
  size_t slen ;
  size_t tmp___1 ;
  int unquote ;
  char *newstr ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 485
  if (wsp->ws_flags & 33554432) {
#line 485
    tmp = & wordsplit_c_unquote_copy;
  } else {
#line 485
    tmp = & wordsplit_sh_unquote_copy;
  }
#line 485
  uqfn = tmp;
#line 489
  p = wsp->ws_head;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! p) {
#line 489
      goto while_break;
    }
    {
#line 491
    tmp___0 = wsnode_ptr(wsp, p);
#line 491
    str = tmp___0;
#line 492
    tmp___1 = wsnode_len(p);
#line 492
    slen = tmp___1;
    }
#line 495
    if (wsp->ws_flags & 1536) {
#line 497
      unquote = ! (p->flags & 8U);
    } else {
#line 500
      unquote = 0;
    }
#line 502
    if (unquote) {
#line 504
      if (! (p->flags & 2U)) {
        {
#line 506
        tmp___2 = malloc(slen + 1UL);
#line 506
        newstr = (char *)tmp___2;
        }
#line 507
        if (! newstr) {
          {
#line 508
          tmp___3 = _wsplt_nomem(wsp);
          }
#line 508
          return (tmp___3);
        }
        {
#line 509
        memcpy((void */* __restrict  */)newstr, (void const   */* __restrict  */)str,
               slen);
#line 510
        *(newstr + slen) = (char)0;
#line 511
        p->v.word = newstr;
#line 512
        p->flags |= 2U;
        }
      }
#line 515
      if (wsp->ws_flags & 268435456) {
        {
#line 516
        wordsplit_general_unquote_copy(p->v.word, str, slen, wsp->ws_escape);
        }
      } else {
        {
#line 519
        (*uqfn)(p->v.word, str, slen);
        }
      }
    }
#line 489
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return (0);
}
}
#line 525 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wsnode_coalesce(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  int tmp ;

  {
#line 530
  p = wsp->ws_head;
  {
#line 530
  while (1) {
    while_continue: /* CIL Label */ ;
#line 530
    if (! p) {
#line 530
      goto while_break;
    }
#line 532
    if (p->flags & 16U) {
      {
#line 533
      tmp = coalesce_segment(wsp, p);
      }
#line 533
      if (tmp) {
#line 534
        return (1);
      }
    }
#line 530
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return (0);
}
}
#line 539 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wordsplit_finish(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  size_t n ;
  int tmp ;
  char const   *str ;
  char const   *tmp___0 ;
  size_t slen ;
  size_t tmp___1 ;
  char *newstr ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 545
  n = (size_t )0;
#line 547
  p = wsp->ws_head;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! p) {
#line 547
      goto while_break;
    }
#line 548
    n ++;
#line 547
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 550
  tmp = alloc_space(wsp, n + 1UL);
  }
#line 550
  if (tmp) {
#line 551
    return (1);
  }
#line 553
  p = wsp->ws_head;
  {
#line 553
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 553
    if (! p) {
#line 553
      goto while_break___0;
    }
    {
#line 555
    tmp___0 = wsnode_ptr(wsp, p);
#line 555
    str = tmp___0;
#line 556
    tmp___1 = wsnode_len(p);
#line 556
    slen = tmp___1;
#line 557
    tmp___2 = malloc(slen + 1UL);
#line 557
    newstr = (char *)tmp___2;
#line 562
    *(wsp->ws_wordv + (wsp->ws_offs + wsp->ws_wordc)) = newstr;
    }
#line 563
    if (! newstr) {
      {
#line 564
      tmp___3 = _wsplt_nomem(wsp);
      }
#line 564
      return (tmp___3);
    }
    {
#line 565
    memcpy((void */* __restrict  */)newstr, (void const   */* __restrict  */)str,
           slen);
#line 566
    *(newstr + slen) = (char)0;
#line 568
    (wsp->ws_wordc) ++;
#line 553
    p = p->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 571
  *(wsp->ws_wordv + (wsp->ws_offs + wsp->ws_wordc)) = (char *)((void *)0);
#line 572
  return (0);
}
}
#line 577 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int node_split_prefix(struct wordsplit *wsp , struct wordsplit_node **ptail ,
                             struct wordsplit_node *node , size_t beg , size_t len ,
                             int flg ) 
{ 
  struct wordsplit_node *newnode ;
  int tmp ;
  char const   *str ;
  char const   *tmp___0 ;
  char *newstr ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 585
  if (len == 0UL) {
#line 586
    return (0);
  }
  {
#line 587
  tmp = wsnode_new(wsp, & newnode);
  }
#line 587
  if (tmp) {
#line 588
    return (1);
  }
  {
#line 589
  wsnode_insert(wsp, newnode, *ptail, 0);
  }
#line 590
  if (node->flags & 2U) {
    {
#line 592
    tmp___0 = wsnode_ptr(wsp, node);
#line 592
    str = tmp___0;
#line 593
    tmp___1 = malloc(len + 1UL);
#line 593
    newstr = (char *)tmp___1;
    }
#line 594
    if (! newstr) {
      {
#line 595
      tmp___2 = _wsplt_nomem(wsp);
      }
#line 595
      return (tmp___2);
    }
    {
#line 596
    memcpy((void */* __restrict  */)newstr, (void const   */* __restrict  */)(str + beg),
           len);
#line 597
    *(newstr + len) = (char)0;
#line 598
    newnode->flags = 2U;
#line 599
    newnode->v.word = newstr;
    }
  } else {
#line 603
    newnode->v.segm.beg = node->v.segm.beg + beg;
#line 604
    newnode->v.segm.end = newnode->v.segm.beg + len;
  }
#line 606
  newnode->flags |= (unsigned int )flg;
#line 607
  *ptail = newnode;
#line 608
  return (0);
}
}
#line 611 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int find_closing_cbrace(char const   *str , size_t i , size_t len , size_t *poff ) 
{ 
  enum __anonenum_state_691190535 state ;
  size_t level ;

  {
#line 614
  state = (enum __anonenum_state_691190535 )0;
#line 616
  level = (size_t )1;
  {
#line 618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 618
    if (! (i < len)) {
#line 618
      goto while_break;
    }
    {
#line 622
    if ((unsigned int )state == 0U) {
#line 622
      goto case_0;
    }
#line 647
    if ((unsigned int )state == 1U) {
#line 647
      goto case_1;
    }
#line 652
    if ((unsigned int )state == 2U) {
#line 652
      goto case_2;
    }
#line 620
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 625
    if ((int const   )*(str + i) == 123) {
#line 625
      goto case_123;
    }
#line 629
    if ((int const   )*(str + i) == 125) {
#line 629
      goto case_125;
    }
#line 637
    if ((int const   )*(str + i) == 34) {
#line 637
      goto case_34;
    }
#line 641
    if ((int const   )*(str + i) == 39) {
#line 641
      goto case_39;
    }
#line 623
    goto switch_break___0;
    case_123: /* CIL Label */ 
#line 626
    level ++;
#line 627
    goto switch_break___0;
    case_125: /* CIL Label */ 
#line 630
    level --;
#line 630
    if (level == 0UL) {
#line 632
      *poff = i;
#line 633
      return (0);
    }
#line 635
    goto switch_break___0;
    case_34: /* CIL Label */ 
#line 638
    state = (enum __anonenum_state_691190535 )2;
#line 639
    goto switch_break___0;
    case_39: /* CIL Label */ 
#line 642
    state = (enum __anonenum_state_691190535 )1;
#line 643
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 645
    goto switch_break;
    case_1: /* CIL Label */ 
#line 648
    if ((int const   )*(str + i) == 39) {
#line 649
      state = (enum __anonenum_state_691190535 )0;
    }
#line 650
    goto switch_break;
    case_2: /* CIL Label */ 
#line 653
    if ((int const   )*(str + i) == 92) {
#line 654
      i ++;
    } else
#line 655
    if ((int const   )*(str + i) == 34) {
#line 656
      state = (enum __anonenum_state_691190535 )0;
    }
#line 657
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 660
  return (1);
}
}
#line 663 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static char const   *wordsplit_find_env(struct wordsplit *wsp , char const   *name ,
                                        size_t len ) 
{ 
  size_t i ;
  size_t elen ;
  size_t tmp ;
  int tmp___0 ;
  size_t j ;
  char const   *var ;

  {
#line 668
  if (! (wsp->ws_flags & 524288)) {
#line 669
    return ((char const   *)((void *)0));
  }
#line 671
  if (wsp->ws_flags & 134217728) {
#line 674
    i = (size_t )0;
    {
#line 674
    while (1) {
      while_continue: /* CIL Label */ ;
#line 674
      if (! *(wsp->ws_env + i)) {
#line 674
        goto while_break;
      }
      {
#line 676
      tmp = strlen(*(wsp->ws_env + i));
#line 676
      elen = tmp;
      }
#line 677
      if (elen == len) {
        {
#line 677
        tmp___0 = memcmp((void const   *)*(wsp->ws_env + i), (void const   *)name,
                         elen);
        }
#line 677
        if (tmp___0 == 0) {
#line 678
          return (*(wsp->ws_env + (i + 1UL)));
        }
      }
#line 680
      i ++;
#line 681
      if ((unsigned long )*(wsp->ws_env + i) == (unsigned long )((void *)0)) {
#line 682
        goto while_break;
      }
#line 674
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 688
    i = (size_t )0;
    {
#line 688
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 688
      if (! *(wsp->ws_env + i)) {
#line 688
        goto while_break___0;
      }
#line 691
      var = *(wsp->ws_env + i);
#line 693
      j = (size_t )0;
      {
#line 693
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 693
        if (! (j < len)) {
#line 693
          goto while_break___1;
        }
#line 694
        if ((int const   )*(name + j) != (int const   )*(var + j)) {
#line 695
          goto while_break___1;
        }
#line 693
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 696
      if (j == len) {
#line 696
        if ((int const   )*(var + j) == 61) {
#line 697
          return ((var + j) + 1);
        }
      }
#line 688
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 700
  return ((char const   *)((void *)0));
}
}
#line 703 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int expvar(struct wordsplit *wsp , char const   *str , size_t len , struct wordsplit_node **ptail ,
                  char const   **pend , int flg ) 
{ 
  size_t i ;
  char const   *defstr ;
  char const   *value___0 ;
  char const   *vptr ;
  struct wordsplit_node *newnode ;
  char const   *start ;
  size_t j ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  struct wordsplit ws ;
  int i___0 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t size ;
  int tmp___13 ;
  void *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 707
  i = (size_t )0;
#line 708
  defstr = (char const   *)((void *)0);
#line 712
  start = str - 1;
#line 714
  if (65U <= (unsigned int )*(str + 0)) {
#line 714
    if ((unsigned int )*(str + 0) <= 90U) {
#line 714
      goto _L___2;
    } else {
#line 714
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 714
  if (97U <= (unsigned int )*(str + 0)) {
#line 714
    if ((unsigned int )*(str + 0) <= 122U) {
#line 714
      goto _L___2;
    } else {
#line 714
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 714
  if ((int const   )*(str + 0) == 95) {
    _L___2: /* CIL Label */ 
#line 716
    i = (size_t )1;
    {
#line 716
    while (1) {
      while_continue: /* CIL Label */ ;
#line 716
      if (! (i < len)) {
#line 716
        goto while_break;
      }
#line 717
      if (65U <= (unsigned int )*(str + i)) {
#line 717
        if (! ((unsigned int )*(str + i) <= 90U)) {
#line 717
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 717
      if (97U <= (unsigned int )*(str + i)) {
#line 717
        if (! ((unsigned int )*(str + i) <= 122U)) {
#line 717
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 717
      if (48U <= (unsigned int )*(str + i)) {
#line 717
        if (! ((unsigned int )*(str + i) <= 57U)) {
#line 717
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 717
      if (! ((int const   )*(str + i) == 95)) {
#line 718
        goto while_break;
      }
#line 716
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 719
    *pend = (str + i) - 1;
  } else
#line 721
  if ((int const   )*(str + 0) == 123) {
#line 723
    str ++;
#line 724
    len --;
#line 725
    i = (size_t )1;
    {
#line 725
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 725
      if (! (i < len)) {
#line 725
        goto while_break___0;
      }
#line 726
      if ((int const   )*(str + i) == 125) {
#line 727
        goto while_break___0;
      } else
#line 726
      if ((int const   )*(str + i) == 58) {
#line 727
        goto while_break___0;
      }
#line 725
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 728
    if ((int const   )*(str + i) == 58) {
      {
#line 732
      defstr = (str + i) + 1;
#line 733
      tmp = find_closing_cbrace(str, i + 1UL, len, & j);
      }
#line 733
      if (tmp) {
#line 735
        wsp->ws_errno = 5;
#line 736
        return (1);
      }
#line 738
      *pend = str + j;
    } else
#line 740
    if ((int const   )*(str + i) == 125) {
#line 742
      defstr = (char const   *)((void *)0);
#line 743
      *pend = str + i;
    } else {
#line 747
      wsp->ws_errno = 5;
#line 748
      return (1);
    }
  } else {
    {
#line 753
    tmp___0 = wsnode_new(wsp, & newnode);
    }
#line 753
    if (tmp___0) {
#line 754
      return (1);
    }
    {
#line 755
    wsnode_insert(wsp, newnode, *ptail, 0);
#line 756
    *ptail = newnode;
#line 757
    newnode->flags = (unsigned int )(2 | flg);
#line 758
    tmp___1 = malloc((size_t )3);
#line 758
    newnode->v.word = (char *)tmp___1;
    }
#line 759
    if (! newnode->v.word) {
      {
#line 760
      tmp___2 = _wsplt_nomem(wsp);
      }
#line 760
      return (tmp___2);
    }
#line 761
    *(newnode->v.word + 0) = (char )'$';
#line 762
    *(newnode->v.word + 1) = (char )*(str + 0);
#line 763
    *(newnode->v.word + 2) = (char)0;
#line 764
    *pend = str;
#line 765
    return (0);
  }
  {
#line 773
  vptr = wordsplit_find_env(wsp, str, i);
  }
#line 774
  if (vptr) {
    {
#line 776
    tmp___3 = strdup(vptr);
#line 776
    value___0 = (char const   *)tmp___3;
    }
#line 777
    if (! value___0) {
      {
#line 778
      tmp___4 = _wsplt_nomem(wsp);
      }
#line 778
      return (tmp___4);
    }
  } else
#line 780
  if (wsp->ws_flags & 1048576) {
    {
#line 781
    value___0 = (*(wsp->ws_getvar))(str, i, wsp->ws_closure);
    }
  } else
#line 782
  if (wsp->ws_flags & 32) {
#line 784
    wsp->ws_errno = 6;
#line 785
    if (wsp->ws_flags & 16) {
      {
#line 786
      wordsplit_perror(wsp);
      }
    }
#line 787
    return (1);
  } else {
#line 791
    if (wsp->ws_flags & 16777216) {
      {
#line 792
      tmp___5 = gettext("warning: undefined variable `%.*s\'");
#line 792
      (*(wsp->ws_error))((char const   *)tmp___5, (int )i, str);
      }
    }
#line 793
    if (wsp->ws_flags & 8388608) {
#line 794
      value___0 = (char const   *)((void *)0);
    } else {
#line 796
      value___0 = "";
    }
  }
#line 802
  if (value___0) {
#line 804
    if (flg & 4) {
      {
#line 806
      tmp___6 = wsnode_new(wsp, & newnode);
      }
#line 806
      if (tmp___6) {
#line 807
        return (1);
      }
      {
#line 808
      wsnode_insert(wsp, newnode, *ptail, 0);
#line 809
      *ptail = newnode;
#line 810
      newnode->flags = (unsigned int )(10 | flg);
#line 811
      newnode->v.word = strdup(value___0);
      }
#line 812
      if (! newnode->v.word) {
        {
#line 813
        tmp___7 = _wsplt_nomem(wsp);
        }
#line 813
        return (tmp___7);
      }
    } else
#line 815
    if ((int const   )*value___0 == 0) {
      {
#line 818
      tmp___8 = wsnode_new(wsp, & newnode);
      }
#line 818
      if (tmp___8) {
#line 819
        return (1);
      }
      {
#line 820
      wsnode_insert(wsp, newnode, *ptail, 0);
#line 821
      *ptail = newnode;
#line 822
      newnode->flags = 1U;
      }
    } else {
      {
#line 829
      ws.ws_delim = wsp->ws_delim;
#line 830
      tmp___9 = wordsplit(value___0, & ws, 16708);
      }
#line 830
      if (tmp___9) {
        {
#line 833
        wordsplit_free(& ws);
        }
#line 834
        return (1);
      }
#line 836
      i___0 = 0;
      {
#line 836
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 836
        if (! ((size_t )i___0 < ws.ws_wordc)) {
#line 836
          goto while_break___1;
        }
        {
#line 838
        tmp___10 = wsnode_new(wsp, & newnode);
        }
#line 838
        if (tmp___10) {
#line 839
          return (1);
        }
        {
#line 840
        wsnode_insert(wsp, newnode, *ptail, 0);
#line 841
        *ptail = newnode;
        }
#line 842
        if ((size_t )(i___0 + 1) < ws.ws_wordc) {
#line 842
          tmp___11 = flg & -17;
        } else {
#line 842
          tmp___11 = flg;
        }
        {
#line 842
        newnode->flags = (unsigned int )(10 | tmp___11);
#line 845
        newnode->v.word = strdup((char const   *)*(ws.ws_wordv + i___0));
        }
#line 846
        if (! newnode->v.word) {
          {
#line 847
          tmp___12 = _wsplt_nomem(wsp);
          }
#line 847
          return (tmp___12);
        }
#line 836
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 849
      wordsplit_free(& ws);
      }
    }
  } else
#line 852
  if (wsp->ws_flags & 8388608) {
    {
#line 854
    size = (size_t )((*pend - start) + 1L);
#line 856
    tmp___13 = wsnode_new(wsp, & newnode);
    }
#line 856
    if (tmp___13) {
#line 857
      return (1);
    }
    {
#line 858
    wsnode_insert(wsp, newnode, *ptail, 0);
#line 859
    *ptail = newnode;
#line 860
    newnode->flags = (unsigned int )(10 | flg);
#line 861
    tmp___14 = malloc(size + 1UL);
#line 861
    newnode->v.word = (char *)tmp___14;
    }
#line 862
    if (! newnode->v.word) {
      {
#line 863
      tmp___15 = _wsplt_nomem(wsp);
      }
#line 863
      return (tmp___15);
    }
    {
#line 864
    memcpy((void */* __restrict  */)newnode->v.word, (void const   */* __restrict  */)start,
           size);
#line 865
    *(newnode->v.word + size) = (char)0;
    }
  } else {
    {
#line 869
    tmp___16 = wsnode_new(wsp, & newnode);
    }
#line 869
    if (tmp___16) {
#line 870
      return (1);
    }
    {
#line 871
    wsnode_insert(wsp, newnode, *ptail, 0);
#line 872
    *ptail = newnode;
#line 873
    newnode->flags = 1U;
    }
  }
#line 875
  return (0);
}
}
#line 878 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int node_expand_vars(struct wordsplit *wsp , struct wordsplit_node *node ) 
{ 
  char const   *str ;
  char const   *tmp ;
  size_t slen ;
  size_t tmp___0 ;
  char const   *end ;
  char const   *p ;
  size_t off ;
  struct wordsplit_node *tail ;
  size_t n ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 881
  tmp = wsnode_ptr(wsp, node);
#line 881
  str = tmp;
#line 882
  tmp___0 = wsnode_len(node);
#line 882
  slen = tmp___0;
#line 883
  end = str + slen;
#line 885
  off = (size_t )0;
#line 886
  tail = node;
#line 888
  p = str;
  }
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 888
      goto while_break;
    }
#line 890
    if ((int const   )*p == 92) {
#line 892
      p ++;
#line 893
      goto __Cont;
    }
#line 895
    if ((int const   )*p == 36) {
#line 897
      n = (size_t )(p - str);
#line 899
      if ((unsigned long )tail != (unsigned long )node) {
#line 900
        tail->flags |= 16U;
      }
      {
#line 901
      tmp___1 = node_split_prefix(wsp, & tail, node, off, n, 16);
      }
#line 901
      if (tmp___1) {
#line 902
        return (1);
      }
      {
#line 903
      p ++;
#line 904
      tmp___2 = expvar(wsp, p, slen - n, & tail, & p, (int )(node->flags & 20U));
      }
#line 904
      if (tmp___2) {
#line 906
        return (1);
      }
#line 907
      off += (size_t )((p - str) + 1L);
#line 908
      str = p + 1;
    }
    __Cont: /* CIL Label */ 
#line 888
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 911
  if ((unsigned long )p > (unsigned long )str) {
#line 913
    if ((unsigned long )tail != (unsigned long )node) {
#line 914
      tail->flags |= 16U;
    }
    {
#line 915
    tmp___3 = node_split_prefix(wsp, & tail, node, off, (size_t )(p - str), (int )(node->flags & 16U));
    }
#line 915
    if (tmp___3) {
#line 917
      return (1);
    }
  }
#line 919
  if ((unsigned long )tail != (unsigned long )node) {
    {
#line 921
    wsnode_remove(wsp, node);
#line 922
    wsnode_free(node);
    }
  }
#line 924
  return (0);
}
}
#line 928 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wsnode_nullelim(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *next ;

  {
#line 933
  p = wsp->ws_head;
  {
#line 933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 933
    if (! p) {
#line 933
      goto while_break;
    }
#line 935
    next = p->next;
#line 936
    if (p->flags & 1U) {
      {
#line 938
      wsnode_remove(wsp, p);
#line 939
      wsnode_free(p);
      }
    }
#line 941
    p = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 943
  return;
}
}
#line 945 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wordsplit_varexp(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  struct wordsplit_node *next ;
  int tmp ;

  {
#line 950
  p = wsp->ws_head;
  {
#line 950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 950
    if (! p) {
#line 950
      goto while_break;
    }
#line 952
    next = p->next;
#line 953
    if (! (p->flags & 8U)) {
      {
#line 954
      tmp = node_expand_vars(wsp, p);
      }
#line 954
      if (tmp) {
#line 955
        return (1);
      }
    }
#line 956
    p = next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 959
  wsnode_nullelim(wsp);
  }
#line 960
  return (0);
}
}
#line 966 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static void wordsplit_trimws(struct wordsplit *wsp ) 
{ 
  struct wordsplit_node *p ;
  size_t n ;

  {
#line 971
  p = wsp->ws_head;
  {
#line 971
  while (1) {
    while_continue: /* CIL Label */ ;
#line 971
    if (! p) {
#line 971
      goto while_break;
    }
#line 975
    if (p->flags & 4U) {
#line 976
      goto __Cont;
    }
#line 979
    n = p->v.segm.beg;
    {
#line 979
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 979
      if (n < p->v.segm.end) {
#line 979
        if (! ((int const   )*(wsp->ws_input + n) == 32)) {
#line 979
          if (! ((int const   )*(wsp->ws_input + n) == 9)) {
#line 979
            if (! ((int const   )*(wsp->ws_input + n) == 10)) {
#line 979
              goto while_break___0;
            }
          }
        }
      } else {
#line 979
        goto while_break___0;
      }
#line 979
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 982
    p->v.segm.beg = n;
#line 984
    n = p->v.segm.end;
    {
#line 984
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 984
      if (n > p->v.segm.beg) {
#line 984
        if (! ((int const   )*(wsp->ws_input + (n - 1UL)) == 32)) {
#line 984
          if (! ((int const   )*(wsp->ws_input + (n - 1UL)) == 9)) {
#line 984
            if (! ((int const   )*(wsp->ws_input + (n - 1UL)) == 10)) {
#line 984
              goto while_break___1;
            }
          }
        }
      } else {
#line 984
        goto while_break___1;
      }
#line 984
      n --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 986
    p->v.segm.end = n;
#line 987
    if (p->v.segm.beg == p->v.segm.end) {
#line 988
      p->flags |= 1U;
    }
    __Cont: /* CIL Label */ 
#line 971
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 991
  wsnode_nullelim(wsp);
  }
#line 992
  return;
}
}
#line 994 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int skip_sed_expr(char const   *command , size_t i , size_t len ) 
{ 
  int state ;
  int delim ;
  char *tmp ;

  {
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if ((int const   )*(command + i) == 59) {
#line 1004
      i ++;
    }
#line 1005
    if ((int const   )*(command + i) == 115) {
#line 1005
      if (i + 3UL < len) {
        {
#line 1005
        tmp = strchr("!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~", (int )*(command + (i + 1UL)));
        }
#line 1005
        if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1006
          goto while_break;
        }
      } else {
#line 1006
        goto while_break;
      }
    } else {
#line 1006
      goto while_break;
    }
#line 1008
    i ++;
#line 1008
    delim = (int )*(command + i);
#line 1009
    state = 1;
#line 1010
    i ++;
    {
#line 1010
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1010
      if (! (i < len)) {
#line 1010
        goto while_break___0;
      }
#line 1012
      if (state == 3) {
#line 1014
        if ((int const   )*(command + i) == (int const   )delim) {
#line 1015
          goto while_break___0;
        } else
#line 1014
        if (65U <= (unsigned int )*(command + i)) {
#line 1014
          if (! ((unsigned int )*(command + i) <= 90U)) {
#line 1014
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1014
        if (97U <= (unsigned int )*(command + i)) {
#line 1014
          if (! ((unsigned int )*(command + i) <= 122U)) {
#line 1014
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1014
        if (48U <= (unsigned int )*(command + i)) {
#line 1014
          if (! ((unsigned int )*(command + i) <= 57U)) {
#line 1015
            goto while_break___0;
          }
        } else {
#line 1015
          goto while_break___0;
        }
      } else
#line 1017
      if ((int const   )*(command + i) == 92) {
#line 1018
        i ++;
      } else
#line 1019
      if ((int const   )*(command + i) == (int const   )delim) {
#line 1020
        state ++;
      }
#line 1010
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 999
    if (state == 3) {
#line 999
      if (i < len) {
#line 999
        if (! ((int const   )*(command + i) == 59)) {
#line 999
          goto while_break;
        }
      } else {
#line 999
        goto while_break;
      }
    } else {
#line 999
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  return ((int )i);
}
}
#line 1027 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static size_t skip_delim(struct wordsplit *wsp ) 
{ 
  size_t start ;
  int delim ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1030
  start = wsp->ws_endp;
#line 1031
  if (wsp->ws_flags & 2048) {
#line 1033
    if (wsp->ws_flags & 4096) {
      {
#line 1033
      tmp___0 = strchr(wsp->ws_delim, (int )*(wsp->ws_input + start));
      }
#line 1033
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1036
        delim = (int )*(wsp->ws_input + start);
        {
#line 1037
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1038
          start ++;
#line 1037
          if (start < wsp->ws_len) {
#line 1037
            if (! (delim == (int )*(wsp->ws_input + start))) {
#line 1037
              goto while_break;
            }
          } else {
#line 1037
            goto while_break;
          }
        }
        while_break: /* CIL Label */ ;
        }
      } else {
#line 1033
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1043
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1044
        start ++;
#line 1043
        if (start < wsp->ws_len) {
          {
#line 1043
          tmp = strchr(wsp->ws_delim, (int )*(wsp->ws_input + start));
          }
#line 1043
          if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 1043
            goto while_break___0;
          }
        } else {
#line 1043
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1047
    start --;
  }
#line 1050
  if (! (wsp->ws_flags & 4096)) {
#line 1051
    start ++;
  }
#line 1053
  return (start);
}
}
#line 1060 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int scan_qstring(struct wordsplit *wsp , size_t start , size_t *end ) 
{ 
  size_t j ;
  char const   *command ;
  size_t len ;
  char q ;
  int flags ;
  int tmp ;

  {
#line 1064
  command = wsp->ws_input;
#line 1065
  len = wsp->ws_len;
#line 1066
  q = (char )*(command + start);
#line 1068
  j = start + 1UL;
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (j < len) {
#line 1068
      if (! ((int const   )*(command + j) != (int const   )q)) {
#line 1068
        goto while_break;
      }
    } else {
#line 1068
      goto while_break;
    }
#line 1069
    if ((int )q == 34) {
#line 1069
      if ((int const   )*(command + j) == 92) {
#line 1070
        j ++;
      }
    }
#line 1068
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1071
  if (j < len) {
#line 1071
    if ((int const   )*(command + j) == (int const   )q) {
#line 1073
      flags = 260;
#line 1074
      if ((int )q == 39) {
#line 1075
        flags |= 8;
      }
      {
#line 1076
      tmp = wordsplit_add_segm(wsp, start + 1UL, j, flags);
      }
#line 1076
      if (tmp) {
#line 1077
        return (2);
      }
#line 1078
      *end = j;
    } else {
#line 1071
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1082
    wsp->ws_endp = start;
#line 1083
    wsp->ws_errno = 1;
#line 1084
    if (wsp->ws_flags & 16) {
      {
#line 1085
      wordsplit_perror(wsp);
      }
    }
#line 1086
    return (2);
  }
#line 1088
  return (0);
}
}
#line 1091 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int scan_word(struct wordsplit *wsp , size_t start ) 
{ 
  size_t len ;
  char const   *command ;
  char const   *comment ;
  int join ;
  int flags ;
  size_t i ;
  int tmp ;
  size_t j ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
#line 1094
  len = wsp->ws_len;
#line 1095
  command = wsp->ws_input;
#line 1096
  comment = wsp->ws_comment;
#line 1097
  join = 0;
#line 1098
  flags = 0;
#line 1100
  i = start;
#line 1102
  if (i >= len) {
#line 1104
    wsp->ws_errno = 0;
#line 1105
    return (0);
  }
#line 1108
  start = i;
#line 1110
  if (wsp->ws_flags & 8192) {
#line 1110
    if ((int const   )*(command + i) == 115) {
#line 1110
      if (i + 3UL < len) {
        {
#line 1110
        tmp___6 = strchr("!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~", (int )*(command + (i + 1UL)));
        }
#line 1110
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
          {
#line 1113
          flags = 32;
#line 1114
          tmp = skip_sed_expr(command, i, len);
#line 1114
          i = (size_t )tmp;
          }
        } else {
#line 1110
          goto _L___3;
        }
      } else {
#line 1110
        goto _L___3;
      }
    } else {
#line 1110
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 1116
    tmp___5 = strchr(wsp->ws_delim, (int )*(command + i));
    }
#line 1116
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 1161
      if (wsp->ws_flags & 4096) {
#line 1163
        i ++;
      } else
#line 1165
      if (! (wsp->ws_flags & 2048)) {
#line 1166
        flags |= 256;
      }
    } else {
      {
#line 1118
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1118
        if (! (i < len)) {
#line 1118
          goto while_break;
        }
#line 1120
        if (comment) {
          {
#line 1120
          tmp___1 = strchr(comment, (int )*(command + i));
          }
#line 1120
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1123
            j = i + 1UL;
            {
#line 1123
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1123
              if (j < len) {
#line 1123
                if (! ((int const   )*(command + j) != 10)) {
#line 1123
                  goto while_break___0;
                }
              } else {
#line 1123
                goto while_break___0;
              }
#line 1123
              j ++;
            }
            while_break___0: /* CIL Label */ ;
            }
            {
#line 1125
            tmp___0 = wordsplit_add_segm(wsp, start, i, 0);
            }
#line 1125
            if (tmp___0) {
#line 1126
              return (2);
            }
#line 1127
            wsp->ws_endp = j;
#line 1128
            return (1);
          }
        }
#line 1131
        if (wsp->ws_flags & 1536) {
#line 1133
          if ((int const   )*(command + i) == 92) {
#line 1135
            i ++;
#line 1135
            if (i == len) {
#line 1136
              goto while_break;
            }
#line 1137
            i ++;
#line 1138
            goto while_continue;
          }
#line 1141
          if (wsp->ws_flags & 512) {
#line 1141
            if ((int const   )*(command + i) == 39) {
#line 1141
              goto _L;
            } else {
#line 1141
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1141
          if (wsp->ws_flags & 1024) {
#line 1141
            if ((int const   )*(command + i) == 34) {
              _L: /* CIL Label */ 
#line 1144
              if (join) {
#line 1144
                if (wsp->ws_tail) {
#line 1145
                  (wsp->ws_tail)->flags |= 16U;
                }
              }
              {
#line 1146
              tmp___2 = wordsplit_add_segm(wsp, start, i, 16);
              }
#line 1146
              if (tmp___2) {
#line 1147
                return (2);
              }
              {
#line 1148
              tmp___3 = scan_qstring(wsp, i, & i);
              }
#line 1148
              if (tmp___3) {
#line 1149
                return (2);
              }
#line 1150
              start = i + 1UL;
#line 1151
              join = 1;
            }
          }
        }
        {
#line 1155
        tmp___4 = strchr(wsp->ws_delim, (int )*(command + i));
        }
#line 1155
        if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 1156
          goto while_break;
        } else {
#line 1158
          i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1168
  if (join) {
#line 1168
    if (i > start) {
#line 1168
      if (wsp->ws_tail) {
#line 1169
        (wsp->ws_tail)->flags |= 16U;
      }
    }
  }
  {
#line 1170
  tmp___7 = wordsplit_add_segm(wsp, start, i, flags);
  }
#line 1170
  if (tmp___7) {
#line 1171
    return (2);
  }
#line 1172
  wsp->ws_endp = i;
#line 1173
  if (wsp->ws_flags & 536870912) {
#line 1174
    return (0);
  }
#line 1175
  return (1);
}
}
#line 1178 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static char quote_transtab[19]  = 
#line 1178
  {      (char )'\\',      (char )'\\',      (char )'\"',      (char )'\"', 
        (char )'a',      (char )'\a',      (char )'b',      (char )'\b', 
        (char )'f',      (char )'\f',      (char )'n',      (char )'\n', 
        (char )'r',      (char )'\r',      (char )'t',      (char )'\t', 
        (char )'v',      (char )'\v',      (char )'\000'};
#line 1180 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
int wordsplit_c_unquote_char(int c ) 
{ 
  char *p ;

  {
#line 1185
  p = quote_transtab;
  {
#line 1185
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1185
    if (! *p) {
#line 1185
      goto while_break;
    }
#line 1187
    if ((int )*p == c) {
#line 1188
      return ((int )*(p + 1));
    }
#line 1185
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  return (c);
}
}
#line 1193 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
int wordsplit_c_quote_char(int c ) 
{ 
  char *p ;

  {
#line 1198
  p = (quote_transtab + sizeof(quote_transtab)) - 2;
  {
#line 1198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1198
    if (! ((unsigned long )p > (unsigned long )(quote_transtab))) {
#line 1198
      goto while_break;
    }
#line 1201
    if ((int )*p == c) {
#line 1202
      return ((int )*(p + -1));
    }
#line 1198
    p -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  return (-1);
}
}
#line 1210 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int xtonum(int *pval , char const   *src , int base , int cnt ) 
{ 
  int i ;
  int val___0 ;
  int n ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 1215
  i = 0;
#line 1215
  val___0 = 0;
  {
#line 1215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1215
    if (! (i < cnt)) {
#line 1215
      goto while_break;
    }
#line 1217
    n = (int )*((unsigned char *)src);
#line 1218
    if (n > 127) {
#line 1219
      goto while_break;
    } else {
#line 1218
      if (48U <= (unsigned int )n) {
#line 1218
        if ((unsigned int )n <= 57U) {
#line 1218
          n -= 48;
        } else {
#line 1218
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1218
        tmp___2 = strchr("abcdefABCDEF", n);
        }
#line 1218
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
          {
#line 1218
          tmp___0 = toupper(n);
#line 1218
          tmp___1 = (tmp___0 - 65) + 10;
          }
        } else {
#line 1218
          tmp___1 = 255;
        }
#line 1218
        n = tmp___1;
      }
#line 1218
      if (n >= base) {
#line 1219
        goto while_break;
      }
    }
#line 1220
    val___0 = val___0 * base + n;
#line 1215
    i ++;
#line 1215
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  *pval = val___0;
#line 1223
  return (i);
}
}
#line 1226 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
size_t wordsplit_c_quoted_length(char const   *str , int quote_hex , int *quote___0 ) 
{ 
  size_t len ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1229
  len = (size_t )0;
#line 1231
  *quote___0 = 0;
  {
#line 1232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1232
    if (! *str) {
#line 1232
      goto while_break;
    }
    {
#line 1234
    tmp = strchr(" \"", (int )*str);
    }
#line 1234
    if (tmp) {
#line 1235
      *quote___0 = 1;
    }
#line 1237
    if ((int const   )*str == 32) {
#line 1238
      len ++;
    } else
#line 1239
    if ((int const   )*str == 34) {
#line 1240
      len += 2UL;
    } else
#line 1241
    if ((int const   )*str != 9) {
#line 1241
      if ((int const   )*str != 92) {
#line 1241
        if (32U <= (unsigned int )*str) {
#line 1241
          if ((unsigned int )*str <= 127U) {
#line 1242
            len ++;
          } else {
#line 1241
            goto _L___0;
          }
        } else {
#line 1241
          goto _L___0;
        }
      } else {
#line 1241
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1243
    if (quote_hex) {
#line 1244
      len += 3UL;
    } else {
      {
#line 1247
      tmp___0 = wordsplit_c_quote_char((int )*str);
      }
#line 1247
      if (tmp___0 != -1) {
#line 1248
        len += 2UL;
      } else {
#line 1250
        len += 4UL;
      }
    }
#line 1232
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  return (len);
}
}
#line 1256 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_general_unquote_copy(char *dst , char const   *src , size_t n , char const   *escapable ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1262
  i = 0;
  {
#line 1262
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1262
    if (! ((size_t )i < n)) {
#line 1262
      goto while_break;
    }
#line 1264
    if ((int const   )*(src + i) == 92) {
#line 1264
      if ((size_t )i < n) {
        {
#line 1264
        tmp = strchr(escapable, (int )*(src + (i + 1)));
        }
#line 1264
        if (tmp) {
#line 1265
          i ++;
        }
      }
    }
#line 1266
    tmp___0 = dst;
#line 1266
    dst ++;
#line 1266
    tmp___1 = i;
#line 1266
    i ++;
#line 1266
    *tmp___0 = (char )*(src + tmp___1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1268
  *dst = (char)0;
#line 1269
  return;
}
}
#line 1271 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_sh_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  char *tmp ;
  int tmp___0 ;

  {
#line 1276
  i = 0;
  {
#line 1276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1276
    if (! ((size_t )i < n)) {
#line 1276
      goto while_break;
    }
#line 1278
    if ((int const   )*(src + i) == 92) {
#line 1279
      i ++;
    }
#line 1280
    tmp = dst;
#line 1280
    dst ++;
#line 1280
    tmp___0 = i;
#line 1280
    i ++;
#line 1280
    *tmp = (char )*(src + tmp___0);
  }
  while_break: /* CIL Label */ ;
  }
#line 1282
  *dst = (char)0;
#line 1283
  return;
}
}
#line 1285 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_c_unquote_copy(char *dst , char const   *src , size_t n ) 
{ 
  int i ;
  int c ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int off ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int off___0 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 1288
  i = 0;
  {
#line 1291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1291
    if (! ((size_t )i < n)) {
#line 1291
      goto while_break;
    }
#line 1293
    if ((int const   )*(src + i) == 92) {
#line 1295
      i ++;
#line 1296
      if ((int const   )*(src + i) == 120) {
#line 1296
        goto _L___0;
      } else
#line 1296
      if ((int const   )*(src + i) == 88) {
        _L___0: /* CIL Label */ 
#line 1298
        if (n - (size_t )i < 2UL) {
#line 1300
          tmp = dst;
#line 1300
          dst ++;
#line 1300
          *tmp = (char )'\\';
#line 1301
          tmp___0 = dst;
#line 1301
          dst ++;
#line 1301
          tmp___1 = i;
#line 1301
          i ++;
#line 1301
          *tmp___0 = (char )*(src + tmp___1);
        } else {
          {
#line 1305
          tmp___2 = xtonum(& c, (src + i) + 1, 16, 2);
#line 1305
          off = tmp___2;
          }
#line 1307
          if (off == 0) {
#line 1309
            tmp___3 = dst;
#line 1309
            dst ++;
#line 1309
            *tmp___3 = (char )'\\';
#line 1310
            tmp___4 = dst;
#line 1310
            dst ++;
#line 1310
            tmp___5 = i;
#line 1310
            i ++;
#line 1310
            *tmp___4 = (char )*(src + tmp___5);
          } else {
#line 1314
            tmp___6 = dst;
#line 1314
            dst ++;
#line 1314
            *tmp___6 = (char )c;
#line 1315
            i += off + 1;
          }
        }
      } else
#line 1319
      if ((int )((unsigned char )*(src + i)) < 128) {
#line 1319
        if (48U <= (unsigned int )*(src + i)) {
#line 1319
          if ((unsigned int )*(src + i) <= 57U) {
#line 1321
            if (n - (size_t )i < 1UL) {
#line 1323
              tmp___7 = dst;
#line 1323
              dst ++;
#line 1323
              *tmp___7 = (char )'\\';
#line 1324
              tmp___8 = dst;
#line 1324
              dst ++;
#line 1324
              tmp___9 = i;
#line 1324
              i ++;
#line 1324
              *tmp___8 = (char )*(src + tmp___9);
            } else {
              {
#line 1328
              tmp___10 = xtonum(& c, src + i, 8, 3);
#line 1328
              off___0 = tmp___10;
              }
#line 1329
              if (off___0 == 0) {
#line 1331
                tmp___11 = dst;
#line 1331
                dst ++;
#line 1331
                *tmp___11 = (char )'\\';
#line 1332
                tmp___12 = dst;
#line 1332
                dst ++;
#line 1332
                tmp___13 = i;
#line 1332
                i ++;
#line 1332
                *tmp___12 = (char )*(src + tmp___13);
              } else {
#line 1336
                tmp___14 = dst;
#line 1336
                dst ++;
#line 1336
                *tmp___14 = (char )c;
#line 1337
                i += off___0;
              }
            }
          } else {
#line 1319
            goto _L;
          }
        } else {
#line 1319
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 1342
        tmp___15 = dst;
#line 1342
        dst ++;
#line 1342
        tmp___16 = i;
#line 1342
        i ++;
#line 1342
        tmp___17 = wordsplit_c_unquote_char((int )*(src + tmp___16));
#line 1342
        *tmp___15 = (char )tmp___17;
        }
      }
    } else {
#line 1345
      tmp___18 = dst;
#line 1345
      dst ++;
#line 1345
      tmp___19 = i;
#line 1345
      i ++;
#line 1345
      *tmp___18 = (char )*(src + tmp___19);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1347
  *dst = (char)0;
#line 1348
  return;
}
}
#line 1350 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_c_quote_copy(char *dst , char const   *src , int quote_hex ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char tmp___2[4] ;
  int c ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 1353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1353
    if (! *src) {
#line 1353
      goto while_break;
    }
#line 1355
    if ((int const   )*src == 34) {
#line 1357
      tmp = dst;
#line 1357
      dst ++;
#line 1357
      *tmp = (char )'\\';
#line 1358
      tmp___0 = dst;
#line 1358
      dst ++;
#line 1358
      *tmp___0 = (char )*src;
    } else
#line 1360
    if ((int const   )*src != 9) {
#line 1360
      if ((int const   )*src != 92) {
#line 1360
        if (32U <= (unsigned int )*src) {
#line 1360
          if ((unsigned int )*src <= 127U) {
#line 1361
            tmp___1 = dst;
#line 1361
            dst ++;
#line 1361
            *tmp___1 = (char )*src;
          } else {
#line 1360
            goto _L___0;
          }
        } else {
#line 1360
          goto _L___0;
        }
      } else {
#line 1360
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1366
    if (quote_hex) {
      {
#line 1368
      snprintf((char */* __restrict  */)(tmp___2), sizeof(tmp___2), (char const   */* __restrict  */)"%%%02X",
               (int )*((unsigned char *)src));
#line 1369
      memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
             (size_t )3);
#line 1370
      dst += 3;
      }
    } else {
      {
#line 1374
      tmp___3 = wordsplit_c_quote_char((int )*src);
#line 1374
      c = tmp___3;
#line 1375
      tmp___4 = dst;
#line 1375
      dst ++;
#line 1375
      *tmp___4 = (char )'\\';
      }
#line 1376
      if (c != -1) {
#line 1377
        tmp___5 = dst;
#line 1377
        dst ++;
#line 1377
        *tmp___5 = (char )c;
      } else {
        {
#line 1380
        snprintf((char */* __restrict  */)(tmp___2), sizeof(tmp___2), (char const   */* __restrict  */)"%03o",
                 (int )*((unsigned char *)src));
#line 1381
        memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(tmp___2),
               (size_t )3);
#line 1382
        dst += 3;
        }
      }
    }
#line 1353
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1387
  return;
}
}
#line 1389 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
static int wordsplit_process_list(struct wordsplit *wsp , size_t start ) 
{ 
  int tmp ;
  int rc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1392
  if (wsp->ws_flags & 4194304) {
    {
#line 1395
    tmp = wordsplit_add_segm(wsp, start, wsp->ws_len, 4);
    }
#line 1395
    if (tmp) {
#line 1396
      return (wsp->ws_errno);
    }
  } else {
    {
#line 1402
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1402
      rc = scan_word(wsp, start);
      }
#line 1402
      if (! (rc == 1)) {
#line 1402
        goto while_break;
      }
      {
#line 1403
      start = skip_delim(wsp);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1405
    if (wsp->ws_tail) {
#line 1406
      (wsp->ws_tail)->flags &= 4294967279U;
    }
#line 1407
    if (rc == 2) {
#line 1408
      return (wsp->ws_errno);
    }
  }
#line 1411
  if (wsp->ws_flags & 2097152) {
    {
#line 1413
    (*(wsp->ws_debug))("Initial list:");
#line 1414
    wordsplit_dump_nodes(wsp);
    }
  }
#line 1417
  if (wsp->ws_flags & 256) {
    {
#line 1420
    wordsplit_trimws(wsp);
    }
#line 1421
    if (wsp->ws_flags & 2097152) {
      {
#line 1423
      (*(wsp->ws_debug))("After WS trimming:");
#line 1424
      wordsplit_dump_nodes(wsp);
      }
    }
  }
#line 1429
  if (! (wsp->ws_flags & 64)) {
    {
#line 1431
    tmp___0 = wordsplit_varexp(wsp);
    }
#line 1431
    if (tmp___0) {
      {
#line 1433
      wordsplit_free_nodes(wsp);
      }
#line 1434
      return (wsp->ws_errno);
    }
#line 1436
    if (wsp->ws_flags & 2097152) {
      {
#line 1438
      (*(wsp->ws_debug))("Expanded list:");
#line 1439
      wordsplit_dump_nodes(wsp);
      }
    }
  }
  {
#line 1443
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1445
    tmp___1 = wsnode_quoteremoval(wsp);
    }
#line 1445
    if (tmp___1) {
#line 1446
      goto while_break___0;
    }
#line 1447
    if (wsp->ws_flags & 2097152) {
      {
#line 1449
      (*(wsp->ws_debug))("After quote removal:");
#line 1450
      wordsplit_dump_nodes(wsp);
      }
    }
    {
#line 1453
    tmp___2 = wsnode_coalesce(wsp);
    }
#line 1453
    if (tmp___2) {
#line 1454
      goto while_break___0;
    }
#line 1456
    if (wsp->ws_flags & 2097152) {
      {
#line 1458
      (*(wsp->ws_debug))("Coalesced list:");
#line 1459
      wordsplit_dump_nodes(wsp);
      }
    }
#line 1443
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1463
  return (wsp->ws_errno);
}
}
#line 1466 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
int wordsplit_len(char const   *command , size_t length , struct wordsplit *wsp ,
                  int flags ) 
{ 
  int rc ;
  size_t start ;
  char const   *cmdptr ;
  size_t cmdlen ;

  {
#line 1475
  if (! command) {
#line 1477
    if (! (flags & 536870912)) {
#line 1478
      return (22);
    }
    {
#line 1480
    start = skip_delim(wsp);
    }
#line 1481
    if (wsp->ws_endp == wsp->ws_len) {
#line 1483
      wsp->ws_errno = 7;
#line 1484
      if (wsp->ws_flags & 16) {
        {
#line 1485
        wordsplit_perror(wsp);
        }
      }
#line 1486
      return (wsp->ws_errno);
    }
    {
#line 1489
    cmdptr = wsp->ws_input + wsp->ws_endp;
#line 1490
    cmdlen = wsp->ws_len - wsp->ws_endp;
#line 1491
    wsp->ws_flags |= 8;
#line 1492
    wordsplit_init0(wsp);
    }
  } else {
    {
#line 1496
    cmdptr = command;
#line 1497
    cmdlen = length;
#line 1498
    start = (size_t )0;
#line 1499
    rc = wordsplit_init(wsp, cmdptr, cmdlen, flags);
    }
#line 1500
    if (rc) {
#line 1501
      return (rc);
    }
  }
#line 1504
  if (wsp->ws_flags & 2097152) {
    {
#line 1505
    (*(wsp->ws_debug))("Input:%.*s;", (int )cmdlen, cmdptr);
    }
  }
  {
#line 1507
  rc = wordsplit_process_list(wsp, start);
  }
#line 1508
  if (rc == 0) {
#line 1508
    if (flags & 536870912) {
      {
#line 1510
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1510
        if (! wsp->ws_head) {
#line 1510
          if (! (wsp->ws_endp < wsp->ws_len)) {
#line 1510
            goto while_break;
          }
        } else {
#line 1510
          goto while_break;
        }
        {
#line 1512
        start = skip_delim(wsp);
        }
#line 1513
        if (wsp->ws_flags & 2097152) {
          {
#line 1515
          cmdptr = wsp->ws_input + wsp->ws_endp;
#line 1516
          cmdlen = wsp->ws_len - wsp->ws_endp;
#line 1517
          (*(wsp->ws_debug))("Restart:%.*s;", (int )cmdlen, cmdptr);
          }
        }
        {
#line 1519
        rc = wordsplit_process_list(wsp, start);
        }
#line 1520
        if (rc) {
#line 1521
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1524
  if (rc) {
    {
#line 1526
    wordsplit_free_nodes(wsp);
    }
#line 1527
    return (rc);
  }
  {
#line 1529
  wordsplit_finish(wsp);
#line 1530
  wordsplit_free_nodes(wsp);
  }
#line 1531
  return (wsp->ws_errno);
}
}
#line 1534 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
int wordsplit(char const   *command , struct wordsplit *ws , int flags ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 1537
  if (command) {
    {
#line 1537
    tmp = strlen(command);
#line 1537
    tmp___0 = tmp;
    }
  } else {
#line 1537
    tmp___0 = (size_t )0;
  }
  {
#line 1537
  tmp___1 = wordsplit_len(command, tmp___0, ws, flags);
  }
#line 1537
  return (tmp___1);
}
}
#line 1541 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_free_words(struct wordsplit *ws ) 
{ 
  size_t i ;
  char *p ;

  {
#line 1546
  i = (size_t )0;
  {
#line 1546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1546
    if (! (i < ws->ws_wordc)) {
#line 1546
      goto while_break;
    }
#line 1548
    p = *(ws->ws_wordv + (ws->ws_offs + i));
#line 1549
    if (p) {
      {
#line 1551
      free((void *)p);
#line 1552
      *(ws->ws_wordv + (ws->ws_offs + i)) = (char *)((void *)0);
      }
    }
#line 1546
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1555
  ws->ws_wordc = (size_t )0;
#line 1556
  return;
}
}
#line 1558 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_free(struct wordsplit *ws ) 
{ 


  {
  {
#line 1561
  wordsplit_free_words(ws);
#line 1562
  free((void *)ws->ws_wordv);
#line 1563
  ws->ws_wordv = (char **)((void *)0);
  }
#line 1564
  return;
}
}
#line 1566 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
void wordsplit_perror(struct wordsplit *wsp ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 1571
  if (wsp->ws_errno == 0) {
#line 1571
    goto case_0;
  }
#line 1575
  if (wsp->ws_errno == 1) {
#line 1575
    goto case_1;
  }
#line 1581
  if (wsp->ws_errno == 2) {
#line 1581
    goto case_2;
  }
#line 1585
  if (wsp->ws_errno == 3) {
#line 1585
    goto case_3;
  }
#line 1588
  if (wsp->ws_errno == 4) {
#line 1588
    goto case_4;
  }
#line 1592
  if (wsp->ws_errno == 5) {
#line 1592
    goto case_5;
  }
#line 1596
  if (wsp->ws_errno == 6) {
#line 1596
    goto case_6;
  }
#line 1600
  if (wsp->ws_errno == 7) {
#line 1600
    goto case_7;
  }
#line 1604
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1572
  tmp = gettext("no error");
#line 1572
  (*(wsp->ws_error))((char const   *)tmp);
  }
#line 1573
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1576
  tmp___0 = gettext("missing closing %c (start near #%lu)");
#line 1576
  (*(wsp->ws_error))((char const   *)tmp___0, (int const   )*(wsp->ws_input + wsp->ws_endp),
                     wsp->ws_endp);
  }
#line 1579
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1582
  tmp___1 = gettext("memory exhausted");
#line 1582
  (*(wsp->ws_error))((char const   *)tmp___1);
  }
#line 1583
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 1586
  tmp___2 = gettext("command substitution is not yet supported");
#line 1586
  (*(wsp->ws_error))((char const   *)tmp___2);
  }
  case_4: /* CIL Label */ 
  {
#line 1589
  tmp___3 = gettext("invalid wordsplit usage");
#line 1589
  (*(wsp->ws_error))((char const   *)tmp___3);
  }
#line 1590
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 1593
  tmp___4 = gettext("unbalanced curly brace");
#line 1593
  (*(wsp->ws_error))((char const   *)tmp___4);
  }
#line 1594
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 1597
  tmp___5 = gettext("undefined variable");
#line 1597
  (*(wsp->ws_error))((char const   *)tmp___5);
  }
#line 1598
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 1601
  tmp___6 = gettext("input exhausted");
#line 1601
  (*(wsp->ws_error))((char const   *)tmp___6);
  }
#line 1602
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1605
  tmp___7 = gettext("unknown error");
#line 1605
  (*(wsp->ws_error))((char const   *)tmp___7);
  }
  switch_break: /* CIL Label */ ;
  }
#line 1607
  return;
}
}
#line 1609 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
char const   *_wordsplit_errstr[8]  = 
#line 1609
  {      "no error",      "missing closing quote",      "memory exhausted",      "command substitution is not yet supported", 
        "invalid wordsplit usage",      "unbalanced curly brace",      "undefined variable",      "input exhausted"};
#line 1619 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
int _wordsplit_nerrs  =    (int )(sizeof(_wordsplit_errstr) / sizeof(_wordsplit_errstr[0]));
#line 1622 "/home/khheo/project/benchmark/tar-1.29/lib/wordsplit.c"
char const   *wordsplit_strerror(struct wordsplit *ws ) 
{ 


  {
#line 1625
  if (ws->ws_errno < _wordsplit_nerrs) {
#line 1626
    return (_wordsplit_errstr[ws->ws_errno]);
  }
#line 1627
  return ("unknown error");
}
}
#line 10 "/home/khheo/project/benchmark/tar-1.29/lib/stdopen.h"
_Bool stdopen(void) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 52 "/home/khheo/project/benchmark/tar-1.29/lib/stdopen.c"
static int const   contrary_mode[3]  = {      (int const   )1,      (int const   )0,      (int const   )0};
#line 38 "/home/khheo/project/benchmark/tar-1.29/lib/stdopen.c"
_Bool stdopen(void) 
{ 
  int fd ;
  _Bool ok ;
  int mode ;
  int new_fd ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 42
  ok = (_Bool)1;
#line 44
  fd = 0;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (! (fd <= 2)) {
#line 44
      goto while_break;
    }
    {
#line 46
    tmp___1 = rpl_fcntl(fd, 1);
    }
#line 46
    if (tmp___1 < 0) {
      {
#line 48
      tmp___0 = __errno_location();
      }
#line 48
      if (*tmp___0 != 9) {
#line 49
        ok = (_Bool)0;
      } else {
#line 54
        mode = (int )contrary_mode[fd];
#line 62
        if (mode == 0) {
          {
#line 64
          new_fd = open("/dev/null", mode);
          }
        } else {
          {
#line 62
          tmp = open("/dev/full", mode);
#line 62
          new_fd = tmp != fd;
          }
#line 62
          if (new_fd) {
            {
#line 64
            new_fd = open("/dev/null", mode);
            }
          }
        }
#line 65
        if (new_fd != fd) {
#line 67
          if (0 <= new_fd) {
            {
#line 68
            close(new_fd);
            }
          }
#line 69
          ok = (_Bool)0;
        }
      }
    }
#line 44
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return (ok);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 537 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 576
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 703
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 720
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 759
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 88 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 107 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 142 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 20 "./rmt.h"
char const   *rmt_command ;
#line 21 "./rmt.h"
char const   *rmt_dev_name__  ;
#line 23
int rmt_open__(char const   *file_name___0 , int open_mode , int bias , char const   *remote_shell ) ;
#line 24
int rmt_close__(int handle ) ;
#line 25
size_t rmt_read__(int handle , char *buffer___1 , size_t length ) ;
#line 26
size_t rmt_write__(int handle , char *buffer___1 , size_t length ) ;
#line 27
off_t rmt_lseek__(int handle , off_t offset , int whence ) ;
#line 28
int rmt_ioctl__(int handle , int operation , char *argument ) ;
#line 30 "./rmt.h"
_Bool force_local_option  ;
#line 88 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static int from_remote[4][2]  = { {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}};
#line 91 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static int to_remote[4][2]  = { {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}, 
   {        -1,        -1}};
#line 93 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
char const   *rmt_command  =    "/usr/local/libexec/rmt";
#line 105 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static void _rmt_shutdown(int handle , int errno_value ) 
{ 
  int *tmp ;

  {
  {
#line 108
  close(from_remote[handle][0]);
#line 109
  close(to_remote[handle][1]);
#line 110
  from_remote[handle][0] = -1;
#line 111
  to_remote[handle][1] = -1;
#line 112
  tmp = __errno_location();
#line 112
  *tmp = errno_value;
  }
#line 113
  return;
}
}
#line 118 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static int do_command(int handle , char const   *buffer___1 ) 
{ 
  size_t length ;
  size_t tmp ;
  void (*pipe_handler___0)(int  ) ;
  __sighandler_t tmp___0 ;
  ssize_t written ;
  size_t tmp___1 ;

  {
  {
#line 123
  tmp = strlen(buffer___1);
#line 123
  length = tmp;
#line 124
  tmp___0 = signal(13, (void (*)(int  ))1);
#line 124
  pipe_handler___0 = tmp___0;
#line 125
  tmp___1 = full_write(to_remote[handle][1], (void const   *)buffer___1, length);
#line 125
  written = (ssize_t )tmp___1;
#line 126
  signal(13, pipe_handler___0);
  }
#line 128
  if ((size_t )written == length) {
#line 129
    return (0);
  }
  {
#line 133
  _rmt_shutdown(handle, 5);
  }
#line 134
  return (-1);
}
}
#line 137 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static char *get_status_string(int handle , char *command_buffer ) 
{ 
  char *cursor ;
  int counter ;
  size_t tmp ;
  char character ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 145
  counter = 0;
#line 145
  cursor = command_buffer;
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! (counter < 64)) {
#line 145
      goto while_break;
    }
    {
#line 149
    tmp = safe_read(from_remote[handle][0], (void *)cursor, (size_t )1);
    }
#line 149
    if (tmp != 1UL) {
      {
#line 151
      _rmt_shutdown(handle, 5);
      }
#line 152
      return ((char *)0);
    }
#line 154
    if ((int )*cursor == 10) {
#line 156
      *cursor = (char )'\000';
#line 157
      goto while_break;
    }
#line 145
    counter ++;
#line 145
    cursor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (counter == 64) {
    {
#line 163
    _rmt_shutdown(handle, 5);
    }
#line 164
    return ((char *)0);
  }
#line 169
  cursor = command_buffer;
  {
#line 169
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 169
    if (! *cursor) {
#line 169
      goto while_break___0;
    }
#line 170
    if ((int )*cursor != 32) {
#line 171
      goto while_break___0;
    }
#line 169
    cursor ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 173
  if ((int )*cursor == 69) {
#line 173
    goto _L;
  } else
#line 173
  if ((int )*cursor == 70) {
    _L: /* CIL Label */ 
    {
#line 183
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 183
      tmp___0 = safe_read(from_remote[handle][0], (void *)(& character), (size_t )1);
      }
#line 183
      if (! (tmp___0 == 1UL)) {
#line 183
        goto while_break___1;
      }
#line 184
      if ((int )character == 10) {
#line 185
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 188
    tmp___1 = __errno_location();
#line 188
    *tmp___1 = atoi((char const   *)(cursor + 1));
    }
#line 190
    if ((int )*cursor == 70) {
      {
#line 191
      tmp___2 = __errno_location();
#line 191
      _rmt_shutdown(handle, *tmp___2);
      }
    }
#line 193
    return ((char *)0);
  }
#line 198
  if ((int )*cursor != 65) {
    {
#line 200
    _rmt_shutdown(handle, 5);
    }
#line 201
    return ((char *)0);
  }
#line 206
  return (cursor + 1);
}
}
#line 211 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static long get_status(int handle ) 
{ 
  char command_buffer[64] ;
  char const   *status ;
  char *tmp ;
  long result ;
  long tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 215
  tmp = get_status_string(handle, command_buffer);
#line 215
  status = (char const   *)tmp;
  }
#line 216
  if (status) {
    {
#line 218
    tmp___0 = atol(status);
#line 218
    result = tmp___0;
    }
#line 219
    if (0L <= result) {
#line 220
      return (result);
    }
    {
#line 221
    tmp___1 = __errno_location();
#line 221
    *tmp___1 = 5;
    }
  }
#line 223
  return (-1L);
}
}
#line 226 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static off_t get_status_off(int handle ) 
{ 
  char command_buffer[64] ;
  char const   *status ;
  char *tmp ;
  off_t count ;
  int negative ;
  int tmp___0 ;
  int digit ;
  char const   *tmp___1 ;
  off_t c10 ;
  off_t nc ;
  off_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 230
  tmp = get_status_string(handle, command_buffer);
#line 230
  status = (char const   *)tmp;
  }
#line 232
  if (! status) {
#line 233
    return ((off_t )-1);
  } else {
#line 240
    count = (off_t )0;
    {
#line 243
    while (1) {
      while_continue: /* CIL Label */ ;
#line 243
      if (! ((int const   )*status == 32)) {
#line 243
        if (! ((int const   )*status == 9)) {
#line 243
          goto while_break;
        }
      }
#line 244
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 243
      status ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 246
    negative = (int const   )*status == 45;
#line 247
    if (negative) {
#line 247
      tmp___0 = 1;
    } else
#line 247
    if ((int const   )*status == 43) {
#line 247
      tmp___0 = 1;
    } else {
#line 247
      tmp___0 = 0;
    }
#line 247
    status += tmp___0;
    {
#line 249
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 251
      tmp___1 = status;
#line 251
      status ++;
#line 251
      digit = (int )((int const   )*tmp___1 - 48);
#line 252
      if (9U < (unsigned int )digit) {
#line 253
        goto while_break___0;
      } else {
#line 256
        c10 = 10L * count;
#line 257
        if (negative) {
#line 257
          tmp___2 = c10 - (off_t )digit;
        } else {
#line 257
          tmp___2 = c10 + (off_t )digit;
        }
#line 257
        nc = tmp___2;
#line 258
        if (c10 / 10L != count) {
#line 259
          return ((off_t )-1);
        } else {
#line 258
          if (negative) {
#line 258
            tmp___3 = c10 < nc;
          } else {
#line 258
            tmp___3 = nc < c10;
          }
#line 258
          if (tmp___3) {
#line 259
            return ((off_t )-1);
          }
        }
#line 260
        count = nc;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    return (count);
  }
}
}
#line 318 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
static void encode_oflag(char *buf , int oflag ) 
{ 


  {
  {
#line 321
  sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"%d ", oflag);
  }
  {
#line 325
  if ((oflag & 3) == 0) {
#line 325
    goto case_0;
  }
#line 326
  if ((oflag & 3) == 2) {
#line 326
    goto case_2;
  }
#line 327
  if ((oflag & 3) == 1) {
#line 327
    goto case_1;
  }
#line 328
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 325
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O_RDONLY");
  }
#line 325
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 326
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O_RDWR");
  }
#line 326
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 327
  strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"O_WRONLY");
  }
#line 327
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 328
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 332
  if (oflag & 1024) {
    {
#line 332
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_APPEND");
    }
  }
#line 334
  if (oflag & 64) {
    {
#line 334
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_CREAT");
    }
  }
#line 336
  if (oflag & 4096) {
    {
#line 336
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_DSYNC");
    }
  }
#line 338
  if (oflag & 128) {
    {
#line 338
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_EXCL");
    }
  }
#line 343
  if (oflag & 256) {
    {
#line 343
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_NOCTTY");
    }
  }
#line 345
  if (oflag & 2048) {
    {
#line 345
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_NONBLOCK");
    }
  }
#line 347
  if (oflag & 1052672) {
    {
#line 347
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_RSYNC");
    }
  }
#line 350
  if (oflag & 1052672) {
    {
#line 350
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_SYNC");
    }
  }
#line 352
  if (oflag & 512) {
    {
#line 352
    strcat((char */* __restrict  */)buf, (char const   */* __restrict  */)"|O_TRUNC");
    }
  }
#line 353
  return;
}
}
#line 360 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
int rmt_open__(char const   *file_name___0 , int open_mode , int bias , char const   *remote_shell ) 
{ 
  int remote_pipe_number ;
  char *file_name_copy ;
  char *remote_host ;
  char *remote_file ;
  char *remote_user ;
  int *tmp ;
  char *cursor ;
  int *tmp___0 ;
  char *tmp___1 ;
  struct hostent *tmp___2 ;
  char const   *remote_shell_basename ;
  pid_t status ;
  char *tmp___3 ;
  int e ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int e___0 ;
  int *tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  __uid_t tmp___18 ;
  int tmp___19 ;
  __gid_t tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  size_t remote_file_len ;
  size_t tmp___24 ;
  char *command_buffer ;
  void *tmp___25 ;
  int e___1 ;
  int *tmp___26 ;
  int tmp___27 ;
  long tmp___28 ;

  {
#line 372
  remote_pipe_number = 0;
  {
#line 372
  while (1) {
    while_continue: /* CIL Label */ ;
#line 372
    if (! (remote_pipe_number < 4)) {
#line 372
      goto while_break;
    }
#line 375
    if (from_remote[remote_pipe_number][0] == -1) {
#line 375
      if (to_remote[remote_pipe_number][1] == -1) {
#line 377
        goto while_break;
      }
    }
#line 372
    remote_pipe_number ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  if (remote_pipe_number == 4) {
    {
#line 381
    tmp = __errno_location();
#line 381
    *tmp = 24;
    }
#line 382
    return (-1);
  }
  {
#line 390
  file_name_copy = xstrdup(file_name___0);
#line 391
  remote_host = file_name_copy;
#line 392
  remote_user = (char *)0;
#line 393
  remote_file = (char *)0;
#line 395
  cursor = file_name_copy;
  }
  {
#line 395
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if (! *cursor) {
#line 395
      goto while_break___0;
    }
    {
#line 401
    if ((int )*cursor == 10) {
#line 401
      goto case_10;
    }
#line 408
    if ((int )*cursor == 64) {
#line 408
      goto case_64;
    }
#line 417
    if ((int )*cursor == 58) {
#line 417
      goto case_58;
    }
#line 398
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 399
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 404
    free((void *)file_name_copy);
#line 405
    tmp___0 = __errno_location();
#line 405
    *tmp___0 = 2;
    }
#line 406
    return (-1);
    case_64: /* CIL Label */ 
#line 409
    if (! remote_user) {
#line 411
      remote_user = remote_host;
#line 412
      *cursor = (char )'\000';
#line 413
      remote_host = cursor + 1;
    }
#line 415
    goto switch_break;
    case_58: /* CIL Label */ 
#line 418
    if (! remote_file) {
#line 420
      *cursor = (char )'\000';
#line 421
      remote_file = cursor + 1;
    }
#line 423
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 395
    cursor ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 428
  tmp___2 = gethostbyname((char const   *)remote_host);
  }
#line 428
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 429
    tmp___1 = gettext("Cannot connect to %s: resolve failed");
#line 429
    error(128, 0, (char const   *)tmp___1, remote_host);
    }
  }
#line 432
  if (remote_user) {
#line 432
    if ((int )*remote_user == 0) {
#line 433
      remote_user = (char *)0;
    }
  }
#line 457
  if (! remote_shell) {
#line 460
    remote_shell = "/usr/bin/rsh";
  }
  {
#line 467
  tmp___3 = last_component(remote_shell);
#line 467
  remote_shell_basename = (char const   *)tmp___3;
#line 471
  tmp___6 = pipe((int *)(to_remote[remote_pipe_number]));
  }
#line 471
  if (tmp___6 == -1) {
#line 471
    goto _L;
  } else {
    {
#line 471
    tmp___7 = pipe((int *)(from_remote[remote_pipe_number]));
    }
#line 471
    if (tmp___7 == -1) {
      _L: /* CIL Label */ 
      {
#line 474
      tmp___4 = __errno_location();
#line 474
      e = *tmp___4;
#line 475
      free((void *)file_name_copy);
#line 476
      tmp___5 = __errno_location();
#line 476
      *tmp___5 = e;
      }
#line 477
      return (-1);
    }
  }
  {
#line 480
  status = fork();
  }
#line 481
  if (status == -1) {
    {
#line 483
    tmp___8 = __errno_location();
#line 483
    e___0 = *tmp___8;
#line 484
    free((void *)file_name_copy);
#line 485
    tmp___9 = __errno_location();
#line 485
    *tmp___9 = e___0;
    }
#line 486
    return (-1);
  }
#line 489
  if (status == 0) {
    {
#line 493
    tmp___12 = dup2(to_remote[remote_pipe_number][0], 0);
    }
#line 493
    if (tmp___12 < 0) {
      {
#line 501
      tmp___10 = gettext("Cannot redirect files for remote shell");
#line 501
      tmp___11 = __errno_location();
#line 501
      error(128, *tmp___11, (char const   *)tmp___10);
      }
    } else
#line 493
    if (to_remote[remote_pipe_number][0] != 0) {
      {
#line 493
      tmp___13 = close(to_remote[remote_pipe_number][0]);
      }
#line 493
      if (tmp___13 != 0) {
        {
#line 501
        tmp___10 = gettext("Cannot redirect files for remote shell");
#line 501
        tmp___11 = __errno_location();
#line 501
        error(128, *tmp___11, (char const   *)tmp___10);
        }
      } else {
#line 493
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 493
    if (to_remote[remote_pipe_number][1] != 0) {
      {
#line 493
      tmp___14 = close(to_remote[remote_pipe_number][1]);
      }
#line 493
      if (tmp___14 != 0) {
        {
#line 501
        tmp___10 = gettext("Cannot redirect files for remote shell");
#line 501
        tmp___11 = __errno_location();
#line 501
        error(128, *tmp___11, (char const   *)tmp___10);
        }
      } else {
#line 493
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 493
      tmp___15 = dup2(from_remote[remote_pipe_number][1], 1);
      }
#line 493
      if (tmp___15 < 0) {
        {
#line 501
        tmp___10 = gettext("Cannot redirect files for remote shell");
#line 501
        tmp___11 = __errno_location();
#line 501
        error(128, *tmp___11, (char const   *)tmp___10);
        }
      } else {
        {
#line 493
        tmp___16 = close(from_remote[remote_pipe_number][0]);
        }
#line 493
        if (tmp___16 != 0) {
          {
#line 501
          tmp___10 = gettext("Cannot redirect files for remote shell");
#line 501
          tmp___11 = __errno_location();
#line 501
          error(128, *tmp___11, (char const   *)tmp___10);
          }
        } else {
          {
#line 493
          tmp___17 = close(from_remote[remote_pipe_number][1]);
          }
#line 493
          if (tmp___17 != 0) {
            {
#line 501
            tmp___10 = gettext("Cannot redirect files for remote shell");
#line 501
            tmp___11 = __errno_location();
#line 501
            error(128, *tmp___11, (char const   *)tmp___10);
            }
          }
        }
      }
    }
    {
#line 504
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 504
      tmp___18 = getuid();
#line 504
      tmp___19 = setuid(tmp___18);
      }
#line 504
      if (tmp___19 == 0) {
        {
#line 504
        tmp___20 = getgid();
#line 504
        tmp___21 = setgid(tmp___20);
        }
#line 504
        if (! (tmp___21 == 0)) {
          {
#line 504
          abort();
          }
        }
      } else {
        {
#line 504
        abort();
        }
      }
#line 504
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 506
    if (remote_user) {
      {
#line 507
      execl(remote_shell, remote_shell_basename, remote_host, "-l", remote_user, rmt_command,
            (char *)0);
      }
    } else {
      {
#line 510
      execl(remote_shell, remote_shell_basename, remote_host, rmt_command, (char *)0);
      }
    }
    {
#line 516
    tmp___22 = gettext("Cannot execute remote shell");
#line 516
    tmp___23 = __errno_location();
#line 516
    error(128, *tmp___23, (char const   *)tmp___22);
    }
  }
  {
#line 521
  close(from_remote[remote_pipe_number][1]);
#line 522
  close(to_remote[remote_pipe_number][0]);
#line 529
  tmp___24 = strlen((char const   *)remote_file);
#line 529
  remote_file_len = tmp___24;
#line 530
  tmp___25 = xmalloc(remote_file_len + 1000UL);
#line 530
  command_buffer = (char *)tmp___25;
#line 531
  sprintf((char */* __restrict  */)command_buffer, (char const   */* __restrict  */)"O%s\n",
          remote_file);
#line 532
  encode_oflag((command_buffer + remote_file_len) + 2, open_mode);
#line 533
  strcat((char */* __restrict  */)command_buffer, (char const   */* __restrict  */)"\n");
#line 534
  tmp___27 = do_command(remote_pipe_number, (char const   *)command_buffer);
  }
#line 534
  if (tmp___27 == -1) {
#line 534
    goto _L___2;
  } else {
    {
#line 534
    tmp___28 = get_status(remote_pipe_number);
    }
#line 534
    if (tmp___28 == -1L) {
      _L___2: /* CIL Label */ 
      {
#line 537
      tmp___26 = __errno_location();
#line 537
      e___1 = *tmp___26;
#line 538
      free((void *)command_buffer);
#line 539
      free((void *)file_name_copy);
#line 540
      _rmt_shutdown(remote_pipe_number, e___1);
      }
#line 541
      return (-1);
    }
  }
  {
#line 543
  free((void *)command_buffer);
#line 546
  free((void *)file_name_copy);
  }
#line 547
  return (remote_pipe_number + bias);
}
}
#line 552 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
int rmt_close__(int handle ) 
{ 
  long status ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 557
  tmp = do_command(handle, "C\n");
  }
#line 557
  if (tmp == -1) {
#line 558
    return (-1);
  }
  {
#line 560
  status = get_status(handle);
#line 561
  tmp___0 = __errno_location();
#line 561
  _rmt_shutdown(handle, *tmp___0);
  }
#line 562
  return ((int )status);
}
}
#line 567 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
size_t rmt_read__(int handle , char *buffer___1 , size_t length ) 
{ 
  char command_buffer[64] ;
  size_t status ;
  size_t rlen ;
  size_t counter ;
  int tmp ;
  long tmp___0 ;

  {
  {
#line 575
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"R%lu\n",
          length);
#line 576
  tmp = do_command(handle, (char const   *)(command_buffer));
  }
#line 576
  if (tmp == -1) {
#line 579
    return ((size_t )-1);
  } else {
    {
#line 576
    tmp___0 = get_status(handle);
#line 576
    status = (size_t )tmp___0;
    }
#line 576
    if (status == 0xffffffffffffffffUL) {
#line 579
      return ((size_t )-1);
    } else
#line 576
    if (status > length) {
#line 579
      return ((size_t )-1);
    }
  }
#line 581
  counter = (size_t )0;
  {
#line 581
  while (1) {
    while_continue: /* CIL Label */ ;
#line 581
    if (! (counter < status)) {
#line 581
      goto while_break;
    }
    {
#line 583
    rlen = safe_read(from_remote[handle][0], (void *)buffer___1, status - counter);
    }
#line 584
    if (rlen == 0xffffffffffffffffUL) {
      {
#line 586
      _rmt_shutdown(handle, 5);
      }
#line 587
      return ((size_t )-1);
    } else
#line 584
    if (rlen == 0UL) {
      {
#line 586
      _rmt_shutdown(handle, 5);
      }
#line 587
      return ((size_t )-1);
    }
#line 581
    counter += rlen;
#line 581
    buffer___1 += rlen;
  }
  while_break: /* CIL Label */ ;
  }
#line 591
  return (status);
}
}
#line 596 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
size_t rmt_write__(int handle , char *buffer___1 , size_t length ) 
{ 
  char command_buffer[64] ;
  void (*pipe_handler___0)(int  ) ;
  size_t written ;
  int tmp ;
  long r ;
  long tmp___0 ;

  {
  {
#line 603
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"W%lu\n",
          length);
#line 604
  tmp = do_command(handle, (char const   *)(command_buffer));
  }
#line 604
  if (tmp == -1) {
#line 605
    return ((size_t )0);
  }
  {
#line 607
  pipe_handler___0 = signal(13, (void (*)(int  ))1);
#line 608
  written = full_write(to_remote[handle][1], (void const   *)buffer___1, length);
#line 609
  signal(13, pipe_handler___0);
  }
#line 610
  if (written == length) {
    {
#line 612
    tmp___0 = get_status(handle);
#line 612
    r = tmp___0;
    }
#line 613
    if (r < 0L) {
#line 614
      return ((size_t )0);
    }
#line 615
    if ((size_t )r == length) {
#line 616
      return (length);
    }
#line 617
    written = (size_t )r;
  }
  {
#line 622
  _rmt_shutdown(handle, 5);
  }
#line 623
  return (written);
}
}
#line 628 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
off_t rmt_lseek__(int handle , off_t offset , int whence ) 
{ 
  char command_buffer[64] ;
  char operand_buffer[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  uintmax_t u ;
  uintmax_t tmp ;
  char *p ;
  int tmp___0 ;
  off_t tmp___1 ;

  {
#line 633
  if (offset < 0L) {
#line 633
    tmp = - ((uintmax_t )offset);
  } else {
#line 633
    tmp = (uintmax_t )offset;
  }
#line 633
  u = tmp;
#line 634
  p = operand_buffer + sizeof(operand_buffer);
#line 636
  p --;
#line 636
  *p = (char)0;
  {
#line 637
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    p --;
#line 638
    *p = (char )(48 + (int )(u % 10UL));
#line 637
    u /= 10UL;
#line 637
    if (! (u != 0UL)) {
#line 637
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if (offset < 0L) {
#line 641
    p --;
#line 641
    *p = (char )'-';
  }
  {
#line 645
  if (whence == 0) {
#line 645
    goto case_0;
  }
#line 646
  if (whence == 1) {
#line 646
    goto case_1;
  }
#line 647
  if (whence == 2) {
#line 647
    goto case_2;
  }
#line 648
  goto switch_default;
  case_0: /* CIL Label */ 
#line 645
  whence = 0;
#line 645
  goto switch_break;
  case_1: /* CIL Label */ 
#line 646
  whence = 1;
#line 646
  goto switch_break;
  case_2: /* CIL Label */ 
#line 647
  whence = 2;
#line 647
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 648
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 651
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"L%s\n%d\n",
          p, whence);
#line 653
  tmp___0 = do_command(handle, (char const   *)(command_buffer));
  }
#line 653
  if (tmp___0 == -1) {
#line 654
    return ((off_t )-1);
  }
  {
#line 656
  tmp___1 = get_status_off(handle);
  }
#line 656
  return (tmp___1);
}
}
#line 661 "/home/khheo/project/benchmark/tar-1.29/lib/rtapelib.c"
int rmt_ioctl__(int handle , int operation , char *argument ) 
{ 
  int *tmp ;
  char command_buffer[64] ;
  char operand_buffer[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  uintmax_t u ;
  uintmax_t tmp___0 ;
  char *p ;
  int tmp___1 ;
  long tmp___2 ;
  ssize_t status ;
  size_t counter ;
  int tmp___3 ;
  int *tmp___4 ;
  char copy ;

  {
  {
#line 671
  if (operation == (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16))) {
#line 671
    goto case_exp;
  }
#line 699
  if (operation == (int )((unsigned long )(((2U << 30) | (unsigned int )(109 << 8)) | 2U) | (sizeof(struct mtget ) << 16))) {
#line 699
    goto case_exp___0;
  }
#line 666
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 667
  tmp = __errno_location();
#line 667
  *tmp = 95;
  }
#line 668
  return (-1);
  case_exp: /* CIL Label */ 
#line 675
  if (((struct mtop *)argument)->mt_count < 0) {
#line 675
    tmp___0 = - ((uintmax_t )((struct mtop *)argument)->mt_count);
  } else {
#line 675
    tmp___0 = (uintmax_t )((struct mtop *)argument)->mt_count;
  }
#line 675
  u = tmp___0;
#line 678
  p = operand_buffer + sizeof(operand_buffer);
#line 680
  p --;
#line 680
  *p = (char)0;
  {
#line 681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 682
    p --;
#line 682
    *p = (char )(48 + (int )(u % 10UL));
#line 681
    u /= 10UL;
#line 681
    if (! (u != 0UL)) {
#line 681
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 684
  if (((struct mtop *)argument)->mt_count < 0) {
#line 685
    p --;
#line 685
    *p = (char )'-';
  }
  {
#line 689
  sprintf((char */* __restrict  */)(command_buffer), (char const   */* __restrict  */)"I%d\n%s\n",
          (int )((struct mtop *)argument)->mt_op, p);
#line 691
  tmp___1 = do_command(handle, (char const   *)(command_buffer));
  }
#line 691
  if (tmp___1 == -1) {
#line 692
    return (-1);
  }
  {
#line 694
  tmp___2 = get_status(handle);
  }
#line 694
  return ((int )tmp___2);
  case_exp___0: /* CIL Label */ 
  {
#line 710
  tmp___3 = do_command(handle, "S");
  }
#line 710
  if (tmp___3 == -1) {
#line 712
    return (-1);
  } else {
    {
#line 710
    status = get_status(handle);
    }
#line 710
    if (status == -1L) {
#line 712
      return (-1);
    }
  }
#line 714
  if ((unsigned long )status > sizeof(struct mtop )) {
    {
#line 716
    tmp___4 = __errno_location();
#line 716
    *tmp___4 = 75;
    }
#line 717
    return (-1);
  }
  {
#line 720
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 720
    if (! (status > 0L)) {
#line 720
      goto while_break___0;
    }
    {
#line 722
    counter = safe_read(from_remote[handle][0], (void *)argument, (size_t )status);
    }
#line 723
    if (counter == 0xffffffffffffffffUL) {
      {
#line 725
      _rmt_shutdown(handle, 5);
      }
#line 726
      return (-1);
    } else
#line 723
    if (counter == 0UL) {
      {
#line 725
      _rmt_shutdown(handle, 5);
      }
#line 726
      return (-1);
    }
#line 720
    status = (ssize_t )((size_t )status - counter);
#line 720
    argument += counter;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 735
  if (((struct mtget *)argument)->mt_type < 256L) {
#line 736
    return (0);
  }
#line 738
  counter = (size_t )0;
  {
#line 738
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 738
    if (! (counter < (size_t )status)) {
#line 738
      goto while_break___1;
    }
#line 740
    copy = *(argument + counter);
#line 742
    *(argument + counter) = *(argument + (counter + 1UL));
#line 743
    *(argument + (counter + 1UL)) = copy;
#line 738
    counter += 2UL;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 746
  return (0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 35 "./paxlib.h"
void (*error_hook)(void) ;
#line 129
_Bool removed_prefixes_p(void) ;
#line 130
char *safer_name_suffix(char const   *file_name___0 , _Bool link_target , _Bool absolute_names ) ;
#line 26 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
static size_t hash_string_hasher(void const   *name , size_t n_buckets ) 
{ 
  size_t tmp ;

  {
  {
#line 29
  tmp = hash_string((char const   *)name, n_buckets);
  }
#line 29
  return (tmp);
}
}
#line 33 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
static _Bool hash_string_compare(void const   *name1 , void const   *name2 ) 
{ 
  int tmp ;

  {
  {
#line 36
  tmp = strcmp((char const   *)name1, (char const   *)name2);
  }
#line 36
  return ((_Bool )(tmp == 0));
}
}
#line 43 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
static _Bool hash_string_insert_prefix(Hash_table **table , char const   *string ,
                                       size_t len , char const   **return_prefix ) 
{ 
  Hash_table *t ;
  char *s ;
  char *e ;
  void *tmp ;
  Hash_table *tmp___0 ;
  void *tmp___1 ;

  {
#line 47
  t = *table;
#line 51
  if (len) {
    {
#line 53
    tmp = xmalloc(len + 1UL);
#line 53
    s = (char *)tmp;
#line 54
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)string, len);
#line 55
    *(s + len) = (char)0;
    }
  } else {
    {
#line 58
    s = xstrdup(string);
    }
  }
#line 60
  if (t) {
#line 60
    goto _L;
  } else {
    {
#line 60
    t = hash_initialize((size_t )0, (Hash_tuning const   *)0, & hash_string_hasher,
                        & hash_string_compare, (void (*)(void * ))0);
#line 60
    tmp___0 = t;
#line 60
    *table = tmp___0;
    }
#line 60
    if (tmp___0) {
      _L: /* CIL Label */ 
      {
#line 60
      tmp___1 = hash_insert(t, (void const   *)s);
#line 60
      e = (char *)tmp___1;
      }
#line 60
      if (! e) {
        {
#line 64
        xalloc_die();
        }
      }
    } else {
      {
#line 64
      xalloc_die();
      }
    }
  }
#line 66
  if ((unsigned long )e == (unsigned long )s) {
#line 68
    if (return_prefix) {
#line 69
      *return_prefix = (char const   *)s;
    }
#line 70
    return ((_Bool)1);
  } else {
    {
#line 74
    free((void *)s);
    }
#line 75
    return ((_Bool)0);
  }
}
}
#line 80 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
static Hash_table *prefix_table[2]  ;
#line 86 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
_Bool removed_prefixes_p(void) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 89
  if (prefix_table[0]) {
    {
#line 89
    tmp = hash_get_n_entries((Hash_table const   *)prefix_table[0]);
    }
#line 89
    if (tmp != 0UL) {
#line 89
      tmp___1 = 1;
    } else {
#line 89
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 89
  if (prefix_table[1]) {
    {
#line 89
    tmp___0 = hash_get_n_entries((Hash_table const   *)prefix_table[1]);
    }
#line 89
    if (tmp___0 != 0UL) {
#line 89
      tmp___1 = 1;
    } else {
#line 89
      tmp___1 = 0;
    }
  } else {
#line 89
    tmp___1 = 0;
  }
#line 89
  return ((_Bool )tmp___1);
}
}
#line 138 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
static char const   * const  diagnostic[2]  = {      (char const   */* const  */)"Removing leading `%s\' from member names",      (char const   */* const  */)"Removing leading `%s\' from hard link targets"};
#line 152 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
static char const   * const  diagnostic___0[2]  = {      (char const   */* const  */)"Substituting `.\' for empty member name",      (char const   */* const  */)"Substituting `.\' for empty hard link target"};
#line 99 "/home/khheo/project/benchmark/tar-1.29/lib/paxnames.c"
char *safer_name_suffix(char const   *file_name___0 , _Bool link_target , _Bool absolute_names ) 
{ 
  char const   *p ;
  size_t prefix_len ;
  char c ;
  char const   *tmp ;
  char const   *prefix ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;

  {
#line 105
  if (absolute_names) {
#line 106
    p = file_name___0;
  } else {
#line 112
    prefix_len = (size_t )0;
#line 114
    p = file_name___0 + prefix_len;
    {
#line 114
    while (1) {
      while_continue: /* CIL Label */ ;
#line 114
      if (! *p) {
#line 114
        goto while_break;
      }
#line 116
      if ((int const   )*(p + 0) == 46) {
#line 116
        if ((int const   )*(p + 1) == 46) {
#line 116
          if ((int const   )*(p + 2) == 47) {
#line 117
            prefix_len = (size_t )((p + 2) - file_name___0);
          } else
#line 116
          if (! *(p + 2)) {
#line 117
            prefix_len = (size_t )((p + 2) - file_name___0);
          }
        }
      }
      {
#line 119
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 121
        tmp = p;
#line 121
        p ++;
#line 121
        c = (char )*tmp;
#line 122
        if ((int )c == 47) {
#line 123
          goto while_break___0;
        }
#line 119
        if (! *p) {
#line 119
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 128
    p = file_name___0 + prefix_len;
    {
#line 128
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 128
      if (! ((int const   )*p == 47)) {
#line 128
        goto while_break___1;
      }
#line 129
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 128
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 130
    prefix_len = (size_t )(p - file_name___0);
#line 132
    if (prefix_len) {
      {
#line 135
      tmp___1 = hash_string_insert_prefix(& prefix_table[link_target], file_name___0,
                                          prefix_len, & prefix);
      }
#line 135
      if (tmp___1) {
        {
#line 143
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 143
          if (error_hook) {
            {
#line 143
            (*error_hook)();
            }
          }
          {
#line 143
          tmp___0 = gettext((char const   *)diagnostic[link_target]);
#line 143
          error(0, 0, (char const   *)tmp___0, prefix);
          }
#line 143
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
  }
#line 148
  if (! *p) {
#line 150
    if ((unsigned long )p == (unsigned long )file_name___0) {
      {
#line 157
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 157
        if (error_hook) {
          {
#line 157
          (*error_hook)();
          }
        }
        {
#line 157
        tmp___2 = gettext((char const   *)diagnostic___0[link_target]);
#line 157
        error(0, 0, "%s", tmp___2);
        }
#line 157
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 160
    p = ".";
  }
#line 163
  return ((char *)p);
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 72 "./paxlib.h"
int exit_status ;
#line 3 "/home/khheo/project/benchmark/tar-1.29/lib/paxexit-status.c"
int exit_status  =    0;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 61 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ngettext)(char const   *__msgid1 ,
                                                                                 char const   *__msgid2 ,
                                                                                 unsigned long __n )  __attribute__((__format_arg__(2),
__format_arg__(1))) ;
#line 35 "./paxlib.h"
void (*error_hook)(void)  ;
#line 74
void pax_decode_mode(mode_t mode , char *string ) ;
#line 75
void call_arg_error(char const   *call , char const   *name ) ;
#line 76
 __attribute__((__noreturn__)) void call_arg_fatal(char const   *call , char const   *name ) ;
#line 77
void call_arg_warn(char const   *call , char const   *name ) ;
#line 78
void chmod_error_details(char const   *name , mode_t mode ) ;
#line 79
void chown_error_details(char const   *name , uid_t uid , gid_t gid ) ;
#line 83
 __attribute__((__noreturn__)) void chdir_fatal(char const   *name ) ;
#line 86
void close_error(char const   *name ) ;
#line 87
void close_warn(char const   *name ) ;
#line 88
 __attribute__((__noreturn__)) void exec_fatal(char const   *name ) ;
#line 89
void link_error(char const   *target , char const   *source ) ;
#line 90
void mkdir_error(char const   *name ) ;
#line 91
void mkfifo_error(char const   *name ) ;
#line 92
void mknod_error(char const   *name ) ;
#line 93
void open_error(char const   *name ) ;
#line 94
 __attribute__((__noreturn__)) void open_fatal(char const   *name ) ;
#line 95
void open_warn(char const   *name ) ;
#line 96
void read_error(char const   *name ) ;
#line 97
void read_error_details(char const   *name , off_t offset , size_t size ) ;
#line 98
 __attribute__((__noreturn__)) void read_fatal(char const   *name ) ;
#line 99
 __attribute__((__noreturn__)) void read_fatal_details(char const   *name , off_t offset ,
                                                       size_t size ) ;
#line 100
void read_warn_details(char const   *name , off_t offset , size_t size ) ;
#line 101
void readlink_error(char const   *name ) ;
#line 102
void readlink_warn(char const   *name ) ;
#line 103
void rmdir_error(char const   *name ) ;
#line 104
void savedir_error(char const   *name ) ;
#line 105
void savedir_warn(char const   *name ) ;
#line 106
void seek_error(char const   *name ) ;
#line 107
void seek_error_details(char const   *name , off_t offset ) ;
#line 108
void seek_warn(char const   *name ) ;
#line 109
void seek_warn_details(char const   *name , off_t offset ) ;
#line 110
 __attribute__((__noreturn__)) void stat_fatal(char const   *name ) ;
#line 111
void stat_error(char const   *name ) ;
#line 112
void stat_warn(char const   *name ) ;
#line 113
void symlink_error(char const   *contents , char const   *name ) ;
#line 114
void truncate_error(char const   *name ) ;
#line 115
void truncate_warn(char const   *name ) ;
#line 116
void unlink_error(char const   *name ) ;
#line 117
void utime_error(char const   *name ) ;
#line 118
void waitpid_error(char const   *name ) ;
#line 119
void write_error(char const   *name ) ;
#line 120
void write_error_details(char const   *name , size_t status , size_t size ) ;
#line 123
 __attribute__((__noreturn__)) void fatal_exit(void) ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void pax_decode_mode(mode_t mode , char *string ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 32
  tmp = string;
#line 32
  string ++;
#line 32
  if (mode & 256U) {
#line 32
    *tmp = (char )'r';
  } else {
#line 32
    *tmp = (char )'-';
  }
#line 33
  tmp___0 = string;
#line 33
  string ++;
#line 33
  if (mode & 128U) {
#line 33
    *tmp___0 = (char )'w';
  } else {
#line 33
    *tmp___0 = (char )'-';
  }
#line 34
  tmp___1 = string;
#line 34
  string ++;
#line 34
  if (mode & 2048U) {
#line 34
    if (mode & 64U) {
#line 34
      tmp___2 = 's';
    } else {
#line 34
      tmp___2 = 'S';
    }
#line 34
    *tmp___1 = (char )tmp___2;
  } else {
#line 34
    if (mode & 64U) {
#line 34
      tmp___3 = 'x';
    } else {
#line 34
      tmp___3 = '-';
    }
#line 34
    *tmp___1 = (char )tmp___3;
  }
#line 37
  tmp___4 = string;
#line 37
  string ++;
#line 37
  if (mode & (unsigned int )(256 >> 3)) {
#line 37
    *tmp___4 = (char )'r';
  } else {
#line 37
    *tmp___4 = (char )'-';
  }
#line 38
  tmp___5 = string;
#line 38
  string ++;
#line 38
  if (mode & (unsigned int )(128 >> 3)) {
#line 38
    *tmp___5 = (char )'w';
  } else {
#line 38
    *tmp___5 = (char )'-';
  }
#line 39
  tmp___6 = string;
#line 39
  string ++;
#line 39
  if (mode & 1024U) {
#line 39
    if (mode & (unsigned int )(64 >> 3)) {
#line 39
      tmp___7 = 's';
    } else {
#line 39
      tmp___7 = 'S';
    }
#line 39
    *tmp___6 = (char )tmp___7;
  } else {
#line 39
    if (mode & (unsigned int )(64 >> 3)) {
#line 39
      tmp___8 = 'x';
    } else {
#line 39
      tmp___8 = '-';
    }
#line 39
    *tmp___6 = (char )tmp___8;
  }
#line 42
  tmp___9 = string;
#line 42
  string ++;
#line 42
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 42
    *tmp___9 = (char )'r';
  } else {
#line 42
    *tmp___9 = (char )'-';
  }
#line 43
  tmp___10 = string;
#line 43
  string ++;
#line 43
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 43
    *tmp___10 = (char )'w';
  } else {
#line 43
    *tmp___10 = (char )'-';
  }
#line 44
  tmp___11 = string;
#line 44
  string ++;
#line 44
  if (mode & 512U) {
#line 44
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 44
      tmp___12 = 't';
    } else {
#line 44
      tmp___12 = 'T';
    }
#line 44
    *tmp___11 = (char )tmp___12;
  } else {
#line 44
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 44
      tmp___13 = 'x';
    } else {
#line 44
      tmp___13 = '-';
    }
#line 44
    *tmp___11 = (char )tmp___13;
  }
#line 47
  *string = (char )'\000';
#line 48
  return;
}
}
#line 52 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void call_arg_error(char const   *call , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 55
  tmp = __errno_location();
#line 55
  e = *tmp;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (error_hook) {
      {
#line 60
      (*error_hook)();
      }
    }
    {
#line 60
    tmp___0 = quotearg_colon(name);
#line 60
    tmp___1 = gettext("%s: Cannot %s");
#line 60
    error(0, e, (char const   *)tmp___1, tmp___0, call);
#line 60
    exit_status = 2;
    }
#line 60
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 65
 __attribute__((__noreturn__)) void call_arg_fatal(char const   *call , char const   *name ) ;
#line 65 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void call_arg_fatal(char const   *call , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 68
  tmp = __errno_location();
#line 68
  e = *tmp;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (error_hook) {
      {
#line 73
      (*error_hook)();
      }
    }
    {
#line 73
    tmp___0 = quotearg_colon(name);
#line 73
    tmp___1 = gettext("%s: Cannot %s");
#line 73
    error(0, e, (char const   *)tmp___1, tmp___0, call);
#line 73
    fatal_exit();
    }
#line 73
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 78 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void call_arg_warn(char const   *call , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 81
  tmp = __errno_location();
#line 81
  e = *tmp;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (error_hook) {
      {
#line 86
      (*error_hook)();
      }
    }
    {
#line 86
    tmp___0 = quotearg_colon(name);
#line 86
    tmp___1 = gettext("%s: Warning: Cannot %s");
#line 86
    error(0, e, (char const   *)tmp___1, tmp___0, call);
    }
#line 86
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  return;
}
}
#line 89 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void chmod_error_details(char const   *name , mode_t mode ) 
{ 
  int e ;
  int *tmp ;
  char buf[10] ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 92
  tmp = __errno_location();
#line 92
  e = *tmp;
#line 94
  pax_decode_mode(mode, buf);
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (error_hook) {
      {
#line 95
      (*error_hook)();
      }
    }
    {
#line 95
    tmp___0 = quotearg_colon(name);
#line 95
    tmp___1 = gettext("%s: Cannot change mode to %s");
#line 95
    error(0, e, (char const   *)tmp___1, tmp___0, buf);
#line 95
    exit_status = 2;
    }
#line 95
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return;
}
}
#line 99 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void chown_error_details(char const   *name , uid_t uid , gid_t gid ) 
{ 
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 102
  tmp = __errno_location();
#line 102
  e = *tmp;
  }
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (error_hook) {
      {
#line 103
      (*error_hook)();
      }
    }
    {
#line 103
    tmp___0 = quotearg_colon(name);
#line 103
    tmp___1 = gettext("%s: Cannot change ownership to uid %lu, gid %lu");
#line 103
    error(0, e, (char const   *)tmp___1, tmp___0, (unsigned long )uid, (unsigned long )gid);
#line 103
    exit_status = 2;
    }
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  return;
}
}
#line 107 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void close_error(char const   *name ) 
{ 


  {
  {
#line 110
  call_arg_error("close", name);
  }
#line 111
  return;
}
}
#line 113 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void close_warn(char const   *name ) 
{ 


  {
  {
#line 116
  call_arg_warn("close", name);
  }
#line 117
  return;
}
}
#line 119
 __attribute__((__noreturn__)) void exec_fatal(char const   *name ) ;
#line 119 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void exec_fatal(char const   *name ) 
{ 


  {
  {
#line 122
  call_arg_fatal("exec", name);
  }
}
}
#line 125 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void link_error(char const   *target , char const   *source ) 
{ 
  int e ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 128
  tmp = __errno_location();
#line 128
  e = *tmp;
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (error_hook) {
      {
#line 129
      (*error_hook)();
      }
    }
    {
#line 129
    tmp___0 = quote_n(1, target);
#line 129
    tmp___1 = quotearg_colon(source);
#line 129
    tmp___2 = gettext("%s: Cannot hard link to %s");
#line 129
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 129
    exit_status = 2;
    }
#line 129
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 133 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void mkdir_error(char const   *name ) 
{ 


  {
  {
#line 136
  call_arg_error("mkdir", name);
  }
#line 137
  return;
}
}
#line 139 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void mkfifo_error(char const   *name ) 
{ 


  {
  {
#line 142
  call_arg_error("mkfifo", name);
  }
#line 143
  return;
}
}
#line 145 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void mknod_error(char const   *name ) 
{ 


  {
  {
#line 148
  call_arg_error("mknod", name);
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void open_error(char const   *name ) 
{ 


  {
  {
#line 154
  call_arg_error("open", name);
  }
#line 155
  return;
}
}
#line 157
 __attribute__((__noreturn__)) void open_fatal(char const   *name ) ;
#line 157 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void open_fatal(char const   *name ) 
{ 


  {
  {
#line 160
  call_arg_fatal("open", name);
  }
}
}
#line 163 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void open_warn(char const   *name ) 
{ 


  {
  {
#line 166
  call_arg_warn("open", name);
  }
#line 167
  return;
}
}
#line 169 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void read_error(char const   *name ) 
{ 


  {
  {
#line 172
  call_arg_error("read", name);
  }
#line 173
  return;
}
}
#line 175 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void read_error_details(char const   *name , off_t offset , size_t size ) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 179
  tmp = __errno_location();
#line 179
  e = *tmp;
  }
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (error_hook) {
      {
#line 180
      (*error_hook)();
      }
    }
    {
#line 180
    tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 180
    tmp___1 = quotearg_colon(name);
#line 180
    tmp___2 = ngettext("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes",
                       size);
#line 180
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0, size);
#line 180
    exit_status = 2;
    }
#line 180
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 186
  return;
}
}
#line 188 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void read_warn_details(char const   *name , off_t offset , size_t size ) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 192
  tmp = __errno_location();
#line 192
  e = *tmp;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (error_hook) {
      {
#line 193
      (*error_hook)();
      }
    }
    {
#line 193
    tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 193
    tmp___1 = quotearg_colon(name);
#line 193
    tmp___2 = ngettext("%s: Warning: Read error at byte %s, while reading %lu byte",
                       "%s: Warning: Read error at byte %s, while reading %lu bytes",
                       size);
#line 193
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0, size);
    }
#line 193
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return;
}
}
#line 201
 __attribute__((__noreturn__)) void read_fatal(char const   *name ) ;
#line 201 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void read_fatal(char const   *name ) 
{ 


  {
  {
#line 204
  call_arg_fatal("read", name);
  }
}
}
#line 207
 __attribute__((__noreturn__)) void read_fatal_details(char const   *name , off_t offset ,
                                                       size_t size ) ;
#line 207 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void read_fatal_details(char const   *name , off_t offset , size_t size ) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 211
  tmp = __errno_location();
#line 211
  e = *tmp;
  }
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (error_hook) {
      {
#line 212
      (*error_hook)();
      }
    }
    {
#line 212
    tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 212
    tmp___1 = quotearg_colon(name);
#line 212
    tmp___2 = ngettext("%s: Read error at byte %s, while reading %lu byte", "%s: Read error at byte %s, while reading %lu bytes",
                       size);
#line 212
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0, size);
#line 212
    fatal_exit();
    }
#line 212
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 220 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void readlink_error(char const   *name ) 
{ 


  {
  {
#line 223
  call_arg_error("readlink", name);
  }
#line 224
  return;
}
}
#line 226 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void readlink_warn(char const   *name ) 
{ 


  {
  {
#line 229
  call_arg_warn("readlink", name);
  }
#line 230
  return;
}
}
#line 232 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void rmdir_error(char const   *name ) 
{ 


  {
  {
#line 235
  call_arg_error("rmdir", name);
  }
#line 236
  return;
}
}
#line 238 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void savedir_error(char const   *name ) 
{ 


  {
  {
#line 241
  call_arg_error("savedir", name);
  }
#line 242
  return;
}
}
#line 244 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void savedir_warn(char const   *name ) 
{ 


  {
  {
#line 247
  call_arg_warn("savedir", name);
  }
#line 248
  return;
}
}
#line 250 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void seek_error(char const   *name ) 
{ 


  {
  {
#line 253
  call_arg_error("seek", name);
  }
#line 254
  return;
}
}
#line 256 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void seek_error_details(char const   *name , off_t offset ) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 260
  tmp = __errno_location();
#line 260
  e = *tmp;
  }
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (error_hook) {
      {
#line 261
      (*error_hook)();
      }
    }
    {
#line 261
    tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 261
    tmp___1 = quotearg_colon(name);
#line 261
    tmp___2 = gettext("%s: Cannot seek to %s");
#line 261
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 261
    exit_status = 2;
    }
#line 261
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return;
}
}
#line 266 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void seek_warn(char const   *name ) 
{ 


  {
  {
#line 269
  call_arg_warn("seek", name);
  }
#line 270
  return;
}
}
#line 272 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void seek_warn_details(char const   *name , off_t offset ) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int e ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 276
  tmp = __errno_location();
#line 276
  e = *tmp;
  }
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (error_hook) {
      {
#line 277
      (*error_hook)();
      }
    }
    {
#line 277
    tmp___0 = umaxtostr((uintmax_t )offset, buf);
#line 277
    tmp___1 = quotearg_colon(name);
#line 277
    tmp___2 = gettext("%s: Warning: Cannot seek to %s");
#line 277
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
    }
#line 277
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return;
}
}
#line 282 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void symlink_error(char const   *contents , char const   *name ) 
{ 
  int e ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 285
  tmp = __errno_location();
#line 285
  e = *tmp;
  }
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (error_hook) {
      {
#line 286
      (*error_hook)();
      }
    }
    {
#line 286
    tmp___0 = quote_n(1, contents);
#line 286
    tmp___1 = quotearg_colon(name);
#line 286
    tmp___2 = gettext("%s: Cannot create symlink to %s");
#line 286
    error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 286
    exit_status = 2;
    }
#line 286
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 288
  return;
}
}
#line 290
 __attribute__((__noreturn__)) void stat_fatal(char const   *name ) ;
#line 290 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void stat_fatal(char const   *name ) 
{ 


  {
  {
#line 293
  call_arg_fatal("stat", name);
  }
}
}
#line 296 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void stat_error(char const   *name ) 
{ 


  {
  {
#line 299
  call_arg_error("stat", name);
  }
#line 300
  return;
}
}
#line 302 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void stat_warn(char const   *name ) 
{ 


  {
  {
#line 305
  call_arg_warn("stat", name);
  }
#line 306
  return;
}
}
#line 308 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void truncate_error(char const   *name ) 
{ 


  {
  {
#line 311
  call_arg_error("truncate", name);
  }
#line 312
  return;
}
}
#line 314 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void truncate_warn(char const   *name ) 
{ 


  {
  {
#line 317
  call_arg_warn("truncate", name);
  }
#line 318
  return;
}
}
#line 320 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void unlink_error(char const   *name ) 
{ 


  {
  {
#line 323
  call_arg_error("unlink", name);
  }
#line 324
  return;
}
}
#line 326 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void utime_error(char const   *name ) 
{ 


  {
  {
#line 329
  call_arg_error("utime", name);
  }
#line 330
  return;
}
}
#line 332 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void waitpid_error(char const   *name ) 
{ 


  {
  {
#line 335
  call_arg_error("waitpid", name);
  }
#line 336
  return;
}
}
#line 338 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void write_error(char const   *name ) 
{ 


  {
  {
#line 341
  call_arg_error("write", name);
  }
#line 342
  return;
}
}
#line 344 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void write_error_details(char const   *name , size_t status , size_t size ) 
{ 
  char *tmp ;

  {
#line 347
  if (status == 0UL) {
    {
#line 348
    write_error(name);
    }
  } else {
    {
#line 350
    while (1) {
      while_continue: /* CIL Label */ ;
#line 350
      if (error_hook) {
        {
#line 350
        (*error_hook)();
        }
      }
      {
#line 350
      tmp = ngettext("%s: Wrote only %lu of %lu byte", "%s: Wrote only %lu of %lu bytes",
                     size);
#line 350
      error(0, 0, (char const   *)tmp, name, status, size);
#line 350
      exit_status = 2;
      }
#line 350
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 355
  return;
}
}
#line 357
 __attribute__((__noreturn__)) void chdir_fatal(char const   *name ) ;
#line 357 "/home/khheo/project/benchmark/tar-1.29/lib/paxerror.c"
void chdir_fatal(char const   *name ) 
{ 


  {
  {
#line 360
  call_arg_fatal("chdir", name);
  }
}
}
#line 272 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 272
int selinux_context_option ;
#line 275
int acls_option ;
#line 278
int xattrs_option ;
#line 322
int verbose_option ;
#line 436
FILE *stdlis ;
#line 647 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
__inline intmax_t represent_uintmax(uintmax_t n ) 
{ 
  intmax_t nd ;

  {
#line 650
  if (n <= 9223372036854775807UL) {
#line 651
    return ((intmax_t )n);
  } else {
#line 655
    nd = (intmax_t )(n - 0x8000000000000000UL);
#line 656
    return (nd + (-0x7FFFFFFFFFFFFFFF-1));
  }
}
}
#line 672 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
__inline _Bool valid_timespec(struct timespec t ) 
{ 


  {
#line 675
  return ((_Bool )(0L <= t.tv_nsec));
}
}
#line 704
int chdir_fd ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.h"
void xattrs_mask_add(char const   *mask , _Bool incl ) ;
#line 30
void xattrs_clear_setup(void) ;
#line 32
void xattrs_acls_get(int parentfd , char const   *file_name___0 , struct tar_stat_info *st ,
                     int fd , int xisfile ) ;
#line 34
void xattrs_selinux_get(int parentfd , char const   *file_name___0 , struct tar_stat_info *st ,
                        int fd ) ;
#line 36
void xattrs_xattrs_get(int parentfd , char const   *file_name___0 , struct tar_stat_info *st ,
                       int fd ) ;
#line 39
void xattrs_acls_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                     char typeflag ) ;
#line 41
void xattrs_selinux_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                        char typeflag ) ;
#line 43
void xattrs_xattrs_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                       char typeflag , int later_run ) ;
#line 47
void xattrs_print_char(struct tar_stat_info  const  *st , char *output ) ;
#line 48
void xattrs_print(struct tar_stat_info  const  *st ) ;
#line 841 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
void xheader_xattr_add(struct tar_stat_info *st , char const   *key , char const   *val___0 ,
                       size_t len ) ;
#line 939
int warning_option ;
#line 974
#pragma GCC diagnostic pop
#line 70 "/usr/include/x86_64-linux-gnu/sys/xattr.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) fgetxattr)(int __fd ,
                                                                                    char const   *__name ,
                                                                                    void *__value ,
                                                                                    size_t __size ) ;
#line 87
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) flistxattr)(int __fd ,
                                                                                     char *__list ,
                                                                                     size_t __size ) ;
#line 38 "../gnu/selinux/selinux.h"
#pragma GCC diagnostic push
#line 38
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 38
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 141
#pragma GCC diagnostic push
#line 141
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 141
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 10 "../gnu/selinux/context.h"
#pragma GCC diagnostic push
#line 10
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 10
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 65
#pragma GCC diagnostic pop
#line 41 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static struct __anonstruct_xattrs_setup_1047061541 xattrs_setup  ;
#line 313 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static void acls_one_line(char const   *prefix , char delim , char const   *aclstring ,
                          size_t len ) 
{ 
  struct obstack stk___0 ;
  int pref_len ;
  size_t tmp ;
  char const   *oldstring ;
  int pos ;
  int move ;
  size_t tmp___0 ;
  struct obstack *__o ;
  struct obstack  const  *__o1 ;
  char *tmp___1 ;
  struct obstack *__o___0 ;
  size_t __len ;
  struct obstack  const  *__o1___0 ;
  struct obstack *__o___1 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o___2 ;
  struct obstack  const  *__o1___2 ;
  char *tmp___2 ;
  struct obstack *__o1___3 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct obstack *__o___3 ;
  void *__obj ;
  char *tmp___5 ;

  {
  {
#line 319
  tmp = strlen(prefix);
#line 319
  pref_len = (int )tmp;
#line 320
  oldstring = aclstring;
#line 321
  pos = 0;
  }
#line 323
  if (! aclstring) {
#line 324
    return;
  } else
#line 323
  if (! len) {
#line 324
    return;
  }
  {
#line 326
  _obstack_begin(& stk___0, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
  }
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! ((size_t )pos <= len)) {
#line 327
      goto while_break;
    }
    {
#line 329
    tmp___0 = strcspn(aclstring, ",\n");
#line 329
    move = (int )tmp___0;
    }
#line 330
    if (! move) {
#line 331
      goto while_break;
    }
#line 333
    if ((unsigned long )oldstring != (unsigned long )aclstring) {
#line 334
      __o = & stk___0;
#line 334
      __o1 = (struct obstack  const  *)__o;
#line 334
      if ((size_t )(__o1->chunk_limit - __o1->next_free) < 1UL) {
        {
#line 334
        _obstack_newchunk(__o, (size_t )1);
        }
      }
#line 334
      tmp___1 = __o->next_free;
#line 334
      (__o->next_free) ++;
#line 334
      *tmp___1 = delim;
    }
#line 336
    __o___0 = & stk___0;
#line 336
    __len = (size_t )pref_len;
#line 336
    __o1___0 = (struct obstack  const  *)__o___0;
#line 336
    if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len) {
      {
#line 336
      _obstack_newchunk(__o___0, __len);
      }
    }
    {
#line 336
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)prefix,
           __len);
#line 336
    __o___0->next_free += __len;
#line 337
    __o___1 = & stk___0;
#line 337
    __len___0 = (size_t )move;
#line 337
    __o1___1 = (struct obstack  const  *)__o___1;
    }
#line 337
    if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___0) {
      {
#line 337
      _obstack_newchunk(__o___1, __len___0);
      }
    }
    {
#line 337
    memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)aclstring,
           __len___0);
#line 337
    __o___1->next_free += __len___0;
#line 339
    aclstring += move + 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  __o___2 = & stk___0;
#line 342
  __o1___2 = (struct obstack  const  *)__o___2;
#line 342
  if ((size_t )(__o1___2->chunk_limit - __o1___2->next_free) < 1UL) {
    {
#line 342
    _obstack_newchunk(__o___2, (size_t )1);
    }
  }
#line 342
  tmp___2 = __o___2->next_free;
#line 342
  (__o___2->next_free) ++;
#line 342
  *tmp___2 = (char )'\000';
#line 344
  __o1___3 = & stk___0;
#line 344
  __value = (void *)__o1___3->object_base;
#line 344
  if ((unsigned long )__o1___3->next_free == (unsigned long )__value) {
#line 344
    __o1___3->maybe_empty_object = 1U;
  }
#line 344
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 344
    tmp___3 = __o1___3->object_base;
  } else {
#line 344
    tmp___3 = (char *)0;
  }
#line 344
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 344
    tmp___4 = __o1___3->object_base;
  } else {
#line 344
    tmp___4 = (char *)0;
  }
#line 344
  __o1___3->next_free = tmp___3 + (((size_t )(__o1___3->next_free - tmp___4) + __o1___3->alignment_mask) & ~ __o1___3->alignment_mask);
#line 344
  if ((size_t )(__o1___3->next_free - (char *)__o1___3->chunk) > (size_t )(__o1___3->chunk_limit - (char *)__o1___3->chunk)) {
#line 344
    __o1___3->next_free = __o1___3->chunk_limit;
  }
  {
#line 344
  __o1___3->object_base = __o1___3->next_free;
#line 344
  fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s",
          (char *)__value);
#line 346
  __o___3 = & stk___0;
#line 346
  __obj = (void *)0;
  }
#line 346
  if ((unsigned long )__obj > (unsigned long )((void *)__o___3->chunk)) {
#line 346
    if ((unsigned long )__obj < (unsigned long )((void *)__o___3->chunk_limit)) {
#line 346
      tmp___5 = (char *)__obj;
#line 346
      __o___3->object_base = tmp___5;
#line 346
      __o___3->next_free = tmp___5;
    } else {
      {
#line 346
      _obstack_free(__o___3, __obj);
      }
    }
  } else {
    {
#line 346
    _obstack_free(__o___3, __obj);
    }
  }
#line 347
  return;
}
}
#line 356 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static int done  =    0;
#line 349 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_acls_get(int parentfd , char const   *file_name___0 , struct tar_stat_info *st ,
                     int fd , int xisfile ) 
{ 
  char *tmp ;

  {
#line 353
  if (acls_option > 0) {
#line 357
    if (! done) {
      {
#line 358
      while (1) {
        while_continue: /* CIL Label */ ;
#line 358
        if (error_hook) {
          {
#line 358
          (*error_hook)();
          }
        }
        {
#line 358
        tmp = gettext("POSIX ACL support is not available");
#line 358
        error(0, 0, (char const   *)tmp);
        }
#line 358
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 359
    done = 1;
  }
#line 377
  return;
}
}
#line 386 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static int done___0  =    0;
#line 379 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_acls_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                     char typeflag ) 
{ 
  char *tmp ;

  {
#line 383
  if (acls_option > 0) {
#line 383
    if ((int )typeflag != 50) {
#line 387
      if (! done___0) {
        {
#line 388
        while (1) {
          while_continue: /* CIL Label */ ;
#line 388
          if (error_hook) {
            {
#line 388
            (*error_hook)();
            }
          }
          {
#line 388
          tmp = gettext("POSIX ACL support is not available");
#line 388
          error(0, 0, (char const   *)tmp);
          }
#line 388
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 389
      done___0 = 1;
    }
  }
#line 398
  return;
}
}
#line 400 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static void mask_map_realloc(struct xattrs_mask_map *map ) 
{ 
  void *tmp ;

  {
#line 403
  if (map->used == map->size) {
#line 405
    if (map->size == 0UL) {
#line 406
      map->size = (size_t )4;
    }
    {
#line 407
    tmp = x2nrealloc((void *)map->masks, & map->size, sizeof(*(map->masks + 0)));
#line 407
    map->masks = (char const   **)tmp;
    }
  }
#line 409
  return;
}
}
#line 411 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_mask_add(char const   *mask , _Bool incl ) 
{ 
  struct xattrs_mask_map *mask_map ;
  struct xattrs_mask_map *tmp ;
  size_t tmp___0 ;

  {
#line 414
  if (incl) {
#line 414
    tmp = & xattrs_setup.incl;
  } else {
#line 414
    tmp = & xattrs_setup.excl;
  }
  {
#line 414
  mask_map = tmp;
#line 417
  mask_map_realloc(mask_map);
#line 420
  tmp___0 = mask_map->used;
#line 420
  (mask_map->used) ++;
#line 420
  *(mask_map->masks + tmp___0) = mask;
  }
#line 421
  return;
}
}
#line 423 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static void clear_mask_map(struct xattrs_mask_map *mask_map ) 
{ 


  {
#line 426
  if (mask_map->size) {
    {
#line 427
    free((void *)mask_map->masks);
    }
  }
#line 428
  return;
}
}
#line 430 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_clear_setup(void) 
{ 


  {
  {
#line 433
  clear_mask_map(& xattrs_setup.incl);
#line 434
  clear_mask_map(& xattrs_setup.excl);
  }
#line 435
  return;
}
}
#line 451 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static size_t xsz  =    (size_t )1024;
#line 452 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static char *xatrs  =    (char *)((void *)0);
#line 472 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static size_t asz  =    (size_t )1024;
#line 473 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static char *val  =    (char *)((void *)0);
#line 439 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_xattrs_get(int parentfd , char const   *file_name___0 , struct tar_stat_info *st ,
                       int fd ) 
{ 
  ssize_t xret ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  char const   *tmp___3 ;
  char const   *attr ;
  void *tmp___4 ;
  size_t len ;
  size_t tmp___5 ;
  ssize_t aret ;
  void *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char const   *tmp___9 ;
  int *tmp___10 ;

  {
#line 443
  if (xattrs_option > 0) {
#line 453
    xret = (ssize_t )-1;
#line 455
    if (! xatrs) {
      {
#line 456
      tmp = x2nrealloc((void *)xatrs, & xsz, (size_t )1);
#line 456
      xatrs = (char *)tmp;
      }
    }
    {
#line 458
    while (1) {
      while_continue: /* CIL Label */ ;
#line 458
      if (fd == 0) {
        {
#line 458
        xret = llistxattrat(parentfd, file_name___0, xatrs, xsz);
#line 458
        tmp___1 = xret == -1L;
        }
      } else {
        {
#line 458
        xret = flistxattr(fd, xatrs, xsz);
#line 458
        tmp___1 = xret == -1L;
        }
      }
#line 458
      if (tmp___1) {
        {
#line 458
        tmp___2 = __errno_location();
        }
#line 458
        if (! (*tmp___2 == 34)) {
#line 458
          goto while_break;
        }
      } else {
#line 458
        goto while_break;
      }
      {
#line 464
      tmp___0 = x2nrealloc((void *)xatrs, & xsz, (size_t )1);
#line 464
      xatrs = (char *)tmp___0;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 467
    if (xret == -1L) {
#line 468
      if (fd == 0) {
#line 468
        tmp___3 = "llistxattrat";
      } else {
#line 468
        tmp___3 = "flistxattr";
      }
      {
#line 468
      call_arg_warn(tmp___3, file_name___0);
      }
    } else {
#line 471
      attr = (char const   *)xatrs;
#line 475
      if (! val) {
        {
#line 476
        tmp___4 = x2nrealloc((void *)val, & asz, (size_t )1);
#line 476
        val = (char *)tmp___4;
        }
      }
      {
#line 478
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 478
        if (! (xret > 0L)) {
#line 478
          goto while_break___0;
        }
        {
#line 480
        tmp___5 = strlen(attr);
#line 480
        len = tmp___5;
#line 481
        aret = (ssize_t )0;
        }
        {
#line 485
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 485
          if (fd == 0) {
            {
#line 485
            aret = lgetxattrat(parentfd, file_name___0, attr, (void *)val, asz);
#line 485
            tmp___7 = aret == -1L;
            }
          } else {
            {
#line 485
            aret = fgetxattr(fd, attr, (void *)val, asz);
#line 485
            tmp___7 = aret == -1L;
            }
          }
#line 485
          if (tmp___7) {
            {
#line 485
            tmp___8 = __errno_location();
            }
#line 485
            if (! (*tmp___8 == 34)) {
#line 485
              goto while_break___1;
            }
          } else {
#line 485
            goto while_break___1;
          }
          {
#line 491
          tmp___6 = x2nrealloc((void *)val, & asz, (size_t )1);
#line 491
          val = (char *)tmp___6;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 494
        if (aret != -1L) {
          {
#line 495
          xheader_xattr_add(st, attr, (char const   *)val, (size_t )aret);
          }
        } else {
          {
#line 496
          tmp___10 = __errno_location();
          }
#line 496
          if (*tmp___10 != 61) {
#line 497
            if (fd == 0) {
#line 497
              tmp___9 = "lgetxattrat";
            } else {
#line 497
              tmp___9 = "fgetxattr";
            }
            {
#line 497
            call_arg_warn(tmp___9, file_name___0);
            }
          }
        }
#line 500
        attr += len + 1UL;
#line 501
        xret = (ssize_t )((size_t )xret - (len + 1UL));
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 506
  return;
}
}
#line 509 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static void xattrs__fd_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                           char typeflag , char const   *attr , char const   *ptr ,
                           size_t len ) 
{ 
  char const   *sysname ;
  int ret ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 514
  if (ptr) {
#line 516
    sysname = "setxattrat";
#line 517
    ret = -1;
#line 519
    if ((int )typeflag != 50) {
      {
#line 520
      ret = setxattrat(chdir_fd, file_name___0, attr, (void const   *)ptr, len, 0);
      }
    } else {
      {
#line 523
      sysname = "lsetxattr";
#line 524
      ret = lsetxattrat(chdir_fd, file_name___0, attr, (void const   *)ptr, len, 0);
      }
    }
#line 527
    if (ret == -1) {
      {
#line 528
      while (1) {
        while_continue: /* CIL Label */ ;
#line 528
        if (warning_option & 2097152) {
          {
#line 528
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 528
            if (error_hook) {
              {
#line 528
              (*error_hook)();
              }
            }
            {
#line 528
            tmp = gettext("%s: Cannot set \'%s\' extended attribute for file \'%s\'");
#line 528
            tmp___0 = __errno_location();
#line 528
            error(0, *tmp___0, (char const   *)tmp, sysname, attr, file_name___0);
            }
#line 528
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 528
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 533
  return;
}
}
#line 545 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static int done___1  =    0;
#line 538 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_selinux_get(int parentfd , char const   *file_name___0 , struct tar_stat_info *st ,
                        int fd ) 
{ 
  char *tmp ;

  {
#line 542
  if (selinux_context_option > 0) {
#line 546
    if (! done___1) {
      {
#line 547
      while (1) {
        while_continue: /* CIL Label */ ;
#line 547
        if (error_hook) {
          {
#line 547
          (*error_hook)();
          }
        }
        {
#line 547
        tmp = gettext("SELinux support is not available");
#line 547
        error(0, 0, (char const   *)tmp);
        }
#line 547
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 548
    done___1 = 1;
  }
#line 558
  return;
}
}
#line 567 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static int done___2  =    0;
#line 560 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_selinux_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                        char typeflag ) 
{ 
  char *tmp ;

  {
#line 564
  if (selinux_context_option > 0) {
#line 568
    if (! done___2) {
      {
#line 569
      while (1) {
        while_continue: /* CIL Label */ ;
#line 569
        if (error_hook) {
          {
#line 569
          (*error_hook)();
          }
        }
        {
#line 569
        tmp = gettext("SELinux support is not available");
#line 569
        error(0, 0, (char const   *)tmp);
        }
#line 569
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 570
    done___2 = 1;
  }
#line 596
  return;
}
}
#line 598 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static _Bool xattrs_matches_mask(char const   *kw , struct xattrs_mask_map *mm ) 
{ 
  int i ;
  int tmp ;

  {
#line 603
  if (! mm->size) {
#line 604
    return ((_Bool)0);
  }
#line 606
  i = 0;
  {
#line 606
  while (1) {
    while_continue: /* CIL Label */ ;
#line 606
    if (! ((size_t )i < mm->used)) {
#line 606
      goto while_break;
    }
    {
#line 607
    tmp = fnmatch(*(mm->masks + i), kw, 0);
    }
#line 607
    if (tmp == 0) {
#line 608
      return ((_Bool)1);
    }
#line 606
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return ((_Bool)0);
}
}
#line 615 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static _Bool xattrs_kw_included(char const   *kw , _Bool archiving ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 618
  if (xattrs_setup.incl.size) {
    {
#line 619
    tmp = xattrs_matches_mask(kw, & xattrs_setup.incl);
    }
#line 619
    return (tmp);
  } else
#line 620
  if (archiving) {
#line 621
    return ((_Bool)1);
  } else {
    {
#line 623
    tmp___0 = strncmp(kw, "user.", sizeof("user.") - 1UL);
    }
#line 623
    return ((_Bool )(tmp___0 == 0));
  }
}
}
#line 626 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static _Bool xattrs_kw_excluded(char const   *kw , _Bool archiving ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 629
  if (xattrs_setup.excl.size) {
    {
#line 629
    tmp = xattrs_matches_mask(kw, & xattrs_setup.excl);
#line 629
    tmp___0 = (int )tmp;
    }
  } else {
#line 629
    tmp___0 = 0;
  }
#line 629
  return ((_Bool )tmp___0);
}
}
#line 636 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
static _Bool xattrs_masked_out(char const   *kw , _Bool archiving ) 
{ 
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 639
  tmp___2 = xattrs_kw_included(kw, archiving);
  }
#line 639
  if (tmp___2) {
    {
#line 639
    tmp___0 = xattrs_kw_excluded(kw, archiving);
#line 639
    tmp___1 = (int )tmp___0;
    }
  } else {
#line 639
    tmp___1 = 1;
  }
#line 639
  return ((_Bool )tmp___1);
}
}
#line 643 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_xattrs_set(struct tar_stat_info  const  *st , char const   *file_name___0 ,
                       char typeflag , int later_run ) 
{ 
  size_t scan ;
  char *keyword ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
#line 647
  if (xattrs_option > 0) {
#line 655
    scan = (size_t )0;
#line 657
    if (! st->xattr_map_size) {
#line 658
      return;
    }
    {
#line 660
    while (1) {
      while_continue: /* CIL Label */ ;
#line 660
      if (! (scan < (size_t )st->xattr_map_size)) {
#line 660
        goto while_break;
      }
      {
#line 662
      keyword = (st->xattr_map + scan)->xkey;
#line 663
      tmp = strlen("SCHILY.xattr.");
#line 663
      keyword += tmp;
      }
#line 671
      if ((int )typeflag == 48) {
        {
#line 671
        tmp___0 = strcmp((char const   *)keyword, "security.capability");
        }
#line 671
        if (tmp___0) {
#line 671
          tmp___1 = 1;
        } else {
#line 671
          tmp___1 = 0;
        }
#line 671
        if (later_run == tmp___1) {
#line 673
          goto __Cont;
        }
      }
      {
#line 675
      tmp___2 = xattrs_masked_out((char const   *)keyword, (_Bool)0);
      }
#line 675
      if (tmp___2) {
#line 677
        goto __Cont;
      }
      {
#line 679
      xattrs__fd_set(st, file_name___0, typeflag, (char const   *)keyword, (char const   *)(st->xattr_map + scan)->xval_ptr,
                     (st->xattr_map + scan)->xval_len);
      }
      __Cont: /* CIL Label */ 
#line 660
      scan ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 685
  return;
}
}
#line 687 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_print_char(struct tar_stat_info  const  *st , char *output ) 
{ 
  int i ;
  char *keyword ;
  size_t tmp ;
  _Bool tmp___0 ;

  {
#line 692
  if (verbose_option < 2) {
#line 694
    *output = (char)0;
#line 695
    return;
  }
#line 698
  if (xattrs_option > 0) {
#line 701
    *output = (char )' ';
#line 702
    *(output + 1) = (char)0;
  } else
#line 698
  if (selinux_context_option > 0) {
#line 701
    *output = (char )' ';
#line 702
    *(output + 1) = (char)0;
  } else
#line 698
  if (acls_option > 0) {
#line 701
    *output = (char )' ';
#line 702
    *(output + 1) = (char)0;
  }
#line 705
  if (xattrs_option > 0) {
#line 705
    if (st->xattr_map_size) {
#line 706
      i = 0;
      {
#line 706
      while (1) {
        while_continue: /* CIL Label */ ;
#line 706
        if (! ((size_t const   )i < st->xattr_map_size)) {
#line 706
          goto while_break;
        }
        {
#line 708
        tmp = strlen("SCHILY.xattr.");
#line 708
        keyword = (st->xattr_map + i)->xkey + tmp;
#line 709
        tmp___0 = xattrs_masked_out((char const   *)keyword, (_Bool)0);
        }
#line 709
        if (! tmp___0) {
#line 711
          *output = (char )'*';
#line 712
          goto while_break;
        }
#line 706
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 716
  if (selinux_context_option > 0) {
#line 716
    if (st->cntx_name) {
#line 717
      *output = (char )'.';
    }
  }
#line 719
  if (acls_option > 0) {
#line 719
    if (st->acls_a_len) {
#line 720
      *output = (char )'+';
    } else
#line 719
    if (st->acls_d_len) {
#line 720
      *output = (char )'+';
    }
  }
#line 721
  return;
}
}
#line 723 "/home/khheo/project/benchmark/tar-1.29/src/xattrs.c"
void xattrs_print(struct tar_stat_info  const  *st ) 
{ 
  int i ;
  char *keyword ;
  size_t tmp ;
  _Bool tmp___0 ;

  {
#line 726
  if (verbose_option < 3) {
#line 727
    return;
  }
#line 730
  if (selinux_context_option > 0) {
#line 730
    if (st->cntx_name) {
      {
#line 731
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"  s: %s\n",
              st->cntx_name);
      }
    }
  }
#line 734
  if (acls_option > 0) {
#line 734
    if (st->acls_a_len) {
      {
#line 736
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"  a: ");
#line 737
      acls_one_line("", (char )',', (char const   *)st->acls_a_ptr, (size_t )st->acls_a_len);
#line 738
      acls_one_line("default:", (char )',', (char const   *)st->acls_d_ptr, (size_t )st->acls_d_len);
#line 739
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"\n");
      }
    } else
#line 734
    if (st->acls_d_len) {
      {
#line 736
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"  a: ");
#line 737
      acls_one_line("", (char )',', (char const   *)st->acls_a_ptr, (size_t )st->acls_a_len);
#line 738
      acls_one_line("default:", (char )',', (char const   *)st->acls_d_ptr, (size_t )st->acls_d_len);
#line 739
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"\n");
      }
    }
  }
#line 743
  if (xattrs_option > 0) {
#line 743
    if (st->xattr_map_size) {
#line 747
      i = 0;
      {
#line 747
      while (1) {
        while_continue: /* CIL Label */ ;
#line 747
        if (! ((size_t const   )i < st->xattr_map_size)) {
#line 747
          goto while_break;
        }
        {
#line 749
        tmp = strlen("SCHILY.xattr.");
#line 749
        keyword = (st->xattr_map + i)->xkey + tmp;
#line 750
        tmp___0 = xattrs_masked_out((char const   *)keyword, (_Bool)0);
        }
#line 750
        if (! tmp___0) {
          {
#line 751
          fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"  x: %lu %s\n",
                  (st->xattr_map + i)->xval_len, keyword);
          }
        }
#line 747
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 755
  return;
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 937
void set_warning_option(char const   *arg___0 ) ;
#line 974
#pragma GCC diagnostic pop
#line 25 "/home/khheo/project/benchmark/tar-1.29/src/warning.c"
static char const   * const  warning_args[25]  = 
#line 25 "/home/khheo/project/benchmark/tar-1.29/src/warning.c"
  {      (char const   */* const  */)"all",      (char const   */* const  */)"alone-zero-block",      (char const   */* const  */)"bad-dumpdir",      (char const   */* const  */)"cachedir", 
        (char const   */* const  */)"contiguous-cast",      (char const   */* const  */)"file-changed",      (char const   */* const  */)"file-ignored",      (char const   */* const  */)"file-removed", 
        (char const   */* const  */)"file-shrank",      (char const   */* const  */)"file-unchanged",      (char const   */* const  */)"filename-with-nuls",      (char const   */* const  */)"ignore-archive", 
        (char const   */* const  */)"ignore-newer",      (char const   */* const  */)"new-directory",      (char const   */* const  */)"rename-directory",      (char const   */* const  */)"symlink-cast", 
        (char const   */* const  */)"timestamp",      (char const   */* const  */)"unknown-cast",      (char const   */* const  */)"unknown-keyword",      (char const   */* const  */)"xdev", 
        (char const   */* const  */)"decompress-program",      (char const   */* const  */)"existing-file",      (char const   */* const  */)"xattr-write",      (char const   */* const  */)"record-size", 
        (char const   */* const  */)((void *)0)};
#line 53 "/home/khheo/project/benchmark/tar-1.29/src/warning.c"
static int warning_types[24]  = 
#line 53
  {      ~ 5779456,      1,      2,      4, 
        8,      16,      32,      64, 
        128,      256,      512,      1024, 
        2048,      4096,      8192,      16384, 
        32768,      65536,      131072,      262144, 
        524288,      1048576,      2097152,      4194304};
#line 82 "/home/khheo/project/benchmark/tar-1.29/src/warning.c"
int warning_option  =    ~ 5779456;
#line 84 "/home/khheo/project/benchmark/tar-1.29/src/warning.c"
void set_warning_option(char const   *arg___0 ) 
{ 
  int negate ;
  int option ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  ptrdiff_t tmp___2 ;

  {
  {
#line 87
  negate = 0;
#line 90
  tmp = strcmp(arg___0, "none");
  }
#line 90
  if (tmp == 0) {
#line 92
    warning_option = 0;
#line 93
    return;
  }
  {
#line 95
  tmp___0 = strlen(arg___0);
  }
#line 95
  if (tmp___0 > 2UL) {
    {
#line 95
    tmp___1 = memcmp((void const   *)arg___0, (void const   *)"no-", (size_t )3);
    }
#line 95
    if (tmp___1 == 0) {
#line 97
      negate = 1;
#line 98
      arg___0 += 3;
    }
  }
  {
#line 101
  tmp___2 = __xargmatch_internal("--warning", arg___0, warning_args, (char const   *)(warning_types),
                                 sizeof(warning_types[0]), argmatch_die);
#line 101
  option = warning_types[tmp___2];
  }
#line 103
  if (negate) {
#line 104
    warning_option &= ~ option;
  } else {
#line 106
    warning_option |= option;
  }
#line 107
  return;
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 880
_Bool string_ascii_p(char const   *p ) ;
#line 881
_Bool utf8_convert(_Bool to_utf , char const   *input , char **output ) ;
#line 974
#pragma GCC diagnostic pop
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 49 "/home/khheo/project/benchmark/tar-1.29/src/utf8.c"
static iconv_t conv_desc[2]  = {      (iconv_t )-1,      (iconv_t )-1};
#line 51 "/home/khheo/project/benchmark/tar-1.29/src/utf8.c"
static iconv_t utf8_init(_Bool to_utf ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 54
  if ((unsigned long )conv_desc[(int )to_utf] == (unsigned long )((iconv_t )-1)) {
#line 56
    if (to_utf) {
      {
#line 57
      tmp = locale_charset();
#line 57
      conv_desc[(int )to_utf] = iconv_open("UTF-8", tmp);
      }
    } else {
      {
#line 59
      tmp___0 = locale_charset();
#line 59
      conv_desc[(int )to_utf] = iconv_open(tmp___0, "UTF-8");
      }
    }
  }
#line 61
  return (conv_desc[(int )to_utf]);
}
}
#line 64 "/home/khheo/project/benchmark/tar-1.29/src/utf8.c"
_Bool utf8_convert(_Bool to_utf , char const   *input , char **output ) 
{ 
  char *ib ;
  char *ob ;
  size_t inlen ;
  size_t outlen ;
  size_t rc ;
  iconv_t cd ;
  iconv_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 72
  tmp = utf8_init(to_utf);
#line 72
  cd = tmp;
  }
#line 74
  if ((unsigned long )cd == (unsigned long )((iconv_t )0)) {
    {
#line 76
    *output = xstrdup(input);
    }
#line 77
    return ((_Bool)1);
  } else
#line 79
  if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 80
    return ((_Bool)0);
  }
  {
#line 82
  tmp___0 = strlen(input);
#line 82
  inlen = tmp___0 + 1UL;
#line 83
  outlen = inlen * 16UL + 1UL;
#line 84
  tmp___2 = xmalloc(outlen);
#line 84
  tmp___1 = (char *)tmp___2;
#line 84
  *output = tmp___1;
#line 84
  ob = tmp___1;
#line 85
  ib = (char *)input;
#line 86
  rc = iconv(cd, (char **/* __restrict  */)(& ib), (size_t */* __restrict  */)(& inlen),
             (char **/* __restrict  */)(& ob), (size_t */* __restrict  */)(& outlen));
#line 87
  *ob = (char)0;
  }
#line 88
  return ((_Bool )(rc != 0xffffffffffffffffUL));
}
}
#line 92 "/home/khheo/project/benchmark/tar-1.29/src/utf8.c"
_Bool string_ascii_p(char const   *p ) 
{ 


  {
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! *p) {
#line 95
      goto while_break;
    }
#line 96
    if ((int const   )*p & -128) {
#line 97
      return ((_Bool)0);
    }
#line 95
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return ((_Bool)1);
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 97
enum subcommand subcommand_option ;
#line 100
enum archive_format archive_format ;
#line 176
_Bool interactive_option ;
#line 347
struct tar_stat_info current_stat_info ;
#line 447
size_t available_space_after(union block *pointer ) ;
#line 449
void close_archive(void) ;
#line 452
union block *find_next_block(void) ;
#line 457
void open_archive(enum access_mode wanted_access ) ;
#line 459
void reset_eof(void) ;
#line 460
void set_next_block_after(union block *block ) ;
#line 480
void buffer_write_global_xheader(void) ;
#line 502
void dump_file(struct tar_stat_info *parent , char const   *name , char const   *fullname ) ;
#line 511
void write_eot(void) ;
#line 592
union block *current_header ;
#line 593
enum archive_format current_format ;
#line 597
void decode_header(union block *header , struct tar_stat_info *stat_info , enum archive_format *format_pointer ,
                   int do_user_group ) ;
#line 599
void transform_stat_info(int typeflag , struct tar_stat_info *stat_info ) ;
#line 614
enum read_header read_header(union block **return_block , struct tar_stat_info *info ,
                             enum read_header_mode mode ) ;
#line 619
void skip_member(void) ;
#line 632
char *tar_savedir(char const   *name , int must_exist ) ;
#line 635
namebuf_t namebuf_create(char const   *dir ) ;
#line 636
void namebuf_free(namebuf_t buf ) ;
#line 637
char *namebuf_name(namebuf_t buf , char const   *name ) ;
#line 698
int deref_stat(char const   *name , struct stat *buf ) ;
#line 706
void chdir_do(int i ) ;
#line 744
void name_gather(void) ;
#line 745
struct name *addname(char const   *string , int change_dir___0 , _Bool cmdline , struct name *parent ) ;
#line 747
void remname(struct name *name ) ;
#line 749
void names_notfound(void) ;
#line 752
struct name *name_scan(char const   *file_name___0 ) ;
#line 753
struct name  const  *name_from_list(void) ;
#line 775
int confirm(char const   *message_action , char const   *message_name ) ;
#line 779
void tar_stat_destroy(struct tar_stat_info *st ) ;
#line 781
int tar_timespec_cmp(struct timespec a , struct timespec b ) ;
#line 810 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char *output_start  ;
#line 812
void update_archive(void) ;
#line 951
void finish_deferred_unlinks(void) ;
#line 964
_Bool excluded_name(char const   *name , struct tar_stat_info *st ) ;
#line 974
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/src/update.c"
union block *current_block ;
#line 39 "/home/khheo/project/benchmark/tar-1.29/src/update.c"
_Bool time_to_start_writing  ;
#line 48 "/home/khheo/project/benchmark/tar-1.29/src/update.c"
static void append_file(char *file_name___0 ) 
{ 
  int handle ;
  int tmp ;
  struct stat stat_data ;
  off_t bytes_left ;
  union block *start ;
  union block *tmp___0 ;
  size_t buffer_size ;
  size_t tmp___1 ;
  size_t status ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 51
  tmp = openat(chdir_fd, (char const   *)file_name___0, 0);
#line 51
  handle = tmp;
  }
#line 54
  if (handle < 0) {
    {
#line 56
    open_error((char const   *)file_name___0);
    }
#line 57
    return;
  }
  {
#line 60
  tmp___5 = fstat(handle, & stat_data);
  }
#line 60
  if (tmp___5 != 0) {
    {
#line 61
    stat_error((char const   *)file_name___0);
    }
  } else {
#line 64
    bytes_left = stat_data.st_size;
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! (bytes_left > 0L)) {
#line 66
        goto while_break;
      }
      {
#line 68
      tmp___0 = find_next_block();
#line 68
      start = tmp___0;
#line 69
      tmp___1 = available_space_after(start);
#line 69
      buffer_size = tmp___1;
      }
#line 73
      if ((size_t )bytes_left < buffer_size) {
#line 75
        buffer_size = (size_t )bytes_left;
#line 76
        status = buffer_size % 512UL;
#line 77
        if (status) {
          {
#line 78
          memset((void *)(start->buffer + bytes_left), 0, 512UL - status);
          }
        }
      }
      {
#line 81
      status = safe_read(handle, (void *)(start->buffer), buffer_size);
      }
#line 82
      if (status == 0xffffffffffffffffUL) {
        {
#line 83
        read_fatal_details((char const   *)file_name___0, stat_data.st_size - bytes_left,
                           buffer_size);
        }
      }
#line 85
      if (status == 0UL) {
        {
#line 86
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 86
          if (error_hook) {
            {
#line 86
            (*error_hook)();
            }
          }
          {
#line 86
          tmp___2 = umaxtostr((uintmax_t )bytes_left, buf);
#line 86
          tmp___3 = quotearg_colon((char const   *)file_name___0);
#line 86
          tmp___4 = ngettext("%s: File shrank by %s byte", "%s: File shrank by %s bytes",
                             (unsigned long )bytes_left);
#line 86
          error(0, 0, (char const   *)tmp___4, tmp___3, tmp___2);
#line 86
          fatal_exit();
          }
#line 86
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 93
      bytes_left = (off_t )((size_t )bytes_left - status);
#line 95
      set_next_block_after(start + (status - 1UL) / 512UL);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 99
  tmp___6 = close(handle);
  }
#line 99
  if (tmp___6 != 0) {
    {
#line 100
    close_error((char const   *)file_name___0);
    }
  }
#line 101
  return;
}
}
#line 106 "/home/khheo/project/benchmark/tar-1.29/src/update.c"
void update_archive(void) 
{ 
  enum read_header previous_status ;
  _Bool found_end ;
  enum read_header status ;
  enum read_header tmp ;
  struct name *name ;
  struct stat s ;
  char *p ;
  char *dirp ;
  char *tmp___0 ;
  namebuf_t nbuf ;
  namebuf_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  struct timespec  __attribute__((__pure__)) tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  struct name  const  *p___0 ;
  char *file_name___0 ;
  _Bool tmp___9 ;
  int tmp___10 ;

  {
  {
#line 109
  previous_status = (enum read_header )0;
#line 110
  found_end = (_Bool)0;
#line 112
  name_gather();
#line 113
  open_archive((enum access_mode )2);
#line 114
  buffer_write_global_xheader();
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (! found_end)) {
#line 116
      goto while_break;
    }
    {
#line 118
    tmp = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
#line 118
    status = tmp;
    }
    {
#line 125
    if ((unsigned int )status == 2U) {
#line 125
      goto case_2;
    }
#line 125
    if ((unsigned int )status == 0U) {
#line 125
      goto case_2;
    }
#line 128
    if ((unsigned int )status == 1U) {
#line 128
      goto case_1;
    }
#line 174
    if ((unsigned int )status == 3U) {
#line 174
      goto case_3;
    }
#line 179
    if ((unsigned int )status == 4U) {
#line 179
      goto case_4;
    }
#line 183
    if ((unsigned int )status == 5U) {
#line 183
      goto case_5;
    }
#line 122
    goto switch_break;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 126
    abort();
    }
    case_1: /* CIL Label */ 
    {
#line 132
    decode_header(current_header, & current_stat_info, & current_format, 0);
#line 134
    transform_stat_info((int )current_header->header.typeflag, & current_stat_info);
#line 136
    archive_format = current_format;
    }
#line 138
    if ((unsigned int )subcommand_option == 8U) {
      {
#line 138
      name = name_scan((char const   *)current_stat_info.file_name);
      }
#line 138
      if ((unsigned long )name != (unsigned long )((void *)0)) {
        {
#line 143
        chdir_do(name->change_dir);
#line 144
        tmp___6 = deref_stat((char const   *)current_stat_info.file_name, & s);
        }
#line 144
        if (tmp___6 == 0) {
#line 146
          if ((s.st_mode & 61440U) == 16384U) {
            {
#line 148
            tmp___0 = tar_savedir((char const   *)name->name, 1);
#line 148
            dirp = tmp___0;
            }
#line 149
            if (dirp) {
              {
#line 151
              tmp___1 = namebuf_create((char const   *)name->name);
#line 151
              nbuf = tmp___1;
#line 153
              p = dirp;
              }
              {
#line 153
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 153
                if (! *p) {
#line 153
                  goto while_break___0;
                }
                {
#line 154
                tmp___3 = namebuf_name(nbuf, (char const   *)p);
#line 154
                addname((char const   *)tmp___3, 0, (_Bool)0, (struct name *)((void *)0));
#line 153
                tmp___2 = strlen((char const   *)p);
#line 153
                p += tmp___2 + 1UL;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
              {
#line 157
              namebuf_free(nbuf);
#line 158
              free((void *)dirp);
#line 160
              remname(name);
              }
            }
          } else {
            {
#line 163
            tmp___4 = get_stat_mtime((struct stat  const  *)(& s));
#line 163
            tmp___5 = tar_timespec_cmp((struct timespec )tmp___4, current_stat_info.mtime);
            }
#line 163
            if (tmp___5 <= 0) {
              {
#line 166
              remname(name);
              }
            }
          }
        }
      }
    }
    {
#line 170
    skip_member();
    }
#line 171
    goto switch_break;
    case_3: /* CIL Label */ 
#line 175
    current_block = current_header;
#line 176
    found_end = (_Bool)1;
#line 177
    goto switch_break;
    case_4: /* CIL Label */ 
#line 180
    found_end = (_Bool)1;
#line 181
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 184
    set_next_block_after(current_header);
    }
    {
#line 187
    if ((unsigned int )previous_status == 0U) {
#line 187
      goto case_0___0;
    }
#line 192
    if ((unsigned int )previous_status == 3U) {
#line 192
      goto case_3___0;
    }
#line 192
    if ((unsigned int )previous_status == 1U) {
#line 192
      goto case_3___0;
    }
#line 196
    if ((unsigned int )previous_status == 5U) {
#line 196
      goto case_5___0;
    }
#line 200
    if ((unsigned int )previous_status == 2U) {
#line 200
      goto case_2___0;
    }
#line 200
    if ((unsigned int )previous_status == 4U) {
#line 200
      goto case_2___0;
    }
#line 185
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      if (error_hook) {
        {
#line 188
        (*error_hook)();
        }
      }
      {
#line 188
      tmp___7 = gettext("This does not look like a tar archive");
#line 188
      error(0, 0, (char const   *)tmp___7);
      }
#line 188
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    case_3___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 193
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 193
      if (error_hook) {
        {
#line 193
        (*error_hook)();
        }
      }
      {
#line 193
      tmp___8 = gettext("Skipping to next header");
#line 193
      error(0, 0, (char const   *)tmp___8);
#line 193
      exit_status = 2;
      }
#line 193
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    case_5___0: /* CIL Label */ 
#line 197
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
    {
#line 201
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 203
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 206
    tar_stat_destroy(& current_stat_info);
#line 207
    previous_status = status;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  reset_eof();
#line 211
  time_to_start_writing = (_Bool)1;
#line 212
  output_start = current_block->buffer;
  }
  {
#line 216
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 216
    p___0 = name_from_list();
    }
#line 216
    if (! ((unsigned long )p___0 != (unsigned long )((void *)0))) {
#line 216
      goto while_break___3;
    }
    {
#line 218
    file_name___0 = (char *)p___0->name;
#line 219
    tmp___9 = excluded_name((char const   *)file_name___0, (struct tar_stat_info *)((void *)0));
    }
#line 219
    if (tmp___9) {
#line 220
      goto while_continue___3;
    }
#line 221
    if (interactive_option) {
      {
#line 221
      tmp___10 = confirm("add", (char const   *)file_name___0);
      }
#line 221
      if (! tmp___10) {
#line 222
        goto while_continue___3;
      }
    }
#line 223
    if ((unsigned int )subcommand_option == 2U) {
      {
#line 224
      append_file(file_name___0);
      }
    } else {
      {
#line 226
      dump_file((struct tar_stat_info *)0, (char const   *)file_name___0, (char const   *)file_name___0);
      }
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 230
  write_eot();
#line 231
  close_archive();
#line 232
  finish_deferred_unlinks();
#line 233
  names_notfound();
  }
#line 234
  return;
}
}
#line 832 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) unlinkat)(int __fd ,
                                                                                               char const   *__name ,
                                                                                               int __flag ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 443
off_t records_written ;
#line 629
void normalize_filename_x(char *file_name___0 ) ;
#line 639
char const   *tar_dirname(void) ;
#line 703
int chdir_current ;
#line 950
void queue_deferred_unlink(char const   *name , _Bool is_dir ) ;
#line 974
#pragma GCC diagnostic pop
#line 40 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static struct deferred_unlink *dunlink_head  ;
#line 40 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static struct deferred_unlink *dunlink_tail  ;
#line 43 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static size_t dunlink_count  ;
#line 46 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static struct deferred_unlink *dunlink_avail  ;
#line 50 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static size_t deferred_unlink_delay  =    (size_t )0;
#line 52 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static struct deferred_unlink *dunlink_alloc(void) 
{ 
  struct deferred_unlink *p ;
  void *tmp ;

  {
#line 56
  if (dunlink_avail) {
#line 58
    p = dunlink_avail;
#line 59
    dunlink_avail = p->next;
#line 60
    p->next = (struct deferred_unlink *)((void *)0);
  } else {
    {
#line 63
    tmp = xmalloc(sizeof(*p));
#line 63
    p = (struct deferred_unlink *)tmp;
    }
  }
#line 64
  return (p);
}
}
#line 67 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static void dunlink_insert(struct deferred_unlink *anchor , struct deferred_unlink *p ) 
{ 


  {
#line 70
  if (anchor) {
#line 72
    p->next = anchor->next;
#line 73
    anchor->next = p;
  } else {
#line 77
    p->next = dunlink_head;
#line 78
    dunlink_head = p;
  }
#line 80
  if (! p->next) {
#line 81
    dunlink_tail = p;
  }
#line 82
  dunlink_count ++;
#line 83
  return;
}
}
#line 85 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static void dunlink_reclaim(struct deferred_unlink *p ) 
{ 


  {
  {
#line 88
  free((void *)p->file_name);
#line 89
  p->next = dunlink_avail;
#line 90
  dunlink_avail = p;
  }
#line 91
  return;
}
}
#line 93 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
static void flush_deferred_unlinks(_Bool force ) 
{ 
  struct deferred_unlink *p ;
  struct deferred_unlink *prev ;
  int saved_chdir ;
  struct deferred_unlink *next ;
  char const   *fname ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  struct deferred_unlink *next___0 ;
  char const   *fname___0 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 96
  prev = (struct deferred_unlink *)((void *)0);
#line 97
  saved_chdir = chdir_current;
#line 99
  p = dunlink_head;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! p) {
#line 99
      goto while_break;
    }
#line 101
    next = p->next;
#line 103
    if (force) {
#line 103
      goto _L;
    } else
#line 103
    if ((size_t )records_written > (size_t )p->records_written + deferred_unlink_delay) {
      _L: /* CIL Label */ 
      {
#line 106
      chdir_do(p->dir_idx);
      }
#line 107
      if (p->is_dir) {
#line 111
        if (p->dir_idx) {
#line 111
          if (p->is_dir) {
#line 111
            if ((int )*(p->file_name + 0) == 0) {
#line 113
              prev = p;
#line 114
              p = next;
#line 115
              goto __Cont;
            } else {
              {
#line 111
              tmp = strcmp((char const   *)p->file_name, ".");
              }
#line 111
              if (tmp == 0) {
#line 113
                prev = p;
#line 114
                p = next;
#line 115
                goto __Cont;
              } else {
#line 118
                fname = (char const   *)p->file_name;
              }
            }
          } else {
#line 118
            fname = (char const   *)p->file_name;
          }
        } else {
#line 118
          fname = (char const   *)p->file_name;
        }
        {
#line 120
        tmp___1 = unlinkat(chdir_fd, fname, 512);
        }
#line 120
        if (tmp___1 != 0) {
          {
#line 122
          tmp___0 = __errno_location();
          }
          {
#line 124
          if (*tmp___0 == 2) {
#line 124
            goto case_2;
          }
#line 130
          if (*tmp___0 == 39) {
#line 130
            goto case_39;
          }
#line 130
          if (*tmp___0 == 17) {
#line 130
            goto case_39;
          }
#line 137
          goto switch_default;
          case_2: /* CIL Label */ 
#line 126
          goto switch_break;
          case_39: /* CIL Label */ 
          case_17: /* CIL Label */ 
#line 133
          prev = p;
#line 134
          p = next;
#line 135
          goto __Cont;
          switch_default: /* CIL Label */ 
          {
#line 138
          rmdir_error(fname);
          }
          switch_break: /* CIL Label */ ;
          }
        }
      } else {
        {
#line 144
        tmp___2 = unlinkat(chdir_fd, (char const   *)p->file_name, 0);
        }
#line 144
        if (tmp___2 != 0) {
          {
#line 144
          tmp___3 = __errno_location();
          }
#line 144
          if (*tmp___3 != 2) {
            {
#line 145
            unlink_error((char const   *)p->file_name);
            }
          }
        }
      }
      {
#line 147
      dunlink_reclaim(p);
#line 148
      dunlink_count --;
#line 149
      p = next;
      }
#line 150
      if (prev) {
#line 151
        prev->next = p;
      } else {
#line 153
        dunlink_head = p;
      }
    } else {
#line 157
      prev = p;
#line 158
      p = next;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  if (! dunlink_head) {
#line 162
    dunlink_tail = (struct deferred_unlink *)((void *)0);
  } else
#line 163
  if (force) {
#line 165
    p = dunlink_head;
    {
#line 165
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 165
      if (! p) {
#line 165
        goto while_break___0;
      }
      {
#line 167
      next___0 = p->next;
#line 170
      chdir_do(p->dir_idx);
      }
#line 171
      if (p->dir_idx) {
#line 171
        if (p->is_dir) {
#line 171
          if ((int )*(p->file_name + 0) == 0) {
            {
#line 173
            fname___0 = tar_dirname();
#line 174
            chdir_do(p->dir_idx - 1);
            }
          } else {
            {
#line 171
            tmp___4 = strcmp((char const   *)p->file_name, ".");
            }
#line 171
            if (tmp___4 == 0) {
              {
#line 173
              fname___0 = tar_dirname();
#line 174
              chdir_do(p->dir_idx - 1);
              }
            } else {
#line 177
              fname___0 = (char const   *)p->file_name;
            }
          }
        } else {
#line 177
          fname___0 = (char const   *)p->file_name;
        }
      } else {
#line 177
        fname___0 = (char const   *)p->file_name;
      }
      {
#line 179
      tmp___6 = unlinkat(chdir_fd, fname___0, 512);
      }
#line 179
      if (tmp___6 != 0) {
        {
#line 181
        tmp___5 = __errno_location();
        }
#line 181
        if (*tmp___5 != 2) {
          {
#line 182
          rmdir_error(fname___0);
          }
        }
      }
      {
#line 184
      dunlink_reclaim(p);
#line 185
      dunlink_count --;
#line 186
      p = next___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 188
    dunlink_tail = (struct deferred_unlink *)((void *)0);
#line 188
    dunlink_head = dunlink_tail;
  }
  {
#line 191
  chdir_do(saved_chdir);
  }
#line 192
  return;
}
}
#line 194 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
void finish_deferred_unlinks(void) 
{ 
  struct deferred_unlink *next ;

  {
  {
#line 197
  flush_deferred_unlinks((_Bool)1);
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! dunlink_avail) {
#line 199
      goto while_break;
    }
    {
#line 201
    next = dunlink_avail->next;
#line 202
    free((void *)dunlink_avail);
#line 203
    dunlink_avail = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/home/khheo/project/benchmark/tar-1.29/src/unlink.c"
void queue_deferred_unlink(char const   *name , _Bool is_dir ) 
{ 
  struct deferred_unlink *p ;
  struct deferred_unlink *q ;
  struct deferred_unlink *prev ;
  int tmp ;
  int tmp___0 ;

  {
#line 212
  if (dunlink_head) {
#line 212
    if ((size_t )records_written > (size_t )dunlink_head->records_written + deferred_unlink_delay) {
      {
#line 214
      flush_deferred_unlinks((_Bool)0);
      }
    }
  }
  {
#line 216
  p = dunlink_alloc();
#line 217
  p->next = (struct deferred_unlink *)((void *)0);
#line 218
  p->dir_idx = chdir_current;
#line 219
  p->file_name = xstrdup(name);
#line 220
  normalize_filename_x(p->file_name);
#line 221
  p->is_dir = is_dir;
#line 222
  p->records_written = records_written;
  }
#line 224
  if (p->is_dir) {
#line 224
    if ((int )*(p->file_name + 0) == 0) {
#line 224
      goto _L___0;
    } else {
      {
#line 224
      tmp___0 = strcmp((char const   *)p->file_name, ".");
      }
#line 224
      if (tmp___0 == 0) {
        _L___0: /* CIL Label */ 
#line 227
        q = dunlink_head;
#line 227
        prev = (struct deferred_unlink *)((void *)0);
        {
#line 227
        while (1) {
          while_continue: /* CIL Label */ ;
#line 227
          if (! q) {
#line 227
            goto while_break;
          }
#line 228
          if (q->is_dir) {
#line 228
            if ((int )*(q->file_name + 0) == 0) {
#line 228
              goto _L;
            } else {
              {
#line 228
              tmp = strcmp((char const   *)q->file_name, ".");
              }
#line 228
              if (tmp == 0) {
                _L: /* CIL Label */ 
#line 228
                if (q->dir_idx < p->dir_idx) {
#line 229
                  goto while_break;
                }
              }
            }
          }
#line 227
          prev = q;
#line 227
          q = q->next;
        }
        while_break: /* CIL Label */ ;
        }
#line 230
        if (q) {
          {
#line 231
          dunlink_insert(prev, p);
          }
        } else {
          {
#line 233
          dunlink_insert(dunlink_tail, p);
          }
        }
      } else {
        {
#line 236
        dunlink_insert(dunlink_tail, p);
        }
      }
    }
  } else {
    {
#line 236
    dunlink_insert(dunlink_tail, p);
    }
  }
#line 237
  return;
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 654 "../gnu/regex.h"
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 625
void assign_string(char **string , char const   *value___0 ) ;
#line 773
 __attribute__((__noreturn__)) void usage(int status ) ;
#line 889
void set_transform_expr(char const   *expr ) ;
#line 890
_Bool transform_name(char **pinput , int type ) ;
#line 891
_Bool transform_name_fp(char **pinput , int flags , char *(*fun)(char * , void * ) ,
                        void *dat ) ;
#line 893
_Bool transform_program_p(void) ;
#line 974
#pragma GCC diagnostic pop
#line 73 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static int transform_flags  =    7;
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static struct transform *transform_head  ;
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static struct transform *transform_tail  ;
#line 76 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static struct transform *new_transform(void) 
{ 
  struct transform *p ;
  void *tmp ;

  {
  {
#line 79
  tmp = xzalloc(sizeof(*p));
#line 79
  p = (struct transform *)tmp;
  }
#line 80
  if (transform_tail) {
#line 81
    transform_tail->next = p;
  } else {
#line 83
    transform_head = p;
  }
#line 84
  transform_tail = p;
#line 85
  return (p);
}
}
#line 88 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static struct replace_segm *add_segment(struct transform *tf ) 
{ 
  struct replace_segm *segm ;
  void *tmp ;

  {
  {
#line 91
  tmp = xmalloc(sizeof(*segm));
#line 91
  segm = (struct replace_segm *)tmp;
#line 92
  segm->next = (struct replace_segm *)((void *)0);
  }
#line 93
  if (tf->repl_tail) {
#line 94
    (tf->repl_tail)->next = segm;
  } else {
#line 96
    tf->repl_head = segm;
  }
#line 97
  tf->repl_tail = segm;
#line 98
  (tf->segm_count) ++;
#line 99
  return (segm);
}
}
#line 102 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static void add_literal_segment(struct transform *tf , char *str , char *end ) 
{ 
  size_t len ;
  struct replace_segm *segm ;
  struct replace_segm *tmp ;
  void *tmp___0 ;

  {
#line 105
  len = (size_t )(end - str);
#line 106
  if (len) {
    {
#line 108
    tmp = add_segment(tf);
#line 108
    segm = tmp;
#line 109
    segm->type = (enum replace_segm_type )0;
#line 110
    tmp___0 = xmalloc(len + 1UL);
#line 110
    segm->v.literal.ptr = (char *)tmp___0;
#line 111
    memcpy((void */* __restrict  */)segm->v.literal.ptr, (void const   */* __restrict  */)str,
           len);
#line 112
    *(segm->v.literal.ptr + len) = (char)0;
#line 113
    segm->v.literal.size = len;
    }
  }
#line 115
  return;
}
}
#line 117 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static void add_char_segment(struct transform *tf , int chr ) 
{ 
  struct replace_segm *segm ;
  struct replace_segm *tmp ;
  void *tmp___0 ;

  {
  {
#line 120
  tmp = add_segment(tf);
#line 120
  segm = tmp;
#line 121
  segm->type = (enum replace_segm_type )0;
#line 122
  tmp___0 = xmalloc((size_t )2);
#line 122
  segm->v.literal.ptr = (char *)tmp___0;
#line 123
  *(segm->v.literal.ptr + 0) = (char )chr;
#line 124
  *(segm->v.literal.ptr + 1) = (char)0;
#line 125
  segm->v.literal.size = (size_t )1;
  }
#line 126
  return;
}
}
#line 128 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static void add_backref_segment(struct transform *tf , size_t ref ) 
{ 
  struct replace_segm *segm ;
  struct replace_segm *tmp ;

  {
  {
#line 131
  tmp = add_segment(tf);
#line 131
  segm = tmp;
#line 132
  segm->type = (enum replace_segm_type )1;
#line 133
  segm->v.ref = ref;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static int parse_xform_flags(int *pflags , int c ) 
{ 


  {
  {
#line 141
  if (c == 114) {
#line 141
    goto case_114;
  }
#line 145
  if (c == 82) {
#line 145
    goto case_82;
  }
#line 149
  if (c == 104) {
#line 149
    goto case_104;
  }
#line 153
  if (c == 72) {
#line 153
    goto case_72;
  }
#line 157
  if (c == 115) {
#line 157
    goto case_115;
  }
#line 161
  if (c == 83) {
#line 161
    goto case_83;
  }
#line 165
  goto switch_default;
  case_114: /* CIL Label */ 
#line 142
  *pflags |= 1;
#line 143
  goto switch_break;
  case_82: /* CIL Label */ 
#line 146
  *pflags &= -2;
#line 147
  goto switch_break;
  case_104: /* CIL Label */ 
#line 150
  *pflags |= 2;
#line 151
  goto switch_break;
  case_72: /* CIL Label */ 
#line 154
  *pflags &= -3;
#line 155
  goto switch_break;
  case_115: /* CIL Label */ 
#line 158
  *pflags |= 4;
#line 159
  goto switch_break;
  case_83: /* CIL Label */ 
#line 162
  *pflags &= -5;
#line 163
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 166
  return (1);
  switch_break: /* CIL Label */ ;
  }
#line 168
  return (0);
}
}
#line 171 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static void add_case_ctl_segment(struct transform *tf , enum case_ctl_type ctl ) 
{ 
  struct replace_segm *segm ;
  struct replace_segm *tmp ;

  {
  {
#line 174
  tmp = add_segment(tf);
#line 174
  segm = tmp;
#line 175
  segm->type = (enum replace_segm_type )2;
#line 176
  segm->v.ctl = ctl;
  }
#line 177
  return;
}
}
#line 179 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static char const   *parse_transform_expr(char const   *expr ) 
{ 
  int delim ;
  int i ;
  int j ;
  int rc ;
  char *str ;
  char *beg ;
  char *cur ;
  char const   *p ;
  int cflags ;
  struct transform *tf ;
  struct transform *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char errbuf[512] ;
  char *tmp___10 ;
  size_t tmp___11 ;
  void *tmp___12 ;
  size_t n ;
  char *tmp___13 ;
  char buf[2] ;

  {
  {
#line 186
  cflags = 0;
#line 187
  tmp = new_transform();
#line 187
  tf = tmp;
  }
#line 189
  if ((int const   )*(expr + 0) != 115) {
    {
#line 191
    tmp___2 = strncmp(expr, "flags=", (size_t )6);
    }
#line 191
    if (tmp___2 == 0) {
#line 193
      transform_flags = 0;
#line 194
      expr += 6;
      {
#line 194
      while (1) {
        while_continue: /* CIL Label */ ;
#line 194
        if (! *expr) {
#line 194
          goto while_break;
        }
#line 196
        if ((int const   )*expr == 59) {
#line 198
          expr ++;
#line 199
          goto while_break;
        }
        {
#line 201
        tmp___1 = parse_xform_flags(& transform_flags, (int )*expr);
        }
#line 201
        if (tmp___1) {
          {
#line 202
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 202
            if (error_hook) {
              {
#line 202
              (*error_hook)();
              }
            }
            {
#line 202
            tmp___0 = gettext("Unknown transform flag: %c");
#line 202
            error(0, 0, (char const   *)tmp___0, (int const   )*expr);
#line 202
            usage(2);
            }
#line 202
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 194
        expr ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 205
      return (expr);
    }
    {
#line 207
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 207
      if (error_hook) {
        {
#line 207
        (*error_hook)();
        }
      }
      {
#line 207
      tmp___3 = gettext("Invalid transform expression");
#line 207
      error(0, 0, (char const   *)tmp___3);
#line 207
      usage(2);
      }
#line 207
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 210
  delim = (int )*(expr + 1);
#line 213
  i = 2;
  {
#line 213
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 213
    if (*(expr + i)) {
#line 213
      if (! ((int const   )*(expr + i) != (int const   )delim)) {
#line 213
        goto while_break___2;
      }
    } else {
#line 213
      goto while_break___2;
    }
#line 214
    if ((int const   )*(expr + i) == 92) {
#line 214
      if (*(expr + (i + 1))) {
#line 215
        i ++;
      }
    }
#line 213
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 217
  if ((int const   )*(expr + i) != (int const   )delim) {
    {
#line 218
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 218
      if (error_hook) {
        {
#line 218
        (*error_hook)();
        }
      }
      {
#line 218
      tmp___4 = gettext("Invalid transform expression");
#line 218
      error(0, 0, (char const   *)tmp___4);
#line 218
      usage(2);
      }
#line 218
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 221
  j = i + 1;
  {
#line 221
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 221
    if (*(expr + j)) {
#line 221
      if (! ((int const   )*(expr + j) != (int const   )delim)) {
#line 221
        goto while_break___4;
      }
    } else {
#line 221
      goto while_break___4;
    }
#line 222
    if ((int const   )*(expr + j) == 92) {
#line 222
      if (*(expr + (j + 1))) {
#line 223
        j ++;
      }
    }
#line 221
    j ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 225
  if ((int const   )*(expr + j) != (int const   )delim) {
    {
#line 226
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 226
      if (error_hook) {
        {
#line 226
        (*error_hook)();
        }
      }
      {
#line 226
      tmp___5 = gettext("Invalid transform expression");
#line 226
      error(0, 0, (char const   *)tmp___5);
#line 226
      usage(2);
      }
#line 226
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
#line 229
  tf->transform_type = (enum transform_type )0;
#line 230
  tf->flags = transform_flags;
#line 231
  p = (expr + j) + 1;
  {
#line 231
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 231
    if (*p) {
#line 231
      if (! ((int const   )*p != 59)) {
#line 231
        goto while_break___6;
      }
    } else {
#line 231
      goto while_break___6;
    }
    {
#line 234
    if ((int const   )*p == 103) {
#line 234
      goto case_103;
    }
#line 238
    if ((int const   )*p == 105) {
#line 238
      goto case_105;
    }
#line 242
    if ((int const   )*p == 120) {
#line 242
      goto case_120;
    }
#line 247
    if ((int const   )*p == 57) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 56) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 55) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 54) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 53) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 52) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 51) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 50) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 49) {
#line 247
      goto case_57;
    }
#line 247
    if ((int const   )*p == 48) {
#line 247
      goto case_57;
    }
#line 252
    goto switch_default;
    case_103: /* CIL Label */ 
#line 235
    tf->transform_type = (enum transform_type )1;
#line 236
    goto switch_break;
    case_105: /* CIL Label */ 
#line 239
    cflags |= 1 << 1;
#line 240
    goto switch_break;
    case_120: /* CIL Label */ 
#line 243
    cflags |= 1;
#line 244
    goto switch_break;
    case_57: /* CIL Label */ 
    case_56: /* CIL Label */ 
    case_55: /* CIL Label */ 
    case_54: /* CIL Label */ 
    case_53: /* CIL Label */ 
    case_52: /* CIL Label */ 
    case_51: /* CIL Label */ 
    case_50: /* CIL Label */ 
    case_49: /* CIL Label */ 
    case_48: /* CIL Label */ 
    {
#line 248
    tmp___6 = strtoul((char const   */* __restrict  */)p, (char **/* __restrict  */)((char **)(& p)),
                      0);
#line 248
    tf->match_number = (unsigned int )tmp___6;
#line 249
    p --;
    }
#line 250
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 253
    tmp___8 = parse_xform_flags(& tf->flags, (int )*p);
    }
#line 253
    if (tmp___8) {
      {
#line 254
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 254
        if (error_hook) {
          {
#line 254
          (*error_hook)();
          }
        }
        {
#line 254
        tmp___7 = gettext("Unknown flag in transform expression: %c");
#line 254
        error(0, 0, (char const   *)tmp___7, (int const   )*p);
#line 254
        usage(2);
        }
#line 254
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 231
    p ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 258
  if ((int const   )*p == 59) {
#line 259
    p ++;
  }
  {
#line 262
  tmp___9 = xmalloc((size_t )(i - 1));
#line 262
  str = (char *)tmp___9;
#line 263
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(expr + 2),
         (size_t )(i - 2));
#line 264
  *(str + (i - 2)) = (char)0;
#line 266
  rc = regcomp((regex_t */* __restrict  */)(& tf->regex), (char const   */* __restrict  */)str,
               cflags);
  }
#line 268
  if (rc) {
    {
#line 271
    regerror(rc, (regex_t const   */* __restrict  */)(& tf->regex), (char */* __restrict  */)(errbuf),
             sizeof(errbuf));
    }
    {
#line 272
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 272
      if (error_hook) {
        {
#line 272
        (*error_hook)();
        }
      }
      {
#line 272
      tmp___10 = gettext("Invalid transform expression: %s");
#line 272
      error(0, 0, (char const   *)tmp___10, errbuf);
#line 272
      usage(2);
      }
#line 272
      goto while_break___8;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 275
  if ((int )*(str + 0) == 94) {
#line 276
    tf->transform_type = (enum transform_type )0;
  } else {
    {
#line 275
    tmp___11 = strlen((char const   *)str);
    }
#line 275
    if ((int )*(str + (tmp___11 - 1UL)) == 36) {
#line 276
      tf->transform_type = (enum transform_type )0;
    }
  }
  {
#line 278
  free((void *)str);
#line 281
  i ++;
#line 282
  tmp___12 = xmalloc((size_t )((j - i) + 1));
#line 282
  str = (char *)tmp___12;
#line 283
  memcpy((void */* __restrict  */)str, (void const   */* __restrict  */)(expr + i),
         (size_t )(j - i));
#line 284
  *(str + (j - i)) = (char)0;
#line 286
  beg = str;
#line 286
  cur = beg;
  }
  {
#line 286
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 286
    if (! *cur) {
#line 286
      goto while_break___9;
    }
#line 288
    if ((int )*cur == 92) {
      {
#line 292
      add_literal_segment(tf, beg, cur);
#line 293
      cur ++;
      }
      {
#line 296
      if ((int )*cur == 57) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 56) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 55) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 54) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 53) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 52) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 51) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 50) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 49) {
#line 296
        goto case_57___0;
      }
#line 296
      if ((int )*cur == 48) {
#line 296
        goto case_57___0;
      }
#line 303
      if ((int )*cur == 92) {
#line 303
        goto case_92;
      }
#line 308
      if ((int )*cur == 97) {
#line 308
        goto case_97;
      }
#line 313
      if ((int )*cur == 98) {
#line 313
        goto case_98;
      }
#line 318
      if ((int )*cur == 102) {
#line 318
        goto case_102;
      }
#line 323
      if ((int )*cur == 110) {
#line 323
        goto case_110;
      }
#line 328
      if ((int )*cur == 114) {
#line 328
        goto case_114;
      }
#line 333
      if ((int )*cur == 116) {
#line 333
        goto case_116;
      }
#line 338
      if ((int )*cur == 118) {
#line 338
        goto case_118;
      }
#line 343
      if ((int )*cur == 38) {
#line 343
        goto case_38;
      }
#line 348
      if ((int )*cur == 76) {
#line 348
        goto case_76;
      }
#line 355
      if ((int )*cur == 108) {
#line 355
        goto case_108;
      }
#line 361
      if ((int )*cur == 85) {
#line 361
        goto case_85;
      }
#line 368
      if ((int )*cur == 117) {
#line 368
        goto case_117;
      }
#line 374
      if ((int )*cur == 69) {
#line 374
        goto case_69;
      }
#line 380
      goto switch_default___0;
      case_57___0: /* CIL Label */ 
      case_56___0: /* CIL Label */ 
      case_55___0: /* CIL Label */ 
      case_54___0: /* CIL Label */ 
      case_53___0: /* CIL Label */ 
      case_52___0: /* CIL Label */ 
      case_51___0: /* CIL Label */ 
      case_50___0: /* CIL Label */ 
      case_49___0: /* CIL Label */ 
      case_48___0: /* CIL Label */ 
      {
#line 297
      n = strtoul((char const   */* __restrict  */)cur, (char **/* __restrict  */)(& cur),
                  10);
      }
#line 298
      if (n > tf->regex.re_nsub) {
        {
#line 299
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 299
          if (error_hook) {
            {
#line 299
            (*error_hook)();
            }
          }
          {
#line 299
          tmp___13 = gettext("Invalid transform replacement: back reference out of range");
#line 299
          error(0, 0, (char const   *)tmp___13);
#line 299
          usage(2);
          }
#line 299
          goto while_break___10;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
      {
#line 300
      add_backref_segment(tf, n);
      }
#line 301
      goto switch_break___0;
      case_92: /* CIL Label */ 
      {
#line 304
      add_char_segment(tf, '\\');
#line 305
      cur ++;
      }
#line 306
      goto switch_break___0;
      case_97: /* CIL Label */ 
      {
#line 309
      add_char_segment(tf, '\a');
#line 310
      cur ++;
      }
#line 311
      goto switch_break___0;
      case_98: /* CIL Label */ 
      {
#line 314
      add_char_segment(tf, '\b');
#line 315
      cur ++;
      }
#line 316
      goto switch_break___0;
      case_102: /* CIL Label */ 
      {
#line 319
      add_char_segment(tf, '\f');
#line 320
      cur ++;
      }
#line 321
      goto switch_break___0;
      case_110: /* CIL Label */ 
      {
#line 324
      add_char_segment(tf, '\n');
#line 325
      cur ++;
      }
#line 326
      goto switch_break___0;
      case_114: /* CIL Label */ 
      {
#line 329
      add_char_segment(tf, '\r');
#line 330
      cur ++;
      }
#line 331
      goto switch_break___0;
      case_116: /* CIL Label */ 
      {
#line 334
      add_char_segment(tf, '\t');
#line 335
      cur ++;
      }
#line 336
      goto switch_break___0;
      case_118: /* CIL Label */ 
      {
#line 339
      add_char_segment(tf, '\v');
#line 340
      cur ++;
      }
#line 341
      goto switch_break___0;
      case_38: /* CIL Label */ 
      {
#line 344
      add_char_segment(tf, '&');
#line 345
      cur ++;
      }
#line 346
      goto switch_break___0;
      case_76: /* CIL Label */ 
      {
#line 351
      add_case_ctl_segment(tf, (enum case_ctl_type )4);
#line 352
      cur ++;
      }
#line 353
      goto switch_break___0;
      case_108: /* CIL Label */ 
      {
#line 357
      add_case_ctl_segment(tf, (enum case_ctl_type )2);
#line 358
      cur ++;
      }
#line 359
      goto switch_break___0;
      case_85: /* CIL Label */ 
      {
#line 364
      add_case_ctl_segment(tf, (enum case_ctl_type )3);
#line 365
      cur ++;
      }
#line 366
      goto switch_break___0;
      case_117: /* CIL Label */ 
      {
#line 370
      add_case_ctl_segment(tf, (enum case_ctl_type )1);
#line 371
      cur ++;
      }
#line 372
      goto switch_break___0;
      case_69: /* CIL Label */ 
      {
#line 376
      add_case_ctl_segment(tf, (enum case_ctl_type )0);
#line 377
      cur ++;
      }
#line 378
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 381
      if ((int )*cur == delim) {
        {
#line 382
        add_char_segment(tf, delim);
        }
      } else {
        {
#line 386
        buf[0] = (char )'\\';
#line 387
        buf[1] = *cur;
#line 388
        add_literal_segment(tf, buf, buf + 2);
        }
      }
#line 390
      cur ++;
#line 391
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 393
      beg = cur;
    } else
#line 395
    if ((int )*cur == 38) {
      {
#line 397
      add_literal_segment(tf, beg, cur);
#line 398
      add_backref_segment(tf, (size_t )0);
#line 399
      cur ++;
#line 399
      beg = cur;
      }
    } else {
#line 402
      cur ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 404
  add_literal_segment(tf, beg, cur);
  }
#line 406
  return (p);
}
}
#line 409 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
void set_transform_expr(char const   *expr ) 
{ 


  {
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! *expr) {
#line 412
      goto while_break;
    }
    {
#line 413
    expr = parse_transform_expr(expr);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 414
  return;
}
}
#line 421 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static char *case_ctl_buffer  ;
#line 422 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static size_t case_ctl_bufsize  ;
#line 418 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static char *run_case_conv(enum case_ctl_type case_ctl , char *ptr , size_t size ) 
{ 
  char *p ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 425
  if (case_ctl_bufsize < size) {
    {
#line 427
    case_ctl_bufsize = size;
#line 428
    tmp = xrealloc((void *)case_ctl_buffer, case_ctl_bufsize);
#line 428
    case_ctl_buffer = (char *)tmp;
    }
  }
  {
#line 430
  memcpy((void */* __restrict  */)case_ctl_buffer, (void const   */* __restrict  */)ptr,
         size);
  }
  {
#line 433
  if ((unsigned int )case_ctl == 1U) {
#line 433
    goto case_1;
  }
#line 437
  if ((unsigned int )case_ctl == 2U) {
#line 437
    goto case_2;
  }
#line 441
  if ((unsigned int )case_ctl == 3U) {
#line 441
    goto case_3;
  }
#line 446
  if ((unsigned int )case_ctl == 4U) {
#line 446
    goto case_4;
  }
#line 451
  if ((unsigned int )case_ctl == 0U) {
#line 451
    goto case_0;
  }
#line 431
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 434
  tmp___0 = toupper((int )((unsigned char )*(case_ctl_buffer + 0)));
#line 434
  *(case_ctl_buffer + 0) = (char )tmp___0;
  }
#line 435
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 438
  tmp___1 = tolower((int )((unsigned char )*(case_ctl_buffer + 0)));
#line 438
  *(case_ctl_buffer + 0) = (char )tmp___1;
  }
#line 439
  goto switch_break;
  case_3: /* CIL Label */ 
#line 442
  p = case_ctl_buffer;
  {
#line 442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 442
    if (! ((unsigned long )p < (unsigned long )(case_ctl_buffer + size))) {
#line 442
      goto while_break;
    }
    {
#line 443
    tmp___2 = toupper((int )((unsigned char )*p));
#line 443
    *p = (char )tmp___2;
#line 442
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 444
  goto switch_break;
  case_4: /* CIL Label */ 
#line 447
  p = case_ctl_buffer;
  {
#line 447
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 447
    if (! ((unsigned long )p < (unsigned long )(case_ctl_buffer + size))) {
#line 447
      goto while_break___0;
    }
    {
#line 448
    tmp___3 = tolower((int )((unsigned char )*p));
#line 448
    *p = (char )tmp___3;
#line 447
    p ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 449
  goto switch_break;
  case_0: /* CIL Label */ 
#line 452
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 454
  return (case_ctl_buffer);
}
}
#line 458 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static struct obstack stk  ;
#line 459 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static _Bool stk_init  ;
#line 461 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static void _single_transform_name_to_obstack(struct transform *tf , char *input ) 
{ 
  regmatch_t *rmp ;
  int rc ;
  size_t nmatches ;
  enum case_ctl_type case_ctl ;
  enum case_ctl_type save_ctl ;
  void *tmp ;
  size_t disp ;
  char *ptr ;
  struct replace_segm *segm ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___0 ;
  struct obstack *__o___1 ;
  size_t __len___1 ;
  struct obstack  const  *__o1___1 ;
  size_t size ;
  struct obstack *__o___2 ;
  size_t __len___2 ;
  struct obstack  const  *__o1___2 ;
  struct obstack *__o___3 ;
  size_t __len___3 ;
  struct obstack  const  *__o1___3 ;
  struct obstack *__o___4 ;
  size_t __len___4 ;
  size_t tmp___0 ;
  struct obstack  const  *__o1___4 ;
  struct obstack *__o___5 ;
  struct obstack  const  *__o1___5 ;
  char *tmp___1 ;

  {
  {
#line 466
  nmatches = (size_t )0;
#line 467
  case_ctl = (enum case_ctl_type )0;
#line 467
  save_ctl = (enum case_ctl_type )0;
#line 478
  tmp = xmalloc((tf->regex.re_nsub + 1UL) * sizeof(*rmp));
#line 478
  rmp = (regmatch_t *)tmp;
  }
  {
#line 480
  while (1) {
    while_continue: /* CIL Label */ ;
#line 480
    if (! *input) {
#line 480
      goto while_break;
    }
    {
#line 485
    rc = regexec((regex_t const   */* __restrict  */)(& tf->regex), (char const   */* __restrict  */)input,
                 tf->regex.re_nsub + 1UL, (regmatch_t */* __restrict  */)rmp, 0);
    }
#line 487
    if (rc == 0) {
#line 491
      disp = (size_t )(rmp + 0)->rm_eo;
#line 493
      if ((rmp + 0)->rm_so) {
#line 494
        __o = & stk;
#line 494
        __len = (size_t )(rmp + 0)->rm_so;
#line 494
        __o1 = (struct obstack  const  *)__o;
#line 494
        if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
          {
#line 494
          _obstack_newchunk(__o, __len);
          }
        }
        {
#line 494
        memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)input,
               __len);
#line 494
        __o->next_free += __len;
        }
      }
#line 496
      nmatches ++;
#line 497
      if (tf->match_number) {
#line 497
        if (nmatches < (size_t )tf->match_number) {
#line 499
          __o___0 = & stk;
#line 499
          __len___0 = disp;
#line 499
          __o1___0 = (struct obstack  const  *)__o___0;
#line 499
          if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len___0) {
            {
#line 499
            _obstack_newchunk(__o___0, __len___0);
            }
          }
          {
#line 499
          memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)input,
                 __len___0);
#line 499
          __o___0->next_free += __len___0;
#line 500
          input += disp;
          }
#line 501
          goto while_continue;
        }
      }
#line 504
      segm = tf->repl_head;
      {
#line 504
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 504
        if (! segm) {
#line 504
          goto while_break___0;
        }
        {
#line 508
        if ((unsigned int )segm->type == 0U) {
#line 508
          goto case_0;
        }
#line 521
        if ((unsigned int )segm->type == 1U) {
#line 521
          goto case_1;
        }
#line 538
        if ((unsigned int )segm->type == 2U) {
#line 538
          goto case_2;
        }
#line 506
        goto switch_break;
        case_0: /* CIL Label */ 
#line 509
        if ((unsigned int )case_ctl == 0U) {
#line 510
          ptr = segm->v.literal.ptr;
        } else {
          {
#line 513
          ptr = run_case_conv(case_ctl, segm->v.literal.ptr, segm->v.literal.size);
          }
#line 516
          if ((unsigned int )case_ctl == 1U) {
#line 516
            case_ctl = save_ctl;
#line 516
            save_ctl = (enum case_ctl_type )0;
          } else
#line 516
          if ((unsigned int )case_ctl == 2U) {
#line 516
            case_ctl = save_ctl;
#line 516
            save_ctl = (enum case_ctl_type )0;
          }
        }
#line 518
        __o___1 = & stk;
#line 518
        __len___1 = segm->v.literal.size;
#line 518
        __o1___1 = (struct obstack  const  *)__o___1;
#line 518
        if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___1) {
          {
#line 518
          _obstack_newchunk(__o___1, __len___1);
          }
        }
        {
#line 518
        memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)ptr,
               __len___1);
#line 518
        __o___1->next_free += __len___1;
        }
#line 519
        goto switch_break;
        case_1: /* CIL Label */ 
#line 522
        if ((rmp + segm->v.ref)->rm_so != -1) {
#line 522
          if ((rmp + segm->v.ref)->rm_eo != -1) {
#line 525
            size = (size_t )((rmp + segm->v.ref)->rm_eo - (rmp + segm->v.ref)->rm_so);
#line 527
            ptr = input + (rmp + segm->v.ref)->rm_so;
#line 528
            if ((unsigned int )case_ctl != 0U) {
              {
#line 530
              ptr = run_case_conv(case_ctl, ptr, size);
              }
#line 531
              if ((unsigned int )case_ctl == 1U) {
#line 531
                case_ctl = save_ctl;
#line 531
                save_ctl = (enum case_ctl_type )0;
              } else
#line 531
              if ((unsigned int )case_ctl == 2U) {
#line 531
                case_ctl = save_ctl;
#line 531
                save_ctl = (enum case_ctl_type )0;
              }
            }
#line 534
            __o___2 = & stk;
#line 534
            __len___2 = size;
#line 534
            __o1___2 = (struct obstack  const  *)__o___2;
#line 534
            if ((size_t )(__o1___2->chunk_limit - __o1___2->next_free) < __len___2) {
              {
#line 534
              _obstack_newchunk(__o___2, __len___2);
              }
            }
            {
#line 534
            memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)ptr,
                   __len___2);
#line 534
            __o___2->next_free += __len___2;
            }
          }
        }
#line 536
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 542
        if ((unsigned int )segm->v.ctl == 2U) {
#line 542
          goto case_2___0;
        }
#line 542
        if ((unsigned int )segm->v.ctl == 1U) {
#line 542
          goto case_2___0;
        }
#line 556
        if ((unsigned int )segm->v.ctl == 0U) {
#line 556
          goto case_0___1;
        }
#line 556
        if ((unsigned int )segm->v.ctl == 4U) {
#line 556
          goto case_0___1;
        }
#line 556
        if ((unsigned int )segm->v.ctl == 3U) {
#line 556
          goto case_0___1;
        }
#line 539
        goto switch_break___0;
        case_2___0: /* CIL Label */ 
        case_1___0: /* CIL Label */ 
        {
#line 547
        if ((unsigned int )save_ctl == 4U) {
#line 547
          goto case_4;
        }
#line 547
        if ((unsigned int )save_ctl == 3U) {
#line 547
          goto case_4;
        }
#line 547
        if ((unsigned int )save_ctl == 0U) {
#line 547
          goto case_4;
        }
#line 549
        goto switch_default;
        case_4: /* CIL Label */ 
        case_3: /* CIL Label */ 
        case_0___0: /* CIL Label */ 
#line 548
        save_ctl = case_ctl;
        switch_default: /* CIL Label */ 
#line 550
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
        case_0___1: /* CIL Label */ 
        case_4___0: /* CIL Label */ 
        case_3___0: /* CIL Label */ 
#line 557
        case_ctl = segm->v.ctl;
        switch_break___0: /* CIL Label */ ;
        }
        switch_break: /* CIL Label */ ;
        }
#line 504
        segm = segm->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 564
      disp = strlen((char const   *)input);
#line 565
      __o___3 = & stk;
#line 565
      __len___3 = disp;
#line 565
      __o1___3 = (struct obstack  const  *)__o___3;
      }
#line 565
      if ((size_t )(__o1___3->chunk_limit - __o1___3->next_free) < __len___3) {
        {
#line 565
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 565
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)input,
             __len___3);
#line 565
      __o___3->next_free += __len___3;
      }
    }
#line 568
    input += disp;
#line 570
    if ((unsigned int )tf->transform_type == 0U) {
      {
#line 572
      __o___4 = & stk;
#line 572
      tmp___0 = strlen((char const   *)input);
#line 572
      __len___4 = tmp___0;
#line 572
      __o1___4 = (struct obstack  const  *)__o___4;
      }
#line 572
      if ((size_t )(__o1___4->chunk_limit - __o1___4->next_free) < __len___4) {
        {
#line 572
        _obstack_newchunk(__o___4, __len___4);
        }
      }
      {
#line 572
      memcpy((void */* __restrict  */)__o___4->next_free, (void const   */* __restrict  */)input,
             __len___4);
#line 572
      __o___4->next_free += __len___4;
      }
#line 573
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  __o___5 = & stk;
#line 577
  __o1___5 = (struct obstack  const  *)__o___5;
#line 577
  if ((size_t )(__o1___5->chunk_limit - __o1___5->next_free) < 1UL) {
    {
#line 577
    _obstack_newchunk(__o___5, (size_t )1);
    }
  }
  {
#line 577
  tmp___1 = __o___5->next_free;
#line 577
  (__o___5->next_free) ++;
#line 577
  *tmp___1 = (char)0;
#line 578
  free((void *)rmp);
  }
#line 579
  return;
}
}
#line 581 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
static _Bool _transform_name_to_obstack(int flags , char *input , char **output ) 
{ 
  struct transform *tf ;
  _Bool alloced ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 585
  alloced = (_Bool)0;
#line 587
  if (! stk_init) {
    {
#line 589
    _obstack_begin(& stk, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
#line 590
    stk_init = (_Bool)1;
    }
  }
#line 593
  tf = transform_head;
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! tf) {
#line 593
      goto while_break;
    }
#line 595
    if (tf->flags & flags) {
      {
#line 597
      _single_transform_name_to_obstack(tf, input);
#line 598
      __o1 = & stk;
#line 598
      __value = (void *)__o1->object_base;
      }
#line 598
      if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 598
        __o1->maybe_empty_object = 1U;
      }
#line 598
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 598
        tmp = __o1->object_base;
      } else {
#line 598
        tmp = (char *)0;
      }
#line 598
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 598
        tmp___0 = __o1->object_base;
      } else {
#line 598
        tmp___0 = (char *)0;
      }
#line 598
      __o1->next_free = tmp + (((size_t )(__o1->next_free - tmp___0) + __o1->alignment_mask) & ~ __o1->alignment_mask);
#line 598
      if ((size_t )(__o1->next_free - (char *)__o1->chunk) > (size_t )(__o1->chunk_limit - (char *)__o1->chunk)) {
#line 598
        __o1->next_free = __o1->chunk_limit;
      }
#line 598
      __o1->object_base = __o1->next_free;
#line 598
      input = (char *)__value;
#line 599
      alloced = (_Bool)1;
    }
#line 593
    tf = tf->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 602
  *output = input;
#line 603
  return (alloced);
}
}
#line 606 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
_Bool transform_name_fp(char **pinput , int flags , char *(*fun)(char * , void * ) ,
                        void *dat ) 
{ 
  char *str ;
  _Bool ret ;
  _Bool tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 611
  tmp = _transform_name_to_obstack(flags, *pinput, & str);
#line 611
  ret = tmp;
  }
#line 612
  if (ret) {
#line 614
    if (fun) {
      {
#line 614
      tmp___0 = (*fun)(str, dat);
#line 614
      tmp___1 = tmp___0;
      }
    } else {
#line 614
      tmp___1 = str;
    }
    {
#line 614
    assign_string(pinput, (char const   *)tmp___1);
#line 615
    __o = & stk;
#line 615
    __obj = (void *)str;
    }
#line 615
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 615
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 615
        tmp___2 = (char *)__obj;
#line 615
        __o->object_base = tmp___2;
#line 615
        __o->next_free = tmp___2;
      } else {
        {
#line 615
        _obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 615
      _obstack_free(__o, __obj);
      }
    }
  } else
#line 617
  if (fun) {
    {
#line 619
    *pinput = (char *)((void *)0);
#line 620
    tmp___3 = (*fun)(str, dat);
#line 620
    assign_string(pinput, (char const   *)tmp___3);
#line 621
    free((void *)str);
#line 622
    ret = (_Bool)1;
    }
  }
#line 624
  return (ret);
}
}
#line 627 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
_Bool transform_name(char **pinput , int type ) 
{ 
  _Bool tmp ;

  {
  {
#line 630
  tmp = transform_name_fp(pinput, type, (char *(*)(char * , void * ))((void *)0),
                          (void *)0);
  }
#line 630
  return (tmp);
}
}
#line 633 "/home/khheo/project/benchmark/tar-1.29/src/transform.c"
_Bool transform_program_p(void) 
{ 


  {
#line 636
  return ((_Bool )((unsigned long )transform_head != (unsigned long )((void *)0)));
}
}
#line 308 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 943 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *response ) ;
#line 213 "/usr/include/stdio.h"
extern int fflush_unlocked(FILE *__stream ) ;
#line 122 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 585 "../gnu/argp.h"
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 203 "../gnu/argp-fmtstream.h"
#pragma GCC diagnostic push
#line 203
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 203
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 355
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 97 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum subcommand subcommand_option  ;
#line 100 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum archive_format archive_format  ;
#line 106 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int blocking_factor  ;
#line 107 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
size_t record_size  ;
#line 109 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool absolute_names_option  ;
#line 112 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool utc_option  ;
#line 114 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool full_time_option  ;
#line 120 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int after_date_option  ;
#line 128 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum atime_preserve atime_preserve_option  ;
#line 130 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool backup_option  ;
#line 133 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum backup_type backup_type  ;
#line 135 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool block_number_option  ;
#line 137 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
unsigned int checkpoint_option  ;
#line 141 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *use_compress_program_option  ;
#line 143 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool dereference_option  ;
#line 144 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool hard_dereference_option  ;
#line 147 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct exclude *excluded  ;
#line 164 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *group_name_option  ;
#line 165 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
gid_t group_option  ;
#line 167 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool ignore_failed_read_option  ;
#line 169 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool ignore_zeros_option  ;
#line 171 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool incremental_option  ;
#line 174 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *info_script_option  ;
#line 176 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool interactive_option  ;
#line 179 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
uintmax_t occurrence_option  ;
#line 191 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum old_files old_files_option  ;
#line 193 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool keep_directory_symlink_option  ;
#line 196 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *listed_incremental_option  ;
#line 198 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int incremental_level  ;
#line 200 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool check_device_option  ;
#line 203 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct mode_change *mode_option  ;
#line 206 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
mode_t initial_umask  ;
#line 208 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool multi_volume_option  ;
#line 212 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct timespec newer_mtime_option  ;
#line 222 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum set_mtime_option_mode set_mtime_option  ;
#line 224 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct timespec mtime_option  ;
#line 239 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int recursion_option  ;
#line 241 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool numeric_owner_option  ;
#line 243 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool one_file_system_option  ;
#line 246 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool one_top_level_option  ;
#line 247 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char *one_top_level_dir  ;
#line 251 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *owner_name_option  ;
#line 252 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
uid_t owner_option  ;
#line 254 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool recursive_unlink_option  ;
#line 256 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool read_full_records_option  ;
#line 258 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool remove_files_option  ;
#line 261 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *rsh_command_option  ;
#line 263 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool same_order_option  ;
#line 266 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int same_owner_option  ;
#line 269 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int same_permissions_option  ;
#line 272 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int selinux_context_option  ;
#line 275 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int acls_option  ;
#line 278 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int xattrs_option  ;
#line 282 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
size_t strip_name_components  ;
#line 284 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool show_omitted_dirs_option  ;
#line 286 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool sparse_option  ;
#line 287 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
unsigned int tar_sparse_major  ;
#line 288 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
unsigned int tar_sparse_minor  ;
#line 297 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum hole_detection_method hole_detection  ;
#line 299 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool starting_file_option  ;
#line 302 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
tarlong tape_length_option  ;
#line 304 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool to_stdout_option  ;
#line 306 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool totals_option  ;
#line 308 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool touch_option  ;
#line 310 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char *to_command_option  ;
#line 311 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool ignore_command_error_option  ;
#line 314 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool restrict_option  ;
#line 322 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int verbose_option  ;
#line 324 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool verify_option  ;
#line 327 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *volno_file_option  ;
#line 330 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *volume_label_option  ;
#line 335 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int archive  ;
#line 338 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool dev_null_output  ;
#line 341 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct timespec start_time  ;
#line 342 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct timespec volume_start_time  ;
#line 344 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct timespec last_stat_time  ;
#line 347 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct tar_stat_info current_stat_info  ;
#line 351 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   **archive_name_array  ;
#line 352 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
size_t archive_names  ;
#line 353 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   **archive_name_cursor  ;
#line 356 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char const   *index_file_name  ;
#line 389 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
dev_t ar_dev  ;
#line 390 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
ino_t ar_ino  ;
#line 393 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int open_read_flags  ;
#line 394 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int open_searchdir_flags  ;
#line 395 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int fstatat_flags  ;
#line 397 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int seek_option  ;
#line 398 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool seekable_archive  ;
#line 400 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
dev_t root_device  ;
#line 403 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool unquote_option  ;
#line 405 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int savedir_sort_order  ;
#line 410 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool show_transformed_names_option  ;
#line 416 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool delay_directory_restore_option  ;
#line 419 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool files_from_option  ;
#line 450
void closeout_volume_number(void) ;
#line 451
double compute_duration(void) ;
#line 456
void init_volume_number(void) ;
#line 458
void print_total_stats(void) ;
#line 466
void set_start_time(void) ;
#line 500
void create_archive(void) ;
#line 512
void check_links(void) ;
#line 530
void diff_archive(void) ;
#line 531
void diff_init(void) ;
#line 536
void extr_init(void) ;
#line 537
void extract_archive(void) ;
#line 538
void extract_finish(void) ;
#line 545
void delete_archive_members(void) ;
#line 558
void show_snapshot_field_ranges(void) ;
#line 600
char const   *tartime(struct timespec t , _Bool full_time ) ;
#line 608
void list_archive(void) ;
#line 609
void test_archive_label(void) ;
#line 613
void read_and(void (*do_something)(void) ) ;
#line 665
char const   *code_timespec(struct timespec t , char *sbuf ) ;
#line 709
void close_diag(char const   *name ) ;
#line 736
int gname_to_gid(char const   *gname , gid_t *gidp ) ;
#line 738
int uname_to_uid(char const   *uname , uid_t *uidp ) ;
#line 740
void name_init(void) ;
#line 741
void name_add_name(char const   *name ) ;
#line 742
void name_term(void) ;
#line 777
void tar_stat_init(struct tar_stat_info *st ) ;
#line 778
_Bool tar_stat_close(struct tar_stat_info *st ) ;
#line 782
char const   *archive_format_string(enum archive_format fmt ) ;
#line 783
char const   *subcommand_string(enum subcommand c ) ;
#line 784
void set_exit_status(int val___0 ) ;
#line 786
void request_stdin(char const   *rpl_option ) ;
#line 806
void more_options(int argc , char **argv , struct option_locus *loc ) ;
#line 827
void xheader_destroy(struct xheader *xhdr ) ;
#line 830
void xheader_set_option(char *string ) ;
#line 838
void xheader_xattr_free(struct xattr_array *xattr_map , size_t xattr_map_size ) ;
#line 896
void set_compression_program_by_suffix(char const   *name , char const   *defprog ) ;
#line 897
char *strip_compression_suffix(char const   *name ) ;
#line 900
void checkpoint_compile_action(char const   *str ) ;
#line 901
void checkpoint_finish_compile(void) ;
#line 903
void checkpoint_finish(void) ;
#line 904
void checkpoint_flush_actions(void) ;
#line 963
void info_free_exclist(struct tar_stat_info *dir ) ;
#line 968
void owner_map_read(char const   *file ) ;
#line 970
void group_map_read(char const   *file ) ;
#line 974
#pragma GCC diagnostic pop
#line 23 "../gnu/priv-set.h"
#pragma GCC diagnostic push
#line 23
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 23
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 64
#pragma GCC diagnostic pop
#line 72 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int check_links_option  ;
#line 75 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static size_t allocated_archive_names  ;
#line 81 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   *stdin_used_by  ;
#line 84 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
void request_stdin(char const   *rpl_option ) 
{ 
  char *tmp ;

  {
#line 87
  if (stdin_used_by) {
    {
#line 88
    while (1) {
      while_continue: /* CIL Label */ ;
#line 88
      if (error_hook) {
        {
#line 88
        (*error_hook)();
        }
      }
      {
#line 88
      tmp = gettext("Options \'%s\' and \'%s\' both want standard input");
#line 88
      error(0, 0, (char const   *)tmp, stdin_used_by, rpl_option);
#line 88
      usage(2);
      }
#line 88
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 91
  stdin_used_by = rpl_option;
#line 92
  return;
}
}
#line 100 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static FILE *confirm_file  ;
#line 101 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int confirm_file_EOF  ;
#line 97 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
int confirm(char const   *message_action , char const   *message_name ) 
{ 
  _Bool status ;
  char const   *tmp ;
  char *response ;
  size_t response_size ;
  int tmp___0 ;
  __ssize_t tmp___1 ;

  {
#line 102
  status = (_Bool)0;
#line 104
  if (! confirm_file) {
#line 106
    if (archive == 0) {
#line 106
      goto _L;
    } else
#line 106
    if (stdin_used_by) {
      _L: /* CIL Label */ 
      {
#line 108
      confirm_file = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
      }
#line 109
      if (! confirm_file) {
        {
#line 110
        open_fatal("/dev/tty");
        }
      }
    } else {
      {
#line 114
      request_stdin("-w");
#line 115
      confirm_file = stdin;
      }
    }
  }
  {
#line 119
  tmp = quote(message_name);
#line 119
  fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %s?",
          message_action, tmp);
#line 120
  fflush_unlocked(stdlis);
  }
#line 122
  if (! confirm_file_EOF) {
    {
#line 124
    response = (char *)((void *)0);
#line 125
    response_size = (size_t )0;
#line 126
    tmp___1 = getline((char **/* __restrict  */)(& response), (size_t */* __restrict  */)(& response_size),
                      (FILE */* __restrict  */)confirm_file);
    }
#line 126
    if (tmp___1 < 0L) {
#line 127
      confirm_file_EOF = 1;
    } else {
      {
#line 129
      tmp___0 = rpmatch((char const   *)response);
#line 129
      status = (_Bool )(tmp___0 > 0);
      }
    }
    {
#line 130
    free((void *)response);
    }
  }
#line 133
  if (confirm_file_EOF) {
    {
#line 135
    fputc_unlocked('\n', stdlis);
#line 136
    fflush_unlocked(stdlis);
    }
  }
#line 139
  return ((int )status);
}
}
#line 142 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct fmttab  const  fmttab[7]  = {      {"v7", (enum archive_format )1}, 
        {"oldgnu", (enum archive_format )2}, 
        {"ustar", (enum archive_format )3}, 
        {"posix", (enum archive_format )4}, 
        {"gnu", (enum archive_format )6}, 
        {"pax", (enum archive_format )4}, 
        {(char const   *)((void *)0), (enum archive_format )0}};
#line 158 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void set_archive_format(char const   *name ) 
{ 
  struct fmttab  const  *p ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 163
  p = fmttab;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 163
    tmp___1 = strcmp((char const   *)p->name, name);
    }
#line 163
    if (! (tmp___1 != 0)) {
#line 163
      goto while_break;
    }
#line 164
    p ++;
#line 164
    if (! p->name) {
      {
#line 165
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 165
        if (error_hook) {
          {
#line 165
          (*error_hook)();
          }
        }
        {
#line 165
        tmp = quotearg_colon(name);
#line 165
        tmp___0 = gettext("%s: Invalid archive format");
#line 165
        error(0, 0, (char const   *)tmp___0, tmp);
#line 165
        usage(2);
        }
#line 165
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  archive_format = (enum archive_format )p->fmt;
#line 169
  return;
}
}
#line 171 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void set_xattr_option(int value___0 ) 
{ 


  {
#line 174
  if (value___0 == 1) {
    {
#line 175
    set_archive_format("posix");
    }
  }
#line 176
  xattrs_option = value___0;
#line 177
  return;
}
}
#line 179 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
char const   *archive_format_string(enum archive_format fmt ) 
{ 
  struct fmttab  const  *p ;

  {
#line 184
  p = fmttab;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! p->name) {
#line 184
      goto while_break;
    }
#line 185
    if ((unsigned int const   )p->fmt == (unsigned int const   )fmt) {
#line 186
      return ((char const   *)p->name);
    }
#line 184
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return ("unknown?");
}
}
#line 192 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void assert_format(unsigned int fmt_mask ) 
{ 
  char *tmp ;

  {
#line 195
  if (((unsigned int )(1 << (unsigned int )archive_format) & fmt_mask) == 0U) {
    {
#line 196
    while (1) {
      while_continue: /* CIL Label */ ;
#line 196
      if (error_hook) {
        {
#line 196
        (*error_hook)();
        }
      }
      {
#line 196
      tmp = gettext("GNU features wanted on incompatible archive format");
#line 196
      error(0, 0, (char const   *)tmp);
#line 196
      usage(2);
      }
#line 196
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 198
  return;
}
}
#line 200 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
char const   *subcommand_string(enum subcommand c ) 
{ 


  {
  {
#line 205
  if ((unsigned int )c == 0U) {
#line 205
    goto case_0;
  }
#line 208
  if ((unsigned int )c == 1U) {
#line 208
    goto case_1;
  }
#line 211
  if ((unsigned int )c == 2U) {
#line 211
    goto case_2;
  }
#line 214
  if ((unsigned int )c == 3U) {
#line 214
    goto case_3;
  }
#line 217
  if ((unsigned int )c == 4U) {
#line 217
    goto case_4;
  }
#line 220
  if ((unsigned int )c == 5U) {
#line 220
    goto case_5;
  }
#line 223
  if ((unsigned int )c == 6U) {
#line 223
    goto case_6;
  }
#line 226
  if ((unsigned int )c == 7U) {
#line 226
    goto case_7;
  }
#line 229
  if ((unsigned int )c == 8U) {
#line 229
    goto case_8;
  }
#line 232
  if ((unsigned int )c == 9U) {
#line 232
    goto case_9;
  }
#line 203
  goto switch_break;
  case_0: /* CIL Label */ 
#line 206
  return ("unknown?");
  case_1: /* CIL Label */ 
#line 209
  return ("-r");
  case_2: /* CIL Label */ 
#line 212
  return ("-A");
  case_3: /* CIL Label */ 
#line 215
  return ("-c");
  case_4: /* CIL Label */ 
#line 218
  return ("-D");
  case_5: /* CIL Label */ 
#line 221
  return ("-d");
  case_6: /* CIL Label */ 
#line 224
  return ("-x");
  case_7: /* CIL Label */ 
#line 227
  return ("-t");
  case_8: /* CIL Label */ 
#line 230
  return ("-u");
  case_9: /* CIL Label */ 
#line 233
  return ("--test-label");
  switch_break: /* CIL Label */ ;
  }
  {
#line 235
  abort();
  }
}
}
#line 238 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void tar_list_quoting_styles(struct obstack *stk___0 , char const   *prefix ) 
{ 
  int i ;
  size_t prefixlen ;
  size_t tmp ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  size_t tmp___0 ;
  struct obstack  const  *__o1___0 ;
  struct obstack *__o___1 ;
  struct obstack  const  *__o1___1 ;
  char *tmp___1 ;

  {
  {
#line 242
  tmp = strlen(prefix);
#line 242
  prefixlen = tmp;
#line 244
  i = 0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! quoting_style_args[i]) {
#line 244
      goto while_break;
    }
#line 246
    __o = stk___0;
#line 246
    __len = prefixlen;
#line 246
    __o1 = (struct obstack  const  *)__o;
#line 246
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 246
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 246
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)prefix,
           __len);
#line 246
    __o->next_free += __len;
#line 247
    __o___0 = stk___0;
#line 247
    tmp___0 = strlen((char const   *)quoting_style_args[i]);
#line 247
    __len___0 = tmp___0;
#line 247
    __o1___0 = (struct obstack  const  *)__o___0;
    }
#line 247
    if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len___0) {
      {
#line 247
      _obstack_newchunk(__o___0, __len___0);
      }
    }
    {
#line 247
    memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)quoting_style_args[i],
           __len___0);
#line 247
    __o___0->next_free += __len___0;
#line 249
    __o___1 = stk___0;
#line 249
    __o1___1 = (struct obstack  const  *)__o___1;
    }
#line 249
    if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < 1UL) {
      {
#line 249
      _obstack_newchunk(__o___1, (size_t )1);
      }
    }
#line 249
    tmp___1 = __o___1->next_free;
#line 249
    (__o___1->next_free) ++;
#line 249
    *tmp___1 = (char )'\n';
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 251
  return;
}
}
#line 253 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void tar_set_quoting_style(char *arg___0 ) 
{ 
  int i ;
  int tmp ;
  char *tmp___0 ;

  {
#line 258
  i = 0;
  {
#line 258
  while (1) {
    while_continue: /* CIL Label */ ;
#line 258
    if (! quoting_style_args[i]) {
#line 258
      goto while_break;
    }
    {
#line 259
    tmp = strcmp((char const   *)arg___0, (char const   *)quoting_style_args[i]);
    }
#line 259
    if (tmp == 0) {
      {
#line 261
      set_quoting_style((struct quoting_options *)((void *)0), (enum quoting_style )i);
      }
#line 262
      return;
    }
#line 258
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 264
    if (error_hook) {
      {
#line 264
      (*error_hook)();
      }
    }
    {
#line 264
    tmp___0 = gettext("Unknown quoting style \'%s\'. Try \'%s --quoting-style=help\' to get a list.");
#line 264
    error(0, 0, (char const   *)tmp___0, arg___0, program_name);
#line 264
    fatal_exit();
    }
#line 264
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 266
  return;
}
}
#line 354 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   doc[702]  = 
#line 354
  {      (char const   )'G',      (char const   )'N',      (char const   )'U',      (char const   )' ', 
        (char const   )'\'',      (char const   )'t',      (char const   )'a',      (char const   )'r', 
        (char const   )'\'',      (char const   )' ',      (char const   )'s',      (char const   )'a', 
        (char const   )'v',      (char const   )'e',      (char const   )'s',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'n',      (char const   )'y', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'g',      (char const   )'e',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'t',      (char const   )'o', 
        (char const   )' ',      (char const   )'a',      (char const   )' ',      (char const   )'s', 
        (char const   )'i',      (char const   )'n',      (char const   )'g',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'p',      (char const   )'e',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'d',      (char const   )'i', 
        (char const   )'s',      (char const   )'k',      (char const   )' ',      (char const   )'a', 
        (char const   )'r',      (char const   )'c',      (char const   )'h',      (char const   )'i', 
        (char const   )'v',      (char const   )'e',      (char const   )',',      (char const   )' ', 
        (char const   )'a',      (char const   )'n',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'a',      (char const   )'n',      (char const   )' ', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'t', 
        (char const   )'o',      (char const   )'r',      (char const   )'e',      (char const   )' ', 
        (char const   )'i',      (char const   )'n',      (char const   )'d',      (char const   )'i', 
        (char const   )'v',      (char const   )'i',      (char const   )'d',      (char const   )'u', 
        (char const   )'a',      (char const   )'l',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'r',      (char const   )'o', 
        (char const   )'m',      (char const   )' ',      (char const   )'t',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'.',      (char const   )'\n',      (char const   )'\n', 
        (char const   )'E',      (char const   )'x',      (char const   )'a',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )'s', 
        (char const   )':',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'t',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'-',      (char const   )'c',      (char const   )'f',      (char const   )' ', 
        (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'.', 
        (char const   )'t',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'f',      (char const   )'o',      (char const   )'o',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )' ',      (char const   )'#',      (char const   )' ',      (char const   )'C', 
        (char const   )'r',      (char const   )'e',      (char const   )'a',      (char const   )'t', 
        (char const   )'e',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'.',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )' ',      (char const   )'f',      (char const   )'r', 
        (char const   )'o',      (char const   )'m',      (char const   )' ',      (char const   )'f', 
        (char const   )'i',      (char const   )'l',      (char const   )'e',      (char const   )'s', 
        (char const   )' ',      (char const   )'f',      (char const   )'o',      (char const   )'o', 
        (char const   )' ',      (char const   )'a',      (char const   )'n',      (char const   )'d', 
        (char const   )' ',      (char const   )'b',      (char const   )'a',      (char const   )'r', 
        (char const   )'.',      (char const   )'\n',      (char const   )' ',      (char const   )' ', 
        (char const   )'t',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'-',      (char const   )'t',      (char const   )'v',      (char const   )'f', 
        (char const   )' ',      (char const   )'a',      (char const   )'r',      (char const   )'c', 
        (char const   )'h',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )'.',      (char const   )'t',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )'#',      (char const   )' ',      (char const   )'L', 
        (char const   )'i',      (char const   )'s',      (char const   )'t',      (char const   )' ', 
        (char const   )'a',      (char const   )'l',      (char const   )'l',      (char const   )' ', 
        (char const   )'f',      (char const   )'i',      (char const   )'l',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'i',      (char const   )'n', 
        (char const   )' ',      (char const   )'a',      (char const   )'r',      (char const   )'c', 
        (char const   )'h',      (char const   )'i',      (char const   )'v',      (char const   )'e', 
        (char const   )'.',      (char const   )'t',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'v',      (char const   )'e',      (char const   )'r', 
        (char const   )'b',      (char const   )'o',      (char const   )'s',      (char const   )'e', 
        (char const   )'l',      (char const   )'y',      (char const   )'.',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )' ',      (char const   )'-',      (char const   )'x', 
        (char const   )'f',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'c',      (char const   )'h',      (char const   )'i',      (char const   )'v', 
        (char const   )'e',      (char const   )'.',      (char const   )'t',      (char const   )'a', 
        (char const   )'r',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'#', 
        (char const   )' ',      (char const   )'E',      (char const   )'x',      (char const   )'t', 
        (char const   )'r',      (char const   )'a',      (char const   )'c',      (char const   )'t', 
        (char const   )' ',      (char const   )'a',      (char const   )'l',      (char const   )'l', 
        (char const   )' ',      (char const   )'f',      (char const   )'i',      (char const   )'l', 
        (char const   )'e',      (char const   )'s',      (char const   )' ',      (char const   )'f', 
        (char const   )'r',      (char const   )'o',      (char const   )'m',      (char const   )' ', 
        (char const   )'a',      (char const   )'r',      (char const   )'c',      (char const   )'h', 
        (char const   )'i',      (char const   )'v',      (char const   )'e',      (char const   )'.', 
        (char const   )'t',      (char const   )'a',      (char const   )'r',      (char const   )'.', 
        (char const   )'\n',      (char const   )'\v',      (char const   )'T',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'u',      (char const   )'p', 
        (char const   )' ',      (char const   )'s',      (char const   )'u',      (char const   )'f', 
        (char const   )'f',      (char const   )'i',      (char const   )'x',      (char const   )' ', 
        (char const   )'i',      (char const   )'s',      (char const   )' ',      (char const   )'\'', 
        (char const   )'~',      (char const   )'\'',      (char const   )',',      (char const   )' ', 
        (char const   )'u',      (char const   )'n',      (char const   )'l',      (char const   )'e', 
        (char const   )'s',      (char const   )'s',      (char const   )' ',      (char const   )'s', 
        (char const   )'e',      (char const   )'t',      (char const   )' ',      (char const   )'w', 
        (char const   )'i',      (char const   )'t',      (char const   )'h',      (char const   )' ', 
        (char const   )'-',      (char const   )'-',      (char const   )'s',      (char const   )'u', 
        (char const   )'f',      (char const   )'f',      (char const   )'i',      (char const   )'x', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'S',      (char const   )'I',      (char const   )'M',      (char const   )'P', 
        (char const   )'L',      (char const   )'E',      (char const   )'_',      (char const   )'B', 
        (char const   )'A',      (char const   )'C',      (char const   )'K',      (char const   )'U', 
        (char const   )'P',      (char const   )'_',      (char const   )'S',      (char const   )'U', 
        (char const   )'F',      (char const   )'F',      (char const   )'I',      (char const   )'X', 
        (char const   )'.',      (char const   )'\n',      (char const   )'T',      (char const   )'h', 
        (char const   )'e',      (char const   )' ',      (char const   )'v',      (char const   )'e', 
        (char const   )'r',      (char const   )'s',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'o', 
        (char const   )'n',      (char const   )'t',      (char const   )'r',      (char const   )'o', 
        (char const   )'l',      (char const   )' ',      (char const   )'m',      (char const   )'a', 
        (char const   )'y',      (char const   )' ',      (char const   )'b',      (char const   )'e', 
        (char const   )' ',      (char const   )'s',      (char const   )'e',      (char const   )'t', 
        (char const   )' ',      (char const   )'w',      (char const   )'i',      (char const   )'t', 
        (char const   )'h',      (char const   )' ',      (char const   )'-',      (char const   )'-', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'u',      (char const   )'p',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'V',      (char const   )'E', 
        (char const   )'R',      (char const   )'S',      (char const   )'I',      (char const   )'O', 
        (char const   )'N',      (char const   )'_',      (char const   )'C',      (char const   )'O', 
        (char const   )'N',      (char const   )'T',      (char const   )'R',      (char const   )'O', 
        (char const   )'L',      (char const   )',',      (char const   )' ',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'u',      (char const   )'e', 
        (char const   )'s',      (char const   )' ',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )':',      (char const   )'\n',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'n',      (char const   )'e',      (char const   )',',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )'f',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'n',      (char const   )'e', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )' ', 
        (char const   )'m',      (char const   )'a',      (char const   )'k',      (char const   )'e', 
        (char const   )' ',      (char const   )'b',      (char const   )'a',      (char const   )'c', 
        (char const   )'k',      (char const   )'u',      (char const   )'p',      (char const   )'s', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'t', 
        (char const   )',',      (char const   )' ',      (char const   )'n',      (char const   )'u', 
        (char const   )'m',      (char const   )'b',      (char const   )'e',      (char const   )'r', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'k',      (char const   )'e',      (char const   )' ', 
        (char const   )'n',      (char const   )'u',      (char const   )'m',      (char const   )'b', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'b',      (char const   )'a',      (char const   )'c', 
        (char const   )'k',      (char const   )'u',      (char const   )'p',      (char const   )'s', 
        (char const   )'\n',      (char const   )' ',      (char const   )' ',      (char const   )'n', 
        (char const   )'i',      (char const   )'l',      (char const   )',',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )' ',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'i',      (char const   )'f',      (char const   )' ',      (char const   )'n', 
        (char const   )'u',      (char const   )'m',      (char const   )'b',      (char const   )'e', 
        (char const   )'r',      (char const   )'e',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )'u',      (char const   )'p',      (char const   )'s',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'i',      (char const   )'s', 
        (char const   )'t',      (char const   )',',      (char const   )' ',      (char const   )'s', 
        (char const   )'i',      (char const   )'m',      (char const   )'p',      (char const   )'l', 
        (char const   )'e',      (char const   )' ',      (char const   )'o',      (char const   )'t', 
        (char const   )'h',      (char const   )'e',      (char const   )'r',      (char const   )'w', 
        (char const   )'i',      (char const   )'s',      (char const   )'e',      (char const   )'\n', 
        (char const   )' ',      (char const   )' ',      (char const   )'n',      (char const   )'e', 
        (char const   )'v',      (char const   )'e',      (char const   )'r',      (char const   )',', 
        (char const   )' ',      (char const   )'s',      (char const   )'i',      (char const   )'m', 
        (char const   )'p',      (char const   )'l',      (char const   )'e',      (char const   )' ', 
        (char const   )' ',      (char const   )' ',      (char const   )'a',      (char const   )'l', 
        (char const   )'w',      (char const   )'a',      (char const   )'y',      (char const   )'s', 
        (char const   )' ',      (char const   )'m',      (char const   )'a',      (char const   )'k', 
        (char const   )'e',      (char const   )' ',      (char const   )'s',      (char const   )'i', 
        (char const   )'m',      (char const   )'p',      (char const   )'l',      (char const   )'e', 
        (char const   )' ',      (char const   )'b',      (char const   )'a',      (char const   )'c', 
        (char const   )'k',      (char const   )'u',      (char const   )'p',      (char const   )'s', 
        (char const   )'\n',      (char const   )'\000'};
#line 390 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct argp_option options[168]  = 
#line 390
  {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Main operation mode:",
      10}, 
        {"list", 't', (char const   *)0, 0, "list the contents of an archive", 11}, 
        {"extract", 'x', (char const   *)0, 0, "extract files from an archive", 11}, 
        {"get", 0, (char const   *)0, 4, (char const   *)((void *)0), 11}, 
        {"create", 'c', (char const   *)0, 0, "create a new archive", 11}, 
        {"diff", 'd', (char const   *)0, 0, "find differences between archive and file system",
      11}, 
        {"compare", 0, (char const   *)0, 4, (char const   *)((void *)0), 11}, 
        {"append", 'r', (char const   *)0, 0, "append files to the end of an archive",
      11}, 
        {"update", 'u', (char const   *)0, 0, "only append files newer than copy in archive",
      11}, 
        {"catenate", 'A', (char const   *)0, 0, "append tar files to an archive", 11}, 
        {"concatenate",
      0, (char const   *)0, 4, (char const   *)((void *)0), 11}, 
        {"delete", 137, (char const   *)0, 0, "delete from the archive (not on mag tapes!)",
      11}, 
        {"test-label", 197, (char const   *)((void *)0), 0, "test the archive volume label and exit",
      11}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Operation modifiers:",
      20}, 
        {"sparse", 'S', (char const   *)0, 0, "handle sparse files efficiently", 21}, 
        {"hole-detection",
      193, "TYPE", 0, "technique to detect holes", 21}, 
        {"sparse-version", 194, "MAJOR[.MINOR]", 0, "set version of the sparse format to use (implies --sparse)",
      21}, 
        {"incremental", 'G', (char const   *)0, 0, "handle old GNU-format incremental backup",
      21}, 
        {"listed-incremental", 'g', "FILE", 0, "handle new GNU-format incremental backup",
      21}, 
        {"level", 147, "NUMBER", 0, "dump level for created listed-incremental archive",
      21}, 
        {"ignore-failed-read", 143, (char const   *)0, 0, "do not exit with nonzero on unreadable files",
      21}, 
        {"occurrence", 167, "NUMBER", 1, "process only the NUMBERth occurrence of each file in the archive; this option is valid only in conjunction with one of the subcommands --delete, --diff, --extract or --list and when a list of files is given either on the command line or via the -T option; NUMBER defaults to 1",
      21}, 
        {"seek", 'n', (char const   *)((void *)0), 0, "archive is seekable", 21}, 
        {"no-seek", 163, (char const   *)((void *)0), 0, "archive is not seekable", 21}, 
        {"no-check-device",
      156, (char const   *)((void *)0), 0, "do not check device numbers when creating incremental archives",
      21}, 
        {"check-device", 131, (char const   *)((void *)0), 0, "check device numbers when creating incremental archives (default)",
      21}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Overwrite control:",
      30}, 
        {"verify", 'W', (char const   *)0, 0, "attempt to verify the archive after writing it",
      31}, 
        {"remove-files", 181, (char const   *)0, 0, "remove files after adding them to the archive",
      31}, 
        {"keep-old-files", 'k', (char const   *)0, 0, "don\'t replace existing files when extracting, treat them as errors",
      31}, 
        {"skip-old-files", 191, (char const   *)0, 0, "don\'t replace existing files when extracting, silently skip over them",
      31}, 
        {"keep-newer-files", 146, (char const   *)0, 0, "don\'t replace existing files that are newer than their archive copies",
      31}, 
        {"overwrite", 172, (char const   *)0, 0, "overwrite existing files when extracting",
      31}, 
        {"unlink-first", 'U', (char const   *)0, 0, "remove each file prior to extracting over it",
      31}, 
        {"recursive-unlink", 180, (char const   *)0, 0, "empty hierarchies prior to extracting directory",
      31}, 
        {"no-overwrite-dir", 159, (char const   *)0, 0, "preserve metadata of existing directories",
      31}, 
        {"overwrite-dir", 171, (char const   *)0, 0, "overwrite metadata of existing directories when extracting (default)",
      31}, 
        {"keep-directory-symlink", 145, (char const   *)0, 0, "preserve existing symlinks to directories when extracting",
      31}, 
        {"one-top-level", 170, "DIR", 1, "create a subdirectory to avoid having loose files extracted",
      31}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Select output stream:",
      40}, 
        {"to-stdout", 'O', (char const   *)0, 0, "extract files to standard output",
      41}, 
        {"to-command", 199, "COMMAND", 0, "pipe extracted files to another program",
      41}, 
        {"ignore-command-error", 142, (char const   *)0, 0, "ignore exit codes of children",
      41}, 
        {"no-ignore-command-error", 158, (char const   *)0, 0, "treat non-zero exit codes of children as error",
      41}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Handling of file attributes:",
      50}, 
        {"owner", 173, "NAME", 0, "force NAME as owner for added files", 51}, 
        {"group", 140, "NAME", 0, "force NAME as group for added files", 51}, 
        {"owner-map", 174, "FILE", 0, "use FILE to map file owner UIDs and names", 51}, 
        {"group-map",
      141, "FILE", 0, "use FILE to map file owner GIDs and names", 51}, 
        {"mtime", 152, "DATE-OR-FILE", 0, "set mtime for added files from DATE-OR-FILE",
      51}, 
        {"clamp-mtime", 134, (char const   *)0, 0, "only set time when the file is more recent than what was given with --mtime",
      51}, 
        {"mode", 151, "CHANGES", 0, "force (symbolic) mode CHANGES for added files",
      51}, 
        {"atime-preserve", 129, "METHOD", 1, "preserve access times on dumped files, either by restoring the times after reading (METHOD=\'replace\'; default) or by not setting the times in the first place (METHOD=\'system\')",
      51}, 
        {"touch", 'm', (char const   *)0, 0, "don\'t extract file modified time", 51}, 
        {"same-owner",
      185, (char const   *)0, 0, "try extracting files with the same ownership as exists in the archive (default for superuser)",
      51}, 
        {"no-same-owner", 161, (char const   *)0, 0, "extract files as yourself (default for ordinary users)",
      51}, 
        {"numeric-owner", 166, (char const   *)0, 0, "always use numbers for user/group names",
      51}, 
        {"preserve-permissions", 'p', (char const   *)0, 0, "extract information about file permissions (default for superuser)",
      51}, 
        {"same-permissions", 0, (char const   *)0, 4, (char const   *)((void *)0), 51}, 
        {"no-same-permissions",
      162, (char const   *)0, 0, "apply the user\'s umask when extracting permissions from the archive (default for ordinary users)",
      51}, 
        {"preserve-order", 's', (char const   *)0, 0, "member arguments are listed in the same order as the files in the archive",
      51}, 
        {"same-order", 0, (char const   *)0, 4, (char const   *)((void *)0), 51}, 
        {"delay-directory-restore", 135, (char const   *)0, 0, "delay setting modification times and permissions of extracted directories until the end of extraction",
      51}, 
        {"no-delay-directory-restore", 157, (char const   *)0, 0, "cancel the effect of --delay-directory-restore option",
      51}, 
        {"sort", 192, "ORDER", 0, "directory sorting order: none (default), name or inode",
      51}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Handling of extended file attributes:",
      55}, 
        {"xattrs", 204, (char const   *)0, 0, "Enable extended attributes support", 56}, 
        {"no-xattrs",
      165, (char const   *)0, 0, "Disable extended attributes support", 56}, 
        {"xattrs-include", 206, "MASK", 0, "specify the include pattern for xattr keys",
      56}, 
        {"xattrs-exclude", 205, "MASK", 0, "specify the exclude pattern for xattr keys",
      56}, 
        {"selinux", 186, (char const   *)0, 0, "Enable the SELinux context support",
      56}, 
        {"no-selinux", 164, (char const   *)0, 0, "Disable the SELinux context support",
      56}, 
        {"acls", 128, (char const   *)0, 0, "Enable the POSIX ACLs support", 56}, 
        {"no-acls", 154, (char const   *)0, 0, "Disable the POSIX ACLs support", 56}, 
        {(char const   *)((void *)0),
      0, (char const   *)((void *)0), 0, "Device selection and switching:", 60}, 
        {"file", 'f', "ARCHIVE", 0, "use archive file or device ARCHIVE", 61}, 
        {"force-local", 138, (char const   *)0, 0, "archive file is local even if it has a colon",
      61}, 
        {"rmt-command", 183, "COMMAND", 0, "use given rmt COMMAND instead of rmt", 61}, 
        {"rsh-command",
      184, "COMMAND", 0, "use remote COMMAND instead of rsh", 61}, 
        {(char const   *)((void *)0), '0', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '1', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '2', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '3', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '4', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '5', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '6', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '7', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '8', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {(char const   *)((void *)0), '9', (char const   *)((void *)0), 2, (char const   *)((void *)0),
      61}, 
        {"multi-volume", 'M', (char const   *)0, 0, "create/list/extract multi-volume archive",
      61}, 
        {"tape-length", 'L', "NUMBER", 0, "change tape after writing NUMBER x 1024 bytes",
      61}, 
        {"info-script", 'F', "NAME", 0, "run script at end of each tape (implies -M)",
      61}, 
        {"new-volume-script", 0, (char const   *)0, 4, (char const   *)((void *)0), 61}, 
        {"volno-file",
      202, "FILE", 0, "use/update the volume number in FILE", 61}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Device blocking:",
      70}, 
        {"blocking-factor", 'b', "BLOCKS", 0, "BLOCKS x 512 bytes per record", 71}, 
        {"record-size", 179, "NUMBER", 0, "NUMBER of bytes per record, multiple of 512",
      71}, 
        {"ignore-zeros", 'i', (char const   *)0, 0, "ignore zeroed blocks in archive (means EOF)",
      71}, 
        {"read-full-records", 'B', (char const   *)0, 0, "reblock as we read (for 4.2BSD pipes)",
      71}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Archive format selection:",
      80}, 
        {"format", 'H', "FORMAT", 0, "create archive of the given format", 81}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "FORMAT is one of the following:",
      82}, 
        {"  v7", 0, (char const   *)((void *)0), 40, "old V7 tar format", 83}, 
        {"  oldgnu", 0, (char const   *)((void *)0), 40, "GNU format as per tar <= 1.12",
      83}, 
        {"  gnu", 0, (char const   *)((void *)0), 40, "GNU tar 1.13.x format", 83}, 
        {"  ustar", 0, (char const   *)((void *)0), 40, "POSIX 1003.1-1988 (ustar) format",
      83}, 
        {"  pax", 0, (char const   *)((void *)0), 40, "POSIX 1003.1-2001 (pax) format",
      83}, 
        {"  posix", 0, (char const   *)((void *)0), 40, "same as pax", 83}, 
        {"old-archive", 168, (char const   *)0, 0, "same as --format=v7", 88}, 
        {"portability", 0, (char const   *)0, 4, (char const   *)((void *)0), 88}, 
        {"posix", 176, (char const   *)0, 0, "same as --format=posix", 88}, 
        {"pax-option", 175, "keyword[[:]=value][,keyword[[:]=value]]...", 0, "control pax keywords",
      88}, 
        {"label", 'V', "TEXT", 0, "create archive with volume name TEXT; at list/extract time, use TEXT as a globbing pattern for volume name",
      88}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Compression options:",
      90}, 
        {"auto-compress", 'a', (char const   *)0, 0, "use archive suffix to determine the compression program",
      91}, 
        {"no-auto-compress", 155, (char const   *)0, 0, "do not use archive suffix to determine the compression program",
      91}, 
        {"use-compress-program", 'I', "PROG", 0, "filter through PROG (must accept -d)",
      91}, 
        {"bzip2", 'j', (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {"gzip", 'z', (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {"gunzip", 0, (char const   *)0, 4, (char const   *)((void *)0), 91}, 
        {"ungzip", 0, (char const   *)0, 4, (char const   *)((void *)0), 91}, 
        {"compress", 'Z', (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {"uncompress", 0, (char const   *)0, 4, (char const   *)((void *)0), 91}, 
        {"lzip", 148, (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {"lzma", 149, (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {"lzop", 150, (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {"xz", 'J', (char const   *)0, 0, (char const   *)((void *)0), 91}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Local file selection:",
      100}, 
        {"one-file-system", 169, (char const   *)0, 0, "stay in local file system when creating archive",
      101}, 
        {"absolute-names", 'P', (char const   *)0, 0, "don\'t strip leading \'/\'s from file names",
      101}, 
        {"dereference", 'h', (char const   *)0, 0, "follow symlinks; archive and dump the files they point to",
      101}, 
        {"hard-dereference", 136, (char const   *)0, 0, "follow hard links; archive and dump the files they refer to",
      101}, 
        {"starting-file", 'K', "MEMBER-NAME", 0, "begin at member MEMBER-NAME when reading the archive",
      101}, 
        {"newer", 'N', "DATE-OR-FILE", 0, "only store files newer than DATE-OR-FILE",
      101}, 
        {"after-date", 0, (char const   *)0, 4, (char const   *)((void *)0), 101}, 
        {"newer-mtime", 153, "DATE", 0, "compare date and time when data changed only",
      101}, 
        {"backup", 130, "CONTROL", 1, "backup before removal, choose version CONTROL",
      101}, 
        {"suffix", 196, "STRING", 0, "backup before removal, override usual suffix (\'~\' unless overridden by environment variable SIMPLE_BACKUP_SUFFIX)",
      101}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "File name transformations:",
      110}, 
        {"strip-components", 195, "NUMBER", 0, "strip NUMBER leading components from file names on extraction",
      111}, 
        {"transform", 200, "EXPRESSION", 0, "use sed replace EXPRESSION to transform file names",
      111}, 
        {"xform", 0, (char const   *)0, 4, (char const   *)((void *)0), 111}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Informative output:",
      130}, 
        {"verbose", 'v', (char const   *)0, 0, "verbosely list files processed", 131}, 
        {"warning",
      203, "KEYWORD", 0, "warning control", 131}, 
        {"checkpoint", 132, "NUMBER", 1, "display progress messages every NUMBERth record (default 10)",
      131}, 
        {"checkpoint-action", 133, "ACTION", 0, "execute ACTION on each checkpoint",
      131}, 
        {"check-links", 'l', (char const   *)0, 0, "print a message if not all links are dumped",
      131}, 
        {"totals", 198, "SIGNAL", 1, "print total bytes after processing the archive; with an argument - print total bytes when this SIGNAL is delivered; Allowed signals are: SIGHUP, SIGQUIT, SIGINT, SIGUSR1 and SIGUSR2; the names without SIG prefix are also accepted",
      131}, 
        {"utc", 201, (char const   *)0, 0, "print file modification times in UTC", 131}, 
        {"full-time",
      139, (char const   *)0, 0, "print file time to its full resolution", 131}, 
        {"index-file", 144, "FILE", 0, "send verbose output to FILE", 131}, 
        {"block-number", 'R', (char const   *)0, 0, "show block number within archive with each message",
      131}, 
        {"interactive", 'w', (char const   *)0, 0, "ask for confirmation for every action",
      131}, 
        {"confirmation", 0, (char const   *)0, 4, (char const   *)((void *)0), 131}, 
        {"show-defaults", 187, (char const   *)0, 0, "show tar defaults", 131}, 
        {"show-snapshot-field-ranges", 189, (char const   *)0, 0, "show valid ranges for snapshot-file fields",
      131}, 
        {"show-omitted-dirs", 188, (char const   *)0, 0, "when listing or extracting, list each directory that does not match search criteria",
      131}, 
        {"show-transformed-names", 190, (char const   *)0, 0, "show file or archive names after transformation",
      131}, 
        {"show-stored-names", 0, (char const   *)0, 4, (char const   *)((void *)0), 131}, 
        {"quoting-style",
      178, "STYLE", 0, "set name quoting style; see below for valid STYLE values",
      131}, 
        {"quote-chars", 177, "STRING", 0, "additionally quote characters from STRING",
      131}, 
        {"no-quote-chars", 160, "STRING", 0, "disable quoting for characters from STRING",
      131}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Compatibility options:",
      140}, 
        {(char const   *)((void *)0), 'o', (char const   *)0, 0, "when creating, same as --old-archive; when extracting, same as --no-same-owner",
      141}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Other options:",
      150}, 
        {"restrict", 182, (char const   *)0, 0, "disable use of some potentially harmful options",
      -1}, 
        {(char const   *)0, 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 791 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   * const  atime_preserve_args[3]  = {      (char const   */* const  */)"replace",      (char const   */* const  */)"system",      (char const   */* const  */)((void *)0)};
#line 796 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static enum atime_preserve  const  atime_preserve_types[2]  = {      (enum atime_preserve  const  )1,      (enum atime_preserve  const  )2};
#line 822 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char *format_default_settings(void) 
{ 
  char const   *tmp ;
  char *tmp___0 ;

  {
  {
#line 825
  tmp = archive_format_string((enum archive_format )6);
#line 825
  tmp___0 = xasprintf("--format=%s -f%s -b%d --quoting-style=%s --rmt-command=%s --rsh-command=%s",
                      tmp, "-", 20, quoting_style_args[5], "/usr/local/libexec/rmt",
                      "/usr/bin/rsh");
  }
#line 825
  return (tmp___0);
}
}
#line 841 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void option_conflict_error(char const   *a , char const   *b ) 
{ 
  char *tmp ;

  {
  {
#line 846
  while (1) {
    while_continue: /* CIL Label */ ;
#line 846
    if (error_hook) {
      {
#line 846
      (*error_hook)();
      }
    }
    {
#line 846
    tmp = gettext("\'%s\' cannot be used with \'%s\'");
#line 846
    error(0, 0, (char const   *)tmp, a, b);
#line 846
    usage(2);
    }
#line 846
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 847
  return;
}
}
#line 868 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct option_locus *option_class[10]  ;
#line 872 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct option_locus *optloc_save(unsigned int id , struct option_locus *loc ) 
{ 
  struct option_locus *optloc ;
  char *p ;
  size_t s ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 879
  if ((unsigned long )id >= sizeof(option_class) / sizeof(option_class[0])) {
    {
#line 880
    abort();
    }
  }
#line 881
  s = sizeof(*loc);
#line 882
  if (loc->name) {
    {
#line 883
    tmp = strlen(loc->name);
#line 883
    s += tmp + 1UL;
    }
  }
  {
#line 884
  tmp___0 = xmalloc(s);
#line 884
  optloc = (struct option_locus *)tmp___0;
  }
#line 885
  if (loc->name) {
    {
#line 887
    p = (char *)optloc + sizeof(*loc);
#line 888
    strcpy((char */* __restrict  */)p, (char const   */* __restrict  */)loc->name);
#line 889
    optloc->name = (char const   *)p;
    }
  } else {
#line 892
    optloc->name = (char const   *)((void *)0);
  }
#line 893
  optloc->source = loc->source;
#line 894
  optloc->line = loc->line;
#line 895
  optloc->prev = option_class[id];
#line 896
  option_class[id] = optloc;
#line 897
  return (optloc->prev);
}
}
#line 901 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct option_locus *optloc_lookup(int id ) 
{ 


  {
#line 904
  return (option_class[id]);
}
}
#line 908 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int option_set_in_cl(int id ) 
{ 
  struct option_locus *loc ;
  struct option_locus *tmp ;

  {
  {
#line 911
  tmp = optloc_lookup(id);
#line 911
  loc = tmp;
  }
#line 912
  if (! loc) {
#line 913
    return (0);
  }
#line 914
  return ((unsigned int )loc->source == 1U);
}
}
#line 918 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int optloc_eq(struct option_locus *a , struct option_locus *b ) 
{ 
  int tmp ;

  {
#line 921
  if ((unsigned int )a->source != (unsigned int )b->source) {
#line 922
    return (0);
  }
#line 923
  if ((unsigned int )a->source == 1U) {
#line 924
    return (1);
  }
  {
#line 925
  tmp = strcmp(a->name, b->name);
  }
#line 925
  return (tmp == 0);
}
}
#line 928 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void set_subcommand_option(enum subcommand subcommand ) 
{ 
  char *tmp ;

  {
#line 931
  if ((unsigned int )subcommand_option != 0U) {
#line 931
    if ((unsigned int )subcommand_option != (unsigned int )subcommand) {
      {
#line 933
      while (1) {
        while_continue: /* CIL Label */ ;
#line 933
        if (error_hook) {
          {
#line 933
          (*error_hook)();
          }
        }
        {
#line 933
        tmp = gettext("You may not specify more than one \'-Acdtrux\', \'--delete\' or  \'--test-label\' option");
#line 933
        error(0, 0, (char const   *)tmp);
#line 933
        usage(2);
        }
#line 933
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 936
  subcommand_option = subcommand;
#line 937
  return;
}
}
#line 939 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void set_use_compress_program_option(char const   *string , struct option_locus *loc ) 
{ 
  struct option_locus *p ;
  struct option_locus *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 942
  tmp = optloc_save(0U, loc);
#line 942
  p = tmp;
  }
#line 943
  if (use_compress_program_option) {
    {
#line 943
    tmp___1 = strcmp(use_compress_program_option, string);
    }
#line 943
    if (tmp___1 != 0) {
#line 943
      if ((unsigned int )p->source == 1U) {
        {
#line 946
        while (1) {
          while_continue: /* CIL Label */ ;
#line 946
          if (error_hook) {
            {
#line 946
            (*error_hook)();
            }
          }
          {
#line 946
          tmp___0 = gettext("Conflicting compression options");
#line 946
          error(0, 0, (char const   *)tmp___0);
#line 946
          usage(2);
          }
#line 946
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
#line 948
  use_compress_program_option = string;
#line 949
  return;
}
}
#line 951 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void sigstat(int signo ) 
{ 


  {
  {
#line 954
  compute_duration();
#line 955
  print_total_stats();
#line 957
  signal(signo, & sigstat);
  }
#line 959
  return;
}
}
#line 961 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void stat_on_signal(int signo ) 
{ 


  {
  {
#line 974
  signal(signo, & sigstat);
  }
#line 976
  return;
}
}
#line 981
static void set_stat_signal(char const   *name ) ;
#line 981 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct sigtab  const  sigtab[10]  = 
#line 981
  {      {"SIGUSR1", 10}, 
        {"USR1", 10}, 
        {"SIGUSR2", 12}, 
        {"USR2", 12}, 
        {"SIGHUP", 1}, 
        {"HUP", 1}, 
        {"SIGINT", 2}, 
        {"INT", 2}, 
        {"SIGQUIT", 3}, 
        {"QUIT", 3}};
#line 978 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void set_stat_signal(char const   *name ) 
{ 
  struct sigtab  const  *p ;
  int tmp ;
  char *tmp___0 ;

  {
#line 999
  p = sigtab;
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 999
    if (! ((unsigned long )p < (unsigned long )(sigtab + sizeof(sigtab) / sizeof(sigtab[0])))) {
#line 999
      goto while_break;
    }
    {
#line 1000
    tmp = strcmp((char const   *)p->name, name);
    }
#line 1000
    if (tmp == 0) {
      {
#line 1002
      stat_on_signal((int )p->signo);
      }
#line 1003
      return;
    }
#line 999
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1005
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1005
    if (error_hook) {
      {
#line 1005
      (*error_hook)();
      }
    }
    {
#line 1005
    tmp___0 = gettext("Unknown signal name: %s");
#line 1005
    error(0, 0, (char const   *)tmp___0, name);
#line 1005
    fatal_exit();
    }
#line 1005
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1006
  return;
}
}
#line 1017 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int get_date_or_file(struct tar_args *args___0 , char const   *rpl_option ,
                            char const   *str , struct timespec *ts ) 
{ 
  struct stat st ;
  char *tmp ;
  int tmp___0 ;
  struct timespec  __attribute__((__pure__)) tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  struct textual_date *p ;
  void *tmp___5 ;
  _Bool tmp___6 ;

  {
#line 1021
  if ((int const   )*str == 47) {
#line 1021
    goto _L;
  } else
#line 1021
  if ((int const   )*str == 46) {
    _L: /* CIL Label */ 
    {
#line 1026
    tmp___0 = stat((char const   */* __restrict  */)str, (struct stat */* __restrict  */)(& st));
    }
#line 1026
    if (tmp___0 != 0) {
      {
#line 1028
      stat_error(str);
      }
      {
#line 1029
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1029
        if (error_hook) {
          {
#line 1029
          (*error_hook)();
          }
        }
        {
#line 1029
        tmp = gettext("Date sample file not found");
#line 1029
        error(0, 0, (char const   *)tmp);
#line 1029
        usage(2);
        }
#line 1029
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1031
    tmp___1 = get_stat_mtime((struct stat  const  *)(& st));
#line 1031
    *ts = (struct timespec )tmp___1;
    }
  } else {
    {
#line 1035
    tmp___6 = parse_datetime(ts, str, (struct timespec  const  *)((void *)0));
    }
#line 1035
    if (tmp___6) {
      {
#line 1044
      tmp___5 = xmalloc(sizeof(*p));
#line 1044
      p = (struct textual_date *)tmp___5;
#line 1045
      p->ts = *ts;
#line 1046
      p->rpl_option = rpl_option;
#line 1047
      p->date = xstrdup(str);
#line 1048
      p->next = args___0->textual_date;
#line 1049
      args___0->textual_date = p;
      }
    } else {
      {
#line 1037
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1037
        if (error_hook) {
          {
#line 1037
          (*error_hook)();
          }
        }
        {
#line 1037
        tmp___2 = quote(str);
#line 1037
        tmp___3 = tartime(*ts, (_Bool)0);
#line 1037
        tmp___4 = gettext("Substituting %s for unknown date format %s");
#line 1037
        error(0, 0, (char const   *)tmp___4, tmp___3, tmp___2);
        }
#line 1037
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1039
      ts->tv_nsec = (__syscall_slong_t )0;
#line 1040
      return (1);
    }
  }
#line 1052
  return (0);
}
}
#line 1055 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void report_textual_dates(struct tar_args *args___0 ) 
{ 
  struct textual_date *p ;
  struct textual_date *next ;
  char const   *treated_as ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1059
  p = args___0->textual_date;
  {
#line 1059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1059
    if (! p) {
#line 1059
      goto while_break;
    }
#line 1061
    next = p->next;
#line 1062
    if (verbose_option) {
      {
#line 1064
      tmp = tartime(p->ts, (_Bool)1);
#line 1064
      treated_as = tmp;
#line 1065
      tmp___1 = strcmp((char const   *)p->date, treated_as);
      }
#line 1065
      if (tmp___1 != 0) {
        {
#line 1066
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1066
          if (error_hook) {
            {
#line 1066
            (*error_hook)();
            }
          }
          {
#line 1066
          tmp___0 = gettext("Option %s: Treating date \'%s\' as %s");
#line 1066
          error(0, 0, (char const   *)tmp___0, p->rpl_option, p->date, treated_as);
          }
#line 1066
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
    {
#line 1069
    free((void *)p->date);
#line 1070
    free((void *)p);
#line 1071
    p = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1073
  return;
}
}
#line 1093 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char *tar_help_filter(int key , char const   *text , void *input ) 
{ 
  struct obstack stk___0 ;
  char *s ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tstr ;
  char *tmp___6 ;
  struct obstack *__o ;
  size_t __len ;
  size_t tmp___7 ;
  struct obstack  const  *__o1 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  struct obstack  const  *__o1___0 ;
  char *tmp___8 ;
  struct obstack *__o___1 ;
  size_t __len___1 ;
  size_t tmp___9 ;
  struct obstack  const  *__o1___1 ;
  struct obstack *__o___2 ;
  size_t __len___2 ;
  size_t tmp___10 ;
  struct obstack  const  *__o1___2 ;
  struct obstack *__o___3 ;
  struct obstack  const  *__o1___3 ;
  char *tmp___11 ;
  struct obstack *__o___4 ;
  struct obstack  const  *__o1___4 ;
  char *tmp___12 ;
  struct obstack *__o1___5 ;
  void *__value ;
  char *tmp___13 ;
  char *tmp___14 ;
  struct obstack *__o___5 ;
  void *__obj ;
  char *tmp___15 ;

  {
  {
#line 1105
  if (key == 106) {
#line 1105
    goto case_106;
  }
#line 1109
  if (key == 122) {
#line 1109
    goto case_122;
  }
#line 1113
  if (key == 90) {
#line 1113
    goto case_90;
  }
#line 1117
  if (key == 148) {
#line 1117
    goto case_148;
  }
#line 1121
  if (key == 149) {
#line 1121
    goto case_149;
  }
#line 1125
  if (key == 150) {
#line 1125
    goto case_150;
  }
#line 1128
  if (key == 74) {
#line 1128
    goto case_74;
  }
#line 1132
  if (key == 33554436) {
#line 1132
    goto case_33554436;
  }
#line 1101
  goto switch_default;
  switch_default: /* CIL Label */ 
#line 1102
  s = (char *)text;
#line 1103
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 1106
  tmp = gettext("filter the archive through %s");
#line 1106
  s = xasprintf((char const   *)tmp, "bzip2");
  }
#line 1107
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 1110
  tmp___0 = gettext("filter the archive through %s");
#line 1110
  s = xasprintf((char const   *)tmp___0, "gzip");
  }
#line 1111
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 1114
  tmp___1 = gettext("filter the archive through %s");
#line 1114
  s = xasprintf((char const   *)tmp___1, "compress");
  }
#line 1115
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 1118
  tmp___2 = gettext("filter the archive through %s");
#line 1118
  s = xasprintf((char const   *)tmp___2, "lzip");
  }
#line 1119
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 1122
  tmp___3 = gettext("filter the archive through %s");
#line 1122
  s = xasprintf((char const   *)tmp___3, "lzma");
  }
#line 1123
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 1126
  tmp___4 = gettext("filter the archive through %s");
#line 1126
  s = xasprintf((char const   *)tmp___4, "lzop");
  }
  case_74: /* CIL Label */ 
  {
#line 1129
  tmp___5 = gettext("filter the archive through %s");
#line 1129
  s = xasprintf((char const   *)tmp___5, "xz");
  }
#line 1130
  goto switch_break;
  case_33554436: /* CIL Label */ 
  {
#line 1136
  _obstack_begin(& stk___0, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
#line 1137
  tmp___6 = gettext("Valid arguments for the --quoting-style option are:");
#line 1137
  tstr = (char const   *)tmp___6;
#line 1138
  __o = & stk___0;
#line 1138
  tmp___7 = strlen(tstr);
#line 1138
  __len = tmp___7;
#line 1138
  __o1 = (struct obstack  const  *)__o;
  }
#line 1138
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 1138
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 1138
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)tstr,
         __len);
#line 1138
  __o->next_free += __len;
#line 1139
  __o___0 = & stk___0;
#line 1139
  __len___0 = (size_t )2;
#line 1139
  __o1___0 = (struct obstack  const  *)__o___0;
  }
#line 1139
  if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len___0) {
    {
#line 1139
    _obstack_newchunk(__o___0, __len___0);
    }
  }
  {
#line 1139
  memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)"\n\n",
         __len___0);
#line 1139
  __o___0->next_free += __len___0;
#line 1140
  tar_list_quoting_styles(& stk___0, "  ");
#line 1141
  tmp___8 = gettext("\n*This* tar defaults to:\n");
#line 1141
  tstr = (char const   *)tmp___8;
#line 1142
  __o___1 = & stk___0;
#line 1142
  tmp___9 = strlen(tstr);
#line 1142
  __len___1 = tmp___9;
#line 1142
  __o1___1 = (struct obstack  const  *)__o___1;
  }
#line 1142
  if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___1) {
    {
#line 1142
    _obstack_newchunk(__o___1, __len___1);
    }
  }
  {
#line 1142
  memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)tstr,
         __len___1);
#line 1142
  __o___1->next_free += __len___1;
#line 1143
  s = format_default_settings();
#line 1144
  __o___2 = & stk___0;
#line 1144
  tmp___10 = strlen((char const   *)s);
#line 1144
  __len___2 = tmp___10;
#line 1144
  __o1___2 = (struct obstack  const  *)__o___2;
  }
#line 1144
  if ((size_t )(__o1___2->chunk_limit - __o1___2->next_free) < __len___2) {
    {
#line 1144
    _obstack_newchunk(__o___2, __len___2);
    }
  }
  {
#line 1144
  memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)s,
         __len___2);
#line 1144
  __o___2->next_free += __len___2;
#line 1145
  __o___3 = & stk___0;
#line 1145
  __o1___3 = (struct obstack  const  *)__o___3;
  }
#line 1145
  if ((size_t )(__o1___3->chunk_limit - __o1___3->next_free) < 1UL) {
    {
#line 1145
    _obstack_newchunk(__o___3, (size_t )1);
    }
  }
#line 1145
  tmp___11 = __o___3->next_free;
#line 1145
  (__o___3->next_free) ++;
#line 1145
  *tmp___11 = (char )'\n';
#line 1146
  __o___4 = & stk___0;
#line 1146
  __o1___4 = (struct obstack  const  *)__o___4;
#line 1146
  if ((size_t )(__o1___4->chunk_limit - __o1___4->next_free) < 1UL) {
    {
#line 1146
    _obstack_newchunk(__o___4, (size_t )1);
    }
  }
#line 1146
  tmp___12 = __o___4->next_free;
#line 1146
  (__o___4->next_free) ++;
#line 1146
  *tmp___12 = (char)0;
#line 1147
  __o1___5 = & stk___0;
#line 1147
  __value = (void *)__o1___5->object_base;
#line 1147
  if ((unsigned long )__o1___5->next_free == (unsigned long )__value) {
#line 1147
    __o1___5->maybe_empty_object = 1U;
  }
#line 1147
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1147
    tmp___13 = __o1___5->object_base;
  } else {
#line 1147
    tmp___13 = (char *)0;
  }
#line 1147
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1147
    tmp___14 = __o1___5->object_base;
  } else {
#line 1147
    tmp___14 = (char *)0;
  }
#line 1147
  __o1___5->next_free = tmp___13 + (((size_t )(__o1___5->next_free - tmp___14) + __o1___5->alignment_mask) & ~ __o1___5->alignment_mask);
#line 1147
  if ((size_t )(__o1___5->next_free - (char *)__o1___5->chunk) > (size_t )(__o1___5->chunk_limit - (char *)__o1___5->chunk)) {
#line 1147
    __o1___5->next_free = __o1___5->chunk_limit;
  }
  {
#line 1147
  __o1___5->object_base = __o1___5->next_free;
#line 1147
  s = xstrdup((char const   *)__value);
#line 1148
  __o___5 = & stk___0;
#line 1148
  __obj = (void *)0;
  }
#line 1148
  if ((unsigned long )__obj > (unsigned long )((void *)__o___5->chunk)) {
#line 1148
    if ((unsigned long )__obj < (unsigned long )((void *)__o___5->chunk_limit)) {
#line 1148
      tmp___15 = (char *)__obj;
#line 1148
      __o___5->object_base = tmp___15;
#line 1148
      __o___5->next_free = tmp___15;
    } else {
      {
#line 1148
      _obstack_free(__o___5, __obj);
      }
    }
  } else {
    {
#line 1148
    _obstack_free(__o___5, __obj);
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 1151
  return (s);
}
}
#line 1154 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char *expand_pax_option(struct tar_args *targs , char const   *arg___0 ) 
{ 
  struct obstack stk___0 ;
  char *res ;
  size_t seglen ;
  size_t tmp ;
  char *p ;
  void *tmp___0 ;
  size_t len ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  unsigned short const   **tmp___1 ;
  struct timespec ts ;
  char *tmp___2 ;
  void *tmp___3 ;
  char buf[32] ;
  char const   *s ;
  char const   *tmp___4 ;
  struct obstack *__o___0 ;
  size_t __len___0 ;
  size_t tmp___5 ;
  struct obstack  const  *__o1___0 ;
  struct obstack *__o___1 ;
  size_t __len___1 ;
  struct obstack  const  *__o1___1 ;
  int tmp___6 ;
  struct obstack *__o___2 ;
  size_t __len___2 ;
  struct obstack  const  *__o1___2 ;
  struct obstack *__o___3 ;
  size_t __len___3 ;
  struct obstack  const  *__o1___3 ;
  struct obstack *__o___4 ;
  struct obstack  const  *__o1___4 ;
  char *tmp___7 ;
  struct obstack *__o___5 ;
  struct obstack  const  *__o1___5 ;
  char *tmp___8 ;
  struct obstack *__o1___6 ;
  void *__value ;
  char *tmp___9 ;
  char *tmp___10 ;
  struct obstack *__o___6 ;
  void *__obj ;
  char *tmp___11 ;

  {
  {
#line 1160
  _obstack_begin(& stk___0, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
  }
  {
#line 1161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1161
    if (! *arg___0) {
#line 1161
      goto while_break;
    }
    {
#line 1163
    tmp = strcspn(arg___0, ",");
#line 1163
    seglen = tmp;
#line 1164
    tmp___0 = memchr((void const   *)arg___0, '=', seglen);
#line 1164
    p = (char *)tmp___0;
    }
#line 1165
    if (p) {
#line 1167
      len = (size_t )((p - (char *)arg___0) + 1L);
#line 1168
      __o = & stk___0;
#line 1168
      __len = len;
#line 1168
      __o1 = (struct obstack  const  *)__o;
#line 1168
      if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
        {
#line 1168
        _obstack_newchunk(__o, __len);
        }
      }
      {
#line 1168
      memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)arg___0,
             __len);
#line 1168
      __o->next_free += __len;
#line 1169
      len = seglen - len;
#line 1170
      p ++;
      }
      {
#line 1170
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1170
        if (*p) {
          {
#line 1170
          tmp___1 = __ctype_b_loc();
          }
#line 1170
          if (! ((int const   )*(*tmp___1 + (int )((unsigned char )*p)) & 8192)) {
#line 1170
            goto while_break___0;
          }
        } else {
#line 1170
          goto while_break___0;
        }
#line 1171
        len --;
#line 1170
        p ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1172
      if ((int )*p == 123) {
#line 1172
        if ((int )*(p + (len - 1UL)) == 125) {
          {
#line 1175
          tmp___3 = xmalloc(len);
#line 1175
          tmp___2 = (char *)tmp___3;
#line 1176
          memcpy((void */* __restrict  */)tmp___2, (void const   */* __restrict  */)(p + 1),
                 len - 2UL);
#line 1177
          *(tmp___2 + (len - 2UL)) = (char)0;
#line 1178
          tmp___6 = get_date_or_file(targs, "--pax-option", (char const   *)tmp___2,
                                     & ts);
          }
#line 1178
          if (tmp___6 == 0) {
            {
#line 1181
            tmp___4 = code_timespec(ts, buf);
#line 1181
            s = tmp___4;
#line 1182
            __o___0 = & stk___0;
#line 1182
            tmp___5 = strlen(s);
#line 1182
            __len___0 = tmp___5;
#line 1182
            __o1___0 = (struct obstack  const  *)__o___0;
            }
#line 1182
            if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len___0) {
              {
#line 1182
              _obstack_newchunk(__o___0, __len___0);
              }
            }
            {
#line 1182
            memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)s,
                   __len___0);
#line 1182
            __o___0->next_free += __len___0;
            }
          } else {
#line 1185
            __o___1 = & stk___0;
#line 1185
            __len___1 = len;
#line 1185
            __o1___1 = (struct obstack  const  *)__o___1;
#line 1185
            if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < __len___1) {
              {
#line 1185
              _obstack_newchunk(__o___1, __len___1);
              }
            }
            {
#line 1185
            memcpy((void */* __restrict  */)__o___1->next_free, (void const   */* __restrict  */)p,
                   __len___1);
#line 1185
            __o___1->next_free += __len___1;
            }
          }
          {
#line 1186
          free((void *)tmp___2);
          }
        } else {
#line 1172
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 1189
        __o___2 = & stk___0;
#line 1189
        __len___2 = len;
#line 1189
        __o1___2 = (struct obstack  const  *)__o___2;
#line 1189
        if ((size_t )(__o1___2->chunk_limit - __o1___2->next_free) < __len___2) {
          {
#line 1189
          _obstack_newchunk(__o___2, __len___2);
          }
        }
        {
#line 1189
        memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)p,
               __len___2);
#line 1189
        __o___2->next_free += __len___2;
        }
      }
    } else {
#line 1192
      __o___3 = & stk___0;
#line 1192
      __len___3 = seglen;
#line 1192
      __o1___3 = (struct obstack  const  *)__o___3;
#line 1192
      if ((size_t )(__o1___3->chunk_limit - __o1___3->next_free) < __len___3) {
        {
#line 1192
        _obstack_newchunk(__o___3, __len___3);
        }
      }
      {
#line 1192
      memcpy((void */* __restrict  */)__o___3->next_free, (void const   */* __restrict  */)arg___0,
             __len___3);
#line 1192
      __o___3->next_free += __len___3;
      }
    }
#line 1194
    arg___0 += seglen;
#line 1195
    if (*arg___0) {
#line 1197
      __o___4 = & stk___0;
#line 1197
      __o1___4 = (struct obstack  const  *)__o___4;
#line 1197
      if ((size_t )(__o1___4->chunk_limit - __o1___4->next_free) < 1UL) {
        {
#line 1197
        _obstack_newchunk(__o___4, (size_t )1);
        }
      }
#line 1197
      tmp___7 = __o___4->next_free;
#line 1197
      (__o___4->next_free) ++;
#line 1197
      *tmp___7 = (char )*arg___0;
#line 1198
      arg___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1201
  __o___5 = & stk___0;
#line 1201
  __o1___5 = (struct obstack  const  *)__o___5;
#line 1201
  if ((size_t )(__o1___5->chunk_limit - __o1___5->next_free) < 1UL) {
    {
#line 1201
    _obstack_newchunk(__o___5, (size_t )1);
    }
  }
#line 1201
  tmp___8 = __o___5->next_free;
#line 1201
  (__o___5->next_free) ++;
#line 1201
  *tmp___8 = (char)0;
#line 1202
  __o1___6 = & stk___0;
#line 1202
  __value = (void *)__o1___6->object_base;
#line 1202
  if ((unsigned long )__o1___6->next_free == (unsigned long )__value) {
#line 1202
    __o1___6->maybe_empty_object = 1U;
  }
#line 1202
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1202
    tmp___9 = __o1___6->object_base;
  } else {
#line 1202
    tmp___9 = (char *)0;
  }
#line 1202
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1202
    tmp___10 = __o1___6->object_base;
  } else {
#line 1202
    tmp___10 = (char *)0;
  }
#line 1202
  __o1___6->next_free = tmp___9 + (((size_t )(__o1___6->next_free - tmp___10) + __o1___6->alignment_mask) & ~ __o1___6->alignment_mask);
#line 1202
  if ((size_t )(__o1___6->next_free - (char *)__o1___6->chunk) > (size_t )(__o1___6->chunk_limit - (char *)__o1___6->chunk)) {
#line 1202
    __o1___6->next_free = __o1___6->chunk_limit;
  }
  {
#line 1202
  __o1___6->object_base = __o1___6->next_free;
#line 1202
  res = xstrdup((char const   *)__value);
#line 1203
  __o___6 = & stk___0;
#line 1203
  __obj = (void *)0;
  }
#line 1203
  if ((unsigned long )__obj > (unsigned long )((void *)__o___6->chunk)) {
#line 1203
    if ((unsigned long )__obj < (unsigned long )((void *)__o___6->chunk_limit)) {
#line 1203
      tmp___11 = (char *)__obj;
#line 1203
      __o___6->object_base = tmp___11;
#line 1203
      __o___6->next_free = tmp___11;
    } else {
      {
#line 1203
      _obstack_free(__o___6, __obj);
      }
    }
  } else {
    {
#line 1203
    _obstack_free(__o___6, __obj);
    }
  }
#line 1204
  return (res);
}
}
#line 1208 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static uintmax_t parse_owner_group(char *arg___0 , uintmax_t field_max , char const   **name_option ) 
{ 
  uintmax_t u ;
  char *end ;
  char const   *name ;
  char const   *invalid_num ;
  char *colon ;
  char *tmp ;
  char const   *num ;
  strtol_error tmp___0 ;
  uintmax_t u1 ;
  strtol_error tmp___1 ;
  unsigned int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 1211
  u = 0xffffffffffffffffUL;
#line 1213
  name = (char const   *)0;
#line 1214
  invalid_num = (char const   *)0;
#line 1215
  tmp = strchr((char const   *)arg___0, ':');
#line 1215
  colon = tmp;
  }
#line 1217
  if (colon) {
#line 1219
    num = (char const   *)(colon + 1);
#line 1220
    *colon = (char )'\000';
#line 1221
    if (*arg___0) {
#line 1222
      name = (char const   *)arg___0;
    }
#line 1223
    if (num) {
      {
#line 1223
      tmp___0 = xstrtoumax(num, & end, 10, & u, "");
      }
#line 1223
      if ((unsigned int )tmp___0 == 0U) {
#line 1223
        if (! (u <= field_max)) {
#line 1225
          invalid_num = num;
        }
      } else {
#line 1225
        invalid_num = num;
      }
    }
  } else {
#line 1230
    if (48 <= (int )*arg___0) {
#line 1230
      if ((int )*arg___0 <= 57) {
        {
#line 1230
        tmp___1 = xstrtoumax((char const   *)arg___0, & end, 10, & u1, "");
#line 1230
        tmp___2 = (unsigned int )tmp___1;
        }
      } else {
#line 1230
        tmp___2 = 4U;
      }
    } else {
#line 1230
      tmp___2 = 4U;
    }
    {
#line 1238
    if (tmp___2 == 0U) {
#line 1238
      goto case_0;
    }
#line 1245
    if (tmp___2 == 1U) {
#line 1245
      goto case_1;
    }
#line 1234
    goto switch_default;
    switch_default: /* CIL Label */ 
#line 1235
    name = (char const   *)arg___0;
#line 1236
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1239
    if (u1 <= field_max) {
#line 1241
      u = u1;
#line 1242
      goto switch_break;
    }
    case_1: /* CIL Label */ 
#line 1246
    invalid_num = (char const   *)arg___0;
#line 1247
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1251
  if (invalid_num) {
    {
#line 1252
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1252
      if (error_hook) {
        {
#line 1252
        (*error_hook)();
        }
      }
      {
#line 1252
      tmp___3 = gettext("Invalid owner or group ID");
#line 1252
      tmp___4 = quotearg_colon(invalid_num);
#line 1252
      error(0, 0, "%s: %s", tmp___4, tmp___3);
#line 1252
      fatal_exit();
      }
#line 1252
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1254
  if (name) {
#line 1255
    *name_option = name;
  }
#line 1256
  return (u);
}
}
#line 1261 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   * const  sort_mode_arg[4]  = {      (char const   */* const  */)"none",      (char const   */* const  */)"name",      (char const   */* const  */)"inode",      (char const   */* const  */)((void *)0)};
#line 1270 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int sort_mode_flag[3]  = {      0,      1,      2};
#line 1280 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   * const  hole_detection_args[3]  = {      (char const   */* const  */)"raw",      (char const   */* const  */)"seek",      (char const   */* const  */)((void *)0)};
#line 1285 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int const   hole_detection_types[2]  = {      (int const   )1,      (int const   )2};
#line 1297
static void set_old_files_option(int code , struct option_locus *loc ) ;
#line 1297 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   * const  code_to_opt[7]  = {      (char const   */* const  */)"--overwrite-dir",      (char const   */* const  */)"--no-overwrite-dir",      (char const   */* const  */)"--overwrite",      (char const   */* const  */)"--unlink-first", 
        (char const   */* const  */)"--keep-old-files",      (char const   */* const  */)"--skip-old-files",      (char const   */* const  */)"--keep-newer-files"};
#line 1293 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void set_old_files_option(int code , struct option_locus *loc ) 
{ 
  struct option_locus *prev ;
  int tmp ;

  {
  {
#line 1307
  prev = optloc_save(9U, loc);
  }
#line 1308
  if (prev) {
    {
#line 1308
    tmp = optloc_eq(loc, prev);
    }
#line 1308
    if (tmp) {
#line 1308
      if ((unsigned int )code != (unsigned int )old_files_option) {
        {
#line 1309
        option_conflict_error((char const   *)code_to_opt[code], (char const   *)code_to_opt[old_files_option]);
        }
      }
    }
  }
#line 1311
  old_files_option = (enum old_files )code;
#line 1312
  return;
}
}
#line 1315 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static error_t parse_opt(int key , char *arg___0 , struct argp_state *state ) 
{ 
  struct tar_args *args___0 ;
  uintmax_t u ;
  char *tmp ;
  char *tmp___0 ;
  strtol_error tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  uintmax_t u___0 ;
  char *p ;
  char *tmp___4 ;
  char *tmp___5 ;
  strtol_error tmp___6 ;
  char *tmp___7 ;
  char *p___0 ;
  unsigned long tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  ptrdiff_t tmp___12 ;
  char *p___1 ;
  unsigned long tmp___13 ;
  char *tmp___14 ;
  unsigned long tmp___15 ;
  char *tmp___16 ;
  ptrdiff_t tmp___17 ;
  char *p___2 ;
  unsigned long tmp___19 ;
  char *tmp___20 ;
  uintmax_t u___1 ;
  uintmax_t tmp___21 ;
  char *tmp___22 ;
  uintmax_t u___2 ;
  char *tmp___23 ;
  char *tmp___24 ;
  strtol_error tmp___25 ;
  uintmax_t u___3 ;
  uintmax_t tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;
  uintmax_t u___4 ;
  char *tmp___29 ;
  char *tmp___30 ;
  strtol_error tmp___31 ;
  char *tmp___32 ;
  char *s ;
  char *tmp___33 ;
  uintmax_t u___5 ;
  char *tmp___34 ;
  char *tmp___35 ;
  strtol_error tmp___36 ;
  ptrdiff_t tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;

  {
#line 1318
  args___0 = (struct tar_args *)state->input;
  {
#line 1322
  if (key == 0) {
#line 1322
    goto case_0;
  }
#line 1328
  if (key == 65) {
#line 1328
    goto case_65;
  }
#line 1332
  if (key == 97) {
#line 1332
    goto case_97;
  }
#line 1336
  if (key == 155) {
#line 1336
    goto case_155;
  }
#line 1340
  if (key == 98) {
#line 1340
    goto case_98;
  }
#line 1352
  if (key == 66) {
#line 1352
    goto case_66;
  }
#line 1363
  if (key == 99) {
#line 1363
    goto case_99;
  }
#line 1367
  if (key == 134) {
#line 1367
    goto case_134;
  }
#line 1371
  if (key == 100) {
#line 1371
    goto case_100;
  }
#line 1375
  if (key == 102) {
#line 1375
    goto case_102;
  }
#line 1384
  if (key == 70) {
#line 1384
    goto case_70;
  }
#line 1392
  if (key == 139) {
#line 1392
    goto case_139;
  }
#line 1396
  if (key == 103) {
#line 1396
    goto case_103;
  }
#line 1402
  if (key == 71) {
#line 1402
    goto case_71;
  }
#line 1410
  if (key == 104) {
#line 1410
    goto case_104;
  }
#line 1415
  if (key == 136) {
#line 1415
    goto case_136;
  }
#line 1419
  if (key == 105) {
#line 1419
    goto case_105;
  }
#line 1427
  if (key == 106) {
#line 1427
    goto case_106;
  }
#line 1431
  if (key == 74) {
#line 1431
    goto case_74;
  }
#line 1435
  if (key == 107) {
#line 1435
    goto case_107;
  }
#line 1440
  if (key == 75) {
#line 1440
    goto case_75;
  }
#line 1446
  if (key == 169) {
#line 1446
    goto case_169;
  }
#line 1452
  if (key == 170) {
#line 1452
    goto case_170;
  }
#line 1458
  if (key == 108) {
#line 1458
    goto case_108;
  }
#line 1462
  if (key == 76) {
#line 1462
    goto case_76;
  }
#line 1478
  if (key == 147) {
#line 1478
    goto case_147;
  }
#line 1487
  if (key == 148) {
#line 1487
    goto case_148;
  }
#line 1491
  if (key == 149) {
#line 1491
    goto case_149;
  }
#line 1495
  if (key == 150) {
#line 1495
    goto case_150;
  }
#line 1499
  if (key == 109) {
#line 1499
    goto case_109;
  }
#line 1503
  if (key == 77) {
#line 1503
    goto case_77;
  }
#line 1510
  if (key == 152) {
#line 1510
    goto case_152;
  }
#line 1516
  if (key == 110) {
#line 1516
    goto case_110;
  }
#line 1520
  if (key == 163) {
#line 1520
    goto case_163;
  }
#line 1524
  if (key == 78) {
#line 1524
    goto case_78;
  }
#line 1528
  if (key == 153) {
#line 1528
    goto case_153;
  }
#line 1537
  if (key == 111) {
#line 1537
    goto case_111;
  }
#line 1541
  if (key == 79) {
#line 1541
    goto case_79;
  }
#line 1545
  if (key == 112) {
#line 1545
    goto case_112;
  }
#line 1549
  if (key == 80) {
#line 1549
    goto case_80;
  }
#line 1554
  if (key == 114) {
#line 1554
    goto case_114;
  }
#line 1558
  if (key == 82) {
#line 1558
    goto case_82;
  }
#line 1569
  if (key == 115) {
#line 1569
    goto case_115;
  }
#line 1575
  if (key == 83) {
#line 1575
    goto case_83;
  }
#line 1579
  if (key == 191) {
#line 1579
    goto case_191;
  }
#line 1583
  if (key == 193) {
#line 1583
    goto case_193;
  }
#line 1589
  if (key == 194) {
#line 1589
    goto case_194;
  }
#line 1605
  if (key == 116) {
#line 1605
    goto case_116;
  }
#line 1610
  if (key == 197) {
#line 1610
    goto case_197;
  }
#line 1614
  if (key == 117) {
#line 1614
    goto case_117;
  }
#line 1618
  if (key == 85) {
#line 1618
    goto case_85;
  }
#line 1622
  if (key == 201) {
#line 1622
    goto case_201;
  }
#line 1626
  if (key == 118) {
#line 1626
    goto case_118;
  }
#line 1631
  if (key == 86) {
#line 1631
    goto case_86;
  }
#line 1635
  if (key == 119) {
#line 1635
    goto case_119;
  }
#line 1639
  if (key == 87) {
#line 1639
    goto case_87;
  }
#line 1644
  if (key == 120) {
#line 1644
    goto case_120;
  }
#line 1648
  if (key == 122) {
#line 1648
    goto case_122;
  }
#line 1652
  if (key == 90) {
#line 1652
    goto case_90;
  }
#line 1656
  if (key == 129) {
#line 1656
    goto case_129;
  }
#line 1668
  if (key == 131) {
#line 1668
    goto case_131;
  }
#line 1672
  if (key == 156) {
#line 1672
    goto case_156;
  }
#line 1676
  if (key == 132) {
#line 1676
    goto case_132;
  }
#line 1695
  if (key == 133) {
#line 1695
    goto case_133;
  }
#line 1699
  if (key == 130) {
#line 1699
    goto case_130;
  }
#line 1705
  if (key == 135) {
#line 1705
    goto case_135;
  }
#line 1709
  if (key == 157) {
#line 1709
    goto case_157;
  }
#line 1713
  if (key == 137) {
#line 1713
    goto case_137;
  }
#line 1717
  if (key == 138) {
#line 1717
    goto case_138;
  }
#line 1721
  if (key == 72) {
#line 1721
    goto case_72;
  }
#line 1725
  if (key == 144) {
#line 1725
    goto case_144;
  }
#line 1729
  if (key == 142) {
#line 1729
    goto case_142;
  }
#line 1733
  if (key == 143) {
#line 1733
    goto case_143;
  }
#line 1737
  if (key == 145) {
#line 1737
    goto case_145;
  }
#line 1741
  if (key == 146) {
#line 1741
    goto case_146;
  }
#line 1745
  if (key == 140) {
#line 1745
    goto case_140;
  }
#line 1760
  if (key == 141) {
#line 1760
    goto case_141;
  }
#line 1764
  if (key == 151) {
#line 1764
    goto case_151;
  }
#line 1772
  if (key == 158) {
#line 1772
    goto case_158;
  }
#line 1776
  if (key == 159) {
#line 1776
    goto case_159;
  }
#line 1780
  if (key == 160) {
#line 1780
    goto case_160;
  }
#line 1785
  if (key == 166) {
#line 1785
    goto case_166;
  }
#line 1789
  if (key == 167) {
#line 1789
    goto case_167;
  }
#line 1804
  if (key == 168) {
#line 1804
    goto case_168;
  }
#line 1808
  if (key == 171) {
#line 1808
    goto case_171;
  }
#line 1812
  if (key == 172) {
#line 1812
    goto case_172;
  }
#line 1816
  if (key == 173) {
#line 1816
    goto case_173;
  }
#line 1831
  if (key == 174) {
#line 1831
    goto case_174;
  }
#line 1835
  if (key == 177) {
#line 1835
    goto case_177;
  }
#line 1840
  if (key == 178) {
#line 1840
    goto case_178;
  }
#line 1844
  if (key == 175) {
#line 1844
    goto case_175;
  }
#line 1853
  if (key == 176) {
#line 1853
    goto case_176;
  }
#line 1857
  if (key == 179) {
#line 1857
    goto case_179;
  }
#line 1873
  if (key == 180) {
#line 1873
    goto case_180;
  }
#line 1877
  if (key == 181) {
#line 1877
    goto case_181;
  }
#line 1881
  if (key == 182) {
#line 1881
    goto case_182;
  }
#line 1885
  if (key == 183) {
#line 1885
    goto case_183;
  }
#line 1889
  if (key == 184) {
#line 1889
    goto case_184;
  }
#line 1893
  if (key == 187) {
#line 1893
    goto case_187;
  }
#line 1902
  if (key == 189) {
#line 1902
    goto case_189;
  }
#line 1907
  if (key == 195) {
#line 1907
    goto case_195;
  }
#line 1918
  if (key == 188) {
#line 1918
    goto case_188;
  }
#line 1922
  if (key == 190) {
#line 1922
    goto case_190;
  }
#line 1926
  if (key == 192) {
#line 1926
    goto case_192;
  }
#line 1931
  if (key == 196) {
#line 1931
    goto case_196;
  }
#line 1936
  if (key == 199) {
#line 1936
    goto case_199;
  }
#line 1942
  if (key == 198) {
#line 1942
    goto case_198;
  }
#line 1949
  if (key == 200) {
#line 1949
    goto case_200;
  }
#line 1953
  if (key == 73) {
#line 1953
    goto case_73;
  }
#line 1957
  if (key == 202) {
#line 1957
    goto case_202;
  }
#line 1961
  if (key == 161) {
#line 1961
    goto case_161;
  }
#line 1965
  if (key == 162) {
#line 1965
    goto case_162;
  }
#line 1969
  if (key == 128) {
#line 1969
    goto case_128;
  }
#line 1974
  if (key == 154) {
#line 1974
    goto case_154;
  }
#line 1978
  if (key == 186) {
#line 1978
    goto case_186;
  }
#line 1983
  if (key == 164) {
#line 1983
    goto case_164;
  }
#line 1987
  if (key == 204) {
#line 1987
    goto case_204;
  }
#line 1991
  if (key == 165) {
#line 1991
    goto case_165;
  }
#line 1996
  if (key == 205) {
#line 1996
    goto case_205;
  }
#line 1996
  if (key == 206) {
#line 1996
    goto case_205;
  }
#line 2001
  if (key == 185) {
#line 2001
    goto case_185;
  }
#line 2005
  if (key == 203) {
#line 2005
    goto case_203;
  }
#line 2016
  if (key == 55) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 54) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 53) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 52) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 51) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 50) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 49) {
#line 2016
    goto case_55;
  }
#line 2016
  if (key == 48) {
#line 2016
    goto case_55;
  }
#line 2073
  if (key == 16777221) {
#line 2073
    goto case_16777221;
  }
#line 2081
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1324
  name_add_name((char const   *)arg___0);
#line 1325
  args___0->input_files = (_Bool)1;
  }
#line 1326
  goto switch_break;
  case_65: /* CIL Label */ 
  {
#line 1329
  set_subcommand_option((enum subcommand )2);
  }
#line 1330
  goto switch_break;
  case_97: /* CIL Label */ 
#line 1333
  args___0->compress_autodetect = 1;
#line 1334
  goto switch_break;
  case_155: /* CIL Label */ 
#line 1337
  args___0->compress_autodetect = 0;
#line 1338
  goto switch_break;
  case_98: /* CIL Label */ 
  {
#line 1343
  tmp___1 = xstrtoumax((char const   *)arg___0, (char **)0, 10, & u, "");
  }
#line 1343
  if ((unsigned int )tmp___1 == 0U) {
#line 1343
    blocking_factor = (int )u;
#line 1343
    if (u == (uintmax_t )blocking_factor) {
#line 1343
      if (0 < blocking_factor) {
#line 1343
        record_size = u * 512UL;
#line 1343
        if (! (u == record_size / 512UL)) {
#line 1343
          goto _L___1;
        }
      } else {
#line 1343
        goto _L___1;
      }
    } else {
#line 1343
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 1347
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1347
      if (error_hook) {
        {
#line 1347
        (*error_hook)();
        }
      }
      {
#line 1347
      tmp = gettext("Invalid blocking factor");
#line 1347
      tmp___0 = quotearg_colon((char const   *)arg___0);
#line 1347
      error(0, 0, "%s: %s", tmp___0, tmp);
#line 1347
      usage(2);
      }
#line 1347
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1350
  goto switch_break;
  case_66: /* CIL Label */ 
#line 1360
  read_full_records_option = (_Bool)1;
#line 1361
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 1364
  set_subcommand_option((enum subcommand )3);
  }
#line 1365
  goto switch_break;
  case_134: /* CIL Label */ 
#line 1368
  set_mtime_option = (enum set_mtime_option_mode )2;
#line 1369
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 1372
  set_subcommand_option((enum subcommand )5);
  }
#line 1373
  goto switch_break;
  case_102: /* CIL Label */ 
#line 1376
  if (archive_names == allocated_archive_names) {
    {
#line 1377
    tmp___2 = x2nrealloc((void *)archive_name_array, & allocated_archive_names, sizeof(*(archive_name_array + 0)));
#line 1377
    archive_name_array = (char const   **)tmp___2;
    }
  }
#line 1381
  tmp___3 = archive_names;
#line 1381
  archive_names ++;
#line 1381
  *(archive_name_array + tmp___3) = (char const   *)arg___0;
#line 1382
  goto switch_break;
  case_70: /* CIL Label */ 
#line 1388
  info_script_option = (char const   *)arg___0;
#line 1389
  multi_volume_option = (_Bool)1;
#line 1390
  goto switch_break;
  case_139: /* CIL Label */ 
#line 1393
  full_time_option = (_Bool)1;
#line 1394
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 1397
  optloc_save(2U, args___0->loc);
#line 1398
  listed_incremental_option = (char const   *)arg___0;
#line 1399
  after_date_option = 1;
  }
  case_71: /* CIL Label */ 
#line 1407
  incremental_option = (_Bool)1;
#line 1408
  goto switch_break;
  case_104: /* CIL Label */ 
#line 1412
  dereference_option = (_Bool)1;
#line 1413
  goto switch_break;
  case_136: /* CIL Label */ 
#line 1416
  hard_dereference_option = (_Bool)1;
#line 1417
  goto switch_break;
  case_105: /* CIL Label */ 
#line 1424
  ignore_zeros_option = (_Bool)1;
#line 1425
  goto switch_break;
  case_106: /* CIL Label */ 
  {
#line 1428
  set_use_compress_program_option("bzip2", args___0->loc);
  }
#line 1429
  goto switch_break;
  case_74: /* CIL Label */ 
  {
#line 1432
  set_use_compress_program_option("xz", args___0->loc);
  }
#line 1433
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 1437
  set_old_files_option(4, args___0->loc);
  }
#line 1438
  goto switch_break;
  case_75: /* CIL Label */ 
  {
#line 1441
  optloc_save(5U, args___0->loc);
#line 1442
  starting_file_option = (_Bool)1;
#line 1443
  addname((char const   *)arg___0, 0, (_Bool)1, (struct name *)((void *)0));
  }
#line 1444
  goto switch_break;
  case_169: /* CIL Label */ 
#line 1449
  one_file_system_option = (_Bool)1;
#line 1450
  goto switch_break;
  case_170: /* CIL Label */ 
  {
#line 1453
  optloc_save(7U, args___0->loc);
#line 1454
  one_top_level_option = (_Bool)1;
#line 1455
  one_top_level_dir = arg___0;
  }
#line 1456
  goto switch_break;
  case_108: /* CIL Label */ 
#line 1459
  check_links_option = 1;
#line 1460
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 1467
  tmp___6 = xstrtoumax((char const   *)arg___0, & p, 10, & u___0, "bBcGgkKMmPTtw");
  }
#line 1467
  if ((unsigned int )tmp___6 != 0U) {
    {
#line 1468
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1468
      if (error_hook) {
        {
#line 1468
        (*error_hook)();
        }
      }
      {
#line 1468
      tmp___4 = gettext("Invalid tape length");
#line 1468
      tmp___5 = quotearg_colon((char const   *)arg___0);
#line 1468
      error(0, 0, "%s: %s", tmp___5, tmp___4);
#line 1468
      usage(2);
      }
#line 1468
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1470
  if ((unsigned long )p > (unsigned long )arg___0) {
    {
#line 1470
    tmp___7 = strchr("bBcGgkKMmPTtw", (int )*(p + -1));
    }
#line 1470
    if (tmp___7) {
#line 1473
      tape_length_option = (tarlong )u___0;
    } else {
#line 1471
      tape_length_option = (tarlong )1024 * (tarlong )u___0;
    }
  } else {
#line 1473
    tape_length_option = (tarlong )u___0;
  }
#line 1474
  multi_volume_option = (_Bool)1;
#line 1476
  goto switch_break;
  case_147: /* CIL Label */ 
  {
#line 1481
  tmp___8 = strtoul((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& p___0),
                    10);
#line 1481
  incremental_level = (int )tmp___8;
  }
#line 1482
  if (*p___0) {
    {
#line 1483
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1483
      if (error_hook) {
        {
#line 1483
        (*error_hook)();
        }
      }
      {
#line 1483
      tmp___9 = gettext("Invalid incremental level value");
#line 1483
      error(0, 0, (char const   *)tmp___9);
#line 1483
      usage(2);
      }
#line 1483
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1485
  goto switch_break;
  case_148: /* CIL Label */ 
  {
#line 1488
  set_use_compress_program_option("lzip", args___0->loc);
  }
#line 1489
  goto switch_break;
  case_149: /* CIL Label */ 
  {
#line 1492
  set_use_compress_program_option("lzma", args___0->loc);
  }
#line 1493
  goto switch_break;
  case_150: /* CIL Label */ 
  {
#line 1496
  set_use_compress_program_option("lzop", args___0->loc);
  }
#line 1497
  goto switch_break;
  case_109: /* CIL Label */ 
#line 1500
  touch_option = (_Bool)1;
#line 1501
  goto switch_break;
  case_77: /* CIL Label */ 
#line 1507
  multi_volume_option = (_Bool)1;
#line 1508
  goto switch_break;
  case_152: /* CIL Label */ 
  {
#line 1511
  get_date_or_file(args___0, "--mtime", (char const   *)arg___0, & mtime_option);
  }
#line 1512
  if ((unsigned int )set_mtime_option == 0U) {
#line 1513
    set_mtime_option = (enum set_mtime_option_mode )1;
  }
#line 1514
  goto switch_break;
  case_110: /* CIL Label */ 
#line 1517
  seek_option = 1;
#line 1518
  goto switch_break;
  case_163: /* CIL Label */ 
#line 1521
  seek_option = 0;
#line 1522
  goto switch_break;
  case_78: /* CIL Label */ 
#line 1525
  after_date_option = 1;
  case_153: /* CIL Label */ 
#line 1529
  if (0L <= newer_mtime_option.tv_nsec) {
    {
#line 1530
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1530
      if (error_hook) {
        {
#line 1530
        (*error_hook)();
        }
      }
      {
#line 1530
      tmp___10 = gettext("More than one threshold date");
#line 1530
      error(0, 0, (char const   *)tmp___10);
#line 1530
      usage(2);
      }
#line 1530
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 1531
  if (key == 153) {
#line 1531
    tmp___11 = "--newer-mtime";
  } else {
#line 1531
    tmp___11 = "--after-date";
  }
  {
#line 1531
  get_date_or_file(args___0, tmp___11, (char const   *)arg___0, & newer_mtime_option);
#line 1534
  optloc_save(3U, args___0->loc);
  }
#line 1535
  goto switch_break;
  case_111: /* CIL Label */ 
#line 1538
  args___0->o_option = (_Bool)1;
#line 1539
  goto switch_break;
  case_79: /* CIL Label */ 
#line 1542
  to_stdout_option = (_Bool)1;
#line 1543
  goto switch_break;
  case_112: /* CIL Label */ 
#line 1546
  same_permissions_option = 1;
#line 1547
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 1550
  optloc_save(8U, args___0->loc);
#line 1551
  absolute_names_option = (_Bool)1;
  }
#line 1552
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 1555
  set_subcommand_option((enum subcommand )1);
  }
#line 1556
  goto switch_break;
  case_82: /* CIL Label */ 
#line 1566
  block_number_option = (_Bool)1;
#line 1567
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 1571
  optloc_save(6U, args___0->loc);
#line 1572
  same_order_option = (_Bool)1;
  }
#line 1573
  goto switch_break;
  case_83: /* CIL Label */ 
#line 1576
  sparse_option = (_Bool)1;
#line 1577
  goto switch_break;
  case_191: /* CIL Label */ 
  {
#line 1580
  set_old_files_option(5, args___0->loc);
  }
#line 1581
  goto switch_break;
  case_193: /* CIL Label */ 
  {
#line 1584
  tmp___12 = __xargmatch_internal("--hole-detection", (char const   *)arg___0, hole_detection_args,
                                  (char const   *)(hole_detection_types), sizeof(hole_detection_types[0]),
                                  argmatch_die);
#line 1584
  hole_detection = (enum hole_detection_method )hole_detection_types[tmp___12];
#line 1586
  sparse_option = (_Bool)1;
  }
#line 1587
  goto switch_break;
  case_194: /* CIL Label */ 
  {
#line 1590
  sparse_option = (_Bool)1;
#line 1593
  tmp___13 = strtoul((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& p___1),
                     10);
#line 1593
  tar_sparse_major = (unsigned int )tmp___13;
  }
#line 1594
  if (*p___1) {
#line 1596
    if ((int )*p___1 != 46) {
      {
#line 1597
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1597
        if (error_hook) {
          {
#line 1597
          (*error_hook)();
          }
        }
        {
#line 1597
        tmp___14 = gettext("Invalid sparse version value");
#line 1597
        error(0, 0, (char const   *)tmp___14);
#line 1597
        usage(2);
        }
#line 1597
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
    {
#line 1598
    tmp___15 = strtoul((char const   */* __restrict  */)(p___1 + 1), (char **/* __restrict  */)(& p___1),
                       10);
#line 1598
    tar_sparse_minor = (unsigned int )tmp___15;
    }
#line 1599
    if (*p___1) {
      {
#line 1600
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1600
        if (error_hook) {
          {
#line 1600
          (*error_hook)();
          }
        }
        {
#line 1600
        tmp___16 = gettext("Invalid sparse version value");
#line 1600
        error(0, 0, (char const   *)tmp___16);
#line 1600
        usage(2);
        }
#line 1600
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 1603
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 1606
  set_subcommand_option((enum subcommand )7);
#line 1607
  verbose_option ++;
  }
#line 1608
  goto switch_break;
  case_197: /* CIL Label */ 
  {
#line 1611
  set_subcommand_option((enum subcommand )9);
  }
#line 1612
  goto switch_break;
  case_117: /* CIL Label */ 
  {
#line 1615
  set_subcommand_option((enum subcommand )8);
  }
#line 1616
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 1619
  set_old_files_option(3, args___0->loc);
  }
#line 1620
  goto switch_break;
  case_201: /* CIL Label */ 
#line 1623
  utc_option = (_Bool)1;
#line 1624
  goto switch_break;
  case_118: /* CIL Label */ 
#line 1627
  verbose_option ++;
#line 1628
  warning_option |= 5779456;
#line 1629
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1632
  volume_label_option = (char const   *)arg___0;
#line 1633
  goto switch_break;
  case_119: /* CIL Label */ 
#line 1636
  interactive_option = (_Bool)1;
#line 1637
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 1640
  optloc_save(4U, args___0->loc);
#line 1641
  verify_option = (_Bool)1;
  }
#line 1642
  goto switch_break;
  case_120: /* CIL Label */ 
  {
#line 1645
  set_subcommand_option((enum subcommand )6);
  }
#line 1646
  goto switch_break;
  case_122: /* CIL Label */ 
  {
#line 1649
  set_use_compress_program_option("gzip", args___0->loc);
  }
#line 1650
  goto switch_break;
  case_90: /* CIL Label */ 
  {
#line 1653
  set_use_compress_program_option("compress", args___0->loc);
  }
#line 1654
  goto switch_break;
  case_129: /* CIL Label */ 
#line 1657
  if (arg___0) {
    {
#line 1657
    tmp___17 = __xargmatch_internal("--atime-preserve", (char const   *)arg___0, atime_preserve_args,
                                    (char const   *)(atime_preserve_types), sizeof(atime_preserve_types[0]),
                                    argmatch_die);
#line 1657
    atime_preserve_option = (enum atime_preserve )atime_preserve_types[tmp___17];
    }
  } else {
#line 1657
    atime_preserve_option = (enum atime_preserve )1;
  }
#line 1666
  goto switch_break;
  case_131: /* CIL Label */ 
#line 1669
  check_device_option = (_Bool)1;
#line 1670
  goto switch_break;
  case_156: /* CIL Label */ 
#line 1673
  check_device_option = (_Bool)0;
#line 1674
  goto switch_break;
  case_132: /* CIL Label */ 
#line 1677
  if (arg___0) {
#line 1681
    if ((int )*arg___0 == 46) {
      {
#line 1683
      checkpoint_compile_action(".");
#line 1684
      arg___0 ++;
      }
    }
    {
#line 1686
    tmp___19 = strtoul((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& p___2),
                       0);
#line 1686
    checkpoint_option = (unsigned int )tmp___19;
    }
#line 1687
    if (*p___2) {
      {
#line 1688
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1688
        if (error_hook) {
          {
#line 1688
          (*error_hook)();
          }
        }
        {
#line 1688
        tmp___20 = gettext("--checkpoint value is not an integer");
#line 1688
        error(0, 0, (char const   *)tmp___20);
#line 1688
        fatal_exit();
        }
#line 1688
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  } else {
#line 1692
    checkpoint_option = 10U;
  }
#line 1693
  goto switch_break;
  case_133: /* CIL Label */ 
  {
#line 1696
  checkpoint_compile_action((char const   *)arg___0);
  }
#line 1697
  goto switch_break;
  case_130: /* CIL Label */ 
#line 1700
  backup_option = (_Bool)1;
#line 1701
  if (arg___0) {
#line 1702
    args___0->version_control_string = (char const   *)arg___0;
  }
#line 1703
  goto switch_break;
  case_135: /* CIL Label */ 
#line 1706
  delay_directory_restore_option = (_Bool)1;
#line 1707
  goto switch_break;
  case_157: /* CIL Label */ 
#line 1710
  delay_directory_restore_option = (_Bool)0;
#line 1711
  goto switch_break;
  case_137: /* CIL Label */ 
  {
#line 1714
  set_subcommand_option((enum subcommand )4);
  }
#line 1715
  goto switch_break;
  case_138: /* CIL Label */ 
#line 1718
  force_local_option = (_Bool)1;
#line 1719
  goto switch_break;
  case_72: /* CIL Label */ 
  {
#line 1722
  set_archive_format((char const   *)arg___0);
  }
#line 1723
  goto switch_break;
  case_144: /* CIL Label */ 
#line 1726
  index_file_name = (char const   *)arg___0;
#line 1727
  goto switch_break;
  case_142: /* CIL Label */ 
#line 1730
  ignore_command_error_option = (_Bool)1;
#line 1731
  goto switch_break;
  case_143: /* CIL Label */ 
#line 1734
  ignore_failed_read_option = (_Bool)1;
#line 1735
  goto switch_break;
  case_145: /* CIL Label */ 
#line 1738
  keep_directory_symlink_option = (_Bool)1;
#line 1739
  goto switch_break;
  case_146: /* CIL Label */ 
  {
#line 1742
  set_old_files_option(6, args___0->loc);
  }
#line 1743
  goto switch_break;
  case_140: /* CIL Label */ 
  {
#line 1747
  tmp___21 = parse_owner_group(arg___0, (uintmax_t )((gid_t )-1), & group_name_option);
#line 1747
  u___1 = tmp___21;
  }
#line 1749
  if (u___1 == 0xffffffffffffffffUL) {
#line 1751
    group_option = (gid_t )-1;
#line 1752
    if (group_name_option) {
      {
#line 1753
      gname_to_gid(group_name_option, & group_option);
      }
    }
  } else {
#line 1756
    group_option = (gid_t )u___1;
  }
#line 1758
  goto switch_break;
  case_141: /* CIL Label */ 
  {
#line 1761
  group_map_read((char const   *)arg___0);
  }
#line 1762
  goto switch_break;
  case_151: /* CIL Label */ 
  {
#line 1765
  mode_option = mode_compile((char const   *)arg___0);
  }
#line 1766
  if (! mode_option) {
    {
#line 1767
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1767
      if (error_hook) {
        {
#line 1767
        (*error_hook)();
        }
      }
      {
#line 1767
      tmp___22 = gettext("Invalid mode given on option");
#line 1767
      error(0, 0, (char const   *)tmp___22);
#line 1767
      fatal_exit();
      }
#line 1767
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
  {
#line 1768
  initial_umask = umask((__mode_t )0);
#line 1769
  umask(initial_umask);
  }
#line 1770
  goto switch_break;
  case_158: /* CIL Label */ 
#line 1773
  ignore_command_error_option = (_Bool)0;
#line 1774
  goto switch_break;
  case_159: /* CIL Label */ 
  {
#line 1777
  set_old_files_option(1, args___0->loc);
  }
#line 1778
  goto switch_break;
  case_160: /* CIL Label */ 
  {
#line 1781
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1781
    if (! *arg___0) {
#line 1781
      goto while_break___7;
    }
    {
#line 1782
    set_char_quoting((struct quoting_options *)((void *)0), *arg___0, 0);
#line 1781
    arg___0 ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1783
  goto switch_break;
  case_166: /* CIL Label */ 
#line 1786
  numeric_owner_option = (_Bool)1;
#line 1787
  goto switch_break;
  case_167: /* CIL Label */ 
  {
#line 1790
  optloc_save(1U, args___0->loc);
  }
#line 1791
  if (! arg___0) {
#line 1792
    occurrence_option = (uintmax_t )1;
  } else {
    {
#line 1796
    tmp___25 = xstrtoumax((char const   *)arg___0, (char **)0, 10, & u___2, "");
    }
#line 1796
    if ((unsigned int )tmp___25 == 0U) {
#line 1797
      occurrence_option = u___2;
    } else {
      {
#line 1799
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1799
        if (error_hook) {
          {
#line 1799
          (*error_hook)();
          }
        }
        {
#line 1799
        tmp___23 = gettext("Invalid number");
#line 1799
        tmp___24 = quotearg_colon((char const   *)arg___0);
#line 1799
        error(0, 0, "%s: %s", tmp___24, tmp___23);
#line 1799
        fatal_exit();
        }
#line 1799
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
  }
#line 1802
  goto switch_break;
  case_168: /* CIL Label */ 
  {
#line 1805
  set_archive_format("v7");
  }
#line 1806
  goto switch_break;
  case_171: /* CIL Label */ 
  {
#line 1809
  set_old_files_option(0, args___0->loc);
  }
#line 1810
  goto switch_break;
  case_172: /* CIL Label */ 
  {
#line 1813
  set_old_files_option(2, args___0->loc);
  }
#line 1814
  goto switch_break;
  case_173: /* CIL Label */ 
  {
#line 1818
  tmp___26 = parse_owner_group(arg___0, (uintmax_t )((uid_t )-1), & owner_name_option);
#line 1818
  u___3 = tmp___26;
  }
#line 1820
  if (u___3 == 0xffffffffffffffffUL) {
#line 1822
    owner_option = (uid_t )-1;
#line 1823
    if (owner_name_option) {
      {
#line 1824
      uname_to_uid(owner_name_option, & owner_option);
      }
    }
  } else {
#line 1827
    owner_option = (uid_t )u___3;
  }
#line 1829
  goto switch_break;
  case_174: /* CIL Label */ 
  {
#line 1832
  owner_map_read((char const   *)arg___0);
  }
#line 1833
  goto switch_break;
  case_177: /* CIL Label */ 
  {
#line 1836
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1836
    if (! *arg___0) {
#line 1836
      goto while_break___9;
    }
    {
#line 1837
    set_char_quoting((struct quoting_options *)((void *)0), *arg___0, 1);
#line 1836
    arg___0 ++;
    }
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1838
  goto switch_break;
  case_178: /* CIL Label */ 
  {
#line 1841
  tar_set_quoting_style(arg___0);
  }
#line 1842
  goto switch_break;
  case_175: /* CIL Label */ 
  {
#line 1846
  tmp___28 = expand_pax_option(args___0, (char const   *)arg___0);
#line 1846
  tmp___27 = tmp___28;
#line 1847
  args___0->pax_option = (_Bool)1;
#line 1848
  xheader_set_option(tmp___27);
#line 1849
  free((void *)tmp___27);
  }
#line 1851
  goto switch_break;
  case_176: /* CIL Label */ 
  {
#line 1854
  set_archive_format("posix");
  }
#line 1855
  goto switch_break;
  case_179: /* CIL Label */ 
  {
#line 1861
  tmp___31 = xstrtoumax((char const   *)arg___0, (char **)((void *)0), 10, & u___4,
                        "bBcGgkKMmPTtw");
  }
#line 1861
  if ((unsigned int )tmp___31 == 0U) {
#line 1861
    if (! (u___4 == u___4)) {
#line 1861
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
    {
#line 1863
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1863
      if (error_hook) {
        {
#line 1863
        (*error_hook)();
        }
      }
      {
#line 1863
      tmp___29 = gettext("Invalid record size");
#line 1863
      tmp___30 = quotearg_colon((char const   *)arg___0);
#line 1863
      error(0, 0, "%s: %s", tmp___30, tmp___29);
#line 1863
      usage(2);
      }
#line 1863
      goto while_break___10;
    }
    while_break___10: /* CIL Label */ ;
    }
  }
#line 1865
  record_size = u___4;
#line 1866
  if (record_size % 512UL != 0UL) {
    {
#line 1867
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1867
      if (error_hook) {
        {
#line 1867
        (*error_hook)();
        }
      }
      {
#line 1867
      tmp___32 = gettext("Record size must be a multiple of %d.");
#line 1867
      error(0, 0, (char const   *)tmp___32, 512);
#line 1867
      usage(2);
      }
#line 1867
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
  }
#line 1869
  blocking_factor = (int )(record_size / 512UL);
#line 1871
  goto switch_break;
  case_180: /* CIL Label */ 
#line 1874
  recursive_unlink_option = (_Bool)1;
#line 1875
  goto switch_break;
  case_181: /* CIL Label */ 
#line 1878
  remove_files_option = (_Bool)1;
#line 1879
  goto switch_break;
  case_182: /* CIL Label */ 
#line 1882
  restrict_option = (_Bool)1;
#line 1883
  goto switch_break;
  case_183: /* CIL Label */ 
#line 1886
  rmt_command = (char const   *)arg___0;
#line 1887
  goto switch_break;
  case_184: /* CIL Label */ 
#line 1890
  rsh_command_option = (char const   *)arg___0;
#line 1891
  goto switch_break;
  case_187: /* CIL Label */ 
  {
#line 1895
  tmp___33 = format_default_settings();
#line 1895
  s = tmp___33;
#line 1896
  printf((char const   */* __restrict  */)"%s\n", s);
#line 1897
  close_stdout();
#line 1898
  free((void *)s);
#line 1899
  exit(0);
  }
  case_189: /* CIL Label */ 
  {
#line 1903
  show_snapshot_field_ranges();
#line 1904
  close_stdout();
#line 1905
  exit(0);
  }
  case_195: /* CIL Label */ 
  {
#line 1910
  tmp___36 = xstrtoumax((char const   *)arg___0, (char **)0, 10, & u___5, "");
  }
#line 1910
  if ((unsigned int )tmp___36 == 0U) {
#line 1910
    if (! (u___5 == u___5)) {
#line 1910
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    {
#line 1912
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1912
      if (error_hook) {
        {
#line 1912
        (*error_hook)();
        }
      }
      {
#line 1912
      tmp___34 = gettext("Invalid number of elements");
#line 1912
      tmp___35 = quotearg_colon((char const   *)arg___0);
#line 1912
      error(0, 0, "%s: %s", tmp___35, tmp___34);
#line 1912
      usage(2);
      }
#line 1912
      goto while_break___12;
    }
    while_break___12: /* CIL Label */ ;
    }
  }
#line 1914
  strip_name_components = u___5;
#line 1916
  goto switch_break;
  case_188: /* CIL Label */ 
#line 1919
  show_omitted_dirs_option = (_Bool)1;
#line 1920
  goto switch_break;
  case_190: /* CIL Label */ 
#line 1923
  show_transformed_names_option = (_Bool)1;
#line 1924
  goto switch_break;
  case_192: /* CIL Label */ 
  {
#line 1927
  tmp___37 = __xargmatch_internal("--sort", (char const   *)arg___0, sort_mode_arg,
                                  (char const   *)(sort_mode_flag), sizeof(sort_mode_flag[0]),
                                  argmatch_die);
#line 1927
  savedir_sort_order = sort_mode_flag[tmp___37];
  }
#line 1929
  goto switch_break;
  case_196: /* CIL Label */ 
#line 1932
  backup_option = (_Bool)1;
#line 1933
  args___0->backup_suffix_string = (char const   *)arg___0;
#line 1934
  goto switch_break;
  case_199: /* CIL Label */ 
#line 1937
  if (to_command_option) {
    {
#line 1938
    while (1) {
      while_continue___13: /* CIL Label */ ;
#line 1938
      if (error_hook) {
        {
#line 1938
        (*error_hook)();
        }
      }
      {
#line 1938
      tmp___38 = gettext("Only one --to-command option allowed");
#line 1938
      error(0, 0, (char const   *)tmp___38);
#line 1938
      usage(2);
      }
#line 1938
      goto while_break___13;
    }
    while_break___13: /* CIL Label */ ;
    }
  }
#line 1939
  to_command_option = arg___0;
#line 1940
  goto switch_break;
  case_198: /* CIL Label */ 
#line 1943
  if (arg___0) {
    {
#line 1944
    set_stat_signal((char const   *)arg___0);
    }
  } else {
#line 1946
    totals_option = (_Bool)1;
  }
#line 1947
  goto switch_break;
  case_200: /* CIL Label */ 
  {
#line 1950
  set_transform_expr((char const   *)arg___0);
  }
#line 1951
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 1954
  set_use_compress_program_option((char const   *)arg___0, args___0->loc);
  }
#line 1955
  goto switch_break;
  case_202: /* CIL Label */ 
#line 1958
  volno_file_option = (char const   *)arg___0;
#line 1959
  goto switch_break;
  case_161: /* CIL Label */ 
#line 1962
  same_owner_option = -1;
#line 1963
  goto switch_break;
  case_162: /* CIL Label */ 
#line 1966
  same_permissions_option = -1;
#line 1967
  goto switch_break;
  case_128: /* CIL Label */ 
  {
#line 1970
  set_archive_format("posix");
#line 1971
  acls_option = 1;
  }
#line 1972
  goto switch_break;
  case_154: /* CIL Label */ 
#line 1975
  acls_option = -1;
#line 1976
  goto switch_break;
  case_186: /* CIL Label */ 
  {
#line 1979
  set_archive_format("posix");
#line 1980
  selinux_context_option = 1;
  }
#line 1981
  goto switch_break;
  case_164: /* CIL Label */ 
#line 1984
  selinux_context_option = -1;
#line 1985
  goto switch_break;
  case_204: /* CIL Label */ 
  {
#line 1988
  set_xattr_option(1);
  }
#line 1989
  goto switch_break;
  case_165: /* CIL Label */ 
  {
#line 1992
  set_xattr_option(-1);
  }
#line 1993
  goto switch_break;
  case_205: /* CIL Label */ 
  case_206: /* CIL Label */ 
  {
#line 1997
  set_xattr_option(1);
#line 1998
  xattrs_mask_add((char const   *)arg___0, (_Bool )(key == 206));
  }
#line 1999
  goto switch_break;
  case_185: /* CIL Label */ 
#line 2002
  same_owner_option = 1;
#line 2003
  goto switch_break;
  case_203: /* CIL Label */ 
  {
#line 2006
  set_warning_option((char const   *)arg___0);
  }
#line 2007
  goto switch_break;
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  {
#line 2068
  tmp___39 = gettext("Options \'-[0-7][lmh]\' not supported by *this* tar");
#line 2068
  argp_error((struct argp_state  const  */* __restrict  */)state, (char const   */* __restrict  */)tmp___39);
  }
  case_16777221: /* CIL Label */ 
#line 2074
  if ((unsigned int )(args___0->loc)->source == 2U) {
    {
#line 2075
    tmp___40 = gettext("%s:%lu: location of the error");
#line 2075
    error(0, 0, (char const   *)tmp___40, (args___0->loc)->name, (args___0->loc)->line);
    }
  } else
#line 2077
  if ((unsigned int )(args___0->loc)->source == 0U) {
    {
#line 2078
    tmp___41 = gettext("error parsing %s");
#line 2078
    error(0, 0, (char const   *)tmp___41, (args___0->loc)->name);
    }
  }
  {
#line 2079
  exit(64);
  }
  switch_default: /* CIL Label */ 
#line 2082
  return (7);
  switch_break: /* CIL Label */ ;
  }
#line 2084
  return (0);
}
}
#line 2087
struct argp_child names_argp_children[2] ;
#line 2089 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct argp argp  =    {(struct argp_option  const  *)(options), & parse_opt, "[FILE]...", doc, (struct argp_child  const  *)(names_argp_children),
    & tar_help_filter, (char const   *)((void *)0)};
#line 2099
 __attribute__((__noreturn__)) void usage(int status ) ;
#line 2099 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
void usage(int status ) 
{ 


  {
  {
#line 2102
  argp_help((struct argp  const  */* __restrict  */)(& argp), (FILE */* __restrict  */)stderr,
            4U, (char */* __restrict  */)((char *)program_name));
#line 2103
  close_stdout();
#line 2104
  exit(status);
  }
}
}
#line 2109 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct argp_option  const  *find_argp_option_key(struct argp_option  const  *o___0 ,
                                                        int key ) 
{ 


  {
  {
#line 2112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2112
    if ((unsigned long )o___0->name == (unsigned long )((void *)0)) {
#line 2112
      if (o___0->key == 0) {
#line 2112
        if ((unsigned long )o___0->arg == (unsigned long )((char const   */* const  */)0)) {
#line 2112
          if (o___0->flags == 0) {
#line 2112
            if ((unsigned long )o___0->doc == (unsigned long )((void *)0)) {
#line 2112
              goto while_break;
            }
          }
        }
      }
    }
#line 2118
    if (o___0->key == (int const   )key) {
#line 2119
      return (o___0);
    }
#line 2112
    o___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2120
  return ((struct argp_option  const  *)((void *)0));
}
}
#line 2123 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct argp_option  const  *find_argp_option(struct argp *ap , int key ) 
{ 
  struct argp_option  const  *p ;
  struct argp_child  const  *child ;

  {
  {
#line 2126
  p = (struct argp_option  const  *)((void *)0);
#line 2129
  p = find_argp_option_key(ap->options, key);
  }
#line 2130
  if (! p) {
#line 2130
    if (ap->children) {
#line 2132
      child = ap->children;
      {
#line 2132
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2132
        if (! child->argp) {
#line 2132
          goto while_break;
        }
        {
#line 2134
        p = find_argp_option_key((struct argp_option  const  *)(child->argp)->options,
                                 key);
        }
#line 2135
        if (p) {
#line 2136
          goto while_break;
        }
#line 2132
        child ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2139
  return (p);
}
}
#line 2142 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static char const   *tar_authors[3]  = {      "John Gilmore",      "Jay Fenlason",      (char const   *)((void *)0)};
#line 2156 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static int subcommand_class[10]  = 
#line 2156
  {      0,      6,      2,      2, 
        22,      17,      17,      17, 
        6,      8};
#line 2172 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static struct tar_args args  ;
#line 2174 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
void more_options(int argc , char **argv , struct option_locus *loc ) 
{ 
  int idx ;
  error_t tmp ;
  char *tmp___0 ;

  {
  {
#line 2179
  args.loc = loc;
#line 2180
  tmp = argp_parse((struct argp  const  */* __restrict  */)(& argp), argc, (char **/* __restrict  */)argv,
                   40U, (int */* __restrict  */)(& idx), (void */* __restrict  */)(& args));
  }
#line 2180
  if (tmp) {
    {
#line 2181
    abort();
    }
  }
#line 2182
  if ((unsigned int )loc->source == 0U) {
#line 2182
    if (args.input_files) {
      {
#line 2183
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2183
        if (error_hook) {
          {
#line 2183
          (*error_hook)();
          }
        }
        {
#line 2183
        tmp___0 = gettext("non-option arguments in %s");
#line 2183
        error(0, 0, (char const   *)tmp___0, loc->name);
#line 2183
        usage(2);
        }
#line 2183
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2184
  return;
}
}
#line 2186 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void parse_default_options(void) 
{ 
  char *opts ;
  char *tmp ;
  struct wordsplit ws ;
  struct option_locus loc ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 2189
  tmp = getenv("TAR_OPTIONS");
#line 2189
  opts = tmp;
#line 2191
  loc.source = (enum option_source )0;
#line 2191
  loc.name = "TAR_OPTIONS";
#line 2191
  loc.line = (size_t )0;
#line 2191
  loc.prev = (struct option_locus *)0;
  }
#line 2193
  if (! opts) {
#line 2194
    return;
  }
  {
#line 2196
  ws.ws_offs = (size_t )1;
#line 2197
  tmp___2 = wordsplit((char const   *)opts, & ws, 33558086);
  }
#line 2197
  if (tmp___2) {
    {
#line 2198
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2198
      if (error_hook) {
        {
#line 2198
        (*error_hook)();
        }
      }
      {
#line 2198
      tmp___0 = wordsplit_strerror(& ws);
#line 2198
      tmp___1 = gettext("cannot split TAR_OPTIONS: %s");
#line 2198
      error(0, 0, (char const   *)tmp___1, tmp___0);
#line 2198
      fatal_exit();
      }
#line 2198
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2200
  if (ws.ws_wordc) {
    {
#line 2202
    *(ws.ws_wordv + 0) = (char *)program_name;
#line 2203
    more_options((int )(ws.ws_offs + ws.ws_wordc), ws.ws_wordv, & loc);
    }
  }
  {
#line 2206
  wordsplit_free(& ws);
  }
#line 2207
  return;
}
}
#line 2209 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
static void decode_options(int argc , char **argv ) 
{ 
  int idx ;
  struct option_locus loc ;
  char *tmp ;
  int new_argc ;
  char **new_argv ;
  char * const  *in ;
  char **out ;
  char const   *letter ;
  char buffer___1[3] ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char **tmp___2 ;
  char * const  *tmp___3 ;
  char * const  *tmp___4 ;
  struct argp_option  const  *opt ;
  char **tmp___5 ;
  char **tmp___6 ;
  char * const  *tmp___7 ;
  char *tmp___8 ;
  char **tmp___9 ;
  char * const  *tmp___10 ;
  error_t tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  struct option_locus *listed_loc ;
  struct option_locus *tmp___17 ;
  struct option_locus *newer_loc ;
  struct option_locus *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  size_t volume_label_max_len ;
  unsigned long tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  size_t tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  char const   *tmp___27 ;
  int tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  char *tmp___34 ;
  char *tmp___35 ;
  char *tmp___36 ;
  char const   *tmp___37 ;
  int tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  char *base ;
  struct option_locus *one_top_level_loc ;
  struct option_locus *tmp___41 ;
  struct option_locus *absolute_names_loc ;
  struct option_locus *tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int base_open_flags ;
  int tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  struct option_locus *preserve_order_loc ;
  struct option_locus *tmp___48 ;
  struct option_locus *listed_incremental_loc ;
  struct option_locus *tmp___49 ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  int tmp___55 ;
  char *tmp___56 ;

  {
  {
#line 2213
  loc.source = (enum option_source )1;
#line 2213
  loc.name = (char const   *)0;
#line 2213
  loc.line = (size_t )0;
#line 2213
  loc.prev = (struct option_locus *)0;
#line 2215
  argp_version_setup("tar", (char const   * const  *)(tar_authors));
#line 2218
  args.textual_date = (struct textual_date *)((void *)0);
#line 2219
  args.o_option = (_Bool)0;
#line 2220
  args.pax_option = (_Bool)0;
#line 2221
  tmp = getenv("SIMPLE_BACKUP_SUFFIX");
#line 2221
  args.backup_suffix_string = (char const   *)tmp;
#line 2222
  args.version_control_string = (char const   *)0;
#line 2223
  args.input_files = (_Bool)0;
#line 2224
  args.compress_autodetect = 0;
#line 2226
  subcommand_option = (enum subcommand )0;
#line 2227
  archive_format = (enum archive_format )0;
#line 2228
  blocking_factor = 20;
#line 2229
  record_size = (size_t )10240;
#line 2230
  excluded = new_exclude();
#line 2231
  hole_detection = (enum hole_detection_method )0;
#line 2233
  newer_mtime_option.tv_sec = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 2234
  newer_mtime_option.tv_nsec = (__syscall_slong_t )-1;
#line 2235
  mtime_option.tv_sec = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 2236
  mtime_option.tv_nsec = (__syscall_slong_t )-1;
#line 2237
  recursion_option = 1 << 3;
#line 2238
  unquote_option = (_Bool)1;
#line 2239
  tar_sparse_major = 1U;
#line 2240
  tar_sparse_minor = 0U;
#line 2242
  savedir_sort_order = 0;
#line 2244
  owner_option = (uid_t )-1;
#line 2244
  owner_name_option = (char const   *)((void *)0);
#line 2245
  group_option = (gid_t )-1;
#line 2245
  group_name_option = (char const   *)((void *)0);
#line 2247
  check_device_option = (_Bool)1;
#line 2249
  incremental_level = -1;
#line 2251
  seek_option = -1;
  }
#line 2256
  if (argc > 1) {
#line 2256
    if ((int )*(*(argv + 1) + 0) != 45) {
      {
#line 2267
      buffer___1[0] = (char )'-';
#line 2268
      buffer___1[2] = (char )'\000';
#line 2272
      tmp___0 = strlen((char const   *)*(argv + 1));
#line 2272
      new_argc = (int )((size_t )(argc - 1) + tmp___0);
#line 2273
      tmp___1 = xmalloc((unsigned long )(new_argc + 1) * sizeof(char *));
#line 2273
      new_argv = (char **)tmp___1;
#line 2274
      in = (char * const  *)argv;
#line 2275
      out = new_argv;
#line 2276
      tmp___2 = out;
#line 2276
      out ++;
#line 2276
      tmp___3 = in;
#line 2276
      in ++;
#line 2276
      *tmp___2 = (char *)*tmp___3;
#line 2281
      tmp___4 = in;
#line 2281
      in ++;
#line 2281
      letter = (char const   *)*tmp___4;
      }
      {
#line 2281
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2281
        if (! *letter) {
#line 2281
          goto while_break;
        }
        {
#line 2285
        buffer___1[1] = (char )*letter;
#line 2286
        tmp___5 = out;
#line 2286
        out ++;
#line 2286
        *tmp___5 = xstrdup((char const   *)(buffer___1));
#line 2287
        opt = find_argp_option(& argp, (int )*letter);
        }
#line 2288
        if (opt) {
#line 2288
          if (opt->arg) {
#line 2290
            if ((unsigned long )in < (unsigned long )(argv + argc)) {
#line 2291
              tmp___6 = out;
#line 2291
              out ++;
#line 2291
              tmp___7 = in;
#line 2291
              in ++;
#line 2291
              *tmp___6 = (char *)*tmp___7;
            } else {
              {
#line 2293
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 2293
                if (error_hook) {
                  {
#line 2293
                  (*error_hook)();
                  }
                }
                {
#line 2293
                tmp___8 = gettext("Old option \'%c\' requires an argument.");
#line 2293
                error(0, 0, (char const   *)tmp___8, (int const   )*letter);
#line 2293
                usage(2);
                }
#line 2293
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
          }
        }
#line 2281
        letter ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2300
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2300
        if (! ((unsigned long )in < (unsigned long )(argv + argc))) {
#line 2300
          goto while_break___1;
        }
#line 2301
        tmp___9 = out;
#line 2301
        out ++;
#line 2301
        tmp___10 = in;
#line 2301
        in ++;
#line 2301
        *tmp___9 = (char *)*tmp___10;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2302
      *out = (char *)0;
#line 2306
      argc = new_argc;
#line 2307
      argv = new_argv;
    }
  }
  {
#line 2311
  parse_default_options();
#line 2313
  args.loc = & loc;
#line 2314
  tmp___11 = argp_parse((struct argp  const  */* __restrict  */)(& argp), argc, (char **/* __restrict  */)argv,
                        8U, (int */* __restrict  */)(& idx), (void */* __restrict  */)(& args));
  }
#line 2314
  if (tmp___11) {
    {
#line 2315
    exit(2);
    }
  }
#line 2326
  if (args.o_option) {
#line 2328
    if ((unsigned int )subcommand_option == 3U) {
      {
#line 2331
      set_archive_format("v7");
      }
    } else {
#line 2336
      same_owner_option = -1;
    }
  }
  {
#line 2341
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2341
    if (! (idx < argc)) {
#line 2341
      goto while_break___2;
    }
    {
#line 2343
    name_add_name((char const   *)*(argv + idx));
#line 2344
    args.input_files = (_Bool)1;
#line 2341
    idx ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 2349
  if ((unsigned int )archive_format == 0U) {
#line 2351
    if (args.pax_option) {
#line 2352
      archive_format = (enum archive_format )4;
    } else {
#line 2354
      archive_format = (enum archive_format )6;
    }
  }
#line 2357
  if (volume_label_option) {
#line 2357
    if ((unsigned int )subcommand_option == 3U) {
      {
#line 2361
      assert_format((unsigned int )(((1 << 2) | (1 << 6)) | (1 << 4)));
      }
    } else {
#line 2357
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2357
  if (incremental_option) {
    {
#line 2361
    assert_format((unsigned int )(((1 << 2) | (1 << 6)) | (1 << 4)));
    }
  } else
#line 2357
  if (multi_volume_option) {
    {
#line 2361
    assert_format((unsigned int )(((1 << 2) | (1 << 6)) | (1 << 4)));
    }
  } else
#line 2357
  if (sparse_option) {
    {
#line 2361
    assert_format((unsigned int )(((1 << 2) | (1 << 6)) | (1 << 4)));
    }
  }
#line 2365
  if (occurrence_option) {
#line 2367
    if (! args.input_files) {
      {
#line 2368
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2368
        if (error_hook) {
          {
#line 2368
          (*error_hook)();
          }
        }
        {
#line 2368
        tmp___12 = gettext("--occurrence is meaningless without a file list");
#line 2368
        error(0, 0, (char const   *)tmp___12);
#line 2368
        usage(2);
        }
#line 2368
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
    }
#line 2370
    if (! (subcommand_class[subcommand_option] & 16)) {
      {
#line 2372
      tmp___14 = option_set_in_cl(1);
      }
#line 2372
      if (tmp___14) {
        {
#line 2373
        tmp___13 = subcommand_string(subcommand_option);
#line 2373
        option_conflict_error("--occurrence", tmp___13);
        }
      } else {
#line 2376
        occurrence_option = (uintmax_t )0;
      }
    }
  }
#line 2380
  if (archive_names == 0UL) {
    {
#line 2385
    archive_names = (size_t )1;
#line 2386
    tmp___15 = getenv("TAPE");
#line 2386
    *(archive_name_array + 0) = (char const   *)tmp___15;
    }
#line 2387
    if (! *(archive_name_array + 0)) {
#line 2388
      *(archive_name_array + 0) = "-";
    }
  }
#line 2393
  if (archive_names > 1UL) {
#line 2393
    if (! multi_volume_option) {
      {
#line 2394
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2394
        if (error_hook) {
          {
#line 2394
          (*error_hook)();
          }
        }
        {
#line 2394
        tmp___16 = gettext("Multiple archive files require \'-M\' option");
#line 2394
        error(0, 0, (char const   *)tmp___16);
#line 2394
        usage(2);
        }
#line 2394
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
  }
#line 2397
  if (listed_incremental_option) {
#line 2397
    if (0L <= newer_mtime_option.tv_nsec) {
      {
#line 2400
      tmp___17 = optloc_lookup(2);
#line 2400
      listed_loc = tmp___17;
#line 2401
      tmp___18 = optloc_lookup(3);
#line 2401
      newer_loc = tmp___18;
#line 2402
      tmp___19 = optloc_eq(listed_loc, newer_loc);
      }
#line 2402
      if (tmp___19) {
        {
#line 2403
        option_conflict_error("--listed-incremental", "--newer");
        }
      } else
#line 2404
      if ((unsigned int )listed_loc->source == 1U) {
#line 2405
        listed_incremental_option = (char const   *)((void *)0);
      } else {
        {
#line 2407
        memset((void *)(& newer_mtime_option), 0, sizeof(newer_mtime_option));
        }
      }
    }
  }
#line 2410
  if (incremental_level != -1) {
#line 2410
    if (! listed_incremental_option) {
      {
#line 2411
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2411
        if (error_hook) {
          {
#line 2411
          (*error_hook)();
          }
        }
        {
#line 2411
        tmp___20 = gettext("--level is meaningless without --listed-incremental");
#line 2411
        error(0, 0, (char const   *)tmp___20);
        }
#line 2411
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
  }
#line 2414
  if (volume_label_option) {
#line 2416
    if ((unsigned int )archive_format == 6U) {
#line 2416
      goto _L___0;
    } else
#line 2416
    if ((unsigned int )archive_format == 2U) {
      _L___0: /* CIL Label */ 
#line 2418
      if (multi_volume_option) {
#line 2418
        tmp___21 = ((sizeof(" Volume ") - 1UL) + (((sizeof(int ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL)) - 1UL;
      } else {
#line 2418
        tmp___21 = 0UL;
      }
      {
#line 2418
      volume_label_max_len = (sizeof(current_header->header.name) - 1UL) - tmp___21;
#line 2427
      tmp___24 = strlen(volume_label_option);
      }
#line 2427
      if (volume_label_max_len < tmp___24) {
        {
#line 2428
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 2428
          if (error_hook) {
            {
#line 2428
            (*error_hook)();
            }
          }
          {
#line 2428
          tmp___22 = quotearg_colon(volume_label_option);
#line 2428
          tmp___23 = ngettext("%s: Volume label is too long (limit is %lu byte)",
                              "%s: Volume label is too long (limit is %lu bytes)",
                              volume_label_max_len);
#line 2428
          error(0, 0, (char const   *)tmp___23, tmp___22, volume_label_max_len);
#line 2428
          usage(2);
          }
#line 2428
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
    }
  }
#line 2439
  if (verify_option) {
#line 2441
    if (multi_volume_option) {
      {
#line 2442
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 2442
        if (error_hook) {
          {
#line 2442
          (*error_hook)();
          }
        }
        {
#line 2442
        tmp___25 = gettext("Cannot verify multi-volume archives");
#line 2442
        error(0, 0, (char const   *)tmp___25);
#line 2442
        usage(2);
        }
#line 2442
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
    }
#line 2443
    if (use_compress_program_option) {
      {
#line 2444
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 2444
        if (error_hook) {
          {
#line 2444
          (*error_hook)();
          }
        }
        {
#line 2444
        tmp___26 = gettext("Cannot verify compressed archives");
#line 2444
        error(0, 0, (char const   *)tmp___26);
#line 2444
        usage(2);
        }
#line 2444
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 2445
    if (! (subcommand_class[subcommand_option] & 2)) {
      {
#line 2447
      tmp___28 = option_set_in_cl(4);
      }
#line 2447
      if (tmp___28) {
        {
#line 2448
        tmp___27 = subcommand_string(subcommand_option);
#line 2448
        option_conflict_error("--verify", tmp___27);
        }
      } else {
#line 2451
        verify_option = (_Bool)0;
      }
    }
  }
#line 2455
  if (use_compress_program_option) {
#line 2457
    if (multi_volume_option) {
      {
#line 2458
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 2458
        if (error_hook) {
          {
#line 2458
          (*error_hook)();
          }
        }
        {
#line 2458
        tmp___29 = gettext("Cannot use multi-volume compressed archives");
#line 2458
        error(0, 0, (char const   *)tmp___29);
#line 2458
        usage(2);
        }
#line 2458
        goto while_break___9;
      }
      while_break___9: /* CIL Label */ ;
      }
    }
#line 2459
    if (subcommand_class[subcommand_option] & 4) {
      {
#line 2460
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 2460
        if (error_hook) {
          {
#line 2460
          (*error_hook)();
          }
        }
        {
#line 2460
        tmp___30 = gettext("Cannot update compressed archives");
#line 2460
        error(0, 0, (char const   *)tmp___30);
#line 2460
        usage(2);
        }
#line 2460
        goto while_break___10;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 2461
    if ((unsigned int )subcommand_option == 2U) {
      {
#line 2462
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 2462
        if (error_hook) {
          {
#line 2462
          (*error_hook)();
          }
        }
        {
#line 2462
        tmp___31 = gettext("Cannot concatenate compressed archives");
#line 2462
        error(0, 0, (char const   *)tmp___31);
#line 2462
        usage(2);
        }
#line 2462
        goto while_break___11;
      }
      while_break___11: /* CIL Label */ ;
      }
    }
  }
#line 2465
  if ((unsigned int )set_mtime_option == 2U) {
#line 2467
    if (! (0L <= mtime_option.tv_nsec)) {
      {
#line 2468
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 2468
        if (error_hook) {
          {
#line 2468
          (*error_hook)();
          }
        }
        {
#line 2468
        tmp___32 = gettext("--clamp-mtime needs a date specified using --mtime");
#line 2468
        error(0, 0, (char const   *)tmp___32);
#line 2468
        usage(2);
        }
#line 2468
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
  }
#line 2476
  if (args.pax_option) {
#line 2476
    if ((unsigned int )archive_format != 4U) {
#line 2476
      if (! (subcommand_class[subcommand_option] & 1)) {
        {
#line 2479
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 2479
          if (error_hook) {
            {
#line 2479
            (*error_hook)();
            }
          }
          {
#line 2479
          tmp___33 = gettext("--pax-option can be used only on POSIX archives");
#line 2479
          error(0, 0, (char const   *)tmp___33);
#line 2479
          usage(2);
          }
#line 2479
          goto while_break___13;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
  }
#line 2483
  if (acls_option > 0) {
#line 2483
    if ((unsigned int )archive_format != 4U) {
#line 2483
      if (! (subcommand_class[subcommand_option] & 1)) {
        {
#line 2486
        while (1) {
          while_continue___14: /* CIL Label */ ;
#line 2486
          if (error_hook) {
            {
#line 2486
            (*error_hook)();
            }
          }
          {
#line 2486
          tmp___34 = gettext("--acls can be used only on POSIX archives");
#line 2486
          error(0, 0, (char const   *)tmp___34);
#line 2486
          usage(2);
          }
#line 2486
          goto while_break___14;
        }
        while_break___14: /* CIL Label */ ;
        }
      }
    }
  }
#line 2488
  if (selinux_context_option > 0) {
#line 2488
    if ((unsigned int )archive_format != 4U) {
#line 2488
      if (! (subcommand_class[subcommand_option] & 1)) {
        {
#line 2491
        while (1) {
          while_continue___15: /* CIL Label */ ;
#line 2491
          if (error_hook) {
            {
#line 2491
            (*error_hook)();
            }
          }
          {
#line 2491
          tmp___35 = gettext("--selinux can be used only on POSIX archives");
#line 2491
          error(0, 0, (char const   *)tmp___35);
#line 2491
          usage(2);
          }
#line 2491
          goto while_break___15;
        }
        while_break___15: /* CIL Label */ ;
        }
      }
    }
  }
#line 2493
  if (xattrs_option > 0) {
#line 2493
    if ((unsigned int )archive_format != 4U) {
#line 2493
      if (! (subcommand_class[subcommand_option] & 1)) {
        {
#line 2496
        while (1) {
          while_continue___16: /* CIL Label */ ;
#line 2496
          if (error_hook) {
            {
#line 2496
            (*error_hook)();
            }
          }
          {
#line 2496
          tmp___36 = gettext("--xattrs can be used only on POSIX archives");
#line 2496
          error(0, 0, (char const   *)tmp___36);
#line 2496
          usage(2);
          }
#line 2496
          goto while_break___16;
        }
        while_break___16: /* CIL Label */ ;
        }
      }
    }
  }
#line 2498
  if (starting_file_option) {
#line 2498
    if (! (subcommand_class[subcommand_option] & 1)) {
      {
#line 2500
      tmp___38 = option_set_in_cl(5);
      }
#line 2500
      if (tmp___38) {
        {
#line 2501
        tmp___37 = subcommand_string(subcommand_option);
#line 2501
        option_conflict_error("--starting-file", tmp___37);
        }
      } else {
#line 2504
        starting_file_option = (_Bool)0;
      }
    }
  }
#line 2507
  if (same_order_option) {
#line 2507
    if (! (subcommand_class[subcommand_option] & 1)) {
      {
#line 2509
      tmp___40 = option_set_in_cl(6);
      }
#line 2509
      if (tmp___40) {
        {
#line 2510
        tmp___39 = subcommand_string(subcommand_option);
#line 2510
        option_conflict_error("--same-order", tmp___39);
        }
      } else {
#line 2513
        same_order_option = (_Bool)0;
      }
    }
  }
#line 2516
  if (one_top_level_option) {
#line 2520
    if (absolute_names_option) {
      {
#line 2522
      tmp___41 = optloc_lookup(7);
#line 2522
      one_top_level_loc = tmp___41;
#line 2524
      tmp___42 = optloc_lookup(8);
#line 2524
      absolute_names_loc = tmp___42;
#line 2527
      tmp___43 = optloc_eq(one_top_level_loc, absolute_names_loc);
      }
#line 2527
      if (tmp___43) {
        {
#line 2528
        option_conflict_error("--one-top-level", "--absolute-names");
        }
      } else
#line 2529
      if ((unsigned int )one_top_level_loc->source == 1U) {
#line 2530
        absolute_names_option = (_Bool)0;
      } else {
#line 2532
        one_top_level_option = (_Bool)0;
      }
    }
#line 2535
    if (one_top_level_option) {
#line 2535
      if (! one_top_level_dir) {
        {
#line 2539
        base = base_name(*(archive_name_array + 0));
#line 2540
        one_top_level_dir = strip_compression_suffix((char const   *)base);
#line 2541
        free((void *)base);
        }
#line 2543
        if (! one_top_level_dir) {
          {
#line 2544
          while (1) {
            while_continue___17: /* CIL Label */ ;
#line 2544
            if (error_hook) {
              {
#line 2544
              (*error_hook)();
              }
            }
            {
#line 2544
            tmp___44 = gettext("Cannot deduce top-level directory name; please set it explicitly with --one-top-level=DIR");
#line 2544
            error(0, 0, (char const   *)tmp___44);
#line 2544
            usage(2);
            }
#line 2544
            goto while_break___17;
          }
          while_break___17: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 2551
  if (recursive_unlink_option) {
#line 2552
    old_files_option = (enum old_files )3;
  }
#line 2558
  if (dereference_option) {
#line 2558
    tmp___45 = 0;
  } else {
#line 2558
    tmp___45 = 131072;
  }
#line 2558
  if ((unsigned int )atime_preserve_option == 2U) {
#line 2558
    tmp___46 = 262144;
  } else {
#line 2558
    tmp___46 = 0;
  }
#line 2558
  base_open_flags = (526592 | tmp___45) | tmp___46;
#line 2562
  open_read_flags = base_open_flags;
#line 2563
  open_searchdir_flags = 65536 | base_open_flags;
#line 2565
  if (dereference_option) {
#line 2565
    fstatat_flags = 0;
  } else {
#line 2565
    fstatat_flags = 256;
  }
#line 2567
  if ((unsigned int )subcommand_option == 9U) {
#line 2571
    if (! args.input_files) {
#line 2572
      verbose_option ++;
    }
  } else
#line 2574
  if (utc_option) {
#line 2575
    verbose_option = 2;
  }
#line 2577
  if (tape_length_option) {
#line 2577
    if (tape_length_option < (tarlong )record_size) {
      {
#line 2578
      while (1) {
        while_continue___18: /* CIL Label */ ;
#line 2578
        if (error_hook) {
          {
#line 2578
          (*error_hook)();
          }
        }
        {
#line 2578
        tmp___47 = gettext("Volume length cannot be less than record size");
#line 2578
        error(0, 0, (char const   *)tmp___47);
#line 2578
        usage(2);
        }
#line 2578
        goto while_break___18;
      }
      while_break___18: /* CIL Label */ ;
      }
    }
  }
#line 2580
  if (same_order_option) {
#line 2580
    if (listed_incremental_option) {
      {
#line 2582
      tmp___48 = optloc_lookup(6);
#line 2582
      preserve_order_loc = tmp___48;
#line 2583
      tmp___49 = optloc_lookup(2);
#line 2583
      listed_incremental_loc = tmp___49;
#line 2586
      tmp___50 = optloc_eq(preserve_order_loc, listed_incremental_loc);
      }
#line 2586
      if (tmp___50) {
        {
#line 2587
        option_conflict_error("--preserve-order", "--listed-incremental");
        }
      } else
#line 2588
      if ((unsigned int )preserve_order_loc->source == 1U) {
#line 2589
        listed_incremental_option = (char const   *)0;
      } else {
#line 2591
        same_order_option = (_Bool)0;
      }
    }
  }
  {
#line 2599
  if ((unsigned int )subcommand_option == 3U) {
#line 2599
    goto case_3;
  }
#line 2612
  if ((unsigned int )subcommand_option == 9U) {
#line 2612
    goto case_9;
  }
#line 2612
  if ((unsigned int )subcommand_option == 5U) {
#line 2612
    goto case_9;
  }
#line 2612
  if ((unsigned int )subcommand_option == 7U) {
#line 2612
    goto case_9;
  }
#line 2612
  if ((unsigned int )subcommand_option == 6U) {
#line 2612
    goto case_9;
  }
#line 2622
  if ((unsigned int )subcommand_option == 1U) {
#line 2622
    goto case_1;
  }
#line 2622
  if ((unsigned int )subcommand_option == 8U) {
#line 2622
    goto case_1;
  }
#line 2622
  if ((unsigned int )subcommand_option == 2U) {
#line 2622
    goto case_1;
  }
#line 2630
  goto switch_default;
  case_3: /* CIL Label */ 
#line 2600
  if (! args.input_files) {
#line 2600
    if (! files_from_option) {
      {
#line 2601
      while (1) {
        while_continue___19: /* CIL Label */ ;
#line 2601
        if (error_hook) {
          {
#line 2601
          (*error_hook)();
          }
        }
        {
#line 2601
        tmp___51 = gettext("Cowardly refusing to create an empty archive");
#line 2601
        error(0, 0, (char const   *)tmp___51);
#line 2601
        usage(2);
        }
#line 2601
        goto while_break___19;
      }
      while_break___19: /* CIL Label */ ;
      }
    }
  }
#line 2603
  if (args.compress_autodetect) {
#line 2603
    if (archive_names) {
      {
#line 2603
      tmp___52 = strcmp(*(archive_name_array + 0), "-");
      }
#line 2603
      if (tmp___52) {
        {
#line 2605
        set_compression_program_by_suffix(*(archive_name_array + 0), use_compress_program_option);
        }
      }
    }
  }
#line 2607
  goto switch_break;
  case_9: /* CIL Label */ 
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
#line 2613
  archive_name_cursor = archive_name_array;
  {
#line 2613
  while (1) {
    while_continue___20: /* CIL Label */ ;
#line 2613
    if (! ((unsigned long )archive_name_cursor < (unsigned long )(archive_name_array + archive_names))) {
#line 2613
      goto while_break___20;
    }
    {
#line 2616
    tmp___53 = strcmp(*archive_name_cursor, "-");
    }
#line 2616
    if (! tmp___53) {
      {
#line 2617
      request_stdin("-f");
      }
    }
#line 2613
    archive_name_cursor ++;
  }
  while_break___20: /* CIL Label */ ;
  }
#line 2618
  goto switch_break;
  case_1: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 2623
  archive_name_cursor = archive_name_array;
  {
#line 2623
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 2623
    if (! ((unsigned long )archive_name_cursor < (unsigned long )(archive_name_array + archive_names))) {
#line 2623
      goto while_break___21;
    }
    {
#line 2626
    tmp___55 = strcmp(*archive_name_cursor, "-");
    }
#line 2626
    if (! tmp___55) {
      {
#line 2627
      while (1) {
        while_continue___22: /* CIL Label */ ;
#line 2627
        if (error_hook) {
          {
#line 2627
          (*error_hook)();
          }
        }
        {
#line 2627
        tmp___54 = gettext("Options \'-Aru\' are incompatible with \'-f -\'");
#line 2627
        error(0, 0, (char const   *)tmp___54);
#line 2627
        usage(2);
        }
#line 2627
        goto while_break___22;
      }
      while_break___22: /* CIL Label */ ;
      }
    }
#line 2623
    archive_name_cursor ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  switch_default: /* CIL Label */ 
#line 2631
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2635
  if (index_file_name) {
    {
#line 2637
    stdlis = fopen((char const   */* __restrict  */)index_file_name, (char const   */* __restrict  */)"w");
    }
#line 2638
    if (! stdlis) {
      {
#line 2639
      open_fatal(index_file_name);
      }
    }
  } else
#line 2642
  if (to_stdout_option) {
#line 2642
    stdlis = stderr;
  } else {
#line 2642
    stdlis = stdout;
  }
#line 2644
  archive_name_cursor = archive_name_array;
#line 2648
  if (args.backup_suffix_string) {
    {
#line 2649
    tmp___56 = xstrdup(args.backup_suffix_string);
#line 2649
    simple_backup_suffix = (char const   *)tmp___56;
    }
  }
#line 2651
  if (backup_option) {
    {
#line 2653
    backup_type = xget_version("--backup", args.version_control_string);
    }
#line 2656
    if ((unsigned int )backup_type == 0U) {
#line 2657
      backup_option = (_Bool)0;
    } else
#line 2656
    if (to_stdout_option) {
#line 2657
      backup_option = (_Bool)0;
    } else
#line 2656
    if (to_command_option) {
#line 2657
      backup_option = (_Bool)0;
    }
  }
  {
#line 2660
  checkpoint_finish_compile();
#line 2662
  report_textual_dates(& args);
  }
#line 2663
  return;
}
}
#line 2669 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
int main(int argc , char **argv ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 2672
  set_start_time();
#line 2673
  set_program_name((char const   *)*(argv + 0));
#line 2675
  setlocale(6, "");
#line 2676
  bindtextdomain("tar", "/usr/local/share/locale");
#line 2677
  textdomain("tar");
#line 2679
  exit_failure = (int volatile   )2;
#line 2680
  exit_status = 0;
#line 2681
  error_hook = & checkpoint_flush_actions;
#line 2683
  set_quoting_style((struct quoting_options *)0, (enum quoting_style )5);
#line 2686
  stdopen();
#line 2690
  allocated_archive_names = (size_t )10;
#line 2691
  tmp = xmalloc(sizeof(char const   *) * allocated_archive_names);
#line 2691
  archive_name_array = (char const   **)tmp;
#line 2693
  archive_names = (size_t )0;
#line 2696
  signal(17, (void (*)(int  ))0);
#line 2699
  priv_set_remove_linkdir();
#line 2703
  decode_options(argc, argv);
#line 2705
  name_init();
  }
#line 2709
  if (volno_file_option) {
    {
#line 2710
    init_volume_number();
    }
  }
  {
#line 2714
  if ((unsigned int )subcommand_option == 0U) {
#line 2714
    goto case_0;
  }
#line 2720
  if ((unsigned int )subcommand_option == 1U) {
#line 2720
    goto case_1;
  }
#line 2720
  if ((unsigned int )subcommand_option == 8U) {
#line 2720
    goto case_1;
  }
#line 2720
  if ((unsigned int )subcommand_option == 2U) {
#line 2720
    goto case_1;
  }
#line 2724
  if ((unsigned int )subcommand_option == 4U) {
#line 2724
    goto case_4;
  }
#line 2728
  if ((unsigned int )subcommand_option == 3U) {
#line 2728
    goto case_3;
  }
#line 2732
  if ((unsigned int )subcommand_option == 6U) {
#line 2732
    goto case_6;
  }
#line 2742
  if ((unsigned int )subcommand_option == 7U) {
#line 2742
    goto case_7;
  }
#line 2746
  if ((unsigned int )subcommand_option == 5U) {
#line 2746
    goto case_5;
  }
#line 2751
  if ((unsigned int )subcommand_option == 9U) {
#line 2751
    goto case_9;
  }
#line 2712
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 2715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2715
    if (error_hook) {
      {
#line 2715
      (*error_hook)();
      }
    }
    {
#line 2715
    tmp___0 = gettext("You must specify one of the \'-Acdtrux\', \'--delete\' or \'--test-label\' options");
#line 2715
    error(0, 0, (char const   *)tmp___0);
#line 2715
    usage(2);
    }
#line 2715
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  case_1: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 2721
  update_archive();
  }
#line 2722
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2725
  delete_archive_members();
  }
#line 2726
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2729
  create_archive();
  }
#line 2730
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2733
  extr_init();
#line 2734
  read_and(& extract_archive);
#line 2738
  extract_finish();
  }
#line 2740
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2743
  read_and(& list_archive);
  }
#line 2744
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2747
  diff_init();
#line 2748
  read_and(& diff_archive);
  }
#line 2749
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 2752
  test_archive_label();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 2755
  checkpoint_finish();
  }
#line 2757
  if (totals_option) {
    {
#line 2758
    print_total_stats();
    }
  }
#line 2760
  if (check_links_option) {
    {
#line 2761
    check_links();
    }
  }
#line 2763
  if (volno_file_option) {
    {
#line 2764
    closeout_volume_number();
    }
  }
  {
#line 2768
  free((void *)archive_name_array);
#line 2769
  xattrs_clear_setup();
#line 2770
  name_term();
  }
#line 2772
  if (exit_status == 2) {
    {
#line 2773
    tmp___1 = gettext("Exiting with failure status due to previous errors");
#line 2773
    error(0, 0, (char const   *)tmp___1);
    }
  }
#line 2775
  if ((unsigned long )stdlis == (unsigned long )stdout) {
    {
#line 2776
    close_stdout();
    }
  } else {
    {
#line 2777
    tmp___2 = ferror_unlocked(stderr);
    }
#line 2777
    if (tmp___2) {
      {
#line 2778
      set_exit_status(2);
      }
    } else {
      {
#line 2777
      tmp___3 = fclose(stderr);
      }
#line 2777
      if (tmp___3 != 0) {
        {
#line 2778
        set_exit_status(2);
        }
      }
    }
  }
#line 2780
  return (exit_status);
}
}
#line 2783 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
void tar_stat_init(struct tar_stat_info *st ) 
{ 


  {
  {
#line 2786
  memset((void *)st, 0, sizeof(*st));
  }
#line 2787
  return;
}
}
#line 2792 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
_Bool tar_stat_close(struct tar_stat_info *st ) 
{ 
  int status ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 2795
  if (st->dirstream) {
    {
#line 2795
    tmp = closedir(st->dirstream);
#line 2795
    tmp___2 = tmp;
    }
  } else {
#line 2795
    if (0 < st->fd) {
      {
#line 2795
      tmp___0 = close(st->fd);
#line 2795
      tmp___1 = tmp___0;
      }
    } else {
#line 2795
      tmp___1 = 0;
    }
#line 2795
    tmp___2 = tmp___1;
  }
#line 2795
  status = tmp___2;
#line 2798
  st->dirstream = (DIR *)0;
#line 2799
  st->fd = 0;
#line 2801
  if (status == 0) {
#line 2802
    return ((_Bool)1);
  } else {
    {
#line 2805
    close_diag((char const   *)st->orig_file_name);
    }
#line 2806
    return ((_Bool)0);
  }
}
}
#line 2810 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
void tar_stat_destroy(struct tar_stat_info *st ) 
{ 


  {
  {
#line 2813
  tar_stat_close(st);
#line 2814
  xheader_xattr_free(st->xattr_map, st->xattr_map_size);
#line 2815
  free((void *)st->orig_file_name);
#line 2816
  free((void *)st->file_name);
#line 2817
  free((void *)st->link_name);
#line 2818
  free((void *)st->uname);
#line 2819
  free((void *)st->gname);
#line 2820
  free((void *)st->cntx_name);
#line 2821
  free((void *)st->acls_a_ptr);
#line 2822
  free((void *)st->acls_d_ptr);
#line 2823
  free((void *)st->sparse_map);
#line 2824
  free((void *)st->dumpdir);
#line 2825
  xheader_destroy(& st->xhdr);
#line 2826
  info_free_exclist(st);
#line 2827
  memset((void *)st, 0, sizeof(*st));
  }
#line 2828
  return;
}
}
#line 2836 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
int tar_timespec_cmp(struct timespec a , struct timespec b ) 
{ 
  int __attribute__((__pure__))  tmp ;

  {
#line 2839
  if (! ((1 << (unsigned int )current_format) & (1 << 4))) {
#line 2840
    b.tv_nsec = (__syscall_slong_t )0;
#line 2840
    a.tv_nsec = b.tv_nsec;
  }
  {
#line 2841
  tmp = timespec_cmp(a, b);
  }
#line 2841
  return ((int )tmp);
}
}
#line 2847 "/home/khheo/project/benchmark/tar-1.29/src/tar.c"
void set_exit_status(int val___0 ) 
{ 


  {
#line 2850
  if (val___0 > exit_status) {
#line 2851
    exit_status = val___0;
  }
#line 2852
  return;
}
}
#line 203 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 548
extern char **environ ;
#line 566
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 581
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 587
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 1017
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 123 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 461
void clear_read_error_count(void) ;
#line 462
void xclose(int fd ) ;
#line 463
 __attribute__((__noreturn__)) void archive_write_error(ssize_t status ) ;
#line 464
void archive_read_error(void) ;
#line 482
char const   *first_decompress_program(int *pstate ) ;
#line 483
char const   *next_decompress_program(int *pstate ) ;
#line 695
_Bool maybe_backup_file(char const   *file_name___0 , _Bool this_is_the_archive ) ;
#line 696
void undo_last_backup(void) ;
#line 723
pid_t xfork(void) ;
#line 724
void xpipe(int *fd ) ;
#line 846
void sys_detect_dev_null_output(void) ;
#line 847
void sys_save_archive_dev_ino(void) ;
#line 848
void sys_wait_for_child(pid_t child_pid___0 , _Bool eof ) ;
#line 849
void sys_spawn_shell(void) ;
#line 850
_Bool sys_compare_uid(struct stat *a , struct stat *b ) ;
#line 851
_Bool sys_compare_gid(struct stat *a , struct stat *b ) ;
#line 852
_Bool sys_file_is_archive(struct tar_stat_info *p ) ;
#line 853
_Bool sys_compare_links(struct stat *link_data , struct stat *stat_data ) ;
#line 854
int sys_truncate(int fd ) ;
#line 855
pid_t sys_child_open_for_compress(void) ;
#line 856
pid_t sys_child_open_for_uncompress(void) ;
#line 857
size_t sys_write_archive_buffer(void) ;
#line 858
_Bool sys_get_archive_stat(void) ;
#line 859
int sys_exec_command(char *file_name___0 , int typechar , struct tar_stat_info *st ) ;
#line 860
void sys_wait_command(void) ;
#line 861
int sys_exec_info_script(char const   **archive_name , int volume_number ) ;
#line 862
void sys_exec_checkpoint_script(char const   *script_name , char const   *archive_name ,
                                int checkpoint_number ) ;
#line 974
#pragma GCC diagnostic pop
#line 23 "../gnu/priv-set.h"
#pragma GCC diagnostic push
#line 23
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 23
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 64
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static  __attribute__((__noreturn__)) void xexec(char const   *cmd ) ;
#line 27 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void xexec(char const   *cmd ) 
{ 
  char *argv[4] ;

  {
  {
#line 32
  argv[0] = (char *)"/bin/sh";
#line 33
  argv[1] = (char *)"-c";
#line 34
  argv[2] = (char *)cmd;
#line 35
  argv[3] = (char *)((void *)0);
#line 37
  execv("/bin/sh", (char * const  *)(argv));
#line 38
  exec_fatal(cmd);
  }
}
}
#line 130
union block *record_start ;
#line 132 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static struct stat archive_stat  ;
#line 134 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
_Bool sys_get_archive_stat(void) 
{ 
  int tmp ;

  {
  {
#line 137
  tmp = fstat(archive, & archive_stat);
  }
#line 137
  return ((_Bool )(tmp == 0));
}
}
#line 140 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
_Bool sys_file_is_archive(struct tar_stat_info *p ) 
{ 
  int tmp ;

  {
#line 143
  if (ar_dev) {
#line 143
    if (p->stat.st_dev == ar_dev) {
#line 143
      if (p->stat.st_ino == ar_ino) {
#line 143
        tmp = 1;
      } else {
#line 143
        tmp = 0;
      }
    } else {
#line 143
      tmp = 0;
    }
  } else {
#line 143
    tmp = 0;
  }
#line 143
  return ((_Bool )tmp);
}
}
#line 147 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
void sys_save_archive_dev_ino(void) 
{ 


  {
#line 150
  if (! (archive >= 1 << 30)) {
#line 150
    if ((archive_stat.st_mode & 61440U) == 32768U) {
#line 152
      ar_dev = archive_stat.st_dev;
#line 153
      ar_ino = archive_stat.st_ino;
    } else {
#line 156
      ar_dev = (dev_t )0;
    }
  } else {
#line 156
    ar_dev = (dev_t )0;
  }
#line 157
  return;
}
}
#line 163 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static char const   dev_null[10]  = 
#line 163
  {      (char const   )'/',      (char const   )'d',      (char const   )'e',      (char const   )'v', 
        (char const   )'/',      (char const   )'n',      (char const   )'u',      (char const   )'l', 
        (char const   )'l',      (char const   )'\000'};
#line 160 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
void sys_detect_dev_null_output(void) 
{ 
  struct stat dev_null_stat ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 166
  tmp = strcmp(*(archive_name_array + 0), dev_null);
  }
#line 166
  if (tmp == 0) {
#line 166
    tmp___1 = 1;
  } else
#line 166
  if (! (archive >= 1 << 30)) {
#line 166
    if ((archive_stat.st_mode & 61440U) == 8192U) {
      {
#line 166
      tmp___0 = stat((char const   */* __restrict  */)(dev_null), (struct stat */* __restrict  */)(& dev_null_stat));
      }
#line 166
      if (tmp___0 == 0) {
#line 166
        if (archive_stat.st_dev == dev_null_stat.st_dev) {
#line 166
          if (archive_stat.st_ino == dev_null_stat.st_ino) {
#line 166
            tmp___1 = 1;
          } else {
#line 166
            tmp___1 = 0;
          }
        } else {
#line 166
          tmp___1 = 0;
        }
      } else {
#line 166
        tmp___1 = 0;
      }
    } else {
#line 166
      tmp___1 = 0;
    }
  } else {
#line 166
    tmp___1 = 0;
  }
#line 166
  dev_null_output = (_Bool )tmp___1;
#line 172
  return;
}
}
#line 174 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
void sys_wait_for_child(pid_t child_pid___0 , _Bool eof ) 
{ 
  int wait_status ;
  int *tmp ;
  __pid_t tmp___0 ;
  int sig ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 177
  if (child_pid___0) {
    {
#line 181
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 181
      tmp___0 = waitpid(child_pid___0, & wait_status, 0);
      }
#line 181
      if (! (tmp___0 == -1)) {
#line 181
        goto while_break;
      }
      {
#line 182
      tmp = __errno_location();
      }
#line 182
      if (*tmp != 4) {
        {
#line 184
        waitpid_error(use_compress_program_option);
        }
#line 185
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 188
    if ((int )((signed char )((wait_status & 127) + 1)) >> 1 > 0) {
#line 190
      sig = wait_status & 127;
#line 191
      if (! eof) {
#line 191
        if (! (sig == 13)) {
#line 191
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 192
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 192
          if (error_hook) {
            {
#line 192
            (*error_hook)();
            }
          }
          {
#line 192
          tmp___1 = gettext("Child died with signal %d");
#line 192
          error(0, 0, (char const   *)tmp___1, sig);
#line 192
          fatal_exit();
          }
#line 192
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    } else
#line 194
    if ((wait_status & 65280) >> 8 != 0) {
      {
#line 195
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 195
        if (error_hook) {
          {
#line 195
          (*error_hook)();
          }
        }
        {
#line 195
        tmp___2 = gettext("Child returned status %d");
#line 195
        error(0, 0, (char const   *)tmp___2, (wait_status & 65280) >> 8);
#line 195
        fatal_exit();
        }
#line 195
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
#line 198
  return;
}
}
#line 200 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
void sys_spawn_shell(void) 
{ 
  pid_t child ;
  char const   *shell ;
  char *tmp ;
  int wait_status ;
  int *tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 204
  tmp = getenv("SHELL");
#line 204
  shell = (char const   *)tmp;
  }
#line 205
  if (! shell) {
#line 206
    shell = "/bin/sh";
  }
  {
#line 207
  child = xfork();
  }
#line 208
  if (child == 0) {
    {
#line 210
    priv_set_remove_linkdir();
#line 211
    execlp(shell, "-sh", "-i", (void *)0);
#line 212
    exec_fatal(shell);
    }
  } else {
    {
#line 217
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 217
      tmp___1 = waitpid(child, & wait_status, 0);
      }
#line 217
      if (! (tmp___1 == -1)) {
#line 217
        goto while_break;
      }
      {
#line 218
      tmp___0 = __errno_location();
      }
#line 218
      if (*tmp___0 != 4) {
        {
#line 220
        waitpid_error(shell);
        }
#line 221
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 224
  return;
}
}
#line 226 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
_Bool sys_compare_uid(struct stat *a , struct stat *b ) 
{ 


  {
#line 229
  return ((_Bool )(a->st_uid == b->st_uid));
}
}
#line 232 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
_Bool sys_compare_gid(struct stat *a , struct stat *b ) 
{ 


  {
#line 235
  return ((_Bool )(a->st_gid == b->st_gid));
}
}
#line 238 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
_Bool sys_compare_links(struct stat *link_data , struct stat *stat_data ) 
{ 
  int tmp ;

  {
#line 241
  if (stat_data->st_dev == link_data->st_dev) {
#line 241
    if (stat_data->st_ino == link_data->st_ino) {
#line 241
      tmp = 1;
    } else {
#line 241
      tmp = 0;
    }
  } else {
#line 241
    tmp = 0;
  }
#line 241
  return ((_Bool )tmp);
}
}
#line 245 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
int sys_truncate(int fd ) 
{ 
  off_t pos ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 248
  tmp = lseek(fd, (off_t )0, 1);
#line 248
  pos = tmp;
  }
#line 249
  if (pos < 0L) {
#line 249
    tmp___1 = -1;
  } else {
    {
#line 249
    tmp___0 = ftruncate(fd, pos);
#line 249
    tmp___1 = tmp___0;
    }
  }
#line 249
  return (tmp___1);
}
}
#line 254 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static int is_regular_file(char const   *name ) 
{ 
  struct stat stbuf ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 259
  tmp___0 = stat((char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& stbuf));
  }
#line 259
  if (tmp___0 == 0) {
#line 260
    return ((stbuf.st_mode & 61440U) == 32768U);
  } else {
    {
#line 262
    tmp = __errno_location();
    }
#line 262
    return (*tmp == 2);
  }
}
}
#line 265 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
size_t sys_write_archive_buffer(void) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 268
  if (archive >= 1 << 30) {
    {
#line 268
    tmp = rmt_write__(archive - (1 << 30), record_start->buffer, record_size);
#line 268
    tmp___1 = tmp;
    }
  } else {
    {
#line 268
    tmp___0 = full_write(archive, (void const   *)(record_start->buffer), record_size);
#line 268
    tmp___1 = tmp___0;
    }
  }
#line 268
  return (tmp___1);
}
}
#line 276 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void xdup2(int from , int into ) 
{ 
  int status ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int e___0 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 279
  if (from != into) {
    {
#line 281
    tmp = close(into);
#line 281
    status = tmp;
    }
#line 283
    if (status != 0) {
      {
#line 283
      tmp___2 = __errno_location();
      }
#line 283
      if (*tmp___2 != 9) {
        {
#line 285
        tmp___0 = __errno_location();
#line 285
        e = *tmp___0;
        }
        {
#line 286
        while (1) {
          while_continue: /* CIL Label */ ;
#line 286
          if (error_hook) {
            {
#line 286
            (*error_hook)();
            }
          }
          {
#line 286
          tmp___1 = gettext("Cannot close");
#line 286
          error(0, e, (char const   *)tmp___1);
#line 286
          fatal_exit();
          }
#line 286
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
    {
#line 288
    status = dup(from);
    }
#line 289
    if (status != into) {
#line 291
      if (status < 0) {
        {
#line 293
        tmp___3 = __errno_location();
#line 293
        e___0 = *tmp___3;
        }
        {
#line 294
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 294
          if (error_hook) {
            {
#line 294
            (*error_hook)();
            }
          }
          {
#line 294
          tmp___4 = gettext("Cannot dup");
#line 294
          error(0, e___0, (char const   *)tmp___4);
#line 294
          fatal_exit();
          }
#line 294
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 296
      abort();
      }
    }
    {
#line 298
    xclose(from);
    }
  }
#line 300
  return;
}
}
#line 302
static  __attribute__((__noreturn__)) void wait_for_grandchild(pid_t pid ) ;
#line 305
static  __attribute__((__noreturn__)) void wait_for_grandchild(pid_t pid ) ;
#line 305 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void wait_for_grandchild(pid_t pid ) 
{ 
  int wait_status ;
  int exit_code ;
  int *tmp ;
  __pid_t tmp___0 ;

  {
#line 309
  exit_code = 0;
  {
#line 311
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 311
    tmp___0 = waitpid(pid, & wait_status, 0);
    }
#line 311
    if (! (tmp___0 == -1)) {
#line 311
      goto while_break;
    }
    {
#line 312
    tmp = __errno_location();
    }
#line 312
    if (*tmp != 4) {
      {
#line 314
      waitpid_error(use_compress_program_option);
      }
#line 315
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  if ((int )((signed char )((wait_status & 127) + 1)) >> 1 > 0) {
    {
#line 319
    raise(wait_status & 127);
    }
  } else
#line 320
  if ((wait_status & 65280) >> 8 != 0) {
#line 321
    exit_code = (wait_status & 65280) >> 8;
  }
  {
#line 323
  exit(exit_code);
  }
}
}
#line 327 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
pid_t sys_child_open_for_compress(void) 
{ 
  int parent_pipe[2] ;
  int child_pipe[2] ;
  pid_t grandchild_pid ;
  pid_t child_pid___0 ;
  char *tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  size_t status ;
  char *cursor ;
  size_t length ;
  size_t size ;

  {
  {
#line 335
  signal(13, (void (*)(int  ))1);
#line 336
  xpipe((int *)(parent_pipe));
#line 337
  child_pid___0 = xfork();
  }
#line 339
  if (child_pid___0 > 0) {
    {
#line 343
    archive = parent_pipe[1];
#line 344
    xclose(parent_pipe[0]);
    }
#line 345
    return (child_pid___0);
  }
  {
#line 350
  tmp = gettext("tar (child)");
#line 350
  set_program_name((char const   *)tmp);
#line 351
  signal(13, (void (*)(int  ))0);
#line 353
  xdup2(parent_pipe[0], 0);
#line 354
  xclose(parent_pipe[1]);
  }
#line 360
  if (! force_local_option) {
    {
#line 360
    tmp___3 = strchr(*(archive_name_array + 0), ':');
#line 360
    rmt_dev_name__ = (char const   *)tmp___3;
    }
#line 360
    if (rmt_dev_name__) {
#line 360
      if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
        {
#line 360
        tmp___4 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
        }
#line 360
        if (tmp___4) {
#line 360
          goto _L___1;
        }
      } else {
#line 360
        goto _L___1;
      }
    } else {
#line 360
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
    {
#line 360
    tmp___5 = is_regular_file(*(archive_name_array + 0));
    }
#line 360
    if (tmp___5) {
#line 363
      if (backup_option) {
        {
#line 364
        maybe_backup_file(*(archive_name_array + 0), (_Bool)1);
        }
      }
      {
#line 368
      tmp___2 = strcmp(*(archive_name_array + 0), "-");
      }
#line 368
      if (tmp___2) {
        {
#line 370
        archive = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
        }
#line 371
        if (archive < 0) {
          {
#line 373
          tmp___0 = __errno_location();
#line 373
          saved_errno = *tmp___0;
          }
#line 375
          if (backup_option) {
            {
#line 376
            undo_last_backup();
            }
          }
          {
#line 377
          tmp___1 = __errno_location();
#line 377
          *tmp___1 = saved_errno;
#line 378
          open_fatal(*(archive_name_array + 0));
          }
        }
        {
#line 380
        xdup2(archive, 1);
        }
      }
      {
#line 382
      priv_set_remove_linkdir();
#line 383
      xexec(use_compress_program_option);
      }
    }
  }
  {
#line 388
  xpipe((int *)(child_pipe));
#line 389
  grandchild_pid = xfork();
  }
#line 391
  if (grandchild_pid == 0) {
    {
#line 395
    tmp___6 = gettext("tar (grandchild)");
#line 395
    set_program_name((char const   *)tmp___6);
#line 397
    xdup2(child_pipe[1], 1);
#line 398
    xclose(child_pipe[0]);
#line 399
    priv_set_remove_linkdir();
#line 400
    xexec(use_compress_program_option);
    }
  }
  {
#line 407
  xdup2(child_pipe[0], 0);
#line 408
  xclose(child_pipe[1]);
#line 410
  tmp___13 = strcmp(*(archive_name_array + 0), "-");
  }
#line 410
  if (tmp___13 == 0) {
#line 411
    archive = 1;
  } else {
#line 414
    if (! force_local_option) {
      {
#line 414
      tmp___11 = strchr(*(archive_name_array + 0), ':');
#line 414
      rmt_dev_name__ = (char const   *)tmp___11;
      }
#line 414
      if (rmt_dev_name__) {
#line 414
        if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
          {
#line 414
          tmp___12 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
          }
#line 414
          if (tmp___12) {
            {
#line 414
            tmp___10 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 414
            archive = tmp___10;
            }
          } else {
            {
#line 414
            tmp___9 = rmt_open__(*(archive_name_array + 0), 65, 1 << 30, rsh_command_option);
#line 414
            archive = tmp___9;
            }
          }
        } else {
          {
#line 414
          tmp___10 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 414
          archive = tmp___10;
          }
        }
      } else {
        {
#line 414
        tmp___10 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 414
        archive = tmp___10;
        }
      }
    } else {
      {
#line 414
      tmp___10 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 414
      archive = tmp___10;
      }
    }
#line 415
    if (archive < 0) {
      {
#line 416
      open_fatal(*(archive_name_array + 0));
      }
    }
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    status = (size_t )0;
#line 429
    length = (size_t )0;
#line 429
    cursor = record_start->buffer;
    {
#line 429
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 429
      if (! (length < record_size)) {
#line 429
        goto while_break___0;
      }
      {
#line 433
      size = record_size - length;
#line 435
      status = safe_read(0, (void *)cursor, size);
      }
#line 436
      if (status == 0xffffffffffffffffUL) {
        {
#line 437
        read_fatal(use_compress_program_option);
        }
      }
#line 438
      if (status == 0UL) {
#line 439
        goto while_break___0;
      }
#line 429
      length += status;
#line 429
      cursor += status;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 444
    if (status == 0UL) {
#line 450
      if (length > 0UL) {
        {
#line 452
        memset((void *)(record_start->buffer + length), 0, record_size - length);
#line 453
        status = sys_write_archive_buffer();
        }
#line 454
        if (status != record_size) {
          {
#line 455
          archive_write_error((ssize_t )status);
          }
        }
      }
#line 459
      goto while_break;
    }
    {
#line 462
    status = sys_write_archive_buffer();
    }
#line 463
    if (status != record_size) {
      {
#line 464
      archive_write_error((ssize_t )status);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 467
  wait_for_grandchild(grandchild_pid);
  }
}
}
#line 470 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void run_decompress_program(void) 
{ 
  int i ;
  char const   *p ;
  char const   *prog ;
  struct wordsplit ws ;
  int wsflags ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 474
  prog = (char const   *)((void *)0);
#line 476
  wsflags = 34082310;
#line 478
  ws.ws_env = (char const   **)environ;
#line 479
  ws.ws_offs = (size_t )1;
#line 481
  p = first_decompress_program(& i);
  }
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! p) {
#line 481
      goto while_break;
    }
#line 483
    if (prog) {
      {
#line 485
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 485
        if (warning_option & 524288) {
          {
#line 485
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 485
            if (error_hook) {
              {
#line 485
              (*error_hook)();
              }
            }
            {
#line 485
            tmp = gettext("cannot run %s");
#line 485
            tmp___0 = __errno_location();
#line 485
            error(0, *tmp___0, (char const   *)tmp, prog);
            }
#line 485
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 485
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 487
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 487
        if (warning_option & 524288) {
          {
#line 487
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 487
            if (error_hook) {
              {
#line 487
              (*error_hook)();
              }
            }
            {
#line 487
            tmp___1 = gettext("trying %s");
#line 487
            error(0, 0, (char const   *)tmp___1, p);
            }
#line 487
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
#line 487
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    {
#line 490
    tmp___4 = wordsplit(p, & ws, wsflags);
    }
#line 490
    if (tmp___4) {
      {
#line 491
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 491
        if (error_hook) {
          {
#line 491
          (*error_hook)();
          }
        }
        {
#line 491
        tmp___2 = wordsplit_strerror(& ws);
#line 491
        tmp___3 = gettext("cannot split string \'%s\': %s");
#line 491
        error(0, 0, (char const   *)tmp___3, p, tmp___2);
#line 491
        fatal_exit();
        }
#line 491
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 493
    wsflags |= 8;
#line 494
    memmove((void *)ws.ws_wordv, (void const   *)(ws.ws_wordv + ws.ws_offs), sizeof(*(ws.ws_wordv + 0)) * ws.ws_wordc);
#line 496
    *(ws.ws_wordv + ws.ws_wordc) = (char *)"-d";
#line 497
    prog = p;
#line 498
    execvp((char const   *)*(ws.ws_wordv + 0), (char * const  *)ws.ws_wordv);
#line 499
    *(ws.ws_wordv + ws.ws_wordc) = (char *)((void *)0);
#line 481
    p = next_decompress_program(& i);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  if (! prog) {
    {
#line 502
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 502
      if (error_hook) {
        {
#line 502
        (*error_hook)();
        }
      }
      {
#line 502
      tmp___5 = gettext("unable to run decompression program");
#line 502
      error(0, 0, (char const   *)tmp___5);
#line 502
      fatal_exit();
      }
#line 502
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  {
#line 503
  exec_fatal(prog);
  }
}
}
#line 507 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
pid_t sys_child_open_for_uncompress(void) 
{ 
  int parent_pipe[2] ;
  int child_pipe[2] ;
  pid_t grandchild_pid ;
  pid_t child_pid___0 ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  char *cursor ;
  size_t maximum ;
  size_t count ;
  size_t status ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;

  {
  {
#line 515
  xpipe((int *)(parent_pipe));
#line 516
  child_pid___0 = xfork();
  }
#line 518
  if (child_pid___0 > 0) {
    {
#line 522
    archive = parent_pipe[0];
#line 523
    xclose(parent_pipe[1]);
    }
#line 524
    return (child_pid___0);
  }
  {
#line 529
  tmp = gettext("tar (child)");
#line 529
  set_program_name((char const   *)tmp);
#line 530
  signal(13, (void (*)(int  ))0);
#line 532
  xdup2(parent_pipe[1], 1);
#line 533
  xclose(parent_pipe[0]);
#line 540
  tmp___0 = strcmp(*(archive_name_array + 0), "-");
  }
#line 540
  if (tmp___0 != 0) {
#line 540
    if (! force_local_option) {
      {
#line 540
      tmp___1 = strchr(*(archive_name_array + 0), ':');
#line 540
      rmt_dev_name__ = (char const   *)tmp___1;
      }
#line 540
      if (rmt_dev_name__) {
#line 540
        if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
          {
#line 540
          tmp___2 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
          }
#line 540
          if (tmp___2) {
#line 540
            goto _L___1;
          }
        } else {
#line 540
          goto _L___1;
        }
      } else {
#line 540
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 540
      tmp___3 = is_regular_file(*(archive_name_array + 0));
      }
#line 540
      if (tmp___3) {
        {
#line 547
        archive = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
        }
#line 548
        if (archive < 0) {
          {
#line 549
          open_fatal(*(archive_name_array + 0));
          }
        }
        {
#line 550
        xdup2(archive, 0);
#line 551
        priv_set_remove_linkdir();
#line 552
        run_decompress_program();
        }
      }
    }
  }
  {
#line 557
  xpipe((int *)(child_pipe));
#line 558
  grandchild_pid = xfork();
  }
#line 560
  if (grandchild_pid == 0) {
    {
#line 564
    tmp___4 = gettext("tar (grandchild)");
#line 564
    set_program_name((char const   *)tmp___4);
#line 566
    xdup2(child_pipe[0], 0);
#line 567
    xclose(child_pipe[1]);
#line 568
    priv_set_remove_linkdir();
#line 569
    run_decompress_program();
    }
  }
  {
#line 577
  xdup2(child_pipe[1], 1);
#line 578
  xclose(child_pipe[0]);
#line 580
  tmp___11 = strcmp(*(archive_name_array + 0), "-");
  }
#line 580
  if (tmp___11 == 0) {
#line 581
    archive = 0;
  } else
#line 583
  if (! force_local_option) {
    {
#line 583
    tmp___9 = strchr(*(archive_name_array + 0), ':');
#line 583
    rmt_dev_name__ = (char const   *)tmp___9;
    }
#line 583
    if (rmt_dev_name__) {
#line 583
      if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
        {
#line 583
        tmp___10 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
        }
#line 583
        if (tmp___10) {
          {
#line 583
          tmp___8 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 583
          archive = tmp___8;
          }
        } else {
          {
#line 583
          tmp___7 = rmt_open__(*(archive_name_array + 0), 0, 1 << 30, rsh_command_option);
#line 583
          archive = tmp___7;
          }
        }
      } else {
        {
#line 583
        tmp___8 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 583
        archive = tmp___8;
        }
      }
    } else {
      {
#line 583
      tmp___8 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 583
      archive = tmp___8;
      }
    }
  } else {
    {
#line 583
    tmp___8 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 583
    archive = tmp___8;
    }
  }
#line 585
  if (archive < 0) {
    {
#line 586
    open_fatal(*(archive_name_array + 0));
    }
  }
  {
#line 590
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 597
    clear_read_error_count();
    }
    error_loop: 
#line 600
    if (archive >= 1 << 30) {
      {
#line 600
      tmp___12 = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
#line 600
      status = tmp___12;
      }
    } else {
      {
#line 600
      tmp___13 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 600
      status = tmp___13;
      }
    }
#line 601
    if (status == 0xffffffffffffffffUL) {
      {
#line 603
      archive_read_error();
      }
#line 604
      goto error_loop;
    }
#line 606
    if (status == 0UL) {
#line 607
      goto while_break;
    }
#line 608
    cursor = record_start->buffer;
#line 609
    maximum = status;
    {
#line 610
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 610
      if (! maximum) {
#line 610
        goto while_break___0;
      }
#line 612
      if (maximum < 512UL) {
#line 612
        count = maximum;
      } else {
#line 612
        count = (size_t )512;
      }
      {
#line 613
      tmp___14 = full_write(1, (void const   *)cursor, count);
      }
#line 613
      if (tmp___14 != count) {
        {
#line 614
        write_error(use_compress_program_option);
        }
      }
#line 615
      cursor += count;
#line 616
      maximum -= count;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 620
  xclose(1);
#line 622
  wait_for_grandchild(grandchild_pid);
  }
}
}
#line 627 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void dec_to_env(char const   *envar , uintmax_t num ) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *numstr ;
  int tmp ;

  {
  {
#line 633
  numstr = umaxtostr(num, buf);
#line 634
  tmp = setenv(envar, (char const   *)numstr, 1);
  }
#line 634
  if (tmp != 0) {
    {
#line 635
    xalloc_die();
    }
  }
#line 636
  return;
}
}
#line 638 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void time_to_env(char const   *envar , struct timespec t ) 
{ 
  char buf[32] ;
  char const   *tmp ;
  int tmp___0 ;

  {
  {
#line 642
  tmp = code_timespec(t, buf);
#line 642
  tmp___0 = setenv(envar, tmp, 1);
  }
#line 642
  if (tmp___0 != 0) {
    {
#line 643
    xalloc_die();
    }
  }
#line 644
  return;
}
}
#line 646 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void oct_to_env(char const   *envar , unsigned long num ) 
{ 
  char buf[2UL + (sizeof(unsigned long ) * 8UL + 2UL) / 3UL] ;
  int tmp ;

  {
  {
#line 651
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"0%lo",
           num);
#line 652
  tmp = setenv(envar, (char const   *)(buf), 1);
  }
#line 652
  if (tmp != 0) {
    {
#line 653
    xalloc_die();
    }
  }
#line 654
  return;
}
}
#line 656 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void str_to_env(char const   *envar , char const   *str ) 
{ 
  int tmp ;

  {
#line 659
  if (str) {
    {
#line 661
    tmp = setenv(envar, str, 1);
    }
#line 661
    if (tmp != 0) {
      {
#line 662
      xalloc_die();
      }
    }
  } else {
    {
#line 665
    unsetenv(envar);
    }
  }
#line 666
  return;
}
}
#line 668 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void chr_to_env(char const   *envar , char c ) 
{ 
  char buf[2] ;
  int tmp ;

  {
  {
#line 672
  buf[0] = c;
#line 673
  buf[1] = (char)0;
#line 674
  tmp = setenv(envar, (char const   *)(buf), 1);
  }
#line 674
  if (tmp != 0) {
    {
#line 675
    xalloc_die();
    }
  }
#line 676
  return;
}
}
#line 678 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void stat_to_env(char *name , char type , struct tar_stat_info *st ) 
{ 
  unsigned int tmp ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
  {
#line 681
  str_to_env("TAR_VERSION", "1.29");
#line 682
  str_to_env("TAR_ARCHIVE", *archive_name_cursor);
#line 683
  dec_to_env("TAR_VOLUME", (uintmax_t )((archive_name_cursor - archive_name_array) + 1L));
#line 684
  dec_to_env("TAR_BLOCKING_FACTOR", (uintmax_t )blocking_factor);
  }
#line 685
  if ((unsigned int )current_format == 0U) {
#line 685
    tmp = (unsigned int )archive_format;
  } else {
#line 685
    tmp = (unsigned int )current_format;
  }
  {
#line 685
  tmp___0 = archive_format_string((enum archive_format )tmp);
#line 685
  str_to_env("TAR_FORMAT", tmp___0);
#line 688
  chr_to_env("TAR_FILETYPE", type);
#line 689
  oct_to_env("TAR_MODE", (unsigned long )st->stat.st_mode);
#line 690
  str_to_env("TAR_FILENAME", (char const   *)name);
#line 691
  str_to_env("TAR_REALNAME", (char const   *)st->file_name);
#line 692
  str_to_env("TAR_UNAME", (char const   *)st->uname);
#line 693
  str_to_env("TAR_GNAME", (char const   *)st->gname);
#line 694
  time_to_env("TAR_ATIME", st->atime);
#line 695
  time_to_env("TAR_MTIME", st->mtime);
#line 696
  time_to_env("TAR_CTIME", st->ctime);
#line 697
  dec_to_env("TAR_SIZE", (uintmax_t )st->stat.st_size);
#line 698
  dec_to_env("TAR_UID", (uintmax_t )st->stat.st_uid);
#line 699
  dec_to_env("TAR_GID", (uintmax_t )st->stat.st_gid);
  }
  {
#line 704
  if ((int )type == 99) {
#line 704
    goto case_99;
  }
#line 704
  if ((int )type == 98) {
#line 704
    goto case_99;
  }
#line 711
  if ((int )type == 104) {
#line 711
    goto case_104;
  }
#line 711
  if ((int )type == 108) {
#line 711
    goto case_104;
  }
#line 717
  goto switch_default;
  case_99: /* CIL Label */ 
  case_98: /* CIL Label */ 
  {
#line 705
  tmp___1 = gnu_dev_minor(st->stat.st_rdev);
#line 705
  dec_to_env("TAR_MINOR", (uintmax_t )tmp___1);
#line 706
  tmp___2 = gnu_dev_major(st->stat.st_rdev);
#line 706
  dec_to_env("TAR_MAJOR", (uintmax_t )tmp___2);
#line 707
  unsetenv("TAR_LINKNAME");
  }
#line 708
  goto switch_break;
  case_104: /* CIL Label */ 
  case_108: /* CIL Label */ 
  {
#line 712
  unsetenv("TAR_MINOR");
#line 713
  unsetenv("TAR_MAJOR");
#line 714
  str_to_env("TAR_LINKNAME", (char const   *)st->link_name);
  }
#line 715
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 718
  unsetenv("TAR_MINOR");
#line 719
  unsetenv("TAR_MAJOR");
#line 720
  unsetenv("TAR_LINKNAME");
  }
#line 721
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 723
  return;
}
}
#line 725 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static pid_t global_pid  ;
#line 726 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void (*pipe_handler)(int sig )  ;
#line 728 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
int sys_exec_command(char *file_name___0 , int typechar , struct tar_stat_info *st ) 
{ 
  int p[2] ;

  {
  {
#line 733
  xpipe((int *)(p));
#line 734
  pipe_handler = signal(13, (void (*)(int  ))1);
#line 735
  global_pid = xfork();
  }
#line 737
  if (global_pid != 0) {
    {
#line 739
    xclose(p[0]);
    }
#line 740
    return (p[1]);
  }
  {
#line 744
  xdup2(p[0], 0);
#line 745
  xclose(p[1]);
#line 747
  stat_to_env(file_name___0, (char )typechar, st);
#line 749
  priv_set_remove_linkdir();
#line 750
  xexec((char const   *)to_command_option);
  }
}
}
#line 753 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
void sys_wait_command(void) 
{ 
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 758
  if (global_pid < 0) {
#line 759
    return;
  }
  {
#line 761
  signal(13, pipe_handler);
  }
  {
#line 762
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 762
    tmp___0 = waitpid(global_pid, & status, 0);
    }
#line 762
    if (! (tmp___0 == -1)) {
#line 762
      goto while_break;
    }
    {
#line 763
    tmp = __errno_location();
    }
#line 763
    if (*tmp != 4) {
      {
#line 765
      global_pid = -1;
#line 766
      waitpid_error((char const   *)to_command_option);
      }
#line 767
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 770
  if ((status & 127) == 0) {
#line 772
    if (! ignore_command_error_option) {
#line 772
      if ((status & 65280) >> 8) {
        {
#line 773
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 773
          if (error_hook) {
            {
#line 773
            (*error_hook)();
            }
          }
          {
#line 773
          tmp___1 = gettext("%lu: Child returned status %d");
#line 773
          error(0, 0, (char const   *)tmp___1, (unsigned long )global_pid, (status & 65280) >> 8);
#line 773
          exit_status = 2;
          }
#line 773
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
  } else
#line 776
  if ((int )((signed char )((status & 127) + 1)) >> 1 > 0) {
    {
#line 778
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 778
      if (error_hook) {
        {
#line 778
        (*error_hook)();
        }
      }
      {
#line 778
      tmp___2 = gettext("%lu: Child terminated on signal %d");
#line 778
      error(0, 0, (char const   *)tmp___2, (unsigned long )global_pid, status & 127);
      }
#line 778
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 782
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 782
      if (error_hook) {
        {
#line 782
        (*error_hook)();
        }
      }
      {
#line 782
      tmp___3 = gettext("%lu: Child terminated on unknown reason");
#line 782
      error(0, 0, (char const   *)tmp___3, (unsigned long )global_pid);
#line 782
      exit_status = 2;
      }
#line 782
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 785
  global_pid = -1;
#line 786
  return;
}
}
#line 794 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
static void (*saved_handler)(int sig )  ;
#line 788 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
int sys_exec_info_script(char const   **archive_name , int volume_number ) 
{ 
  pid_t pid ;
  char uintbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int p[2] ;
  int rc ;
  int status ;
  char *buf ;
  size_t size ;
  FILE *fp ;
  __ssize_t tmp ;
  int *tmp___0 ;
  __pid_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  unsigned int tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;

  {
  {
#line 796
  xpipe((int *)(p));
#line 797
  saved_handler = signal(13, (void (*)(int  ))1);
#line 799
  pid = xfork();
  }
#line 801
  if (pid != 0) {
    {
#line 807
    buf = (char *)((void *)0);
#line 808
    size = (size_t )0;
#line 811
    xclose(p[1]);
#line 812
    fp = fdopen(p[0], "r");
#line 813
    tmp = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& size),
                  (FILE */* __restrict  */)fp);
#line 813
    rc = (int )tmp;
#line 814
    fclose(fp);
    }
#line 816
    if (rc > 0) {
#line 816
      if ((int )*(buf + (rc - 1)) == 10) {
#line 817
        rc --;
#line 817
        *(buf + rc) = (char)0;
      }
    }
    {
#line 819
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 819
      tmp___1 = waitpid(pid, & status, 0);
      }
#line 819
      if (! (tmp___1 == -1)) {
#line 819
        goto while_break;
      }
      {
#line 820
      tmp___0 = __errno_location();
      }
#line 820
      if (*tmp___0 != 4) {
        {
#line 822
        signal(13, saved_handler);
#line 823
        waitpid_error(info_script_option);
        }
#line 824
        return (-1);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 827
    signal(13, saved_handler);
    }
#line 829
    if ((status & 127) == 0) {
#line 831
      if ((status & 65280) >> 8 == 0) {
#line 831
        if (rc > 0) {
#line 832
          *archive_name = (char const   *)buf;
        } else {
          {
#line 834
          free((void *)buf);
          }
        }
      } else {
        {
#line 834
        free((void *)buf);
        }
      }
#line 835
      return ((status & 65280) >> 8);
    }
    {
#line 838
    free((void *)buf);
    }
#line 839
    return (-1);
  }
  {
#line 843
  setenv("TAR_VERSION", "1.29", 1);
#line 844
  setenv("TAR_ARCHIVE", *archive_name, 1);
#line 845
  tmp___2 = umaxtostr((uintmax_t )volume_number, uintbuf);
#line 845
  setenv("TAR_VOLUME", (char const   *)tmp___2, 1);
#line 846
  tmp___3 = umaxtostr((uintmax_t )blocking_factor, uintbuf);
#line 846
  setenv("TAR_BLOCKING_FACTOR", (char const   *)tmp___3, 1);
#line 848
  tmp___4 = subcommand_string(subcommand_option);
#line 848
  setenv("TAR_SUBCOMMAND", tmp___4, 1);
  }
#line 849
  if ((unsigned int )current_format == 0U) {
#line 849
    tmp___5 = (unsigned int )archive_format;
  } else {
#line 849
    tmp___5 = (unsigned int )current_format;
  }
  {
#line 849
  tmp___6 = archive_format_string((enum archive_format )tmp___5);
#line 849
  setenv("TAR_FORMAT", tmp___6, 1);
#line 852
  tmp___7 = umaxtostr((uintmax_t )p[1], uintbuf);
#line 852
  setenv("TAR_FD", (char const   *)tmp___7, 1);
#line 854
  xclose(p[0]);
#line 856
  priv_set_remove_linkdir();
#line 857
  xexec(info_script_option);
  }
}
}
#line 860 "/home/khheo/project/benchmark/tar-1.29/src/system.c"
void sys_exec_checkpoint_script(char const   *script_name , char const   *archive_name ,
                                int checkpoint_number ) 
{ 
  pid_t pid ;
  char uintbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int status ;
  int *tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  unsigned int tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 868
  pid = xfork();
  }
#line 870
  if (pid != 0) {
    {
#line 876
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 876
      tmp___0 = waitpid(pid, & status, 0);
      }
#line 876
      if (! (tmp___0 == -1)) {
#line 876
        goto while_break;
      }
      {
#line 877
      tmp = __errno_location();
      }
#line 877
      if (*tmp != 4) {
        {
#line 879
        waitpid_error(script_name);
        }
#line 880
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 883
    return;
  }
  {
#line 887
  setenv("TAR_VERSION", "1.29", 1);
#line 888
  setenv("TAR_ARCHIVE", archive_name, 1);
#line 889
  tmp___1 = umaxtostr((uintmax_t )checkpoint_number, uintbuf);
#line 889
  setenv("TAR_CHECKPOINT", (char const   *)tmp___1, 1);
#line 890
  tmp___2 = umaxtostr((uintmax_t )blocking_factor, uintbuf);
#line 890
  setenv("TAR_BLOCKING_FACTOR", (char const   *)tmp___2, 1);
#line 892
  tmp___3 = subcommand_string(subcommand_option);
#line 892
  setenv("TAR_SUBCOMMAND", tmp___3, 1);
  }
#line 893
  if ((unsigned int )current_format == 0U) {
#line 893
    tmp___4 = (unsigned int )archive_format;
  } else {
#line 893
    tmp___4 = (unsigned int )current_format;
  }
  {
#line 893
  tmp___5 = archive_format_string((enum archive_format )tmp___4);
#line 893
  setenv("TAR_FORMAT", tmp___5, 1);
#line 896
  priv_set_remove_linkdir();
#line 897
  xexec(script_name);
  }
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 974
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
static struct compression_suffix compression_suffixes[17]  = 
#line 29 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
  {      {"tar", (size_t )3, (char const   *)((void *)0)}, 
        {"gz", sizeof("gz") - 1UL, "gzip"}, 
        {"tgz", sizeof("tgz") - 1UL, "gzip"}, 
        {"taz", sizeof("taz") - 1UL, "gzip"}, 
        {"Z", sizeof("Z") - 1UL, "compress"}, 
        {"taZ", sizeof("taZ") - 1UL, "compress"}, 
        {"bz2", sizeof("bz2") - 1UL, "bzip2"}, 
        {"tbz", sizeof("tbz") - 1UL, "bzip2"}, 
        {"tbz2", sizeof("tbz2") - 1UL, "bzip2"}, 
        {"tz2", sizeof("tz2") - 1UL, "bzip2"}, 
        {"lz", sizeof("lz") - 1UL, "lzip"}, 
        {"lzma", sizeof("lzma") - 1UL, "lzma"}, 
        {"tlz", sizeof("tlz") - 1UL, "lzma"}, 
        {"lzo", sizeof("lzo") - 1UL, "lzop"}, 
        {"xz", sizeof("xz") - 1UL, "xz"}, 
        {"txz", sizeof("txz") - 1UL, "xz"}, 
        {(char const   *)((void *)0), 0UL, (char const   *)0}};
#line 53 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
static struct compression_suffix  const  *find_compression_suffix(char const   *name ,
                                                                  size_t *ret_len ) 
{ 
  char *suf ;
  char *tmp ;
  size_t len ;
  struct compression_suffix *p ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 56
  tmp = strrchr(name, '.');
#line 56
  suf = tmp;
  }
#line 58
  if (suf) {
    {
#line 63
    suf ++;
#line 64
    len = strlen((char const   *)suf);
#line 66
    p = compression_suffixes;
    }
    {
#line 66
    while (1) {
      while_continue: /* CIL Label */ ;
#line 66
      if (! p->suffix) {
#line 66
        goto while_break;
      }
#line 68
      if (p->length == len) {
        {
#line 68
        tmp___1 = memcmp((void const   *)p->suffix, (void const   *)suf, len);
        }
#line 68
        if (tmp___1 == 0) {
#line 70
          if (ret_len) {
            {
#line 71
            tmp___0 = strlen(name);
#line 71
            *ret_len = (tmp___0 - len) - 1UL;
            }
          }
#line 72
          return ((struct compression_suffix  const  *)p);
        }
      }
#line 66
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 76
  return ((struct compression_suffix  const  *)((void *)0));
}
}
#line 79 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
static char const   *find_compression_program(char const   *name , char const   *defprog ) 
{ 
  struct compression_suffix  const  *p ;
  struct compression_suffix  const  *tmp ;

  {
  {
#line 82
  tmp = find_compression_suffix(name, (size_t *)((void *)0));
#line 82
  p = tmp;
  }
#line 83
  if (p) {
#line 84
    return ((char const   *)p->program);
  }
#line 85
  return (defprog);
}
}
#line 88 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
void set_compression_program_by_suffix(char const   *name , char const   *defprog ) 
{ 
  char const   *program ;
  char const   *tmp ;

  {
  {
#line 91
  tmp = find_compression_program(name, defprog);
#line 91
  program = tmp;
  }
#line 92
  if (program) {
#line 93
    use_compress_program_option = program;
  }
#line 94
  return;
}
}
#line 96 "/home/khheo/project/benchmark/tar-1.29/src/suffix.c"
char *strip_compression_suffix(char const   *name ) 
{ 
  char *s ;
  size_t len ;
  int tmp ;
  void *tmp___0 ;
  struct compression_suffix  const  *tmp___1 ;

  {
  {
#line 99
  s = (char *)((void *)0);
#line 102
  tmp___1 = find_compression_suffix(name, & len);
  }
#line 102
  if (tmp___1) {
    {
#line 104
    tmp = strncmp((name + len) - 4, ".tar", (size_t )4);
    }
#line 104
    if (tmp == 0) {
#line 105
      len -= 4UL;
    }
#line 106
    if (len == 0UL) {
#line 107
      return ((char *)((void *)0));
    }
    {
#line 108
    tmp___0 = xmalloc(len + 1UL);
#line 108
    s = (char *)tmp___0;
#line 109
    memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)name, len);
#line 110
    *(s + len) = (char)0;
    }
  }
#line 112
  return (s);
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 448
off_t current_block_ordinal(void) ;
#line 474
void mv_begin_write(char const   *file_name___0 , off_t totsize , off_t sizeleft ) ;
#line 476
void mv_begin_read(struct tar_stat_info *st ) ;
#line 477
void mv_end(void) ;
#line 478
void mv_size_left(off_t size ) ;
#line 501
void pad_archive(off_t size_left ) ;
#line 504
union block *start_header(struct tar_stat_info *st ) ;
#line 505
void finish_header(struct tar_stat_info *st , union block *header , off_t block_ordinal ) ;
#line 523
_Bool off_to_chars(off_t v , char *p , size_t s ) ;
#line 605
off_t off_from_header(char const   *p , size_t s ) ;
#line 618
void skip_file(off_t size ) ;
#line 700
size_t blocking_read(int fd , void *buf , size_t count ) ;
#line 701
size_t blocking_write(int fd , void const   *buf , size_t count ) ;
#line 711
void read_diag_details(char const   *name , off_t offset , size_t size ) ;
#line 714
void seek_diag_details(char const   *name , off_t offset ) ;
#line 821
void xheader_store(char const   *keyword , struct tar_stat_info *st , void const   *data ) ;
#line 831
void xheader_string_begin(struct xheader *xhdr ) ;
#line 832
void xheader_string_add(struct xheader *xhdr , char const   *s ) ;
#line 833
_Bool xheader_string_end(struct xheader *xhdr , char const   *keyword ) ;
#line 834
_Bool xheader_keyword_deleted_p(char const   *kw ) ;
#line 835
char *xheader_format_name(struct tar_stat_info *st , char const   *fmt , size_t n ) ;
#line 867
void ( /* format attribute */  report_difference)(struct tar_stat_info *st , char const   *fmt 
                                                  , ...) ;
#line 871
_Bool sparse_member_p(struct tar_stat_info *st ) ;
#line 872
_Bool sparse_fixup_header(struct tar_stat_info *st ) ;
#line 873
enum dump_status sparse_dump_file(int fd , struct tar_stat_info *st ) ;
#line 874
enum dump_status sparse_extract_file(int fd , struct tar_stat_info *st , off_t *size ) ;
#line 876
enum dump_status sparse_skip_file(struct tar_stat_info *st ) ;
#line 877
_Bool sparse_diff_file(int fd , struct tar_stat_info *st ) ;
#line 974
#pragma GCC diagnostic pop
#line 24 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_select_optab(struct tar_sparse_file *file ) ;
#line 66 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static char const   zero_buf[512]  ;
#line 63 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool dump_zeros(struct tar_sparse_file *file , off_t offset ) 
{ 
  int *tmp ;
  size_t size ;
  off_t tmp___0 ;
  ssize_t wrbytes ;
  int *tmp___1 ;

  {
#line 68
  if (offset < file->offset) {
    {
#line 70
    tmp = __errno_location();
#line 70
    *tmp = 22;
    }
#line 71
    return ((_Bool)0);
  }
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (file->offset < offset)) {
#line 74
      goto while_break;
    }
#line 76
    if (512L < offset - file->offset) {
#line 76
      tmp___0 = (off_t )512;
    } else {
#line 76
      tmp___0 = offset - file->offset;
    }
    {
#line 76
    size = (size_t )tmp___0;
#line 81
    wrbytes = write(file->fd, (void const   *)(zero_buf), size);
    }
#line 82
    if (wrbytes <= 0L) {
#line 84
      if (wrbytes == 0L) {
        {
#line 85
        tmp___1 = __errno_location();
#line 85
        *tmp___1 = 22;
        }
      }
#line 86
      return ((_Bool)0);
    }
#line 88
    file->offset += wrbytes;
  }
  while_break: /* CIL Label */ ;
  }
#line 91
  return ((_Bool)1);
}
}
#line 94 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_member_p(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;

  {
#line 97
  if ((file->optab)->sparse_member_p) {
    {
#line 98
    tmp = (*((file->optab)->sparse_member_p))(file);
    }
#line 98
    return (tmp);
  }
#line 99
  return ((_Bool)0);
}
}
#line 102 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_init(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 105
  memset((void *)file, 0, sizeof(*file));
#line 107
  tmp = sparse_select_optab(file);
  }
#line 107
  if (! tmp) {
#line 108
    return ((_Bool)0);
  }
#line 110
  if ((file->optab)->init) {
    {
#line 111
    tmp___0 = (*((file->optab)->init))(file);
    }
#line 111
    return (tmp___0);
  }
#line 113
  return ((_Bool)1);
}
}
#line 116 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_done(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;

  {
#line 119
  if ((file->optab)->done) {
    {
#line 120
    tmp = (*((file->optab)->done))(file);
    }
#line 120
    return (tmp);
  }
#line 121
  return ((_Bool)1);
}
}
#line 124 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_scan(struct tar_sparse_file *file , enum sparse_scan_state state ,
                             void *block ) 
{ 
  _Bool tmp ;

  {
#line 128
  if ((file->optab)->scan_block) {
    {
#line 129
    tmp = (*((file->optab)->scan_block))(file, state, block);
    }
#line 129
    return (tmp);
  }
#line 130
  return ((_Bool)1);
}
}
#line 133 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_dump_region(struct tar_sparse_file *file , size_t i ) 
{ 
  _Bool tmp ;

  {
#line 136
  if ((file->optab)->dump_region) {
    {
#line 137
    tmp = (*((file->optab)->dump_region))(file, i);
    }
#line 137
    return (tmp);
  }
#line 138
  return ((_Bool)0);
}
}
#line 141 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_extract_region(struct tar_sparse_file *file , size_t i ) 
{ 
  _Bool tmp ;

  {
#line 144
  if ((file->optab)->extract_region) {
    {
#line 145
    tmp = (*((file->optab)->extract_region))(file, i);
    }
#line 145
    return (tmp);
  }
#line 146
  return ((_Bool)0);
}
}
#line 149 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_dump_header(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;

  {
#line 152
  if ((file->optab)->dump_header) {
    {
#line 153
    tmp = (*((file->optab)->dump_header))(file);
    }
#line 153
    return (tmp);
  }
#line 154
  return ((_Bool)0);
}
}
#line 157 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_decode_header(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;

  {
#line 160
  if ((file->optab)->decode_header) {
    {
#line 161
    tmp = (*((file->optab)->decode_header))(file);
    }
#line 161
    return (tmp);
  }
#line 162
  return ((_Bool)1);
}
}
#line 165 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool tar_sparse_fixup_header(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;

  {
#line 168
  if ((file->optab)->fixup_header) {
    {
#line 169
    tmp = (*((file->optab)->fixup_header))(file);
    }
#line 169
    return (tmp);
  }
#line 170
  return ((_Bool)1);
}
}
#line 174 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool lseek_or_error(struct tar_sparse_file *file , off_t offset ) 
{ 
  __off_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 177
  if (file->seekable) {
    {
#line 177
    tmp = lseek(file->fd, offset, 0);
#line 177
    tmp___2 = tmp < 0L;
    }
  } else {
    {
#line 177
    tmp___0 = dump_zeros(file, offset);
    }
#line 177
    if (tmp___0) {
#line 177
      tmp___1 = 0;
    } else {
#line 177
      tmp___1 = 1;
    }
#line 177
    tmp___2 = tmp___1;
  }
#line 177
  if (tmp___2) {
    {
#line 181
    seek_diag_details((char const   *)(file->stat_info)->orig_file_name, offset);
    }
#line 182
    return ((_Bool)0);
  }
#line 184
  return ((_Bool)1);
}
}
#line 190 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool zero_block_p(char const   *buffer___1 , size_t size ) 
{ 
  char const   *tmp ;
  size_t tmp___0 ;

  {
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    tmp___0 = size;
#line 193
    size --;
#line 193
    if (! tmp___0) {
#line 193
      goto while_break;
    }
#line 194
    tmp = buffer___1;
#line 194
    buffer___1 ++;
#line 194
    if (*tmp) {
#line 195
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return ((_Bool)1);
}
}
#line 199 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static void sparse_add_map(struct tar_stat_info *st , struct sp_array  const  *sp ) 
{ 
  struct sp_array *sparse_map ;
  size_t avail ;
  void *tmp ;

  {
#line 202
  sparse_map = st->sparse_map;
#line 203
  avail = st->sparse_map_avail;
#line 204
  if (avail == st->sparse_map_size) {
    {
#line 205
    tmp = x2nrealloc((void *)sparse_map, & st->sparse_map_size, sizeof(*sparse_map));
#line 205
    sparse_map = (struct sp_array *)tmp;
#line 205
    st->sparse_map = sparse_map;
    }
  }
#line 207
  *(sparse_map + avail) = (struct sp_array )*sp;
#line 208
  st->sparse_map_avail = avail + 1UL;
#line 209
  return;
}
}
#line 212 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_scan_file_raw(struct tar_sparse_file *file ) 
{ 
  struct tar_stat_info *st ;
  int fd ;
  char buffer___1[512] ;
  size_t count ;
  off_t offset ;
  struct sp_array sp ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 215
  st = file->stat_info;
#line 216
  fd = file->fd;
#line 218
  count = (size_t )0;
#line 219
  offset = (off_t )0;
#line 220
  sp.offset = (off_t )0;
#line 220
  sp.numbytes = (off_t )0;
#line 222
  st->archive_file_size = (off_t )0;
#line 224
  tmp = tar_sparse_scan(file, (enum sparse_scan_state )0, (void *)0);
  }
#line 224
  if (! tmp) {
#line 225
    return ((_Bool)0);
  }
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 227
    count = blocking_read(fd, (void *)(buffer___1), sizeof(buffer___1));
    }
#line 227
    if (count != 0UL) {
#line 227
      if (! (count != 0xffffffffffffffffUL)) {
#line 227
        goto while_break;
      }
    } else {
#line 227
      goto while_break;
    }
    {
#line 231
    tmp___2 = zero_block_p((char const   *)(buffer___1), count);
    }
#line 231
    if (tmp___2) {
#line 233
      if (sp.numbytes) {
        {
#line 235
        sparse_add_map(st, (struct sp_array  const  *)(& sp));
#line 236
        sp.numbytes = (off_t )0;
#line 237
        tmp___0 = tar_sparse_scan(file, (enum sparse_scan_state )1, (void *)0);
        }
#line 237
        if (! tmp___0) {
#line 238
          return ((_Bool)0);
        }
      }
    } else {
#line 243
      if (sp.numbytes == 0L) {
#line 244
        sp.offset = offset;
      }
      {
#line 245
      sp.numbytes = (off_t )((size_t )sp.numbytes + count);
#line 246
      st->archive_file_size = (off_t )((size_t )st->archive_file_size + count);
#line 247
      tmp___1 = tar_sparse_scan(file, (enum sparse_scan_state )1, (void *)(buffer___1));
      }
#line 247
      if (! tmp___1) {
#line 248
        return ((_Bool)0);
      }
    }
#line 251
    offset = (off_t )((size_t )offset + count);
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if (sp.numbytes == 0L) {
#line 257
    sp.offset = offset;
  }
  {
#line 259
  sparse_add_map(st, (struct sp_array  const  *)(& sp));
#line 260
  st->archive_file_size = (off_t )((size_t )st->archive_file_size + count);
#line 261
  tmp___3 = tar_sparse_scan(file, (enum sparse_scan_state )2, (void *)0);
  }
#line 261
  return (tmp___3);
}
}
#line 264 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_scan_file_wholesparse(struct tar_sparse_file *file ) 
{ 
  struct tar_stat_info *st ;
  struct sp_array sp ;

  {
#line 267
  st = file->stat_info;
#line 268
  sp.offset = (off_t )0;
#line 268
  sp.numbytes = (off_t )0;
#line 273
  if (st->stat.st_blocks == 0L) {
    {
#line 275
    st->archive_file_size = (off_t )0;
#line 276
    sp.offset = st->stat.st_size;
#line 277
    sparse_add_map(st, (struct sp_array  const  *)(& sp));
    }
#line 278
    return ((_Bool)1);
  }
#line 281
  return ((_Bool)0);
}
}
#line 286 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_scan_file_seek(struct tar_sparse_file *file ) 
{ 
  struct tar_stat_info *st ;
  int fd ;
  struct sp_array sp ;
  off_t offset ;
  off_t data_offset ;
  off_t hole_offset ;
  int *tmp ;

  {
#line 289
  st = file->stat_info;
#line 290
  fd = file->fd;
#line 291
  sp.offset = (off_t )0;
#line 291
  sp.numbytes = (off_t )0;
#line 292
  offset = (off_t )0;
#line 296
  st->archive_file_size = (off_t )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 301
    data_offset = lseek(fd, offset, 3);
    }
#line 303
    if (data_offset == -1L) {
      {
#line 306
      tmp = __errno_location();
      }
#line 306
      if (*tmp == 6) {
        {
#line 309
        sp.numbytes = (off_t )0;
#line 310
        sp.offset = st->stat.st_size;
#line 311
        sparse_add_map(st, (struct sp_array  const  *)(& sp));
        }
#line 312
        return ((_Bool)1);
      }
#line 314
      return ((_Bool)0);
    }
    {
#line 317
    hole_offset = lseek(fd, data_offset, 4);
    }
#line 323
    if (offset == 0L) {
#line 323
      if (data_offset == 0L) {
#line 323
        if (hole_offset == st->stat.st_size) {
          {
#line 327
          lseek(fd, (__off_t )0, 0);
          }
#line 328
          return ((_Bool)0);
        }
      }
    }
    {
#line 331
    sp.offset = data_offset;
#line 332
    sp.numbytes = hole_offset - data_offset;
#line 333
    sparse_add_map(st, (struct sp_array  const  *)(& sp));
#line 335
    st->archive_file_size += sp.numbytes;
#line 336
    offset = hole_offset;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 339
  return ((_Bool)1);
}
}
#line 343 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_scan_file(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 347
  tmp = sparse_scan_file_wholesparse(file);
  }
#line 347
  if (tmp) {
#line 348
    return ((_Bool)1);
  }
  {
#line 353
  if ((unsigned int )hole_detection == 2U) {
#line 353
    goto case_2;
  }
#line 353
  if ((unsigned int )hole_detection == 0U) {
#line 353
    goto case_2;
  }
#line 364
  if ((unsigned int )hole_detection == 1U) {
#line 364
    goto case_1;
  }
#line 350
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 355
  tmp___0 = sparse_scan_file_seek(file);
  }
#line 355
  if (tmp___0) {
#line 356
    return ((_Bool)1);
  }
  case_1: /* CIL Label */ 
  {
#line 365
  tmp___1 = sparse_scan_file_raw(file);
  }
#line 365
  if (tmp___1) {
#line 366
    return ((_Bool)1);
  }
  switch_break: /* CIL Label */ ;
  }
#line 369
  return ((_Bool)0);
}
}
#line 372
static struct tar_sparse_optab  const  oldgnu_optab ;
#line 373
static struct tar_sparse_optab  const  star_optab ;
#line 374
static struct tar_sparse_optab  const  pax_optab ;
#line 376 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_select_optab(struct tar_sparse_file *file ) 
{ 
  unsigned int tmp ;

  {
#line 379
  if ((unsigned int )current_format == 0U) {
#line 379
    tmp = (unsigned int )archive_format;
  } else {
#line 379
    tmp = (unsigned int )current_format;
  }
  {
#line 382
  if (tmp == 3U) {
#line 382
    goto case_3;
  }
#line 382
  if (tmp == 1U) {
#line 382
    goto case_3;
  }
#line 386
  if (tmp == 6U) {
#line 386
    goto case_6;
  }
#line 386
  if (tmp == 2U) {
#line 386
    goto case_6;
  }
#line 390
  if (tmp == 4U) {
#line 390
    goto case_4;
  }
#line 394
  if (tmp == 5U) {
#line 394
    goto case_5;
  }
#line 398
  goto switch_default;
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 383
  return ((_Bool)0);
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
#line 387
  file->optab = & oldgnu_optab;
#line 388
  goto switch_break;
  case_4: /* CIL Label */ 
#line 391
  file->optab = & pax_optab;
#line 392
  goto switch_break;
  case_5: /* CIL Label */ 
#line 395
  file->optab = & star_optab;
#line 396
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 399
  return ((_Bool)0);
  switch_break: /* CIL Label */ ;
  }
#line 401
  return ((_Bool)1);
}
}
#line 404 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_dump_region(struct tar_sparse_file *file , size_t i ) 
{ 
  union block *blk ;
  off_t bytes_left ;
  _Bool tmp ;
  size_t bufsize ;
  off_t tmp___0 ;
  size_t bytes_read ;

  {
  {
#line 408
  bytes_left = ((file->stat_info)->sparse_map + i)->numbytes;
#line 410
  tmp = lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset);
  }
#line 410
  if (! tmp) {
#line 411
    return ((_Bool)0);
  }
  {
#line 413
  while (1) {
    while_continue: /* CIL Label */ ;
#line 413
    if (! (bytes_left > 0L)) {
#line 413
      goto while_break;
    }
#line 415
    if (bytes_left > 512L) {
#line 415
      tmp___0 = (off_t )512;
    } else {
#line 415
      tmp___0 = bytes_left;
    }
    {
#line 415
    bufsize = (size_t )tmp___0;
#line 418
    blk = find_next_block();
#line 419
    bytes_read = safe_read(file->fd, (void *)(blk->buffer), bufsize);
    }
#line 420
    if (bytes_read == 0xffffffffffffffffUL) {
      {
#line 422
      read_diag_details((char const   *)(file->stat_info)->orig_file_name, (((file->stat_info)->sparse_map + i)->offset + ((file->stat_info)->sparse_map + i)->numbytes) - bytes_left,
                        bufsize);
      }
#line 427
      return ((_Bool)0);
    }
    {
#line 430
    memset((void *)(blk->buffer + bytes_read), 0, 512UL - bytes_read);
#line 431
    bytes_left = (off_t )((size_t )bytes_left - bytes_read);
#line 432
    file->dumped_size = (off_t )((size_t )file->dumped_size + bytes_read);
#line 433
    set_next_block_after(blk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 436
  return ((_Bool)1);
}
}
#line 439 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool sparse_extract_region(struct tar_sparse_file *file , size_t i ) 
{ 
  off_t write_size ;
  _Bool tmp ;
  int tmp___0 ;
  size_t count ;
  size_t wrbytes ;
  off_t tmp___1 ;
  union block *blk ;
  union block *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 444
  tmp = lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset);
  }
#line 444
  if (! tmp) {
#line 445
    return ((_Bool)0);
  }
#line 447
  write_size = ((file->stat_info)->sparse_map + i)->numbytes;
#line 449
  if (write_size == 0L) {
#line 452
    if (file->seekable) {
      {
#line 452
      tmp___0 = sys_truncate(file->fd);
      }
#line 452
      if (tmp___0) {
        {
#line 453
        truncate_warn((char const   *)(file->stat_info)->orig_file_name);
        }
      }
    }
  } else {
    {
#line 455
    while (1) {
      while_continue: /* CIL Label */ ;
#line 455
      if (! (write_size > 0L)) {
#line 455
        goto while_break;
      }
#line 458
      if (write_size > 512L) {
#line 458
        tmp___1 = (off_t )512;
      } else {
#line 458
        tmp___1 = write_size;
      }
      {
#line 458
      wrbytes = (size_t )tmp___1;
#line 459
      tmp___2 = find_next_block();
#line 459
      blk = tmp___2;
      }
#line 460
      if (! blk) {
        {
#line 462
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 462
          if (error_hook) {
            {
#line 462
            (*error_hook)();
            }
          }
          {
#line 462
          tmp___3 = gettext("Unexpected EOF in archive");
#line 462
          error(0, 0, (char const   *)tmp___3);
#line 462
          exit_status = 2;
          }
#line 462
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 463
        return ((_Bool)0);
      }
      {
#line 465
      set_next_block_after(blk);
#line 466
      count = blocking_write(file->fd, (void const   *)(blk->buffer), wrbytes);
#line 467
      write_size = (off_t )((size_t )write_size - count);
#line 468
      file->dumped_size = (off_t )((size_t )file->dumped_size + count);
#line 469
      mv_size_left((file->stat_info)->archive_file_size - file->dumped_size);
#line 470
      file->offset = (off_t )((size_t )file->offset + count);
      }
#line 471
      if (count != wrbytes) {
        {
#line 473
        write_error_details((char const   *)(file->stat_info)->orig_file_name, count,
                            wrbytes);
        }
#line 475
        return ((_Bool)0);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 478
  return ((_Bool)1);
}
}
#line 484 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
enum dump_status sparse_dump_file(int fd , struct tar_stat_info *st ) 
{ 
  _Bool rc ;
  struct tar_sparse_file file ;
  _Bool tmp ;
  size_t i ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 490
  tmp = tar_sparse_init(& file);
  }
#line 490
  if (! tmp) {
#line 491
    return ((enum dump_status )3);
  }
  {
#line 493
  file.stat_info = st;
#line 494
  file.fd = fd;
#line 495
  file.seekable = (_Bool)1;
#line 497
  rc = sparse_scan_file(& file);
  }
#line 498
  if (rc) {
#line 498
    if ((file.optab)->dump_region) {
      {
#line 500
      tar_sparse_dump_header(& file);
      }
#line 502
      if (fd >= 0) {
        {
#line 506
        mv_begin_write((char const   *)(file.stat_info)->file_name, (file.stat_info)->stat.st_size,
                       (file.stat_info)->archive_file_size - file.dumped_size);
#line 509
        i = (size_t )0;
        }
        {
#line 509
        while (1) {
          while_continue: /* CIL Label */ ;
#line 509
          if (rc) {
#line 509
            if (! (i < (file.stat_info)->sparse_map_avail)) {
#line 509
              goto while_break;
            }
          } else {
#line 509
            goto while_break;
          }
          {
#line 510
          rc = tar_sparse_dump_region(& file, i);
#line 509
          i ++;
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 514
  pad_archive((file.stat_info)->archive_file_size - file.dumped_size);
#line 515
  tmp___2 = tar_sparse_done(& file);
  }
#line 515
  if (tmp___2) {
#line 515
    if (rc) {
#line 515
      tmp___1 = 0;
    } else {
#line 515
      tmp___1 = 1;
    }
  } else {
#line 515
    tmp___1 = 1;
  }
#line 515
  return ((enum dump_status )tmp___1);
}
}
#line 518 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
_Bool sparse_member_p(struct tar_stat_info *st ) 
{ 
  struct tar_sparse_file file ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 523
  tmp = tar_sparse_init(& file);
  }
#line 523
  if (! tmp) {
#line 524
    return ((_Bool)0);
  }
  {
#line 525
  file.stat_info = st;
#line 526
  tmp___0 = tar_sparse_member_p(& file);
  }
#line 526
  return (tmp___0);
}
}
#line 529 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
_Bool sparse_fixup_header(struct tar_stat_info *st ) 
{ 
  struct tar_sparse_file file ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 534
  tmp = tar_sparse_init(& file);
  }
#line 534
  if (! tmp) {
#line 535
    return ((_Bool)0);
  }
  {
#line 536
  file.stat_info = st;
#line 537
  tmp___0 = tar_sparse_fixup_header(& file);
  }
#line 537
  return (tmp___0);
}
}
#line 540 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
enum dump_status sparse_extract_file(int fd , struct tar_stat_info *st , off_t *size ) 
{ 
  _Bool rc ;
  struct tar_sparse_file file ;
  size_t i ;
  _Bool tmp ;
  __off_t tmp___0 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 543
  rc = (_Bool)1;
#line 547
  tmp = tar_sparse_init(& file);
  }
#line 547
  if (! tmp) {
#line 548
    return ((enum dump_status )3);
  }
  {
#line 550
  file.stat_info = st;
#line 551
  file.fd = fd;
#line 552
  tmp___0 = lseek(fd, (__off_t )0, 0);
#line 552
  file.seekable = (_Bool )(tmp___0 == 0L);
#line 553
  file.offset = (off_t )0;
#line 555
  rc = tar_sparse_decode_header(& file);
#line 556
  i = (size_t )0;
  }
  {
#line 556
  while (1) {
    while_continue: /* CIL Label */ ;
#line 556
    if (rc) {
#line 556
      if (! (i < (file.stat_info)->sparse_map_avail)) {
#line 556
        goto while_break;
      }
    } else {
#line 556
      goto while_break;
    }
    {
#line 557
    rc = tar_sparse_extract_region(& file, i);
#line 556
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 558
  *size = (file.stat_info)->archive_file_size - file.dumped_size;
#line 559
  tmp___3 = tar_sparse_done(& file);
  }
#line 559
  if (tmp___3) {
#line 559
    if (rc) {
#line 559
      tmp___2 = 0;
    } else {
#line 559
      tmp___2 = 1;
    }
  } else {
#line 559
    tmp___2 = 1;
  }
#line 559
  return ((enum dump_status )tmp___2);
}
}
#line 562 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
enum dump_status sparse_skip_file(struct tar_stat_info *st ) 
{ 
  _Bool rc ;
  struct tar_sparse_file file ;
  _Bool tmp ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 565
  rc = (_Bool)1;
#line 568
  tmp = tar_sparse_init(& file);
  }
#line 568
  if (! tmp) {
#line 569
    return ((enum dump_status )3);
  }
  {
#line 571
  file.stat_info = st;
#line 572
  file.fd = -1;
#line 574
  rc = tar_sparse_decode_header(& file);
#line 575
  skip_file((file.stat_info)->archive_file_size - file.dumped_size);
#line 576
  tmp___2 = tar_sparse_done(& file);
  }
#line 576
  if (tmp___2) {
#line 576
    if (rc) {
#line 576
      tmp___1 = 0;
    } else {
#line 576
      tmp___1 = 1;
    }
  } else {
#line 576
    tmp___1 = 1;
  }
#line 576
  return ((enum dump_status )tmp___1);
}
}
#line 580 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool check_sparse_region(struct tar_sparse_file *file , off_t beg , off_t end ) 
{ 
  _Bool tmp ;
  size_t bytes_read ;
  size_t rdsize ;
  off_t tmp___0 ;
  char diff_buffer___0[512] ;
  char begbuf[(((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 583
  tmp = lseek_or_error(file, beg);
  }
#line 583
  if (! tmp) {
#line 584
    return ((_Bool)0);
  }
  {
#line 586
  while (1) {
    while_continue: /* CIL Label */ ;
#line 586
    if (! (beg < end)) {
#line 586
      goto while_break;
    }
#line 589
    if (512L < end - beg) {
#line 589
      tmp___0 = (off_t )512;
    } else {
#line 589
      tmp___0 = end - beg;
    }
    {
#line 589
    rdsize = (size_t )tmp___0;
#line 592
    bytes_read = safe_read(file->fd, (void *)(diff_buffer___0), rdsize);
    }
#line 593
    if (bytes_read == 0xffffffffffffffffUL) {
      {
#line 595
      read_diag_details((char const   *)(file->stat_info)->orig_file_name, beg, rdsize);
      }
#line 598
      return ((_Bool)0);
    }
    {
#line 600
    tmp___3 = zero_block_p((char const   *)(diff_buffer___0), bytes_read);
    }
#line 600
    if (! tmp___3) {
      {
#line 603
      tmp___1 = offtostr(beg, begbuf);
#line 603
      tmp___2 = gettext("File fragment at %s is not a hole");
#line 603
      report_difference(file->stat_info, (char const   *)tmp___2, tmp___1);
      }
#line 606
      return ((_Bool)0);
    }
#line 609
    beg = (off_t )((size_t )beg + bytes_read);
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  return ((_Bool)1);
}
}
#line 614 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool check_data_region(struct tar_sparse_file *file , size_t i ) 
{ 
  off_t size_left ;
  _Bool tmp ;
  size_t bytes_read ;
  size_t rdsize ;
  off_t tmp___0 ;
  char diff_buffer___0[512] ;
  union block *blk ;
  union block *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 619
  tmp = lseek_or_error(file, ((file->stat_info)->sparse_map + i)->offset);
  }
#line 619
  if (! tmp) {
#line 620
    return ((_Bool)0);
  }
  {
#line 621
  size_left = ((file->stat_info)->sparse_map + i)->numbytes;
#line 622
  mv_size_left((file->stat_info)->archive_file_size - file->dumped_size);
  }
  {
#line 624
  while (1) {
    while_continue: /* CIL Label */ ;
#line 624
    if (! (size_left > 0L)) {
#line 624
      goto while_break;
    }
#line 627
    if (size_left > 512L) {
#line 627
      tmp___0 = (off_t )512;
    } else {
#line 627
      tmp___0 = size_left;
    }
    {
#line 627
    rdsize = (size_t )tmp___0;
#line 630
    tmp___1 = find_next_block();
#line 630
    blk = tmp___1;
    }
#line 631
    if (! blk) {
      {
#line 633
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 633
        if (error_hook) {
          {
#line 633
          (*error_hook)();
          }
        }
        {
#line 633
        tmp___2 = gettext("Unexpected EOF in archive");
#line 633
        error(0, 0, (char const   *)tmp___2);
#line 633
        exit_status = 2;
        }
#line 633
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 634
      return ((_Bool)0);
    }
    {
#line 636
    set_next_block_after(blk);
#line 637
    bytes_read = safe_read(file->fd, (void *)(diff_buffer___0), rdsize);
    }
#line 638
    if (bytes_read == 0xffffffffffffffffUL) {
      {
#line 640
      read_diag_details((char const   *)(file->stat_info)->orig_file_name, (((file->stat_info)->sparse_map + i)->offset + ((file->stat_info)->sparse_map + i)->numbytes) - size_left,
                        rdsize);
      }
#line 645
      return ((_Bool)0);
    }
    {
#line 647
    file->dumped_size = (off_t )((size_t )file->dumped_size + bytes_read);
#line 648
    size_left = (off_t )((size_t )size_left - bytes_read);
#line 649
    mv_size_left((file->stat_info)->archive_file_size - file->dumped_size);
#line 650
    tmp___4 = memcmp((void const   *)(blk->buffer), (void const   *)(diff_buffer___0),
                     rdsize);
    }
#line 650
    if (tmp___4) {
      {
#line 652
      tmp___3 = gettext("Contents differ");
#line 652
      report_difference(file->stat_info, (char const   *)tmp___3);
      }
#line 653
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return ((_Bool)1);
}
}
#line 659 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
_Bool sparse_diff_file(int fd , struct tar_stat_info *st ) 
{ 
  _Bool rc ;
  struct tar_sparse_file file ;
  size_t i ;
  off_t offset ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
  {
#line 662
  rc = (_Bool)1;
#line 665
  offset = (off_t )0;
#line 667
  tmp = tar_sparse_init(& file);
  }
#line 667
  if (! tmp) {
#line 668
    return ((_Bool)1);
  }
  {
#line 670
  file.stat_info = st;
#line 671
  file.fd = fd;
#line 672
  file.seekable = (_Bool)1;
#line 674
  rc = tar_sparse_decode_header(& file);
#line 675
  mv_begin_read(st);
#line 676
  i = (size_t )0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (rc) {
#line 676
      if (! (i < (file.stat_info)->sparse_map_avail)) {
#line 676
        goto while_break;
      }
    } else {
#line 676
      goto while_break;
    }
    {
#line 678
    tmp___0 = check_sparse_region(& file, offset, ((file.stat_info)->sparse_map + i)->offset);
    }
#line 678
    if (tmp___0) {
      {
#line 678
      tmp___1 = check_data_region(& file, i);
      }
#line 678
      if (tmp___1) {
#line 678
        tmp___2 = 1;
      } else {
#line 678
        tmp___2 = 0;
      }
    } else {
#line 678
      tmp___2 = 0;
    }
#line 678
    rc = (_Bool )tmp___2;
#line 681
    offset = ((file.stat_info)->sparse_map + i)->offset + ((file.stat_info)->sparse_map + i)->numbytes;
#line 676
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 685
  if (! rc) {
    {
#line 686
    skip_file((file.stat_info)->archive_file_size - file.dumped_size);
    }
  }
  {
#line 687
  mv_end();
#line 689
  tar_sparse_done(& file);
  }
#line 690
  return (rc);
}
}
#line 719 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool oldgnu_sparse_member_p(struct tar_sparse_file *file  __attribute__((__unused__)) ) 
{ 


  {
#line 722
  return ((_Bool )((int )current_header->header.typeflag == 83));
}
}
#line 726 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static enum oldgnu_add_status oldgnu_add_sparse(struct tar_sparse_file *file , struct sparse *s ) 
{ 
  struct sp_array sp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 731
  if ((int )s->numbytes[0] == 0) {
#line 732
    return ((enum oldgnu_add_status )1);
  }
  {
#line 733
  sp.offset = off_from_header((char const   *)(s->offset), sizeof(s->offset));
#line 734
  sp.numbytes = off_from_header((char const   *)(s->numbytes), sizeof(s->numbytes));
  }
#line 735
  if (sp.offset < 0L) {
#line 739
    return ((enum oldgnu_add_status )2);
  } else
#line 735
  if (sp.numbytes < 0L) {
#line 739
    return ((enum oldgnu_add_status )2);
  } else {
#line 735
    if (-1L - (((1L << (sizeof(sp.offset) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 735
      if (sp.numbytes < 0L) {
#line 735
        tmp = sp.offset < (-1L - (((1L << (sizeof(sp.offset) * 8UL - 2UL)) - 1L) * 2L + 1L)) - sp.numbytes;
      } else {
#line 735
        tmp = (((1L << (sizeof(sp.offset) * 8UL - 2UL)) - 1L) * 2L + 1L) - sp.numbytes < sp.offset;
      }
#line 735
      tmp___2 = tmp;
    } else {
#line 735
      if (sp.offset < 0L) {
#line 735
        tmp___1 = sp.numbytes <= sp.offset + sp.numbytes;
      } else {
#line 735
        if (sp.numbytes < 0L) {
#line 735
          tmp___0 = sp.offset <= sp.offset + sp.numbytes;
        } else {
#line 735
          tmp___0 = sp.offset + sp.numbytes < sp.numbytes;
        }
#line 735
        tmp___1 = tmp___0;
      }
#line 735
      tmp___2 = tmp___1;
    }
#line 735
    if (tmp___2) {
#line 739
      return ((enum oldgnu_add_status )2);
    } else
#line 735
    if ((file->stat_info)->stat.st_size < sp.offset + sp.numbytes) {
#line 739
      return ((enum oldgnu_add_status )2);
    } else
#line 735
    if ((file->stat_info)->archive_file_size < 0L) {
#line 739
      return ((enum oldgnu_add_status )2);
    }
  }
  {
#line 741
  sparse_add_map(file->stat_info, (struct sp_array  const  *)(& sp));
  }
#line 742
  return ((enum oldgnu_add_status )0);
}
}
#line 745 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool oldgnu_fixup_header(struct tar_sparse_file *file ) 
{ 
  off_t realsize ;
  off_t tmp ;

  {
  {
#line 750
  tmp = off_from_header((char const   *)(current_header->oldgnu_header.realsize),
                        sizeof(current_header->oldgnu_header.realsize));
#line 750
  realsize = tmp;
#line 751
  (file->stat_info)->archive_file_size = (file->stat_info)->stat.st_size;
  }
#line 752
  if (0L < realsize) {
#line 752
    (file->stat_info)->stat.st_size = realsize;
  } else {
#line 752
    (file->stat_info)->stat.st_size = (__off_t )0;
  }
#line 753
  return ((_Bool )(0L <= realsize));
}
}
#line 757 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool oldgnu_get_sparse_info(struct tar_sparse_file *file ) 
{ 
  size_t i ;
  union block *h ;
  int ext_p ;
  enum oldgnu_add_status rc ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 761
  h = current_header;
#line 765
  (file->stat_info)->sparse_map_avail = (size_t )0;
#line 766
  i = (size_t )0;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (i < 4UL)) {
#line 766
      goto while_break;
    }
    {
#line 768
    rc = oldgnu_add_sparse(file, & h->oldgnu_header.sp[i]);
    }
#line 769
    if ((unsigned int )rc != 0U) {
#line 770
      goto while_break;
    }
#line 766
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 773
  ext_p = (int )h->oldgnu_header.isextended;
  {
#line 773
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 773
    if ((unsigned int )rc == 0U) {
#line 773
      if (! ext_p) {
#line 773
        goto while_break___0;
      }
    } else {
#line 773
      goto while_break___0;
    }
    {
#line 776
    h = find_next_block();
    }
#line 777
    if (! h) {
      {
#line 779
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 779
        if (error_hook) {
          {
#line 779
          (*error_hook)();
          }
        }
        {
#line 779
        tmp = gettext("Unexpected EOF in archive");
#line 779
        error(0, 0, (char const   *)tmp);
#line 779
        exit_status = 2;
        }
#line 779
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 780
      return ((_Bool)0);
    }
    {
#line 782
    set_next_block_after(h);
#line 783
    i = (size_t )0;
    }
    {
#line 783
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 783
      if (i < 21UL) {
#line 783
        if (! ((unsigned int )rc == 0U)) {
#line 783
          goto while_break___2;
        }
      } else {
#line 783
        goto while_break___2;
      }
      {
#line 784
      rc = oldgnu_add_sparse(file, & h->sparse_header.sp[i]);
#line 783
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 773
    ext_p = (int )h->sparse_header.isextended;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 787
  if ((unsigned int )rc == 2U) {
    {
#line 789
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 789
      if (error_hook) {
        {
#line 789
        (*error_hook)();
        }
      }
      {
#line 789
      tmp___0 = gettext("%s: invalid sparse archive member");
#line 789
      error(0, 0, (char const   *)tmp___0, (file->stat_info)->orig_file_name);
#line 789
      exit_status = 2;
      }
#line 789
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 791
    return ((_Bool)0);
  }
#line 793
  return ((_Bool)1);
}
}
#line 796 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static void oldgnu_store_sparse_info(struct tar_sparse_file *file , size_t *pindex ,
                                     struct sparse *sp , size_t sparse_size ) 
{ 


  {
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (*pindex < (file->stat_info)->sparse_map_avail) {
#line 800
      if (! (sparse_size > 0UL)) {
#line 800
        goto while_break;
      }
    } else {
#line 800
      goto while_break;
    }
    {
#line 803
    off_to_chars(((file->stat_info)->sparse_map + *pindex)->offset, sp->offset, sizeof(sp->offset));
#line 805
    off_to_chars(((file->stat_info)->sparse_map + *pindex)->numbytes, sp->numbytes,
                 sizeof(sp->numbytes));
#line 800
    sparse_size --;
#line 800
    sp ++;
#line 800
    (*pindex) ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return;
}
}
#line 810 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool oldgnu_dump_header(struct tar_sparse_file *file ) 
{ 
  off_t block_ordinal ;
  off_t tmp ;
  union block *blk ;
  size_t i ;

  {
  {
#line 813
  tmp = current_block_ordinal();
#line 813
  block_ordinal = tmp;
#line 817
  blk = start_header(file->stat_info);
#line 818
  blk->header.typeflag = (char )'S';
  }
#line 819
  if ((file->stat_info)->sparse_map_avail > 4UL) {
#line 820
    blk->oldgnu_header.isextended = (char)1;
  }
  {
#line 823
  off_to_chars((file->stat_info)->stat.st_size, blk->oldgnu_header.realsize, sizeof(blk->oldgnu_header.realsize));
#line 825
  off_to_chars((file->stat_info)->archive_file_size, blk->header.size, sizeof(blk->header.size));
#line 827
  i = (size_t )0;
#line 828
  oldgnu_store_sparse_info(file, & i, blk->oldgnu_header.sp, (size_t )4);
#line 831
  blk->oldgnu_header.isextended = (char )(i < (file->stat_info)->sparse_map_avail);
#line 832
  finish_header(file->stat_info, blk, block_ordinal);
  }
  {
#line 834
  while (1) {
    while_continue: /* CIL Label */ ;
#line 834
    if (! (i < (file->stat_info)->sparse_map_avail)) {
#line 834
      goto while_break;
    }
    {
#line 836
    blk = find_next_block();
#line 837
    memset((void *)(blk->buffer), 0, (size_t )512);
#line 838
    oldgnu_store_sparse_info(file, & i, blk->sparse_header.sp, (size_t )21);
    }
#line 841
    if (i < (file->stat_info)->sparse_map_avail) {
#line 842
      blk->sparse_header.isextended = (char)1;
    }
    {
#line 843
    set_next_block_after(blk);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 845
  return ((_Bool)1);
}
}
#line 848 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static struct tar_sparse_optab  const  oldgnu_optab  = 
#line 848
     {(_Bool (*)(struct tar_sparse_file * ))((void *)0), (_Bool (*)(struct tar_sparse_file * ))((void *)0),
    & oldgnu_sparse_member_p, & oldgnu_dump_header, & oldgnu_fixup_header, & oldgnu_get_sparse_info,
    (_Bool (*)(struct tar_sparse_file * , enum sparse_scan_state  , void * ))((void *)0),
    & sparse_dump_region, & sparse_extract_region};
#line 863 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool star_sparse_member_p(struct tar_sparse_file *file  __attribute__((__unused__)) ) 
{ 


  {
#line 866
  return ((_Bool )((int )current_header->header.typeflag == 83));
}
}
#line 869 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool star_fixup_header(struct tar_sparse_file *file ) 
{ 
  off_t realsize ;
  off_t tmp ;

  {
  {
#line 874
  tmp = off_from_header((char const   *)(current_header->star_in_header.realsize),
                        sizeof(current_header->star_in_header.realsize));
#line 874
  realsize = tmp;
#line 875
  (file->stat_info)->archive_file_size = (file->stat_info)->stat.st_size;
  }
#line 876
  if (0L < realsize) {
#line 876
    (file->stat_info)->stat.st_size = realsize;
  } else {
#line 876
    (file->stat_info)->stat.st_size = (__off_t )0;
  }
#line 877
  return ((_Bool )(0L <= realsize));
}
}
#line 881 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool star_get_sparse_info(struct tar_sparse_file *file ) 
{ 
  size_t i ;
  union block *h ;
  int ext_p ;
  enum oldgnu_add_status rc ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 885
  h = current_header;
#line 887
  rc = (enum oldgnu_add_status )0;
#line 889
  (file->stat_info)->sparse_map_avail = (size_t )0;
#line 891
  if ((int )h->star_in_header.prefix[0] == 0) {
#line 891
    if ((int )h->star_in_header.sp[0].offset[10] != 0) {
#line 895
      i = (size_t )0;
      {
#line 895
      while (1) {
        while_continue: /* CIL Label */ ;
#line 895
        if (! (i < 4UL)) {
#line 895
          goto while_break;
        }
        {
#line 897
        rc = oldgnu_add_sparse(file, & h->star_in_header.sp[i]);
        }
#line 898
        if ((unsigned int )rc != 0U) {
#line 899
          goto while_break;
        }
#line 895
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 901
      ext_p = (int )h->star_in_header.isextended;
    } else {
#line 904
      ext_p = 1;
    }
  } else {
#line 904
    ext_p = 1;
  }
  {
#line 906
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 906
    if ((unsigned int )rc == 0U) {
#line 906
      if (! ext_p) {
#line 906
        goto while_break___0;
      }
    } else {
#line 906
      goto while_break___0;
    }
    {
#line 908
    h = find_next_block();
    }
#line 909
    if (! h) {
      {
#line 911
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 911
        if (error_hook) {
          {
#line 911
          (*error_hook)();
          }
        }
        {
#line 911
        tmp = gettext("Unexpected EOF in archive");
#line 911
        error(0, 0, (char const   *)tmp);
#line 911
        exit_status = 2;
        }
#line 911
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 912
      return ((_Bool)0);
    }
    {
#line 914
    set_next_block_after(h);
#line 915
    i = (size_t )0;
    }
    {
#line 915
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 915
      if (i < 21UL) {
#line 915
        if (! ((unsigned int )rc == 0U)) {
#line 915
          goto while_break___2;
        }
      } else {
#line 915
        goto while_break___2;
      }
      {
#line 916
      rc = oldgnu_add_sparse(file, & h->star_ext_header.sp[i]);
#line 915
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 917
    file->dumped_size += 512L;
#line 906
    ext_p = (int )h->star_ext_header.isextended;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 920
  if ((unsigned int )rc == 2U) {
    {
#line 922
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 922
      if (error_hook) {
        {
#line 922
        (*error_hook)();
        }
      }
      {
#line 922
      tmp___0 = gettext("%s: invalid sparse archive member");
#line 922
      error(0, 0, (char const   *)tmp___0, (file->stat_info)->orig_file_name);
#line 922
      exit_status = 2;
      }
#line 922
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 924
    return ((_Bool)0);
  }
#line 926
  return ((_Bool)1);
}
}
#line 930 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static struct tar_sparse_optab  const  star_optab  = 
#line 930
     {(_Bool (*)(struct tar_sparse_file * ))((void *)0), (_Bool (*)(struct tar_sparse_file * ))((void *)0),
    & star_sparse_member_p, (_Bool (*)(struct tar_sparse_file * ))((void *)0), & star_fixup_header,
    & star_get_sparse_info, (_Bool (*)(struct tar_sparse_file * , enum sparse_scan_state  ,
                                       void * ))((void *)0), (_Bool (*)(struct tar_sparse_file * ,
                                                                        size_t  ))((void *)0),
    & sparse_extract_region};
#line 1019 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool pax_sparse_member_p(struct tar_sparse_file *file ) 
{ 
  int tmp ;

  {
#line 1022
  if ((file->stat_info)->sparse_map_avail > 0UL) {
#line 1022
    tmp = 1;
  } else
#line 1022
  if ((file->stat_info)->sparse_major > 0U) {
#line 1022
    tmp = 1;
  } else {
#line 1022
    tmp = 0;
  }
#line 1022
  return ((_Bool )tmp);
}
}
#line 1027 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static union block *pax_start_header(struct tar_stat_info *st ) 
{ 
  off_t realsize ;
  union block *blk ;

  {
  {
#line 1030
  realsize = st->stat.st_size;
#line 1032
  st->stat.st_size = st->archive_file_size;
#line 1033
  blk = start_header(st);
#line 1034
  st->stat.st_size = realsize;
  }
#line 1035
  return (blk);
}
}
#line 1038 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool pax_dump_header_0(struct tar_sparse_file *file ) 
{ 
  off_t block_ordinal ;
  off_t tmp ;
  union block *blk ;
  size_t i ;
  char nbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  struct sp_array *map ;
  char *save_file_name ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 1041
  tmp = current_block_ordinal();
#line 1041
  block_ordinal = tmp;
#line 1045
  map = (file->stat_info)->sparse_map;
#line 1046
  save_file_name = (char *)((void *)0);
#line 1049
  xheader_store("GNU.sparse.size", file->stat_info, (void const   *)((void *)0));
#line 1050
  xheader_store("GNU.sparse.numblocks", file->stat_info, (void const   *)((void *)0));
#line 1052
  tmp___3 = xheader_keyword_deleted_p("GNU.sparse.map");
  }
#line 1052
  if (tmp___3) {
#line 1052
    goto _L;
  } else
#line 1052
  if (tar_sparse_minor == 0U) {
    _L: /* CIL Label */ 
#line 1055
    i = (size_t )0;
    {
#line 1055
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1055
      if (! (i < (file->stat_info)->sparse_map_avail)) {
#line 1055
        goto while_break;
      }
      {
#line 1057
      xheader_store("GNU.sparse.offset", file->stat_info, (void const   *)(& i));
#line 1058
      xheader_store("GNU.sparse.numbytes", file->stat_info, (void const   *)(& i));
#line 1055
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1063
    xheader_store("GNU.sparse.name", file->stat_info, (void const   *)((void *)0));
#line 1064
    save_file_name = (file->stat_info)->file_name;
#line 1065
    (file->stat_info)->file_name = xheader_format_name(file->stat_info, "%d/GNUSparseFile.%p/%f",
                                                       (size_t )0);
#line 1068
    xheader_string_begin(& (file->stat_info)->xhdr);
#line 1069
    i = (size_t )0;
    }
    {
#line 1069
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1069
      if (! (i < (file->stat_info)->sparse_map_avail)) {
#line 1069
        goto while_break___0;
      }
#line 1071
      if (i) {
        {
#line 1072
        xheader_string_add(& (file->stat_info)->xhdr, ",");
        }
      }
      {
#line 1073
      tmp___0 = umaxtostr((uintmax_t )(map + i)->offset, nbuf);
#line 1073
      xheader_string_add(& (file->stat_info)->xhdr, (char const   *)tmp___0);
#line 1075
      xheader_string_add(& (file->stat_info)->xhdr, ",");
#line 1076
      tmp___1 = umaxtostr((uintmax_t )(map + i)->numbytes, nbuf);
#line 1076
      xheader_string_add(& (file->stat_info)->xhdr, (char const   *)tmp___1);
#line 1069
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1079
    tmp___2 = xheader_string_end(& (file->stat_info)->xhdr, "GNU.sparse.map");
    }
#line 1079
    if (! tmp___2) {
      {
#line 1082
      free((void *)(file->stat_info)->file_name);
#line 1083
      (file->stat_info)->file_name = save_file_name;
      }
#line 1084
      return ((_Bool)0);
    }
  }
  {
#line 1087
  blk = pax_start_header(file->stat_info);
#line 1088
  finish_header(file->stat_info, blk, block_ordinal);
  }
#line 1089
  if (save_file_name) {
    {
#line 1091
    free((void *)(file->stat_info)->file_name);
#line 1092
    (file->stat_info)->file_name = save_file_name;
    }
  }
#line 1094
  return ((_Bool)1);
}
}
#line 1097 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool pax_dump_header_1(struct tar_sparse_file *file ) 
{ 
  off_t block_ordinal ;
  off_t tmp ;
  union block *blk ;
  char *p ;
  char *q ;
  size_t i ;
  char nbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t size ;
  struct sp_array *map ;
  char *save_file_name ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *endp ;
  char const   *srcp ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *endp___0 ;
  char const   *srcp___0 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char *endp___1 ;
  char const   *srcp___1 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char *endp___2 ;
  char const   *srcp___2 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *endp___3 ;
  char const   *srcp___3 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *endp___4 ;
  char const   *srcp___4 ;
  char *tmp___14 ;
  char const   *tmp___15 ;

  {
  {
#line 1100
  tmp = current_block_ordinal();
#line 1100
  block_ordinal = tmp;
#line 1105
  size = (off_t )0;
#line 1106
  map = (file->stat_info)->sparse_map;
#line 1107
  save_file_name = (file->stat_info)->file_name;
#line 1127
  p = umaxtostr((file->stat_info)->sparse_map_avail, nbuf);
#line 1128
  tmp___0 = strlen((char const   *)p);
#line 1128
  size = (off_t )((size_t )size + (tmp___0 + 1UL));
#line 1129
  i = (size_t )0;
  }
  {
#line 1129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1129
    if (! (i < (file->stat_info)->sparse_map_avail)) {
#line 1129
      goto while_break;
    }
    {
#line 1131
    p = umaxtostr((uintmax_t )(map + i)->offset, nbuf);
#line 1132
    tmp___1 = strlen((char const   *)p);
#line 1132
    size = (off_t )((size_t )size + (tmp___1 + 1UL));
#line 1133
    p = umaxtostr((uintmax_t )(map + i)->numbytes, nbuf);
#line 1134
    tmp___2 = strlen((char const   *)p);
#line 1134
    size = (off_t )((size_t )size + (tmp___2 + 1UL));
#line 1129
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1136
  size = ((size + 512L) - 1L) / 512L;
#line 1137
  (file->stat_info)->archive_file_size += size * 512L;
#line 1138
  file->dumped_size += size * 512L;
#line 1141
  xheader_store("GNU.sparse.major", file->stat_info, (void const   *)((void *)0));
#line 1142
  xheader_store("GNU.sparse.minor", file->stat_info, (void const   *)((void *)0));
#line 1143
  xheader_store("GNU.sparse.name", file->stat_info, (void const   *)((void *)0));
#line 1144
  xheader_store("GNU.sparse.realsize", file->stat_info, (void const   *)((void *)0));
#line 1146
  (file->stat_info)->file_name = xheader_format_name(file->stat_info, "%d/GNUSparseFile.%p/%f",
                                                     (size_t )0);
#line 1149
  tmp___3 = strlen((char const   *)(file->stat_info)->file_name);
  }
#line 1149
  if (tmp___3 > 100UL) {
#line 1150
    *((file->stat_info)->file_name + 100) = (char)0;
  }
  {
#line 1152
  blk = pax_start_header(file->stat_info);
#line 1153
  finish_header(file->stat_info, blk, block_ordinal);
#line 1154
  free((void *)(file->stat_info)->file_name);
#line 1155
  (file->stat_info)->file_name = save_file_name;
#line 1157
  blk = find_next_block();
#line 1158
  q = blk->buffer;
#line 1159
  p = umaxtostr((file->stat_info)->sparse_map_avail, nbuf);
  }
  {
#line 1160
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1160
    endp = blk->buffer + 512;
#line 1160
    srcp = (char const   *)p;
    {
#line 1160
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1160
      if (! *srcp) {
#line 1160
        goto while_break___1;
      }
#line 1160
      if ((unsigned long )q == (unsigned long )endp) {
        {
#line 1160
        set_next_block_after(blk);
#line 1160
        blk = find_next_block();
#line 1160
        q = blk->buffer;
#line 1160
        endp = blk->buffer + 512;
        }
      }
#line 1160
      tmp___4 = q;
#line 1160
      q ++;
#line 1160
      tmp___5 = srcp;
#line 1160
      srcp ++;
#line 1160
      *tmp___4 = (char )*tmp___5;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1160
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1161
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1161
    endp___0 = blk->buffer + 512;
#line 1161
    srcp___0 = "\n";
    {
#line 1161
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1161
      if (! *srcp___0) {
#line 1161
        goto while_break___3;
      }
#line 1161
      if ((unsigned long )q == (unsigned long )endp___0) {
        {
#line 1161
        set_next_block_after(blk);
#line 1161
        blk = find_next_block();
#line 1161
        q = blk->buffer;
#line 1161
        endp___0 = blk->buffer + 512;
        }
      }
#line 1161
      tmp___6 = q;
#line 1161
      q ++;
#line 1161
      tmp___7 = srcp___0;
#line 1161
      srcp___0 ++;
#line 1161
      *tmp___6 = (char )*tmp___7;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1161
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1162
  i = (size_t )0;
  {
#line 1162
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1162
    if (! (i < (file->stat_info)->sparse_map_avail)) {
#line 1162
      goto while_break___4;
    }
    {
#line 1164
    p = umaxtostr((uintmax_t )(map + i)->offset, nbuf);
    }
    {
#line 1165
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1165
      endp___1 = blk->buffer + 512;
#line 1165
      srcp___1 = (char const   *)p;
      {
#line 1165
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1165
        if (! *srcp___1) {
#line 1165
          goto while_break___6;
        }
#line 1165
        if ((unsigned long )q == (unsigned long )endp___1) {
          {
#line 1165
          set_next_block_after(blk);
#line 1165
          blk = find_next_block();
#line 1165
          q = blk->buffer;
#line 1165
          endp___1 = blk->buffer + 512;
          }
        }
#line 1165
        tmp___8 = q;
#line 1165
        q ++;
#line 1165
        tmp___9 = srcp___1;
#line 1165
        srcp___1 ++;
#line 1165
        *tmp___8 = (char )*tmp___9;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1165
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 1166
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1166
      endp___2 = blk->buffer + 512;
#line 1166
      srcp___2 = "\n";
      {
#line 1166
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1166
        if (! *srcp___2) {
#line 1166
          goto while_break___8;
        }
#line 1166
        if ((unsigned long )q == (unsigned long )endp___2) {
          {
#line 1166
          set_next_block_after(blk);
#line 1166
          blk = find_next_block();
#line 1166
          q = blk->buffer;
#line 1166
          endp___2 = blk->buffer + 512;
          }
        }
#line 1166
        tmp___10 = q;
#line 1166
        q ++;
#line 1166
        tmp___11 = srcp___2;
#line 1166
        srcp___2 ++;
#line 1166
        *tmp___10 = (char )*tmp___11;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1166
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 1167
    p = umaxtostr((uintmax_t )(map + i)->numbytes, nbuf);
    }
    {
#line 1168
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1168
      endp___3 = blk->buffer + 512;
#line 1168
      srcp___3 = (char const   *)p;
      {
#line 1168
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1168
        if (! *srcp___3) {
#line 1168
          goto while_break___10;
        }
#line 1168
        if ((unsigned long )q == (unsigned long )endp___3) {
          {
#line 1168
          set_next_block_after(blk);
#line 1168
          blk = find_next_block();
#line 1168
          q = blk->buffer;
#line 1168
          endp___3 = blk->buffer + 512;
          }
        }
#line 1168
        tmp___12 = q;
#line 1168
        q ++;
#line 1168
        tmp___13 = srcp___3;
#line 1168
        srcp___3 ++;
#line 1168
        *tmp___12 = (char )*tmp___13;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1168
      goto while_break___9;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1169
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1169
      endp___4 = blk->buffer + 512;
#line 1169
      srcp___4 = "\n";
      {
#line 1169
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1169
        if (! *srcp___4) {
#line 1169
          goto while_break___12;
        }
#line 1169
        if ((unsigned long )q == (unsigned long )endp___4) {
          {
#line 1169
          set_next_block_after(blk);
#line 1169
          blk = find_next_block();
#line 1169
          q = blk->buffer;
#line 1169
          endp___4 = blk->buffer + 512;
          }
        }
#line 1169
        tmp___14 = q;
#line 1169
        q ++;
#line 1169
        tmp___15 = srcp___4;
#line 1169
        srcp___4 ++;
#line 1169
        *tmp___14 = (char )*tmp___15;
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1169
      goto while_break___11;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 1162
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1171
  memset((void *)q, 0, (size_t )(512L - (q - blk->buffer)));
#line 1172
  set_next_block_after(blk);
  }
#line 1173
  return ((_Bool)1);
}
}
#line 1176 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool pax_dump_header(struct tar_sparse_file *file ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 1179
  (file->stat_info)->sparse_major = tar_sparse_major;
#line 1180
  (file->stat_info)->sparse_minor = tar_sparse_minor;
#line 1182
  if ((file->stat_info)->sparse_major == 0U) {
    {
#line 1182
    tmp = pax_dump_header_0(file);
#line 1182
    tmp___1 = (int )tmp;
    }
  } else {
    {
#line 1182
    tmp___0 = pax_dump_header_1(file);
#line 1182
    tmp___1 = (int )tmp___0;
    }
  }
#line 1182
  return ((_Bool )tmp___1);
}
}
#line 1186 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool decode_num(uintmax_t *num , char const   *arg___0 , uintmax_t maxval ) 
{ 
  uintmax_t u ;
  char *arg_lim ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 1192
  if (! ((unsigned int )*arg___0 - 48U <= 9U)) {
#line 1193
    return ((_Bool)0);
  }
  {
#line 1195
  tmp = __errno_location();
#line 1195
  *tmp = 0;
#line 1196
  u = strtoumax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& arg_lim),
                10);
  }
#line 1198
  if (u <= maxval) {
    {
#line 1198
    tmp___0 = __errno_location();
    }
#line 1198
    if (*tmp___0 != 34) {
#line 1198
      if (*arg_lim) {
#line 1199
        return ((_Bool)0);
      }
    } else {
#line 1199
      return ((_Bool)0);
    }
  } else {
#line 1199
    return ((_Bool)0);
  }
#line 1201
  *num = u;
#line 1202
  return ((_Bool)1);
}
}
#line 1205 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static _Bool pax_decode_header(struct tar_sparse_file *file ) 
{ 
  uintmax_t u ;
  char nbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  union block *blk ;
  char *p ;
  size_t i ;
  char *endp ;
  char *dst ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  void *tmp___4 ;
  struct sp_array sp ;
  char *endp___0 ;
  char *dst___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  char *endp___1 ;
  char *dst___1 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  _Bool tmp___14 ;

  {
#line 1208
  if ((file->stat_info)->sparse_major > 0U) {
    {
#line 1242
    set_next_block_after(current_header);
#line 1243
    file->dumped_size += 512L;
#line 1244
    blk = find_next_block();
#line 1245
    p = blk->buffer;
    }
    {
#line 1246
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1246
      endp = blk->buffer + 512;
#line 1246
      dst = nbuf;
      {
#line 1246
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1246
        if ((unsigned long )dst == (unsigned long )((nbuf + (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL)) - 1)) {
          {
#line 1246
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1246
            if (error_hook) {
              {
#line 1246
              (*error_hook)();
              }
            }
            {
#line 1246
            tmp = gettext("%s: numeric overflow in sparse archive member");
#line 1246
            error(0, 0, (char const   *)tmp, (file->stat_info)->orig_file_name);
#line 1246
            exit_status = 2;
            }
#line 1246
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 1246
          return ((_Bool)0);
        }
#line 1246
        if ((unsigned long )p == (unsigned long )endp) {
          {
#line 1246
          set_next_block_after(blk);
#line 1246
          file->dumped_size += 512L;
#line 1246
          blk = find_next_block();
#line 1246
          p = blk->buffer;
#line 1246
          endp = blk->buffer + 512;
          }
        }
#line 1246
        tmp___0 = p;
#line 1246
        p ++;
#line 1246
        *dst = *tmp___0;
#line 1246
        tmp___1 = dst;
#line 1246
        dst ++;
#line 1246
        if (! ((int )*tmp___1 != 10)) {
#line 1246
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1246
      *(dst + -1) = (char)0;
#line 1246
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1247
    tmp___3 = decode_num(& u, (char const   *)(nbuf), (size_t )-1);
    }
#line 1247
    if (! tmp___3) {
      {
#line 1249
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1249
        if (error_hook) {
          {
#line 1249
          (*error_hook)();
          }
        }
        {
#line 1249
        tmp___2 = gettext("%s: malformed sparse archive member");
#line 1249
        error(0, 0, (char const   *)tmp___2, (file->stat_info)->orig_file_name);
#line 1249
        exit_status = 2;
        }
#line 1249
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1251
      return ((_Bool)0);
    }
    {
#line 1253
    (file->stat_info)->sparse_map_size = u;
#line 1254
    tmp___4 = xcalloc((file->stat_info)->sparse_map_size, sizeof(*((file->stat_info)->sparse_map)));
#line 1254
    (file->stat_info)->sparse_map = (struct sp_array *)tmp___4;
#line 1256
    (file->stat_info)->sparse_map_avail = (size_t )0;
#line 1257
    i = (size_t )0;
    }
    {
#line 1257
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1257
      if (! (i < (file->stat_info)->sparse_map_size)) {
#line 1257
        goto while_break___3;
      }
      {
#line 1261
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1261
        endp___0 = blk->buffer + 512;
#line 1261
        dst___0 = nbuf;
        {
#line 1261
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1261
          if ((unsigned long )dst___0 == (unsigned long )((nbuf + (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL)) - 1)) {
            {
#line 1261
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 1261
              if (error_hook) {
                {
#line 1261
                (*error_hook)();
                }
              }
              {
#line 1261
              tmp___5 = gettext("%s: numeric overflow in sparse archive member");
#line 1261
              error(0, 0, (char const   *)tmp___5, (file->stat_info)->orig_file_name);
#line 1261
              exit_status = 2;
              }
#line 1261
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
#line 1261
            return ((_Bool)0);
          }
#line 1261
          if ((unsigned long )p == (unsigned long )endp___0) {
            {
#line 1261
            set_next_block_after(blk);
#line 1261
            file->dumped_size += 512L;
#line 1261
            blk = find_next_block();
#line 1261
            p = blk->buffer;
#line 1261
            endp___0 = blk->buffer + 512;
            }
          }
#line 1261
          tmp___6 = p;
#line 1261
          p ++;
#line 1261
          *dst___0 = *tmp___6;
#line 1261
          tmp___7 = dst___0;
#line 1261
          dst___0 ++;
#line 1261
          if (! ((int )*tmp___7 != 10)) {
#line 1261
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1261
        *(dst___0 + -1) = (char)0;
#line 1261
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1262
      tmp___9 = decode_num(& u, (char const   *)(nbuf), (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
      }
#line 1262
      if (! tmp___9) {
        {
#line 1264
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1264
          if (error_hook) {
            {
#line 1264
            (*error_hook)();
            }
          }
          {
#line 1264
          tmp___8 = gettext("%s: malformed sparse archive member");
#line 1264
          error(0, 0, (char const   *)tmp___8, (file->stat_info)->orig_file_name);
#line 1264
          exit_status = 2;
          }
#line 1264
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 1266
        return ((_Bool)0);
      }
#line 1268
      sp.offset = (off_t )u;
      {
#line 1269
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1269
        endp___1 = blk->buffer + 512;
#line 1269
        dst___1 = nbuf;
        {
#line 1269
        while (1) {
          while_continue___9: /* CIL Label */ ;
#line 1269
          if ((unsigned long )dst___1 == (unsigned long )((nbuf + (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL)) - 1)) {
            {
#line 1269
            while (1) {
              while_continue___10: /* CIL Label */ ;
#line 1269
              if (error_hook) {
                {
#line 1269
                (*error_hook)();
                }
              }
              {
#line 1269
              tmp___10 = gettext("%s: numeric overflow in sparse archive member");
#line 1269
              error(0, 0, (char const   *)tmp___10, (file->stat_info)->orig_file_name);
#line 1269
              exit_status = 2;
              }
#line 1269
              goto while_break___10;
            }
            while_break___10: /* CIL Label */ ;
            }
#line 1269
            return ((_Bool)0);
          }
#line 1269
          if ((unsigned long )p == (unsigned long )endp___1) {
            {
#line 1269
            set_next_block_after(blk);
#line 1269
            file->dumped_size += 512L;
#line 1269
            blk = find_next_block();
#line 1269
            p = blk->buffer;
#line 1269
            endp___1 = blk->buffer + 512;
            }
          }
#line 1269
          tmp___11 = p;
#line 1269
          p ++;
#line 1269
          *dst___1 = *tmp___11;
#line 1269
          tmp___12 = dst___1;
#line 1269
          dst___1 ++;
#line 1269
          if (! ((int )*tmp___12 != 10)) {
#line 1269
            goto while_break___9;
          }
        }
        while_break___9: /* CIL Label */ ;
        }
#line 1269
        *(dst___1 + -1) = (char)0;
#line 1269
        goto while_break___8;
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 1270
      tmp___14 = decode_num(& u, (char const   *)(nbuf), (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
      }
#line 1270
      if (! tmp___14) {
        {
#line 1272
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 1272
          if (error_hook) {
            {
#line 1272
            (*error_hook)();
            }
          }
          {
#line 1272
          tmp___13 = gettext("%s: malformed sparse archive member");
#line 1272
          error(0, 0, (char const   *)tmp___13, (file->stat_info)->orig_file_name);
#line 1272
          exit_status = 2;
          }
#line 1272
          goto while_break___11;
        }
        while_break___11: /* CIL Label */ ;
        }
#line 1274
        return ((_Bool)0);
      }
      {
#line 1276
      sp.numbytes = (off_t )u;
#line 1277
      sparse_add_map(file->stat_info, (struct sp_array  const  *)(& sp));
#line 1257
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 1279
    set_next_block_after(blk);
    }
  }
#line 1282
  return ((_Bool)1);
}
}
#line 1285 "/home/khheo/project/benchmark/tar-1.29/src/sparse.c"
static struct tar_sparse_optab  const  pax_optab  = 
#line 1285
     {(_Bool (*)(struct tar_sparse_file * ))((void *)0), (_Bool (*)(struct tar_sparse_file * ))((void *)0),
    & pax_sparse_member_p, & pax_dump_header, (_Bool (*)(struct tar_sparse_file * ))((void *)0),
    & pax_decode_header, (_Bool (*)(struct tar_sparse_file * , enum sparse_scan_state  ,
                                    void * ))((void *)0), & sparse_dump_region, & sparse_extract_region};
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 109 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 115
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 101 "/usr/include/grp.h"
extern struct group___0 *getgrgid(__gid_t __gid ) ;
#line 107
extern struct group___0 *getgrnam(char const   *__name ) ;
#line 585 "../gnu/argp.h"
#pragma GCC diagnostic push
#line 585
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 585
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 645
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 495
void add_exclusion_tag(char const   *name , enum exclusion_tag_type type , _Bool (*predicate)(int fd ) ) ;
#line 497
_Bool cachedir_file_p(int fd ) ;
#line 513
int subfile_open(struct tar_stat_info  const  *dir , char const   *file , int flags ) ;
#line 514
void restore_parent_fd(struct tar_stat_info  const  *st ) ;
#line 549
struct directory *scan_directory(struct tar_stat_info *st ) ;
#line 550
char const   *directory_contents(struct directory *dir ) ;
#line 553
void rebase_directory(struct directory *dir , char const   *old_prefix , size_t old_prefix_len ,
                      char const   *new_prefix , size_t new_prefix_len ) ;
#line 557
void append_incremental_renames(struct directory *dir ) ;
#line 559
void read_directory_file(void) ;
#line 626
int unquote_string(char *string ) ;
#line 628
char *normalize_filename(int cdidx , char const   *name ) ;
#line 705
int chdir_arg(char const   *dir ) ;
#line 707
int chdir_count(void) ;
#line 710
void open_diag(char const   *name ) ;
#line 715
void stat_diag(char const   *name ) ;
#line 732 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
size_t name_count  ;
#line 733 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
struct name *gnu_list_name  ;
#line 735
void gid_to_gname(gid_t gid , char **gname ) ;
#line 737
void uid_to_uname(uid_t uid , char **uname ) ;
#line 743
char const   *name_next(int change_dirs ) ;
#line 748
_Bool name_match(char const   *file_name___0 ) ;
#line 750
void label_notfound(void) ;
#line 751
void collect_and_sort_names(void) ;
#line 754
void blank_name_list(void) ;
#line 755
char *make_file_name(char const   *directory_name , char const   *name ) ;
#line 756
size_t stripped_prefix_len(char const   *file_name___0 , size_t num ) ;
#line 757
_Bool all_names_found(struct tar_stat_info *p ) ;
#line 762
_Bool contains_dot_dot(char const   *name ) ;
#line 961
void excfile_add(char const   *name , int flags ) ;
#line 965
void exclude_vcs_ignores(void) ;
#line 974
#pragma GCC diagnostic pop
#line 29 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void name_add_option(int rpl_option , char const   *arg___0 ) ;
#line 30
static void name_add_dir(char const   *name ) ;
#line 31
static void name_add_file(char const   *name ) ;
#line 65 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct argp_option names_options[35]  = 
#line 65
  {      {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "Local file name selection:",
      100}, 
        {"add-file", 0, "FILE", 0, "add given FILE to the archive (useful if its name starts with a dash)",
      101}, 
        {"directory", 'C', "DIR", 0, "change to directory DIR", 101}, 
        {"files-from", 'T', "FILE", 0, "get names to extract or create from FILE", 101}, 
        {"null",
      279, (char const   *)0, 0, "-T reads null-terminated names; implies --verbatim-files-from",
      101}, 
        {"no-null", 280, (char const   *)0, 0, "disable the effect of the previous --null option",
      101}, 
        {"unquote", 274, (char const   *)0, 0, "unquote input file or member names (default)",
      101}, 
        {"no-unquote", 275, (char const   *)0, 0, "do not unquote input file or member names",
      101}, 
        {"verbatim-files-from", 281, (char const   *)0, 0, "-T reads file names verbatim (no option handling)",
      101}, 
        {"no-verbatim-files-from", 276, (char const   *)0, 0, "-T treats file names starting with dash as options (default)",
      101}, 
        {"exclude", 260, "PATTERN", 0, "exclude files, given as a PATTERN", 101}, 
        {"exclude-from", 'X', "FILE", 0, "exclude patterns listed in FILE", 101}, 
        {"exclude-caches", 257, (char const   *)0, 0, "exclude contents of directories containing CACHEDIR.TAG, except for the tag file itself",
      101}, 
        {"exclude-caches-under", 258, (char const   *)0, 0, "exclude everything under directories containing CACHEDIR.TAG",
      101}, 
        {"exclude-caches-all", 259, (char const   *)0, 0, "exclude directories containing CACHEDIR.TAG",
      101}, 
        {"exclude-tag", 263, "FILE", 0, "exclude contents of directories containing FILE, except for FILE itself",
      101}, 
        {"exclude-ignore", 261, "FILE", 0, "read exclude patterns for each directory from FILE, if it exists",
      101}, 
        {"exclude-ignore-recursive", 262, "FILE", 0, "read exclude patterns for each directory and its subdirectories from FILE, if it exists",
      101}, 
        {"exclude-tag-under", 264, "FILE", 0, "exclude everything under directories containing FILE",
      101}, 
        {"exclude-tag-all", 265, "FILE", 0, "exclude directories containing FILE", 101}, 
        {"exclude-vcs",
      266, (char const   *)((void *)0), 0, "exclude version control system directories",
      101}, 
        {"exclude-vcs-ignores", 267, (char const   *)((void *)0), 0, "read exclude patterns from the VCS ignore files",
      101}, 
        {"exclude-backups", 256, (char const   *)((void *)0), 0, "exclude backup and lock files",
      101}, 
        {"recursion", 272, (char const   *)0, 0, "recurse into directories (default)",
      101}, 
        {"no-recursion", 273, (char const   *)0, 0, "avoid descending automatically in directories",
      101}, 
        {(char const   *)((void *)0), 0, (char const   *)((void *)0), 0, "File name matching options (affect both exclude and include patterns):",
      120}, 
        {"anchored", 270, (char const   *)0, 0, "patterns match file name start", 121}, 
        {"no-anchored",
      271, (char const   *)0, 0, "patterns match after any \'/\' (default for exclusion)",
      121}, 
        {"ignore-case", 268, (char const   *)0, 0, "ignore case", 121}, 
        {"no-ignore-case", 269, (char const   *)0, 0, "case sensitive matching (default)",
      121}, 
        {"wildcards", 283, (char const   *)0, 0, "use wildcards (default for exclusion)",
      121}, 
        {"no-wildcards", 278, (char const   *)0, 0, "verbatim string matching", 121}, 
        {"wildcards-match-slash",
      282, (char const   *)0, 0, "wildcards match \'/\' (default for exclusion)",
      121}, 
        {"no-wildcards-match-slash", 277, (char const   *)0, 0, "wildcards do not match \'/\'",
      121}, 
        {(char const   *)((void *)0), 0, (char const   *)0, 0, (char const   *)0, 0}};
#line 152 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static _Bool is_file_selection_option(int key ) 
{ 
  struct argp_option *p ;

  {
#line 157
  p = names_options;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if ((unsigned long )p->name == (unsigned long )((void *)0)) {
#line 157
      if (p->key == 0) {
#line 157
        if ((unsigned long )p->doc == (unsigned long )((void *)0)) {
#line 157
          goto while_break;
        }
      }
    }
#line 159
    if (p->key == key) {
#line 160
      return ((_Bool)1);
    }
#line 157
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 161
  return ((_Bool)0);
}
}
#line 165 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char filename_terminator  =    (char )'\n';
#line 167 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static _Bool verbatim_files_from_option  ;
#line 169 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static error_t names_parse_opt(int key , char *arg___0 , struct argp_state *state ) 
{ 
  _Bool tmp ;

  {
  {
#line 174
  if (key == 67) {
#line 174
    goto case_67;
  }
#line 178
  if (key == 84) {
#line 178
    goto case_84;
  }
#line 186
  goto switch_default;
  case_67: /* CIL Label */ 
  {
#line 175
  name_add_dir((char const   *)arg___0);
  }
#line 176
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 179
  name_add_file((char const   *)arg___0);
#line 183
  files_from_option = (_Bool)1;
  }
#line 184
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 187
  tmp = is_file_selection_option(key);
  }
#line 187
  if (tmp) {
    {
#line 188
    name_add_option(key, (char const   *)arg___0);
    }
  } else {
#line 190
    return (7);
  }
  switch_break: /* CIL Label */ ;
  }
#line 192
  return (0);
}
}
#line 204 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static enum wildcards wildcards  =    (enum wildcards )0;
#line 206 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int matching_flags  =    0;
#line 208 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int include_anchored  =    1 << 30;
#line 222 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char const   * const  vcs_file_table[22]  = 
#line 222
  {      (char const   */* const  */)"CVS",      (char const   */* const  */)".cvsignore",      (char const   */* const  */)"RCS",      (char const   */* const  */)"SCCS", 
        (char const   */* const  */)".svn",      (char const   */* const  */)".git",      (char const   */* const  */)".gitignore",      (char const   */* const  */)".gitattributes", 
        (char const   */* const  */)".gitmodules",      (char const   */* const  */)".arch-ids",      (char const   */* const  */)"{arch}",      (char const   */* const  */)"=RELEASE-ID", 
        (char const   */* const  */)"=meta-update",      (char const   */* const  */)"=update",      (char const   */* const  */)".bzr",      (char const   */* const  */)".bzrignore", 
        (char const   */* const  */)".bzrtags",      (char const   */* const  */)".hg",      (char const   */* const  */)".hgignore",      (char const   */* const  */)".hgtags", 
        (char const   */* const  */)"_darcs",      (char const   */* const  */)((void *)0)};
#line 256 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char const   * const  backup_file_table[4]  = {      (char const   */* const  */)".#*",      (char const   */* const  */)"*~",      (char const   */* const  */)"#*#",      (char const   */* const  */)((void *)0)};
#line 263 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void add_exclude_array(char const   * const  *fv , int opts ) 
{ 
  int i ;

  {
#line 268
  i = 0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! *(fv + i)) {
#line 268
      goto while_break;
    }
    {
#line 269
    add_exclude(excluded, (char const   *)*(fv + i), opts);
#line 268
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return;
}
}
#line 272 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void handle_file_selection_option(int key , char const   *arg___0 ) 
{ 
  int tmp ;
  int e ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 277
  if (key == 256) {
#line 277
    goto case_256;
  }
#line 281
  if (key == 260) {
#line 281
    goto case_260;
  }
#line 285
  if (key == 257) {
#line 285
    goto case_257;
  }
#line 290
  if (key == 258) {
#line 290
    goto case_258;
  }
#line 295
  if (key == 259) {
#line 295
    goto case_259;
  }
#line 300
  if (key == 261) {
#line 300
    goto case_261;
  }
#line 304
  if (key == 262) {
#line 304
    goto case_262;
  }
#line 308
  if (key == 263) {
#line 308
    goto case_263;
  }
#line 312
  if (key == 264) {
#line 312
    goto case_264;
  }
#line 316
  if (key == 265) {
#line 316
    goto case_265;
  }
#line 320
  if (key == 266) {
#line 320
    goto case_266;
  }
#line 324
  if (key == 267) {
#line 324
    goto case_267;
  }
#line 328
  if (key == 272) {
#line 328
    goto case_272;
  }
#line 332
  if (key == 273) {
#line 332
    goto case_273;
  }
#line 336
  if (key == 274) {
#line 336
    goto case_274;
  }
#line 340
  if (key == 275) {
#line 340
    goto case_275;
  }
#line 344
  if (key == 279) {
#line 344
    goto case_279;
  }
#line 349
  if (key == 280) {
#line 349
    goto case_280;
  }
#line 354
  if (key == 88) {
#line 354
    goto case_88;
  }
#line 363
  if (key == 270) {
#line 363
    goto case_270;
  }
#line 367
  if (key == 271) {
#line 367
    goto case_271;
  }
#line 372
  if (key == 268) {
#line 372
    goto case_268;
  }
#line 376
  if (key == 269) {
#line 376
    goto case_269;
  }
#line 380
  if (key == 283) {
#line 380
    goto case_283;
  }
#line 384
  if (key == 278) {
#line 384
    goto case_278;
  }
#line 388
  if (key == 282) {
#line 388
    goto case_282;
  }
#line 392
  if (key == 277) {
#line 392
    goto case_277;
  }
#line 396
  if (key == 281) {
#line 396
    goto case_281;
  }
#line 400
  if (key == 276) {
#line 400
    goto case_276;
  }
#line 404
  goto switch_default;
  case_256: /* CIL Label */ 
  {
#line 278
  add_exclude_array(backup_file_table, 1 << 28);
  }
#line 279
  goto switch_break;
  case_260: /* CIL Label */ 
#line 282
  if ((unsigned int )wildcards != 1U) {
#line 282
    tmp = 1 << 28;
  } else {
#line 282
    tmp = 0;
  }
  {
#line 282
  add_exclude(excluded, arg___0, (tmp | matching_flags) | recursion_option);
  }
#line 283
  goto switch_break;
  case_257: /* CIL Label */ 
  {
#line 286
  add_exclusion_tag("CACHEDIR.TAG", (enum exclusion_tag_type )1, & cachedir_file_p);
  }
#line 288
  goto switch_break;
  case_258: /* CIL Label */ 
  {
#line 291
  add_exclusion_tag("CACHEDIR.TAG", (enum exclusion_tag_type )2, & cachedir_file_p);
  }
#line 293
  goto switch_break;
  case_259: /* CIL Label */ 
  {
#line 296
  add_exclusion_tag("CACHEDIR.TAG", (enum exclusion_tag_type )3, & cachedir_file_p);
  }
#line 298
  goto switch_break;
  case_261: /* CIL Label */ 
  {
#line 301
  excfile_add(arg___0, 2);
  }
#line 302
  goto switch_break;
  case_262: /* CIL Label */ 
  {
#line 305
  excfile_add(arg___0, 1);
  }
#line 306
  goto switch_break;
  case_263: /* CIL Label */ 
  {
#line 309
  add_exclusion_tag(arg___0, (enum exclusion_tag_type )1, (_Bool (*)(int  ))((void *)0));
  }
#line 310
  goto switch_break;
  case_264: /* CIL Label */ 
  {
#line 313
  add_exclusion_tag(arg___0, (enum exclusion_tag_type )2, (_Bool (*)(int  ))((void *)0));
  }
#line 314
  goto switch_break;
  case_265: /* CIL Label */ 
  {
#line 317
  add_exclusion_tag(arg___0, (enum exclusion_tag_type )3, (_Bool (*)(int  ))((void *)0));
  }
#line 318
  goto switch_break;
  case_266: /* CIL Label */ 
  {
#line 321
  add_exclude_array(vcs_file_table, 0);
  }
#line 322
  goto switch_break;
  case_267: /* CIL Label */ 
  {
#line 325
  exclude_vcs_ignores();
  }
#line 326
  goto switch_break;
  case_272: /* CIL Label */ 
#line 329
  recursion_option = 1 << 3;
#line 330
  goto switch_break;
  case_273: /* CIL Label */ 
#line 333
  recursion_option = 0;
#line 334
  goto switch_break;
  case_274: /* CIL Label */ 
#line 337
  unquote_option = (_Bool)1;
#line 338
  goto switch_break;
  case_275: /* CIL Label */ 
#line 341
  unquote_option = (_Bool)0;
#line 342
  goto switch_break;
  case_279: /* CIL Label */ 
#line 345
  filename_terminator = (char )'\000';
#line 346
  verbatim_files_from_option = (_Bool)1;
#line 347
  goto switch_break;
  case_280: /* CIL Label */ 
#line 350
  filename_terminator = (char )'\n';
#line 351
  verbatim_files_from_option = (_Bool)0;
#line 352
  goto switch_break;
  case_88: /* CIL Label */ 
#line 355
  if ((unsigned int )wildcards != 1U) {
#line 355
    tmp___2 = 1 << 28;
  } else {
#line 355
    tmp___2 = 0;
  }
  {
#line 355
  tmp___3 = add_exclude_file(& add_exclude, excluded, arg___0, (tmp___2 | matching_flags) | recursion_option,
                             (char )'\n');
  }
#line 355
  if (tmp___3 != 0) {
    {
#line 358
    tmp___0 = __errno_location();
#line 358
    e = *tmp___0;
    }
    {
#line 359
    while (1) {
      while_continue: /* CIL Label */ ;
#line 359
      if (error_hook) {
        {
#line 359
        (*error_hook)();
        }
      }
      {
#line 359
      tmp___1 = quotearg_colon(arg___0);
#line 359
      error(0, e, "%s", tmp___1);
#line 359
      fatal_exit();
      }
#line 359
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 361
  goto switch_break;
  case_270: /* CIL Label */ 
#line 364
  matching_flags |= 1 << 30;
#line 365
  goto switch_break;
  case_271: /* CIL Label */ 
#line 368
  include_anchored = 0;
#line 369
  matching_flags &= ~ (1 << 30);
#line 370
  goto switch_break;
  case_268: /* CIL Label */ 
#line 373
  matching_flags |= 1 << 4;
#line 374
  goto switch_break;
  case_269: /* CIL Label */ 
#line 377
  matching_flags &= ~ (1 << 4);
#line 378
  goto switch_break;
  case_283: /* CIL Label */ 
#line 381
  wildcards = (enum wildcards )2;
#line 382
  goto switch_break;
  case_278: /* CIL Label */ 
#line 385
  wildcards = (enum wildcards )1;
#line 386
  goto switch_break;
  case_282: /* CIL Label */ 
#line 389
  matching_flags &= -2;
#line 390
  goto switch_break;
  case_277: /* CIL Label */ 
#line 393
  matching_flags |= 1;
#line 394
  goto switch_break;
  case_281: /* CIL Label */ 
#line 397
  verbatim_files_from_option = (_Bool)1;
#line 398
  goto switch_break;
  case_276: /* CIL Label */ 
#line 401
  verbatim_files_from_option = (_Bool)0;
#line 402
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 405
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 405
    if (error_hook) {
      {
#line 405
      (*error_hook)();
      }
    }
    {
#line 405
    error(0, 0, "unhandled positional option %d", key);
#line 405
    fatal_exit();
    }
#line 405
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  switch_break: /* CIL Label */ ;
  }
#line 407
  return;
}
}
#line 409 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct argp names_argp  =    {(struct argp_option  const  *)(names_options), & names_parse_opt, (char const   *)((void *)0),
    (char const   *)((void *)0), (struct argp_child  const  *)((void *)0), (char *(*)(int __key ,
                                                                                      char const   *__text ,
                                                                                      void *__input ))((void *)0),
    (char const   *)((void *)0)};
#line 419 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct argp_child names_argp_children[2]  = {      {(struct argp  const  *)(& names_argp), 0, "", 0}, 
        {(struct argp  const  *)((void *)0), 0, (char const   *)0, 0}};
#line 431 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char *cached_uname  ;
#line 432 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char *cached_gname  ;
#line 434 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static uid_t cached_uid  ;
#line 435 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static gid_t cached_gid  ;
#line 438 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char *cached_no_such_uname  ;
#line 439 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char *cached_no_such_gname  ;
#line 443 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static uid_t cached_no_such_uid  ;
#line 444 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static gid_t cached_no_such_gid  ;
#line 447 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void uid_to_uname(uid_t uid , char **uname ) 
{ 
  struct passwd *passwd ;

  {
#line 452
  if (uid != 0U) {
#line 452
    if (uid == cached_no_such_uid) {
      {
#line 454
      *uname = xstrdup("");
      }
#line 455
      return;
    }
  }
#line 458
  if (! cached_uname) {
#line 458
    goto _L;
  } else
#line 458
  if (uid != cached_uid) {
    _L: /* CIL Label */ 
    {
#line 460
    passwd = getpwuid(uid);
    }
#line 461
    if (passwd) {
      {
#line 463
      cached_uid = uid;
#line 464
      assign_string(& cached_uname, (char const   *)passwd->pw_name);
      }
    } else {
      {
#line 468
      cached_no_such_uid = uid;
#line 469
      *uname = xstrdup("");
      }
#line 470
      return;
    }
  }
  {
#line 473
  *uname = xstrdup((char const   *)cached_uname);
  }
#line 474
  return;
}
}
#line 477 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void gid_to_gname(gid_t gid , char **gname ) 
{ 
  struct group___0 *group ;

  {
#line 482
  if (gid != 0U) {
#line 482
    if (gid == cached_no_such_gid) {
      {
#line 484
      *gname = xstrdup("");
      }
#line 485
      return;
    }
  }
#line 488
  if (! cached_gname) {
#line 488
    goto _L;
  } else
#line 488
  if (gid != cached_gid) {
    _L: /* CIL Label */ 
    {
#line 490
    group = getgrgid(gid);
    }
#line 491
    if (group) {
      {
#line 493
      cached_gid = gid;
#line 494
      assign_string(& cached_gname, (char const   *)group->gr_name);
      }
    } else {
      {
#line 498
      cached_no_such_gid = gid;
#line 499
      *gname = xstrdup("");
      }
#line 500
      return;
    }
  }
  {
#line 503
  *gname = xstrdup((char const   *)cached_gname);
  }
#line 504
  return;
}
}
#line 507 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
int uname_to_uid(char const   *uname , uid_t *uidp ) 
{ 
  struct passwd *passwd ;
  int tmp ;
  int tmp___0 ;

  {
#line 512
  if (cached_no_such_uname) {
    {
#line 512
    tmp = strcmp(uname, (char const   *)cached_no_such_uname);
    }
#line 512
    if (tmp == 0) {
#line 514
      return (0);
    }
  }
#line 516
  if (! cached_uname) {
#line 516
    goto _L;
  } else
#line 516
  if ((int const   )*(uname + 0) != (int const   )*(cached_uname + 0)) {
#line 516
    goto _L;
  } else {
    {
#line 516
    tmp___0 = strcmp(uname, (char const   *)cached_uname);
    }
#line 516
    if (tmp___0 != 0) {
      _L: /* CIL Label */ 
      {
#line 520
      passwd = getpwnam(uname);
      }
#line 521
      if (passwd) {
        {
#line 523
        cached_uid = passwd->pw_uid;
#line 524
        assign_string(& cached_uname, (char const   *)passwd->pw_name);
        }
      } else {
        {
#line 528
        assign_string(& cached_no_such_uname, uname);
        }
#line 529
        return (0);
      }
    }
  }
#line 532
  *uidp = cached_uid;
#line 533
  return (1);
}
}
#line 537 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
int gname_to_gid(char const   *gname , gid_t *gidp ) 
{ 
  struct group___0 *group ;
  int tmp ;
  int tmp___0 ;

  {
#line 542
  if (cached_no_such_gname) {
    {
#line 542
    tmp = strcmp(gname, (char const   *)cached_no_such_gname);
    }
#line 542
    if (tmp == 0) {
#line 544
      return (0);
    }
  }
#line 546
  if (! cached_gname) {
#line 546
    goto _L;
  } else
#line 546
  if ((int const   )*(gname + 0) != (int const   )*(cached_gname + 0)) {
#line 546
    goto _L;
  } else {
    {
#line 546
    tmp___0 = strcmp(gname, (char const   *)cached_gname);
    }
#line 546
    if (tmp___0 != 0) {
      _L: /* CIL Label */ 
      {
#line 550
      group = getgrnam(gname);
      }
#line 551
      if (group) {
        {
#line 553
        cached_gid = group->gr_gid;
#line 554
        assign_string(& cached_gname, gname);
        }
      } else {
        {
#line 558
        assign_string(& cached_no_such_gname, gname);
        }
#line 559
        return (0);
      }
    }
  }
#line 562
  *gidp = cached_gid;
#line 563
  return (1);
}
}
#line 567 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *make_name(char const   *file_name___0 ) 
{ 
  struct name *p ;
  void *tmp ;

  {
  {
#line 570
  tmp = xzalloc(sizeof(*p));
#line 570
  p = (struct name *)tmp;
  }
#line 571
  if (! file_name___0) {
#line 572
    file_name___0 = "";
  }
  {
#line 573
  p->name = xstrdup(file_name___0);
#line 574
  p->length = strlen((char const   *)p->name);
  }
#line 575
  return (p);
}
}
#line 578 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void free_name(struct name *p ) 
{ 


  {
#line 581
  if (p) {
    {
#line 583
    free((void *)p->name);
#line 584
    free((void *)p->caname);
#line 585
    free((void *)p);
    }
  }
#line 587
  return;
}
}
#line 592 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *namelist  ;
#line 593 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *nametail  ;
#line 641 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name_elt *name_head  ;
#line 644 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name_elt *name_elt_alloc(void) 
{ 
  struct name_elt *elt ;
  void *tmp ;
  struct name_elt *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 649
  tmp = xmalloc(sizeof(*elt));
#line 649
  elt = (struct name_elt *)tmp;
  }
#line 650
  if (! name_head) {
    {
#line 652
    name_head = elt;
#line 653
    tmp___0 = (struct name_elt *)((void *)0);
#line 653
    name_head->next = tmp___0;
#line 653
    name_head->prev = tmp___0;
#line 654
    name_head->type = (enum nelt_type )3;
#line 655
    tmp___1 = xmalloc(sizeof(*elt));
#line 655
    elt = (struct name_elt *)tmp___1;
    }
  }
#line 658
  elt->prev = name_head->prev;
#line 659
  if (name_head->prev) {
#line 660
    (name_head->prev)->next = elt;
  }
#line 661
  elt->next = name_head;
#line 662
  name_head->prev = elt;
#line 663
  return (elt);
}
}
#line 666 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void name_list_adjust(void) 
{ 


  {
#line 669
  if (name_head) {
    {
#line 670
    while (1) {
      while_continue: /* CIL Label */ ;
#line 670
      if (! name_head->prev) {
#line 670
        goto while_break;
      }
#line 671
      name_head = name_head->prev;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 672
  return;
}
}
#line 674 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void name_list_advance(void) 
{ 
  struct name_elt *elt ;

  {
#line 677
  elt = name_head;
#line 678
  name_head = elt->next;
#line 679
  if (name_head) {
#line 680
    name_head->prev = (struct name_elt *)((void *)0);
  }
  {
#line 681
  free((void *)elt);
  }
#line 682
  return;
}
}
#line 686 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void name_add_name(char const   *name ) 
{ 
  struct name_elt *ep ;
  struct name_elt *tmp ;

  {
  {
#line 689
  tmp = name_elt_alloc();
#line 689
  ep = tmp;
#line 691
  ep->type = (enum nelt_type )0;
#line 692
  ep->v.name = name;
#line 693
  name_count ++;
  }
#line 694
  return;
}
}
#line 696 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void name_add_option(int rpl_option , char const   *arg___0 ) 
{ 
  struct name_elt *elt ;
  struct name_elt *tmp ;

  {
  {
#line 699
  tmp = name_elt_alloc();
#line 699
  elt = tmp;
#line 700
  elt->type = (enum nelt_type )4;
#line 701
  elt->v.opt.rpl_option = rpl_option;
#line 702
  elt->v.opt.arg = arg___0;
  }
#line 703
  return;
}
}
#line 706 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void name_add_dir(char const   *name ) 
{ 
  struct name_elt *ep ;
  struct name_elt *tmp ;

  {
  {
#line 709
  tmp = name_elt_alloc();
#line 709
  ep = tmp;
#line 710
  ep->type = (enum nelt_type )1;
#line 711
  ep->v.name = name;
  }
#line 712
  return;
}
}
#line 714 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void name_add_file(char const   *name ) 
{ 
  struct name_elt *ep ;
  struct name_elt *tmp ;

  {
  {
#line 717
  tmp = name_elt_alloc();
#line 717
  ep = tmp;
#line 719
  ep->type = (enum nelt_type )2;
#line 720
  ep->v.file.name = name;
#line 721
  ep->v.file.line = (size_t )0;
#line 722
  ep->v.file.fp = (FILE *)((void *)0);
  }
#line 723
  return;
}
}
#line 727 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char *name_buffer  ;
#line 728 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static size_t name_buffer_length  ;
#line 732 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void name_init(void) 
{ 
  void *tmp ;

  {
  {
#line 735
  tmp = xmalloc((size_t )102);
#line 735
  name_buffer = (char *)tmp;
#line 736
  name_buffer_length = (size_t )100;
#line 737
  name_list_adjust();
  }
#line 738
  return;
}
}
#line 740 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void name_term(void) 
{ 


  {
  {
#line 743
  free((void *)name_buffer);
  }
#line 744
  return;
}
}
#line 755 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct file_id_list *file_id_list  ;
#line 760 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static char const   *file_list_name(void) 
{ 
  struct name_elt *elt ;
  char *tmp ;

  {
#line 765
  elt = name_head;
  {
#line 765
  while (1) {
    while_continue: /* CIL Label */ ;
#line 765
    if (! elt) {
#line 765
      goto while_break;
    }
#line 766
    if ((unsigned int )elt->type == 2U) {
#line 766
      if (elt->v.file.fp) {
#line 767
        return (elt->v.file.name);
      }
    }
#line 765
    elt = elt->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 768
  tmp = gettext("command line");
  }
#line 768
  return ((char const   *)tmp);
}
}
#line 771 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int add_file_id(char const   *filename ) 
{ 
  struct file_id_list *p ;
  struct stat st ;
  char const   *reading_from ;
  int tmp ;
  int oldc ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 778
  tmp = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& st));
  }
#line 778
  if (tmp) {
    {
#line 779
    stat_fatal(filename);
    }
  }
  {
#line 780
  reading_from = file_list_name();
#line 781
  p = file_id_list;
  }
  {
#line 781
  while (1) {
    while_continue: /* CIL Label */ ;
#line 781
    if (! p) {
#line 781
      goto while_break;
    }
#line 782
    if (p->ino == st.st_ino) {
#line 782
      if (p->dev == st.st_dev) {
        {
#line 784
        tmp___0 = set_char_quoting((struct quoting_options *)((void *)0), (char )':',
                                   1);
#line 784
        oldc = tmp___0;
        }
        {
#line 785
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 785
          if (error_hook) {
            {
#line 785
            (*error_hook)();
            }
          }
          {
#line 785
          tmp___1 = quotearg_n(0, filename);
#line 785
          tmp___2 = gettext("%s: file list requested from %s already read from %s");
#line 785
          error(0, 0, (char const   *)tmp___2, tmp___1, reading_from, p->from_file);
#line 785
          exit_status = 2;
          }
#line 785
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 789
        set_char_quoting((struct quoting_options *)((void *)0), (char )':', oldc);
        }
#line 790
        return (1);
      }
    }
#line 781
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 792
  tmp___3 = xmalloc(sizeof(*p));
#line 792
  p = (struct file_id_list *)tmp___3;
#line 793
  p->next = file_id_list;
#line 794
  p->ino = st.st_ino;
#line 795
  p->dev = st.st_dev;
#line 796
  p->from_file = reading_from;
#line 797
  file_id_list = p;
  }
#line 798
  return (0);
}
}
#line 802 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void chopslash(char *str ) 
{ 
  char *p ;
  size_t tmp ;
  char *tmp___0 ;

  {
  {
#line 805
  tmp = strlen((char const   *)str);
#line 805
  p = (str + tmp) - 1;
  }
  {
#line 806
  while (1) {
    while_continue: /* CIL Label */ ;
#line 806
    if ((unsigned long )p > (unsigned long )str) {
#line 806
      if (! ((int )*p == 47)) {
#line 806
        goto while_break;
      }
    } else {
#line 806
      goto while_break;
    }
#line 807
    tmp___0 = p;
#line 807
    p --;
#line 807
    *tmp___0 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 808
  return;
}
}
#line 821 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static enum read_file_list_state read_name_from_file(struct name_elt *ent ) 
{ 
  int c ;
  size_t counter ;
  FILE *fp ;
  int term ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 825
  counter = (size_t )0;
#line 826
  fp = ent->v.file.fp;
#line 827
  term = ent->v.file.term;
#line 829
  (ent->v.file.line) ++;
#line 830
  c = getc_unlocked(fp);
  }
  {
#line 830
  while (1) {
    while_continue: /* CIL Label */ ;
#line 830
    if (c != -1) {
#line 830
      if (! (c != term)) {
#line 830
        goto while_break;
      }
    } else {
#line 830
      goto while_break;
    }
#line 832
    if (counter == name_buffer_length) {
      {
#line 833
      tmp = x2realloc((void *)name_buffer, & name_buffer_length);
#line 833
      name_buffer = (char *)tmp;
      }
    }
#line 834
    tmp___0 = counter;
#line 834
    counter ++;
#line 834
    *(name_buffer + tmp___0) = (char )c;
#line 835
    if (c == 0) {
#line 839
      return ((enum read_file_list_state )2);
    }
    {
#line 830
    c = getc_unlocked(fp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 843
  if (counter == 0UL) {
#line 843
    if (c != -1) {
#line 844
      return ((enum read_file_list_state )3);
    }
  }
#line 846
  if (counter == name_buffer_length) {
    {
#line 847
    tmp___1 = x2realloc((void *)name_buffer, & name_buffer_length);
#line 847
    name_buffer = (char *)tmp___1;
    }
  }
  {
#line 848
  *(name_buffer + counter) = (char)0;
#line 849
  chopslash(name_buffer);
  }
#line 850
  if (counter == 0UL) {
#line 850
    if (c == -1) {
#line 850
      tmp___2 = 1;
    } else {
#line 850
      tmp___2 = 0;
    }
  } else {
#line 850
    tmp___2 = 0;
  }
#line 850
  return ((enum read_file_list_state )tmp___2);
}
}
#line 853 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int handle_option(char const   *str , struct name_elt  const  *ent ) 
{ 
  struct wordsplit ws ;
  int i ;
  struct option_locus loc ;
  unsigned short const   **tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (*str) {
      {
#line 860
      tmp = __ctype_b_loc();
      }
#line 860
      if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 860
        goto while_break;
      }
    } else {
#line 860
      goto while_break;
    }
#line 861
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 862
  if ((int const   )*str != 45) {
#line 863
    return (1);
  }
  {
#line 865
  ws.ws_offs = (size_t )1;
#line 866
  tmp___2 = wordsplit(str, & ws, 33558086);
  }
#line 866
  if (tmp___2) {
    {
#line 867
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 867
      if (error_hook) {
        {
#line 867
        (*error_hook)();
        }
      }
      {
#line 867
      tmp___0 = wordsplit_strerror(& ws);
#line 867
      tmp___1 = gettext("cannot split string \'%s\': %s");
#line 867
      error(0, 0, (char const   *)tmp___1, str, tmp___0);
#line 867
      fatal_exit();
      }
#line 867
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 869
  *(ws.ws_wordv + 0) = (char *)program_name;
#line 870
  loc.source = (enum option_source )2;
#line 871
  loc.name = (char const   *)ent->v.file.name;
#line 872
  loc.line = (size_t )ent->v.file.line;
#line 873
  more_options((int )(ws.ws_wordc + ws.ws_offs), ws.ws_wordv, & loc);
#line 874
  i = 0;
  }
  {
#line 874
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 874
    if (! ((size_t )i < ws.ws_wordc + ws.ws_offs)) {
#line 874
      goto while_break___1;
    }
#line 875
    *(ws.ws_wordv + i) = (char *)((void *)0);
#line 874
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 877
  wordsplit_free(& ws);
  }
#line 878
  return (0);
}
}
#line 881 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int read_next_name(struct name_elt *ent , struct name_elt *ret ) 
{ 
  int tmp ;
  FILE *tmp___0 ;
  int tmp___1 ;
  enum read_file_list_state tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 884
  if (! ent->v.file.fp) {
    {
#line 886
    tmp___1 = strcmp(ent->v.file.name, "-");
    }
#line 886
    if (tmp___1) {
      {
#line 893
      tmp = add_file_id(ent->v.file.name);
      }
#line 893
      if (tmp) {
        {
#line 895
        name_list_advance();
        }
#line 896
        return (1);
      }
      {
#line 898
      tmp___0 = fopen((char const   */* __restrict  */)ent->v.file.name, (char const   */* __restrict  */)"r");
#line 898
      ent->v.file.fp = tmp___0;
      }
#line 898
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 899
        open_fatal(ent->v.file.name);
        }
      }
    } else {
      {
#line 888
      request_stdin("-T");
#line 889
      ent->v.file.fp = stdin;
      }
    }
#line 901
    ent->v.file.term = (int )filename_terminator;
#line 902
    ent->v.file.verbatim = verbatim_files_from_option;
  }
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 907
    tmp___2 = read_name_from_file(ent);
    }
    {
#line 909
    if ((unsigned int )tmp___2 == 3U) {
#line 909
      goto case_3;
    }
#line 912
    if ((unsigned int )tmp___2 == 2U) {
#line 912
      goto case_2;
    }
#line 918
    if ((unsigned int )tmp___2 == 0U) {
#line 918
      goto case_0;
    }
#line 930
    if ((unsigned int )tmp___2 == 1U) {
#line 930
      goto case_1;
    }
#line 907
    goto switch_break;
    case_3: /* CIL Label */ 
#line 910
    goto while_continue;
    case_2: /* CIL Label */ 
    {
#line 913
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 913
      if (warning_option & 512) {
        {
#line 913
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 913
          if (error_hook) {
            {
#line 913
            (*error_hook)();
            }
          }
          {
#line 913
          tmp___3 = quotearg_colon(ent->v.file.name);
#line 913
          error(0, 0, "%s: file name read contains nul character", tmp___3);
          }
#line 913
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 913
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 916
    ent->v.file.term = 0;
    case_0: /* CIL Label */ 
#line 919
    if (unquote_option) {
      {
#line 920
      unquote_string(name_buffer);
      }
    }
#line 921
    if (! ent->v.file.verbatim) {
      {
#line 921
      tmp___4 = handle_option((char const   *)name_buffer, (struct name_elt  const  *)ent);
      }
#line 921
      if (tmp___4 == 0) {
        {
#line 923
        name_list_adjust();
        }
#line 924
        return (1);
      }
    }
#line 926
    ret->type = (enum nelt_type )0;
#line 927
    ret->v.name = (char const   *)name_buffer;
#line 928
    return (0);
    case_1: /* CIL Label */ 
    {
#line 931
    tmp___5 = strcmp(ent->v.file.name, "-");
    }
#line 931
    if (tmp___5) {
      {
#line 932
      fclose(ent->v.file.fp);
      }
    }
    {
#line 933
    ent->v.file.fp = (FILE *)((void *)0);
#line 934
    name_list_advance();
    }
#line 935
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 940 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void copy_name(struct name_elt *ep ) 
{ 
  char const   *source ;
  size_t source_len ;
  void *tmp ;

  {
  {
#line 946
  source = ep->v.name;
#line 947
  source_len = strlen(source);
  }
#line 948
  if (name_buffer_length < source_len) {
    {
#line 950
    while (1) {
      while_continue: /* CIL Label */ ;
#line 952
      name_buffer_length *= 2UL;
#line 953
      if (! name_buffer_length) {
        {
#line 954
        xalloc_die();
        }
      }
#line 950
      if (! (name_buffer_length < source_len)) {
#line 950
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 958
    free((void *)name_buffer);
#line 959
    tmp = xmalloc(name_buffer_length + 2UL);
#line 959
    name_buffer = (char *)tmp;
    }
  }
  {
#line 961
  strcpy((char */* __restrict  */)name_buffer, (char const   */* __restrict  */)source);
#line 962
  chopslash(name_buffer);
  }
#line 963
  return;
}
}
#line 976 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name_elt entry  ;
#line 973 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name_elt *name_next_elt(int change_dirs ) 
{ 
  struct name_elt *ep ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 979
  while (1) {
    while_continue: /* CIL Label */ ;
#line 979
    ep = name_head;
#line 979
    if (! ((unsigned long )ep != (unsigned long )((void *)0))) {
#line 979
      goto while_break;
    }
    {
#line 983
    if ((unsigned int )ep->type == 3U) {
#line 983
      goto case_3;
    }
#line 987
    if ((unsigned int )ep->type == 2U) {
#line 987
      goto case_2;
    }
#line 992
    if ((unsigned int )ep->type == 1U) {
#line 992
      goto case_1;
    }
#line 1000
    if ((unsigned int )ep->type == 0U) {
#line 1000
      goto case_0;
    }
#line 1009
    if ((unsigned int )ep->type == 4U) {
#line 1009
      goto case_4;
    }
#line 981
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 984
    name_list_advance();
    }
#line 985
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 988
    tmp = read_next_name(ep, & entry);
    }
#line 988
    if (tmp == 0) {
#line 989
      return (& entry);
    }
#line 990
    goto while_continue;
    case_1: /* CIL Label */ 
#line 993
    if (change_dirs) {
      {
#line 995
      tmp___0 = xstrdup(ep->v.name);
#line 995
      tmp___1 = chdir_arg((char const   *)tmp___0);
#line 995
      chdir_do(tmp___1);
#line 996
      name_list_advance();
      }
#line 997
      goto switch_break;
    }
    case_0: /* CIL Label */ 
    {
#line 1001
    copy_name(ep);
    }
#line 1002
    if (unquote_option) {
      {
#line 1003
      unquote_string(name_buffer);
      }
    }
    {
#line 1004
    entry.type = ep->type;
#line 1005
    entry.v.name = (char const   *)name_buffer;
#line 1006
    name_list_advance();
    }
#line 1007
    return (& entry);
    case_4: /* CIL Label */ 
    {
#line 1010
    handle_file_selection_option(ep->v.opt.rpl_option, ep->v.opt.arg);
#line 1011
    name_list_advance();
    }
#line 1012
    goto while_continue;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  return ((struct name_elt *)((void *)0));
}
}
#line 1019 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
char const   *name_next(int change_dirs ) 
{ 
  struct name_elt *nelt ;
  struct name_elt *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 1022
  tmp = name_next_elt(change_dirs);
#line 1022
  nelt = tmp;
  }
#line 1023
  if (nelt) {
#line 1023
    tmp___0 = nelt->v.name;
  } else {
#line 1023
    tmp___0 = (char const   *)((void *)0);
  }
#line 1023
  return (tmp___0);
}
}
#line 1040 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *buffer  =    (struct name *)((void *)0);
#line 1046 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int change_dir  ;
#line 1036 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void name_gather(void) 
{ 
  struct name_elt *ep ;
  char *tmp ;
  int tmp___0 ;
  int change_dir___0 ;
  int change_dir0 ;
  char *tmp___1 ;

  {
#line 1044
  if (same_order_option) {
    {
#line 1048
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1048
      ep = name_next_elt(0);
      }
#line 1048
      if (ep) {
#line 1048
        if (! ((unsigned int )ep->type == 1U)) {
#line 1048
          goto while_break;
        }
      } else {
#line 1048
        goto while_break;
      }
      {
#line 1049
      tmp = xstrdup(ep->v.name);
#line 1049
      change_dir = chdir_arg((char const   *)tmp);
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1051
    if (ep) {
      {
#line 1053
      free_name(buffer);
#line 1054
      buffer = make_name(ep->v.name);
#line 1055
      buffer->change_dir = change_dir;
#line 1056
      buffer->next = (struct name *)0;
#line 1057
      buffer->found_count = (uintmax_t )0;
      }
#line 1058
      if ((unsigned int )wildcards == 2U) {
#line 1058
        tmp___0 = 1 << 28;
      } else {
#line 1058
        tmp___0 = 0;
      }
#line 1058
      buffer->matching_flags = ((tmp___0 | include_anchored) | matching_flags) | recursion_option;
#line 1059
      buffer->directory = (struct directory *)((void *)0);
#line 1060
      buffer->parent = (struct name *)((void *)0);
#line 1061
      buffer->cmdline = (_Bool)1;
#line 1063
      nametail = buffer;
#line 1063
      namelist = nametail;
    } else
#line 1065
    if (change_dir) {
      {
#line 1066
      addname((char const   *)0, change_dir, (_Bool)0, (struct name *)((void *)0));
      }
    }
  } else {
#line 1071
    change_dir___0 = 0;
    {
#line 1073
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1075
      change_dir0 = change_dir___0;
      {
#line 1076
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 1076
        ep = name_next_elt(0);
        }
#line 1076
        if (ep) {
#line 1076
          if (! ((unsigned int )ep->type == 1U)) {
#line 1076
            goto while_break___1;
          }
        } else {
#line 1076
          goto while_break___1;
        }
        {
#line 1077
        tmp___1 = xstrdup(ep->v.name);
#line 1077
        change_dir___0 = chdir_arg((char const   *)tmp___1);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1079
      if (ep) {
        {
#line 1080
        addname(ep->v.name, change_dir___0, (_Bool)1, (struct name *)((void *)0));
        }
      } else {
#line 1083
        if (change_dir___0 != change_dir0) {
          {
#line 1084
          addname((char const   *)((void *)0), change_dir___0, (_Bool)0, (struct name *)((void *)0));
          }
        }
#line 1085
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1089
  return;
}
}
#line 1092 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct name *addname(char const   *string , int change_dir___0 , _Bool cmdline , struct name *parent ) 
{ 
  struct name *name ;
  struct name *tmp ;
  int tmp___0 ;

  {
  {
#line 1095
  tmp = make_name(string);
#line 1095
  name = tmp;
#line 1097
  name->prev = nametail;
#line 1098
  name->next = (struct name *)((void *)0);
#line 1099
  name->found_count = (uintmax_t )0;
  }
#line 1100
  if ((unsigned int )wildcards == 2U) {
#line 1100
    tmp___0 = 1 << 28;
  } else {
#line 1100
    tmp___0 = 0;
  }
#line 1100
  name->matching_flags = ((tmp___0 | include_anchored) | matching_flags) | recursion_option;
#line 1101
  name->change_dir = change_dir___0;
#line 1102
  name->directory = (struct directory *)((void *)0);
#line 1103
  name->parent = parent;
#line 1104
  name->cmdline = cmdline;
#line 1106
  if (nametail) {
#line 1107
    nametail->next = name;
  } else {
#line 1109
    namelist = name;
  }
#line 1110
  nametail = name;
#line 1111
  return (name);
}
}
#line 1116 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *namelist_match(char const   *file_name___0 , size_t length ) 
{ 
  struct name *p ;
  _Bool tmp ;

  {
#line 1121
  p = namelist;
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (! p) {
#line 1121
      goto while_break;
    }
#line 1123
    if (*(p->name + 0)) {
      {
#line 1123
      tmp = exclude_fnmatch((char const   *)p->name, file_name___0, p->matching_flags);
      }
#line 1123
      if (tmp) {
#line 1125
        return (p);
      }
    }
#line 1121
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1128
  return ((struct name *)((void *)0));
}
}
#line 1131 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void remname(struct name *name ) 
{ 
  struct name *p ;

  {
#line 1136
  p = name->prev;
#line 1136
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1137
    p->next = name->next;
  } else {
#line 1139
    namelist = name->next;
  }
#line 1141
  p = name->next;
#line 1141
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1142
    p->prev = name->prev;
  } else {
#line 1144
    nametail = name->prev;
  }
#line 1145
  return;
}
}
#line 1149 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
_Bool name_match(char const   *file_name___0 ) 
{ 
  size_t length ;
  size_t tmp ;
  struct name *cursor ;
  int tmp___0 ;

  {
  {
#line 1152
  tmp = strlen(file_name___0);
#line 1152
  length = tmp;
  }
  {
#line 1154
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1156
    cursor = namelist;
#line 1158
    if (! cursor) {
#line 1159
      return ((_Bool)1);
    }
#line 1161
    if ((int )*(cursor->name + 0) == 0) {
      {
#line 1163
      chdir_do(cursor->change_dir);
#line 1164
      namelist = (struct name *)((void *)0);
#line 1165
      nametail = (struct name *)((void *)0);
      }
#line 1166
      return ((_Bool)1);
    }
    {
#line 1169
    cursor = namelist_match(file_name___0, length);
    }
#line 1170
    if (cursor) {
#line 1172
      if ((int const   )*(file_name___0 + cursor->length) == 47) {
#line 1172
        if (recursion_option) {
#line 1172
          if (cursor->found_count == 0UL) {
#line 1174
            (cursor->found_count) ++;
          }
        } else {
#line 1174
          (cursor->found_count) ++;
        }
      } else {
#line 1174
        (cursor->found_count) ++;
      }
#line 1175
      if (starting_file_option) {
        {
#line 1177
        free((void *)namelist);
#line 1178
        namelist = (struct name *)((void *)0);
#line 1179
        nametail = (struct name *)((void *)0);
        }
      }
      {
#line 1181
      chdir_do(cursor->change_dir);
      }
#line 1184
      if (occurrence_option == 0UL) {
#line 1184
        tmp___0 = cursor->found_count != 0UL;
      } else {
#line 1184
        tmp___0 = cursor->found_count == occurrence_option;
      }
#line 1184
      return ((_Bool )tmp___0);
    }
#line 1192
    if (same_order_option) {
#line 1192
      if (namelist->found_count) {
        {
#line 1194
        name_gather();
        }
#line 1195
        if (namelist->found_count) {
#line 1196
          return ((_Bool)0);
        }
      } else {
#line 1199
        return ((_Bool)0);
      }
    } else {
#line 1199
      return ((_Bool)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1212 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
_Bool all_names_found(struct tar_stat_info *p ) 
{ 
  struct name  const  *cursor ;
  size_t len ;
  int tmp ;

  {
#line 1218
  if (! p->file_name) {
#line 1219
    return ((_Bool)0);
  } else
#line 1218
  if (occurrence_option == 0UL) {
#line 1219
    return ((_Bool)0);
  } else
#line 1218
  if (p->had_trailing_slash) {
#line 1219
    return ((_Bool)0);
  }
  {
#line 1220
  len = strlen((char const   *)p->file_name);
#line 1221
  cursor = (struct name  const  *)namelist;
  }
  {
#line 1221
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1221
    if (! cursor) {
#line 1221
      goto while_break;
    }
#line 1223
    if (*(cursor->name + 0)) {
#line 1223
      if (occurrence_option == 0UL) {
#line 1223
        tmp = cursor->found_count != 0UL;
      } else {
#line 1223
        tmp = cursor->found_count >= (uintmax_t const   )occurrence_option;
      }
#line 1223
      if (tmp) {
#line 1223
        goto _L;
      } else {
#line 1225
        return ((_Bool)0);
      }
    } else
    _L: /* CIL Label */ 
#line 1223
    if (len >= (size_t )cursor->length) {
#line 1223
      if ((int )*(p->file_name + cursor->length) == 47) {
#line 1225
        return ((_Bool)0);
      }
    }
#line 1221
    cursor = (struct name  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1227
  return ((_Bool)1);
}
}
#line 1233
static int regex_usage_warning(char const   *name ) ;
#line 1233 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int warned_once  =    0;
#line 1230 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int regex_usage_warning(char const   *name ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 1237
  if ((unsigned int )wildcards == 0U) {
    {
#line 1237
    tmp___1 = fnmatch_pattern_has_wildcards(name, 0);
    }
#line 1237
    if (tmp___1) {
#line 1240
      warned_once = 1;
      {
#line 1241
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1241
        if (error_hook) {
          {
#line 1241
          (*error_hook)();
          }
        }
        {
#line 1241
        tmp = gettext("Pattern matching characters used in file names");
#line 1241
        error(0, 0, (char const   *)tmp);
        }
#line 1241
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1243
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1243
        if (error_hook) {
          {
#line 1243
          (*error_hook)();
          }
        }
        {
#line 1243
        tmp___0 = gettext("Use --wildcards to enable pattern matching, or --no-wildcards to suppress this warning");
#line 1243
        error(0, 0, (char const   *)tmp___0);
        }
#line 1243
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 1247
  return (warned_once);
}
}
#line 1251 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void names_notfound(void) 
{ 
  struct name  const  *cursor ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *name ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 1256
  cursor = (struct name  const  *)namelist;
  {
#line 1256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1256
    if (! cursor) {
#line 1256
      goto while_break;
    }
#line 1257
    if (occurrence_option == 0UL) {
#line 1257
      tmp___3 = cursor->found_count != 0UL;
    } else {
#line 1257
      tmp___3 = cursor->found_count >= (uintmax_t const   )occurrence_option;
    }
#line 1257
    if (! tmp___3) {
#line 1257
      if (*(cursor->name + 0)) {
        {
#line 1259
        regex_usage_warning((char const   *)cursor->name);
        }
        {
#line 1260
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1260
          if (error_hook) {
            {
#line 1260
            (*error_hook)();
            }
          }
          {
#line 1260
          tmp = quotearg_colon((char const   *)cursor->name);
          }
#line 1260
          if (cursor->found_count == 0UL) {
            {
#line 1260
            tmp___0 = gettext("%s: Not found in archive");
#line 1260
            tmp___2 = tmp___0;
            }
          } else {
            {
#line 1260
            tmp___1 = gettext("%s: Required occurrence not found in archive");
#line 1260
            tmp___2 = tmp___1;
            }
          }
          {
#line 1260
          error(0, 0, (char const   *)tmp___2, tmp);
#line 1260
          exit_status = 2;
          }
#line 1260
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
    }
#line 1256
    cursor = (struct name  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1268
  namelist = (struct name *)((void *)0);
#line 1269
  nametail = (struct name *)((void *)0);
#line 1271
  if (same_order_option) {
    {
#line 1275
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1275
      name = name_next(1);
      }
#line 1275
      if (! ((unsigned long )name != (unsigned long )((void *)0))) {
#line 1275
        goto while_break___1;
      }
      {
#line 1277
      regex_usage_warning(name);
      }
      {
#line 1278
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1278
        if (error_hook) {
          {
#line 1278
          (*error_hook)();
          }
        }
        {
#line 1278
        tmp___4 = quotearg_colon(name);
#line 1278
        tmp___5 = gettext("%s: Not found in archive");
#line 1278
        error(0, 0, (char const   *)tmp___5, tmp___4);
#line 1278
        exit_status = 2;
        }
#line 1278
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1282
  return;
}
}
#line 1284 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void label_notfound(void) 
{ 
  struct name  const  *cursor ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char const   *name ;
  int tmp___2 ;

  {
#line 1289
  if (! namelist) {
#line 1290
    return;
  }
#line 1292
  cursor = (struct name  const  *)namelist;
  {
#line 1292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1292
    if (! cursor) {
#line 1292
      goto while_break;
    }
#line 1293
    if (occurrence_option == 0UL) {
#line 1293
      tmp = cursor->found_count != 0UL;
    } else {
#line 1293
      tmp = cursor->found_count >= (uintmax_t const   )occurrence_option;
    }
#line 1293
    if (tmp) {
#line 1294
      return;
    }
#line 1292
    cursor = (struct name  const  *)cursor->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1296
  if (verbose_option) {
    {
#line 1297
    tmp___0 = gettext("Archive label mismatch");
#line 1297
    error(0, 0, (char const   *)tmp___0);
    }
  }
  {
#line 1298
  set_exit_status(1);
#line 1300
  cursor = (struct name  const  *)namelist;
  }
  {
#line 1300
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1300
    if (! cursor) {
#line 1300
      goto while_break___0;
    }
    {
#line 1302
    tmp___1 = regex_usage_warning((char const   *)cursor->name);
    }
#line 1302
    if (tmp___1) {
#line 1303
      goto while_break___0;
    }
#line 1300
    cursor = (struct name  const  *)cursor->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1307
  namelist = (struct name *)((void *)0);
#line 1308
  nametail = (struct name *)((void *)0);
#line 1310
  if (same_order_option) {
    {
#line 1314
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1314
      name = name_next(1);
      }
#line 1314
      if ((unsigned long )name != (unsigned long )((void *)0)) {
        {
#line 1314
        tmp___2 = regex_usage_warning(name);
        }
#line 1314
        if (! (tmp___2 == 0)) {
#line 1314
          goto while_break___1;
        }
      } else {
#line 1314
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1318
  return;
}
}
#line 1331 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *merge_sort_sll(struct name *list , int length , int (*compare)(struct name  const  * ,
                                                                                   struct name  const  * ) ) 
{ 
  struct name *first_list ;
  struct name *second_list ;
  int first_length ;
  int second_length ;
  struct name *result ;
  struct name **merge_point ;
  struct name *cursor ;
  int counter ;
  int tmp ;
  int tmp___0 ;

  {
#line 1346
  if (length == 1) {
#line 1347
    return (list);
  }
#line 1349
  if (length == 2) {
    {
#line 1351
    tmp = (*compare)((struct name  const  *)list, (struct name  const  *)list->next);
    }
#line 1351
    if (tmp > 0) {
#line 1353
      result = list->next;
#line 1354
      result->next = list;
#line 1355
      list->next = (struct name *)0;
#line 1356
      return (result);
    }
#line 1358
    return (list);
  }
#line 1361
  first_list = list;
#line 1362
  first_length = (length + 1) / 2;
#line 1363
  second_length = length / 2;
#line 1364
  cursor = list;
#line 1364
  counter = first_length - 1;
  {
#line 1364
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1364
    if (! counter) {
#line 1364
      goto while_break;
    }
#line 1367
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1364
    cursor = cursor->next;
#line 1364
    counter --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1368
  second_list = cursor->next;
#line 1369
  cursor->next = (struct name *)0;
#line 1371
  first_list = merge_sort_sll(first_list, first_length, compare);
#line 1372
  second_list = merge_sort_sll(second_list, second_length, compare);
#line 1374
  merge_point = & result;
  }
  {
#line 1375
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1375
    if (first_list) {
#line 1375
      if (! second_list) {
#line 1375
        goto while_break___0;
      }
    } else {
#line 1375
      goto while_break___0;
    }
    {
#line 1376
    tmp___0 = (*compare)((struct name  const  *)first_list, (struct name  const  *)second_list);
    }
#line 1376
    if (tmp___0 < 0) {
#line 1378
      cursor = first_list->next;
#line 1379
      *merge_point = first_list;
#line 1380
      merge_point = & first_list->next;
#line 1381
      first_list = cursor;
    } else {
#line 1385
      cursor = second_list->next;
#line 1386
      *merge_point = second_list;
#line 1387
      merge_point = & second_list->next;
#line 1388
      second_list = cursor;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1390
  if (first_list) {
#line 1391
    *merge_point = first_list;
  } else {
#line 1393
    *merge_point = second_list;
  }
#line 1395
  return (result);
}
}
#line 1402 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static struct name *merge_sort(struct name *list , int length , int (*compare)(struct name  const  * ,
                                                                               struct name  const  * ) ) 
{ 
  struct name *head ;
  struct name *p ;
  struct name *prev ;

  {
  {
#line 1407
  head = merge_sort_sll(list, length, compare);
#line 1409
  prev = (struct name *)((void *)0);
#line 1409
  p = head;
  }
  {
#line 1409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1409
    if (! p) {
#line 1409
      goto while_break;
    }
#line 1410
    p->prev = prev;
#line 1409
    prev = p;
#line 1409
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1411
  return (head);
}
}
#line 1417 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int compare_names_found(struct name  const  *n1 , struct name  const  *n2 ) 
{ 
  int found_diff ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1420
  if (occurrence_option == 0UL) {
#line 1420
    tmp = n2->found_count != 0UL;
  } else {
#line 1420
    tmp = n2->found_count >= (uintmax_t const   )occurrence_option;
  }
#line 1420
  if (occurrence_option == 0UL) {
#line 1420
    tmp___0 = n1->found_count != 0UL;
  } else {
#line 1420
    tmp___0 = n1->found_count >= (uintmax_t const   )occurrence_option;
  }
#line 1420
  found_diff = tmp - tmp___0;
#line 1421
  if (found_diff) {
#line 1421
    tmp___2 = found_diff;
  } else {
    {
#line 1421
    tmp___1 = strcmp((char const   *)n1->name, (char const   *)n2->name);
#line 1421
    tmp___2 = tmp___1;
    }
  }
#line 1421
  return (tmp___2);
}
}
#line 1425 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static int compare_names(struct name  const  *n1 , struct name  const  *n2 ) 
{ 
  int tmp ;

  {
  {
#line 1428
  tmp = strcmp((char const   *)n1->name, (char const   *)n2->name);
  }
#line 1428
  return (tmp);
}
}
#line 1435 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void add_hierarchy_to_namelist(struct tar_stat_info *st , struct name *name ) 
{ 
  char const   *buffer___1 ;
  struct name *child_head ;
  struct name *child_tail ;
  size_t name_length ;
  size_t allocated_length ;
  size_t tmp ;
  char *namebuf ;
  void *tmp___0 ;
  char const   *string ;
  size_t string_length ;
  int change_dir___0 ;
  size_t tmp___1 ;
  struct name *np ;
  struct tar_stat_info subdir ;
  int subfd ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___5 ;

  {
  {
#line 1440
  name->directory = scan_directory(st);
#line 1441
  buffer___1 = directory_contents(name->directory);
  }
#line 1442
  if (buffer___1) {
#line 1444
    child_head = (struct name *)((void *)0);
#line 1444
    child_tail = (struct name *)((void *)0);
#line 1445
    name_length = name->length;
#line 1446
    if (name_length >= 100UL) {
#line 1446
      tmp = name_length + 100UL;
    } else {
#line 1446
      tmp = (size_t )100;
    }
    {
#line 1446
    allocated_length = tmp;
#line 1449
    tmp___0 = xmalloc(allocated_length + 1UL);
#line 1449
    namebuf = (char *)tmp___0;
#line 1453
    change_dir___0 = name->change_dir;
#line 1455
    strcpy((char */* __restrict  */)namebuf, (char const   */* __restrict  */)name->name);
    }
#line 1456
    if (! ((int )*(namebuf + (name_length - 1UL)) == 47)) {
#line 1458
      tmp___1 = name_length;
#line 1458
      name_length ++;
#line 1458
      *(namebuf + tmp___1) = (char )'/';
#line 1459
      *(namebuf + name_length) = (char )'\000';
    }
#line 1462
    string = buffer___1;
    {
#line 1462
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1462
      if (! *string) {
#line 1462
        goto while_break;
      }
      {
#line 1464
      string_length = strlen(string);
      }
#line 1465
      if ((int const   )*string == 68) {
#line 1471
        if (allocated_length <= name_length + string_length) {
          {
#line 1473
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1475
            allocated_length *= 2UL;
#line 1476
            if (! allocated_length) {
              {
#line 1477
              xalloc_die();
              }
            }
#line 1473
            if (! (allocated_length <= name_length + string_length)) {
#line 1473
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 1481
          tmp___2 = xrealloc((void *)namebuf, allocated_length + 1UL);
#line 1481
          namebuf = (char *)tmp___2;
          }
        }
        {
#line 1483
        strcpy((char */* __restrict  */)(namebuf + name_length), (char const   */* __restrict  */)(string + 1));
#line 1484
        np = addname((char const   *)namebuf, change_dir___0, (_Bool)0, name);
        }
#line 1485
        if (! child_head) {
#line 1486
          child_head = np;
        } else {
#line 1488
          child_tail->sibling = np;
        }
        {
#line 1489
        child_tail = np;
#line 1491
        tar_stat_init(& subdir);
#line 1492
        subdir.parent = st;
        }
#line 1493
        if (st->fd < 0) {
          {
#line 1495
          subfd = -1;
#line 1496
          tmp___3 = __errno_location();
#line 1496
          *tmp___3 = - st->fd;
          }
        } else {
          {
#line 1499
          subfd = subfile_open((struct tar_stat_info  const  *)st, string + 1, open_read_flags | 65536);
          }
        }
#line 1501
        if (subfd < 0) {
          {
#line 1502
          open_diag((char const   *)namebuf);
          }
        } else {
          {
#line 1505
          subdir.fd = subfd;
#line 1506
          tmp___5 = fstat(subfd, & subdir.stat);
          }
#line 1506
          if (tmp___5 != 0) {
            {
#line 1507
            stat_diag((char const   *)namebuf);
            }
          } else {
            {
#line 1515
            subdir.orig_file_name = xstrdup((char const   *)namebuf);
#line 1516
            add_hierarchy_to_namelist(& subdir, np);
#line 1517
            restore_parent_fd((struct tar_stat_info  const  *)(& subdir));
            }
          }
        }
        {
#line 1521
        tar_stat_destroy(& subdir);
        }
      }
#line 1462
      string += string_length + 1UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1525
    free((void *)namebuf);
#line 1526
    name->child = child_head;
    }
  }
#line 1528
  return;
}
}
#line 1532 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static size_t name_hash(void const   *entry___0 , size_t n_buckets ) 
{ 
  struct name  const  *name ;
  size_t tmp ;

  {
  {
#line 1535
  name = (struct name  const  *)entry___0;
#line 1536
  tmp = hash_string((char const   *)name->caname, n_buckets);
  }
#line 1536
  return (tmp);
}
}
#line 1540 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static _Bool name_compare(void const   *entry1 , void const   *entry2 ) 
{ 
  struct name  const  *name1 ;
  struct name  const  *name2 ;
  int tmp ;

  {
  {
#line 1543
  name1 = (struct name  const  *)entry1;
#line 1544
  name2 = (struct name  const  *)entry2;
#line 1545
  tmp = strcmp((char const   *)name1->caname, (char const   *)name2->caname);
  }
#line 1545
  return ((_Bool )(tmp == 0));
}
}
#line 1551 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
static void rebase_child_list(struct name *child , struct name *parent ) 
{ 
  size_t old_prefix_len ;
  size_t new_prefix_len ;
  char *new_prefix ;
  size_t size ;
  char *newp ;
  void *tmp ;

  {
#line 1554
  old_prefix_len = (child->parent)->length;
#line 1555
  new_prefix_len = parent->length;
#line 1556
  new_prefix = parent->name;
  {
#line 1558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1558
    if (! child) {
#line 1558
      goto while_break;
    }
    {
#line 1560
    size = (child->length - old_prefix_len) + new_prefix_len;
#line 1561
    tmp = xmalloc(size + 1UL);
#line 1561
    newp = (char *)tmp;
#line 1562
    strcpy((char */* __restrict  */)newp, (char const   */* __restrict  */)new_prefix);
#line 1563
    strcat((char */* __restrict  */)newp, (char const   */* __restrict  */)(child->name + old_prefix_len));
#line 1564
    free((void *)child->name);
#line 1565
    child->name = newp;
#line 1566
    child->length = size;
#line 1568
    rebase_directory(child->directory, (char const   *)(child->parent)->name, old_prefix_len,
                     (char const   *)new_prefix, new_prefix_len);
#line 1558
    child = child->sibling;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1572
  return;
}
}
#line 1578 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void collect_and_sort_names(void) 
{ 
  struct name *name ;
  struct name *next_name ;
  struct name *prev_name ;
  int num_names ;
  Hash_table *nametab ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  struct tar_stat_info st ;
  int tmp___2 ;
  int dir_fd ;
  int tmp___3 ;
  int tmp___4 ;
  struct name *p ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 1582
  prev_name = (struct name *)((void *)0);
#line 1586
  name_gather();
  }
#line 1588
  if (! namelist) {
    {
#line 1589
    addname(".", 0, (_Bool)0, (struct name *)((void *)0));
    }
  }
#line 1591
  if (listed_incremental_option) {
    {
#line 1593
    tmp = chdir_count();
    }
    {
#line 1595
    if (tmp == 0) {
#line 1595
      goto case_0;
    }
#line 1598
    if (tmp == 1) {
#line 1598
      goto case_1;
    }
#line 1605
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1596
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1599
    if (namelist->change_dir == 0) {
      {
#line 1600
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1600
        if (error_hook) {
          {
#line 1600
          (*error_hook)();
          }
        }
        {
#line 1600
        tmp___0 = gettext("Using -C option inside file list is not allowed with --listed-incremental");
#line 1600
        error(0, 0, (char const   *)tmp___0);
#line 1600
        usage(2);
        }
#line 1600
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1603
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1606
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1606
      if (error_hook) {
        {
#line 1606
        (*error_hook)();
        }
      }
      {
#line 1606
      tmp___1 = gettext("Only one -C option is allowed with --listed-incremental");
#line 1606
      error(0, 0, (char const   *)tmp___1);
#line 1606
      usage(2);
      }
#line 1606
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 1611
    read_directory_file();
    }
  }
#line 1614
  num_names = 0;
#line 1615
  name = namelist;
  {
#line 1615
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1615
    if (! name) {
#line 1615
      goto while_break___1;
    }
#line 1619
    if (name->found_count) {
#line 1620
      goto __Cont;
    } else
#line 1619
    if (name->directory) {
#line 1620
      goto __Cont;
    }
#line 1621
    if (name->matching_flags & (1 << 28)) {
#line 1624
      goto __Cont;
    }
    {
#line 1625
    chdir_do(name->change_dir);
    }
#line 1627
    if ((int )*(name->name + 0) == 0) {
#line 1628
      goto __Cont;
    }
    {
#line 1630
    tar_stat_init(& st);
#line 1632
    tmp___2 = deref_stat((char const   *)name->name, & st.stat);
    }
#line 1632
    if (tmp___2 != 0) {
      {
#line 1634
      stat_diag((char const   *)name->name);
      }
#line 1635
      goto __Cont;
    }
#line 1637
    if ((st.stat.st_mode & 61440U) == 16384U) {
      {
#line 1639
      tmp___3 = openat(chdir_fd, (char const   *)name->name, open_read_flags | 65536);
#line 1639
      dir_fd = tmp___3;
      }
#line 1641
      if (dir_fd < 0) {
        {
#line 1642
        open_diag((char const   *)name->name);
        }
      } else {
        {
#line 1645
        st.fd = dir_fd;
#line 1646
        tmp___4 = fstat(dir_fd, & st.stat);
        }
#line 1646
        if (tmp___4 != 0) {
          {
#line 1647
          stat_diag((char const   *)name->name);
          }
        } else {
          {
#line 1650
          st.orig_file_name = xstrdup((char const   *)name->name);
#line 1651
          (name->found_count) ++;
#line 1652
          add_hierarchy_to_namelist(& st, name);
          }
        }
      }
    }
    {
#line 1657
    tar_stat_destroy(& st);
    }
    __Cont: /* CIL Label */ 
#line 1615
    name = name->next;
#line 1615
    num_names ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1660
  namelist = merge_sort(namelist, num_names, & compare_names);
#line 1662
  num_names = 0;
#line 1663
  nametab = hash_initialize((size_t )0, (Hash_tuning const   *)0, & name_hash, & name_compare,
                            (void (*)(void * ))((void *)0));
#line 1664
  name = namelist;
  }
  {
#line 1664
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1664
    if (! name) {
#line 1664
      goto while_break___2;
    }
    {
#line 1666
    next_name = name->next;
#line 1667
    name->caname = normalize_filename(name->change_dir, (char const   *)name->name);
    }
#line 1668
    if (prev_name) {
      {
#line 1670
      tmp___5 = hash_lookup((Hash_table const   *)nametab, (void const   *)name);
#line 1670
      p = (struct name *)tmp___5;
      }
#line 1671
      if (p) {
#line 1674
        if (! name->parent) {
#line 1676
          if (p->child) {
            {
#line 1677
            rebase_child_list(p->child, name);
            }
          }
          {
#line 1678
          hash_delete(nametab, (void const   *)name);
#line 1680
          remname(p);
#line 1681
          free_name(p);
#line 1682
          num_names --;
          }
        } else {
#line 1686
          if (name->child) {
            {
#line 1687
            rebase_child_list(name->child, p);
            }
          }
          {
#line 1689
          remname(name);
#line 1690
          free_name(name);
          }
#line 1691
          goto __Cont___0;
        }
      }
    }
    {
#line 1695
    name->found_count = (uintmax_t )0;
#line 1696
    tmp___6 = hash_insert(nametab, (void const   *)name);
    }
#line 1696
    if (! tmp___6) {
      {
#line 1697
      xalloc_die();
      }
    }
#line 1698
    prev_name = name;
#line 1699
    num_names ++;
    __Cont___0: /* CIL Label */ 
#line 1664
    name = next_name;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1701
  nametail = prev_name;
#line 1702
  hash_free(nametab);
#line 1704
  namelist = merge_sort(namelist, num_names, & compare_names_found);
  }
#line 1706
  if (listed_incremental_option) {
#line 1708
    name = namelist;
    {
#line 1708
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1708
      if (name) {
#line 1708
        if (! ((int )*(name->name + 0) == 0)) {
#line 1708
          goto while_break___3;
        }
      } else {
#line 1708
        goto while_break___3;
      }
#line 1708
      name ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1710
    if (name) {
      {
#line 1711
      append_incremental_renames(name->directory);
      }
    }
  }
#line 1713
  return;
}
}
#line 1720 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct name *name_scan(char const   *file_name___0 ) 
{ 
  size_t length ;
  size_t tmp ;
  struct name *cursor ;
  struct name *tmp___0 ;

  {
  {
#line 1723
  tmp = strlen(file_name___0);
#line 1723
  length = tmp;
  }
  {
#line 1725
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1727
    tmp___0 = namelist_match(file_name___0, length);
#line 1727
    cursor = tmp___0;
    }
#line 1728
    if (cursor) {
#line 1729
      return (cursor);
    }
#line 1736
    if (same_order_option) {
#line 1736
      if (namelist) {
#line 1736
        if (namelist->found_count) {
          {
#line 1738
          name_gather();
          }
#line 1739
          if (namelist->found_count) {
#line 1740
            return ((struct name *)0);
          }
        } else {
#line 1743
          return ((struct name *)0);
        }
      } else {
#line 1743
        return ((struct name *)0);
      }
    } else {
#line 1743
      return ((struct name *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1752 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
struct name  const  *name_from_list(void) 
{ 


  {
#line 1755
  if (! gnu_list_name) {
#line 1756
    gnu_list_name = namelist;
  }
  {
#line 1757
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1757
    if (gnu_list_name) {
#line 1757
      if (! gnu_list_name->found_count) {
#line 1757
        if (! ((int )*(gnu_list_name->name + 0) == 0)) {
#line 1757
          goto while_break;
        }
      }
    } else {
#line 1757
      goto while_break;
    }
#line 1759
    gnu_list_name = gnu_list_name->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1760
  if (gnu_list_name) {
    {
#line 1762
    (gnu_list_name->found_count) ++;
#line 1763
    chdir_do(gnu_list_name->change_dir);
    }
#line 1764
    return ((struct name  const  *)gnu_list_name);
  }
#line 1766
  return ((struct name  const  *)((void *)0));
}
}
#line 1769 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
void blank_name_list(void) 
{ 
  struct name *name ;

  {
#line 1774
  gnu_list_name = (struct name *)0;
#line 1775
  name = namelist;
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1775
    if (! name) {
#line 1775
      goto while_break;
    }
#line 1776
    name->found_count = (uintmax_t )0;
#line 1775
    name = name->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1777
  return;
}
}
#line 1781 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
char *make_file_name(char const   *directory_name , char const   *name ) 
{ 
  size_t dirlen ;
  size_t tmp ;
  size_t namelen ;
  size_t tmp___0 ;
  int slash ;
  int tmp___1 ;
  char *buffer___1 ;
  void *tmp___2 ;

  {
  {
#line 1784
  tmp = strlen(directory_name);
#line 1784
  dirlen = tmp;
#line 1785
  tmp___0 = strlen(name);
#line 1785
  namelen = tmp___0 + 1UL;
  }
#line 1786
  if (dirlen) {
#line 1786
    if (! ((int const   )*(directory_name + (dirlen - 1UL)) == 47)) {
#line 1786
      tmp___1 = 1;
    } else {
#line 1786
      tmp___1 = 0;
    }
  } else {
#line 1786
    tmp___1 = 0;
  }
  {
#line 1786
  slash = tmp___1;
#line 1787
  tmp___2 = xmalloc((dirlen + (size_t )slash) + namelen);
#line 1787
  buffer___1 = (char *)tmp___2;
#line 1788
  memcpy((void */* __restrict  */)buffer___1, (void const   */* __restrict  */)directory_name,
         dirlen);
#line 1789
  *(buffer___1 + dirlen) = (char )'/';
#line 1790
  memcpy((void */* __restrict  */)((buffer___1 + dirlen) + slash), (void const   */* __restrict  */)name,
         namelen);
  }
#line 1791
  return (buffer___1);
}
}
#line 1800 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
size_t stripped_prefix_len(char const   *file_name___0 , size_t num ) 
{ 
  char const   *p ;
  _Bool slash ;

  {
#line 1803
  p = file_name___0 + 0;
  {
#line 1804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1804
    if (! ((int const   )*p == 47)) {
#line 1804
      goto while_break;
    }
#line 1805
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1806
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1806
    if (! *p) {
#line 1806
      goto while_break___0;
    }
#line 1808
    slash = (_Bool )((int const   )*p == 47);
#line 1809
    p ++;
#line 1810
    if (slash) {
#line 1812
      num --;
#line 1812
      if (num == 0UL) {
#line 1813
        return ((size_t )(p - file_name___0));
      }
      {
#line 1814
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1814
        if (! ((int const   )*p == 47)) {
#line 1814
          goto while_break___1;
        }
#line 1815
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1818
  return ((size_t )-1);
}
}
#line 1822 "/home/khheo/project/benchmark/tar-1.29/src/names.c"
_Bool contains_dot_dot(char const   *name ) 
{ 
  char const   *p ;
  char const   *tmp ;

  {
#line 1825
  p = name + 0;
  {
#line 1827
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1829
    if ((int const   )*(p + 0) == 46) {
#line 1829
      if ((int const   )*(p + 1) == 46) {
#line 1829
        if ((int const   )*(p + 2) == 47) {
#line 1830
          return ((_Bool)1);
        } else
#line 1829
        if (! *(p + 2)) {
#line 1830
          return ((_Bool)1);
        }
      }
    }
    {
#line 1832
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1832
      if (! (! ((int const   )*p == 47))) {
#line 1832
        goto while_break___0;
      }
#line 1834
      tmp = p;
#line 1834
      p ++;
#line 1834
      if (! *tmp) {
#line 1835
        return ((_Bool)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1827
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 979 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 150 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) renameat)(int __oldfd ,
                                                                               char const   *__old ,
                                                                               int __newfd ,
                                                                               char const   *__new ) ;
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 541
void remove_delayed_set_stat(char const   *fname ) ;
#line 627
char *zap_slashes(char *name ) ;
#line 630
void replace_prefix(char **pname , char const   *samp , size_t slen , char const   *repl ,
                    size_t rlen ) ;
#line 662
char *sysinttostr(uintmax_t value___0 , intmax_t minval , uintmax_t maxval , char *buf ) ;
#line 663
intmax_t strtosysint(char const   *arg___0 , char **arglim , intmax_t minval , uintmax_t maxval ) ;
#line 664
void code_ns_fraction(int ns , char *p ) ;
#line 669
struct timespec decode_timespec(char const   *arg___0 , char **arg_lim , _Bool parse_fraction ) ;
#line 678
_Bool must_be_dot_or_slash(char const   *file_name___0 ) ;
#line 694
int remove_any_file(char const   *file_name___0 , enum remove_option option ) ;
#line 703 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
int chdir_current  ;
#line 712
void readlink_diag(char const   *name ) ;
#line 713
void savedir_diag(char const   *name ) ;
#line 716
void file_removed_diag(char const   *name , _Bool top_level , void (*diagfn)(char const   *name ) ) ;
#line 726
void *page_aligned_alloc(void **ptr , size_t size ) ;
#line 727
int set_file_atime(int fd , int parentfd , char const   *file , struct timespec atime ) ;
#line 974
#pragma GCC diagnostic pop
#line 32 "../gnu/utimens.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 47
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static void namebuf_add_dir(namebuf_t buf , char const   *name ) ;
#line 33
static char *namebuf_finish(namebuf_t buf ) ;
#line 34
static char const   *tar_getcdpath(int idx ) ;
#line 41 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void assign_string(char **string , char const   *value___0 ) 
{ 
  char *tmp ;

  {
  {
#line 44
  free((void *)*string);
  }
#line 45
  if (value___0) {
    {
#line 45
    tmp = xstrdup(value___0);
#line 45
    *string = tmp;
    }
  } else {
#line 45
    *string = (char *)0;
  }
#line 46
  return;
}
}
#line 116 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int unquote_string(char *string ) 
{ 
  int result ;
  char *source ;
  char *destination ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int value___0 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;

  {
#line 119
  result = 1;
#line 120
  source = string;
#line 121
  destination = string;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! *source) {
#line 128
      goto while_break;
    }
#line 129
    if ((int )*source == 92) {
#line 130
      source ++;
      {
#line 132
      if ((int )*source == 92) {
#line 132
        goto case_92;
      }
#line 137
      if ((int )*source == 97) {
#line 137
        goto case_97;
      }
#line 142
      if ((int )*source == 98) {
#line 142
        goto case_98;
      }
#line 147
      if ((int )*source == 102) {
#line 147
        goto case_102;
      }
#line 152
      if ((int )*source == 110) {
#line 152
        goto case_110;
      }
#line 157
      if ((int )*source == 114) {
#line 157
        goto case_114;
      }
#line 162
      if ((int )*source == 116) {
#line 162
        goto case_116;
      }
#line 167
      if ((int )*source == 118) {
#line 167
        goto case_118;
      }
#line 172
      if ((int )*source == 63) {
#line 172
        goto case_63;
      }
#line 184
      if ((int )*source == 55) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 54) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 53) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 52) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 51) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 50) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 49) {
#line 184
        goto case_55;
      }
#line 184
      if ((int )*source == 48) {
#line 184
        goto case_55;
      }
#line 204
      goto switch_default;
      case_92: /* CIL Label */ 
#line 133
      tmp = destination;
#line 133
      destination ++;
#line 133
      *tmp = (char )'\\';
#line 134
      source ++;
#line 135
      goto switch_break;
      case_97: /* CIL Label */ 
#line 138
      tmp___0 = destination;
#line 138
      destination ++;
#line 138
      *tmp___0 = (char )'\a';
#line 139
      source ++;
#line 140
      goto switch_break;
      case_98: /* CIL Label */ 
#line 143
      tmp___1 = destination;
#line 143
      destination ++;
#line 143
      *tmp___1 = (char )'\b';
#line 144
      source ++;
#line 145
      goto switch_break;
      case_102: /* CIL Label */ 
#line 148
      tmp___2 = destination;
#line 148
      destination ++;
#line 148
      *tmp___2 = (char )'\f';
#line 149
      source ++;
#line 150
      goto switch_break;
      case_110: /* CIL Label */ 
#line 153
      tmp___3 = destination;
#line 153
      destination ++;
#line 153
      *tmp___3 = (char )'\n';
#line 154
      source ++;
#line 155
      goto switch_break;
      case_114: /* CIL Label */ 
#line 158
      tmp___4 = destination;
#line 158
      destination ++;
#line 158
      *tmp___4 = (char )'\r';
#line 159
      source ++;
#line 160
      goto switch_break;
      case_116: /* CIL Label */ 
#line 163
      tmp___5 = destination;
#line 163
      destination ++;
#line 163
      *tmp___5 = (char )'\t';
#line 164
      source ++;
#line 165
      goto switch_break;
      case_118: /* CIL Label */ 
#line 168
      tmp___6 = destination;
#line 168
      destination ++;
#line 168
      *tmp___6 = (char )'\v';
#line 169
      source ++;
#line 170
      goto switch_break;
      case_63: /* CIL Label */ 
#line 173
      tmp___7 = destination;
#line 173
      destination ++;
#line 173
      *tmp___7 = (char)127;
#line 174
      source ++;
#line 175
      goto switch_break;
      case_55: /* CIL Label */ 
      case_54: /* CIL Label */ 
      case_53: /* CIL Label */ 
      case_52: /* CIL Label */ 
      case_51: /* CIL Label */ 
      case_50: /* CIL Label */ 
      case_49: /* CIL Label */ 
      case_48: /* CIL Label */ 
#line 186
      tmp___8 = source;
#line 186
      source ++;
#line 186
      value___0 = (int )*tmp___8 - 48;
#line 188
      if ((int )*source < 48) {
#line 190
        tmp___9 = destination;
#line 190
        destination ++;
#line 190
        *tmp___9 = (char )value___0;
#line 191
        goto switch_break;
      } else
#line 188
      if ((int )*source > 55) {
#line 190
        tmp___9 = destination;
#line 190
        destination ++;
#line 190
        *tmp___9 = (char )value___0;
#line 191
        goto switch_break;
      }
#line 193
      tmp___10 = source;
#line 193
      source ++;
#line 193
      value___0 = (value___0 * 8 + (int )*tmp___10) - 48;
#line 194
      if ((int )*source < 48) {
#line 196
        tmp___11 = destination;
#line 196
        destination ++;
#line 196
        *tmp___11 = (char )value___0;
#line 197
        goto switch_break;
      } else
#line 194
      if ((int )*source > 55) {
#line 196
        tmp___11 = destination;
#line 196
        destination ++;
#line 196
        *tmp___11 = (char )value___0;
#line 197
        goto switch_break;
      }
#line 199
      tmp___12 = source;
#line 199
      source ++;
#line 199
      value___0 = (value___0 * 8 + (int )*tmp___12) - 48;
#line 200
      tmp___13 = destination;
#line 200
      destination ++;
#line 200
      *tmp___13 = (char )value___0;
#line 201
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 205
      result = 0;
#line 206
      tmp___14 = destination;
#line 206
      destination ++;
#line 206
      *tmp___14 = (char )'\\';
#line 207
      if (*source) {
#line 208
        tmp___15 = destination;
#line 208
        destination ++;
#line 208
        tmp___16 = source;
#line 208
        source ++;
#line 208
        *tmp___15 = *tmp___16;
      }
#line 209
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else
#line 211
    if ((unsigned long )source != (unsigned long )destination) {
#line 212
      tmp___17 = destination;
#line 212
      destination ++;
#line 212
      tmp___18 = source;
#line 212
      source ++;
#line 212
      *tmp___17 = *tmp___18;
    } else {
#line 214
      source ++;
#line 214
      destination ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  if ((unsigned long )source != (unsigned long )destination) {
#line 217
    *destination = (char )'\000';
  }
#line 218
  return (result);
}
}
#line 222 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char *zap_slashes(char *name ) 
{ 
  char *q ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 227
  if (! name) {
#line 228
    return (name);
  } else
#line 227
  if ((int )*name == 0) {
#line 228
    return (name);
  }
  {
#line 229
  tmp = strlen((char const   *)name);
#line 229
  q = (name + tmp) - 1;
  }
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if ((unsigned long )q > (unsigned long )name) {
#line 230
      if (! ((int )*q == 47)) {
#line 230
        goto while_break;
      }
    } else {
#line 230
      goto while_break;
    }
#line 231
    tmp___0 = q;
#line 231
    q --;
#line 231
    *tmp___0 = (char )'\000';
  }
  while_break: /* CIL Label */ ;
  }
#line 232
  return (name);
}
}
#line 241 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void normalize_filename_x(char *file_name___0 ) 
{ 
  char *name ;
  char *p ;
  char const   *q ;
  char c ;
  char tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 244
  name = file_name___0 + 0;
#line 250
  name += 0;
#line 254
  p = name;
#line 254
  q = (char const   *)p;
  {
#line 254
  while (1) {
    while_continue: /* CIL Label */ ;
#line 254
    tmp = (char )*q;
#line 254
    *p = tmp;
#line 254
    if ((int )tmp == 46) {
#line 254
      if (! ((int const   )*(q + 1) == 47)) {
#line 254
        goto while_break;
      }
    } else {
#line 254
      goto while_break;
    }
#line 255
    q += 2;
    {
#line 255
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 255
      if (! ((int const   )*q == 47)) {
#line 255
        goto while_break___0;
      }
#line 256
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 255
      q ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    p += ! *q;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 260
    tmp___0 = p;
#line 260
    p ++;
#line 260
    tmp___2 = q;
#line 260
    q ++;
#line 260
    c = (char )*tmp___2;
#line 260
    tmp___1 = c;
#line 260
    *tmp___0 = tmp___1;
#line 260
    if (! ((int )tmp___1 != 0)) {
#line 260
      goto while_break___1;
    }
#line 261
    if ((int )c == 47) {
      {
#line 262
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 262
        if (! ((int const   )*(q + ((int const   )*q == 46)) == 47)) {
#line 262
          goto while_break___2;
        }
#line 263
        q += ((int const   )*q == 46) + 1;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 266
  if (2L < p - name) {
#line 268
    if ((int )*(p + -2) == 46) {
#line 268
      if ((int )*(p + -3) == 47) {
#line 268
        tmp___3 = 1;
      } else {
#line 268
        tmp___3 = 0;
      }
    } else {
#line 268
      tmp___3 = 0;
    }
#line 268
    p -= tmp___3;
#line 269
    if (2L < p - name) {
#line 269
      if ((int )*(p + -2) == 47) {
#line 269
        tmp___4 = 1;
      } else {
#line 269
        tmp___4 = 0;
      }
    } else {
#line 269
      tmp___4 = 0;
    }
#line 269
    p -= tmp___4;
#line 270
    *(p + -1) = (char )'\000';
  }
#line 272
  return;
}
}
#line 279 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char *normalize_filename(int cdidx , char const   *name ) 
{ 
  char *copy ;
  char const   *cdpath ;
  char const   *tmp ;
  size_t copylen ;
  _Bool need_separator ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 282
  copy = (char *)((void *)0);
#line 284
  if (! ((int const   )*(name + 0) == 47)) {
    {
#line 295
    tmp = tar_getcdpath(cdidx);
#line 295
    cdpath = tmp;
    }
#line 299
    if (! cdpath) {
      {
#line 300
      call_arg_fatal("getcwd", ".");
      }
    }
    {
#line 301
    copylen = strlen(cdpath);
#line 302
    need_separator = (_Bool)1;
#line 304
    tmp___0 = strlen(name);
#line 304
    tmp___1 = xmalloc(((copylen + (size_t )need_separator) + tmp___0) + 1UL);
#line 304
    copy = (char *)tmp___1;
#line 305
    strcpy((char */* __restrict  */)copy, (char const   */* __restrict  */)cdpath);
#line 306
    *(copy + copylen) = (char )'/';
#line 307
    strcpy((char */* __restrict  */)((copy + copylen) + (int )need_separator), (char const   */* __restrict  */)name);
    }
  }
#line 310
  if (! copy) {
    {
#line 311
    copy = xstrdup(name);
    }
  }
  {
#line 312
  normalize_filename_x(copy);
  }
#line 313
  return (copy);
}
}
#line 317 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void replace_prefix(char **pname , char const   *samp , size_t slen , char const   *repl ,
                    size_t rlen ) 
{ 
  char *name ;
  size_t nlen ;
  size_t tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 321
  name = *pname;
#line 322
  tmp = strlen((char const   *)name);
#line 322
  nlen = tmp;
  }
#line 323
  if (nlen > slen) {
    {
#line 323
    tmp___1 = memcmp((void const   *)name, (void const   *)samp, slen);
    }
#line 323
    if (tmp___1 == 0) {
#line 323
      if ((int )*(name + slen) == 47) {
#line 325
        if (rlen > slen) {
          {
#line 327
          tmp___0 = xrealloc((void *)name, ((nlen - slen) + rlen) + 1UL);
#line 327
          name = (char *)tmp___0;
#line 328
          *pname = name;
          }
        }
        {
#line 330
        memmove((void *)(name + rlen), (void const   *)(name + slen), (nlen - slen) + 1UL);
#line 331
        memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)repl,
               rlen);
        }
      }
    }
  }
#line 333
  return;
}
}
#line 347 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char *sysinttostr(uintmax_t value___0 , intmax_t minval , uintmax_t maxval , char *buf ) 
{ 
  char *tmp ;
  intmax_t i ;
  char *tmp___0 ;

  {
#line 351
  if (value___0 <= maxval) {
    {
#line 352
    tmp = umaxtostr(value___0, (char *)buf);
    }
#line 352
    return (tmp);
  } else {
    {
#line 355
    i = (intmax_t )(value___0 - (uintmax_t )minval);
#line 356
    tmp___0 = imaxtostr(i + minval, (char *)buf);
    }
#line 356
    return (tmp___0);
  }
}
}
#line 376 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
intmax_t strtosysint(char const   *arg___0 , char **arglim , intmax_t minval , uintmax_t maxval ) 
{ 
  int *tmp ;
  intmax_t i ;
  intmax_t tmp___0 ;
  intmax_t imaxval ;
  int *tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t i___0 ;
  uintmax_t tmp___3 ;
  intmax_t tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 379
  tmp = __errno_location();
#line 379
  *tmp = 0;
  }
#line 380
  if (maxval <= 9223372036854775807UL) {
#line 382
    if ((unsigned int )*(arg___0 + ((int const   )*arg___0 == 45)) - 48U <= 9U) {
      {
#line 384
      tmp___0 = strtoimax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)arglim,
                          10);
#line 384
      i = tmp___0;
#line 385
      imaxval = (intmax_t )maxval;
      }
#line 386
      if (minval <= i) {
#line 386
        if (i <= imaxval) {
#line 387
          return (i);
        }
      }
      {
#line 388
      tmp___1 = __errno_location();
#line 388
      *tmp___1 = 34;
      }
#line 389
      if (i < minval) {
#line 389
        tmp___2 = (uintmax_t )minval;
      } else {
#line 389
        tmp___2 = maxval;
      }
#line 389
      return ((intmax_t )tmp___2);
    }
  } else
#line 394
  if ((unsigned int )*arg___0 - 48U <= 9U) {
    {
#line 396
    tmp___3 = strtoumax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)arglim,
                        10);
#line 396
    i___0 = tmp___3;
    }
#line 397
    if (i___0 <= maxval) {
      {
#line 398
      tmp___4 = represent_uintmax(i___0);
      }
#line 398
      return (tmp___4);
    }
    {
#line 399
    tmp___5 = __errno_location();
#line 399
    *tmp___5 = 34;
    }
#line 400
    return ((intmax_t )maxval);
  }
  {
#line 404
  tmp___6 = __errno_location();
#line 404
  *tmp___6 = 22;
  }
#line 405
  return ((intmax_t )0);
}
}
#line 412 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void code_ns_fraction(int ns , char *p ) 
{ 
  int i ;
  char *tmp ;

  {
#line 415
  if (ns == 0) {
#line 416
    *p = (char )'\000';
  } else {
#line 419
    i = 9;
#line 420
    tmp = p;
#line 420
    p ++;
#line 420
    *tmp = (char )'.';
    {
#line 422
    while (1) {
      while_continue: /* CIL Label */ ;
#line 422
      if (! (ns % 10 == 0)) {
#line 422
        goto while_break;
      }
#line 424
      ns /= 10;
#line 425
      i --;
    }
    while_break: /* CIL Label */ ;
    }
#line 428
    *(p + i) = (char )'\000';
    {
#line 430
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 432
      i --;
#line 432
      *(p + i) = (char )(48 + ns % 10);
#line 433
      if (i == 0) {
#line 434
        goto while_break___0;
      }
#line 435
      ns /= 10;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 438
  return;
}
}
#line 440 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char const   *code_timespec(struct timespec t , char *sbuf ) 
{ 
  time_t s ;
  int ns ;
  char *np ;
  _Bool negative ;
  uintmax_t tmp ;

  {
#line 443
  s = t.tv_sec;
#line 444
  ns = (int )t.tv_nsec;
#line 446
  negative = (_Bool )(s < 0L);
#line 449
  if (1000000000 <= ns) {
#line 450
    ns = 0;
  } else
#line 449
  if (ns < 0) {
#line 450
    ns = 0;
  }
#line 452
  if (negative) {
#line 452
    if (ns != 0) {
#line 454
      s ++;
#line 455
      ns = 1000000000 - ns;
    }
  }
#line 458
  if (negative) {
#line 458
    tmp = - ((uintmax_t )s);
  } else {
#line 458
    tmp = (uintmax_t )s;
  }
  {
#line 458
  np = umaxtostr(tmp, (char *)(sbuf + 1));
  }
#line 459
  if (negative) {
#line 460
    np --;
#line 460
    *np = (char )'-';
  }
  {
#line 461
  code_ns_fraction(ns, (char *)(sbuf + (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL)));
  }
#line 462
  return ((char const   *)np);
}
}
#line 465 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
struct timespec decode_timespec(char const   *arg___0 , char **arg_lim , _Bool parse_fraction ) 
{ 
  time_t s ;
  int ns ;
  char const   *p ;
  _Bool negative ;
  struct timespec r ;
  int *tmp ;
  int *tmp___0 ;
  intmax_t i ;
  intmax_t tmp___1 ;
  int *tmp___2 ;
  uintmax_t i___0 ;
  uintmax_t tmp___3 ;
  int *tmp___4 ;
  int digits ;
  _Bool trailing_nonzero ;
  int *tmp___5 ;

  {
#line 468
  s = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 469
  ns = -1;
#line 470
  p = arg___0;
#line 471
  negative = (_Bool )((int const   )*arg___0 == 45);
#line 474
  if (! ((unsigned int )*(arg___0 + negative) - 48U <= 9U)) {
    {
#line 475
    tmp = __errno_location();
#line 475
    *tmp = 22;
    }
  } else {
    {
#line 478
    tmp___0 = __errno_location();
#line 478
    *tmp___0 = 0;
    }
#line 480
    if (negative) {
      {
#line 482
      tmp___1 = strtoimax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)arg_lim,
                          10);
#line 482
      i = tmp___1;
      }
#line 483
      if (~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L) <= i) {
#line 484
        s = i;
      } else {
        {
#line 486
        tmp___2 = __errno_location();
#line 486
        *tmp___2 = 34;
        }
      }
    } else {
      {
#line 490
      tmp___3 = strtoumax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)arg_lim,
                          10);
#line 490
      i___0 = tmp___3;
      }
#line 491
      if (i___0 <= (uintmax_t )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) {
#line 492
        s = (time_t )i___0;
      } else {
        {
#line 494
        tmp___4 = __errno_location();
#line 494
        *tmp___4 = 34;
        }
      }
    }
#line 497
    p = (char const   *)*arg_lim;
#line 498
    ns = 0;
#line 500
    if (parse_fraction) {
#line 500
      if ((int const   )*p == 46) {
#line 502
        digits = 0;
#line 503
        trailing_nonzero = (_Bool)0;
        {
#line 505
        while (1) {
          while_continue: /* CIL Label */ ;
#line 505
          p ++;
#line 505
          if (! ((unsigned int )*p - 48U <= 9U)) {
#line 505
            goto while_break;
          }
#line 506
          if (digits < 9) {
#line 507
            digits ++;
#line 507
            ns = 10 * ns + (int )((int const   )*p - 48);
          } else {
#line 509
            trailing_nonzero = (_Bool )((int )trailing_nonzero | ((int const   )*p != 48));
          }
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 511
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 511
          if (! (digits < 9)) {
#line 511
            goto while_break___0;
          }
#line 512
          digits ++;
#line 512
          ns *= 10;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 514
        if (negative) {
#line 519
          ns += (int )trailing_nonzero;
#line 520
          if (ns != 0) {
#line 522
            if (s == ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)) {
#line 523
              ns = -1;
            } else {
#line 526
              s --;
#line 527
              ns = 1000000000 - ns;
            }
          }
        }
      }
    }
    {
#line 533
    tmp___5 = __errno_location();
    }
#line 533
    if (*tmp___5 == 34) {
#line 534
      ns = -1;
    }
  }
#line 537
  *arg_lim = (char *)p;
#line 538
  r.tv_sec = s;
#line 539
  r.tv_nsec = (__syscall_slong_t )ns;
#line 540
  return (r);
}
}
#line 546 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static char *before_backup_name  ;
#line 547 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static char *after_backup_name  ;
#line 550 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
_Bool must_be_dot_or_slash(char const   *file_name___0 ) 
{ 
  int tmp ;

  {
#line 553
  file_name___0 += 0;
#line 555
  if ((int const   )*(file_name___0 + 0) == 47) {
    {
#line 557
    while (1) {
      while_continue: /* CIL Label */ ;
#line 558
      if ((int const   )*(file_name___0 + 1) == 47) {
#line 559
        file_name___0 ++;
      } else
#line 560
      if ((int const   )*(file_name___0 + 1) == 46) {
#line 560
        if ((int const   )*(file_name___0 + (2 + ((int const   )*(file_name___0 + 2) == 46))) == 47) {
#line 562
          file_name___0 += 2 + ((int const   )*(file_name___0 + 2) == 46);
        } else {
#line 564
          return ((_Bool )(! *(file_name___0 + 1)));
        }
      } else {
#line 564
        return ((_Bool )(! *(file_name___0 + 1)));
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 568
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 568
      if ((int const   )*(file_name___0 + 0) == 46) {
#line 568
        if (! ((int const   )*(file_name___0 + 1) == 47)) {
#line 568
          goto while_break___0;
        }
      } else {
#line 568
        goto while_break___0;
      }
#line 570
      file_name___0 += 2;
      {
#line 571
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 571
        if (! ((int const   )*file_name___0 == 47)) {
#line 571
          goto while_break___1;
        }
#line 572
        file_name___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 575
    if (! *(file_name___0 + 0)) {
#line 575
      tmp = 1;
    } else
#line 575
    if ((int const   )*(file_name___0 + 0) == 46) {
#line 575
      if (! *(file_name___0 + 1)) {
#line 575
        tmp = 1;
      } else {
#line 575
        tmp = 0;
      }
    } else {
#line 575
      tmp = 0;
    }
#line 575
    return ((_Bool )tmp);
  }
}
}
#line 582 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static int safer_rmdir(char const   *file_name___0 ) 
{ 
  int *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  {
#line 585
  tmp___0 = must_be_dot_or_slash(file_name___0);
  }
#line 585
  if (tmp___0) {
    {
#line 587
    tmp = __errno_location();
#line 587
    *tmp = 0;
    }
#line 588
    return (-1);
  }
  {
#line 591
  tmp___1 = unlinkat(chdir_fd, file_name___0, 512);
  }
#line 591
  if (tmp___1 == 0) {
    {
#line 593
    remove_delayed_set_stat(file_name___0);
    }
#line 594
    return (0);
  }
#line 596
  return (-1);
}
}
#line 606 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int remove_any_file(char const   *file_name___0 , enum remove_option option ) 
{ 
  _Bool try_unlink_first ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *directory ;
  char *tmp___6 ;
  char const   *entry___0 ;
  size_t entrylen ;
  char *file_name_buffer ;
  char *tmp___7 ;
  int r ;
  int tmp___8 ;
  int e ;
  int *tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 612
  try_unlink_first = (_Bool)1;
#line 614
  if (try_unlink_first) {
    {
#line 616
    tmp = unlinkat(chdir_fd, file_name___0, 0);
    }
#line 616
    if (tmp == 0) {
#line 617
      return (1);
    }
    {
#line 622
    tmp___0 = __errno_location();
    }
#line 622
    if (*tmp___0 != 1) {
      {
#line 622
      tmp___1 = __errno_location();
      }
#line 622
      if (*tmp___1 != 21) {
#line 623
        return (0);
      }
    }
  }
  {
#line 626
  tmp___2 = safer_rmdir(file_name___0);
  }
#line 626
  if (tmp___2 == 0) {
#line 627
    return (1);
  }
  {
#line 629
  tmp___3 = __errno_location();
  }
  {
#line 631
  if (*tmp___3 == 20) {
#line 631
    goto case_20;
  }
#line 637
  if (*tmp___3 == 39) {
#line 637
    goto case_39;
  }
#line 637
  if (*tmp___3 == 17) {
#line 637
    goto case_39;
  }
#line 637
  if (*tmp___3 == 0) {
#line 637
    goto case_39;
  }
#line 629
  goto switch_break;
  case_20: /* CIL Label */ 
#line 632
  if (! try_unlink_first) {
    {
#line 632
    tmp___4 = unlinkat(chdir_fd, file_name___0, 0);
    }
#line 632
    if (tmp___4 == 0) {
#line 632
      tmp___5 = 1;
    } else {
#line 632
      tmp___5 = 0;
    }
  } else {
#line 632
    tmp___5 = 0;
  }
#line 632
  return (tmp___5);
  case_39: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 641
  if ((unsigned int )option == 0U) {
#line 641
    goto case_0___0;
  }
#line 644
  if ((unsigned int )option == 2U) {
#line 644
    goto case_2;
  }
#line 647
  if ((unsigned int )option == 1U) {
#line 647
    goto case_1;
  }
#line 639
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 642
  goto switch_break___0;
  case_2: /* CIL Label */ 
#line 645
  return (-1);
  case_1: /* CIL Label */ 
  {
#line 649
  tmp___6 = tar_savedir(file_name___0, 0);
#line 649
  directory = tmp___6;
  }
#line 653
  if (! directory) {
#line 654
    return (0);
  }
#line 656
  entry___0 = (char const   *)directory;
  {
#line 656
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 656
    entrylen = strlen(entry___0);
    }
#line 656
    if (! (entrylen != 0UL)) {
#line 656
      goto while_break;
    }
    {
#line 660
    tmp___7 = make_file_name(file_name___0, entry___0);
#line 660
    file_name_buffer = tmp___7;
#line 661
    tmp___8 = remove_any_file((char const   *)file_name_buffer, (enum remove_option )1);
#line 661
    r = tmp___8;
#line 663
    tmp___9 = __errno_location();
#line 663
    e = *tmp___9;
#line 664
    free((void *)file_name_buffer);
    }
#line 666
    if (! r) {
      {
#line 668
      free((void *)directory);
#line 669
      tmp___10 = __errno_location();
#line 669
      *tmp___10 = e;
      }
#line 670
      return (0);
    }
#line 656
    entry___0 += entrylen + 1UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 674
  free((void *)directory);
#line 675
  tmp___11 = safer_rmdir(file_name___0);
  }
#line 675
  return (tmp___11 == 0);
  switch_break___0: /* CIL Label */ ;
  }
#line 678
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 681
  return (0);
}
}
#line 690 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
_Bool maybe_backup_file(char const   *file_name___0 , _Bool this_is_the_archive ) 
{ 
  struct stat file_stat ;
  char *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int e ;
  int *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;

  {
  {
#line 695
  assign_string(& before_backup_name, file_name___0);
#line 702
  assign_string(& after_backup_name, (char const   *)0);
  }
#line 706
  if (this_is_the_archive) {
#line 706
    if (! force_local_option) {
      {
#line 706
      tmp = strchr(file_name___0, ':');
#line 706
      rmt_dev_name__ = (char const   *)tmp;
      }
#line 706
      if (rmt_dev_name__) {
#line 706
        if ((unsigned long )rmt_dev_name__ > (unsigned long )file_name___0) {
          {
#line 706
          tmp___0 = memchr((void const   *)file_name___0, '/', (size_t )(rmt_dev_name__ - file_name___0));
          }
#line 706
          if (! tmp___0) {
#line 707
            return ((_Bool)1);
          }
        }
      }
    }
  }
  {
#line 709
  tmp___2 = deref_stat(file_name___0, & file_stat);
  }
#line 709
  if (tmp___2 != 0) {
    {
#line 711
    tmp___1 = __errno_location();
    }
#line 711
    if (*tmp___1 == 2) {
#line 712
      return ((_Bool)1);
    }
    {
#line 714
    stat_error(file_name___0);
    }
#line 715
    return ((_Bool)0);
  }
#line 718
  if ((file_stat.st_mode & 61440U) == 16384U) {
#line 719
    return ((_Bool)1);
  }
#line 721
  if (this_is_the_archive) {
#line 721
    if ((file_stat.st_mode & 61440U) == 24576U) {
#line 723
      return ((_Bool)1);
    } else
#line 721
    if ((file_stat.st_mode & 61440U) == 8192U) {
#line 723
      return ((_Bool)1);
    }
  }
  {
#line 725
  after_backup_name = find_backup_file_name(file_name___0, backup_type);
  }
#line 726
  if (! after_backup_name) {
    {
#line 727
    xalloc_die();
    }
  }
  {
#line 729
  tmp___10 = renameat(chdir_fd, (char const   *)before_backup_name, chdir_fd, (char const   *)after_backup_name);
  }
#line 729
  if (tmp___10 == 0) {
#line 732
    if (verbose_option) {
      {
#line 733
      tmp___3 = quote_n(1, (char const   *)after_backup_name);
#line 733
      tmp___4 = quote_n(0, (char const   *)before_backup_name);
#line 733
      tmp___5 = gettext("Renaming %s to %s\n");
#line 733
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___5,
              tmp___4, tmp___3);
      }
    }
#line 736
    return ((_Bool)1);
  } else {
    {
#line 741
    tmp___6 = __errno_location();
#line 741
    e = *tmp___6;
    }
    {
#line 742
    while (1) {
      while_continue: /* CIL Label */ ;
#line 742
      if (error_hook) {
        {
#line 742
        (*error_hook)();
        }
      }
      {
#line 742
      tmp___7 = quote_n(1, (char const   *)after_backup_name);
#line 742
      tmp___8 = quotearg_colon((char const   *)before_backup_name);
#line 742
      tmp___9 = gettext("%s: Cannot rename to %s");
#line 742
      error(0, e, (char const   *)tmp___9, tmp___8, tmp___7);
#line 742
      exit_status = 2;
      }
#line 742
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 745
    assign_string(& after_backup_name, (char const   *)0);
    }
#line 746
    return ((_Bool)0);
  }
}
}
#line 752 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void undo_last_backup(void) 
{ 
  int e ;
  int *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;

  {
#line 755
  if (after_backup_name) {
    {
#line 757
    tmp___3 = renameat(chdir_fd, (char const   *)after_backup_name, chdir_fd, (char const   *)before_backup_name);
    }
#line 757
    if (tmp___3 != 0) {
      {
#line 760
      tmp = __errno_location();
#line 760
      e = *tmp;
      }
      {
#line 761
      while (1) {
        while_continue: /* CIL Label */ ;
#line 761
        if (error_hook) {
          {
#line 761
          (*error_hook)();
          }
        }
        {
#line 761
        tmp___0 = quote_n(1, (char const   *)before_backup_name);
#line 761
        tmp___1 = quotearg_colon((char const   *)after_backup_name);
#line 761
        tmp___2 = gettext("%s: Cannot rename to %s");
#line 761
        error(0, e, (char const   *)tmp___2, tmp___1, tmp___0);
#line 761
        exit_status = 2;
        }
#line 761
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 765
    if (verbose_option) {
      {
#line 766
      tmp___4 = quote_n(1, (char const   *)before_backup_name);
#line 766
      tmp___5 = quote_n(0, (char const   *)after_backup_name);
#line 766
      tmp___6 = gettext("Renaming %s back to %s\n");
#line 766
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___6,
              tmp___5, tmp___4);
      }
    }
    {
#line 769
    assign_string(& after_backup_name, (char const   *)0);
    }
  }
#line 771
  return;
}
}
#line 776 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int deref_stat(char const   *name , struct stat *buf ) 
{ 
  int tmp ;

  {
  {
#line 779
  tmp = fstatat(chdir_fd, (char const   */* __restrict  */)name, (struct stat */* __restrict  */)buf,
                fstatat_flags);
  }
#line 779
  return (tmp);
}
}
#line 788 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
size_t blocking_read(int fd , void *buf , size_t count ) 
{ 
  size_t bytes ;
  size_t tmp ;
  int flags ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 791
  tmp = safe_read(fd, buf, count);
#line 791
  bytes = tmp;
  }
#line 794
  if (bytes == 0xffffffffffffffffUL) {
    {
#line 794
    tmp___2 = __errno_location();
    }
#line 794
    if (*tmp___2 == 11) {
      {
#line 796
      tmp___0 = rpl_fcntl(fd, 3);
#line 796
      flags = tmp___0;
      }
#line 797
      if (0 <= flags) {
#line 797
        if (flags & 2048) {
          {
#line 797
          tmp___1 = rpl_fcntl(fd, 4, flags & -2049);
          }
#line 797
          if (tmp___1 != -1) {
            {
#line 799
            bytes = safe_read(fd, buf, count);
            }
          }
        }
      }
    }
  }
#line 803
  return (bytes);
}
}
#line 812 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
size_t blocking_write(int fd , void const   *buf , size_t count ) 
{ 
  size_t bytes ;
  size_t tmp ;
  int flags ;
  int tmp___0 ;
  char const   *buffer___1 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 815
  tmp = full_write(fd, buf, count);
#line 815
  bytes = tmp;
  }
#line 818
  if (bytes < count) {
    {
#line 818
    tmp___3 = __errno_location();
    }
#line 818
    if (*tmp___3 == 11) {
      {
#line 820
      tmp___0 = rpl_fcntl(fd, 3);
#line 820
      flags = tmp___0;
      }
#line 821
      if (0 <= flags) {
#line 821
        if (flags & 2048) {
          {
#line 821
          tmp___2 = rpl_fcntl(fd, 4, flags & -2049);
          }
#line 821
          if (tmp___2 != -1) {
            {
#line 824
            buffer___1 = (char const   *)buf;
#line 825
            tmp___1 = full_write(fd, (void const   *)(buffer___1 + bytes), count - bytes);
#line 825
            bytes += tmp___1;
            }
          }
        }
      }
    }
  }
#line 830
  return (bytes);
}
}
#line 835 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int set_file_atime(int fd , int parentfd , char const   *file , struct timespec atime ) 
{ 
  struct timespec ts[2] ;
  int tmp ;

  {
  {
#line 839
  ts[0] = atime;
#line 840
  ts[1].tv_nsec = (1L << 30) - 2L;
#line 841
  tmp = fdutimensat(fd, parentfd, file, (struct timespec  const  *)(ts), fstatat_flags);
  }
#line 841
  return (tmp);
}
}
#line 861 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static struct wd *wd  ;
#line 864 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static size_t wd_count  ;
#line 867 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static size_t wd_alloc  ;
#line 877 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static int wdcache[16]  ;
#line 880 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static size_t wdcache_count  ;
#line 882 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int chdir_count(void) 
{ 


  {
#line 885
  if (wd_count == 0UL) {
#line 886
    return ((int )wd_count);
  }
#line 887
  return ((int )(wd_count - 1UL));
}
}
#line 892 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int chdir_arg(char const   *dir ) 
{ 
  char *absdir ;
  void *tmp ;
  namebuf_t nbuf ;
  namebuf_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 897
  if (wd_count == wd_alloc) {
#line 899
    if (wd_alloc == 0UL) {
#line 900
      wd_alloc = (size_t )2;
    }
    {
#line 901
    tmp = x2nrealloc((void *)wd, & wd_alloc, sizeof(*wd));
#line 901
    wd = (struct wd *)tmp;
    }
#line 903
    if (! wd_count) {
      {
#line 905
      (wd + wd_count)->name = ".";
#line 906
      (wd + wd_count)->abspath = xgetcwd();
#line 907
      (wd + wd_count)->fd = -100;
#line 908
      wd_count ++;
      }
    }
  }
#line 914
  if (*(dir + 0)) {
    {
#line 916
    while (1) {
      while_continue: /* CIL Label */ ;
#line 916
      if ((int const   )*(dir + 0) == 46) {
#line 916
        if (! ((int const   )*(dir + 1) == 47)) {
#line 916
          goto while_break;
        }
      } else {
#line 916
        goto while_break;
      }
#line 917
      dir += 2;
      {
#line 917
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 917
        if (! ((int const   )*dir == 47)) {
#line 917
          goto while_break___0;
        }
#line 918
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 917
        dir ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 919
    if (! *(dir + ((int const   )*(dir + 0) == 46))) {
#line 920
      return ((int )(wd_count - 1UL));
    }
  }
#line 926
  if ((int const   )*(dir + 0) == 47) {
    {
#line 927
    absdir = xstrdup(dir);
    }
  } else
#line 928
  if ((wd + (wd_count - 1UL))->abspath) {
    {
#line 930
    tmp___0 = namebuf_create((char const   *)(wd + (wd_count - 1UL))->abspath);
#line 930
    nbuf = tmp___0;
#line 931
    namebuf_add_dir(nbuf, dir);
#line 932
    absdir = namebuf_finish(nbuf);
    }
  } else {
#line 935
    absdir = (char *)0;
  }
#line 937
  (wd + wd_count)->name = dir;
#line 938
  (wd + wd_count)->abspath = absdir;
#line 939
  (wd + wd_count)->fd = 0;
#line 940
  tmp___1 = wd_count;
#line 940
  wd_count ++;
#line 940
  return ((int )tmp___1);
}
}
#line 950 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
int chdir_fd  =    -100;
#line 957 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void chdir_do(int i ) 
{ 
  struct wd *curr ;
  int fd ;
  size_t tmp ;
  struct wd *stale ;
  int tmp___0 ;
  size_t ci ;
  int prev ;
  int cur ;

  {
#line 960
  if (chdir_current != i) {
#line 962
    curr = wd + i;
#line 963
    fd = curr->fd;
#line 965
    if (! fd) {
#line 967
      if (! ((int const   )*(curr->name + 0) == 47)) {
        {
#line 968
        chdir_do(i - 1);
        }
      }
      {
#line 969
      fd = openat(chdir_fd, curr->name, open_searchdir_flags & -131073);
      }
#line 971
      if (fd < 0) {
        {
#line 972
        open_fatal(curr->name);
        }
      }
#line 974
      curr->fd = fd;
#line 978
      if (wdcache_count < 16UL) {
#line 979
        tmp = wdcache_count;
#line 979
        wdcache_count ++;
#line 979
        wdcache[tmp] = i;
      } else {
        {
#line 982
        stale = wd + wdcache[15];
#line 983
        tmp___0 = close(stale->fd);
        }
#line 983
        if (tmp___0 != 0) {
          {
#line 984
          close_diag(stale->name);
          }
        }
#line 985
        stale->fd = 0;
#line 986
        wdcache[15] = i;
      }
    }
#line 990
    if (0 < fd) {
#line 995
      prev = wdcache[0];
#line 996
      ci = (size_t )1;
      {
#line 996
      while (1) {
        while_continue: /* CIL Label */ ;
#line 996
        if (! (prev != i)) {
#line 996
          goto while_break;
        }
#line 998
        cur = wdcache[ci];
#line 999
        wdcache[ci] = prev;
#line 1000
        if (cur == i) {
#line 1001
          goto while_break;
        }
#line 1002
        prev = cur;
#line 996
        ci ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 1004
      wdcache[0] = i;
    }
#line 1007
    chdir_current = i;
#line 1008
    chdir_fd = fd;
  }
#line 1010
  return;
}
}
#line 1012 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char const   *tar_dirname(void) 
{ 


  {
#line 1015
  return ((wd + chdir_current)->name);
}
}
#line 1030 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static char *cwd  ;
#line 1025 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static char const   *tar_getcdpath(int idx ) 
{ 


  {
#line 1028
  if (! wd) {
#line 1031
    if (! cwd) {
      {
#line 1032
      cwd = xgetcwd();
      }
    }
#line 1033
    return ((char const   *)cwd);
  }
#line 1035
  return ((char const   *)(wd + idx)->abspath);
}
}
#line 1038 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void close_diag(char const   *name ) 
{ 


  {
#line 1041
  if (ignore_failed_read_option) {
    {
#line 1042
    close_warn(name);
    }
  } else {
    {
#line 1044
    close_error(name);
    }
  }
#line 1045
  return;
}
}
#line 1047 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void open_diag(char const   *name ) 
{ 


  {
#line 1050
  if (ignore_failed_read_option) {
    {
#line 1051
    open_warn(name);
    }
  } else {
    {
#line 1053
    open_error(name);
    }
  }
#line 1054
  return;
}
}
#line 1056 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void read_diag_details(char const   *name , off_t offset , size_t size ) 
{ 


  {
#line 1059
  if (ignore_failed_read_option) {
    {
#line 1060
    read_warn_details(name, offset, size);
    }
  } else {
    {
#line 1062
    read_error_details(name, offset, size);
    }
  }
#line 1063
  return;
}
}
#line 1065 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void readlink_diag(char const   *name ) 
{ 


  {
#line 1068
  if (ignore_failed_read_option) {
    {
#line 1069
    readlink_warn(name);
    }
  } else {
    {
#line 1071
    readlink_error(name);
    }
  }
#line 1072
  return;
}
}
#line 1074 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void savedir_diag(char const   *name ) 
{ 


  {
#line 1077
  if (ignore_failed_read_option) {
    {
#line 1078
    savedir_warn(name);
    }
  } else {
    {
#line 1080
    savedir_error(name);
    }
  }
#line 1081
  return;
}
}
#line 1083 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void seek_diag_details(char const   *name , off_t offset ) 
{ 


  {
#line 1086
  if (ignore_failed_read_option) {
    {
#line 1087
    seek_warn_details(name, offset);
    }
  } else {
    {
#line 1089
    seek_error_details(name, offset);
    }
  }
#line 1090
  return;
}
}
#line 1092 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void stat_diag(char const   *name ) 
{ 


  {
#line 1095
  if (ignore_failed_read_option) {
    {
#line 1096
    stat_warn(name);
    }
  } else {
    {
#line 1098
    stat_error(name);
    }
  }
#line 1099
  return;
}
}
#line 1101 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void file_removed_diag(char const   *name , _Bool top_level , void (*diagfn)(char const   *name ) ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 1105
  if (! top_level) {
    {
#line 1105
    tmp___1 = __errno_location();
    }
#line 1105
    if (*tmp___1 == 2) {
      {
#line 1107
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1107
        if (warning_option & 64) {
          {
#line 1107
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1107
            if (error_hook) {
              {
#line 1107
              (*error_hook)();
              }
            }
            {
#line 1107
            tmp = quotearg_colon(name);
#line 1107
            tmp___0 = gettext("%s: File removed before we read it");
#line 1107
            error(0, 0, (char const   *)tmp___0, tmp);
            }
#line 1107
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 1107
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1110
      set_exit_status(1);
      }
    } else {
      {
#line 1113
      (*diagfn)(name);
      }
    }
  } else {
    {
#line 1113
    (*diagfn)(name);
    }
  }
#line 1114
  return;
}
}
#line 1117 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
pid_t xfork(void) 
{ 
  pid_t p ;
  __pid_t tmp ;
  char *tmp___0 ;

  {
  {
#line 1120
  tmp = fork();
#line 1120
  p = tmp;
  }
#line 1121
  if (p == -1) {
    {
#line 1122
    tmp___0 = gettext("child process");
#line 1122
    call_arg_fatal("fork", (char const   *)tmp___0);
    }
  }
#line 1123
  return (p);
}
}
#line 1127 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void xpipe(int *fd ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1130
  tmp___0 = pipe(fd);
  }
#line 1130
  if (tmp___0 < 0) {
    {
#line 1131
    tmp = gettext("interprocess channel");
#line 1131
    call_arg_fatal("pipe", (char const   *)tmp);
    }
  }
#line 1132
  return;
}
}
#line 1139 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
__inline static void *ptr_align(void *ptr , size_t alignment ) 
{ 
  char *p0 ;
  char *p1 ;

  {
#line 1142
  p0 = (char *)ptr;
#line 1143
  p1 = (p0 + alignment) - 1;
#line 1144
  return ((void *)(p1 - (size_t )p1 % alignment));
}
}
#line 1150 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void *page_aligned_alloc(void **ptr , size_t size ) 
{ 
  size_t alignment ;
  int tmp ;
  size_t size1 ;
  void *tmp___0 ;

  {
  {
#line 1153
  tmp = getpagesize();
#line 1153
  alignment = (size_t )tmp;
#line 1154
  size1 = size + alignment;
  }
#line 1155
  if (size1 < size) {
    {
#line 1156
    xalloc_die();
    }
  }
  {
#line 1157
  *ptr = xmalloc(size1);
#line 1158
  tmp___0 = ptr_align(*ptr, alignment);
  }
#line 1158
  return (tmp___0);
}
}
#line 1170 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
namebuf_t namebuf_create(char const   *dir ) 
{ 
  namebuf_t buf ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1173
  tmp = xmalloc(sizeof(*buf));
#line 1173
  buf = (namebuf_t )tmp;
#line 1174
  tmp___0 = strlen(dir);
#line 1174
  buf->buffer_size = tmp___0 + 2UL;
#line 1175
  tmp___1 = xmalloc(buf->buffer_size);
#line 1175
  buf->buffer = (char *)tmp___1;
#line 1176
  strcpy((char */* __restrict  */)buf->buffer, (char const   */* __restrict  */)dir);
#line 1177
  buf->dir_length = strlen((char const   *)buf->buffer);
  }
#line 1178
  if (! ((int )*(buf->buffer + (buf->dir_length - 1UL)) == 47)) {
#line 1179
    tmp___2 = buf->dir_length;
#line 1179
    (buf->dir_length) ++;
#line 1179
    *(buf->buffer + tmp___2) = (char )'/';
  }
#line 1180
  return (buf);
}
}
#line 1183 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
void namebuf_free(namebuf_t buf ) 
{ 


  {
  {
#line 1186
  free((void *)buf->buffer);
#line 1187
  free((void *)buf);
  }
#line 1188
  return;
}
}
#line 1190 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char *namebuf_name(namebuf_t buf , char const   *name ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1193
  tmp = strlen(name);
#line 1193
  len = tmp;
  }
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! ((buf->dir_length + len) + 1UL >= buf->buffer_size)) {
#line 1194
      goto while_break;
    }
    {
#line 1195
    tmp___0 = x2realloc((void *)buf->buffer, & buf->buffer_size);
#line 1195
    buf->buffer = (char *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1196
  strcpy((char */* __restrict  */)(buf->buffer + buf->dir_length), (char const   */* __restrict  */)name);
  }
#line 1197
  return (buf->buffer);
}
}
#line 1203 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static char dirsep[2]  = {      (char )'/',      (char)0};
#line 1200 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static void namebuf_add_dir(namebuf_t buf , char const   *name ) 
{ 
  size_t tmp ;

  {
#line 1204
  if (! ((int )*(buf->buffer + (buf->dir_length - 1UL)) == 47)) {
    {
#line 1206
    namebuf_name(buf, (char const   *)(dirsep));
#line 1207
    (buf->dir_length) ++;
    }
  }
  {
#line 1209
  namebuf_name(buf, name);
#line 1210
  tmp = strlen(name);
#line 1210
  buf->dir_length += tmp;
  }
#line 1211
  return;
}
}
#line 1213 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
static char *namebuf_finish(namebuf_t buf ) 
{ 
  char *res ;

  {
#line 1216
  res = buf->buffer;
#line 1218
  if ((int )*(buf->buffer + (buf->dir_length - 1UL)) == 47) {
#line 1219
    *(buf->buffer + buf->dir_length) = (char)0;
  }
  {
#line 1220
  free((void *)buf);
  }
#line 1221
  return (res);
}
}
#line 1230 "/home/khheo/project/benchmark/tar-1.29/src/misc.c"
char *tar_savedir(char const   *name , int must_exist ) 
{ 
  char *ret ;
  DIR *dir ;
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 1233
  ret = (char *)((void *)0);
#line 1234
  dir = (DIR *)((void *)0);
#line 1235
  tmp = openat(chdir_fd, name, open_read_flags | 65536);
#line 1235
  fd = tmp;
  }
#line 1236
  if (fd < 0) {
#line 1238
    if (! must_exist) {
      {
#line 1238
      tmp___0 = __errno_location();
      }
#line 1238
      if (*tmp___0 == 2) {
#line 1239
        return ((char *)((void *)0));
      }
    }
    {
#line 1240
    open_error(name);
    }
  } else {
    {
#line 1242
    dir = fdopendir(fd);
    }
#line 1242
    if (dir) {
      {
#line 1242
      ret = streamsavedir(dir, (enum savedir_option )savedir_sort_order);
      }
#line 1242
      if (! ret) {
        {
#line 1244
        savedir_error(name);
        }
      }
    } else {
      {
#line 1244
      savedir_error(name);
      }
    }
  }
#line 1246
  if (dir) {
    {
#line 1246
    tmp___1 = closedir(dir);
#line 1246
    tmp___4 = tmp___1 != 0;
    }
  } else {
#line 1246
    if (0 <= fd) {
      {
#line 1246
      tmp___2 = close(fd);
      }
#line 1246
      if (tmp___2 != 0) {
#line 1246
        tmp___3 = 1;
      } else {
#line 1246
        tmp___3 = 0;
      }
    } else {
#line 1246
      tmp___3 = 0;
    }
#line 1246
    tmp___4 = tmp___3;
  }
#line 1246
  if (tmp___4) {
    {
#line 1247
    savedir_error(name);
    }
  }
#line 1249
  return (ret);
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 969
int owner_map_translate(uid_t uid , uid_t *new_uid , char const   **new_name ) ;
#line 971
int group_map_translate(gid_t gid , gid_t *new_gid , char const   **new_name ) ;
#line 974
#pragma GCC diagnostic pop
#line 33 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static size_t map_hash(void const   *entry___0 , size_t nbuckets ) 
{ 
  struct mapentry  const  *map ;

  {
#line 36
  map = (struct mapentry  const  *)entry___0;
#line 37
  return ((size_t )(map->orig_id % (unsigned long const   )nbuckets));
}
}
#line 40 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static _Bool map_compare(void const   *entry1 , void const   *entry2 ) 
{ 
  struct mapentry  const  *map1 ;
  struct mapentry  const  *map2 ;

  {
#line 43
  map1 = (struct mapentry  const  *)entry1;
#line 44
  map2 = (struct mapentry  const  *)entry2;
#line 45
  return ((_Bool )(map1->orig_id == map2->orig_id));
}
}
#line 48 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static int parse_id(uintmax_t *retval , char const   *arg___0 , char const   *what ,
                    uintmax_t maxval , char const   *file , unsigned int line ) 
{ 
  uintmax_t v ;
  char *p ;
  int *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 56
  tmp = __errno_location();
#line 56
  *tmp = 0;
#line 57
  v = strtoumax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& p),
                10);
  }
#line 58
  if (*p) {
    {
#line 60
    tmp___0 = gettext("%s:%u: invalid %s: %s");
#line 60
    error(0, 0, (char const   *)tmp___0, file, line, what, arg___0);
    }
#line 61
    return (-1);
  } else {
    {
#line 58
    tmp___1 = __errno_location();
    }
#line 58
    if (*tmp___1) {
      {
#line 60
      tmp___0 = gettext("%s:%u: invalid %s: %s");
#line 60
      error(0, 0, (char const   *)tmp___0, file, line, what, arg___0);
      }
#line 61
      return (-1);
    }
  }
#line 63
  if (v > maxval) {
    {
#line 65
    tmp___2 = gettext("%s:%u: %s out of range: %s");
#line 65
    error(0, 0, (char const   *)tmp___2, file, line, what, arg___0);
    }
#line 66
    return (-1);
  }
#line 68
  *retval = v;
#line 69
  return (0);
}
}
#line 72 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static void map_read(Hash_table **ptab , char const   *file , uintmax_t (*name_to_id)(char const   * ) ,
                     char const   *what , uintmax_t maxval ) 
{ 
  FILE *fp ;
  char *buf ;
  size_t bufsize ;
  ssize_t n ;
  struct wordsplit ws ;
  int wsopt ;
  unsigned int line ;
  int err ;
  struct mapentry *ent ;
  uintmax_t orig_id ;
  uintmax_t new_id ;
  char *name ;
  char *colon ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  Hash_table *tmp___11 ;
  void *tmp___12 ;
  char *tmp___13 ;

  {
  {
#line 78
  buf = (char *)((void *)0);
#line 79
  bufsize = (size_t )0;
#line 84
  err = 0;
#line 86
  fp = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 87
  if (! fp) {
    {
#line 88
    open_fatal(file);
    }
  }
#line 90
  ws.ws_comment = "#";
#line 91
  wsopt = 36420;
#line 93
  line = 0U;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 94
    n = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                (FILE */* __restrict  */)fp);
    }
#line 94
    if (! (n > 0L)) {
#line 94
      goto while_break;
    }
    {
#line 98
    name = (char *)((void *)0);
#line 101
    line ++;
#line 102
    tmp___1 = wordsplit((char const   *)buf, & ws, wsopt);
    }
#line 102
    if (tmp___1) {
      {
#line 103
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 103
        if (error_hook) {
          {
#line 103
          (*error_hook)();
          }
        }
        {
#line 103
        tmp = wordsplit_strerror(& ws);
#line 103
        tmp___0 = gettext("%s:%u: cannot split line: %s");
#line 103
        error(0, 0, (char const   *)tmp___0, file, line, tmp);
#line 103
        fatal_exit();
        }
#line 103
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 105
    wsopt |= 8;
#line 106
    if (ws.ws_wordc == 0UL) {
#line 107
      goto while_continue;
    }
#line 108
    if (ws.ws_wordc != 2UL) {
      {
#line 110
      tmp___2 = gettext("%s:%u: malformed line");
#line 110
      error(0, 0, (char const   *)tmp___2, file, line);
#line 111
      err = 1;
      }
#line 112
      goto while_continue;
    }
#line 115
    if ((int )*(*(ws.ws_wordv + 0) + 0) == 43) {
      {
#line 117
      tmp___3 = parse_id(& orig_id, (char const   *)(*(ws.ws_wordv + 0) + 1), what,
                         maxval, file, line);
      }
#line 117
      if (tmp___3) {
#line 119
        err = 1;
#line 120
        goto while_continue;
      }
    } else
#line 123
    if (name_to_id) {
      {
#line 125
      orig_id = (*name_to_id)((char const   *)*(ws.ws_wordv + 0));
      }
#line 126
      if (orig_id == 0xffffffffffffffffUL) {
        {
#line 128
        tmp___4 = gettext("%s:%u: can\'t obtain %s of %s");
#line 128
        error(0, 0, (char const   *)tmp___4, file, line, what, *(ws.ws_wordv + 0));
#line 130
        err = 1;
        }
#line 131
        goto while_continue;
      }
    }
    {
#line 135
    colon = strchr((char const   *)*(ws.ws_wordv + 1), ':');
    }
#line 136
    if (colon) {
#line 138
      if ((unsigned long )colon > (unsigned long )*(ws.ws_wordv + 1)) {
#line 139
        name = *(ws.ws_wordv + 1);
      }
      {
#line 140
      tmp___5 = colon;
#line 140
      colon ++;
#line 140
      *tmp___5 = (char)0;
#line 141
      tmp___6 = parse_id(& new_id, (char const   *)colon, what, maxval, file, line);
      }
#line 141
      if (tmp___6) {
#line 143
        err = 1;
#line 144
        goto while_continue;
      }
    } else
#line 147
    if ((int )*(*(ws.ws_wordv + 1) + 0) == 43) {
      {
#line 149
      tmp___7 = parse_id(& new_id, (char const   *)*(ws.ws_wordv + 1), what, maxval,
                         file, line);
      }
#line 149
      if (tmp___7) {
#line 151
        err = 1;
#line 152
        goto while_continue;
      }
    } else {
      {
#line 157
      name = *(ws.ws_wordv + 1);
#line 158
      new_id = (*name_to_id)((char const   *)*(ws.ws_wordv + 1));
      }
#line 159
      if (new_id == 0xffffffffffffffffUL) {
        {
#line 161
        tmp___8 = gettext("%s:%u: can\'t obtain %s of %s");
#line 161
        error(0, 0, (char const   *)tmp___8, file, line, what, *(ws.ws_wordv + 1));
#line 163
        err = 1;
        }
#line 164
        goto while_continue;
      }
    }
    {
#line 168
    tmp___9 = xmalloc(sizeof(*ent));
#line 168
    ent = (struct mapentry *)tmp___9;
#line 169
    ent->orig_id = orig_id;
#line 170
    ent->new_id = new_id;
    }
#line 171
    if (name) {
      {
#line 171
      tmp___10 = xstrdup((char const   *)name);
#line 171
      ent->new_name = tmp___10;
      }
    } else {
#line 171
      ent->new_name = (char *)((void *)0);
    }
#line 173
    if (*ptab) {
#line 173
      goto _L;
    } else {
      {
#line 173
      tmp___11 = hash_initialize((size_t )0, (Hash_tuning const   *)0, & map_hash,
                                 & map_compare, (void (*)(void * ))0);
#line 173
      *ptab = tmp___11;
      }
#line 173
      if (tmp___11) {
        _L: /* CIL Label */ 
        {
#line 173
        tmp___12 = hash_insert(*ptab, (void const   *)ent);
        }
#line 173
        if (! tmp___12) {
          {
#line 176
          xalloc_die();
          }
        }
      } else {
        {
#line 176
        xalloc_die();
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  if (wsopt & 8) {
    {
#line 179
    wordsplit_free(& ws);
    }
  }
  {
#line 180
  fclose(fp);
  }
#line 181
  if (err) {
    {
#line 182
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 182
      if (error_hook) {
        {
#line 182
        (*error_hook)();
        }
      }
      {
#line 182
      tmp___13 = gettext("errors reading map file");
#line 182
      error(0, 0, (char const   *)tmp___13);
#line 182
      fatal_exit();
      }
#line 182
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 183
  return;
}
}
#line 187 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static Hash_table *owner_map  ;
#line 189 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static uintmax_t name_to_uid(char const   *name ) 
{ 
  struct passwd *pw ;
  struct passwd *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 192
  tmp = getpwnam(name);
#line 192
  pw = tmp;
  }
#line 193
  if (pw) {
#line 193
    tmp___0 = (unsigned long )pw->pw_uid;
  } else {
#line 193
    tmp___0 = 0xffffffffffffffffUL;
  }
#line 193
  return (tmp___0);
}
}
#line 196 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
void owner_map_read(char const   *file ) 
{ 


  {
  {
#line 199
  map_read(& owner_map, file, & name_to_uid, "UID", (uintmax_t )((uid_t )-1));
  }
#line 200
  return;
}
}
#line 202 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
int owner_map_translate(uid_t uid , uid_t *new_uid , char const   **new_name ) 
{ 
  int rc ;
  struct mapentry ent ;
  struct mapentry *res ;
  void *tmp ;

  {
#line 205
  rc = 1;
#line 207
  if (owner_map) {
    {
#line 211
    ent.orig_id = (uintmax_t )uid;
#line 212
    tmp = hash_lookup((Hash_table const   *)owner_map, (void const   *)(& ent));
#line 212
    res = (struct mapentry *)tmp;
    }
#line 213
    if (res) {
#line 215
      *new_uid = (uid_t )res->new_id;
#line 216
      *new_name = (char const   *)res->new_name;
#line 217
      return (0);
    }
  }
#line 221
  if (owner_option != 4294967295U) {
#line 223
    *new_uid = owner_option;
#line 224
    rc = 0;
  }
#line 226
  if (owner_name_option) {
#line 228
    *new_name = owner_name_option;
#line 229
    rc = 0;
  }
#line 232
  return (rc);
}
}
#line 237 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static Hash_table *group_map  ;
#line 239 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
static uintmax_t name_to_gid(char const   *name ) 
{ 
  struct group___0 *gr ;
  struct group___0 *tmp ;
  unsigned long tmp___0 ;

  {
  {
#line 242
  tmp = getgrnam(name);
#line 242
  gr = tmp;
  }
#line 243
  if (gr) {
#line 243
    tmp___0 = (unsigned long )gr->gr_gid;
  } else {
#line 243
    tmp___0 = 0xffffffffffffffffUL;
  }
#line 243
  return (tmp___0);
}
}
#line 246 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
void group_map_read(char const   *file ) 
{ 


  {
  {
#line 249
  map_read(& group_map, file, & name_to_gid, "GID", (uintmax_t )((gid_t )-1));
  }
#line 250
  return;
}
}
#line 252 "/home/khheo/project/benchmark/tar-1.29/src/map.c"
int group_map_translate(gid_t gid , gid_t *new_gid , char const   **new_name ) 
{ 
  int rc ;
  struct mapentry ent ;
  struct mapentry *res ;
  void *tmp ;

  {
#line 255
  rc = 1;
#line 257
  if (group_map) {
    {
#line 261
    ent.orig_id = (uintmax_t )gid;
#line 262
    tmp = hash_lookup((Hash_table const   *)group_map, (void const   *)(& ent));
#line 262
    res = (struct mapentry *)tmp;
    }
#line 263
    if (res) {
#line 265
      *new_gid = (gid_t )res->new_id;
#line 266
      *new_name = (char const   *)res->new_name;
#line 267
      return (0);
    }
  }
#line 271
  if (group_option != 4294967295U) {
#line 273
    *new_gid = group_option;
#line 274
    rc = 0;
  }
#line 276
  if (group_name_option) {
#line 278
    *new_name = group_name_option;
#line 279
    rc = 0;
  }
#line 282
  return (rc);
}
}
#line 119 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 438
char *volume_label ;
#line 445
char *drop_volume_label_suffix(char const   *label ) ;
#line 465
off_t seek_archive(off_t size ) ;
#line 562
void list_dumpdir(char *buffer___1 , size_t size ) ;
#line 565
size_t dumpdir_size(char const   *p ) ;
#line 566
_Bool is_dumpdir(struct tar_stat_info *stat_info ) ;
#line 592 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
union block *current_header  ;
#line 593 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum archive_format current_format  ;
#line 594 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
size_t recent_long_name_blocks  ;
#line 595 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
size_t recent_long_link_blocks  ;
#line 606
uintmax_t uintmax_from_header(char const   *p , size_t s ) ;
#line 610
void print_for_mkdir(char *dirname , int length , mode_t mode ) ;
#line 611
void print_header(struct tar_stat_info *st , union block *blk , off_t block_ordinal ) ;
#line 617
enum read_header tar_checksum(union block *header , _Bool silent ) ;
#line 819
void xheader_decode(struct tar_stat_info *st ) ;
#line 820
void xheader_decode_global(struct xheader *xhdr ) ;
#line 823
void xheader_read(struct xheader *xhdr , union block *p , off_t size ) ;
#line 837
void xheader_xattr_init(struct tar_stat_info *st ) ;
#line 974
#pragma GCC diagnostic pop
#line 31 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
union block *recent_long_name  ;
#line 32 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
union block *recent_long_link  ;
#line 35 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static union block *recent_global_header  ;
#line 45
static gid_t gid_from_header(char const   *p , size_t s ) ;
#line 46
static int major_from_header(char const   *p , size_t s ) ;
#line 47
static int minor_from_header(char const   *p , size_t s ) ;
#line 48
static mode_t mode_from_header(char const   *p , size_t s , _Bool *hbits ) ;
#line 49
static time_t time_from_header(char const   *p , size_t s ) ;
#line 50
static uid_t uid_from_header(char const   *p , size_t s ) ;
#line 51
static intmax_t from_header(char const   *where0 , size_t digs , char const   *type ,
                            intmax_t minval , uintmax_t maxval , _Bool octal_only ,
                            _Bool silent ) ;
#line 55 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static char const   base_64_digits[64]  = 
#line 55
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 66 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static char base64_map[256]  ;
#line 68 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static void base64_init(void) 
{ 
  int i ;

  {
  {
#line 72
  memset((void *)(base64_map), 64, sizeof(base64_map));
#line 73
  i = 0;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (i < 64)) {
#line 73
      goto while_break;
    }
#line 74
    base64_map[(int )base_64_digits[i]] = (char )i;
#line 73
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  return;
}
}
#line 77 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static char *decode_xform(char *file_name___0 , void *data ) 
{ 
  int type ;
  size_t prefix_len ;
  size_t tmp ;

  {
#line 80
  type = *((int *)data);
  {
#line 84
  if (type == 4) {
#line 84
    goto case_4;
  }
#line 92
  if (type == 2) {
#line 92
    goto case_2;
  }
#line 96
  if (type == 1) {
#line 96
    goto case_1;
  }
#line 82
  goto switch_break;
  case_4: /* CIL Label */ 
#line 90
  return (file_name___0);
  case_2: /* CIL Label */ 
  {
#line 93
  file_name___0 = safer_name_suffix((char const   *)file_name___0, (_Bool)1, absolute_names_option);
  }
#line 94
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 97
  file_name___0 = safer_name_suffix((char const   *)file_name___0, (_Bool)0, absolute_names_option);
  }
#line 98
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 101
  if (strip_name_components) {
    {
#line 103
    tmp = stripped_prefix_len((char const   *)file_name___0, strip_name_components);
#line 103
    prefix_len = tmp;
    }
#line 105
    if (prefix_len == 0xffffffffffffffffUL) {
      {
#line 106
      prefix_len = strlen((char const   *)file_name___0);
      }
    }
#line 107
    file_name___0 += prefix_len;
  }
#line 109
  return (file_name___0);
}
}
#line 112 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static _Bool transform_member_name(char **pinput , int type ) 
{ 
  _Bool tmp ;

  {
  {
#line 115
  tmp = transform_name_fp(pinput, type, & decode_xform, (void *)(& type));
  }
#line 115
  return (tmp);
}
}
#line 118 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static void enforce_one_top_level(char **pfile_name ) 
{ 
  char *file_name___0 ;
  char *p ;
  int pos ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 121
  file_name___0 = *pfile_name;
#line 124
  p = file_name___0;
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (*p) {
#line 124
      if (! ((int )*p == 47)) {
#line 124
        if (! ((int )*p == 46)) {
#line 124
          goto while_break;
        }
      }
    } else {
#line 124
      goto while_break;
    }
#line 124
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  if (*p) {
    {
#line 129
    tmp = strlen((char const   *)one_top_level_dir);
#line 129
    pos = (int )tmp;
#line 130
    tmp___0 = strncmp((char const   *)p, (char const   *)one_top_level_dir, (size_t )pos);
    }
#line 130
    if (tmp___0 == 0) {
#line 132
      if ((int )*(p + pos) == 47) {
#line 133
        return;
      } else
#line 132
      if ((int )*(p + pos) == 0) {
#line 133
        return;
      }
    }
    {
#line 136
    *pfile_name = make_file_name((char const   *)one_top_level_dir, (char const   *)file_name___0);
#line 137
    normalize_filename_x(*pfile_name);
    }
  } else {
    {
#line 140
    *pfile_name = xstrdup((char const   *)one_top_level_dir);
    }
  }
  {
#line 141
  free((void *)file_name___0);
  }
#line 142
  return;
}
}
#line 144 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void transform_stat_info(int typeflag , struct tar_stat_info *stat_info ) 
{ 


  {
#line 147
  if (typeflag == 86) {
#line 149
    return;
  }
  {
#line 151
  transform_member_name(& stat_info->file_name, 1);
  }
  {
#line 154
  if (typeflag == 50) {
#line 154
    goto case_50;
  }
#line 158
  if (typeflag == 49) {
#line 158
    goto case_49;
  }
#line 152
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 155
  transform_member_name(& stat_info->link_name, 4);
  }
#line 156
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 159
  transform_member_name(& stat_info->link_name, 2);
  }
  switch_break: /* CIL Label */ ;
  }
#line 162
  if (one_top_level_option) {
    {
#line 163
    enforce_one_top_level(& current_stat_info.file_name);
    }
  }
#line 164
  return;
}
}
#line 167 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void read_and(void (*do_something)(void) ) 
{ 
  enum read_header status ;
  enum read_header prev_status ;
  struct timespec mtime ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  _Bool tmp___3 ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char buf___0[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char buf___1[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char buf___2[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t block_ordinal ;
  off_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  _Bool tmp___18 ;

  {
  {
#line 170
  status = (enum read_header )0;
#line 174
  base64_init();
#line 175
  name_gather();
#line 177
  open_archive((enum access_mode )0);
  }
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 180
    prev_status = status;
#line 181
    tar_stat_destroy(& current_stat_info);
#line 183
    status = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
    }
    {
#line 188
    if ((unsigned int )status == 2U) {
#line 188
      goto case_2;
    }
#line 188
    if ((unsigned int )status == 0U) {
#line 188
      goto case_2;
    }
#line 191
    if ((unsigned int )status == 1U) {
#line 191
      goto case_1;
    }
#line 233
    if ((unsigned int )status == 3U) {
#line 233
      goto case_3;
    }
#line 259
    if ((unsigned int )status == 4U) {
#line 259
      goto case_4;
    }
#line 268
    if ((unsigned int )status == 5U) {
#line 268
      goto case_5;
    }
#line 185
    goto switch_break;
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 189
    abort();
    }
    case_1: /* CIL Label */ 
    {
#line 195
    decode_header(current_header, & current_stat_info, & current_format, 1);
#line 197
    tmp___1 = name_match((char const   *)current_stat_info.file_name);
    }
#line 197
    if (tmp___1) {
#line 197
      if (0L <= newer_mtime_option.tv_nsec) {
        {
#line 197
        mtime.tv_sec = time_from_header((char const   *)(current_header->header.mtime),
                                        sizeof(current_header->header.mtime));
#line 197
        mtime.tv_nsec = (__syscall_slong_t )0;
#line 197
        current_stat_info.mtime = mtime;
#line 197
        tmp___2 = timespec_cmp(current_stat_info.mtime, newer_mtime_option);
        }
#line 197
        if (tmp___2 < (int __attribute__((__pure__))  )0) {
#line 197
          goto _L;
        } else {
#line 197
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 197
        tmp___3 = excluded_name((char const   *)current_stat_info.file_name, current_stat_info.parent);
        }
#line 197
        if (tmp___3) {
          _L: /* CIL Label */ 
          {
#line 214
          if ((int )current_header->header.typeflag == 77) {
#line 214
            goto case_77;
          }
#line 214
          if ((int )current_header->header.typeflag == 86) {
#line 214
            goto case_77;
          }
#line 217
          if ((int )current_header->header.typeflag == 53) {
#line 217
            goto case_53;
          }
#line 222
          goto switch_default;
          case_77: /* CIL Label */ 
          case_86: /* CIL Label */ 
#line 215
          goto switch_break___0;
          case_53: /* CIL Label */ 
#line 218
          if (show_omitted_dirs_option) {
            {
#line 219
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 219
              if (error_hook) {
                {
#line 219
                (*error_hook)();
                }
              }
              {
#line 219
              tmp = quotearg_colon((char const   *)current_stat_info.file_name);
#line 219
              tmp___0 = gettext("%s: Omitting");
#line 219
              error(0, 0, (char const   *)tmp___0, tmp);
              }
#line 219
              goto while_break___0;
            }
            while_break___0: /* CIL Label */ ;
            }
          }
          switch_default: /* CIL Label */ 
          {
#line 223
          skip_member();
          }
#line 224
          goto __Cont;
          switch_break___0: /* CIL Label */ ;
          }
        }
      }
    } else {
#line 197
      goto _L;
    }
    {
#line 228
    transform_stat_info((int )current_header->header.typeflag, & current_stat_info);
#line 230
    (*do_something)();
    }
#line 231
    goto __Cont;
    case_3: /* CIL Label */ 
#line 234
    if (block_number_option) {
      {
#line 237
      tmp___4 = current_block_ordinal();
#line 237
      tmp___5 = umaxtostr((uintmax_t )tmp___4, buf);
#line 237
      tmp___6 = gettext("block %s: ** Block of NULs **\n");
#line 237
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___6,
              tmp___5);
      }
    }
    {
#line 241
    set_next_block_after(current_header);
    }
#line 243
    if (! ignore_zeros_option) {
      {
#line 247
      status = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
      }
#line 249
      if ((unsigned int )status == 3U) {
#line 250
        goto switch_break;
      }
      {
#line 251
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 251
        if (warning_option & 1) {
          {
#line 251
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 251
            if (error_hook) {
              {
#line 251
              (*error_hook)();
              }
            }
            {
#line 251
            tmp___7 = current_block_ordinal();
#line 251
            tmp___8 = umaxtostr((uintmax_t )tmp___7, buf___0);
#line 251
            tmp___9 = gettext("A lone zero block at %s");
#line 251
            error(0, 0, (char const   *)tmp___9, tmp___8);
            }
#line 251
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
#line 251
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 254
      goto switch_break;
    }
#line 256
    status = prev_status;
#line 257
    goto __Cont;
    case_4: /* CIL Label */ 
#line 260
    if (block_number_option) {
      {
#line 263
      tmp___10 = current_block_ordinal();
#line 263
      tmp___11 = umaxtostr((uintmax_t )tmp___10, buf___1);
#line 263
      tmp___12 = gettext("block %s: ** End of File **\n");
#line 263
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___12,
              tmp___11);
      }
    }
#line 266
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 271
    set_next_block_after(current_header);
    }
    {
#line 274
    if ((unsigned int )prev_status == 0U) {
#line 274
      goto case_0___0;
    }
#line 279
    if ((unsigned int )prev_status == 1U) {
#line 279
      goto case_1___0;
    }
#line 279
    if ((unsigned int )prev_status == 3U) {
#line 279
      goto case_1___0;
    }
#line 293
    if ((unsigned int )prev_status == 5U) {
#line 293
      goto case_5___0;
    }
#line 293
    if ((unsigned int )prev_status == 4U) {
#line 293
      goto case_5___0;
    }
#line 297
    if ((unsigned int )prev_status == 2U) {
#line 297
      goto case_2___0;
    }
#line 272
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
    {
#line 275
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 275
      if (error_hook) {
        {
#line 275
        (*error_hook)();
        }
      }
      {
#line 275
      tmp___13 = gettext("This does not look like a tar archive");
#line 275
      error(0, 0, (char const   *)tmp___13);
#line 275
      exit_status = 2;
      }
#line 275
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
    case_1___0: /* CIL Label */ 
    case_3___0: /* CIL Label */ 
#line 280
    if (block_number_option) {
      {
#line 283
      tmp___14 = current_block_ordinal();
#line 283
      block_ordinal = tmp___14;
#line 284
      block_ordinal = (off_t )((size_t )block_ordinal - recent_long_name_blocks);
#line 285
      block_ordinal = (off_t )((size_t )block_ordinal - recent_long_link_blocks);
#line 286
      tmp___15 = umaxtostr((uintmax_t )block_ordinal, buf___2);
#line 286
      tmp___16 = gettext("block %s: ");
#line 286
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___16,
              tmp___15);
      }
    }
    {
#line 289
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 289
      if (error_hook) {
        {
#line 289
        (*error_hook)();
        }
      }
      {
#line 289
      tmp___17 = gettext("Skipping to next header");
#line 289
      error(0, 0, (char const   *)tmp___17);
#line 289
      exit_status = 2;
      }
#line 289
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 290
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
    case_4___0: /* CIL Label */ 
#line 295
    goto switch_break___1;
    case_2___0: /* CIL Label */ 
    {
#line 298
    abort();
    }
    switch_break___1: /* CIL Label */ ;
    }
#line 300
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 302
    goto while_break;
    __Cont: /* CIL Label */ 
    {
#line 178
    tmp___18 = all_names_found(& current_stat_info);
    }
#line 178
    if (tmp___18) {
#line 178
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 306
  close_archive();
#line 307
  names_notfound();
  }
#line 308
  return;
}
}
#line 311 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void list_archive(void) 
{ 
  off_t block_ordinal ;
  off_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 314
  tmp = current_block_ordinal();
#line 314
  block_ordinal = tmp;
  }
#line 317
  if (verbose_option) {
    {
#line 318
    print_header(& current_stat_info, current_header, block_ordinal);
    }
  }
#line 320
  if (incremental_option) {
#line 322
    if (verbose_option > 2) {
      {
#line 324
      tmp___1 = is_dumpdir(& current_stat_info);
      }
#line 324
      if (tmp___1) {
        {
#line 325
        tmp___0 = dumpdir_size((char const   *)current_stat_info.dumpdir);
#line 325
        list_dumpdir(current_stat_info.dumpdir, tmp___0);
        }
      }
    }
  }
  {
#line 330
  skip_member();
  }
#line 331
  return;
}
}
#line 343 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
enum read_header tar_checksum(union block *header , _Bool silent ) 
{ 
  size_t i ;
  int unsigned_sum ;
  int signed_sum ;
  int recorded_sum ;
  int parsed_sum ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  intmax_t tmp___2 ;

  {
#line 347
  unsigned_sum = 0;
#line 348
  signed_sum = 0;
#line 353
  p = header->buffer;
#line 354
  i = sizeof(*header);
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 354
    tmp___0 = i;
#line 354
    i --;
#line 354
    if (! (tmp___0 != 0UL)) {
#line 354
      goto while_break;
    }
#line 356
    unsigned_sum += (int )((unsigned char )*p);
#line 357
    tmp = p;
#line 357
    p ++;
#line 357
    signed_sum += (int )((signed char )*tmp);
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  if (unsigned_sum == 0) {
#line 361
    return ((enum read_header )3);
  }
#line 365
  i = sizeof(header->header.chksum);
  {
#line 365
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 365
    tmp___1 = i;
#line 365
    i --;
#line 365
    if (! (tmp___1 != 0UL)) {
#line 365
      goto while_break___0;
    }
#line 367
    unsigned_sum -= (int )((unsigned char )header->header.chksum[i]);
#line 368
    signed_sum -= (int )((signed char )header->header.chksum[i]);
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 370
  unsigned_sum = (int )((unsigned long )unsigned_sum + 32UL * sizeof(header->header.chksum));
#line 371
  signed_sum = (int )((unsigned long )signed_sum + 32UL * sizeof(header->header.chksum));
#line 373
  tmp___2 = from_header((char const   *)(header->header.chksum), sizeof(header->header.chksum),
                        (char const   *)0, (intmax_t )0, (uintmax_t )2147483647, (_Bool)1,
                        silent);
#line 373
  parsed_sum = (int )tmp___2;
  }
#line 376
  if (parsed_sum < 0) {
#line 377
    return ((enum read_header )5);
  }
#line 379
  recorded_sum = parsed_sum;
#line 381
  if (unsigned_sum != recorded_sum) {
#line 381
    if (signed_sum != recorded_sum) {
#line 382
      return ((enum read_header )5);
    }
  }
#line 384
  return ((enum read_header )1);
}
}
#line 408 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
enum read_header read_header(union block **return_block , struct tar_stat_info *info ,
                             enum read_header_mode mode ) 
{ 
  union block *header ;
  union block *header_copy ;
  char *bp ;
  union block *data_block ;
  size_t size ;
  size_t written ;
  union block *next_long_name ;
  union block *next_long_link ;
  size_t next_long_name_blocks ;
  size_t next_long_link_blocks ;
  enum read_header status ;
  size_t name_size ;
  size_t n ;
  void *tmp ;
  char *tmp___0 ;
  off_t tmp___1 ;
  struct xheader xhdr ;
  void *tmp___2 ;
  off_t tmp___3 ;
  char const   *name ;
  struct posix_header  const  *h ;
  char namebuf[((sizeof(h->prefix) + 1UL) + 100UL) + 1UL] ;
  char *np ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 417
  next_long_name = (union block *)0;
#line 418
  next_long_link = (union block *)0;
#line 419
  next_long_name_blocks = (size_t )0;
#line 420
  next_long_link_blocks = (size_t )0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 426
    header = find_next_block();
#line 427
    *return_block = header;
    }
#line 428
    if (! header) {
#line 429
      return ((enum read_header )4);
    }
    {
#line 431
    status = tar_checksum(header, (_Bool)0);
    }
#line 431
    if ((unsigned int )status != 1U) {
#line 432
      return (status);
    }
#line 436
    if ((int )header->header.typeflag == 49) {
#line 437
      info->stat.st_size = (__off_t )0;
    } else {
      {
#line 440
      info->stat.st_size = off_from_header((char const   *)(header->header.size),
                                           sizeof(header->header.size));
      }
#line 441
      if (info->stat.st_size < 0L) {
#line 442
        return ((enum read_header )5);
      }
    }
#line 445
    if ((int )header->header.typeflag == 76) {
#line 445
      goto _L___0;
    } else
#line 445
    if ((int )header->header.typeflag == 75) {
#line 445
      goto _L___0;
    } else
#line 445
    if ((int )header->header.typeflag == 120) {
#line 445
      goto _L___0;
    } else
#line 445
    if ((int )header->header.typeflag == 103) {
#line 445
      goto _L___0;
    } else
#line 445
    if ((int )header->header.typeflag == 88) {
      _L___0: /* CIL Label */ 
#line 451
      if ((unsigned int )mode == 1U) {
#line 452
        return ((enum read_header )2);
      } else
#line 453
      if ((int )header->header.typeflag == 76) {
#line 453
        goto _L;
      } else
#line 453
      if ((int )header->header.typeflag == 75) {
        _L: /* CIL Label */ 
#line 456
        name_size = (size_t )info->stat.st_size;
#line 457
        n = name_size % 512UL;
#line 458
        size = name_size + 512UL;
#line 459
        if (n) {
#line 460
          size += 512UL - n;
        }
#line 462
        if (name_size != (size_t )info->stat.st_size) {
          {
#line 463
          xalloc_die();
          }
        } else
#line 462
        if (size < name_size) {
          {
#line 463
          xalloc_die();
          }
        }
        {
#line 465
        tmp = xmalloc(size + 1UL);
#line 465
        header_copy = (union block *)tmp;
        }
#line 467
        if ((int )header->header.typeflag == 76) {
          {
#line 469
          free((void *)next_long_name);
#line 470
          next_long_name = header_copy;
#line 471
          next_long_name_blocks = size / 512UL;
          }
        } else {
          {
#line 475
          free((void *)next_long_link);
#line 476
          next_long_link = header_copy;
#line 477
          next_long_link_blocks = size / 512UL;
          }
        }
        {
#line 480
        set_next_block_after(header);
#line 481
        *header_copy = *header;
#line 482
        bp = header_copy->buffer + 512;
#line 484
        size -= 512UL;
        }
        {
#line 484
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 484
          if (! (size > 0UL)) {
#line 484
            goto while_break___0;
          }
          {
#line 486
          data_block = find_next_block();
          }
#line 487
          if (! data_block) {
            {
#line 489
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 489
              if (error_hook) {
                {
#line 489
                (*error_hook)();
                }
              }
              {
#line 489
              tmp___0 = gettext("Unexpected EOF in archive");
#line 489
              error(0, 0, (char const   *)tmp___0);
#line 489
              exit_status = 2;
              }
#line 489
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
#line 490
            goto while_break___0;
          }
          {
#line 492
          written = available_space_after(data_block);
          }
#line 493
          if (written > size) {
#line 494
            written = size;
          }
          {
#line 496
          memcpy((void */* __restrict  */)bp, (void const   */* __restrict  */)(data_block->buffer),
                 written);
#line 497
          bp += written;
#line 498
          set_next_block_after((union block *)((data_block->buffer + written) - 1));
#line 484
          size -= written;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 502
        *bp = (char )'\000';
      } else
#line 504
      if ((int )header->header.typeflag == 120) {
        {
#line 506
        tmp___1 = off_from_header((char const   *)(header->header.size), sizeof(header->header.size));
#line 506
        xheader_read(& info->xhdr, header, tmp___1);
        }
      } else
#line 504
      if ((int )header->header.typeflag == 88) {
        {
#line 506
        tmp___1 = off_from_header((char const   *)(header->header.size), sizeof(header->header.size));
#line 506
        xheader_read(& info->xhdr, header, tmp___1);
        }
      } else
#line 508
      if ((int )header->header.typeflag == 103) {
#line 512
        if (! recent_global_header) {
          {
#line 513
          tmp___2 = xmalloc(sizeof(*recent_global_header));
#line 513
          recent_global_header = (union block *)tmp___2;
          }
        }
        {
#line 514
        memcpy((void */* __restrict  */)recent_global_header, (void const   */* __restrict  */)header,
               sizeof(*recent_global_header));
#line 516
        memset((void *)(& xhdr), 0, sizeof(xhdr));
#line 517
        tmp___3 = off_from_header((char const   *)(header->header.size), sizeof(header->header.size));
#line 517
        xheader_read(& xhdr, header, tmp___3);
#line 519
        xheader_decode_global(& xhdr);
#line 520
        xheader_destroy(& xhdr);
        }
#line 521
        if ((unsigned int )mode == 2U) {
#line 522
          return ((enum read_header )2);
        }
      }
    } else {
      {
#line 531
      h = (struct posix_header  const  *)(& header->header);
#line 534
      free((void *)recent_long_name);
      }
#line 536
      if (next_long_name) {
#line 538
        name = (char const   *)(next_long_name->buffer + 512);
#line 539
        recent_long_name = next_long_name;
#line 540
        recent_long_name_blocks = next_long_name_blocks;
      } else {
#line 546
        np = namebuf;
#line 548
        if (h->prefix[0]) {
          {
#line 548
          tmp___6 = strcmp((char const   *)(h->magic), "ustar");
          }
#line 548
          if (tmp___6 == 0) {
            {
#line 550
            memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)(h->prefix),
                   sizeof(h->prefix));
#line 551
            *(np + sizeof(h->prefix)) = (char )'\000';
#line 552
            tmp___4 = strlen((char const   *)np);
#line 552
            np += tmp___4;
#line 553
            tmp___5 = np;
#line 553
            np ++;
#line 553
            *tmp___5 = (char )'/';
            }
          }
        }
        {
#line 555
        memcpy((void */* __restrict  */)np, (void const   */* __restrict  */)(h->name),
               sizeof(h->name));
#line 556
        *(np + sizeof(h->name)) = (char )'\000';
#line 557
        name = (char const   *)(namebuf);
#line 558
        recent_long_name = (union block *)0;
#line 559
        recent_long_name_blocks = (size_t )0;
        }
      }
      {
#line 561
      assign_string(& info->orig_file_name, name);
#line 562
      assign_string(& info->file_name, name);
#line 563
      info->had_trailing_slash = strip_trailing_slashes(info->file_name);
#line 565
      free((void *)recent_long_link);
      }
#line 567
      if (next_long_link) {
#line 569
        name = (char const   *)(next_long_link->buffer + 512);
#line 570
        recent_long_link = next_long_link;
#line 571
        recent_long_link_blocks = next_long_link_blocks;
      } else {
        {
#line 575
        memcpy((void */* __restrict  */)(namebuf), (void const   */* __restrict  */)(h->linkname),
               sizeof(h->linkname));
#line 576
        namebuf[sizeof(h->linkname)] = (char )'\000';
#line 577
        name = (char const   *)(namebuf);
#line 578
        recent_long_link = (union block *)0;
#line 579
        recent_long_link_blocks = (size_t )0;
        }
      }
      {
#line 581
      assign_string(& info->link_name, name);
      }
#line 583
      return ((enum read_header )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 603 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void decode_header(union block *header , struct tar_stat_info *stat_info , enum archive_format *format_pointer ,
                   int do_user_group ) 
{ 
  enum archive_format format ;
  _Bool hbits ;
  mode_t mode ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  __syscall_slong_t tmp___4 ;
  __syscall_slong_t tmp___5 ;
  struct timespec tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;

  {
  {
#line 609
  tmp = mode_from_header((char const   *)(header->header.mode), sizeof(header->header.mode),
                         & hbits);
#line 609
  mode = tmp;
#line 611
  tmp___1 = strcmp((char const   *)(header->header.magic), "ustar");
  }
#line 611
  if (tmp___1 == 0) {
#line 613
    if ((int )header->star_header.prefix[130] == 0) {
#line 613
      if ((int )header->star_header.atime[0] >= 48) {
#line 613
        if ((int )header->star_header.atime[0] <= 55) {
#line 613
          if ((int )header->star_header.atime[11] == 32) {
#line 613
            if ((int )header->star_header.ctime[0] >= 48) {
#line 613
              if ((int )header->star_header.ctime[0] <= 55) {
#line 613
                if ((int )header->star_header.ctime[11] == 32) {
#line 618
                  format = (enum archive_format )5;
                } else {
#line 613
                  goto _L___2;
                }
              } else {
#line 613
                goto _L___2;
              }
            } else {
#line 613
              goto _L___2;
            }
          } else {
#line 613
            goto _L___2;
          }
        } else {
#line 613
          goto _L___2;
        }
      } else {
#line 613
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 619
    if (stat_info->xhdr.size) {
#line 620
      format = (enum archive_format )4;
    } else {
#line 622
      format = (enum archive_format )3;
    }
  } else {
    {
#line 624
    tmp___0 = strcmp((char const   *)(header->buffer + (unsigned long )(& ((struct posix_header *)0)->magic)),
                     "ustar  ");
    }
#line 624
    if (tmp___0 == 0) {
#line 627
      if (hbits) {
#line 627
        format = (enum archive_format )2;
      } else {
#line 627
        format = (enum archive_format )6;
      }
    } else {
#line 629
      format = (enum archive_format )1;
    }
  }
  {
#line 630
  *format_pointer = format;
#line 632
  stat_info->stat.st_mode = mode;
#line 633
  stat_info->mtime.tv_sec = time_from_header((char const   *)(header->header.mtime),
                                             sizeof(header->header.mtime));
#line 634
  stat_info->mtime.tv_nsec = (__syscall_slong_t )0;
  }
#line 635
  if (header->header.uname[0]) {
#line 635
    tmp___2 = header->header.uname;
  } else {
#line 635
    tmp___2 = (char *)((void *)0);
  }
  {
#line 635
  assign_string(& stat_info->uname, (char const   *)tmp___2);
  }
#line 637
  if (header->header.gname[0]) {
#line 637
    tmp___3 = header->header.gname;
  } else {
#line 637
    tmp___3 = (char *)((void *)0);
  }
  {
#line 637
  assign_string(& stat_info->gname, (char const   *)tmp___3);
#line 640
  xheader_xattr_init(stat_info);
  }
#line 642
  if ((unsigned int )format == 2U) {
#line 642
    if (incremental_option) {
      {
#line 644
      stat_info->atime.tv_sec = time_from_header((char const   *)(header->oldgnu_header.atime),
                                                 sizeof(header->oldgnu_header.atime));
#line 645
      stat_info->ctime.tv_sec = time_from_header((char const   *)(header->oldgnu_header.ctime),
                                                 sizeof(header->oldgnu_header.ctime));
#line 646
      tmp___4 = (__syscall_slong_t )0;
#line 646
      stat_info->ctime.tv_nsec = tmp___4;
#line 646
      stat_info->atime.tv_nsec = tmp___4;
      }
    } else {
#line 642
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 648
  if ((unsigned int )format == 5U) {
    {
#line 650
    stat_info->atime.tv_sec = time_from_header((char const   *)(header->star_header.atime),
                                               sizeof(header->star_header.atime));
#line 651
    stat_info->ctime.tv_sec = time_from_header((char const   *)(header->star_header.ctime),
                                               sizeof(header->star_header.ctime));
#line 652
    tmp___5 = (__syscall_slong_t )0;
#line 652
    stat_info->ctime.tv_nsec = tmp___5;
#line 652
    stat_info->atime.tv_nsec = tmp___5;
    }
  } else {
#line 655
    tmp___6 = start_time;
#line 655
    stat_info->ctime = tmp___6;
#line 655
    stat_info->atime = tmp___6;
  }
#line 657
  if ((unsigned int )format == 1U) {
    {
#line 659
    stat_info->stat.st_uid = uid_from_header((char const   *)(header->header.uid),
                                             sizeof(header->header.uid));
#line 660
    stat_info->stat.st_gid = gid_from_header((char const   *)(header->header.gid),
                                             sizeof(header->header.gid));
#line 661
    stat_info->stat.st_rdev = (__dev_t )0;
    }
  } else {
#line 665
    if (do_user_group) {
#line 669
      if (numeric_owner_option) {
        {
#line 672
        stat_info->stat.st_uid = uid_from_header((char const   *)(header->header.uid),
                                                 sizeof(header->header.uid));
        }
      } else
#line 669
      if (! header->header.uname[0]) {
        {
#line 672
        stat_info->stat.st_uid = uid_from_header((char const   *)(header->header.uid),
                                                 sizeof(header->header.uid));
        }
      } else {
        {
#line 669
        tmp___7 = uname_to_uid((char const   *)(header->header.uname), & stat_info->stat.st_uid);
        }
#line 669
        if (! tmp___7) {
          {
#line 672
          stat_info->stat.st_uid = uid_from_header((char const   *)(header->header.uid),
                                                   sizeof(header->header.uid));
          }
        }
      }
#line 674
      if (numeric_owner_option) {
        {
#line 677
        stat_info->stat.st_gid = gid_from_header((char const   *)(header->header.gid),
                                                 sizeof(header->header.gid));
        }
      } else
#line 674
      if (! header->header.gname[0]) {
        {
#line 677
        stat_info->stat.st_gid = gid_from_header((char const   *)(header->header.gid),
                                                 sizeof(header->header.gid));
        }
      } else {
        {
#line 674
        tmp___8 = gname_to_gid((char const   *)(header->header.gname), & stat_info->stat.st_gid);
        }
#line 674
        if (! tmp___8) {
          {
#line 677
          stat_info->stat.st_gid = gid_from_header((char const   *)(header->header.gid),
                                                   sizeof(header->header.gid));
          }
        }
      }
    }
    {
#line 683
    if ((int )header->header.typeflag == 51) {
#line 683
      goto case_51;
    }
#line 683
    if ((int )header->header.typeflag == 52) {
#line 683
      goto case_51;
    }
#line 689
    goto switch_default;
    case_51: /* CIL Label */ 
    case_52: /* CIL Label */ 
    {
#line 684
    tmp___9 = minor_from_header((char const   *)(header->header.devminor), sizeof(header->header.devminor));
#line 684
    tmp___10 = major_from_header((char const   *)(header->header.devmajor), sizeof(header->header.devmajor));
#line 684
    stat_info->stat.st_rdev = gnu_dev_makedev((unsigned int )tmp___10, (unsigned int )tmp___9);
    }
#line 687
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 690
    stat_info->stat.st_rdev = (__dev_t )0;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 694
  xheader_decode(stat_info);
#line 696
  tmp___11 = sparse_member_p(stat_info);
  }
#line 696
  if (tmp___11) {
    {
#line 698
    sparse_fixup_header(stat_info);
#line 699
    stat_info->is_sparse = (_Bool)1;
    }
  } else {
#line 703
    stat_info->is_sparse = (_Bool)0;
#line 704
    if ((unsigned int )current_format == 6U) {
#line 704
      goto _L___5;
    } else
#line 704
    if ((unsigned int )current_format == 2U) {
      _L___5: /* CIL Label */ 
#line 704
      if ((int )current_header->header.typeflag == 68) {
#line 708
        stat_info->is_dumpdir = (_Bool)1;
      } else {
#line 704
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 704
    if (stat_info->dumpdir) {
#line 708
      stat_info->is_dumpdir = (_Bool)1;
    }
  }
#line 710
  return;
}
}
#line 835 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static _Bool warned_once___0  ;
#line 899 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static struct quoting_options *o  ;
#line 727 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static intmax_t from_header(char const   *where0 , size_t digs , char const   *type ,
                            intmax_t minval , uintmax_t maxval , _Bool octal_only ,
                            _Bool silent ) 
{ 
  uintmax_t value___0 ;
  uintmax_t uminval ;
  uintmax_t minus_minval ;
  char const   *where ;
  char const   *lim ;
  _Bool negative ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  char const   *where1 ;
  _Bool overflow ;
  char const   *tmp___1 ;
  int digit ;
  char *tmp___2 ;
  char *tmp___3 ;
  int dig ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *string ;
  void *tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  int signbit ;
  uintmax_t topbits ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char buf[1000] ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  uintmax_t tmp___14 ;
  intmax_t tmp___15 ;
  uintmax_t tmp___16 ;
  char minval_buf[(((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char maxval_buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char value_buf[(((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char *minval_string ;
  char *tmp___17 ;
  char *value_string ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;

  {
#line 733
  uminval = (uintmax_t )minval;
#line 734
  minus_minval = - uminval;
#line 735
  where = where0;
#line 736
  lim = where + digs;
#line 737
  negative = (_Bool)0;
#line 741
  where += ! *where;
  {
#line 744
  while (1) {
    while_continue: /* CIL Label */ ;
#line 746
    if ((unsigned long )where == (unsigned long )lim) {
#line 748
      if (type) {
#line 748
        if (! silent) {
          {
#line 749
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 749
            if (error_hook) {
              {
#line 749
              (*error_hook)();
              }
            }
            {
#line 749
            tmp = gettext("Blanks in header where numeric %s value expected");
#line 749
            error(0, 0, (char const   *)tmp, type);
#line 749
            exit_status = 2;
            }
#line 749
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 754
      return ((intmax_t )-1);
    }
    {
#line 756
    tmp___0 = __ctype_b_loc();
    }
#line 756
    if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*where)) & 8192)) {
#line 757
      goto while_break;
    }
#line 758
    where ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 761
  value___0 = (uintmax_t )0;
#line 762
  if ((unsigned int )*where - 48U <= 7U) {
#line 764
    where1 = where;
#line 765
    overflow = (_Bool)0;
    {
#line 767
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 769
      tmp___1 = where;
#line 769
      where ++;
#line 769
      value___0 += (uintmax_t )((int const   )*tmp___1 - 48);
#line 770
      if ((unsigned long )where == (unsigned long )lim) {
#line 771
        goto while_break___1;
      } else
#line 770
      if (! ((unsigned int )*where - 48U <= 7U)) {
#line 771
        goto while_break___1;
      }
#line 772
      overflow = (_Bool )((int )overflow | (value___0 != (value___0 << 3) >> 3));
#line 773
      value___0 <<= 3;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 781
    if (overflow) {
#line 781
      goto _L;
    } else
#line 781
    if (maxval < value___0) {
      _L: /* CIL Label */ 
#line 781
      if (50 <= (int )*where1) {
#line 781
        if (type) {
#line 785
          digit = (int )(((int const   )*where1 - 48) | 4);
#line 786
          overflow = (_Bool)0;
#line 787
          value___0 = (uintmax_t )0;
#line 788
          where = where1;
          {
#line 789
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 791
            value___0 += (uintmax_t )(7 - digit);
#line 792
            where ++;
#line 793
            if ((unsigned long )where == (unsigned long )lim) {
#line 794
              goto while_break___2;
            } else
#line 793
            if (! ((unsigned int )*where - 48U <= 7U)) {
#line 794
              goto while_break___2;
            }
#line 795
            digit = (int )((int const   )*where - 48);
#line 796
            overflow = (_Bool )((int )overflow | (value___0 != (value___0 << 3) >> 3));
#line 797
            value___0 <<= 3;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 799
          value___0 ++;
#line 800
          overflow = (_Bool )((int )overflow | ! value___0);
#line 802
          if (! overflow) {
#line 802
            if (value___0 <= minus_minval) {
#line 804
              if (! silent) {
                {
#line 805
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 805
                  if (error_hook) {
                    {
#line 805
                    (*error_hook)();
                    }
                  }
                  {
#line 805
                  tmp___2 = gettext("Archive octal value %.*s is out of %s range; assuming two\'s complement");
#line 805
                  error(0, 0, (char const   *)tmp___2, (int )(where - where1), where1,
                        type);
                  }
#line 805
                  goto while_break___3;
                }
                while_break___3: /* CIL Label */ ;
                }
              }
#line 809
              negative = (_Bool)1;
            }
          }
        }
      }
    }
#line 813
    if (overflow) {
#line 815
      if (type) {
#line 815
        if (! silent) {
          {
#line 816
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 816
            if (error_hook) {
              {
#line 816
              (*error_hook)();
              }
            }
            {
#line 816
            tmp___3 = gettext("Archive octal value %.*s is out of %s range");
#line 816
            error(0, 0, (char const   *)tmp___3, (int )(where - where1), where1, type);
#line 816
            exit_status = 2;
            }
#line 816
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
      }
#line 820
      return ((intmax_t )-1);
    }
  } else
#line 823
  if (! octal_only) {
#line 827
    if ((int const   )*where == 45) {
#line 827
      goto _L___1;
    } else
#line 827
    if ((int const   )*where == 43) {
      _L___1: /* CIL Label */ 
#line 833
      if (! silent) {
#line 836
        if (! warned_once___0) {
#line 838
          warned_once___0 = (_Bool)1;
          {
#line 839
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 839
            if (error_hook) {
              {
#line 839
              (*error_hook)();
              }
            }
            {
#line 839
            tmp___4 = gettext("Archive contains obsolescent base-64 headers");
#line 839
            error(0, 0, (char const   *)tmp___4);
            }
#line 839
            goto while_break___5;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
#line 842
      tmp___5 = where;
#line 842
      where ++;
#line 842
      negative = (_Bool )((int const   )*tmp___5 == 45);
      {
#line 843
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 843
        if ((unsigned long )where != (unsigned long )lim) {
#line 843
          dig = (int )base64_map[(unsigned char )*where];
#line 843
          if (! (dig < 64)) {
#line 843
            goto while_break___6;
          }
        } else {
#line 843
          goto while_break___6;
        }
#line 846
        if ((value___0 << 6) >> 6 != value___0) {
          {
#line 848
          tmp___6 = __builtin_alloca(digs + 1UL);
#line 848
          string = (char *)tmp___6;
#line 849
          memcpy((void */* __restrict  */)string, (void const   */* __restrict  */)where0,
                 digs);
#line 850
          *(string + digs) = (char )'\000';
          }
#line 851
          if (type) {
#line 851
            if (! silent) {
              {
#line 852
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 852
                if (error_hook) {
                  {
#line 852
                  (*error_hook)();
                  }
                }
                {
#line 852
                tmp___7 = quote((char const   *)string);
#line 852
                tmp___8 = gettext("Archive signed base-64 string %s is out of %s range");
#line 852
                error(0, 0, (char const   *)tmp___8, tmp___7, type);
#line 852
                exit_status = 2;
                }
#line 852
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
            }
          }
#line 855
          return ((intmax_t )-1);
        }
#line 857
        value___0 = (value___0 << 6) | (unsigned long )dig;
#line 858
        where ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    } else
#line 861
    if ((int const   )*where == -128) {
#line 861
      goto _L___0;
    } else
#line 861
    if ((int const   )*where == -1) {
      _L___0: /* CIL Label */ 
#line 870
      signbit = (int )((int const   )*where & (int const   )(1 << 6));
#line 871
      topbits = (uintmax_t )(- signbit) << ((8UL * sizeof(uintmax_t ) - 8UL) - 6UL);
#line 874
      tmp___9 = where;
#line 874
      where ++;
#line 874
      value___0 = (uintmax_t )(((int const   )*tmp___9 & (int const   )((1 << 6) - 1)) - (int const   )signbit);
      {
#line 875
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 877
        tmp___10 = where;
#line 877
        where ++;
#line 877
        value___0 = (value___0 << 8) + (uintmax_t )((unsigned char )*tmp___10);
#line 878
        if ((unsigned long )where == (unsigned long )lim) {
#line 879
          goto while_break___8;
        }
#line 880
        if ((((value___0 << 8) >> 8) | topbits) != value___0) {
#line 882
          if (type) {
#line 882
            if (! silent) {
              {
#line 883
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 883
                if (error_hook) {
                  {
#line 883
                  (*error_hook)();
                  }
                }
                {
#line 883
                tmp___11 = gettext("Archive base-256 value is out of %s range");
#line 883
                error(0, 0, (char const   *)tmp___11, type);
#line 883
                exit_status = 2;
                }
#line 883
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
            }
          }
#line 886
          return ((intmax_t )-1);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 889
      negative = (_Bool )(signbit != 0);
#line 890
      if (negative) {
#line 891
        value___0 = - value___0;
      }
    }
  }
#line 894
  if ((unsigned long )where != (unsigned long )lim) {
#line 894
    if (*where) {
      {
#line 894
      tmp___13 = __ctype_b_loc();
      }
#line 894
      if (! ((int const   )*(*tmp___13 + (int )((unsigned char )*where)) & 8192)) {
#line 896
        if (type) {
#line 901
          if (! o) {
            {
#line 903
            o = clone_quoting_options((struct quoting_options *)0);
#line 904
            set_quoting_style(o, (enum quoting_style )6);
            }
          }
          {
#line 907
          while (1) {
            while_continue___10: /* CIL Label */ ;
#line 907
            if ((unsigned long )where0 != (unsigned long )lim) {
#line 907
              if (! (! *(lim + -1))) {
#line 907
                goto while_break___10;
              }
            } else {
#line 907
              goto while_break___10;
            }
#line 908
            lim --;
          }
          while_break___10: /* CIL Label */ ;
          }
          {
#line 909
          quotearg_buffer(buf, sizeof(buf), where0, (size_t )(lim - where0), (struct quoting_options  const  *)o);
          }
#line 910
          if (! silent) {
            {
#line 911
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 911
              if (error_hook) {
                {
#line 911
                (*error_hook)();
                }
              }
              {
#line 911
              tmp___12 = gettext("Archive contains %.*s where numeric %s value expected");
#line 911
              error(0, 0, (char const   *)tmp___12, (int )sizeof(buf), buf, type);
#line 911
              exit_status = 2;
              }
#line 911
              goto while_break___11;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
        }
#line 917
        return ((intmax_t )-1);
      }
    }
  }
#line 920
  if (negative) {
#line 920
    tmp___16 = minus_minval;
  } else {
#line 920
    tmp___16 = maxval;
  }
#line 920
  if (value___0 <= tmp___16) {
#line 921
    if (negative) {
#line 921
      tmp___14 = - value___0;
    } else {
#line 921
      tmp___14 = value___0;
    }
    {
#line 921
    tmp___15 = represent_uintmax(tmp___14);
    }
#line 921
    return (tmp___15);
  }
#line 923
  if (type) {
#line 923
    if (! silent) {
      {
#line 928
      tmp___17 = umaxtostr(minus_minval, minval_buf + 1);
#line 928
      minval_string = tmp___17;
#line 929
      tmp___18 = umaxtostr(value___0, value_buf + 1);
#line 929
      value_string = tmp___18;
      }
#line 930
      if (negative) {
#line 931
        value_string --;
#line 931
        *value_string = (char )'-';
      }
#line 932
      if (minus_minval) {
#line 933
        minval_string --;
#line 933
        *minval_string = (char )'-';
      }
      {
#line 935
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 935
        if (error_hook) {
          {
#line 935
          (*error_hook)();
          }
        }
        {
#line 935
        tmp___19 = umaxtostr(maxval, maxval_buf);
#line 935
        tmp___20 = gettext("Archive value %s is out of %s range %s..%s");
#line 935
        error(0, 0, (char const   *)tmp___20, value_string, type, minval_string, tmp___19);
#line 935
        exit_status = 2;
        }
#line 935
        goto while_break___12;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
  }
#line 940
  return ((intmax_t )-1);
}
}
#line 943 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static gid_t gid_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 946
  tmp = from_header(p, s, "gid_t", (intmax_t )((gid_t )0), (uintmax_t )((gid_t )-1),
                    (_Bool)0, (_Bool)0);
  }
#line 946
  return ((gid_t )tmp);
}
}
#line 951 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static int major_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 954
  tmp = from_header(p, s, "major_t", (intmax_t )(~ (((1 << (sizeof(int ) * 8UL - 2UL)) - 1) * 2 + 1)),
                    (uintmax_t )(((1 << (sizeof(int ) * 8UL - 2UL)) - 1) * 2 + 1),
                    (_Bool)0, (_Bool)0);
  }
#line 954
  return ((int )tmp);
}
}
#line 959 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static int minor_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 962
  tmp = from_header(p, s, "minor_t", (intmax_t )(~ (((1 << (sizeof(int ) * 8UL - 2UL)) - 1) * 2 + 1)),
                    (uintmax_t )(((1 << (sizeof(int ) * 8UL - 2UL)) - 1) * 2 + 1),
                    (_Bool)0, (_Bool)0);
  }
#line 962
  return ((int )tmp);
}
}
#line 969 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static mode_t mode_from_header(char const   *p , size_t s , _Bool *hbits ) 
{ 
  intmax_t u ;
  intmax_t tmp ;
  mode_t mode ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 972
  tmp = from_header(p, s, "mode_t", (-0x7FFFFFFFFFFFFFFF-1), 0xffffffffffffffffUL,
                    (_Bool)0, (_Bool)0);
#line 972
  u = tmp;
  }
#line 975
  if (u & 2048L) {
#line 975
    tmp___0 = 2048;
  } else {
#line 975
    tmp___0 = 0;
  }
#line 975
  if (u & 1024L) {
#line 975
    tmp___1 = 1024;
  } else {
#line 975
    tmp___1 = 0;
  }
#line 975
  if (u & 512L) {
#line 975
    tmp___2 = 512;
  } else {
#line 975
    tmp___2 = 0;
  }
#line 975
  if (u & 256L) {
#line 975
    tmp___3 = 256;
  } else {
#line 975
    tmp___3 = 0;
  }
#line 975
  if (u & 128L) {
#line 975
    tmp___4 = 128;
  } else {
#line 975
    tmp___4 = 0;
  }
#line 975
  if (u & 64L) {
#line 975
    tmp___5 = 64;
  } else {
#line 975
    tmp___5 = 0;
  }
#line 975
  if (u & 32L) {
#line 975
    tmp___6 = 256 >> 3;
  } else {
#line 975
    tmp___6 = 0;
  }
#line 975
  if (u & 16L) {
#line 975
    tmp___7 = 128 >> 3;
  } else {
#line 975
    tmp___7 = 0;
  }
#line 975
  if (u & 8L) {
#line 975
    tmp___8 = 64 >> 3;
  } else {
#line 975
    tmp___8 = 0;
  }
#line 975
  if (u & 4L) {
#line 975
    tmp___9 = (256 >> 3) >> 3;
  } else {
#line 975
    tmp___9 = 0;
  }
#line 975
  if (u & 2L) {
#line 975
    tmp___10 = (128 >> 3) >> 3;
  } else {
#line 975
    tmp___10 = 0;
  }
#line 975
  if (u & 1L) {
#line 975
    tmp___11 = (64 >> 3) >> 3;
  } else {
#line 975
    tmp___11 = 0;
  }
#line 975
  mode = (mode_t )(((((((((((tmp___0 | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10) | tmp___11);
#line 987
  *hbits = (_Bool )((u & -4096L) != 0L);
#line 988
  return (mode);
}
}
#line 991 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
off_t off_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 996
  tmp = from_header(p, s, "off_t", (intmax_t )0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                    (_Bool)0, (_Bool)0);
  }
#line 996
  return (tmp);
}
}
#line 1001 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static time_t time_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 1004
  tmp = from_header(p, s, "time_t", ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                    (uintmax_t )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                    (_Bool)0, (_Bool)0);
  }
#line 1004
  return (tmp);
}
}
#line 1009 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static uid_t uid_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 1012
  tmp = from_header(p, s, "uid_t", (intmax_t )((uid_t )0), (uintmax_t )((uid_t )-1),
                    (_Bool)0, (_Bool)0);
  }
#line 1012
  return ((uid_t )tmp);
}
}
#line 1017 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
uintmax_t uintmax_from_header(char const   *p , size_t s ) 
{ 
  intmax_t tmp ;

  {
  {
#line 1020
  tmp = from_header(p, s, "uintmax_t", (intmax_t )0, 0xffffffffffffffffUL, (_Bool)0,
                    (_Bool)0);
  }
#line 1020
  return ((uintmax_t )tmp);
}
}
#line 1033 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static char buffer___0[37UL]  ;
#line 1029 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
char const   *tartime(struct timespec t , _Bool full_time ) 
{ 
  struct tm *tm ;
  time_t s ;
  int ns ;
  _Bool negative ;
  char *p ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  size_t tmp___1 ;
  uintmax_t tmp___2 ;
  unsigned long tmp___3 ;

  {
#line 1037
  s = t.tv_sec;
#line 1038
  ns = (int )t.tv_nsec;
#line 1039
  negative = (_Bool )(s < 0L);
#line 1042
  if (negative) {
#line 1042
    if (ns != 0) {
#line 1044
      s ++;
#line 1045
      ns = 1000000000 - ns;
    }
  }
#line 1048
  if (utc_option) {
    {
#line 1048
    tmp = gmtime((time_t const   *)(& s));
#line 1048
    tm = tmp;
    }
  } else {
    {
#line 1048
    tmp___0 = localtime((time_t const   *)(& s));
#line 1048
    tm = tmp___0;
    }
  }
#line 1049
  if (tm) {
#line 1051
    if (full_time) {
      {
#line 1053
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%04ld-%02d-%02d %02d:%02d:%02d",
              (long )tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,
              tm->tm_min, tm->tm_sec);
#line 1056
      tmp___1 = strlen((char const   *)(buffer___0));
#line 1056
      code_ns_fraction(ns, buffer___0 + tmp___1);
      }
    } else {
      {
#line 1059
      sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"%04ld-%02d-%02d %02d:%02d",
              (long )tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour,
              tm->tm_min);
      }
    }
#line 1062
    return ((char const   *)(buffer___0));
  }
#line 1069
  if (negative) {
#line 1069
    tmp___2 = - ((uintmax_t )s);
  } else {
#line 1069
    tmp___2 = (uintmax_t )s;
  }
  {
#line 1069
  p = umaxtostr(tmp___2, ((buffer___0 + sizeof(buffer___0)) - (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL)) - 10);
  }
#line 1071
  if (negative) {
#line 1072
    p --;
#line 1072
    *p = (char )'-';
  }
  {
#line 1073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1073
    if (full_time) {
#line 1073
      tmp___3 = sizeof(":SS.FFFFFFFFF") - 1UL;
    } else {
#line 1073
      tmp___3 = 0UL;
    }
#line 1073
    if (! ((unsigned long )(((buffer___0 + sizeof(buffer___0)) - sizeof("YYYY-MM-DD HH:MM")) + tmp___3) < (unsigned long )p)) {
#line 1073
      goto while_break;
    }
#line 1076
    p --;
#line 1076
    *p = (char )' ';
  }
  while_break: /* CIL Label */ ;
  }
#line 1077
  if (full_time) {
    {
#line 1078
    code_ns_fraction(ns, ((buffer___0 + sizeof(buffer___0)) - 1) - 10);
    }
  }
#line 1079
  return ((char const   *)p);
}
}
#line 1097 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static int ugswidth  =    19;
#line 1102 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static int datewidth  =    (int )(sizeof("YYYY-MM-DD HH:MM") - 1UL);
#line 1104 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static _Bool volume_label_printed  =    (_Bool)0;
#line 1106 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static void simple_print_header(struct tar_stat_info *st , union block *blk , off_t block_ordinal ) 
{ 
  char modes[12] ;
  char const   *time_stamp ;
  int time_stamp_len ;
  char *temp_name ;
  char uform[(((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char gform[sizeof(uform)] ;
  char *user ;
  char *group ;
  char size[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL)] ;
  char uintbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int pad ;
  int sizelen ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  unsigned int tmp___4 ;
  char *tmp___5 ;
  unsigned int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char type_string[2] ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  uintmax_t tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;

  {
#line 1125
  if (show_transformed_names_option) {
#line 1126
    if (st->file_name) {
#line 1126
      temp_name = st->file_name;
    } else {
#line 1126
      temp_name = st->orig_file_name;
    }
  } else
#line 1128
  if (st->orig_file_name) {
#line 1128
    temp_name = st->orig_file_name;
  } else {
#line 1128
    temp_name = st->file_name;
  }
#line 1130
  if (block_number_option) {
#line 1133
    if (block_ordinal < 0L) {
      {
#line 1134
      block_ordinal = current_block_ordinal();
      }
    }
    {
#line 1135
    block_ordinal = (off_t )((size_t )block_ordinal - recent_long_name_blocks);
#line 1136
    block_ordinal = (off_t )((size_t )block_ordinal - recent_long_link_blocks);
#line 1137
    tmp = umaxtostr((uintmax_t )block_ordinal, buf);
#line 1137
    tmp___0 = gettext("block %s: ");
#line 1137
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___0,
            tmp);
    }
  }
#line 1141
  if (verbose_option <= 1) {
    {
#line 1144
    tmp___1 = quotearg((char const   *)temp_name);
#line 1144
    fputs_unlocked((char const   */* __restrict  */)tmp___1, (FILE */* __restrict  */)stdlis);
    }
#line 1145
    if (show_transformed_names_option) {
#line 1145
      if (st->had_trailing_slash) {
        {
#line 1146
        fputc_unlocked('/', stdlis);
        }
      }
    }
    {
#line 1147
    fputc_unlocked('\n', stdlis);
    }
  } else {
#line 1153
    modes[0] = (char )'?';
    {
#line 1156
    if ((int )blk->header.typeflag == 86) {
#line 1156
      goto case_86;
    }
#line 1161
    if ((int )blk->header.typeflag == 77) {
#line 1161
      goto case_77;
    }
#line 1166
    if ((int )blk->header.typeflag == 75) {
#line 1166
      goto case_75;
    }
#line 1166
    if ((int )blk->header.typeflag == 76) {
#line 1166
      goto case_75;
    }
#line 1173
    if ((int )blk->header.typeflag == 0) {
#line 1173
      goto case_0;
    }
#line 1173
    if ((int )blk->header.typeflag == 48) {
#line 1173
      goto case_0;
    }
#line 1173
    if ((int )blk->header.typeflag == 83) {
#line 1173
      goto case_0;
    }
#line 1176
    if ((int )blk->header.typeflag == 49) {
#line 1176
      goto case_49;
    }
#line 1179
    if ((int )blk->header.typeflag == 68) {
#line 1179
      goto case_68;
    }
#line 1182
    if ((int )blk->header.typeflag == 53) {
#line 1182
      goto case_53;
    }
#line 1185
    if ((int )blk->header.typeflag == 50) {
#line 1185
      goto case_50;
    }
#line 1188
    if ((int )blk->header.typeflag == 52) {
#line 1188
      goto case_52;
    }
#line 1191
    if ((int )blk->header.typeflag == 51) {
#line 1191
      goto case_51;
    }
#line 1194
    if ((int )blk->header.typeflag == 54) {
#line 1194
      goto case_54;
    }
#line 1197
    if ((int )blk->header.typeflag == 55) {
#line 1197
      goto case_55;
    }
#line 1154
    goto switch_break;
    case_86: /* CIL Label */ 
#line 1157
    volume_label_printed = (_Bool)1;
#line 1158
    modes[0] = (char )'V';
#line 1159
    goto switch_break;
    case_77: /* CIL Label */ 
#line 1162
    modes[0] = (char )'M';
#line 1163
    goto switch_break;
    case_75: /* CIL Label */ 
    case_76: /* CIL Label */ 
#line 1167
    modes[0] = (char )'L';
    {
#line 1168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1168
      if (error_hook) {
        {
#line 1168
        (*error_hook)();
        }
      }
      {
#line 1168
      tmp___2 = gettext("Unexpected long name header");
#line 1168
      error(0, 0, (char const   *)tmp___2);
#line 1168
      exit_status = 2;
      }
#line 1168
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1169
    goto switch_break;
    case_0: /* CIL Label */ 
    case_48: /* CIL Label */ 
    case_83: /* CIL Label */ 
#line 1174
    if (st->had_trailing_slash) {
#line 1174
      modes[0] = (char )'d';
    } else {
#line 1174
      modes[0] = (char )'-';
    }
#line 1175
    goto switch_break;
    case_49: /* CIL Label */ 
#line 1177
    modes[0] = (char )'h';
#line 1178
    goto switch_break;
    case_68: /* CIL Label */ 
#line 1180
    modes[0] = (char )'d';
#line 1181
    goto switch_break;
    case_53: /* CIL Label */ 
#line 1183
    modes[0] = (char )'d';
#line 1184
    goto switch_break;
    case_50: /* CIL Label */ 
#line 1186
    modes[0] = (char )'l';
#line 1187
    goto switch_break;
    case_52: /* CIL Label */ 
#line 1189
    modes[0] = (char )'b';
#line 1190
    goto switch_break;
    case_51: /* CIL Label */ 
#line 1192
    modes[0] = (char )'c';
#line 1193
    goto switch_break;
    case_54: /* CIL Label */ 
#line 1195
    modes[0] = (char )'p';
#line 1196
    goto switch_break;
    case_55: /* CIL Label */ 
#line 1198
    modes[0] = (char )'C';
#line 1199
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1202
    pax_decode_mode(st->stat.st_mode, modes + 1);
#line 1205
    xattrs_print_char((struct tar_stat_info  const  *)st, modes + 10);
#line 1209
    time_stamp = tartime(st->mtime, full_time_option);
#line 1210
    tmp___3 = strlen(time_stamp);
#line 1210
    time_stamp_len = (int )tmp___3;
    }
#line 1211
    if (datewidth < time_stamp_len) {
#line 1212
      datewidth = time_stamp_len;
    }
#line 1216
    if (st->uname) {
#line 1216
      if (*(st->uname + 0)) {
#line 1216
        if ((unsigned int )current_format != 1U) {
#line 1216
          if (! numeric_owner_option) {
#line 1220
            user = st->uname;
          } else {
            {
#line 1222
            user = umaxtostr((uintmax_t )st->stat.st_uid, uform);
            }
          }
        } else {
          {
#line 1222
          user = umaxtostr((uintmax_t )st->stat.st_uid, uform);
          }
        }
      } else {
        {
#line 1222
        user = umaxtostr((uintmax_t )st->stat.st_uid, uform);
        }
      }
    } else {
      {
#line 1222
      user = umaxtostr((uintmax_t )st->stat.st_uid, uform);
      }
    }
#line 1224
    if (st->gname) {
#line 1224
      if (*(st->gname + 0)) {
#line 1224
        if ((unsigned int )current_format != 1U) {
#line 1224
          if (! numeric_owner_option) {
#line 1228
            group = st->gname;
          } else {
            {
#line 1230
            group = umaxtostr((uintmax_t )st->stat.st_gid, gform);
            }
          }
        } else {
          {
#line 1230
          group = umaxtostr((uintmax_t )st->stat.st_gid, gform);
          }
        }
      } else {
        {
#line 1230
        group = umaxtostr((uintmax_t )st->stat.st_gid, gform);
        }
      }
    } else {
      {
#line 1230
      group = umaxtostr((uintmax_t )st->stat.st_gid, gform);
      }
    }
    {
#line 1237
    if ((int )blk->header.typeflag == 52) {
#line 1237
      goto case_52___0;
    }
#line 1237
    if ((int )blk->header.typeflag == 51) {
#line 1237
      goto case_52___0;
    }
#line 1245
    goto switch_default;
    case_52___0: /* CIL Label */ 
    case_51___0: /* CIL Label */ 
    {
#line 1238
    tmp___4 = gnu_dev_major(st->stat.st_rdev);
#line 1238
    tmp___5 = umaxtostr((uintmax_t )tmp___4, uintbuf);
#line 1238
    strcpy((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___5);
#line 1240
    strcat((char */* __restrict  */)(size), (char const   */* __restrict  */)",");
#line 1241
    tmp___6 = gnu_dev_minor(st->stat.st_rdev);
#line 1241
    tmp___7 = umaxtostr((uintmax_t )tmp___6, uintbuf);
#line 1241
    strcat((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___7);
    }
#line 1243
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1247
    tmp___8 = umaxtostr((uintmax_t )st->stat.st_size, uintbuf);
#line 1247
    strcpy((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___8);
    }
#line 1248
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1253
    tmp___9 = strlen((char const   *)(size));
#line 1253
    sizelen = (int )tmp___9;
#line 1254
    tmp___10 = strlen((char const   *)user);
#line 1254
    tmp___11 = strlen((char const   *)group);
#line 1254
    pad = (int )((((tmp___10 + 1UL) + tmp___11) + 1UL) + (size_t )sizelen);
    }
#line 1255
    if (pad > ugswidth) {
#line 1256
      ugswidth = pad;
    }
    {
#line 1258
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %s/%s %*s %-*s",
            modes, user, group, (ugswidth - pad) + sizelen, size, datewidth, time_stamp);
#line 1262
    tmp___12 = quotearg((char const   *)temp_name);
#line 1262
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" %s",
            tmp___12);
    }
#line 1263
    if (show_transformed_names_option) {
#line 1263
      if (st->had_trailing_slash) {
        {
#line 1264
        fputc_unlocked('/', stdlis);
        }
      }
    }
    {
#line 1268
    if ((int )blk->header.typeflag == 50) {
#line 1268
      goto case_50___0;
    }
#line 1272
    if ((int )blk->header.typeflag == 49) {
#line 1272
      goto case_49___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 68) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 55) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 54) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 53) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 52) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 51) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 83) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 48) {
#line 1294
      goto case_68___0;
    }
#line 1294
    if ((int )blk->header.typeflag == 0) {
#line 1294
      goto case_68___0;
    }
#line 1298
    if ((int )blk->header.typeflag == 75) {
#line 1298
      goto case_75___0;
    }
#line 1302
    if ((int )blk->header.typeflag == 76) {
#line 1302
      goto case_76___0;
    }
#line 1306
    if ((int )blk->header.typeflag == 86) {
#line 1306
      goto case_86___0;
    }
#line 1310
    if ((int )blk->header.typeflag == 77) {
#line 1310
      goto case_77___0;
    }
#line 1276
    goto switch_default___0;
    case_50___0: /* CIL Label */ 
    {
#line 1269
    tmp___13 = quotearg((char const   *)st->link_name);
#line 1269
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" -> %s\n",
            tmp___13);
    }
#line 1270
    goto switch_break___1;
    case_49___0: /* CIL Label */ 
    {
#line 1273
    tmp___14 = quotearg((char const   *)st->link_name);
#line 1273
    tmp___15 = gettext(" link to %s\n");
#line 1273
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___15,
            tmp___14);
    }
#line 1274
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
    {
#line 1279
    type_string[0] = blk->header.typeflag;
#line 1280
    type_string[1] = (char )'\000';
#line 1281
    tmp___16 = quote((char const   *)(type_string));
#line 1281
    tmp___17 = gettext(" unknown file type %s\n");
#line 1281
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___17,
            tmp___16);
    }
#line 1284
    goto switch_break___1;
    case_68___0: /* CIL Label */ 
    case_55___0: /* CIL Label */ 
    case_54___0: /* CIL Label */ 
    case_53___0: /* CIL Label */ 
    case_52___1: /* CIL Label */ 
    case_51___1: /* CIL Label */ 
    case_83___0: /* CIL Label */ 
    case_48___0: /* CIL Label */ 
    case_0___0: /* CIL Label */ 
    {
#line 1295
    fputc_unlocked('\n', stdlis);
    }
#line 1296
    goto switch_break___1;
    case_75___0: /* CIL Label */ 
    {
#line 1299
    tmp___18 = gettext("--Long Link--\n");
#line 1299
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___18);
    }
#line 1300
    goto switch_break___1;
    case_76___0: /* CIL Label */ 
    {
#line 1303
    tmp___19 = gettext("--Long Name--\n");
#line 1303
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___19);
    }
#line 1304
    goto switch_break___1;
    case_86___0: /* CIL Label */ 
    {
#line 1307
    tmp___20 = gettext("--Volume Header--\n");
#line 1307
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___20);
    }
#line 1308
    goto switch_break___1;
    case_77___0: /* CIL Label */ 
    {
#line 1311
    tmp___21 = uintmax_from_header((char const   *)(blk->oldgnu_header.offset), sizeof(blk->oldgnu_header.offset));
#line 1311
    tmp___22 = umaxtostr(tmp___21, uintbuf);
#line 1311
    strcpy((char */* __restrict  */)(size), (char const   */* __restrict  */)tmp___22);
#line 1315
    tmp___23 = gettext("--Continued at byte %s--\n");
#line 1315
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___23,
            size);
    }
#line 1316
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 1319
  fflush_unlocked(stdlis);
#line 1320
  xattrs_print((struct tar_stat_info  const  *)st);
  }
#line 1321
  return;
}
}
#line 1324 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
static void print_volume_label(void) 
{ 
  struct tar_stat_info vstat ;
  union block vblk ;
  enum archive_format dummy___0 ;

  {
  {
#line 1331
  memset((void *)(& vblk), 0, sizeof(vblk));
#line 1332
  vblk.header.typeflag = (char )'V';
  }
#line 1333
  if (recent_global_header) {
    {
#line 1334
    memcpy((void */* __restrict  */)(vblk.header.mtime), (void const   */* __restrict  */)(recent_global_header->header.mtime),
           sizeof(vblk.header.mtime));
    }
  }
  {
#line 1336
  tar_stat_init(& vstat);
#line 1337
  assign_string(& vstat.file_name, ".");
#line 1338
  decode_header(& vblk, & vstat, & dummy___0, 0);
#line 1339
  assign_string(& vstat.file_name, (char const   *)volume_label);
#line 1340
  simple_print_header(& vstat, & vblk, (off_t )0);
#line 1341
  tar_stat_destroy(& vstat);
  }
#line 1342
  return;
}
}
#line 1344 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void print_header(struct tar_stat_info *st , union block *blk , off_t block_ordinal ) 
{ 


  {
#line 1348
  if ((unsigned int )current_format == 4U) {
#line 1348
    if (! volume_label_printed) {
#line 1348
      if (volume_label) {
        {
#line 1350
        print_volume_label();
#line 1351
        volume_label_printed = (_Bool)1;
        }
      }
    }
  }
  {
#line 1354
  simple_print_header(st, blk, block_ordinal);
  }
#line 1355
  return;
}
}
#line 1358 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void print_for_mkdir(char *dirname , int length , mode_t mode ) 
{ 
  char modes[11] ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 1363
  if (verbose_option > 1) {
    {
#line 1367
    modes[0] = (char )'d';
#line 1368
    pax_decode_mode(mode, modes + 1);
    }
#line 1370
    if (block_number_option) {
      {
#line 1373
      tmp = current_block_ordinal();
#line 1373
      tmp___0 = umaxtostr((uintmax_t )tmp, buf);
#line 1373
      tmp___1 = gettext("block %s: ");
#line 1373
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___1,
              tmp___0);
      }
    }
    {
#line 1377
    tmp___2 = quotearg((char const   *)dirname);
#line 1377
    tmp___3 = gettext("Creating directory:");
#line 1377
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s %*s %s\n",
            modes, (ugswidth + 1) + datewidth, tmp___3, tmp___2);
    }
  }
#line 1380
  return;
}
}
#line 1383 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void skip_file(off_t size ) 
{ 
  union block *x ;
  off_t nblk ;
  off_t tmp ;
  char *tmp___0 ;

  {
#line 1390
  if (seekable_archive) {
    {
#line 1392
    tmp = seek_archive(size);
#line 1392
    nblk = tmp;
    }
#line 1393
    if (nblk >= 0L) {
#line 1394
      size -= nblk * 512L;
    } else {
#line 1396
      seekable_archive = (_Bool)0;
    }
  }
  {
#line 1399
  mv_size_left(size);
  }
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if (! (size > 0L)) {
#line 1401
      goto while_break;
    }
    {
#line 1403
    x = find_next_block();
    }
#line 1404
    if (! x) {
      {
#line 1405
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1405
        if (error_hook) {
          {
#line 1405
          (*error_hook)();
          }
        }
        {
#line 1405
        tmp___0 = gettext("Unexpected EOF in archive");
#line 1405
        error(0, 0, (char const   *)tmp___0);
#line 1405
        fatal_exit();
        }
#line 1405
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1407
    set_next_block_after(x);
#line 1408
    size -= 512L;
#line 1409
    mv_size_left(size);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1411
  return;
}
}
#line 1415 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void skip_member(void) 
{ 
  char save_typeflag ;

  {
#line 1418
  if (! current_stat_info.skipped) {
    {
#line 1420
    save_typeflag = current_header->header.typeflag;
#line 1421
    set_next_block_after(current_header);
#line 1423
    mv_begin_read(& current_stat_info);
    }
#line 1425
    if (current_stat_info.is_sparse) {
      {
#line 1426
      sparse_skip_file(& current_stat_info);
      }
    } else
#line 1427
    if ((int )save_typeflag != 53) {
      {
#line 1428
      skip_file(current_stat_info.stat.st_size);
      }
    }
    {
#line 1430
    mv_end();
    }
  }
#line 1432
  return;
}
}
#line 1434 "/home/khheo/project/benchmark/tar-1.29/src/list.c"
void test_archive_label(void) 
{ 
  char *s ;
  char *tmp ;
  _Bool tmp___0 ;
  enum read_header tmp___1 ;

  {
  {
#line 1437
  base64_init();
#line 1438
  name_gather();
#line 1440
  open_archive((enum access_mode )0);
#line 1441
  tmp___1 = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
  }
#line 1441
  if ((unsigned int )tmp___1 == 1U) {
    {
#line 1444
    decode_header(current_header, & current_stat_info, & current_format, 0);
    }
#line 1446
    if ((int )current_header->header.typeflag == 86) {
      {
#line 1447
      assign_string(& volume_label, (char const   *)(current_header->header.name));
      }
    }
#line 1449
    if (volume_label) {
#line 1451
      if (verbose_option) {
        {
#line 1452
        print_volume_label();
        }
      }
      {
#line 1453
      tmp___0 = name_match((char const   *)volume_label);
      }
#line 1453
      if (! tmp___0) {
#line 1453
        if (multi_volume_option) {
          {
#line 1455
          tmp = drop_volume_label_suffix((char const   *)volume_label);
#line 1455
          s = tmp;
#line 1456
          name_match((char const   *)s);
#line 1457
          free((void *)s);
          }
        }
      }
    }
  }
  {
#line 1461
  close_archive();
#line 1462
  label_notfound();
  }
#line 1463
  return;
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 728 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mkdtemp)(char *__template ) ;
#line 817
extern void *( __attribute__((__nonnull__(1,2,5))) bsearch)(void const   *__key ,
                                                            void const   *__base ,
                                                            size_t __nmemb , size_t __size ,
                                                            int (*__compar)(void const   * ,
                                                                            void const   * ) ) ;
#line 707 "/usr/include/stdio.h"
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 712
extern __off_t ftello(FILE *__stream ) ;
#line 786
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 498
char *get_directory_entries(struct tar_stat_info *st ) ;
#line 515
void exclusion_tag_warning(char const   *dirname , char const   *tagname , char const   *message ) ;
#line 517
enum exclusion_tag_type check_exclusion_tags(struct tar_stat_info  const  *st , char const   **tag_file_name ) ;
#line 539
_Bool rename_directory(char *src , char *dst ) ;
#line 551
char const   *safe_directory_contents(struct directory *dir ) ;
#line 560
void write_directory_file(void) ;
#line 561
void purge_directory(char const   *directory_name ) ;
#line 563
void update_parent_directory(struct tar_stat_info *parent ) ;
#line 567
void clear_directory_table(void) ;
#line 962
void info_attach_exclist(struct tar_stat_info *dir ) ;
#line 974
#pragma GCC diagnostic pop
#line 81 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct dumpdir *dumpdir_create0(char const   *contents , char const   *cmask ) 
{ 
  struct dumpdir *dump ;
  size_t i ;
  size_t total ;
  size_t ctsize ;
  size_t len ;
  char *p ;
  char const   *q ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;

  {
#line 89
  i = (size_t )0;
#line 89
  total = (size_t )0;
#line 89
  ctsize = (size_t )1;
#line 89
  q = contents;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! *q) {
#line 89
      goto while_break;
    }
    {
#line 91
    tmp = strlen(q);
#line 91
    len = tmp + 1UL;
#line 92
    ctsize += len;
    }
#line 93
    if (! cmask) {
#line 94
      i ++;
    } else {
      {
#line 93
      tmp___0 = strchr(cmask, (int )*q);
      }
#line 93
      if (tmp___0) {
#line 94
        i ++;
      }
    }
#line 89
    total ++;
#line 89
    q += len;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 96
  tmp___1 = xmalloc(sizeof(*dump) + ctsize);
#line 96
  dump = (struct dumpdir *)tmp___1;
#line 97
  dump->contents = (char *)(dump + 1);
#line 98
  memcpy((void */* __restrict  */)dump->contents, (void const   */* __restrict  */)contents,
         ctsize);
#line 99
  dump->total = total;
#line 100
  dump->elc = i;
#line 101
  tmp___2 = xcalloc(i + 1UL, sizeof(*(dump->elv + 0)));
#line 101
  dump->elv = (char **)tmp___2;
#line 103
  i = (size_t )0;
#line 103
  p = dump->contents;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! *p) {
#line 103
      goto while_break___0;
    }
#line 105
    if (! cmask) {
#line 106
      tmp___4 = i;
#line 106
      i ++;
#line 106
      *(dump->elv + tmp___4) = p + 1;
    } else {
      {
#line 105
      tmp___5 = strchr(cmask, (int )*p);
      }
#line 105
      if (tmp___5) {
#line 106
        tmp___4 = i;
#line 106
        i ++;
#line 106
        *(dump->elv + tmp___4) = p + 1;
      }
    }
    {
#line 103
    tmp___3 = strlen((char const   *)p);
#line 103
    p += tmp___3 + 1UL;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  *(dump->elv + i) = (char *)((void *)0);
#line 109
  return (dump);
}
}
#line 112 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct dumpdir *dumpdir_create(char const   *contents ) 
{ 
  struct dumpdir *tmp ;

  {
  {
#line 115
  tmp = dumpdir_create0(contents, "YND");
  }
#line 115
  return (tmp);
}
}
#line 118 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void dumpdir_free(struct dumpdir *dump ) 
{ 


  {
  {
#line 121
  free((void *)dump->elv);
#line 122
  free((void *)dump);
  }
#line 123
  return;
}
}
#line 125 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static int compare_dirnames(void const   *first , void const   *second ) 
{ 
  char const   * const  *name1 ;
  char const   * const  *name2 ;
  int tmp ;

  {
  {
#line 128
  name1 = (char const   * const  *)first;
#line 129
  name2 = (char const   * const  *)second;
#line 130
  tmp = strcmp((char const   *)*name1, (char const   *)*name2);
  }
#line 130
  return (tmp);
}
}
#line 135 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static char *dumpdir_locate(struct dumpdir *dump , char const   *name ) 
{ 
  char **ptr ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 139
  if (! dump) {
#line 140
    return ((char *)((void *)0));
  }
  {
#line 142
  tmp = bsearch((void const   *)(& name), (void const   *)dump->elv, dump->elc, sizeof(*(dump->elv + 0)),
                & compare_dirnames);
#line 142
  ptr = (char **)tmp;
  }
#line 144
  if (ptr) {
#line 144
    tmp___0 = *ptr - 1;
  } else {
#line 144
    tmp___0 = (char *)((void *)0);
  }
#line 144
  return (tmp___0);
}
}
#line 154 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static char *dumpdir_next(struct dumpdir_iter *itr ) 
{ 
  size_t cur ;
  char *ret ;
  size_t tmp ;

  {
#line 157
  cur = itr->next;
#line 158
  ret = (char *)((void *)0);
#line 160
  if (itr->all) {
#line 162
    ret = (itr->dump)->contents + cur;
#line 163
    if ((int )*ret == 0) {
#line 164
      return ((char *)((void *)0));
    }
    {
#line 165
    tmp = strlen((char const   *)ret);
#line 165
    itr->next += tmp + 1UL;
    }
  } else
#line 167
  if (cur < (itr->dump)->elc) {
#line 169
    ret = *((itr->dump)->elv + cur) - 1;
#line 170
    (itr->next) ++;
  }
#line 173
  return (ret);
}
}
#line 176 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static char *dumpdir_first(struct dumpdir *dump , int all , struct dumpdir_iter **pitr ) 
{ 
  struct dumpdir_iter *itr ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 179
  tmp = xmalloc(sizeof(*itr));
#line 179
  itr = (struct dumpdir_iter *)tmp;
#line 180
  itr->dump = dump;
#line 181
  itr->all = all;
#line 182
  itr->next = (size_t )0;
#line 183
  *pitr = itr;
#line 184
  tmp___0 = dumpdir_next(itr);
  }
#line 184
  return (tmp___0);
}
}
#line 188 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
size_t dumpdir_size(char const   *p ) 
{ 
  size_t totsize ;
  size_t size ;
  size_t tmp ;

  {
#line 191
  totsize = (size_t )0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! *p) {
#line 193
      goto while_break;
    }
    {
#line 195
    tmp = strlen(p);
#line 195
    size = tmp + 1UL;
#line 196
    totsize += size;
#line 197
    p += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (totsize + 1UL);
}
}
#line 203 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *dirhead  ;
#line 203 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *dirtail  ;
#line 204 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static Hash_table *directory_table  ;
#line 205 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static Hash_table *directory_meta_table  ;
#line 216 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static size_t hash_directory_canonical_name(void const   *entry___0 , size_t n_buckets ) 
{ 
  struct directory  const  *directory ;
  size_t tmp ;

  {
  {
#line 219
  directory = (struct directory  const  *)entry___0;
#line 220
  tmp = hash_string((char const   *)directory->caname, n_buckets);
  }
#line 220
  return (tmp);
}
}
#line 224 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static _Bool compare_directory_canonical_names(void const   *entry1 , void const   *entry2 ) 
{ 
  struct directory  const  *directory1 ;
  struct directory  const  *directory2 ;
  int tmp ;

  {
  {
#line 227
  directory1 = (struct directory  const  *)entry1;
#line 228
  directory2 = (struct directory  const  *)entry2;
#line 229
  tmp = strcmp((char const   *)directory1->caname, (char const   *)directory2->caname);
  }
#line 229
  return ((_Bool )(tmp == 0));
}
}
#line 232 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static size_t hash_directory_meta(void const   *entry___0 , size_t n_buckets ) 
{ 
  struct directory  const  *directory ;

  {
#line 235
  directory = (struct directory  const  *)entry___0;
#line 237
  return ((size_t )((directory->device_number + directory->inode_number) % (unsigned long const   )n_buckets));
}
}
#line 241 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static _Bool compare_directory_meta(void const   *entry1 , void const   *entry2 ) 
{ 
  struct directory  const  *directory1 ;
  struct directory  const  *directory2 ;
  int tmp ;

  {
#line 244
  directory1 = (struct directory  const  *)entry1;
#line 245
  directory2 = (struct directory  const  *)entry2;
#line 246
  if (directory1->device_number == directory2->device_number) {
#line 246
    if (directory1->inode_number == directory2->inode_number) {
#line 246
      tmp = 1;
    } else {
#line 246
      tmp = 0;
    }
  } else {
#line 246
    tmp = 0;
  }
#line 246
  return ((_Bool )tmp);
}
}
#line 253 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *make_directory(char const   *name , char *caname ) 
{ 
  size_t namelen ;
  size_t tmp ;
  struct directory *directory ;
  void *tmp___0 ;
  struct dumpdir *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 256
  tmp = strlen(name);
#line 256
  namelen = tmp;
#line 257
  tmp___0 = xmalloc(sizeof(*directory));
#line 257
  directory = (struct directory *)tmp___0;
#line 258
  directory->next = (struct directory *)((void *)0);
#line 259
  tmp___1 = (struct dumpdir *)((void *)0);
#line 259
  directory->idump = tmp___1;
#line 259
  directory->dump = tmp___1;
#line 260
  directory->orig = (struct directory *)((void *)0);
#line 261
  directory->flags = 0U;
  }
#line 262
  if (namelen > 1UL) {
#line 262
    if ((int const   )*(name + (namelen - 1UL)) == 47) {
#line 263
      namelen --;
    }
  }
  {
#line 264
  tmp___2 = xmalloc(namelen + 1UL);
#line 264
  directory->name = (char *)tmp___2;
#line 265
  memcpy((void */* __restrict  */)directory->name, (void const   */* __restrict  */)name,
         namelen);
#line 266
  *(directory->name + namelen) = (char)0;
#line 267
  directory->caname = caname;
#line 268
  directory->tagfile = (char const   *)((void *)0);
  }
#line 269
  return (directory);
}
}
#line 272 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void free_directory(struct directory *dir ) 
{ 


  {
  {
#line 275
  free((void *)dir->caname);
#line 276
  free((void *)dir->name);
#line 277
  free((void *)dir);
  }
#line 278
  return;
}
}
#line 280 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *attach_directory(char const   *name ) 
{ 
  char *cname ;
  char *tmp ;
  struct directory *dir ;
  struct directory *tmp___0 ;

  {
  {
#line 283
  tmp = normalize_filename(chdir_current, name);
#line 283
  cname = tmp;
#line 284
  tmp___0 = make_directory(name, cname);
#line 284
  dir = tmp___0;
  }
#line 285
  if (dirtail) {
#line 286
    dirtail->next = dir;
  } else {
#line 288
    dirhead = dir;
  }
#line 289
  dirtail = dir;
#line 290
  return (dir);
}
}
#line 294 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void dirlist_replace_prefix(char const   *pref , char const   *repl ) 
{ 
  struct directory *dp ;
  size_t pref_len ;
  size_t tmp ;
  size_t repl_len ;
  size_t tmp___0 ;

  {
  {
#line 298
  tmp = strlen(pref);
#line 298
  pref_len = tmp;
#line 299
  tmp___0 = strlen(repl);
#line 299
  repl_len = tmp___0;
#line 300
  dp = dirhead;
  }
  {
#line 300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 300
    if (! dp) {
#line 300
      goto while_break;
    }
    {
#line 301
    replace_prefix(& dp->name, pref, pref_len, repl, repl_len);
#line 300
    dp = dp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  return;
}
}
#line 304 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void clear_directory_table(void) 
{ 
  struct directory *dp ;
  struct directory *next ;

  {
#line 309
  if (directory_table) {
    {
#line 310
    hash_clear(directory_table);
    }
  }
#line 311
  if (directory_meta_table) {
    {
#line 312
    hash_clear(directory_meta_table);
    }
  }
#line 313
  dp = dirhead;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! dp) {
#line 313
      goto while_break;
    }
    {
#line 315
    next = dp->next;
#line 316
    free_directory(dp);
#line 317
    dp = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  dirtail = (struct directory *)((void *)0);
#line 319
  dirhead = dirtail;
#line 320
  return;
}
}
#line 326 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *note_directory(char const   *name , struct timespec mtime ,
                                        dev_t dev , ino_t ino , _Bool nfs , _Bool found ,
                                        char const   *contents ) 
{ 
  struct directory *directory ;
  struct directory *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 331
  tmp = attach_directory(name);
#line 331
  directory = tmp;
#line 333
  directory->mtime = mtime;
#line 334
  directory->device_number = dev;
#line 335
  directory->inode_number = ino;
#line 336
  directory->children = (enum children )1;
  }
#line 337
  if (nfs) {
#line 338
    directory->flags |= 2U;
  }
#line 339
  if (found) {
#line 340
    directory->flags |= 4U;
  }
#line 341
  if (contents) {
    {
#line 342
    directory->dump = dumpdir_create(contents);
    }
  } else {
#line 344
    directory->dump = (struct dumpdir *)((void *)0);
  }
#line 346
  if (directory_table) {
#line 346
    goto _L;
  } else {
    {
#line 346
    directory_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & hash_directory_canonical_name,
                                      & compare_directory_canonical_names, (void (*)(void * ))0);
    }
#line 346
    if (directory_table) {
      _L: /* CIL Label */ 
      {
#line 346
      tmp___0 = hash_insert(directory_table, (void const   *)directory);
      }
#line 346
      if (! tmp___0) {
        {
#line 352
        xalloc_die();
        }
      }
    } else {
      {
#line 352
      xalloc_die();
      }
    }
  }
#line 354
  if (directory_meta_table) {
#line 354
    goto _L___0;
  } else {
    {
#line 354
    directory_meta_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & hash_directory_meta,
                                           & compare_directory_meta, (void (*)(void * ))0);
    }
#line 354
    if (directory_meta_table) {
      _L___0: /* CIL Label */ 
      {
#line 354
      tmp___1 = hash_insert(directory_meta_table, (void const   *)directory);
      }
#line 354
      if (! tmp___1) {
        {
#line 360
        xalloc_die();
        }
      }
    } else {
      {
#line 360
      xalloc_die();
      }
    }
  }
#line 362
  return (directory);
}
}
#line 366 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *find_directory(char const   *name ) 
{ 
  char *caname ;
  char *tmp ;
  struct directory *dir ;
  struct directory *tmp___0 ;
  struct directory *ret ;
  void *tmp___1 ;

  {
#line 369
  if (! directory_table) {
#line 370
    return ((struct directory *)0);
  } else {
    {
#line 373
    tmp = normalize_filename(chdir_current, name);
#line 373
    caname = tmp;
#line 374
    tmp___0 = make_directory(name, caname);
#line 374
    dir = tmp___0;
#line 375
    tmp___1 = hash_lookup((Hash_table const   *)directory_table, (void const   *)dir);
#line 375
    ret = (struct directory *)tmp___1;
#line 376
    free_directory(dir);
    }
#line 377
    return (ret);
  }
}
}
#line 396 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void rebase_directory(struct directory *dir , char const   *old_prefix , size_t old_prefix_len ,
                      char const   *new_prefix , size_t new_prefix_len ) 
{ 


  {
  {
#line 401
  replace_prefix(& dir->name, old_prefix, old_prefix_len, new_prefix, new_prefix_len);
  }
#line 403
  return;
}
}
#line 407 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *find_directory_meta(dev_t dev , ino_t ino ) 
{ 
  struct directory *dir ;
  struct directory *tmp ;
  struct directory *ret ;
  void *tmp___0 ;

  {
#line 410
  if (! directory_meta_table) {
#line 411
    return ((struct directory *)0);
  } else {
    {
#line 414
    tmp = make_directory("", (char *)((void *)0));
#line 414
    dir = tmp;
#line 416
    dir->device_number = dev;
#line 417
    dir->inode_number = ino;
#line 418
    tmp___0 = hash_lookup((Hash_table const   *)directory_meta_table, (void const   *)dir);
#line 418
    ret = (struct directory *)tmp___0;
#line 419
    free_directory(dir);
    }
#line 420
    return (ret);
  }
}
}
#line 424 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void update_parent_directory(struct tar_stat_info *parent ) 
{ 
  struct directory *directory ;
  struct directory *tmp ;
  struct stat st ;
  struct timespec  __attribute__((__pure__)) tmp___0 ;
  int tmp___1 ;

  {
  {
#line 427
  tmp = find_directory((char const   *)parent->orig_file_name);
#line 427
  directory = tmp;
  }
#line 428
  if (directory) {
    {
#line 431
    tmp___1 = fstat(parent->fd, & st);
    }
#line 431
    if (tmp___1 != 0) {
      {
#line 432
      stat_diag((char const   *)directory->name);
      }
    } else {
      {
#line 434
      tmp___0 = get_stat_mtime((struct stat  const  *)(& st));
#line 434
      directory->mtime = (struct timespec )tmp___0;
      }
    }
  }
#line 436
  return;
}
}
#line 442 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct directory *procdir(char const   *name_buffer___0 , struct tar_stat_info *st ,
                                 int flag , char *entry___0 ) 
{ 
  struct directory *directory ;
  struct stat *stat_data ;
  _Bool nfs ;
  _Bool perhaps_renamed ;
  int tmp ;
  struct directory *d ;
  struct directory *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct directory *d___0 ;
  struct directory *tmp___5 ;
  struct timespec  __attribute__((__pure__)) tmp___6 ;
  char const   *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  struct timespec  __attribute__((__pure__)) tmp___17 ;
  int __attribute__((__pure__))  tmp___18 ;
  struct timespec  __attribute__((__pure__)) tmp___19 ;
  int __attribute__((__pure__))  tmp___20 ;
  char *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  char *tmp___24 ;
  char const   *tag_file_name ;
  enum exclusion_tag_type tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  char *tmp___28 ;

  {
  {
#line 448
  stat_data = & st->stat;
#line 449
  nfs = (_Bool )((stat_data->st_dev & (0xffffffffffffffffUL << (sizeof(stat_data->st_dev) * 8UL - 1UL))) != 0UL);
#line 450
  perhaps_renamed = (_Bool)0;
#line 452
  directory = find_directory(name_buffer___0);
  }
#line 452
  if ((unsigned long )directory != (unsigned long )((void *)0)) {
#line 454
    if (directory->flags & 1U) {
#line 456
      if (flag & 32) {
        {
#line 458
        assign_string(& directory->name, name_buffer___0);
        }
      } else {
#line 462
        *entry___0 = (char )'N';
#line 463
        return (directory);
      }
    }
    {
#line 467
    tmp = strcmp((char const   *)directory->name, name_buffer___0);
    }
#line 467
    if (tmp) {
#line 469
      *entry___0 = (char )'N';
#line 470
      return (directory);
    }
#line 480
    if (! check_device_option) {
#line 480
      goto _L___0;
    } else
#line 480
    if (directory->flags & 2U) {
#line 480
      if (nfs) {
#line 480
        goto _L___0;
      } else {
#line 480
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 480
    if (directory->device_number == stat_data->st_dev) {
      _L___0: /* CIL Label */ 
#line 480
      if (directory->inode_number == stat_data->st_ino) {
#line 514
        directory->children = (enum children )1;
      } else {
#line 480
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 486
      tmp___0 = find_directory_meta(stat_data->st_dev, stat_data->st_ino);
#line 486
      d = tmp___0;
      }
#line 488
      if (d) {
        {
#line 490
        tmp___4 = strcmp((char const   *)d->name, name_buffer___0);
        }
#line 490
        if (tmp___4) {
          {
#line 492
          while (1) {
            while_continue: /* CIL Label */ ;
#line 492
            if (warning_option & 8192) {
              {
#line 492
              while (1) {
                while_continue___0: /* CIL Label */ ;
#line 492
                if (error_hook) {
                  {
#line 492
                  (*error_hook)();
                  }
                }
                {
#line 492
                tmp___1 = quote_n(1, (char const   *)d->name);
#line 492
                tmp___2 = quotearg_colon(name_buffer___0);
#line 492
                tmp___3 = gettext("%s: Directory has been renamed from %s");
#line 492
                error(0, 0, (char const   *)tmp___3, tmp___2, tmp___1);
                }
#line 492
                goto while_break___0;
              }
              while_break___0: /* CIL Label */ ;
              }
            }
#line 492
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
          {
#line 497
          directory->orig = d;
#line 498
          directory->flags |= 16U;
#line 499
          dirlist_replace_prefix((char const   *)d->name, name_buffer___0);
          }
        }
#line 501
        directory->children = (enum children )1;
      } else {
#line 505
        perhaps_renamed = (_Bool)1;
#line 506
        directory->children = (enum children )2;
#line 507
        directory->device_number = stat_data->st_dev;
#line 508
        directory->inode_number = stat_data->st_ino;
      }
#line 510
      if (nfs) {
#line 511
        directory->flags |= 2U;
      }
    }
#line 516
    directory->flags |= 4U;
  } else {
    {
#line 520
    tmp___5 = find_directory_meta(stat_data->st_dev, stat_data->st_ino);
#line 520
    d___0 = tmp___5;
#line 523
    tmp___6 = get_stat_mtime((struct stat  const  *)stat_data);
#line 523
    directory = note_directory(name_buffer___0, (struct timespec )tmp___6, stat_data->st_dev,
                               stat_data->st_ino, nfs, (_Bool)1, (char const   *)((void *)0));
    }
#line 531
    if (d___0) {
      {
#line 533
      tmp___10 = strcmp((char const   *)d___0->name, name_buffer___0);
      }
#line 533
      if (tmp___10) {
        {
#line 535
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 535
          if (warning_option & 8192) {
            {
#line 535
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 535
              if (error_hook) {
                {
#line 535
                (*error_hook)();
                }
              }
              {
#line 535
              tmp___7 = quote_n(1, (char const   *)d___0->name);
#line 535
              tmp___8 = quotearg_colon(name_buffer___0);
#line 535
              tmp___9 = gettext("%s: Directory has been renamed from %s");
#line 535
              error(0, 0, (char const   *)tmp___9, tmp___8, tmp___7);
              }
#line 535
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 535
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 539
        directory->orig = d___0;
#line 540
        directory->flags |= 16U;
#line 541
        dirlist_replace_prefix((char const   *)d___0->name, name_buffer___0);
        }
      }
#line 543
      directory->children = (enum children )1;
    } else {
#line 547
      directory->flags |= 8U;
      {
#line 548
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 548
        if (warning_option & 4096) {
          {
#line 548
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 548
            if (error_hook) {
              {
#line 548
              (*error_hook)();
              }
            }
            {
#line 548
            tmp___11 = quotearg_colon(name_buffer___0);
#line 548
            tmp___12 = gettext("%s: Directory is new");
#line 548
            error(0, 0, (char const   *)tmp___12, tmp___11);
            }
#line 548
            goto while_break___4;
          }
          while_break___4: /* CIL Label */ ;
          }
        }
#line 548
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 551
      if (listed_incremental_option) {
#line 551
        directory->children = (enum children )2;
      } else {
        {
#line 551
        tmp___17 = get_stat_mtime((struct stat  const  *)stat_data);
#line 551
        tmp___18 = timespec_cmp((struct timespec )tmp___17, newer_mtime_option);
        }
#line 551
        if (tmp___18 < (int __attribute__((__pure__))  )0) {
#line 551
          directory->children = (enum children )2;
        } else
#line 551
        if (after_date_option) {
          {
#line 551
          tmp___19 = get_stat_ctime((struct stat  const  *)stat_data);
#line 551
          tmp___20 = timespec_cmp((struct timespec )tmp___19, newer_mtime_option);
          }
#line 551
          if (tmp___20 < (int __attribute__((__pure__))  )0) {
#line 551
            directory->children = (enum children )2;
          } else {
#line 551
            directory->children = (enum children )1;
          }
        } else {
#line 551
          directory->children = (enum children )1;
        }
      }
    }
  }
#line 561
  if (one_file_system_option) {
#line 561
    if (st->parent) {
#line 561
      if (stat_data->st_dev != (st->parent)->stat.st_dev) {
        {
#line 564
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 564
          if (warning_option & 262144) {
            {
#line 564
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 564
              if (error_hook) {
                {
#line 564
                (*error_hook)();
                }
              }
              {
#line 564
              tmp___21 = quotearg_colon((char const   *)directory->name);
#line 564
              tmp___22 = gettext("%s: directory is on a different filesystem; not dumped");
#line 564
              error(0, 0, (char const   *)tmp___22, tmp___21);
              }
#line 564
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 564
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 568
        directory->children = (enum children )0;
#line 570
        if (directory->dump) {
          {
#line 572
          dumpdir_free(directory->dump);
#line 573
          directory->dump = (struct dumpdir *)((void *)0);
          }
        }
#line 575
        perhaps_renamed = (_Bool)0;
      } else {
#line 561
        goto _L___3;
      }
    } else {
#line 561
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 578
  if (flag & 16) {
#line 580
    directory->children = (enum children )(flag & 3);
#line 581
    if ((unsigned int )directory->children == 0U) {
#line 582
      *entry___0 = (char )'N';
    }
  }
#line 585
  if (perhaps_renamed) {
    {
#line 586
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 586
      if (warning_option & 8192) {
        {
#line 586
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 586
          if (error_hook) {
            {
#line 586
            (*error_hook)();
            }
          }
          {
#line 586
          tmp___23 = quotearg_colon(name_buffer___0);
#line 586
          tmp___24 = gettext("%s: Directory has been renamed");
#line 586
          error(0, 0, (char const   *)tmp___24, tmp___23);
          }
#line 586
          goto while_break___8;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 586
      goto while_break___7;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 590
  directory->flags |= 1U;
#line 592
  if ((unsigned int )directory->children != 0U) {
    {
#line 596
    tmp___25 = check_exclusion_tags((struct tar_stat_info  const  *)st, & tag_file_name);
    }
    {
#line 598
    if ((unsigned int )tmp___25 == 3U) {
#line 598
      goto case_3;
    }
#line 608
    if ((unsigned int )tmp___25 == 1U) {
#line 608
      goto case_1;
    }
#line 615
    if ((unsigned int )tmp___25 == 2U) {
#line 615
      goto case_2;
    }
#line 621
    if ((unsigned int )tmp___25 == 0U) {
#line 621
      goto case_0;
    }
#line 596
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 602
    tmp___26 = gettext("directory not dumped");
#line 602
    exclusion_tag_warning(name_buffer___0, tag_file_name, (char const   *)tmp___26);
#line 604
    *entry___0 = (char )'N';
#line 605
    directory->children = (enum children )0;
    }
#line 606
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 609
    tmp___27 = gettext("contents not dumped");
#line 609
    exclusion_tag_warning(name_buffer___0, tag_file_name, (char const   *)tmp___27);
#line 611
    directory->children = (enum children )0;
#line 612
    directory->tagfile = tag_file_name;
    }
#line 613
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 616
    tmp___28 = gettext("contents not dumped");
#line 616
    exclusion_tag_warning(name_buffer___0, tag_file_name, (char const   *)tmp___28);
#line 618
    directory->tagfile = tag_file_name;
    }
#line 619
    goto switch_break;
    case_0: /* CIL Label */ 
#line 622
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 626
  return (directory);
}
}
#line 640 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void makedumpdir(struct directory *directory , char const   *dir ) 
{ 
  size_t i ;
  size_t dirsize ;
  size_t len ;
  char const   *p ;
  char const   **array ;
  char *new_dump ;
  char *new_dump_ptr ;
  struct dumpdir *dump ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char const   *loc ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char tmp___8 ;
  char const   *tmp___9 ;

  {
#line 651
  if ((unsigned int )directory->children == 2U) {
#line 652
    dump = (struct dumpdir *)((void *)0);
  } else
#line 653
  if (directory->flags & 16U) {
#line 654
    if ((directory->orig)->idump) {
#line 654
      dump = (directory->orig)->idump;
    } else {
#line 654
      dump = (directory->orig)->dump;
    }
  } else {
#line 657
    dump = directory->dump;
  }
#line 660
  dirsize = (size_t )0;
#line 661
  len = (size_t )0;
#line 662
  p = dir;
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! *p) {
#line 662
      goto while_break;
    }
    {
#line 663
    tmp___0 = strlen(p);
#line 663
    len += tmp___0 + 2UL;
#line 662
    tmp = strlen(p);
#line 662
    p += tmp + 1UL;
#line 662
    dirsize ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 664
  len ++;
#line 667
  tmp___1 = xcalloc(dirsize, sizeof(*(array + 0)));
#line 667
  array = (char const   **)tmp___1;
#line 668
  i = (size_t )0;
#line 668
  p = dir;
  }
  {
#line 668
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 668
    if (! *p) {
#line 668
      goto while_break___0;
    }
    {
#line 669
    *(array + i) = p;
#line 668
    tmp___2 = strlen(p);
#line 668
    p += tmp___2 + 1UL;
#line 668
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 671
  qsort((void *)array, dirsize, sizeof(*(array + 0)), & compare_dirnames);
#line 674
  tmp___3 = xmalloc(len);
#line 674
  new_dump = (char *)tmp___3;
#line 675
  new_dump_ptr = new_dump;
#line 678
  i = (size_t )0;
  }
  {
#line 678
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 678
    if (! (i < dirsize)) {
#line 678
      goto while_break___1;
    }
    {
#line 680
    tmp___4 = dumpdir_locate(dump, *(array + i));
#line 680
    loc = (char const   *)tmp___4;
    }
#line 681
    if (loc) {
#line 683
      if (directory->tagfile) {
#line 684
        *new_dump_ptr = (char )'I';
      } else {
#line 686
        *new_dump_ptr = (char )' ';
      }
#line 687
      new_dump_ptr ++;
    } else
#line 689
    if (directory->tagfile) {
#line 690
      tmp___5 = new_dump_ptr;
#line 690
      new_dump_ptr ++;
#line 690
      *tmp___5 = (char )'I';
    } else {
#line 692
      tmp___6 = new_dump_ptr;
#line 692
      new_dump_ptr ++;
#line 692
      *tmp___6 = (char )'Y';
    }
#line 695
    p = *(array + i);
    {
#line 695
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 695
      tmp___7 = new_dump_ptr;
#line 695
      new_dump_ptr ++;
#line 695
      tmp___9 = p;
#line 695
      p ++;
#line 695
      tmp___8 = (char )*tmp___9;
#line 695
      *tmp___7 = tmp___8;
#line 695
      if (! tmp___8) {
#line 695
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 678
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 698
  *new_dump_ptr = (char)0;
#line 699
  directory->idump = directory->dump;
#line 700
  directory->dump = dumpdir_create0((char const   *)new_dump, (char const   *)((void *)0));
#line 701
  free((void *)new_dump);
#line 702
  free((void *)array);
  }
#line 703
  return;
}
}
#line 707 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void maketagdumpdir(struct directory *directory ) 
{ 
  size_t len ;
  size_t tmp ;
  char *new_dump ;
  void *tmp___0 ;

  {
  {
#line 710
  tmp = strlen(directory->tagfile);
#line 710
  len = tmp + 1UL;
#line 711
  tmp___0 = xmalloc(len + 2UL);
#line 711
  new_dump = (char *)tmp___0;
#line 712
  *(new_dump + 0) = (char )'Y';
#line 713
  memcpy((void */* __restrict  */)(new_dump + 1), (void const   */* __restrict  */)directory->tagfile,
         len);
#line 714
  *(new_dump + (len + 1UL)) = (char)0;
#line 716
  directory->idump = directory->dump;
#line 717
  directory->dump = dumpdir_create0((char const   *)new_dump, (char const   *)((void *)0));
#line 718
  free((void *)new_dump);
  }
#line 719
  return;
}
}
#line 722 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
struct directory *scan_directory(struct tar_stat_info *st ) 
{ 
  char const   *dir ;
  char *dirp ;
  char *tmp ;
  dev_t device ;
  _Bool cmdline ;
  namebuf_t nbuf ;
  char *tmp___0 ;
  struct directory *directory ;
  char ch ;
  int tmp___1 ;
  char *entry___0 ;
  struct dumpdir_iter *itr ;
  char *full_name ;
  char *tmp___2 ;
  int fd ;
  void (*diag)(char const   * ) ;
  struct tar_stat_info stsub ;
  int *tmp___3 ;
  int subfd ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int pd_flag ;
  struct timespec  __attribute__((__pure__)) tmp___7 ;
  int __attribute__((__pure__))  tmp___8 ;
  struct timespec  __attribute__((__pure__)) tmp___9 ;
  int __attribute__((__pure__))  tmp___10 ;
  _Bool tmp___11 ;

  {
  {
#line 725
  dir = (char const   *)st->orig_file_name;
#line 726
  tmp = get_directory_entries(st);
#line 726
  dirp = tmp;
#line 727
  device = st->stat.st_dev;
#line 728
  cmdline = (_Bool )(! st->parent);
  }
#line 734
  if (! dirp) {
    {
#line 735
    savedir_error(dir);
    }
  }
  {
#line 737
  info_attach_exclist(st);
#line 739
  tmp___0 = xstrdup(dir);
#line 740
  zap_slashes(tmp___0);
  }
#line 742
  if (cmdline) {
#line 742
    tmp___1 = 32;
  } else {
#line 742
    tmp___1 = 0;
  }
  {
#line 742
  directory = procdir((char const   *)tmp___0, st, tmp___1, & ch);
#line 746
  free((void *)tmp___0);
#line 748
  nbuf = namebuf_create(dir);
  }
#line 750
  if (dirp) {
#line 752
    if ((unsigned int )directory->children != 0U) {
      {
#line 757
      makedumpdir(directory, (char const   *)dirp);
#line 759
      entry___0 = dumpdir_first(directory->dump, 1, & itr);
      }
      {
#line 759
      while (1) {
        while_continue: /* CIL Label */ ;
#line 759
        if (! entry___0) {
#line 759
          goto while_break;
        }
        {
#line 763
        tmp___2 = namebuf_name(nbuf, (char const   *)(entry___0 + 1));
#line 763
        full_name = tmp___2;
        }
#line 765
        if ((int )*entry___0 == 73) {
#line 766
          *entry___0 = (char )'N';
        } else {
          {
#line 767
          tmp___11 = excluded_name((char const   *)full_name, st);
          }
#line 767
          if (tmp___11) {
#line 768
            *entry___0 = (char )'N';
          } else {
            {
#line 771
            fd = st->fd;
#line 772
            diag = (void (*)(char const   * ))0;
#line 774
            tar_stat_init(& stsub);
            }
#line 776
            if (fd < 0) {
              {
#line 778
              tmp___3 = __errno_location();
#line 778
              *tmp___3 = - fd;
#line 779
              diag = & open_diag;
              }
            } else {
              {
#line 781
              tmp___6 = fstatat(fd, (char const   */* __restrict  */)(entry___0 + 1),
                                (struct stat */* __restrict  */)(& stsub.stat), fstatat_flags);
              }
#line 781
              if (tmp___6 != 0) {
#line 783
                diag = & stat_diag;
              } else
#line 784
              if ((stsub.stat.st_mode & 61440U) == 16384U) {
                {
#line 786
                tmp___4 = subfile_open((struct tar_stat_info  const  *)st, (char const   *)(entry___0 + 1),
                                       open_read_flags);
#line 786
                subfd = tmp___4;
                }
#line 788
                if (subfd < 0) {
#line 789
                  diag = & open_diag;
                } else {
                  {
#line 792
                  stsub.fd = subfd;
#line 793
                  tmp___5 = fstat(subfd, & stsub.stat);
                  }
#line 793
                  if (tmp___5 != 0) {
#line 794
                    diag = & stat_diag;
                  }
                }
              }
            }
#line 798
            if (diag) {
              {
#line 800
              file_removed_diag((char const   *)full_name, (_Bool)0, diag);
#line 801
              *entry___0 = (char )'N';
              }
            } else
#line 803
            if ((stsub.stat.st_mode & 61440U) == 16384U) {
#line 805
              pd_flag = 0;
#line 806
              if (! recursion_option) {
#line 807
                pd_flag |= 16;
              } else
#line 808
              if ((unsigned int )directory->children == 2U) {
#line 809
                pd_flag |= 18;
              }
              {
#line 810
              *entry___0 = (char )'D';
#line 812
              stsub.parent = st;
#line 813
              procdir((char const   *)full_name, & stsub, pd_flag, entry___0);
#line 814
              restore_parent_fd((struct tar_stat_info  const  *)(& stsub));
              }
            } else
#line 816
            if (one_file_system_option) {
#line 816
              if (device != stsub.stat.st_dev) {
#line 818
                *entry___0 = (char )'N';
              } else {
#line 816
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 819
            if (! ((int )*entry___0 == 89)) {
              {
#line 822
              tmp___7 = get_stat_mtime((struct stat  const  *)(& stsub.stat));
#line 822
              tmp___8 = timespec_cmp((struct timespec )tmp___7, newer_mtime_option);
              }
#line 822
              if (tmp___8 < (int __attribute__((__pure__))  )0) {
#line 822
                if (! after_date_option) {
#line 825
                  *entry___0 = (char )'N';
                } else {
                  {
#line 822
                  tmp___9 = get_stat_ctime((struct stat  const  *)(& stsub.stat));
#line 822
                  tmp___10 = timespec_cmp((struct timespec )tmp___9, newer_mtime_option);
                  }
#line 822
                  if (tmp___10 < (int __attribute__((__pure__))  )0) {
#line 825
                    *entry___0 = (char )'N';
                  } else {
#line 827
                    *entry___0 = (char )'Y';
                  }
                }
              } else {
#line 827
                *entry___0 = (char )'Y';
              }
            }
            {
#line 829
            tar_stat_destroy(& stsub);
            }
          }
        }
        {
#line 759
        entry___0 = dumpdir_next(itr);
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 832
      free((void *)itr);
      }
    } else
#line 834
    if (directory->tagfile) {
      {
#line 835
      maketagdumpdir(directory);
      }
    }
  }
  {
#line 838
  namebuf_free(nbuf);
#line 840
  free((void *)dirp);
  }
#line 842
  return (directory);
}
}
#line 846 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
char const   *directory_contents(struct directory *dir ) 
{ 
  char *tmp ;

  {
#line 849
  if (! dir) {
#line 850
    return ((char const   *)((void *)0));
  }
#line 851
  if (dir->dump) {
#line 851
    tmp = (dir->dump)->contents;
  } else {
#line 851
    tmp = (char *)((void *)0);
  }
#line 851
  return ((char const   *)tmp);
}
}
#line 855 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
char const   *safe_directory_contents(struct directory *dir ) 
{ 
  char const   *ret ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 858
  tmp = directory_contents(dir);
#line 858
  ret = tmp;
  }
#line 859
  if (ret) {
#line 859
    tmp___0 = ret;
  } else {
#line 859
    tmp___0 = "\000\000\000\000";
  }
#line 859
  return (tmp___0);
}
}
#line 863 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void obstack_code_rename(struct obstack *stk___0 , char const   *from , char const   *to ) 
{ 
  char const   *s ;
  char *tmp ;
  struct obstack *__o ;
  struct obstack  const  *__o1 ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  size_t __len ;
  size_t tmp___1 ;
  struct obstack  const  *__o1___0 ;
  char *tmp___2 ;
  struct obstack *__o___1 ;
  struct obstack  const  *__o1___1 ;
  char *tmp___3 ;
  struct obstack *__o___2 ;
  size_t __len___0 ;
  size_t tmp___4 ;
  struct obstack  const  *__o1___2 ;

  {
#line 868
  if ((int const   )*(from + 0) == 0) {
#line 868
    s = from;
  } else {
    {
#line 868
    tmp = safer_name_suffix(from, (_Bool)0, absolute_names_option);
#line 868
    s = (char const   *)tmp;
    }
  }
#line 870
  __o = stk___0;
#line 870
  __o1 = (struct obstack  const  *)__o;
#line 870
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < 1UL) {
    {
#line 870
    _obstack_newchunk(__o, (size_t )1);
    }
  }
  {
#line 870
  tmp___0 = __o->next_free;
#line 870
  (__o->next_free) ++;
#line 870
  *tmp___0 = (char )'R';
#line 871
  __o___0 = stk___0;
#line 871
  tmp___1 = strlen(s);
#line 871
  __len = tmp___1 + 1UL;
#line 871
  __o1___0 = (struct obstack  const  *)__o___0;
  }
#line 871
  if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len) {
    {
#line 871
    _obstack_newchunk(__o___0, __len);
    }
  }
  {
#line 871
  memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)s,
         __len);
#line 871
  __o___0->next_free += __len;
  }
#line 873
  if ((int const   )*(to + 0) == 0) {
#line 873
    s = to;
  } else {
    {
#line 873
    tmp___2 = safer_name_suffix(to, (_Bool)0, absolute_names_option);
#line 873
    s = (char const   *)tmp___2;
    }
  }
#line 875
  __o___1 = stk___0;
#line 875
  __o1___1 = (struct obstack  const  *)__o___1;
#line 875
  if ((size_t )(__o1___1->chunk_limit - __o1___1->next_free) < 1UL) {
    {
#line 875
    _obstack_newchunk(__o___1, (size_t )1);
    }
  }
  {
#line 875
  tmp___3 = __o___1->next_free;
#line 875
  (__o___1->next_free) ++;
#line 875
  *tmp___3 = (char )'T';
#line 876
  __o___2 = stk___0;
#line 876
  tmp___4 = strlen(s);
#line 876
  __len___0 = tmp___4 + 1UL;
#line 876
  __o1___2 = (struct obstack  const  *)__o___2;
  }
#line 876
  if ((size_t )(__o1___2->chunk_limit - __o1___2->next_free) < __len___0) {
    {
#line 876
    _obstack_newchunk(__o___2, __len___0);
    }
  }
  {
#line 876
  memcpy((void */* __restrict  */)__o___2->next_free, (void const   */* __restrict  */)s,
         __len___0);
#line 876
  __o___2->next_free += __len___0;
  }
#line 877
  return;
}
}
#line 879 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void store_rename(struct directory *dir , struct obstack *stk___0 ) 
{ 
  struct directory *prev ;
  struct directory *p ;
  char *temp_name ;
  struct obstack *__o ;
  struct obstack  const  *__o1 ;
  char *tmp ;
  struct obstack *__o___0 ;
  size_t __len ;
  size_t tmp___0 ;
  struct obstack  const  *__o1___0 ;

  {
#line 882
  if (dir->flags & 16U) {
#line 891
    prev = dir;
    {
#line 891
    while (1) {
      while_continue: /* CIL Label */ ;
#line 891
      if (prev) {
#line 891
        if (! ((unsigned long )prev->orig != (unsigned long )dir)) {
#line 891
          goto while_break;
        }
      } else {
#line 891
        goto while_break;
      }
#line 892
      prev->flags &= 4294967279U;
#line 891
      prev = prev->orig;
    }
    while_break: /* CIL Label */ ;
    }
#line 894
    if ((unsigned long )prev == (unsigned long )((void *)0)) {
#line 896
      p = dir;
      {
#line 896
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 896
        if (p) {
#line 896
          if (! p->orig) {
#line 896
            goto while_break___0;
          }
        } else {
#line 896
          goto while_break___0;
        }
        {
#line 897
        obstack_code_rename(stk___0, (char const   *)(p->orig)->name, (char const   *)p->name);
#line 896
        p = p->orig;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 903
      prev->flags &= 4294967279U;
#line 908
      temp_name = dir_name((char const   *)dir->name);
#line 909
      __o = stk___0;
#line 909
      __o1 = (struct obstack  const  *)__o;
      }
#line 909
      if ((size_t )(__o1->chunk_limit - __o1->next_free) < 1UL) {
        {
#line 909
        _obstack_newchunk(__o, (size_t )1);
        }
      }
      {
#line 909
      tmp = __o->next_free;
#line 909
      (__o->next_free) ++;
#line 909
      *tmp = (char )'X';
#line 910
      __o___0 = stk___0;
#line 910
      tmp___0 = strlen((char const   *)temp_name);
#line 910
      __len = tmp___0 + 1UL;
#line 910
      __o1___0 = (struct obstack  const  *)__o___0;
      }
#line 910
      if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < __len) {
        {
#line 910
        _obstack_newchunk(__o___0, __len);
        }
      }
      {
#line 910
      memcpy((void */* __restrict  */)__o___0->next_free, (void const   */* __restrict  */)temp_name,
             __len);
#line 910
      __o___0->next_free += __len;
#line 912
      obstack_code_rename(stk___0, (char const   *)dir->name, "");
#line 914
      p = dir;
      }
      {
#line 914
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 914
        if (! ((unsigned long )p != (unsigned long )prev)) {
#line 914
          goto while_break___1;
        }
        {
#line 915
        obstack_code_rename(stk___0, (char const   *)(p->orig)->name, (char const   *)p->name);
#line 914
        p = p->orig;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 917
      obstack_code_rename(stk___0, "", (char const   *)prev->name);
      }
    }
  }
#line 920
  return;
}
}
#line 922 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void append_incremental_renames(struct directory *dir ) 
{ 
  struct obstack stk___0 ;
  size_t size ;
  struct directory *dp ;
  char const   *dump ;
  size_t tmp ;
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;
  struct obstack *__o___0 ;
  struct obstack  const  *__o1___0 ;
  char *tmp___0 ;
  struct obstack *__o1___1 ;
  void *__value ;
  char *tmp___1 ;
  char *tmp___2 ;
  struct obstack  const  *__o___1 ;
  struct obstack *__o___2 ;
  void *__obj ;
  char *tmp___3 ;

  {
#line 930
  if ((unsigned long )dirhead == (unsigned long )((void *)0)) {
#line 931
    return;
  }
  {
#line 933
  _obstack_begin(& stk___0, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
#line 934
  dump = directory_contents(dir);
  }
#line 935
  if (dump) {
    {
#line 937
    tmp = dumpdir_size(dump);
#line 937
    size = tmp - 1UL;
#line 938
    __o = & stk___0;
#line 938
    __len = size;
#line 938
    __o1 = (struct obstack  const  *)__o;
    }
#line 938
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
      {
#line 938
      _obstack_newchunk(__o, __len);
      }
    }
    {
#line 938
    memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)dump,
           __len);
#line 938
    __o->next_free += __len;
    }
  } else {
#line 941
    size = (size_t )0;
  }
#line 943
  dp = dirhead;
  {
#line 943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 943
    if (! dp) {
#line 943
      goto while_break;
    }
    {
#line 944
    store_rename(dp, & stk___0);
#line 943
    dp = dp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  if (dir) {
#line 947
    __o___1 = (struct obstack  const  *)(& stk___0);
#line 947
    if ((size_t )(__o___1->next_free - __o___1->object_base) != size) {
#line 949
      __o___0 = & stk___0;
#line 949
      __o1___0 = (struct obstack  const  *)__o___0;
#line 949
      if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < 1UL) {
        {
#line 949
        _obstack_newchunk(__o___0, (size_t )1);
        }
      }
      {
#line 949
      tmp___0 = __o___0->next_free;
#line 949
      (__o___0->next_free) ++;
#line 949
      *tmp___0 = (char)0;
#line 950
      dumpdir_free(dir->dump);
#line 951
      __o1___1 = & stk___0;
#line 951
      __value = (void *)__o1___1->object_base;
      }
#line 951
      if ((unsigned long )__o1___1->next_free == (unsigned long )__value) {
#line 951
        __o1___1->maybe_empty_object = 1U;
      }
#line 951
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 951
        tmp___1 = __o1___1->object_base;
      } else {
#line 951
        tmp___1 = (char *)0;
      }
#line 951
      if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 951
        tmp___2 = __o1___1->object_base;
      } else {
#line 951
        tmp___2 = (char *)0;
      }
#line 951
      __o1___1->next_free = tmp___1 + (((size_t )(__o1___1->next_free - tmp___2) + __o1___1->alignment_mask) & ~ __o1___1->alignment_mask);
#line 951
      if ((size_t )(__o1___1->next_free - (char *)__o1___1->chunk) > (size_t )(__o1___1->chunk_limit - (char *)__o1___1->chunk)) {
#line 951
        __o1___1->next_free = __o1___1->chunk_limit;
      }
      {
#line 951
      __o1___1->object_base = __o1___1->next_free;
#line 951
      dir->dump = dumpdir_create((char const   *)__value);
      }
    }
  }
#line 953
  __o___2 = & stk___0;
#line 953
  __obj = (void *)0;
#line 953
  if ((unsigned long )__obj > (unsigned long )((void *)__o___2->chunk)) {
#line 953
    if ((unsigned long )__obj < (unsigned long )((void *)__o___2->chunk_limit)) {
#line 953
      tmp___3 = (char *)__obj;
#line 953
      __o___2->object_base = tmp___3;
#line 953
      __o___2->next_free = tmp___3;
    } else {
      {
#line 953
      _obstack_free(__o___2, __obj);
      }
    }
  } else {
    {
#line 953
    _obstack_free(__o___2, __obj);
    }
  }
#line 954
  return;
}
}
#line 958 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static FILE *listed_incremental_stream  ;
#line 971 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void read_incr_db_01(int version , char const   *initbuf ) 
{ 
  int n ;
  uintmax_t u ;
  char *buf ;
  size_t bufsize ;
  char *ebuf ;
  long lineno ;
  __ssize_t tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char const   *buf_ns ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;
  _Bool tmp___11 ;
  dev_t dev ;
  ino_t ino ;
  _Bool nfs ;
  char *strp ;
  struct timespec mtime ;
  char *tmp___12 ;
  char *tmp___13 ;
  int *tmp___14 ;
  _Bool tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  int *tmp___21 ;
  int *tmp___22 ;
  intmax_t tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  intmax_t tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int *tmp___31 ;
  int *tmp___32 ;
  __ssize_t tmp___33 ;

  {
#line 976
  buf = (char *)((void *)0);
#line 977
  bufsize = (size_t )0;
#line 979
  lineno = 1L;
#line 981
  if (version == 1) {
    {
#line 983
    tmp = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                  (FILE */* __restrict  */)listed_incremental_stream);
    }
#line 983
    if (tmp <= 0L) {
      {
#line 985
      read_error(listed_incremental_option);
#line 986
      free((void *)buf);
      }
#line 987
      return;
    }
#line 989
    lineno ++;
  } else {
    {
#line 993
    buf = strdup(initbuf);
#line 994
    tmp___0 = strlen((char const   *)buf);
#line 994
    bufsize = tmp___0 + 1UL;
    }
  }
  {
#line 997
  newer_mtime_option = decode_timespec((char const   *)buf, & ebuf, (_Bool)0);
#line 999
  tmp___11 = valid_timespec(newer_mtime_option);
  }
#line 999
  if (tmp___11) {
#line 1006
    if (version == 1) {
#line 1006
      if (*ebuf) {
        {
#line 1008
        buf_ns = (char const   *)(ebuf + 1);
#line 1009
        tmp___4 = __errno_location();
#line 1009
        *tmp___4 = 0;
#line 1010
        u = strtoumax((char const   */* __restrict  */)buf_ns, (char **/* __restrict  */)(& ebuf),
                      10);
#line 1011
        tmp___6 = __errno_location();
        }
#line 1011
        if (! *tmp___6) {
#line 1011
          if (1000000000UL <= u) {
            {
#line 1012
            tmp___5 = __errno_location();
#line 1012
            *tmp___5 = 34;
            }
          }
        }
        {
#line 1013
        tmp___10 = __errno_location();
        }
#line 1013
        if (*tmp___10) {
#line 1013
          goto _L;
        } else
#line 1013
        if ((unsigned long )buf_ns == (unsigned long )ebuf) {
          _L: /* CIL Label */ 
          {
#line 1015
          while (1) {
            while_continue: /* CIL Label */ ;
#line 1015
            if (error_hook) {
              {
#line 1015
              (*error_hook)();
              }
            }
            {
#line 1015
            tmp___7 = gettext("Invalid time stamp");
#line 1015
            tmp___8 = quotearg_colon(listed_incremental_option);
#line 1015
            tmp___9 = __errno_location();
#line 1015
            error(0, *tmp___9, "%s:%ld: %s", tmp___8, lineno, tmp___7);
#line 1015
            exit_status = 2;
            }
#line 1015
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
#line 1019
          newer_mtime_option.tv_sec = ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L);
#line 1020
          newer_mtime_option.tv_nsec = (__syscall_slong_t )-1;
        } else {
#line 1023
          newer_mtime_option.tv_nsec = (__syscall_slong_t )u;
        }
      }
    }
  } else {
    {
#line 1000
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1000
      if (error_hook) {
        {
#line 1000
        (*error_hook)();
        }
      }
      {
#line 1000
      tmp___1 = gettext("Invalid time stamp");
#line 1000
      tmp___2 = quotearg_colon(listed_incremental_option);
#line 1000
      tmp___3 = __errno_location();
#line 1000
      error(0, *tmp___3, "%s:%ld: %s", tmp___2, lineno, tmp___1);
#line 1000
      exit_status = 2;
      }
#line 1000
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1027
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1027
    tmp___33 = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                       (FILE */* __restrict  */)listed_incremental_stream);
#line 1027
    n = (int )tmp___33;
    }
#line 1027
    if (! (0 < n)) {
#line 1027
      goto while_break___1;
    }
#line 1031
    nfs = (_Bool )((int )*(buf + 0) == 43);
#line 1032
    strp = buf + (int )nfs;
#line 1035
    lineno ++;
#line 1037
    if ((int )*(buf + (n - 1)) == 10) {
#line 1038
      *(buf + (n - 1)) = (char )'\000';
    }
#line 1040
    if (version == 1) {
      {
#line 1042
      mtime = decode_timespec((char const   *)strp, & ebuf, (_Bool)0);
#line 1043
      strp = ebuf;
#line 1044
      tmp___15 = valid_timespec(mtime);
      }
#line 1044
      if (tmp___15) {
#line 1044
        if ((int )*strp != 32) {
          _L___0: /* CIL Label */ 
          {
#line 1045
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1045
            if (error_hook) {
              {
#line 1045
              (*error_hook)();
              }
            }
            {
#line 1045
            tmp___12 = gettext("Invalid modification time");
#line 1045
            tmp___13 = quotearg_colon(listed_incremental_option);
#line 1045
            tmp___14 = __errno_location();
#line 1045
            error(0, *tmp___14, "%s:%ld: %s", tmp___13, lineno, tmp___12);
#line 1045
            exit_status = 2;
            }
#line 1045
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      } else {
#line 1044
        goto _L___0;
      }
      {
#line 1049
      tmp___16 = __errno_location();
#line 1049
      *tmp___16 = 0;
#line 1050
      u = strtoumax((char const   */* __restrict  */)strp, (char **/* __restrict  */)(& ebuf),
                    10);
#line 1051
      tmp___18 = __errno_location();
      }
#line 1051
      if (! *tmp___18) {
#line 1051
        if (1000000000UL <= u) {
          {
#line 1052
          tmp___17 = __errno_location();
#line 1052
          *tmp___17 = 34;
          }
        }
      }
      {
#line 1053
      tmp___22 = __errno_location();
      }
#line 1053
      if (*tmp___22) {
#line 1053
        goto _L___1;
      } else
#line 1053
      if ((unsigned long )strp == (unsigned long )ebuf) {
#line 1053
        goto _L___1;
      } else
#line 1053
      if ((int )*ebuf != 32) {
        _L___1: /* CIL Label */ 
        {
#line 1055
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1055
          if (error_hook) {
            {
#line 1055
            (*error_hook)();
            }
          }
          {
#line 1055
          tmp___19 = gettext("Invalid modification time (nanoseconds)");
#line 1055
          tmp___20 = quotearg_colon(listed_incremental_option);
#line 1055
          tmp___21 = __errno_location();
#line 1055
          error(0, *tmp___21, "%s:%ld: %s", tmp___20, lineno, tmp___19);
#line 1055
          exit_status = 2;
          }
#line 1055
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1058
        mtime.tv_nsec = (__syscall_slong_t )-1;
      } else {
#line 1061
        mtime.tv_nsec = (__syscall_slong_t )u;
      }
#line 1062
      strp = ebuf;
    } else {
#line 1065
      mtime.tv_nsec = (__syscall_slong_t )0;
#line 1065
      mtime.tv_sec = mtime.tv_nsec;
    }
    {
#line 1067
    tmp___23 = strtosysint((char const   *)strp, & ebuf, (intmax_t )((dev_t )0), (dev_t )-1);
#line 1067
    dev = (dev_t )tmp___23;
#line 1069
    strp = ebuf;
#line 1070
    tmp___27 = __errno_location();
    }
#line 1070
    if (*tmp___27) {
#line 1070
      goto _L___2;
    } else
#line 1070
    if ((int )*strp != 32) {
      _L___2: /* CIL Label */ 
      {
#line 1071
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1071
        if (error_hook) {
          {
#line 1071
          (*error_hook)();
          }
        }
        {
#line 1071
        tmp___24 = gettext("Invalid device number");
#line 1071
        tmp___25 = quotearg_colon(listed_incremental_option);
#line 1071
        tmp___26 = __errno_location();
#line 1071
        error(0, *tmp___26, "%s:%ld: %s", tmp___25, lineno, tmp___24);
#line 1071
        exit_status = 2;
        }
#line 1071
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 1075
    tmp___28 = strtosysint((char const   *)strp, & ebuf, (intmax_t )((ino_t )0), (ino_t )-1);
#line 1075
    ino = (ino_t )tmp___28;
#line 1077
    strp = ebuf;
#line 1078
    tmp___32 = __errno_location();
    }
#line 1078
    if (*tmp___32) {
#line 1078
      goto _L___3;
    } else
#line 1078
    if ((int )*strp != 32) {
      _L___3: /* CIL Label */ 
      {
#line 1079
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1079
        if (error_hook) {
          {
#line 1079
          (*error_hook)();
          }
        }
        {
#line 1079
        tmp___29 = gettext("Invalid inode number");
#line 1079
        tmp___30 = quotearg_colon(listed_incremental_option);
#line 1079
        tmp___31 = __errno_location();
#line 1079
        error(0, *tmp___31, "%s:%ld: %s", tmp___30, lineno, tmp___29);
#line 1079
        exit_status = 2;
        }
#line 1079
        goto while_break___5;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    {
#line 1083
    strp ++;
#line 1084
    unquote_string(strp);
#line 1085
    note_directory((char const   *)strp, mtime, dev, ino, nfs, (_Bool)0, (char const   *)((void *)0));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1087
  free((void *)buf);
  }
#line 1088
  return;
}
}
#line 1094 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static int read_obstack(FILE *fp , struct obstack *stk___0 , size_t *pcount ) 
{ 
  int c ;
  size_t i ;
  struct obstack *__o ;
  struct obstack  const  *__o1 ;
  char *tmp ;
  struct obstack *__o___0 ;
  struct obstack  const  *__o1___0 ;
  char *tmp___0 ;

  {
  {
#line 1100
  i = (size_t )0;
#line 1100
  c = getc_unlocked(fp);
  }
  {
#line 1100
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1100
    if (c != -1) {
#line 1100
      if (! (c != 0)) {
#line 1100
        goto while_break;
      }
    } else {
#line 1100
      goto while_break;
    }
#line 1101
    __o = stk___0;
#line 1101
    __o1 = (struct obstack  const  *)__o;
#line 1101
    if ((size_t )(__o1->chunk_limit - __o1->next_free) < 1UL) {
      {
#line 1101
      _obstack_newchunk(__o, (size_t )1);
      }
    }
    {
#line 1101
    tmp = __o->next_free;
#line 1101
    (__o->next_free) ++;
#line 1101
    *tmp = (char )c;
#line 1100
    c = getc_unlocked(fp);
#line 1100
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1102
  __o___0 = stk___0;
#line 1102
  __o1___0 = (struct obstack  const  *)__o___0;
#line 1102
  if ((size_t )(__o1___0->chunk_limit - __o1___0->next_free) < 1UL) {
    {
#line 1102
    _obstack_newchunk(__o___0, (size_t )1);
    }
  }
#line 1102
  tmp___0 = __o___0->next_free;
#line 1102
  (__o___0->next_free) ++;
#line 1102
  *tmp___0 = (char)0;
#line 1104
  *pcount = i;
#line 1105
  return (c);
}
}
#line 1119 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static _Bool read_num(FILE *fp , char const   *fieldname , intmax_t min_val , uintmax_t max_val ,
                      intmax_t *pval ) 
{ 
  int i ;
  char buf[(((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char offbuf[(((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char minbuf[(((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char maxbuf[(((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  int conversion_errno ;
  int c ;
  int tmp ;
  _Bool negative ;
  __off_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned int uc ;
  __off_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  __off_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;
  __off_t tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;

  {
  {
#line 1129
  tmp = getc_unlocked(fp);
#line 1129
  c = tmp;
#line 1130
  negative = (_Bool )(c == 45);
#line 1132
  i = 0;
  }
  {
#line 1132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1132
    if (i == 0) {
#line 1132
      if (! negative) {
#line 1132
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1132
    if (! ((unsigned int )c - 48U <= 9U)) {
#line 1132
      goto while_break;
    }
#line 1134
    buf[i] = (char )c;
#line 1135
    if ((unsigned long )i == sizeof(buf) - 1UL) {
      {
#line 1136
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1136
        if (error_hook) {
          {
#line 1136
          (*error_hook)();
          }
        }
        {
#line 1136
        tmp___0 = ftello(fp);
#line 1136
        tmp___1 = offtostr(tmp___0, offbuf);
#line 1136
        tmp___2 = quotearg_colon(listed_incremental_option);
#line 1136
        tmp___3 = gettext("%s: byte %s: %s %.*s... too long");
#line 1136
        error(0, 0, (char const   *)tmp___3, tmp___2, tmp___1, fieldname, i + 1, buf);
#line 1136
        fatal_exit();
        }
#line 1136
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1141
    c = getc_unlocked(fp);
#line 1132
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1144
  buf[i] = (char)0;
#line 1146
  if (c < 0) {
    {
#line 1148
    tmp___4 = ferror_unlocked(fp);
    }
#line 1148
    if (tmp___4) {
      {
#line 1149
      read_fatal(listed_incremental_option);
      }
    }
#line 1150
    if (i != 0) {
      {
#line 1151
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1151
        if (error_hook) {
          {
#line 1151
          (*error_hook)();
          }
        }
        {
#line 1151
        tmp___5 = gettext("Unexpected EOF in snapshot file");
#line 1151
        tmp___6 = quotearg_colon(listed_incremental_option);
#line 1151
        error(0, 0, "%s: %s", tmp___6, tmp___5);
#line 1151
        fatal_exit();
        }
#line 1151
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1154
    return ((_Bool)0);
  }
#line 1157
  if (c) {
#line 1159
    uc = (unsigned int )c;
    {
#line 1160
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1160
      if (error_hook) {
        {
#line 1160
        (*error_hook)();
        }
      }
      {
#line 1160
      tmp___7 = ftello(fp);
#line 1160
      tmp___8 = offtostr(tmp___7, offbuf);
#line 1160
      tmp___9 = quotearg_colon(listed_incremental_option);
#line 1160
      tmp___10 = gettext("%s: byte %s: %s %s followed by invalid byte 0x%02x");
#line 1160
      error(0, 0, (char const   *)tmp___10, tmp___9, tmp___8, fieldname, buf, uc);
#line 1160
      fatal_exit();
      }
#line 1160
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1167
  *pval = strtosysint((char const   *)(buf), (char **)((void *)0), min_val, max_val);
#line 1168
  tmp___11 = __errno_location();
#line 1168
  conversion_errno = *tmp___11;
  }
  {
#line 1172
  if (conversion_errno == 34) {
#line 1172
    goto case_34;
  }
#line 1184
  if (conversion_errno == 0) {
#line 1184
    goto case_0;
  }
#line 1179
  goto switch_default;
  case_34: /* CIL Label */ 
  {
#line 1173
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1173
    if (error_hook) {
      {
#line 1173
      (*error_hook)();
      }
    }
    {
#line 1173
    tmp___12 = umaxtostr(max_val, maxbuf);
#line 1173
    tmp___13 = imaxtostr(min_val, minbuf);
#line 1173
    tmp___14 = ftello(fp);
#line 1173
    tmp___15 = offtostr(tmp___14, offbuf);
#line 1173
    tmp___16 = quotearg_colon(listed_incremental_option);
#line 1173
    tmp___17 = gettext("%s: byte %s: (valid range %s..%s)\n\t%s %s");
#line 1173
    error(0, conversion_errno, (char const   *)tmp___17, tmp___16, tmp___15, tmp___13,
          tmp___12, fieldname, buf);
#line 1173
    fatal_exit();
    }
#line 1173
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  switch_default: /* CIL Label */ 
  {
#line 1180
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1180
    if (error_hook) {
      {
#line 1180
      (*error_hook)();
      }
    }
    {
#line 1180
    tmp___18 = ftello(fp);
#line 1180
    tmp___19 = offtostr(tmp___18, offbuf);
#line 1180
    tmp___20 = quotearg_colon(listed_incremental_option);
#line 1180
    tmp___21 = gettext("%s: byte %s: %s %s");
#line 1180
    error(0, conversion_errno, (char const   *)tmp___21, tmp___20, tmp___19, fieldname,
          buf);
#line 1180
    fatal_exit();
    }
#line 1180
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  case_0: /* CIL Label */ 
#line 1185
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1188
  return ((_Bool)1);
}
}
#line 1196 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void read_timespec(FILE *fp , struct timespec *pval ) 
{ 
  intmax_t s ;
  intmax_t ns ;
  char *tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 1201
  tmp___1 = read_num(fp, "sec", ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                     (uintmax_t )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                     & s);
  }
#line 1201
  if (tmp___1) {
    {
#line 1201
    tmp___2 = read_num(fp, "nsec", (intmax_t )0, (uintmax_t )999999999, & ns);
    }
#line 1201
    if (tmp___2) {
#line 1204
      pval->tv_sec = s;
#line 1205
      pval->tv_nsec = ns;
    } else {
#line 1201
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1209
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1209
      if (error_hook) {
        {
#line 1209
        (*error_hook)();
        }
      }
      {
#line 1209
      tmp = gettext("Unexpected EOF in snapshot file");
#line 1209
      tmp___0 = quotearg_colon(listed_incremental_option);
#line 1209
      error(0, 0, "%s: %s", tmp___0, tmp);
#line 1209
      fatal_exit();
      }
#line 1209
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1213
  return;
}
}
#line 1216 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void read_incr_db_2(void) 
{ 
  struct obstack stk___0 ;
  char offbuf[(((sizeof(off_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  intmax_t i ;
  struct timespec mtime ;
  dev_t dev ;
  ino_t ino ;
  _Bool nfs ;
  char *name ;
  char *content ;
  size_t s ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  __off_t tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  struct obstack *__o1___0 ;
  void *__value___0 ;
  char *tmp___12 ;
  char *tmp___13 ;
  struct obstack *__o ;
  void *__obj ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 1222
  _obstack_begin(& stk___0, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
#line 1224
  read_timespec(listed_incremental_stream, & newer_mtime_option);
  }
  {
#line 1226
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1237
    tmp = read_num(listed_incremental_stream, "nfs", (intmax_t )0, (uintmax_t )1,
                   & i);
    }
#line 1237
    if (! tmp) {
#line 1238
      return;
    }
    {
#line 1240
    nfs = (_Bool )i;
#line 1242
    read_timespec(listed_incremental_stream, & mtime);
#line 1244
    tmp___0 = read_num(listed_incremental_stream, "dev", (intmax_t )((dev_t )0), (dev_t )-1,
                       & i);
    }
#line 1244
    if (! tmp___0) {
#line 1246
      goto while_break;
    }
    {
#line 1247
    dev = (dev_t )i;
#line 1249
    tmp___1 = read_num(listed_incremental_stream, "ino", (intmax_t )((ino_t )0), (ino_t )-1,
                       & i);
    }
#line 1249
    if (! tmp___1) {
#line 1251
      goto while_break;
    }
    {
#line 1252
    ino = (ino_t )i;
#line 1254
    tmp___2 = read_obstack(listed_incremental_stream, & stk___0, & s);
    }
#line 1254
    if (tmp___2) {
#line 1255
      goto while_break;
    }
#line 1257
    __o1 = & stk___0;
#line 1257
    __value = (void *)__o1->object_base;
#line 1257
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 1257
      __o1->maybe_empty_object = 1U;
    }
#line 1257
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1257
      tmp___3 = __o1->object_base;
    } else {
#line 1257
      tmp___3 = (char *)0;
    }
#line 1257
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1257
      tmp___4 = __o1->object_base;
    } else {
#line 1257
      tmp___4 = (char *)0;
    }
#line 1257
    __o1->next_free = tmp___3 + (((size_t )(__o1->next_free - tmp___4) + __o1->alignment_mask) & ~ __o1->alignment_mask);
#line 1257
    if ((size_t )(__o1->next_free - (char *)__o1->chunk) > (size_t )(__o1->chunk_limit - (char *)__o1->chunk)) {
#line 1257
      __o1->next_free = __o1->chunk_limit;
    }
#line 1257
    __o1->object_base = __o1->next_free;
#line 1257
    name = (char *)__value;
    {
#line 1259
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1259
      tmp___5 = read_obstack(listed_incremental_stream, & stk___0, & s);
      }
#line 1259
      if (tmp___5 == 0) {
#line 1259
        if (! (s > 1UL)) {
#line 1259
          goto while_break___0;
        }
      } else {
#line 1259
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1261
    tmp___11 = getc_unlocked(listed_incremental_stream);
    }
#line 1261
    if (tmp___11 != 0) {
      {
#line 1262
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1262
        if (error_hook) {
          {
#line 1262
          (*error_hook)();
          }
        }
        {
#line 1262
        tmp___6 = gettext("Missing record terminator");
#line 1262
        tmp___7 = ftello(listed_incremental_stream);
#line 1262
        tmp___8 = offtostr(tmp___7, offbuf);
#line 1262
        tmp___9 = quotearg_colon(listed_incremental_option);
#line 1262
        tmp___10 = gettext("%s: byte %s: %s");
#line 1262
        error(0, 0, (char const   *)tmp___10, tmp___9, tmp___8, tmp___6);
#line 1262
        fatal_exit();
        }
#line 1262
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 1267
    __o1___0 = & stk___0;
#line 1267
    __value___0 = (void *)__o1___0->object_base;
#line 1267
    if ((unsigned long )__o1___0->next_free == (unsigned long )__value___0) {
#line 1267
      __o1___0->maybe_empty_object = 1U;
    }
#line 1267
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1267
      tmp___12 = __o1___0->object_base;
    } else {
#line 1267
      tmp___12 = (char *)0;
    }
#line 1267
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1267
      tmp___13 = __o1___0->object_base;
    } else {
#line 1267
      tmp___13 = (char *)0;
    }
#line 1267
    __o1___0->next_free = tmp___12 + (((size_t )(__o1___0->next_free - tmp___13) + __o1___0->alignment_mask) & ~ __o1___0->alignment_mask);
#line 1267
    if ((size_t )(__o1___0->next_free - (char *)__o1___0->chunk) > (size_t )(__o1___0->chunk_limit - (char *)__o1___0->chunk)) {
#line 1267
      __o1___0->next_free = __o1___0->chunk_limit;
    }
    {
#line 1267
    __o1___0->object_base = __o1___0->next_free;
#line 1267
    content = (char *)__value___0;
#line 1268
    note_directory((char const   *)name, mtime, dev, ino, nfs, (_Bool)0, (char const   *)content);
#line 1269
    __o = & stk___0;
#line 1269
    __obj = (void *)content;
    }
#line 1269
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1269
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1269
        tmp___14 = (char *)__obj;
#line 1269
        __o->object_base = tmp___14;
#line 1269
        __o->next_free = tmp___14;
      } else {
        {
#line 1269
        _obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 1269
      _obstack_free(__o, __obj);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1271
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1271
    if (error_hook) {
      {
#line 1271
      (*error_hook)();
      }
    }
    {
#line 1271
    tmp___15 = gettext("Unexpected EOF in snapshot file");
#line 1271
    tmp___16 = quotearg_colon(listed_incremental_option);
#line 1271
    error(0, 0, "%s: %s", tmp___16, tmp___15);
#line 1271
    fatal_exit();
    }
#line 1271
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1274
  return;
}
}
#line 1291 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static struct field_range  const  field_ranges[6]  = {      {"nfs", (intmax_t )0, (uintmax_t )1}, 
        {"timestamp_sec", ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
      (uintmax_t )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L)}, 
        {"timestamp_nsec", (intmax_t )0, (uintmax_t )999999999}, 
        {"dev", (intmax_t )((dev_t )0), (dev_t )-1}, 
        {"ino", (intmax_t )((ino_t )0), (ino_t )-1}, 
        {(char const   *)((void *)0), (intmax_t )0, (uintmax_t )0}};
#line 1300 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void show_snapshot_field_ranges(void) 
{ 
  struct field_range  const  *p ;
  char minbuf[21] ;
  char maxbuf[21] ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1307
  printf((char const   */* __restrict  */)"This tar\'s snapshot file field ranges are\n");
#line 1308
  printf((char const   */* __restrict  */)"   (%-15s => [ %s, %s ]):\n\n", "field name",
         "min", "max");
#line 1310
  p = field_ranges;
  }
  {
#line 1310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1310
    if (! ((unsigned long )p->fieldname != (unsigned long )((void *)0))) {
#line 1310
      goto while_break;
    }
    {
#line 1312
    tmp = sysinttostr((uintmax_t )p->max_val, (intmax_t )p->min_val, (uintmax_t )p->max_val,
                      (char *)(maxbuf));
#line 1312
    tmp___0 = sysinttostr((uintmax_t )p->min_val, (intmax_t )p->min_val, (uintmax_t )p->max_val,
                          (char *)(minbuf));
#line 1312
    printf((char const   */* __restrict  */)"    %-15s => [ %s, %s ],\n", p->fieldname,
           tmp___0, tmp);
#line 1310
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1318
  printf((char const   */* __restrict  */)"\n");
  }
#line 1319
  return;
}
}
#line 1327 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void read_directory_file(void) 
{ 
  int fd ;
  char *buf ;
  size_t bufsize ;
  int flags ;
  char *ebuf ;
  uintmax_t incremental_version ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  __ssize_t tmp___4 ;
  int tmp___5 ;

  {
#line 1331
  buf = (char *)((void *)0);
#line 1332
  bufsize = (size_t )0;
#line 1333
  flags = 66;
#line 1335
  if (incremental_level == 0) {
#line 1336
    flags |= 512;
  }
  {
#line 1340
  fd = open(listed_incremental_option, flags, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
  }
#line 1341
  if (fd < 0) {
    {
#line 1343
    open_error(listed_incremental_option);
    }
#line 1344
    return;
  }
  {
#line 1347
  listed_incremental_stream = fdopen(fd, "r+");
  }
#line 1348
  if (! listed_incremental_stream) {
    {
#line 1350
    open_error(listed_incremental_option);
#line 1351
    close(fd);
    }
#line 1352
    return;
  }
  {
#line 1359
  name_from_list();
#line 1360
  blank_name_list();
#line 1362
  tmp___4 = getline((char **/* __restrict  */)(& buf), (size_t */* __restrict  */)(& bufsize),
                    (FILE */* __restrict  */)listed_incremental_stream);
  }
#line 1362
  if (0L < tmp___4) {
    {
#line 1367
    tmp___2 = strncmp((char const   *)buf, "GNU tar", sizeof("GNU tar") - 1UL);
    }
#line 1367
    if (tmp___2 == 0) {
#line 1369
      ebuf = (buf + sizeof("GNU tar")) - 1;
#line 1370
      tmp___0 = ebuf;
#line 1370
      ebuf ++;
#line 1370
      if ((int )*tmp___0 != 45) {
        {
#line 1371
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1371
          if (error_hook) {
            {
#line 1371
            (*error_hook)();
            }
          }
          {
#line 1371
          tmp = gettext("Bad incremental file format");
#line 1371
          error(1, 0, (char const   *)tmp);
#line 1371
          exit_status = 2;
          }
#line 1371
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 1372
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1372
        if (! ((int )*ebuf != 45)) {
#line 1372
          goto while_break___0;
        }
#line 1373
        if (! *ebuf) {
          {
#line 1374
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1374
            if (error_hook) {
              {
#line 1374
              (*error_hook)();
              }
            }
            {
#line 1374
            tmp___1 = gettext("Bad incremental file format");
#line 1374
            error(1, 0, (char const   *)tmp___1);
#line 1374
            exit_status = 2;
            }
#line 1374
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1372
        ebuf ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1376
      incremental_version = strtoumax((char const   */* __restrict  */)(ebuf + 1),
                                      (char **/* __restrict  */)((void *)0), 10);
      }
    } else {
#line 1379
      incremental_version = (uintmax_t )0;
    }
    {
#line 1384
    if (incremental_version == 1UL) {
#line 1384
      goto case_1;
    }
#line 1384
    if (incremental_version == 0UL) {
#line 1384
      goto case_1;
    }
#line 1388
    if (incremental_version == 2UL) {
#line 1388
      goto case_2;
    }
#line 1392
    goto switch_default;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 1385
    read_incr_db_01((int )incremental_version, (char const   *)buf);
    }
#line 1386
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1389
    read_incr_db_2();
    }
#line 1390
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1393
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1393
      if (error_hook) {
        {
#line 1393
        (*error_hook)();
        }
      }
      {
#line 1393
      tmp___3 = gettext("Unsupported incremental format version: %lu");
#line 1393
      error(1, 0, (char const   *)tmp___3, incremental_version);
#line 1393
      exit_status = 2;
      }
#line 1393
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 1399
  tmp___5 = ferror_unlocked(listed_incremental_stream);
  }
#line 1399
  if (tmp___5) {
    {
#line 1400
    read_error(listed_incremental_option);
    }
  }
  {
#line 1401
  free((void *)buf);
  }
#line 1402
  return;
}
}
#line 1406 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static _Bool write_directory_file_entry(void *entry___0 , void *data ) 
{ 
  struct directory  const  *directory ;
  FILE *fp ;
  char buf[21] ;
  char const   *s ;
  char *tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  char const   *p ;
  struct dumpdir_iter *itr ;
  char *tmp___8 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 1409
  directory = (struct directory  const  *)entry___0;
#line 1410
  fp = (FILE *)data;
#line 1412
  if (directory->flags & 4U) {
#line 1417
    if (directory->flags & 2U) {
#line 1417
      s = "1";
    } else {
#line 1417
      s = "0";
    }
    {
#line 1418
    fwrite_unlocked((void const   */* __restrict  */)s, (size_t )2, (size_t )1, (FILE */* __restrict  */)fp);
#line 1419
    tmp = sysinttostr((uintmax_t )directory->mtime.tv_sec, ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                      (uintmax_t )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                      (char *)(buf));
#line 1419
    s = (char const   *)tmp;
#line 1421
    tmp___0 = strlen(s);
#line 1421
    fwrite_unlocked((void const   */* __restrict  */)s, tmp___0 + 1UL, (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 1422
    tmp___1 = imaxtostr((intmax_t )directory->mtime.tv_nsec, buf);
#line 1422
    s = (char const   *)tmp___1;
#line 1423
    tmp___2 = strlen(s);
#line 1423
    fwrite_unlocked((void const   */* __restrict  */)s, tmp___2 + 1UL, (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 1424
    tmp___3 = sysinttostr((uintmax_t )directory->device_number, (intmax_t )((dev_t )0),
                          (dev_t )-1, (char *)(buf));
#line 1424
    s = (char const   *)tmp___3;
#line 1426
    tmp___4 = strlen(s);
#line 1426
    fwrite_unlocked((void const   */* __restrict  */)s, tmp___4 + 1UL, (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 1427
    tmp___5 = sysinttostr((uintmax_t )directory->inode_number, (intmax_t )((ino_t )0),
                          (ino_t )-1, (char *)(buf));
#line 1427
    s = (char const   *)tmp___5;
#line 1429
    tmp___6 = strlen(s);
#line 1429
    fwrite_unlocked((void const   */* __restrict  */)s, tmp___6 + 1UL, (size_t )1,
                    (FILE */* __restrict  */)fp);
#line 1431
    tmp___7 = strlen((char const   *)directory->name);
#line 1431
    fwrite_unlocked((void const   */* __restrict  */)directory->name, tmp___7 + 1UL,
                    (size_t )1, (FILE */* __restrict  */)fp);
    }
#line 1432
    if (directory->dump) {
      {
#line 1437
      tmp___8 = dumpdir_first((struct dumpdir *)directory->dump, 0, & itr);
#line 1437
      p = (char const   *)tmp___8;
      }
      {
#line 1437
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1437
        if (! p) {
#line 1437
          goto while_break;
        }
        {
#line 1440
        tmp___10 = strlen(p);
#line 1440
        fwrite_unlocked((void const   */* __restrict  */)p, tmp___10 + 1UL, (size_t )1,
                        (FILE */* __restrict  */)fp);
#line 1437
        tmp___9 = dumpdir_next(itr);
#line 1437
        p = (char const   *)tmp___9;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1441
      free((void *)itr);
      }
    }
    {
#line 1443
    fwrite_unlocked((void const   */* __restrict  */)"\000\000", (size_t )2, (size_t )1,
                    (FILE */* __restrict  */)fp);
    }
  }
  {
#line 1446
  tmp___11 = ferror_unlocked(fp);
  }
#line 1446
  if (tmp___11) {
#line 1446
    tmp___12 = 0;
  } else {
#line 1446
    tmp___12 = 1;
  }
#line 1446
  return ((_Bool )tmp___12);
}
}
#line 1449 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void write_directory_file(void) 
{ 
  FILE *fp ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 1452
  fp = listed_incremental_stream;
#line 1456
  if (! fp) {
#line 1457
    return;
  }
  {
#line 1459
  tmp = fseeko(fp, 0L, 0);
  }
#line 1459
  if (tmp != 0) {
    {
#line 1460
    seek_error(listed_incremental_option);
    }
  }
  {
#line 1461
  tmp___0 = fileno(fp);
#line 1461
  tmp___1 = sys_truncate(tmp___0);
  }
#line 1461
  if (tmp___1 != 0) {
    {
#line 1462
    truncate_error(listed_incremental_option);
    }
  }
  {
#line 1464
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s-%s-%d\n",
          "GNU tar", "1.29", 2);
#line 1467
  tmp___2 = imaxtostr(start_time.tv_sec, buf);
#line 1467
  s = tmp___2;
#line 1470
  tmp___4 = strlen((char const   *)s);
#line 1470
  fwrite_unlocked((void const   */* __restrict  */)s, tmp___4 + 1UL, (size_t )1, (FILE */* __restrict  */)fp);
#line 1471
  s = umaxtostr((uintmax_t )start_time.tv_nsec, buf);
#line 1472
  tmp___5 = strlen((char const   *)s);
#line 1472
  fwrite_unlocked((void const   */* __restrict  */)s, tmp___5 + 1UL, (size_t )1, (FILE */* __restrict  */)fp);
#line 1474
  tmp___6 = ferror_unlocked(fp);
  }
#line 1474
  if (! tmp___6) {
#line 1474
    if (directory_table) {
      {
#line 1475
      hash_do_for_each((Hash_table const   *)directory_table, & write_directory_file_entry,
                       (void *)fp);
      }
    }
  }
  {
#line 1477
  tmp___7 = ferror_unlocked(fp);
  }
#line 1477
  if (tmp___7) {
    {
#line 1478
    write_error(listed_incremental_option);
    }
  }
  {
#line 1479
  tmp___8 = fclose(fp);
  }
#line 1479
  if (tmp___8 != 0) {
    {
#line 1480
    close_error(listed_incremental_option);
    }
  }
#line 1481
  return;
}
}
#line 1486 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static void get_gnu_dumpdir(struct tar_stat_info *stat_info ) 
{ 
  size_t size ;
  size_t copied ;
  union block *data_block ;
  char *to ;
  char *archive_dir ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 1495
  size = (size_t )stat_info->stat.st_size;
#line 1497
  tmp = xmalloc(size);
#line 1497
  archive_dir = (char *)tmp;
#line 1498
  to = archive_dir;
#line 1500
  set_next_block_after(current_header);
#line 1501
  mv_begin_read(stat_info);
  }
  {
#line 1503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1503
    if (! (size > 0UL)) {
#line 1503
      goto while_break;
    }
    {
#line 1505
    mv_size_left((off_t )size);
#line 1506
    data_block = find_next_block();
    }
#line 1507
    if (! data_block) {
      {
#line 1508
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1508
        if (error_hook) {
          {
#line 1508
          (*error_hook)();
          }
        }
        {
#line 1508
        tmp___0 = gettext("Unexpected EOF in archive");
#line 1508
        error(1, 0, (char const   *)tmp___0);
#line 1508
        exit_status = 2;
        }
#line 1508
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1509
    copied = available_space_after(data_block);
    }
#line 1510
    if (copied > size) {
#line 1511
      copied = size;
    }
    {
#line 1512
    memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)(data_block->buffer),
           copied);
#line 1513
    to += copied;
#line 1514
    set_next_block_after((union block *)((data_block->buffer + copied) - 1));
#line 1503
    size -= copied;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1518
  mv_end();
#line 1520
  stat_info->dumpdir = archive_dir;
#line 1521
  stat_info->skipped = (_Bool)1;
  }
#line 1523
  return;
}
}
#line 1528 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
_Bool is_dumpdir(struct tar_stat_info *stat_info ) 
{ 


  {
#line 1531
  if (stat_info->is_dumpdir) {
#line 1531
    if (! stat_info->dumpdir) {
      {
#line 1532
      get_gnu_dumpdir(stat_info);
      }
    }
  }
#line 1533
  return (stat_info->is_dumpdir);
}
}
#line 1536 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static _Bool dumpdir_ok(char *dumpdir ) 
{ 
  char *p ;
  int has_tempdir ;
  int expect ;
  size_t tmp ;
  unsigned char uc ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 1540
  has_tempdir = 0;
#line 1541
  expect = 0;
#line 1543
  p = dumpdir;
  {
#line 1543
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1543
    if (! *p) {
#line 1543
      goto while_break;
    }
#line 1545
    if (expect) {
#line 1545
      if ((int )*p != expect) {
#line 1547
        uc = (unsigned char )*p;
        {
#line 1548
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1548
          if (error_hook) {
            {
#line 1548
            (*error_hook)();
            }
          }
          {
#line 1548
          tmp___0 = gettext("Malformed dumpdir: expected \'%c\' but found %#3o");
#line 1548
          error(0, 0, (char const   *)tmp___0, expect, (int )uc);
#line 1548
          exit_status = 2;
          }
#line 1548
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1551
        return ((_Bool)0);
      }
    }
    {
#line 1555
    if ((int )*p == 88) {
#line 1555
      goto case_88;
    }
#line 1566
    if ((int )*p == 82) {
#line 1566
      goto case_82;
    }
#line 1581
    if ((int )*p == 84) {
#line 1581
      goto case_84;
    }
#line 1599
    if ((int )*p == 68) {
#line 1599
      goto case_68;
    }
#line 1599
    if ((int )*p == 89) {
#line 1599
      goto case_68;
    }
#line 1599
    if ((int )*p == 78) {
#line 1599
      goto case_68;
    }
#line 1602
    goto switch_default;
    case_88: /* CIL Label */ 
#line 1556
    if (has_tempdir) {
      {
#line 1558
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1558
        if (error_hook) {
          {
#line 1558
          (*error_hook)();
          }
        }
        {
#line 1558
        tmp___1 = gettext("Malformed dumpdir: \'X\' duplicated");
#line 1558
        error(0, 0, (char const   *)tmp___1);
#line 1558
        exit_status = 2;
        }
#line 1558
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1560
      return ((_Bool)0);
    } else {
#line 1563
      has_tempdir = 1;
    }
#line 1564
    goto switch_break;
    case_82: /* CIL Label */ 
#line 1567
    if ((int )*(p + 1) == 0) {
#line 1569
      if (! has_tempdir) {
        {
#line 1571
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1571
          if (error_hook) {
            {
#line 1571
            (*error_hook)();
            }
          }
          {
#line 1571
          tmp___2 = gettext("Malformed dumpdir: empty name in \'R\'");
#line 1571
          error(0, 0, (char const   *)tmp___2);
#line 1571
          exit_status = 2;
          }
#line 1571
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1573
        return ((_Bool)0);
      } else {
#line 1576
        has_tempdir = 0;
      }
    }
#line 1578
    expect = 'T';
#line 1579
    goto switch_break;
    case_84: /* CIL Label */ 
#line 1582
    if (expect != 84) {
      {
#line 1584
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1584
        if (error_hook) {
          {
#line 1584
          (*error_hook)();
          }
        }
        {
#line 1584
        tmp___3 = gettext("Malformed dumpdir: \'T\' not preceded by \'R\'");
#line 1584
        error(0, 0, (char const   *)tmp___3);
#line 1584
        exit_status = 2;
        }
#line 1584
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1586
      return ((_Bool)0);
    }
#line 1588
    if ((int )*(p + 1) == 0) {
#line 1588
      if (! has_tempdir) {
        {
#line 1590
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1590
          if (error_hook) {
            {
#line 1590
            (*error_hook)();
            }
          }
          {
#line 1590
          tmp___4 = gettext("Malformed dumpdir: empty name in \'T\'");
#line 1590
          error(0, 0, (char const   *)tmp___4);
#line 1590
          exit_status = 2;
          }
#line 1590
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1592
        return ((_Bool)0);
      }
    }
#line 1594
    expect = 0;
#line 1595
    goto switch_break;
    case_68: /* CIL Label */ 
    case_89: /* CIL Label */ 
    case_78: /* CIL Label */ 
#line 1600
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1604
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1543
    tmp = strlen((char const   *)p);
#line 1543
    p += tmp + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1608
  if (expect) {
    {
#line 1610
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1610
      if (error_hook) {
        {
#line 1610
        (*error_hook)();
        }
      }
      {
#line 1610
      tmp___5 = gettext("Malformed dumpdir: expected \'%c\' but found end of data");
#line 1610
      error(0, 0, (char const   *)tmp___5, expect);
#line 1610
      exit_status = 2;
      }
#line 1610
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1613
    return ((_Bool)0);
  }
#line 1616
  if (has_tempdir) {
    {
#line 1617
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1617
      if (warning_option & 2) {
        {
#line 1617
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 1617
          if (error_hook) {
            {
#line 1617
            (*error_hook)();
            }
          }
          {
#line 1617
          tmp___6 = gettext("Malformed dumpdir: \'X\' never used");
#line 1617
          error(0, 0, (char const   *)tmp___6);
          }
#line 1617
          goto while_break___7;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1617
      goto while_break___6;
    }
    while_break___6: /* CIL Label */ ;
    }
  }
#line 1620
  return ((_Bool)1);
}
}
#line 1625 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
static _Bool try_purge_directory(char const   *directory_name ) 
{ 
  char *current_dir ;
  char *cur ;
  char *arc ;
  char *p ;
  char *temp_stub ;
  struct dumpdir *dump ;
  _Bool tmp ;
  _Bool tmp___0 ;
  size_t tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  char *tmp___7 ;
  char *src ;
  char *dst ;
  size_t tmp___8 ;
  _Bool tmp___9 ;
  size_t tmp___10 ;
  char const   *entry___0 ;
  struct stat st ;
  char *tmp___11 ;
  char *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  char const   *tmp___17 ;
  char *tmp___18 ;
  int e ;
  int *tmp___19 ;
  char *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;

  {
  {
#line 1630
  temp_stub = (char *)((void *)0);
#line 1633
  tmp = is_dumpdir(& current_stat_info);
  }
#line 1633
  if (! tmp) {
#line 1634
    return ((_Bool)0);
  }
  {
#line 1636
  current_dir = tar_savedir(directory_name, 0);
  }
#line 1638
  if (! current_dir) {
#line 1641
    return ((_Bool)0);
  }
  {
#line 1644
  tmp___0 = dumpdir_ok(current_stat_info.dumpdir);
  }
#line 1644
  if (! tmp___0) {
#line 1645
    return ((_Bool)0);
  }
#line 1648
  arc = current_stat_info.dumpdir;
  {
#line 1648
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1648
    if (! *arc) {
#line 1648
      goto while_break;
    }
#line 1650
    if ((int )*arc == 88) {
      {
#line 1653
      tmp___2 = strlen((char const   *)(arc + 1));
#line 1653
      len = tmp___2;
#line 1654
      tmp___3 = xrealloc((void *)temp_stub, (len + 1UL) + sizeof("tar.XXXXXX"));
#line 1654
      temp_stub = (char *)tmp___3;
#line 1655
      memcpy((void */* __restrict  */)temp_stub, (void const   */* __restrict  */)(arc + 1),
             len);
#line 1656
      *(temp_stub + len) = (char )'/';
#line 1657
      memcpy((void */* __restrict  */)((temp_stub + len) + 1), (void const   */* __restrict  */)"tar.XXXXXX",
             sizeof("tar.XXXXXX"));
#line 1659
      tmp___7 = mkdtemp(temp_stub);
      }
#line 1659
      if (! tmp___7) {
        {
#line 1661
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1661
          if (error_hook) {
            {
#line 1661
            (*error_hook)();
            }
          }
          {
#line 1661
          tmp___4 = quote((char const   *)temp_stub);
#line 1661
          tmp___5 = gettext("Cannot create temporary directory using template %s");
#line 1661
          tmp___6 = __errno_location();
#line 1661
          error(0, *tmp___6, (char const   *)tmp___5, tmp___4);
#line 1661
          exit_status = 2;
          }
#line 1661
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 1664
        free((void *)temp_stub);
#line 1665
        free((void *)current_dir);
        }
#line 1666
        return ((_Bool)0);
      }
    } else
#line 1669
    if ((int )*arc == 82) {
      {
#line 1672
      src = arc + 1;
#line 1673
      tmp___8 = strlen((char const   *)arc);
#line 1673
      arc += tmp___8 + 1UL;
#line 1674
      dst = arc + 1;
      }
#line 1684
      if (*src) {
        {
#line 1685
        src = safer_name_suffix((char const   *)src, (_Bool)0, absolute_names_option);
        }
      }
#line 1686
      if (*dst) {
        {
#line 1687
        dst = safer_name_suffix((char const   *)dst, (_Bool)0, absolute_names_option);
        }
      }
#line 1689
      if ((int )*src == 0) {
#line 1690
        src = temp_stub;
      } else
#line 1691
      if ((int )*dst == 0) {
#line 1692
        dst = temp_stub;
      }
      {
#line 1694
      tmp___9 = rename_directory(src, dst);
      }
#line 1694
      if (! tmp___9) {
        {
#line 1696
        free((void *)temp_stub);
#line 1697
        free((void *)current_dir);
        }
#line 1700
        return ((_Bool)0);
      }
    }
    {
#line 1648
    tmp___1 = strlen((char const   *)arc);
#line 1648
    arc += tmp___1 + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1705
  free((void *)temp_stub);
#line 1708
  dump = dumpdir_create((char const   *)current_stat_info.dumpdir);
#line 1709
  p = (char *)((void *)0);
#line 1710
  cur = current_dir;
  }
  {
#line 1710
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1710
    if (! *cur) {
#line 1710
      goto while_break___1;
    }
    {
#line 1714
    free((void *)p);
#line 1715
    p = make_file_name(directory_name, (char const   *)cur);
#line 1717
    tmp___14 = deref_stat((char const   *)p, & st);
    }
#line 1717
    if (tmp___14 != 0) {
      {
#line 1719
      tmp___13 = __errno_location();
      }
#line 1719
      if (*tmp___13 != 2) {
        {
#line 1722
        stat_diag((char const   *)p);
        }
        {
#line 1723
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1723
          if (error_hook) {
            {
#line 1723
            (*error_hook)();
            }
          }
          {
#line 1723
          tmp___11 = quotearg_colon((char const   *)p);
#line 1723
          tmp___12 = gettext("%s: Not purging directory: unable to stat");
#line 1723
          error(0, 0, (char const   *)tmp___12, tmp___11);
          }
#line 1723
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1726
      goto __Cont;
    }
    {
#line 1729
    tmp___24 = dumpdir_locate(dump, (char const   *)cur);
#line 1729
    entry___0 = (char const   *)tmp___24;
    }
#line 1729
    if (entry___0) {
#line 1729
      if ((int const   )*entry___0 == 68) {
#line 1729
        if (! ((st.st_mode & 61440U) == 16384U)) {
#line 1729
          goto _L___0;
        } else {
#line 1729
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1729
      if ((int const   )*entry___0 == 89) {
#line 1729
        if ((st.st_mode & 61440U) == 16384U) {
          _L___0: /* CIL Label */ 
#line 1733
          if (one_file_system_option) {
#line 1733
            if (st.st_dev != root_device) {
              {
#line 1735
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 1735
                if (error_hook) {
                  {
#line 1735
                  (*error_hook)();
                  }
                }
                {
#line 1735
                tmp___15 = quotearg_colon((char const   *)p);
#line 1735
                tmp___16 = gettext("%s: directory is on a different device: not purging");
#line 1735
                error(0, 0, (char const   *)tmp___16, tmp___15);
                }
#line 1735
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
#line 1738
              goto __Cont;
            }
          }
#line 1741
          if (! interactive_option) {
#line 1741
            goto _L;
          } else {
            {
#line 1741
            tmp___23 = confirm("delete", (char const   *)p);
            }
#line 1741
            if (tmp___23) {
              _L: /* CIL Label */ 
#line 1743
              if (verbose_option) {
                {
#line 1744
                tmp___17 = quote((char const   *)p);
#line 1744
                tmp___18 = gettext("%s: Deleting %s\n");
#line 1744
                fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp___18,
                        program_name, tmp___17);
                }
              }
              {
#line 1746
              tmp___22 = remove_any_file((char const   *)p, (enum remove_option )1);
              }
#line 1746
              if (! tmp___22) {
                {
#line 1748
                tmp___19 = __errno_location();
#line 1748
                e = *tmp___19;
                }
                {
#line 1749
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 1749
                  if (error_hook) {
                    {
#line 1749
                    (*error_hook)();
                    }
                  }
                  {
#line 1749
                  tmp___20 = quotearg_colon((char const   *)p);
#line 1749
                  tmp___21 = gettext("%s: Cannot remove");
#line 1749
                  error(0, e, (char const   *)tmp___21, tmp___20);
#line 1749
                  exit_status = 2;
                  }
#line 1749
                  goto while_break___4;
                }
                while_break___4: /* CIL Label */ ;
                }
              }
            }
          }
        }
      }
    } else {
#line 1729
      goto _L___0;
    }
    __Cont: /* CIL Label */ 
    {
#line 1710
    tmp___10 = strlen((char const   *)cur);
#line 1710
    cur += tmp___10 + 1UL;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1754
  free((void *)p);
#line 1755
  dumpdir_free(dump);
#line 1757
  free((void *)current_dir);
  }
#line 1758
  return ((_Bool)1);
}
}
#line 1761 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void purge_directory(char const   *directory_name ) 
{ 
  _Bool tmp ;

  {
  {
#line 1764
  tmp = try_purge_directory(directory_name);
  }
#line 1764
  if (! tmp) {
    {
#line 1765
    skip_member();
    }
  }
#line 1766
  return;
}
}
#line 1768 "/home/khheo/project/benchmark/tar-1.29/src/incremen.c"
void list_dumpdir(char *buffer___1 , size_t size ) 
{ 
  int state ;

  {
#line 1771
  state = 0;
  {
#line 1772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1772
    if (! size) {
#line 1772
      goto while_break;
    }
    {
#line 1781
    if ((int )*buffer___1 == 88) {
#line 1781
      goto case_88;
    }
#line 1781
    if ((int )*buffer___1 == 84) {
#line 1781
      goto case_88;
    }
#line 1781
    if ((int )*buffer___1 == 82) {
#line 1781
      goto case_88;
    }
#line 1781
    if ((int )*buffer___1 == 68) {
#line 1781
      goto case_88;
    }
#line 1781
    if ((int )*buffer___1 == 78) {
#line 1781
      goto case_88;
    }
#line 1781
    if ((int )*buffer___1 == 89) {
#line 1781
      goto case_88;
    }
#line 1792
    if ((int )*buffer___1 == 0) {
#line 1792
      goto case_0;
    }
#line 1799
    goto switch_default;
    case_88: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_82: /* CIL Label */ 
    case_68: /* CIL Label */ 
    case_78: /* CIL Label */ 
    case_89: /* CIL Label */ 
    {
#line 1782
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%c",
            (int )*buffer___1);
    }
#line 1783
    if (state == 0) {
      {
#line 1785
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)" ");
#line 1786
      state = 1;
      }
    }
#line 1788
    buffer___1 ++;
#line 1789
    size --;
#line 1790
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1793
    fputc_unlocked('\n', stdlis);
#line 1794
    buffer___1 ++;
#line 1795
    size --;
#line 1796
    state = 0;
    }
#line 1797
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1800
    fputc_unlocked((int )*buffer___1, stdlis);
#line 1801
    buffer___1 ++;
#line 1802
    size --;
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1805
  return;
}
}
#line 335 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 440
char *continued_file_name ;
#line 441
uintmax_t continued_file_size ;
#line 442
uintmax_t continued_file_offset ;
#line 507
void simple_finish_header(union block *header ) ;
#line 510
union block *start_private_header(char const   *name , size_t size , time_t t ) ;
#line 824
void xheader_write(char type , char *name , time_t t , struct xheader *xhdr ) ;
#line 825
void xheader_write_global(struct xheader *xhdr ) ;
#line 826
void xheader_finish(struct xheader *xhdr ) ;
#line 828
char *xheader_xhdr_name(struct tar_stat_info *st ) ;
#line 829
char *xheader_ghdr_name(void) ;
#line 839
void xheader_xattr_copy(struct tar_stat_info  const  *st , struct xattr_array **xattr_map ,
                        size_t *xattr_map_size ) ;
#line 974
#pragma GCC diagnostic pop
#line 30 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_init(struct xheader *xhdr ) ;
#line 31
static _Bool xheader_protected_pattern_p(char const   *pattern ) ;
#line 32
static _Bool xheader_protected_keyword_p(char const   *keyword ) ;
#line 33
static  __attribute__((__noreturn__)) void xheader_set_single_keyword(char *kw ) ;
#line 36
static void code_string(char const   *string , char const   *keyword , struct xheader *xhdr ) ;
#line 40 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static size_t global_header_count  ;
#line 55 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void x_obstack_grow(struct xheader *xhdr , char const   *ptr , size_t length ) 
{ 
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;

  {
#line 58
  __o = xhdr->stk;
#line 58
  __len = length;
#line 58
  __o1 = (struct obstack  const  *)__o;
#line 58
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 58
    _obstack_newchunk(__o, __len);
    }
  }
  {
#line 58
  memcpy((void */* __restrict  */)__o->next_free, (void const   */* __restrict  */)ptr,
         __len);
#line 58
  __o->next_free += __len;
#line 59
  xhdr->size += length;
  }
#line 60
  return;
}
}
#line 62 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void x_obstack_1grow(struct xheader *xhdr , char c ) 
{ 
  struct obstack *__o ;
  struct obstack  const  *__o1 ;
  char *tmp ;

  {
#line 65
  __o = xhdr->stk;
#line 65
  __o1 = (struct obstack  const  *)__o;
#line 65
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < 1UL) {
    {
#line 65
    _obstack_newchunk(__o, (size_t )1);
    }
  }
#line 65
  tmp = __o->next_free;
#line 65
  (__o->next_free) ++;
#line 65
  *tmp = c;
#line 66
  (xhdr->size) ++;
#line 67
  return;
}
}
#line 69 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void x_obstack_blank(struct xheader *xhdr , size_t length ) 
{ 
  struct obstack *__o ;
  size_t __len ;
  struct obstack  const  *__o1 ;

  {
#line 72
  __o = xhdr->stk;
#line 72
  __len = length;
#line 72
  __o1 = (struct obstack  const  *)__o;
#line 72
  if ((size_t )(__o1->chunk_limit - __o1->next_free) < __len) {
    {
#line 72
    _obstack_newchunk(__o, __len);
    }
  }
#line 72
  __o->next_free += __len;
#line 73
  xhdr->size += length;
#line 74
  return;
}
}
#line 88 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static struct keyword_list *keyword_pattern_list  ;
#line 91 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static struct keyword_list *keyword_global_override_list  ;
#line 94 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static struct keyword_list *keyword_override_list  ;
#line 97 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static struct keyword_list *global_header_override_list  ;
#line 100 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static char *exthdr_name  ;
#line 102 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static char *exthdr_mtime_option  ;
#line 103 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static time_t exthdr_mtime  ;
#line 106 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static char *globexthdr_name  ;
#line 108 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static char *globexthdr_mtime_option  ;
#line 109 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static time_t globexthdr_mtime  ;
#line 111 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
_Bool xheader_keyword_deleted_p(char const   *kw ) 
{ 
  struct keyword_list *kp ;
  int tmp ;

  {
#line 116
  kp = keyword_pattern_list;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! kp) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp = fnmatch((char const   *)kp->pattern, kw, 0);
    }
#line 117
    if (tmp == 0) {
#line 118
      return ((_Bool)1);
    }
#line 116
    kp = kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return ((_Bool)0);
}
}
#line 122 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool xheader_keyword_override_p(char const   *keyword ) 
{ 
  struct keyword_list *kp ;
  int tmp ;

  {
#line 127
  kp = keyword_override_list;
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! kp) {
#line 127
      goto while_break;
    }
    {
#line 128
    tmp = strcmp((char const   *)kp->pattern, keyword);
    }
#line 128
    if (tmp == 0) {
#line 129
      return ((_Bool)1);
    }
#line 127
    kp = kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return ((_Bool)0);
}
}
#line 133 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_list_append(struct keyword_list **root , char const   *kw , char const   *value___0 ) 
{ 
  struct keyword_list *kp ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 137
  tmp = xmalloc(sizeof(*kp));
#line 137
  kp = (struct keyword_list *)tmp;
#line 138
  kp->pattern = xstrdup(kw);
  }
#line 139
  if (value___0) {
    {
#line 139
    tmp___0 = xstrdup(value___0);
#line 139
    kp->value = tmp___0;
    }
  } else {
#line 139
    kp->value = (char *)((void *)0);
  }
#line 140
  kp->next = *root;
#line 141
  *root = kp;
#line 142
  return;
}
}
#line 144 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_list_destroy(struct keyword_list **root ) 
{ 
  struct keyword_list *kw ;
  struct keyword_list *next ;

  {
#line 147
  if (root) {
#line 149
    kw = *root;
    {
#line 150
    while (1) {
      while_continue: /* CIL Label */ ;
#line 150
      if (! kw) {
#line 150
        goto while_break;
      }
      {
#line 152
      next = kw->next;
#line 153
      free((void *)kw->pattern);
#line 154
      free((void *)kw->value);
#line 155
      free((void *)kw);
#line 156
      kw = next;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 158
    *root = (struct keyword_list *)((void *)0);
  }
#line 160
  return;
}
}
#line 162
static  __attribute__((__noreturn__)) void xheader_set_single_keyword(char *kw ) ;
#line 162 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_set_single_keyword(char *kw ) 
{ 
  char *tmp ;

  {
  {
#line 165
  while (1) {
    while_continue: /* CIL Label */ ;
#line 165
    if (error_hook) {
      {
#line 165
      (*error_hook)();
      }
    }
    {
#line 165
    tmp = gettext("Keyword %s is unknown or not yet implemented");
#line 165
    error(0, 0, (char const   *)tmp, kw);
#line 165
    usage(2);
    }
#line 165
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 168 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void assign_time_option(char **sval , time_t *tval , char const   *input ) 
{ 
  char *p ;
  struct timespec t ;
  struct timespec tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 172
  tmp = decode_timespec(input, & p, (_Bool)0);
#line 172
  t = tmp;
#line 173
  tmp___1 = valid_timespec(t);
  }
#line 173
  if (tmp___1) {
#line 173
    if (*p) {
      _L: /* CIL Label */ 
      {
#line 174
      while (1) {
        while_continue: /* CIL Label */ ;
#line 174
        if (error_hook) {
          {
#line 174
          (*error_hook)();
          }
        }
        {
#line 174
        tmp___0 = gettext("Time stamp is out of allowed range");
#line 174
        error(0, 0, (char const   *)tmp___0);
#line 174
        exit_status = 2;
        }
#line 174
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 177
      *tval = t.tv_sec;
#line 178
      assign_string(sval, input);
      }
    }
  } else {
#line 173
    goto _L;
  }
#line 180
  return;
}
}
#line 182 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_set_keyword_equal(char *kw , char *eq ) 
{ 
  _Bool global ;
  char *p ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 185
  global = (_Bool)1;
#line 186
  p = eq;
#line 188
  if ((int )*(eq + -1) == 58) {
#line 190
    p --;
#line 191
    global = (_Bool)0;
  }
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if ((unsigned long )p > (unsigned long )kw) {
      {
#line 194
      tmp = __ctype_b_loc();
      }
#line 194
      if (! ((int const   )*(*tmp + (int )((unsigned char )*p)) & 8192)) {
#line 194
        goto while_break;
      }
    } else {
#line 194
      goto while_break;
    }
#line 195
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  *p = (char)0;
#line 199
  p = eq + 1;
  {
#line 199
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 199
    if (*p) {
      {
#line 199
      tmp___0 = __ctype_b_loc();
      }
#line 199
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 8192)) {
#line 199
        goto while_break___0;
      }
    } else {
#line 199
      goto while_break___0;
    }
#line 199
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 202
  tmp___10 = strcmp((char const   *)kw, "delete");
  }
#line 202
  if (tmp___10 == 0) {
    {
#line 204
    tmp___3 = xheader_protected_pattern_p((char const   *)p);
    }
#line 204
    if (tmp___3) {
      {
#line 205
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 205
        if (error_hook) {
          {
#line 205
          (*error_hook)();
          }
        }
        {
#line 205
        tmp___1 = quote((char const   *)p);
#line 205
        tmp___2 = gettext("Pattern %s cannot be used");
#line 205
        error(0, 0, (char const   *)tmp___2, tmp___1);
#line 205
        usage(2);
        }
#line 205
        goto while_break___1;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 206
    xheader_list_append(& keyword_pattern_list, (char const   *)p, (char const   *)((void *)0));
    }
  } else {
    {
#line 208
    tmp___9 = strcmp((char const   *)kw, "exthdr.name");
    }
#line 208
    if (tmp___9 == 0) {
      {
#line 209
      assign_string(& exthdr_name, (char const   *)p);
      }
    } else {
      {
#line 210
      tmp___8 = strcmp((char const   *)kw, "globexthdr.name");
      }
#line 210
      if (tmp___8 == 0) {
        {
#line 211
        assign_string(& globexthdr_name, (char const   *)p);
        }
      } else {
        {
#line 212
        tmp___7 = strcmp((char const   *)kw, "exthdr.mtime");
        }
#line 212
        if (tmp___7 == 0) {
          {
#line 213
          assign_time_option(& exthdr_mtime_option, & exthdr_mtime, (char const   *)p);
          }
        } else {
          {
#line 214
          tmp___6 = strcmp((char const   *)kw, "globexthdr.mtime");
          }
#line 214
          if (tmp___6 == 0) {
            {
#line 215
            assign_time_option(& globexthdr_mtime_option, & globexthdr_mtime, (char const   *)p);
            }
          } else {
            {
#line 218
            tmp___5 = xheader_protected_keyword_p((char const   *)kw);
            }
#line 218
            if (tmp___5) {
              {
#line 219
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 219
                if (error_hook) {
                  {
#line 219
                  (*error_hook)();
                  }
                }
                {
#line 219
                tmp___4 = gettext("Keyword %s cannot be overridden");
#line 219
                error(0, 0, (char const   *)tmp___4, kw);
#line 219
                usage(2);
                }
#line 219
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
            }
#line 220
            if (global) {
              {
#line 221
              xheader_list_append(& keyword_global_override_list, (char const   *)kw,
                                  (char const   *)p);
              }
            } else {
              {
#line 223
              xheader_list_append(& keyword_override_list, (char const   *)kw, (char const   *)p);
              }
            }
          }
        }
      }
    }
  }
#line 225
  return;
}
}
#line 227 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_set_option(char *string ) 
{ 
  char *token ;
  char *p ;
  char *tmp ;

  {
  {
#line 231
  token = strtok((char */* __restrict  */)string, (char const   */* __restrict  */)",");
  }
  {
#line 231
  while (1) {
    while_continue: /* CIL Label */ ;
#line 231
    if (! token) {
#line 231
      goto while_break;
    }
    {
#line 233
    tmp = strchr((char const   *)token, '=');
#line 233
    p = tmp;
    }
#line 234
    if (! p) {
      {
#line 235
      xheader_set_single_keyword(token);
      }
    } else {
      {
#line 237
      xheader_set_keyword_equal(token, p);
      }
    }
    {
#line 231
    token = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 239
  return;
}
}
#line 254 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
char *xheader_format_name(struct tar_stat_info *st , char const   *fmt , size_t n ) 
{ 
  char *buf ;
  size_t len ;
  size_t tmp ;
  char *q ;
  char const   *p ;
  char *dirp ;
  char *dir ;
  char *base ;
  char pidbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char const   *pptr ;
  char nbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char const   *nptr ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  __pid_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;
  char *tmp___13 ;
  char const   *tmp___14 ;

  {
  {
#line 258
  tmp = strlen(fmt);
#line 258
  len = tmp;
#line 261
  dirp = (char *)((void *)0);
#line 262
  dir = (char *)((void *)0);
#line 263
  base = (char *)((void *)0);
#line 265
  pptr = (char const   *)((void *)0);
#line 267
  nptr = (char const   *)((void *)0);
#line 269
  p = fmt;
  }
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (*p) {
      {
#line 269
      tmp___5 = strchr(p, '%');
#line 269
      p = (char const   *)tmp___5;
      }
#line 269
      if (! p) {
#line 269
        goto while_break;
      }
    } else {
#line 269
      goto while_break;
    }
    {
#line 273
    if ((int const   )*(p + 1) == 37) {
#line 273
      goto case_37;
    }
#line 277
    if ((int const   )*(p + 1) == 100) {
#line 277
      goto case_100;
    }
#line 287
    if ((int const   )*(p + 1) == 102) {
#line 287
      goto case_102;
    }
#line 295
    if ((int const   )*(p + 1) == 112) {
#line 295
      goto case_112;
    }
#line 300
    if ((int const   )*(p + 1) == 110) {
#line 300
      goto case_110;
    }
#line 271
    goto switch_break;
    case_37: /* CIL Label */ 
#line 274
    len --;
#line 275
    goto switch_break;
    case_100: /* CIL Label */ 
#line 278
    if (st) {
#line 280
      if (! dirp) {
        {
#line 281
        dirp = dir_name((char const   *)st->orig_file_name);
        }
      }
      {
#line 282
      dir = safer_name_suffix((char const   *)dirp, (_Bool)0, absolute_names_option);
#line 283
      tmp___0 = strlen((char const   *)dir);
#line 283
      len += tmp___0 - 2UL;
      }
    }
#line 285
    goto switch_break;
    case_102: /* CIL Label */ 
#line 288
    if (st) {
      {
#line 290
      base = last_component((char const   *)st->orig_file_name);
#line 291
      tmp___1 = strlen((char const   *)base);
#line 291
      len += tmp___1 - 2UL;
      }
    }
#line 293
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 296
    tmp___2 = getpid();
#line 296
    tmp___3 = umaxtostr((uintmax_t )tmp___2, pidbuf);
#line 296
    pptr = (char const   *)tmp___3;
#line 297
    len += (size_t )((((pidbuf + sizeof(pidbuf)) - 1) - (char *)pptr) - 2L);
    }
#line 298
    goto switch_break;
    case_110: /* CIL Label */ 
    {
#line 301
    tmp___4 = umaxtostr(n, nbuf);
#line 301
    nptr = (char const   *)tmp___4;
#line 302
    len += (size_t )((((nbuf + sizeof(nbuf)) - 1) - (char *)nptr) - 2L);
    }
#line 303
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 305
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 308
  tmp___6 = xmalloc(len + 1UL);
#line 308
  buf = (char *)tmp___6;
#line 309
  q = buf;
#line 309
  p = fmt;
  }
  {
#line 309
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 309
    if (! *p) {
#line 309
      goto while_break___0;
    }
#line 311
    if ((int const   )*p == 37) {
      {
#line 315
      if ((int const   )*(p + 1) == 37) {
#line 315
        goto case_37___0;
      }
#line 320
      if ((int const   )*(p + 1) == 100) {
#line 320
        goto case_100___0;
      }
#line 326
      if ((int const   )*(p + 1) == 102) {
#line 326
        goto case_102___0;
      }
#line 332
      if ((int const   )*(p + 1) == 112) {
#line 332
        goto case_112___0;
      }
#line 337
      if ((int const   )*(p + 1) == 110) {
#line 337
        goto case_110___0;
      }
#line 343
      goto switch_default;
      case_37___0: /* CIL Label */ 
#line 316
      tmp___7 = q;
#line 316
      q ++;
#line 316
      tmp___8 = p;
#line 316
      p ++;
#line 316
      *tmp___7 = (char )*tmp___8;
#line 317
      p ++;
#line 318
      goto switch_break___0;
      case_100___0: /* CIL Label */ 
#line 321
      if (dir) {
        {
#line 322
        q = stpcpy((char */* __restrict  */)q, (char const   */* __restrict  */)dir);
        }
      }
#line 323
      p += 2;
#line 324
      goto switch_break___0;
      case_102___0: /* CIL Label */ 
#line 327
      if (base) {
        {
#line 328
        q = stpcpy((char */* __restrict  */)q, (char const   */* __restrict  */)base);
        }
      }
#line 329
      p += 2;
#line 330
      goto switch_break___0;
      case_112___0: /* CIL Label */ 
      {
#line 333
      q = stpcpy((char */* __restrict  */)q, (char const   */* __restrict  */)pptr);
#line 334
      p += 2;
      }
#line 335
      goto switch_break___0;
      case_110___0: /* CIL Label */ 
      {
#line 338
      q = stpcpy((char */* __restrict  */)q, (char const   */* __restrict  */)nptr);
#line 339
      p += 2;
      }
#line 340
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 344
      tmp___9 = q;
#line 344
      q ++;
#line 344
      tmp___10 = p;
#line 344
      p ++;
#line 344
      *tmp___9 = (char )*tmp___10;
#line 345
      if (*p) {
#line 346
        tmp___11 = q;
#line 346
        q ++;
#line 346
        tmp___12 = p;
#line 346
        p ++;
#line 346
        *tmp___11 = (char )*tmp___12;
      }
      switch_break___0: /* CIL Label */ ;
      }
    } else {
#line 350
      tmp___13 = q;
#line 350
      q ++;
#line 350
      tmp___14 = p;
#line 350
      p ++;
#line 350
      *tmp___13 = (char )*tmp___14;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 353
  free((void *)dirp);
  }
  {
#line 356
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 356
    if ((unsigned long )q > (unsigned long )buf) {
#line 356
      if (! ((int )*(q + -1) == 47)) {
#line 356
        goto while_break___1;
      }
    } else {
#line 356
      goto while_break___1;
    }
#line 357
    q --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 358
  *q = (char)0;
#line 359
  return (buf);
}
}
#line 362 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
char *xheader_xhdr_name(struct tar_stat_info *st ) 
{ 
  char *tmp ;

  {
#line 365
  if (! exthdr_name) {
    {
#line 366
    assign_string(& exthdr_name, "%d/PaxHeaders.%p/%f");
    }
  }
  {
#line 367
  tmp = xheader_format_name(st, (char const   *)exthdr_name, (size_t )0);
  }
#line 367
  return (tmp);
}
}
#line 372 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
char *xheader_ghdr_name(void) 
{ 
  size_t len ;
  char const   *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 375
  if (! globexthdr_name) {
    {
#line 378
    tmp___0 = getenv("TMPDIR");
#line 378
    tmp = (char const   *)tmp___0;
    }
#line 379
    if (! tmp) {
#line 380
      tmp = "/tmp";
    }
    {
#line 381
    tmp___1 = strlen(tmp);
#line 381
    len = tmp___1 + sizeof("/GlobalHead.%p.%n");
#line 382
    tmp___2 = xmalloc(len);
#line 382
    globexthdr_name = (char *)tmp___2;
#line 383
    strcpy((char */* __restrict  */)globexthdr_name, (char const   */* __restrict  */)tmp);
#line 384
    strcat((char */* __restrict  */)globexthdr_name, (char const   */* __restrict  */)"/GlobalHead.%p.%n");
    }
  }
  {
#line 387
  tmp___3 = xheader_format_name((struct tar_stat_info *)((void *)0), (char const   *)globexthdr_name,
                                global_header_count + 1UL);
  }
#line 387
  return (tmp___3);
}
}
#line 390 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_write(char type , char *name , time_t t , struct xheader *xhdr ) 
{ 
  union block *header ;
  size_t size ;
  char *p ;
  size_t len ;

  {
#line 397
  size = xhdr->size;
  {
#line 400
  if ((int )type == 103) {
#line 400
    goto case_103;
  }
#line 405
  if ((int )type == 120) {
#line 405
    goto case_120;
  }
#line 398
  goto switch_break;
  case_103: /* CIL Label */ 
#line 401
  if (globexthdr_mtime_option) {
#line 402
    t = globexthdr_mtime;
  }
#line 403
  goto switch_break;
  case_120: /* CIL Label */ 
#line 406
  if (exthdr_mtime_option) {
#line 407
    t = exthdr_mtime;
  }
#line 408
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 410
  header = start_private_header((char const   *)name, size, t);
#line 411
  header->header.typeflag = type;
#line 413
  simple_finish_header(header);
#line 415
  p = xhdr->buffer;
  }
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 421
    header = find_next_block();
#line 422
    len = (size_t )512;
    }
#line 423
    if (len > size) {
#line 424
      len = size;
    }
    {
#line 425
    memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)p,
           len);
    }
#line 426
    if (len < 512UL) {
      {
#line 427
      memset((void *)(header->buffer + len), 0, 512UL - len);
      }
    }
    {
#line 428
    p += len;
#line 429
    size -= len;
#line 430
    set_next_block_after(header);
    }
#line 417
    if (! (size > 0UL)) {
#line 417
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 433
  xheader_destroy(xhdr);
  }
#line 435
  if ((int )type == 103) {
#line 436
    global_header_count ++;
  }
#line 437
  return;
}
}
#line 439 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_write_global(struct xheader *xhdr ) 
{ 
  struct keyword_list *kp ;
  char *name ;

  {
#line 442
  if (keyword_global_override_list) {
    {
#line 446
    xheader_init(xhdr);
#line 447
    kp = keyword_global_override_list;
    }
    {
#line 447
    while (1) {
      while_continue: /* CIL Label */ ;
#line 447
      if (! kp) {
#line 447
        goto while_break;
      }
      {
#line 448
      code_string((char const   *)kp->value, (char const   *)kp->pattern, xhdr);
#line 447
      kp = kp->next;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 450
  if (xhdr->stk) {
    {
#line 454
    xheader_finish(xhdr);
#line 455
    name = xheader_ghdr_name();
#line 456
    xheader_write((char )'g', name, start_time.tv_sec, xhdr);
#line 457
    free((void *)name);
    }
  }
#line 459
  return;
}
}
#line 461 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_xattr_init(struct tar_stat_info *st ) 
{ 


  {
#line 464
  st->xattr_map = (struct xattr_array *)((void *)0);
#line 465
  st->xattr_map_size = (size_t )0;
#line 467
  st->acls_a_ptr = (char *)((void *)0);
#line 468
  st->acls_a_len = (size_t )0;
#line 469
  st->acls_d_ptr = (char *)((void *)0);
#line 470
  st->acls_d_len = (size_t )0;
#line 471
  st->cntx_name = (char *)((void *)0);
#line 472
  return;
}
}
#line 474 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_xattr_free(struct xattr_array *xattr_map , size_t xattr_map_size ) 
{ 
  size_t scan ;

  {
#line 477
  scan = (size_t )0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (scan < xattr_map_size)) {
#line 479
      goto while_break;
    }
    {
#line 481
    free((void *)(xattr_map + scan)->xkey);
#line 482
    free((void *)(xattr_map + scan)->xval_ptr);
#line 484
    scan ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 486
  free((void *)xattr_map);
  }
#line 487
  return;
}
}
#line 489 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_xattr__add(struct xattr_array **xattr_map , size_t *xattr_map_size ,
                               char const   *key , char const   *val___0 , size_t len ) 
{ 
  size_t pos ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 494
  tmp = *xattr_map_size;
#line 494
  (*xattr_map_size) ++;
#line 494
  pos = tmp;
#line 496
  tmp___0 = xrealloc((void *)*xattr_map, *xattr_map_size * sizeof(struct xattr_array ));
#line 496
  *xattr_map = (struct xattr_array *)tmp___0;
#line 498
  (*xattr_map + pos)->xkey = xstrdup(key);
#line 499
  tmp___1 = xmemdup((void const   *)val___0, len + 1UL);
#line 499
  (*xattr_map + pos)->xval_ptr = (char *)tmp___1;
#line 500
  (*xattr_map + pos)->xval_len = len;
  }
#line 501
  return;
}
}
#line 505 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_decode_keyword(char *keyword ) 
{ 
  char *kpr ;
  char *kpl ;

  {
#line 509
  kpl = keyword;
#line 509
  kpr = kpl;
  {
#line 511
  while (1) {
    while_continue: /* CIL Label */ ;
#line 513
    if ((int )*kpr == 37) {
#line 515
      if ((int )*(kpr + 1) == 51) {
#line 515
        if ((int )*(kpr + 2) == 68) {
#line 517
          *kpl = (char )'=';
#line 518
          kpr += 3;
#line 519
          kpl ++;
#line 520
          goto __Cont;
        } else {
#line 515
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 522
      if ((int )*(kpr + 1) == 50) {
#line 522
        if ((int )*(kpr + 2) == 53) {
#line 524
          *kpl = (char )'%';
#line 525
          kpr += 3;
#line 526
          kpl ++;
#line 527
          goto __Cont;
        }
      }
    }
#line 531
    *kpl = *kpr;
#line 533
    if ((int )*kpr == 0) {
#line 534
      goto while_break;
    }
#line 536
    kpr ++;
#line 537
    kpl ++;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return;
}
}
#line 541 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_xattr_add(struct tar_stat_info *st , char const   *key , char const   *val___0 ,
                       size_t len ) 
{ 
  size_t klen ;
  size_t tmp ;
  char *xkey ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 545
  tmp = strlen(key);
#line 545
  klen = tmp;
#line 546
  tmp___0 = strlen("SCHILY.xattr.");
#line 546
  tmp___1 = xmalloc((tmp___0 + klen) + 1UL);
#line 546
  xkey = (char *)tmp___1;
#line 547
  tmp___2 = xkey;
#line 549
  tmp___2 = stpcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)"SCHILY.xattr.");
#line 550
  stpcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)key);
#line 552
  xheader_xattr__add(& st->xattr_map, & st->xattr_map_size, (char const   *)xkey,
                     val___0, len);
#line 554
  free((void *)xkey);
  }
#line 555
  return;
}
}
#line 557 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_xattr_copy(struct tar_stat_info  const  *st , struct xattr_array **xattr_map ,
                        size_t *xattr_map_size ) 
{ 
  size_t scan ;
  char *key ;
  char *val___0 ;
  size_t len ;

  {
#line 561
  scan = (size_t )0;
#line 563
  *xattr_map = (struct xattr_array *)((void *)0);
#line 564
  *xattr_map_size = (size_t )0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (scan < (size_t )st->xattr_map_size)) {
#line 566
      goto while_break;
    }
    {
#line 568
    key = (st->xattr_map + scan)->xkey;
#line 569
    val___0 = (st->xattr_map + scan)->xval_ptr;
#line 570
    len = (st->xattr_map + scan)->xval_len;
#line 572
    xheader_xattr__add(xattr_map, xattr_map_size, (char const   *)key, (char const   *)val___0,
                       len);
#line 574
    scan ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return;
}
}
#line 600
struct xhdr_tab  const  xhdr_tab[31] ;
#line 602 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static struct xhdr_tab  const  *locate_handler(char const   *keyword ) 
{ 
  struct xhdr_tab  const  *p ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 607
  p = xhdr_tab;
  {
#line 607
  while (1) {
    while_continue: /* CIL Label */ ;
#line 607
    if (! p->keyword) {
#line 607
      goto while_break;
    }
#line 608
    if (p->prefix) {
      {
#line 610
      tmp = strlen((char const   *)p->keyword);
#line 610
      tmp___0 = strncmp((char const   *)p->keyword, keyword, tmp);
      }
#line 610
      if (tmp___0 == 0) {
#line 611
        return (p);
      }
    } else {
      {
#line 615
      tmp___1 = strcmp((char const   *)p->keyword, keyword);
      }
#line 615
      if (tmp___1 == 0) {
#line 616
        return (p);
      }
    }
#line 607
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return ((struct xhdr_tab  const  *)((void *)0));
}
}
#line 622 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool xheader_protected_pattern_p(char const   *pattern ) 
{ 
  struct xhdr_tab  const  *p ;
  int tmp ;

  {
#line 627
  p = xhdr_tab;
  {
#line 627
  while (1) {
    while_continue: /* CIL Label */ ;
#line 627
    if (! p->keyword) {
#line 627
      goto while_break;
    }
#line 628
    if (! p->prefix) {
#line 628
      if (p->flags & 1) {
        {
#line 628
        tmp = fnmatch(pattern, (char const   *)p->keyword, 0);
        }
#line 628
        if (tmp == 0) {
#line 630
          return ((_Bool)1);
        }
      }
    }
#line 627
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 631
  return ((_Bool)0);
}
}
#line 634 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool xheader_protected_keyword_p(char const   *keyword ) 
{ 
  struct xhdr_tab  const  *p ;
  int tmp ;

  {
#line 639
  p = xhdr_tab;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! p->keyword) {
#line 639
      goto while_break;
    }
#line 640
    if (! p->prefix) {
#line 640
      if (p->flags & 1) {
        {
#line 640
        tmp = strcmp((char const   *)p->keyword, keyword);
        }
#line 640
        if (tmp == 0) {
#line 642
          return ((_Bool)1);
        }
      }
    }
#line 639
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 643
  return ((_Bool)0);
}
}
#line 648 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool decode_record(struct xheader *xhdr , char **ptr , void (*handler)(void * ,
                                                                               char const   * ,
                                                                               char const   * ,
                                                                               size_t  ) ,
                           void *data ) 
{ 
  char *start ;
  char *p ;
  size_t len ;
  char *len_lim ;
  char const   *keyword ;
  char *nextp ;
  size_t len_max ;
  char *tmp ;
  int len_len ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;

  {
#line 654
  start = *ptr;
#line 655
  p = start;
#line 660
  len_max = (size_t )((xhdr->buffer + xhdr->size) - start);
  {
#line 662
  while (1) {
    while_continue: /* CIL Label */ ;
#line 662
    if (! ((int )*p == 32)) {
#line 662
      if (! ((int )*p == 9)) {
#line 662
        goto while_break;
      }
    }
#line 663
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  if (! ((unsigned int )*p - 48U <= 9U)) {
#line 667
    if (*p) {
      {
#line 668
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 668
        if (error_hook) {
          {
#line 668
          (*error_hook)();
          }
        }
        {
#line 668
        tmp = gettext("Malformed extended header: missing length");
#line 668
        error(0, 0, (char const   *)tmp);
#line 668
        exit_status = 2;
        }
#line 668
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 669
    return ((_Bool)0);
  }
  {
#line 672
  len = strtoumax((char const   */* __restrict  */)p, (char **/* __restrict  */)(& len_lim),
                  10);
  }
#line 674
  if (len_max < len) {
#line 676
    len_len = (int )(len_lim - p);
    {
#line 677
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 677
      if (error_hook) {
        {
#line 677
        (*error_hook)();
        }
      }
      {
#line 677
      tmp___0 = gettext("Extended header length %*s is out of range");
#line 677
      error(0, 0, (char const   *)tmp___0, len_len, p);
#line 677
      exit_status = 2;
      }
#line 677
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 679
    return ((_Bool)0);
  }
#line 682
  nextp = start + len;
#line 684
  p = len_lim;
  {
#line 684
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 684
    if (! ((int )*p == 32)) {
#line 684
      if (! ((int )*p == 9)) {
#line 684
        goto while_break___2;
      }
    }
#line 685
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 684
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 686
  if ((unsigned long )p == (unsigned long )len_lim) {
    {
#line 688
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 688
      if (error_hook) {
        {
#line 688
        (*error_hook)();
        }
      }
      {
#line 688
      tmp___1 = gettext("Malformed extended header: missing blank after length");
#line 688
      error(0, 0, (char const   *)tmp___1);
#line 688
      exit_status = 2;
      }
#line 688
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 690
    return ((_Bool)0);
  }
  {
#line 693
  keyword = (char const   *)p;
#line 694
  p = strchr((char const   *)p, '=');
  }
#line 695
  if (p) {
#line 695
    if (! ((unsigned long )p < (unsigned long )nextp)) {
#line 695
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 697
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 697
      if (error_hook) {
        {
#line 697
        (*error_hook)();
        }
      }
      {
#line 697
      tmp___2 = gettext("Malformed extended header: missing equal sign");
#line 697
      error(0, 0, (char const   *)tmp___2);
#line 697
      exit_status = 2;
      }
#line 697
      goto while_break___4;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 698
    return ((_Bool)0);
  }
#line 701
  if ((int )*(nextp + -1) != 10) {
    {
#line 703
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 703
      if (error_hook) {
        {
#line 703
        (*error_hook)();
        }
      }
      {
#line 703
      tmp___3 = gettext("Malformed extended header: missing newline");
#line 703
      error(0, 0, (char const   *)tmp___3);
#line 703
      exit_status = 2;
      }
#line 703
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 704
    return ((_Bool)0);
  }
  {
#line 707
  tmp___4 = (char )'\000';
#line 707
  *(nextp + -1) = tmp___4;
#line 707
  *p = tmp___4;
#line 708
  (*handler)(data, keyword, (char const   *)(p + 1), (size_t )((nextp - p) - 2L));
#line 709
  *p = (char )'=';
#line 710
  *(nextp + -1) = (char )'\n';
#line 711
  *ptr = nextp;
  }
#line 712
  return ((_Bool)1);
}
}
#line 715 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void run_override_list(struct keyword_list *kp , struct tar_stat_info *st ) 
{ 
  struct xhdr_tab  const  *t ;
  struct xhdr_tab  const  *tmp ;
  size_t tmp___0 ;

  {
  {
#line 718
  while (1) {
    while_continue: /* CIL Label */ ;
#line 718
    if (! kp) {
#line 718
      goto while_break;
    }
    {
#line 720
    tmp = locate_handler((char const   *)kp->pattern);
#line 720
    t = tmp;
    }
#line 721
    if (t) {
      {
#line 722
      tmp___0 = strlen((char const   *)kp->value);
#line 722
      (*(t->decoder))(st, (char const   *)t->keyword, (char const   *)kp->value, tmp___0);
      }
    }
#line 718
    kp = kp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 724
  return;
}
}
#line 726 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void decx(void *data , char const   *keyword , char const   *value___0 , size_t size ) 
{ 
  struct xhdr_tab  const  *t ;
  struct tar_stat_info *st ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 730
  st = (struct tar_stat_info *)data;
#line 732
  tmp = xheader_keyword_deleted_p(keyword);
  }
#line 732
  if (tmp) {
#line 734
    return;
  } else {
    {
#line 732
    tmp___0 = xheader_keyword_override_p(keyword);
    }
#line 732
    if (tmp___0) {
#line 734
      return;
    }
  }
  {
#line 736
  t = locate_handler(keyword);
  }
#line 737
  if (t) {
    {
#line 738
    (*(t->decoder))(st, keyword, value___0, size);
    }
  } else {
    {
#line 740
    while (1) {
      while_continue: /* CIL Label */ ;
#line 740
      if (warning_option & 131072) {
        {
#line 740
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 740
          if (error_hook) {
            {
#line 740
            (*error_hook)();
            }
          }
          {
#line 740
          tmp___1 = gettext("Ignoring unknown extended header keyword \'%s\'");
#line 740
          error(0, 0, (char const   *)tmp___1, keyword);
          }
#line 740
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 740
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 743
  return;
}
}
#line 745 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_decode(struct tar_stat_info *st ) 
{ 
  char *p ;
  _Bool tmp ;

  {
  {
#line 748
  run_override_list(keyword_global_override_list, st);
#line 749
  run_override_list(global_header_override_list, st);
  }
#line 751
  if (st->xhdr.size) {
#line 753
    p = st->xhdr.buffer + 512;
    {
#line 754
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 754
      tmp = decode_record(& st->xhdr, & p, & decx, (void *)st);
      }
#line 754
      if (! tmp) {
#line 754
        goto while_break;
      }
#line 755
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 757
  run_override_list(keyword_override_list, st);
#line 762
  st->archive_file_size = st->stat.st_size;
  }
#line 766
  if (st->real_size_set) {
#line 767
    st->stat.st_size = st->real_size;
  }
#line 768
  return;
}
}
#line 770 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void decg(void *data , char const   *keyword , char const   *value___0 , size_t size  __attribute__((__unused__)) ) 
{ 
  struct keyword_list **kwl ;
  struct xhdr_tab  const  *tab ;
  struct xhdr_tab  const  *tmp ;

  {
  {
#line 774
  kwl = (struct keyword_list **)data;
#line 775
  tmp = locate_handler(keyword);
#line 775
  tab = tmp;
  }
#line 776
  if (tab) {
#line 776
    if (tab->flags & 2) {
      {
#line 777
      (*(tab->decoder))((struct tar_stat_info *)data, keyword, value___0, size);
      }
    } else {
      {
#line 779
      xheader_list_append(kwl, keyword, value___0);
      }
    }
  } else {
    {
#line 779
    xheader_list_append(kwl, keyword, value___0);
    }
  }
#line 780
  return;
}
}
#line 782 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_decode_global(struct xheader *xhdr ) 
{ 
  char *p ;
  _Bool tmp ;

  {
#line 785
  if (xhdr->size) {
    {
#line 787
    p = xhdr->buffer + 512;
#line 789
    xheader_list_destroy(& global_header_override_list);
    }
    {
#line 790
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 790
      tmp = decode_record(xhdr, & p, & decg, (void *)(& global_header_override_list));
      }
#line 790
      if (! tmp) {
#line 790
        goto while_break;
      }
#line 791
      goto while_continue;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 793
  return;
}
}
#line 795 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_init(struct xheader *xhdr ) 
{ 
  void *tmp ;

  {
#line 798
  if (! xhdr->stk) {
    {
#line 800
    tmp = xmalloc(sizeof(*(xhdr->stk)));
#line 800
    xhdr->stk = (struct obstack *)tmp;
#line 801
    _obstack_begin(xhdr->stk, (size_t )0, (size_t )0, & xmalloc, (void (*)(void * ))(& free));
    }
  }
#line 803
  return;
}
}
#line 805 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_store(char const   *keyword , struct tar_stat_info *st , void const   *data ) 
{ 
  struct xhdr_tab  const  *t ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 811
  if (st->xhdr.buffer) {
#line 812
    return;
  }
  {
#line 813
  t = locate_handler(keyword);
  }
#line 814
  if (! t) {
#line 815
    return;
  } else
#line 814
  if (! t->coder) {
#line 815
    return;
  }
  {
#line 816
  tmp = xheader_keyword_deleted_p(keyword);
  }
#line 816
  if (tmp) {
#line 817
    return;
  }
  {
#line 818
  xheader_init(& st->xhdr);
#line 819
  tmp___0 = xheader_keyword_override_p(keyword);
  }
#line 819
  if (! tmp___0) {
    {
#line 820
    (*(t->coder))((struct tar_stat_info  const  *)st, keyword, & st->xhdr, data);
    }
  }
#line 821
  return;
}
}
#line 823 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_read(struct xheader *xhdr , union block *p , off_t size ) 
{ 
  size_t j ;
  void *tmp ;
  size_t len ;
  char *tmp___0 ;

  {
#line 826
  j = (size_t )0;
#line 828
  if (size < 0L) {
#line 829
    size = (off_t )0;
  }
#line 831
  if (0xfffffffffffffdffUL <= (unsigned long )size) {
    {
#line 832
    xalloc_die();
    }
  }
  {
#line 834
  size += 512L;
#line 835
  xhdr->size = (size_t )size;
#line 836
  tmp = xmalloc((size_t )(size + 1L));
#line 836
  xhdr->buffer = (char *)tmp;
#line 837
  *(xhdr->buffer + size) = (char )'\000';
  }
  {
#line 839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    len = (size_t )size;
#line 843
    if (len > 512UL) {
#line 844
      len = (size_t )512;
    }
#line 846
    if (! p) {
      {
#line 847
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 847
        if (error_hook) {
          {
#line 847
          (*error_hook)();
          }
        }
        {
#line 847
        tmp___0 = gettext("Unexpected EOF in archive");
#line 847
        error(0, 0, (char const   *)tmp___0);
#line 847
        fatal_exit();
        }
#line 847
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 849
    memcpy((void */* __restrict  */)(xhdr->buffer + j), (void const   */* __restrict  */)(p->buffer),
           len);
#line 850
    set_next_block_after(p);
#line 852
    p = find_next_block();
#line 854
    j += len;
#line 855
    size = (off_t )((size_t )size - len);
    }
#line 839
    if (! (size > 0L)) {
#line 839
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 858
  return;
}
}
#line 872
static char *xattr_encode_keyword(char const   *keyword ) ;
#line 872 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static char *encode_buffer  =    (char *)((void *)0);
#line 873 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static size_t encode_buffer_size  =    (size_t )0;
#line 869 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static char *xattr_encode_keyword(char const   *keyword ) 
{ 
  size_t bp ;
  void *tmp ;
  char c ;
  void *tmp___0 ;

  {
#line 876
  if (! encode_buffer) {
    {
#line 878
    encode_buffer_size = (size_t )256;
#line 879
    tmp = xmalloc(encode_buffer_size);
#line 879
    encode_buffer = (char *)tmp;
    }
  } else {
#line 882
    *encode_buffer = (char)0;
  }
#line 884
  bp = (size_t )0;
  {
#line 884
  while (1) {
    while_continue: /* CIL Label */ ;
#line 884
    if (! ((int const   )*keyword != 0)) {
#line 884
      goto while_break;
    }
#line 886
    c = (char )*keyword;
#line 888
    if (bp + 2UL >= encode_buffer_size) {
      {
#line 890
      tmp___0 = x2realloc((void *)encode_buffer, & encode_buffer_size);
#line 890
      encode_buffer = (char *)tmp___0;
      }
    }
#line 893
    if ((int )c == 37) {
      {
#line 895
      strcpy((char */* __restrict  */)(encode_buffer + bp), (char const   */* __restrict  */)"%25");
#line 896
      bp += 2UL;
      }
    } else
#line 898
    if ((int )c == 61) {
      {
#line 900
      strcpy((char */* __restrict  */)(encode_buffer + bp), (char const   */* __restrict  */)"%3D");
#line 901
      bp += 2UL;
      }
    } else {
#line 904
      *(encode_buffer + bp) = c;
    }
#line 884
    bp ++;
#line 884
    keyword ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 907
  *(encode_buffer + bp) = (char)0;
#line 909
  return (encode_buffer);
}
}
#line 912 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_print_n(struct xheader *xhdr , char const   *keyword , char const   *value___0 ,
                            size_t vsize ) 
{ 
  size_t p ;
  size_t n ;
  char nbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char const   *np ;
  size_t len ;
  size_t klen ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 917
  n = (size_t )0;
#line 922
  tmp = xattr_encode_keyword(keyword);
#line 922
  keyword = (char const   *)tmp;
#line 923
  klen = strlen(keyword);
#line 924
  len = (klen + vsize) + 3UL;
  }
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 928
    p = n;
#line 929
    tmp___0 = umaxtostr(len + p, nbuf);
#line 929
    np = (char const   *)tmp___0;
#line 930
    n = (size_t )(((nbuf + sizeof(nbuf)) - 1) - (char *)np);
    }
#line 926
    if (! (n != p)) {
#line 926
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 934
  x_obstack_grow(xhdr, np, n);
#line 935
  x_obstack_1grow(xhdr, (char )' ');
#line 936
  x_obstack_grow(xhdr, keyword, klen);
#line 937
  x_obstack_1grow(xhdr, (char )'=');
#line 938
  x_obstack_grow(xhdr, value___0, vsize);
#line 939
  x_obstack_1grow(xhdr, (char )'\n');
  }
#line 940
  return;
}
}
#line 942 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xheader_print(struct xheader *xhdr , char const   *keyword , char const   *value___0 ) 
{ 
  size_t tmp ;

  {
  {
#line 945
  tmp = strlen(value___0);
#line 945
  xheader_print_n(xhdr, keyword, value___0, tmp);
  }
#line 946
  return;
}
}
#line 948 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_finish(struct xheader *xhdr ) 
{ 
  struct keyword_list *kp ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 953
  kp = keyword_override_list;
  {
#line 953
  while (1) {
    while_continue: /* CIL Label */ ;
#line 953
    if (! kp) {
#line 953
      goto while_break;
    }
    {
#line 954
    code_string((char const   *)kp->value, (char const   *)kp->pattern, xhdr);
#line 953
    kp = kp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 956
  __o1 = xhdr->stk;
#line 956
  __value = (void *)__o1->object_base;
#line 956
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 956
    __o1->maybe_empty_object = 1U;
  }
#line 956
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 956
    tmp = __o1->object_base;
  } else {
#line 956
    tmp = (char *)0;
  }
#line 956
  if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 956
    tmp___0 = __o1->object_base;
  } else {
#line 956
    tmp___0 = (char *)0;
  }
#line 956
  __o1->next_free = tmp + (((size_t )(__o1->next_free - tmp___0) + __o1->alignment_mask) & ~ __o1->alignment_mask);
#line 956
  if ((size_t )(__o1->next_free - (char *)__o1->chunk) > (size_t )(__o1->chunk_limit - (char *)__o1->chunk)) {
#line 956
    __o1->next_free = __o1->chunk_limit;
  }
#line 956
  __o1->object_base = __o1->next_free;
#line 956
  xhdr->buffer = (char *)__value;
#line 957
  return;
}
}
#line 959 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_destroy(struct xheader *xhdr ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;

  {
#line 962
  if (xhdr->stk) {
#line 964
    __o = xhdr->stk;
#line 964
    __obj = (void *)0;
#line 964
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 964
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 964
        tmp = (char *)__obj;
#line 964
        __o->object_base = tmp;
#line 964
        __o->next_free = tmp;
      } else {
        {
#line 964
        _obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 964
      _obstack_free(__o, __obj);
      }
    }
    {
#line 965
    free((void *)xhdr->stk);
#line 966
    xhdr->stk = (struct obstack *)((void *)0);
    }
  } else {
    {
#line 969
    free((void *)xhdr->buffer);
    }
  }
#line 970
  xhdr->buffer = (char *)0;
#line 971
  xhdr->size = (size_t )0;
#line 972
  return;
}
}
#line 977 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_string_begin(struct xheader *xhdr ) 
{ 


  {
#line 980
  xhdr->string_length = (uintmax_t )0;
#line 981
  return;
}
}
#line 983 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
void xheader_string_add(struct xheader *xhdr , char const   *s ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 986
  if (xhdr->buffer) {
#line 987
    return;
  }
  {
#line 988
  xheader_init(xhdr);
#line 989
  tmp = strlen(s);
#line 989
  xhdr->string_length += tmp;
#line 990
  tmp___0 = strlen(s);
#line 990
  x_obstack_grow(xhdr, s, tmp___0);
  }
#line 991
  return;
}
}
#line 993 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
_Bool xheader_string_end(struct xheader *xhdr , char const   *keyword ) 
{ 
  uintmax_t len ;
  uintmax_t p ;
  uintmax_t n ;
  size_t size ;
  char nbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char const   *np ;
  char *cp ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  struct obstack *__o ;
  void *__obj ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 998
  n = (uintmax_t )0;
#line 1004
  if (xhdr->buffer) {
#line 1005
    return ((_Bool)0);
  }
  {
#line 1006
  xheader_init(xhdr);
#line 1008
  tmp = strlen(keyword);
#line 1008
  len = (tmp + xhdr->string_length) + 3UL;
  }
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1012
    p = n;
#line 1013
    tmp___0 = umaxtostr(len + p, nbuf);
#line 1013
    np = (char const   *)tmp___0;
#line 1014
    n = (uintmax_t )(((nbuf + sizeof(nbuf)) - 1) - (char *)np);
    }
#line 1010
    if (! (n != p)) {
#line 1010
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1018
  tmp___1 = strlen(keyword);
#line 1018
  p = (tmp___1 + n) + 2UL;
#line 1019
  size = p;
  }
#line 1020
  if (size != p) {
    {
#line 1022
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1022
      if (error_hook) {
        {
#line 1022
        (*error_hook)();
        }
      }
      {
#line 1022
      tmp___2 = gettext("Generated keyword/value pair is too long (keyword=%s, length=%s)");
#line 1022
      error(0, 0, (char const   *)tmp___2, keyword, nbuf);
#line 1022
      exit_status = 2;
      }
#line 1022
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1025
    __o = xhdr->stk;
#line 1025
    __o1 = xhdr->stk;
#line 1025
    __value = (void *)__o1->object_base;
#line 1025
    if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 1025
      __o1->maybe_empty_object = 1U;
    }
#line 1025
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1025
      tmp___3 = __o1->object_base;
    } else {
#line 1025
      tmp___3 = (char *)0;
    }
#line 1025
    if (sizeof(ptrdiff_t ) < sizeof(void *)) {
#line 1025
      tmp___4 = __o1->object_base;
    } else {
#line 1025
      tmp___4 = (char *)0;
    }
#line 1025
    __o1->next_free = tmp___3 + (((size_t )(__o1->next_free - tmp___4) + __o1->alignment_mask) & ~ __o1->alignment_mask);
#line 1025
    if ((size_t )(__o1->next_free - (char *)__o1->chunk) > (size_t )(__o1->chunk_limit - (char *)__o1->chunk)) {
#line 1025
      __o1->next_free = __o1->chunk_limit;
    }
#line 1025
    __o1->object_base = __o1->next_free;
#line 1025
    __obj = __value;
#line 1025
    if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 1025
      if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 1025
        tmp___5 = (char *)__obj;
#line 1025
        __o->object_base = tmp___5;
#line 1025
        __o->next_free = tmp___5;
      } else {
        {
#line 1025
        _obstack_free(__o, __obj);
        }
      }
    } else {
      {
#line 1025
      _obstack_free(__o, __obj);
      }
    }
#line 1026
    return ((_Bool)0);
  }
  {
#line 1028
  x_obstack_blank(xhdr, p);
#line 1029
  x_obstack_1grow(xhdr, (char )'\n');
#line 1030
  cp = (((char *)((void *)(xhdr->stk)->next_free) - xhdr->string_length) - p) - 1;
#line 1031
  memmove((void *)(cp + p), (void const   *)cp, xhdr->string_length);
#line 1032
  cp = stpcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)np);
#line 1033
  tmp___6 = cp;
#line 1033
  cp ++;
#line 1033
  *tmp___6 = (char )' ';
#line 1034
  cp = stpcpy((char */* __restrict  */)cp, (char const   */* __restrict  */)keyword);
#line 1035
  tmp___7 = cp;
#line 1035
  cp ++;
#line 1035
  *tmp___7 = (char )'=';
  }
#line 1036
  return ((_Bool)1);
}
}
#line 1042 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void out_of_range_header(char const   *keyword , char const   *value___0 ,
                                intmax_t minval , uintmax_t maxval ) 
{ 
  char minval_buf[(((sizeof(intmax_t ) * 8UL - 1UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char maxval_buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *minval_string ;
  char *tmp ;
  char *maxval_string ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1048
  tmp = imaxtostr(minval, minval_buf);
#line 1048
  minval_string = tmp;
#line 1049
  tmp___0 = umaxtostr(maxval, maxval_buf);
#line 1049
  maxval_string = tmp___0;
  }
  {
#line 1053
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1053
    if (error_hook) {
      {
#line 1053
      (*error_hook)();
      }
    }
    {
#line 1053
    tmp___1 = gettext("Extended header %s=%s is out of range %s..%s");
#line 1053
    error(0, 0, (char const   *)tmp___1, keyword, value___0, minval_string, maxval_string);
#line 1053
    exit_status = 2;
    }
#line 1053
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1055
  return;
}
}
#line 1057 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void code_string(char const   *string , char const   *keyword , struct xheader *xhdr ) 
{ 
  char *outstr ;
  _Bool tmp ;

  {
  {
#line 1061
  tmp = utf8_convert((_Bool)1, string, & outstr);
  }
#line 1061
  if (! tmp) {
    {
#line 1064
    outstr = xstrdup(string);
    }
  }
  {
#line 1066
  xheader_print(xhdr, keyword, (char const   *)outstr);
#line 1067
  free((void *)outstr);
  }
#line 1068
  return;
}
}
#line 1070 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void decode_string(char **string , char const   *arg___0 ) 
{ 
  _Bool tmp ;

  {
#line 1073
  if (*string) {
    {
#line 1075
    free((void *)*string);
#line 1076
    *string = (char *)((void *)0);
    }
  }
  {
#line 1078
  tmp = utf8_convert((_Bool)0, arg___0, string);
  }
#line 1078
  if (! tmp) {
    {
#line 1081
    assign_string(string, arg___0);
    }
  }
#line 1083
  return;
}
}
#line 1085 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void code_time(struct timespec t , char const   *keyword , struct xheader *xhdr ) 
{ 
  char buf[32] ;
  char const   *tmp ;

  {
  {
#line 1089
  tmp = code_timespec(t, buf);
#line 1089
  xheader_print(xhdr, keyword, tmp);
  }
#line 1090
  return;
}
}
#line 1092 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool decode_time(struct timespec *ts , char const   *arg___0 , char const   *keyword ) 
{ 
  char *arg_lim ;
  struct timespec t ;
  struct timespec tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1096
  tmp = decode_timespec(arg___0, & arg_lim, (_Bool)1);
#line 1096
  t = tmp;
#line 1098
  tmp___1 = valid_timespec(t);
  }
#line 1098
  if (! tmp___1) {
#line 1100
    if ((unsigned long )arg___0 < (unsigned long )arg_lim) {
#line 1100
      if (! *arg_lim) {
        {
#line 1101
        out_of_range_header(keyword, arg___0, ~ (((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                            (uintmax_t )(((1L << (sizeof(time_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
        }
      } else {
#line 1100
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1104
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1104
        if (error_hook) {
          {
#line 1104
          (*error_hook)();
          }
        }
        {
#line 1104
        tmp___0 = gettext("Malformed extended header: invalid %s=%s");
#line 1104
        error(0, 0, (char const   *)tmp___0, keyword, arg___0);
#line 1104
        exit_status = 2;
        }
#line 1104
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1106
    return ((_Bool)0);
  }
#line 1109
  *ts = t;
#line 1110
  return ((_Bool)1);
}
}
#line 1113 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void code_signed_num(uintmax_t value___0 , char const   *keyword , intmax_t minval ,
                            uintmax_t maxval , struct xheader *xhdr ) 
{ 
  char sbuf[21] ;
  char *tmp ;

  {
  {
#line 1118
  tmp = sysinttostr(value___0, minval, maxval, (char *)(sbuf));
#line 1118
  xheader_print(xhdr, keyword, (char const   *)tmp);
  }
#line 1119
  return;
}
}
#line 1121 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void code_num(uintmax_t value___0 , char const   *keyword , struct xheader *xhdr ) 
{ 


  {
  {
#line 1124
  code_signed_num(value___0, keyword, (intmax_t )0, 0xffffffffffffffffUL, xhdr);
  }
#line 1125
  return;
}
}
#line 1127 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool decode_signed_num(intmax_t *num , char const   *arg___0 , intmax_t minval ,
                               uintmax_t maxval , char const   *keyword ) 
{ 
  char *arg_lim ;
  intmax_t u ;
  intmax_t tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1133
  tmp = strtosysint(arg___0, & arg_lim, minval, maxval);
#line 1133
  u = tmp;
#line 1135
  tmp___1 = __errno_location();
  }
#line 1135
  if (*tmp___1 == 22) {
#line 1135
    goto _L;
  } else
#line 1135
  if (*arg_lim) {
    _L: /* CIL Label */ 
    {
#line 1137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1137
      if (error_hook) {
        {
#line 1137
        (*error_hook)();
        }
      }
      {
#line 1137
      tmp___0 = gettext("Malformed extended header: invalid %s=%s");
#line 1137
      error(0, 0, (char const   *)tmp___0, keyword, arg___0);
#line 1137
      exit_status = 2;
      }
#line 1137
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1139
    return ((_Bool)0);
  }
  {
#line 1142
  tmp___2 = __errno_location();
  }
#line 1142
  if (*tmp___2 == 34) {
    {
#line 1144
    out_of_range_header(keyword, arg___0, minval, maxval);
    }
#line 1145
    return ((_Bool)0);
  }
#line 1148
  *num = u;
#line 1149
  return ((_Bool)1);
}
}
#line 1152 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static _Bool decode_num___0(uintmax_t *num , char const   *arg___0 , uintmax_t maxval ,
                            char const   *keyword ) 
{ 
  intmax_t i ;
  _Bool tmp ;

  {
  {
#line 1157
  tmp = decode_signed_num(& i, arg___0, (intmax_t )0, maxval, keyword);
  }
#line 1157
  if (! tmp) {
#line 1158
    return ((_Bool)0);
  }
#line 1159
  *num = (uintmax_t )i;
#line 1160
  return ((_Bool)1);
}
}
#line 1163 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void dummy_coder(struct tar_stat_info  const  *st  __attribute__((__unused__)) ,
                        char const   *keyword  __attribute__((__unused__)) , struct xheader *xhdr  __attribute__((__unused__)) ,
                        void const   *data  __attribute__((__unused__)) ) 
{ 


  {
#line 1169
  return;
}
}
#line 1171 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void dummy_decoder(struct tar_stat_info *st  __attribute__((__unused__)) ,
                          char const   *keyword  __attribute__((__unused__)) , char const   *arg___0  __attribute__((__unused__)) ,
                          size_t size  __attribute__((__unused__)) ) 
{ 


  {
#line 1177
  return;
}
}
#line 1179 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void atime_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                        struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1183
  code_time((struct timespec )st->atime, keyword, xhdr);
  }
#line 1184
  return;
}
}
#line 1186 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void atime_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                          size_t size  __attribute__((__unused__)) ) 
{ 
  struct timespec ts ;
  _Bool tmp ;

  {
  {
#line 1193
  tmp = decode_time(& ts, arg___0, keyword);
  }
#line 1193
  if (tmp) {
#line 1194
    st->atime = ts;
  }
#line 1195
  return;
}
}
#line 1197 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void gid_coder(struct tar_stat_info  const  *st , char const   *keyword , struct xheader *xhdr ,
                      void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1201
  code_signed_num((uintmax_t )st->stat.st_gid, keyword, (intmax_t )((gid_t )0), (uintmax_t )((gid_t )-1),
                  xhdr);
  }
#line 1203
  return;
}
}
#line 1205 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void gid_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                        size_t size  __attribute__((__unused__)) ) 
{ 
  intmax_t u ;
  _Bool tmp ;

  {
  {
#line 1212
  tmp = decode_signed_num(& u, arg___0, (intmax_t )((gid_t )0), (uintmax_t )((gid_t )-1),
                          keyword);
  }
#line 1212
  if (tmp) {
#line 1214
    st->stat.st_gid = (__gid_t )u;
  }
#line 1215
  return;
}
}
#line 1217 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void gname_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                        struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1221
  code_string((char const   *)st->gname, keyword, xhdr);
  }
#line 1222
  return;
}
}
#line 1224 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void gname_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                          char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1230
  decode_string(& st->gname, arg___0);
  }
#line 1231
  return;
}
}
#line 1233 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void linkpath_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                           struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1237
  code_string((char const   *)st->link_name, keyword, xhdr);
  }
#line 1238
  return;
}
}
#line 1240 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void linkpath_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                             char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1246
  decode_string(& st->link_name, arg___0);
  }
#line 1247
  return;
}
}
#line 1249 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void ctime_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                        struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1253
  code_time((struct timespec )st->ctime, keyword, xhdr);
  }
#line 1254
  return;
}
}
#line 1256 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void ctime_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                          size_t size  __attribute__((__unused__)) ) 
{ 
  struct timespec ts ;
  _Bool tmp ;

  {
  {
#line 1263
  tmp = decode_time(& ts, arg___0, keyword);
  }
#line 1263
  if (tmp) {
#line 1264
    st->ctime = ts;
  }
#line 1265
  return;
}
}
#line 1267 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void mtime_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                        struct xheader *xhdr , void const   *data ) 
{ 
  struct timespec  const  *mtime ;
  struct timespec tmp ;

  {
#line 1271
  mtime = (struct timespec  const  *)data;
#line 1272
  if (mtime) {
#line 1272
    tmp = *mtime;
  } else {
#line 1272
    tmp = st->mtime;
  }
  {
#line 1272
  code_time((struct timespec )tmp, keyword, xhdr);
  }
#line 1273
  return;
}
}
#line 1275 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void mtime_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                          size_t size  __attribute__((__unused__)) ) 
{ 
  struct timespec ts ;
  _Bool tmp ;

  {
  {
#line 1282
  tmp = decode_time(& ts, arg___0, keyword);
  }
#line 1282
  if (tmp) {
#line 1283
    st->mtime = ts;
  }
#line 1284
  return;
}
}
#line 1286 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void path_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                       struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1290
  code_string((char const   *)st->file_name, keyword, xhdr);
  }
#line 1291
  return;
}
}
#line 1293 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void path_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                         char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1299
  decode_string(& st->orig_file_name, arg___0);
#line 1300
  decode_string(& st->file_name, arg___0);
#line 1301
  st->had_trailing_slash = strip_trailing_slashes(st->file_name);
  }
#line 1302
  return;
}
}
#line 1304 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void size_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                       struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1308
  code_num((uintmax_t )st->stat.st_size, keyword, xhdr);
  }
#line 1309
  return;
}
}
#line 1311 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void size_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                         size_t size  __attribute__((__unused__)) ) 
{ 
  uintmax_t u ;
  _Bool tmp ;

  {
  {
#line 1318
  tmp = decode_num___0(& u, arg___0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                       keyword);
  }
#line 1318
  if (tmp) {
#line 1319
    st->stat.st_size = (__off_t )u;
  }
#line 1320
  return;
}
}
#line 1322 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void uid_coder(struct tar_stat_info  const  *st , char const   *keyword , struct xheader *xhdr ,
                      void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1326
  code_signed_num((uintmax_t )st->stat.st_uid, keyword, (intmax_t )((uid_t )0), (uintmax_t )((uid_t )-1),
                  xhdr);
  }
#line 1328
  return;
}
}
#line 1330 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void uid_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                        size_t size  __attribute__((__unused__)) ) 
{ 
  intmax_t u ;
  _Bool tmp ;

  {
  {
#line 1337
  tmp = decode_signed_num(& u, arg___0, (intmax_t )((uid_t )0), (uintmax_t )((uid_t )-1),
                          keyword);
  }
#line 1337
  if (tmp) {
#line 1339
    st->stat.st_uid = (__uid_t )u;
  }
#line 1340
  return;
}
}
#line 1342 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void uname_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                        struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1346
  code_string((char const   *)st->uname, keyword, xhdr);
  }
#line 1347
  return;
}
}
#line 1349 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void uname_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                          char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1355
  decode_string(& st->uname, arg___0);
  }
#line 1356
  return;
}
}
#line 1358 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_size_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                              struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1362
  size_coder(st, keyword, xhdr, data);
  }
#line 1363
  return;
}
}
#line 1365 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_size_decoder(struct tar_stat_info *st , char const   *keyword ,
                                char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 
  uintmax_t u ;
  _Bool tmp ;

  {
  {
#line 1372
  tmp = decode_num___0(& u, arg___0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                       keyword);
  }
#line 1372
  if (tmp) {
#line 1374
    st->real_size_set = 1;
#line 1375
    st->real_size = (off_t )u;
  }
#line 1377
  return;
}
}
#line 1379 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_numblocks_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                                   struct xheader *xhdr , void const   *data  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1384
  code_num((uintmax_t )st->sparse_map_avail, keyword, xhdr);
  }
#line 1385
  return;
}
}
#line 1387 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_numblocks_decoder(struct tar_stat_info *st , char const   *keyword ,
                                     char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 
  uintmax_t u ;
  void *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1394
  tmp___0 = decode_num___0(& u, arg___0, 0xffffffffffffffffUL, keyword);
  }
#line 1394
  if (tmp___0) {
    {
#line 1396
    st->sparse_map_size = u;
#line 1397
    tmp = xcalloc(u, sizeof(*(st->sparse_map + 0)));
#line 1397
    st->sparse_map = (struct sp_array *)tmp;
#line 1398
    st->sparse_map_avail = (size_t )0;
    }
  }
#line 1400
  return;
}
}
#line 1402 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_offset_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                                struct xheader *xhdr , void const   *data ) 
{ 
  size_t const   *pi ;

  {
  {
#line 1406
  pi = (size_t const   *)data;
#line 1407
  code_num((uintmax_t )(st->sparse_map + *pi)->offset, keyword, xhdr);
  }
#line 1408
  return;
}
}
#line 1410 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_offset_decoder(struct tar_stat_info *st , char const   *keyword ,
                                  char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 
  uintmax_t u ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  {
#line 1417
  tmp___0 = decode_num___0(& u, arg___0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                           keyword);
  }
#line 1417
  if (tmp___0) {
#line 1419
    if (st->sparse_map_avail < st->sparse_map_size) {
#line 1420
      (st->sparse_map + st->sparse_map_avail)->offset = (off_t )u;
    } else {
      {
#line 1422
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1422
        if (error_hook) {
          {
#line 1422
          (*error_hook)();
          }
        }
        {
#line 1422
        tmp = gettext("Malformed extended header: excess %s=%s");
#line 1422
        error(0, 0, (char const   *)tmp, "GNU.sparse.offset", arg___0);
#line 1422
        exit_status = 2;
        }
#line 1422
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1425
  return;
}
}
#line 1427 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_numbytes_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                                  struct xheader *xhdr , void const   *data ) 
{ 
  size_t const   *pi ;

  {
  {
#line 1431
  pi = (size_t const   *)data;
#line 1432
  code_num((uintmax_t )(st->sparse_map + *pi)->numbytes, keyword, xhdr);
  }
#line 1433
  return;
}
}
#line 1435 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_numbytes_decoder(struct tar_stat_info *st , char const   *keyword ,
                                    char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 
  uintmax_t u ;
  size_t tmp ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
  {
#line 1442
  tmp___1 = decode_num___0(& u, arg___0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L),
                           keyword);
  }
#line 1442
  if (tmp___1) {
#line 1444
    if (st->sparse_map_avail < st->sparse_map_size) {
#line 1445
      tmp = st->sparse_map_avail;
#line 1445
      (st->sparse_map_avail) ++;
#line 1445
      (st->sparse_map + tmp)->numbytes = (off_t )u;
    } else {
      {
#line 1447
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1447
        if (error_hook) {
          {
#line 1447
          (*error_hook)();
          }
        }
        {
#line 1447
        tmp___0 = gettext("Malformed extended header: excess %s=%s");
#line 1447
        error(0, 0, (char const   *)tmp___0, keyword, arg___0);
#line 1447
        exit_status = 2;
        }
#line 1447
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1450
  return;
}
}
#line 1452 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_map_decoder(struct tar_stat_info *st , char const   *keyword ,
                               char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 
  int offset ;
  struct sp_array e ;
  intmax_t u ;
  char *delim ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 1458
  offset = 1;
#line 1461
  st->sparse_map_avail = (size_t )0;
  {
#line 1462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1467
    if (! ((unsigned int )*arg___0 - 48U <= 9U)) {
      {
#line 1469
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1469
        if (error_hook) {
          {
#line 1469
          (*error_hook)();
          }
        }
        {
#line 1469
        tmp = gettext("Malformed extended header: invalid %s=%s");
#line 1469
        error(0, 0, (char const   *)tmp, keyword, arg___0);
#line 1469
        exit_status = 2;
        }
#line 1469
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1471
      return;
    }
    {
#line 1474
    tmp___0 = __errno_location();
#line 1474
    *tmp___0 = 0;
#line 1475
    u = strtoimax((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)(& delim),
                  10);
    }
#line 1476
    if (((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L < u) {
      {
#line 1478
      u = ((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L;
#line 1479
      tmp___1 = __errno_location();
#line 1479
      *tmp___1 = 34;
      }
    }
#line 1481
    if (offset) {
      {
#line 1483
      e.offset = u;
#line 1484
      tmp___2 = __errno_location();
      }
#line 1484
      if (*tmp___2 == 34) {
        {
#line 1486
        out_of_range_header(keyword, arg___0, (intmax_t )0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
        }
#line 1487
        return;
      }
    } else {
      {
#line 1492
      e.numbytes = u;
#line 1493
      tmp___3 = __errno_location();
      }
#line 1493
      if (*tmp___3 == 34) {
        {
#line 1495
        out_of_range_header(keyword, arg___0, (intmax_t )0, (uintmax_t )(((1L << (sizeof(off_t ) * 8UL - 2UL)) - 1L) * 2L + 1L));
        }
#line 1496
        return;
      }
#line 1498
      if (st->sparse_map_avail < st->sparse_map_size) {
#line 1499
        tmp___4 = st->sparse_map_avail;
#line 1499
        (st->sparse_map_avail) ++;
#line 1499
        *(st->sparse_map + tmp___4) = e;
      } else {
        {
#line 1502
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1502
          if (error_hook) {
            {
#line 1502
            (*error_hook)();
            }
          }
          {
#line 1502
          tmp___5 = gettext("Malformed extended header: excess %s=%s");
#line 1502
          error(0, 0, (char const   *)tmp___5, keyword, arg___0);
#line 1502
          exit_status = 2;
          }
#line 1502
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1504
        return;
      }
    }
#line 1508
    offset = ! offset;
#line 1510
    if ((int )*delim == 0) {
#line 1511
      goto while_break;
    } else
#line 1512
    if ((int )*delim != 44) {
      {
#line 1514
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1514
        if (error_hook) {
          {
#line 1514
          (*error_hook)();
          }
        }
        {
#line 1514
        tmp___6 = gettext("Malformed extended header: invalid %s: unexpected delimiter %c");
#line 1514
        error(0, 0, (char const   *)tmp___6, keyword, (int )*delim);
#line 1514
        exit_status = 2;
        }
#line 1514
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1517
      return;
    }
#line 1520
    arg___0 = (char const   *)(delim + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 1523
  if (! offset) {
    {
#line 1524
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1524
      if (error_hook) {
        {
#line 1524
        (*error_hook)();
        }
      }
      {
#line 1524
      tmp___7 = gettext("Malformed extended header: invalid %s: odd number of values");
#line 1524
      error(0, 0, (char const   *)tmp___7, keyword);
#line 1524
      exit_status = 2;
      }
#line 1524
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 1527
  return;
}
}
#line 1529 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void dumpdir_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                          struct xheader *xhdr , void const   *data ) 
{ 
  size_t tmp ;

  {
  {
#line 1533
  tmp = dumpdir_size((char const   *)data);
#line 1533
  xheader_print_n(xhdr, keyword, (char const   *)data, tmp);
  }
#line 1534
  return;
}
}
#line 1536 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void dumpdir_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                            char const   *arg___0 , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1542
  tmp = xmalloc(size);
#line 1542
  st->dumpdir = (char *)tmp;
#line 1543
  memcpy((void */* __restrict  */)st->dumpdir, (void const   */* __restrict  */)arg___0,
         size);
  }
#line 1544
  return;
}
}
#line 1546 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_label_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                               struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1550
  code_string((char const   *)data, keyword, xhdr);
  }
#line 1551
  return;
}
}
#line 1553 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_label_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                                 char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1559
  decode_string(& volume_label, arg___0);
  }
#line 1560
  return;
}
}
#line 1562 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_size_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                              struct xheader *xhdr , void const   *data ) 
{ 
  off_t const   *v ;

  {
  {
#line 1566
  v = (off_t const   *)data;
#line 1567
  code_num((uintmax_t )*v, keyword, xhdr);
  }
#line 1568
  return;
}
}
#line 1570 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_size_decoder(struct tar_stat_info *st , char const   *keyword ,
                                char const   *arg___0 , size_t size ) 
{ 
  uintmax_t u ;
  _Bool tmp ;

  {
  {
#line 1576
  tmp = decode_num___0(& u, arg___0, (uintmax_t )-1, keyword);
  }
#line 1576
  if (tmp) {
#line 1577
    continued_file_size = u;
  }
#line 1578
  return;
}
}
#line 1581 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_offset_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                                struct xheader *xhdr , void const   *data ) 
{ 
  off_t const   *v ;

  {
  {
#line 1585
  v = (off_t const   *)data;
#line 1586
  code_num((uintmax_t )*v, keyword, xhdr);
  }
#line 1587
  return;
}
}
#line 1589 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_offset_decoder(struct tar_stat_info *st , char const   *keyword ,
                                  char const   *arg___0 , size_t size ) 
{ 
  uintmax_t u ;
  _Bool tmp ;

  {
  {
#line 1595
  tmp = decode_num___0(& u, arg___0, (uintmax_t )-1, keyword);
  }
#line 1595
  if (tmp) {
#line 1596
    continued_file_offset = u;
  }
#line 1597
  return;
}
}
#line 1599 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void volume_filename_decoder(struct tar_stat_info *st , char const   *keyword  __attribute__((__unused__)) ,
                                    char const   *arg___0 , size_t size  __attribute__((__unused__)) ) 
{ 


  {
  {
#line 1605
  decode_string(& continued_file_name, arg___0);
  }
#line 1606
  return;
}
}
#line 1608 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_selinux_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                                struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1612
  code_string((char const   *)st->cntx_name, keyword, xhdr);
  }
#line 1613
  return;
}
}
#line 1615 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_selinux_decoder(struct tar_stat_info *st , char const   *keyword ,
                                  char const   *arg___0 , size_t size ) 
{ 


  {
  {
#line 1619
  decode_string(& st->cntx_name, arg___0);
  }
#line 1620
  return;
}
}
#line 1622 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_acls_a_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                               struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1626
  xheader_print_n(xhdr, keyword, (char const   *)st->acls_a_ptr, (size_t )st->acls_a_len);
  }
#line 1627
  return;
}
}
#line 1629 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_acls_a_decoder(struct tar_stat_info *st , char const   *keyword ,
                                 char const   *arg___0 , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1633
  tmp = xmemdup((void const   *)arg___0, size + 1UL);
#line 1633
  st->acls_a_ptr = (char *)tmp;
#line 1634
  st->acls_a_len = size;
  }
#line 1635
  return;
}
}
#line 1637 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_acls_d_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                               struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1641
  xheader_print_n(xhdr, keyword, (char const   *)st->acls_d_ptr, (size_t )st->acls_d_len);
  }
#line 1642
  return;
}
}
#line 1644 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_acls_d_decoder(struct tar_stat_info *st , char const   *keyword ,
                                 char const   *arg___0 , size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 1648
  tmp = xmemdup((void const   *)arg___0, size + 1UL);
#line 1648
  st->acls_d_ptr = (char *)tmp;
#line 1649
  st->acls_d_len = size;
  }
#line 1650
  return;
}
}
#line 1652 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                        struct xheader *xhdr , void const   *data ) 
{ 
  struct xattr_array *xattr_map ;
  size_t const   *off ;

  {
  {
#line 1656
  xattr_map = (struct xattr_array *)st->xattr_map;
#line 1657
  off = (size_t const   *)data;
#line 1658
  xheader_print_n(xhdr, keyword, (char const   *)(xattr_map + *off)->xval_ptr, (xattr_map + *off)->xval_len);
  }
#line 1660
  return;
}
}
#line 1662 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void xattr_decoder(struct tar_stat_info *st , char const   *keyword , char const   *arg___0 ,
                          size_t size ) 
{ 
  char *xstr ;
  char *xkey ;
  size_t klen_raw ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1669
  tmp = strlen(keyword);
#line 1669
  klen_raw = tmp;
#line 1670
  tmp___0 = __builtin_alloca(klen_raw + 1UL);
#line 1670
  xkey = (char *)tmp___0;
#line 1671
  memcpy((void */* __restrict  */)xkey, (void const   */* __restrict  */)keyword,
         klen_raw + 1UL);
#line 1674
  tmp___1 = __builtin_alloca(size + 1UL);
#line 1674
  xstr = (char *)tmp___1;
#line 1675
  memcpy((void */* __restrict  */)xstr, (void const   */* __restrict  */)arg___0,
         size + 1UL);
#line 1677
  xattr_decode_keyword(xkey);
#line 1679
  tmp___2 = strlen("SCHILY.xattr.");
#line 1679
  xheader_xattr_add(st, (char const   *)(xkey + tmp___2), (char const   *)xstr, size);
  }
#line 1680
  return;
}
}
#line 1682 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_major_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                               struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1686
  code_num((uintmax_t )st->sparse_major, keyword, xhdr);
  }
#line 1687
  return;
}
}
#line 1689 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_major_decoder(struct tar_stat_info *st , char const   *keyword ,
                                 char const   *arg___0 , size_t size ) 
{ 
  uintmax_t u ;
  _Bool tmp ;

  {
  {
#line 1696
  tmp = decode_num___0(& u, arg___0, (uintmax_t )4294967295U, keyword);
  }
#line 1696
  if (tmp) {
#line 1697
    st->sparse_major = (unsigned int )u;
  }
#line 1698
  return;
}
}
#line 1700 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_minor_coder(struct tar_stat_info  const  *st , char const   *keyword ,
                               struct xheader *xhdr , void const   *data ) 
{ 


  {
  {
#line 1704
  code_num((uintmax_t )st->sparse_minor, keyword, xhdr);
  }
#line 1705
  return;
}
}
#line 1707 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
static void sparse_minor_decoder(struct tar_stat_info *st , char const   *keyword ,
                                 char const   *arg___0 , size_t size ) 
{ 
  uintmax_t u ;
  _Bool tmp ;

  {
  {
#line 1714
  tmp = decode_num___0(& u, arg___0, (uintmax_t )4294967295U, keyword);
  }
#line 1714
  if (tmp) {
#line 1715
    st->sparse_minor = (unsigned int )u;
  }
#line 1716
  return;
}
}
#line 1718 "/home/khheo/project/benchmark/tar-1.29/src/xheader.c"
struct xhdr_tab  const  xhdr_tab[31]  = 
#line 1718
  {      {"atime", & atime_coder, & atime_decoder, 0, (_Bool)0}, 
        {"comment", & dummy_coder, & dummy_decoder, 0, (_Bool)0}, 
        {"charset", & dummy_coder, & dummy_decoder, 0, (_Bool)0}, 
        {"ctime", & ctime_coder, & ctime_decoder, 0, (_Bool)0}, 
        {"gid", & gid_coder, & gid_decoder, 0, (_Bool)0}, 
        {"gname", & gname_coder, & gname_decoder, 0, (_Bool)0}, 
        {"linkpath", & linkpath_coder, & linkpath_decoder, 0, (_Bool)0}, 
        {"mtime", & mtime_coder, & mtime_decoder, 0, (_Bool)0}, 
        {"path", & path_coder, & path_decoder, 0, (_Bool)0}, 
        {"size", & size_coder, & size_decoder, 0, (_Bool)0}, 
        {"uid", & uid_coder, & uid_decoder, 0, (_Bool)0}, 
        {"uname", & uname_coder, & uname_decoder, 0, (_Bool)0}, 
        {"GNU.sparse.name", & path_coder, & path_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.major", & sparse_major_coder, & sparse_major_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.minor",
      & sparse_minor_coder, & sparse_minor_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.realsize", & sparse_size_coder, & sparse_size_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.numblocks",
      & sparse_numblocks_coder, & sparse_numblocks_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.size", & sparse_size_coder, & sparse_size_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.offset",
      & sparse_offset_coder, & sparse_offset_decoder, 1, (_Bool)0}, 
        {"GNU.sparse.numbytes", & sparse_numbytes_coder, & sparse_numbytes_decoder, 1,
      (_Bool)0}, 
        {"GNU.sparse.map", (void (*)(struct tar_stat_info  const  * , char const   * ,
                                  struct xheader * , void const   *data ))((void *)0),
      & sparse_map_decoder, 0, (_Bool)0}, 
        {"GNU.dumpdir", & dumpdir_coder, & dumpdir_decoder, 1, (_Bool)0}, 
        {"GNU.volume.label", & volume_label_coder, & volume_label_decoder, 3, (_Bool)0}, 
        {"GNU.volume.filename",
      & volume_label_coder, & volume_filename_decoder, 3, (_Bool)0}, 
        {"GNU.volume.size", & volume_size_coder, & volume_size_decoder, 3, (_Bool)0}, 
        {"GNU.volume.offset",
      & volume_offset_coder, & volume_offset_decoder, 3, (_Bool)0}, 
        {"RHT.security.selinux", & xattr_selinux_coder, & xattr_selinux_decoder, 0, (_Bool)0}, 
        {"SCHILY.acl.access",
      & xattr_acls_a_coder, & xattr_acls_a_decoder, 0, (_Bool)0}, 
        {"SCHILY.acl.default", & xattr_acls_d_coder, & xattr_acls_d_decoder, 0, (_Bool)0}, 
        {"SCHILY.xattr",
      & xattr_coder, & xattr_decoder, 0, (_Bool)1}, 
        {(char const   *)((void *)0), (void (*)(struct tar_stat_info  const  * , char const   * ,
                                             struct xheader * , void const   *data ))((void *)0),
      (void (*)(struct tar_stat_info * , char const   * , char const   * , size_t  ))((void *)0),
      0, (_Bool)0}};
#line 324 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) mkdirat)(int __fd ,
                                                                                              char const   *__path ,
                                                                                              __mode_t __mode ) ;
#line 339
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd ,
                                                                                              char const   *__path ,
                                                                                              __mode_t __mode ,
                                                                                              __dev_t __dev ) ;
#line 353
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) mkfifoat)(int __fd ,
                                                                                               char const   *__path ,
                                                                                               __mode_t __mode ) ;
#line 481 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 681
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 798
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int __fromfd ,
                                                                                               char const   *__from ,
                                                                                               int __tofd ,
                                                                                               char const   *__to ,
                                                                                               int __flags ) ;
#line 818
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3), __leaf__)) symlinkat)(char const   *__from ,
                                                                                                  int __tofd ,
                                                                                                  char const   *__to ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 23 "../gnu/priv-set.h"
#pragma GCC diagnostic push
#line 23
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 23
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 64
#pragma GCC diagnostic pop
#line 32 "../gnu/utimens.h"
#pragma GCC diagnostic push
#line 32
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 32
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 47
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 954
void (*fatal_exit_hook)(void) ;
#line 974
#pragma GCC diagnostic pop
#line 32 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static _Bool we_are_root  ;
#line 33 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static mode_t newdir_umask  ;
#line 34 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static mode_t current_umask  ;
#line 47 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static _Bool implemented(int err ) 
{ 
  int tmp ;

  {
#line 50
  if (err == 38) {
#line 50
    tmp = 0;
  } else
#line 50
  if (err == 95) {
#line 50
    tmp = 0;
  } else {
#line 50
    tmp = 1;
  }
#line 50
  return ((_Bool )tmp);
}
}
#line 115 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static struct delayed_set_stat *delayed_set_stat_head  ;
#line 166 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static struct delayed_link *delayed_link_head  ;
#line 175 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
void extr_init(void) 
{ 
  __uid_t tmp ;

  {
  {
#line 178
  tmp = geteuid();
#line 178
  we_are_root = (_Bool )(tmp == 0U);
#line 179
  same_permissions_option += (int )we_are_root;
#line 180
  same_owner_option += (int )we_are_root;
#line 186
  newdir_umask = umask((__mode_t )0);
  }
#line 187
  if (0 < same_permissions_option) {
#line 188
    current_umask = (mode_t )0;
  } else {
    {
#line 191
    umask(newdir_umask);
#line 192
    current_umask = newdir_umask;
    }
  }
#line 194
  return;
}
}
#line 197 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int fd_chmod(int fd , char const   *file , mode_t mode , int atflag ) 
{ 
  int result ;
  int tmp ;
  int *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 200
  if (0 <= fd) {
    {
#line 202
    tmp = fchmod(fd, mode);
#line 202
    result = tmp;
    }
#line 203
    if (result == 0) {
#line 204
      return (result);
    } else {
      {
#line 203
      tmp___0 = __errno_location();
#line 203
      tmp___1 = implemented(*tmp___0);
      }
#line 203
      if (tmp___1) {
#line 204
        return (result);
      }
    }
  }
  {
#line 206
  tmp___2 = fchmodat(chdir_fd, file, mode, atflag);
  }
#line 206
  return (tmp___2);
}
}
#line 210 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int fd_chown(int fd , char const   *file , uid_t uid , gid_t gid , int atflag ) 
{ 
  int result ;
  int tmp ;
  int *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
#line 213
  if (0 <= fd) {
    {
#line 215
    tmp = fchown(fd, uid, gid);
#line 215
    result = tmp;
    }
#line 216
    if (result == 0) {
#line 217
      return (result);
    } else {
      {
#line 216
      tmp___0 = __errno_location();
#line 216
      tmp___1 = implemented(*tmp___0);
      }
#line 216
      if (tmp___1) {
#line 217
        return (result);
      }
    }
  }
  {
#line 219
  tmp___2 = fchownat(chdir_fd, file, uid, gid, atflag);
  }
#line 219
  return (tmp___2);
}
}
#line 223 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int fd_stat(int fd , char const   *file , struct stat *st , int atflag ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 226
  if (0 <= fd) {
    {
#line 226
    tmp = fstat(fd, st);
#line 226
    tmp___1 = tmp;
    }
  } else {
    {
#line 226
    tmp___0 = fstatat(chdir_fd, (char const   */* __restrict  */)file, (struct stat */* __restrict  */)st,
                      atflag);
#line 226
    tmp___1 = tmp___0;
    }
  }
#line 226
  return (tmp___1);
}
}
#line 239 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void set_mode(char const   *file_name___0 , mode_t mode , mode_t mode_mask ,
                     int fd , mode_t current_mode , mode_t current_mode_mask , char typeflag ,
                     int atflag ) 
{ 
  struct stat st ;
  int tmp ;
  int chmod_errno ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  int *tmp___12 ;
  _Bool tmp___13 ;

  {
#line 245
  if (((current_mode ^ mode) | ~ current_mode_mask) & mode_mask) {
#line 247
    if (((unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) & ~ mode_mask) & ~ current_mode_mask) {
      {
#line 250
      tmp = fd_stat(fd, file_name___0, & st, atflag);
      }
#line 250
      if (tmp != 0) {
        {
#line 252
        stat_error(file_name___0);
        }
#line 253
        return;
      }
#line 255
      current_mode = st.st_mode;
    }
#line 258
    current_mode &= (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))));
#line 259
    mode = (current_mode & ~ mode_mask) | (mode & mode_mask);
#line 261
    if (current_mode != mode) {
      {
#line 263
      tmp___3 = fd_chmod(fd, file_name___0, mode, atflag);
      }
#line 263
      if (tmp___3 == 0) {
#line 263
        tmp___2 = 0;
      } else {
        {
#line 263
        tmp___1 = __errno_location();
#line 263
        tmp___2 = *tmp___1;
        }
      }
#line 263
      chmod_errno = tmp___2;
#line 270
      if (chmod_errno == 1) {
#line 270
        if (mode & 2048U) {
          {
#line 270
          tmp___7 = priv_set_remove_linkdir();
          }
#line 270
          if (tmp___7 == 0) {
            {
#line 273
            tmp___6 = fd_chmod(fd, file_name___0, mode, atflag);
            }
#line 273
            if (tmp___6 == 0) {
#line 273
              chmod_errno = 0;
            } else {
              {
#line 273
              tmp___5 = __errno_location();
#line 273
              chmod_errno = *tmp___5;
              }
            }
            {
#line 275
            priv_set_remove_linkdir();
            }
          }
        }
      }
#line 283
      if (atflag) {
#line 283
        if ((int )typeflag != 50) {
          {
#line 283
          tmp___11 = implemented(chmod_errno);
          }
#line 283
          if (! tmp___11) {
            {
#line 284
            tmp___10 = fd_chmod(fd, file_name___0, mode, 0);
            }
#line 284
            if (tmp___10 == 0) {
#line 284
              chmod_errno = 0;
            } else {
              {
#line 284
              tmp___9 = __errno_location();
#line 284
              chmod_errno = *tmp___9;
              }
            }
          }
        }
      }
#line 286
      if (chmod_errno) {
#line 286
        if ((int )typeflag != 50) {
          {
#line 289
          tmp___12 = __errno_location();
#line 289
          *tmp___12 = chmod_errno;
#line 290
          chmod_error_details(file_name___0, mode);
          }
        } else {
          {
#line 286
          tmp___13 = implemented(chmod_errno);
          }
#line 286
          if (tmp___13) {
            {
#line 289
            tmp___12 = __errno_location();
#line 289
            *tmp___12 = chmod_errno;
#line 290
            chmod_error_details(file_name___0, mode);
            }
          }
        }
      }
    }
  }
#line 294
  return;
}
}
#line 297 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void check_time(char const   *file_name___0 , struct timespec t ) 
{ 
  char const   *tmp ;
  char *tmp___0 ;
  struct timespec now ;
  char buf[32] ;
  struct timespec diff ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int __attribute__((__pure__))  tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;

  {
#line 300
  if (t.tv_sec < 0L) {
    {
#line 301
    while (1) {
      while_continue: /* CIL Label */ ;
#line 301
      if (warning_option & 32768) {
        {
#line 301
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 301
          if (error_hook) {
            {
#line 301
            (*error_hook)();
            }
          }
          {
#line 301
          tmp = tartime(t, (_Bool)1);
#line 301
          tmp___0 = gettext("%s: implausibly old time stamp %s");
#line 301
          error(0, 0, (char const   *)tmp___0, file_name___0, tmp);
          }
#line 301
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 301
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 304
    tmp___5 = timespec_cmp(volume_start_time, t);
    }
#line 304
    if (tmp___5 < (int __attribute__((__pure__))  )0) {
      {
#line 307
      gettime(& now);
#line 308
      tmp___4 = timespec_cmp(now, t);
      }
#line 308
      if (tmp___4 < (int __attribute__((__pure__))  )0) {
#line 312
        diff.tv_sec = t.tv_sec - now.tv_sec;
#line 313
        diff.tv_nsec = t.tv_nsec - now.tv_nsec;
#line 314
        if (diff.tv_nsec < 0L) {
#line 316
          diff.tv_nsec += 1000000000L;
#line 317
          (diff.tv_sec) --;
        }
        {
#line 319
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 319
          if (warning_option & 32768) {
            {
#line 319
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 319
              if (error_hook) {
                {
#line 319
                (*error_hook)();
                }
              }
              {
#line 319
              tmp___1 = code_timespec(diff, buf);
#line 319
              tmp___2 = tartime(t, (_Bool)1);
#line 319
              tmp___3 = gettext("%s: time stamp %s is %s s in the future");
#line 319
              error(0, 0, (char const   *)tmp___3, file_name___0, tmp___2, tmp___1);
              }
#line 319
              goto while_break___2;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
#line 319
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
    }
  }
#line 324
  return;
}
}
#line 335 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void set_stat(char const   *file_name___0 , struct tar_stat_info  const  *st ,
                     int fd , mode_t current_mode , mode_t current_mode_mask , char typeflag ,
                     _Bool interdir , int atflag ) 
{ 
  struct timespec ts[2] ;
  int *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  uid_t uid ;
  gid_t gid ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 344
  if (! touch_option) {
#line 344
    if (! interdir) {
#line 347
      if (incremental_option) {
#line 348
        ts[0] = (struct timespec )st->atime;
      } else {
#line 350
        ts[0].tv_nsec = (1L << 30) - 2L;
      }
      {
#line 351
      ts[1] = (struct timespec )st->mtime;
#line 353
      tmp___1 = fdutimensat(fd, chdir_fd, file_name___0, (struct timespec  const  *)(ts),
                            atflag);
      }
#line 353
      if (tmp___1 == 0) {
#line 355
        if (incremental_option) {
          {
#line 356
          check_time(file_name___0, ts[0]);
          }
        }
        {
#line 357
        check_time(file_name___0, ts[1]);
        }
      } else
#line 359
      if ((int )typeflag != 50) {
        {
#line 360
        utime_error(file_name___0);
        }
      } else {
        {
#line 359
        tmp = __errno_location();
#line 359
        tmp___0 = implemented(*tmp);
        }
#line 359
        if (tmp___0) {
          {
#line 360
          utime_error(file_name___0);
          }
        }
      }
    }
  }
#line 363
  if (0 < same_owner_option) {
#line 363
    if (! interdir) {
      {
#line 371
      uid = (uid_t )st->stat.st_uid;
#line 372
      gid = (gid_t )st->stat.st_gid;
#line 374
      tmp___4 = fd_chown(fd, file_name___0, uid, gid, atflag);
      }
#line 374
      if (tmp___4 == 0) {
#line 377
        if ((current_mode | ~ current_mode_mask) & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 378
          current_mode_mask &= ~ (current_mode & 3072U);
        }
      } else
#line 380
      if ((int )typeflag != 50) {
        {
#line 381
        chown_error_details(file_name___0, uid, gid);
        }
      } else {
        {
#line 380
        tmp___2 = __errno_location();
#line 380
        tmp___3 = implemented(*tmp___2);
        }
#line 380
        if (tmp___3) {
          {
#line 381
          chown_error_details(file_name___0, uid, gid);
          }
        }
      }
    }
  }
#line 384
  if (0 < same_permissions_option) {
#line 384
    if (! interdir) {
#line 384
      tmp___5 = 3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
    } else {
#line 384
      tmp___5 = ((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
    }
  } else {
#line 384
    tmp___5 = ((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
  }
  {
#line 384
  set_mode(file_name___0, (mode_t )(st->stat.st_mode & (unsigned int const   )(~ current_umask)),
           (mode_t )tmp___5, fd, current_mode, current_mode_mask, typeflag, atflag);
#line 391
  xattrs_xattrs_set(st, file_name___0, typeflag, 1);
#line 392
  xattrs_acls_set(st, file_name___0, typeflag);
#line 393
  xattrs_selinux_set(st, file_name___0, typeflag);
  }
#line 394
  return;
}
}
#line 399 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void mark_after_links(struct delayed_set_stat *head ) 
{ 
  struct delayed_set_stat *h ;
  struct stat st ;
  int tmp ;

  {
#line 402
  h = head;
  {
#line 404
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 407
    h->after_links = (_Bool)1;
#line 409
    tmp = deref_stat((char const   *)h->file_name, & st);
    }
#line 409
    if (tmp != 0) {
      {
#line 410
      stat_error((char const   *)h->file_name);
      }
    } else {
#line 413
      h->dev = st.st_dev;
#line 414
      h->ino = st.st_ino;
    }
#line 404
    h = h->next;
#line 404
    if (h) {
#line 404
      if (! (! h->after_links)) {
#line 404
        goto while_break;
      }
    } else {
#line 404
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return;
}
}
#line 438 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void delay_set_stat(char const   *file_name___0 , struct tar_stat_info  const  *st ,
                           mode_t current_mode , mode_t current_mode_mask , mode_t mode ,
                           int atflag ) 
{ 
  size_t file_name_len ;
  size_t tmp ;
  struct delayed_set_stat *data ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 443
  tmp = strlen(file_name___0);
#line 443
  file_name_len = tmp;
#line 444
  tmp___0 = xmalloc(sizeof(*data));
#line 444
  data = (struct delayed_set_stat *)tmp___0;
#line 445
  data->next = delayed_set_stat_head;
#line 446
  data->mode = mode;
  }
#line 447
  if (st) {
#line 449
    data->dev = (dev_t )st->stat.st_dev;
#line 450
    data->ino = (ino_t )st->stat.st_ino;
#line 451
    data->uid = (uid_t )st->stat.st_uid;
#line 452
    data->gid = (gid_t )st->stat.st_gid;
#line 453
    data->atime = (struct timespec )st->atime;
#line 454
    data->mtime = (struct timespec )st->mtime;
  }
  {
#line 456
  data->file_name_len = file_name_len;
#line 457
  data->file_name = xstrdup(file_name___0);
#line 458
  data->current_mode = current_mode;
#line 459
  data->current_mode_mask = current_mode_mask;
#line 460
  data->interdir = (_Bool )(! st);
#line 461
  data->atflag = atflag;
#line 462
  data->after_links = (_Bool)0;
#line 463
  data->change_dir = chdir_current;
#line 464
  data->cntx_name = (char *)((void *)0);
  }
#line 465
  if (st) {
    {
#line 466
    assign_string(& data->cntx_name, (char const   *)st->cntx_name);
    }
  }
#line 467
  if (st) {
#line 467
    if (st->acls_a_ptr) {
      {
#line 469
      tmp___1 = xmemdup((void const   *)st->acls_a_ptr, (size_t )(st->acls_a_len + 1UL));
#line 469
      data->acls_a_ptr = (char *)tmp___1;
#line 470
      data->acls_a_len = (size_t )st->acls_a_len;
      }
    } else {
#line 474
      data->acls_a_ptr = (char *)((void *)0);
#line 475
      data->acls_a_len = (size_t )0;
    }
  } else {
#line 474
    data->acls_a_ptr = (char *)((void *)0);
#line 475
    data->acls_a_len = (size_t )0;
  }
#line 477
  if (st) {
#line 477
    if (st->acls_d_ptr) {
      {
#line 479
      tmp___2 = xmemdup((void const   *)st->acls_d_ptr, (size_t )(st->acls_d_len + 1UL));
#line 479
      data->acls_d_ptr = (char *)tmp___2;
#line 480
      data->acls_d_len = (size_t )st->acls_d_len;
      }
    } else {
#line 484
      data->acls_d_ptr = (char *)((void *)0);
#line 485
      data->acls_d_len = (size_t )0;
    }
  } else {
#line 484
    data->acls_d_ptr = (char *)((void *)0);
#line 485
    data->acls_d_len = (size_t )0;
  }
#line 487
  if (st) {
    {
#line 488
    xheader_xattr_copy(st, & data->xattr_map, & data->xattr_map_size);
    }
  } else {
#line 491
    data->xattr_map = (struct xattr_array *)((void *)0);
#line 492
    data->xattr_map_size = (size_t )0;
  }
  {
#line 494
  strcpy((char */* __restrict  */)data->file_name, (char const   */* __restrict  */)file_name___0);
#line 495
  delayed_set_stat_head = data;
#line 496
  tmp___3 = must_be_dot_or_slash(file_name___0);
  }
#line 496
  if (tmp___3) {
    {
#line 497
    mark_after_links(data);
    }
  }
#line 498
  return;
}
}
#line 504 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void repair_delayed_set_stat(char const   *dir , struct stat  const  *dir_stat_info ) 
{ 
  struct delayed_set_stat *data ;
  struct stat st ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 509
  data = delayed_set_stat_head;
  {
#line 509
  while (1) {
    while_continue: /* CIL Label */ ;
#line 509
    if (! data) {
#line 509
      goto while_break;
    }
    {
#line 512
    tmp = fstatat(chdir_fd, (char const   */* __restrict  */)data->file_name, (struct stat */* __restrict  */)(& st),
                  data->atflag);
    }
#line 512
    if (tmp != 0) {
      {
#line 514
      stat_error((char const   *)data->file_name);
      }
#line 515
      return;
    }
#line 518
    if (st.st_dev == (__dev_t )dir_stat_info->st_dev) {
#line 518
      if (st.st_ino == (__ino_t )dir_stat_info->st_ino) {
#line 521
        data->dev = current_stat_info.stat.st_dev;
#line 522
        data->ino = current_stat_info.stat.st_ino;
#line 523
        data->mode = current_stat_info.stat.st_mode;
#line 524
        data->uid = current_stat_info.stat.st_uid;
#line 525
        data->gid = current_stat_info.stat.st_gid;
#line 526
        data->atime = current_stat_info.atime;
#line 527
        data->mtime = current_stat_info.mtime;
#line 528
        data->current_mode = st.st_mode;
#line 529
        data->current_mode_mask = ~ ((mode_t )0);
#line 530
        data->interdir = (_Bool)0;
#line 531
        return;
      }
    }
#line 509
    data = data->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 535
    if (error_hook) {
      {
#line 535
      (*error_hook)();
      }
    }
    {
#line 535
    tmp___0 = quotearg_colon(dir);
#line 535
    tmp___1 = gettext("%s: Unexpected inconsistency when making directory");
#line 535
    error(0, 0, (char const   *)tmp___1, tmp___0);
#line 535
    exit_status = 2;
    }
#line 535
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 537
  return;
}
}
#line 539 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void free_delayed_set_stat(struct delayed_set_stat *data ) 
{ 


  {
  {
#line 542
  free((void *)data->file_name);
#line 543
  xheader_xattr_free(data->xattr_map, data->xattr_map_size);
#line 544
  free((void *)data->cntx_name);
#line 545
  free((void *)data->acls_a_ptr);
#line 546
  free((void *)data->acls_d_ptr);
#line 547
  free((void *)data);
  }
#line 548
  return;
}
}
#line 550 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
void remove_delayed_set_stat(char const   *fname ) 
{ 
  struct delayed_set_stat *data ;
  struct delayed_set_stat *next ;
  struct delayed_set_stat *prev ;
  int tmp ;

  {
#line 553
  prev = (struct delayed_set_stat *)((void *)0);
#line 554
  data = delayed_set_stat_head;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! data) {
#line 554
      goto while_break;
    }
#line 556
    next = data->next;
#line 557
    if (chdir_current == data->change_dir) {
      {
#line 557
      tmp = strcmp((char const   *)data->file_name, fname);
      }
#line 557
      if (tmp == 0) {
        {
#line 560
        free_delayed_set_stat(data);
        }
#line 561
        if (prev) {
#line 562
          prev->next = next;
        } else {
#line 564
          delayed_set_stat_head = next;
        }
#line 565
        return;
      } else {
#line 568
        prev = data;
      }
    } else {
#line 568
      prev = data;
    }
#line 554
    data = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 570
  return;
}
}
#line 572 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void fixup_delayed_set_stat(char const   *src , char const   *dst ) 
{ 
  struct delayed_set_stat *data ;
  int tmp ;

  {
#line 576
  data = delayed_set_stat_head;
  {
#line 576
  while (1) {
    while_continue: /* CIL Label */ ;
#line 576
    if (! data) {
#line 576
      goto while_break;
    }
#line 578
    if (chdir_current == data->change_dir) {
      {
#line 578
      tmp = strcmp((char const   *)data->file_name, src);
      }
#line 578
      if (tmp == 0) {
        {
#line 581
        free((void *)data->file_name);
#line 582
        data->file_name = xstrdup(dst);
#line 583
        data->file_name_len = strlen(dst);
        }
#line 584
        return;
      }
    }
#line 576
    data = data->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 587
  return;
}
}
#line 594 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int make_directories(char *file_name___0 , _Bool *interdir_made ) 
{ 
  char *cursor0 ;
  char *cursor ;
  mode_t mode ;
  mode_t desired_mode ;
  int status ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  struct stat st ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 597
  cursor0 = file_name___0 + 0;
#line 600
  cursor = cursor0;
  {
#line 600
  while (1) {
    while_continue: /* CIL Label */ ;
#line 600
    if (! *cursor) {
#line 600
      goto while_break;
    }
#line 606
    if (! ((int )*cursor == 47)) {
#line 607
      goto __Cont;
    }
#line 611
    if ((unsigned long )cursor == (unsigned long )cursor0) {
#line 612
      goto __Cont;
    } else
#line 611
    if ((int )*(cursor + -1) == 47) {
#line 612
      goto __Cont;
    }
#line 616
    if ((int )*(cursor + -1) == 46) {
#line 616
      if ((unsigned long )cursor == (unsigned long )(cursor0 + 1)) {
#line 620
        goto __Cont;
      } else
#line 616
      if ((int )*(cursor + -2) == 47) {
#line 620
        goto __Cont;
      } else
#line 616
      if ((int )*(cursor + -2) == 46) {
#line 616
        if ((unsigned long )cursor == (unsigned long )(cursor0 + 2)) {
#line 620
          goto __Cont;
        } else
#line 616
        if ((int )*(cursor + -3) == 47) {
#line 620
          goto __Cont;
        }
      }
    }
#line 622
    *cursor = (char )'\000';
#line 623
    desired_mode = (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) & ~ newdir_umask;
#line 624
    if (we_are_root) {
#line 624
      tmp = 0;
    } else {
#line 624
      tmp = 192;
    }
    {
#line 624
    mode = desired_mode | (unsigned int )tmp;
#line 625
    status = mkdirat(chdir_fd, (char const   *)file_name___0, mode);
    }
#line 627
    if (status == 0) {
      {
#line 632
      delay_set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)0,
                     mode & ~ current_umask, (mode_t )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))),
                     desired_mode, 256);
#line 636
      print_for_mkdir(file_name___0, (int )(cursor - file_name___0), desired_mode);
#line 637
      *interdir_made = (_Bool)1;
      }
    } else {
      {
#line 639
      tmp___2 = __errno_location();
      }
#line 639
      if (*tmp___2 == 17) {
#line 640
        status = 0;
      } else {
        {
#line 647
        tmp___0 = __errno_location();
#line 647
        e = *tmp___0;
#line 649
        status = fstatat(chdir_fd, (char const   */* __restrict  */)file_name___0,
                         (struct stat */* __restrict  */)(& st), 0);
        }
#line 650
        if (status) {
          {
#line 652
          tmp___1 = __errno_location();
#line 652
          *tmp___1 = e;
#line 653
          mkdir_error((char const   *)file_name___0);
          }
        }
      }
    }
#line 657
    *cursor = (char )'/';
#line 658
    if (status) {
#line 659
      return (status);
    }
    __Cont: /* CIL Label */ 
#line 600
    cursor ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return (0);
}
}
#line 668 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static _Bool file_newer_p(char const   *file_name___0 , struct stat  const  *stp ,
                          struct tar_stat_info *tar_stat ) 
{ 
  struct stat st ;
  int *tmp ;
  int tmp___0 ;
  struct timespec  __attribute__((__pure__)) tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 674
  if (! stp) {
    {
#line 676
    tmp___0 = deref_stat(file_name___0, & st);
    }
#line 676
    if (tmp___0 != 0) {
      {
#line 678
      tmp = __errno_location();
      }
#line 678
      if (*tmp != 2) {
        {
#line 680
        stat_warn(file_name___0);
        }
#line 682
        return ((_Bool)1);
      }
#line 684
      return ((_Bool)0);
    }
#line 686
    stp = (struct stat  const  *)(& st);
  }
#line 689
  if (! ((stp->st_mode & 61440U) == 16384U)) {
    {
#line 689
    tmp___1 = get_stat_mtime(stp);
#line 689
    tmp___2 = tar_timespec_cmp(tar_stat->mtime, (struct timespec )tmp___1);
    }
#line 689
    if (tmp___2 <= 0) {
#line 689
      tmp___3 = 1;
    } else {
#line 689
      tmp___3 = 0;
    }
  } else {
#line 689
    tmp___3 = 0;
  }
#line 689
  return ((_Bool )tmp___3);
}
}
#line 709 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int maybe_recoverable(char *file_name___0 , _Bool regular , _Bool *interdir_made ) 
{ 
  int e ;
  int *tmp ;
  struct stat st ;
  struct stat  const  *stp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;

  {
  {
#line 712
  tmp = __errno_location();
#line 712
  e = *tmp;
#line 714
  stp = (struct stat  const  *)0;
  }
#line 716
  if (*interdir_made) {
#line 717
    return (0);
  }
  {
#line 732
  if (e == 95) {
#line 732
    goto case_95;
  }
#line 732
  if (e == 31) {
#line 732
    goto case_95;
  }
#line 732
  if (e == 40) {
#line 732
    goto case_95;
  }
#line 747
  if (e == 17) {
#line 747
    goto case_17;
  }
#line 776
  if (e == 2) {
#line 776
    goto case_2___0;
  }
#line 782
  goto switch_default;
  case_95: /* CIL Label */ 
  case_31: /* CIL Label */ 
  case_40: /* CIL Label */ 
#line 734
  if (! regular) {
#line 736
    goto switch_break;
  } else
#line 734
  if ((unsigned int )old_files_option != 2U) {
#line 736
    goto switch_break;
  } else
#line 734
  if (dereference_option) {
#line 736
    goto switch_break;
  }
  {
#line 737
  tmp___1 = strchr((char const   *)file_name___0, '/');
  }
#line 737
  if (tmp___1) {
    {
#line 739
    tmp___0 = deref_stat((char const   *)file_name___0, & st);
    }
#line 739
    if (tmp___0 != 0) {
#line 740
      goto switch_break;
    }
#line 741
    stp = (struct stat  const  *)(& st);
  }
  case_17: /* CIL Label */ 
  {
#line 752
  if ((unsigned int )old_files_option == 5U) {
#line 752
    goto case_5;
  }
#line 757
  if ((unsigned int )old_files_option == 4U) {
#line 757
    goto case_4;
  }
#line 760
  if ((unsigned int )old_files_option == 6U) {
#line 760
    goto case_6;
  }
#line 767
  if ((unsigned int )old_files_option == 2U) {
#line 767
    goto case_2;
  }
#line 767
  if ((unsigned int )old_files_option == 1U) {
#line 767
    goto case_2;
  }
#line 767
  if ((unsigned int )old_files_option == 0U) {
#line 767
    goto case_2;
  }
#line 772
  if ((unsigned int )old_files_option == 3U) {
#line 772
    goto case_3;
  }
#line 750
  goto switch_break___0;
  case_5: /* CIL Label */ 
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 753
    if (warning_option & 1048576) {
      {
#line 753
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 753
        if (error_hook) {
          {
#line 753
          (*error_hook)();
          }
        }
        {
#line 753
        tmp___2 = gettext("%s: skipping existing file");
#line 753
        error(0, 0, (char const   *)tmp___2, file_name___0);
        }
#line 753
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 753
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 755
  return (2);
  case_4: /* CIL Label */ 
#line 758
  return (0);
  case_6: /* CIL Label */ 
  {
#line 761
  tmp___3 = file_newer_p((char const   *)file_name___0, stp, & current_stat_info);
  }
#line 761
  if (tmp___3) {
#line 762
    goto switch_break___0;
  }
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
  case_0: /* CIL Label */ 
  {
#line 768
  tmp___4 = remove_any_file((char const   *)file_name___0, (enum remove_option )0);
  }
#line 768
  if (0 < tmp___4) {
#line 769
    return (1);
  }
#line 770
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 773
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
  case_2___0: /* CIL Label */ 
  {
#line 778
  tmp___5 = make_directories(file_name___0, interdir_made);
  }
#line 778
  if (tmp___5 == 0) {
#line 778
    if (*interdir_made) {
#line 779
      return (1);
    }
  }
#line 780
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 784
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 787
  tmp___6 = __errno_location();
#line 787
  *tmp___6 = e;
  }
#line 788
  return (0);
}
}
#line 799 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int set_xattr(char const   *file_name___0 , struct tar_stat_info  const  *st ,
                     mode_t invert_permissions , char typeflag , int *file_created ) 
{ 
  int status ;
  _Bool interdir_made ;
  mode_t mode ;
  int tmp ;

  {
#line 803
  status = 0;
#line 806
  interdir_made = (_Bool)0;
#line 808
  if (xattrs_option > 0) {
#line 808
    if (st->xattr_map_size) {
#line 810
      mode = (current_stat_info.stat.st_mode & (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) & ~ current_umask;
      {
#line 812
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 813
        status = mknodat(chdir_fd, file_name___0, mode ^ invert_permissions, (__dev_t )0);
        }
#line 812
        if (status) {
          {
#line 812
          tmp = maybe_recoverable((char *)file_name___0, (_Bool)0, & interdir_made);
          }
#line 812
          if (! tmp) {
#line 812
            goto while_break;
          }
        } else {
#line 812
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 817
      xattrs_xattrs_set(st, file_name___0, typeflag, 0);
#line 818
      *file_created = 1;
      }
    }
  }
#line 822
  return (status);
}
}
#line 830 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void apply_nonancestor_delayed_set_stat(char const   *file_name___0 , _Bool after_links ) 
{ 
  size_t file_name_len ;
  size_t tmp ;
  _Bool check_for_renamed_directories ;
  struct delayed_set_stat *data ;
  _Bool skip_this_one ;
  struct stat st ;
  mode_t current_mode ;
  mode_t current_mode_mask ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  struct tar_stat_info sb ;

  {
  {
#line 833
  tmp = strlen(file_name___0);
#line 833
  file_name_len = tmp;
#line 834
  check_for_renamed_directories = (_Bool)0;
  }
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! delayed_set_stat_head) {
#line 836
      goto while_break;
    }
#line 838
    data = delayed_set_stat_head;
#line 839
    skip_this_one = (_Bool)0;
#line 841
    current_mode = data->current_mode;
#line 842
    current_mode_mask = data->current_mode_mask;
#line 844
    check_for_renamed_directories = (_Bool )((int )check_for_renamed_directories | (int )data->after_links);
#line 846
    if ((int )after_links < (int )data->after_links) {
#line 852
      goto while_break;
    } else
#line 846
    if (data->file_name_len < file_name_len) {
#line 846
      if (*(file_name___0 + data->file_name_len)) {
#line 846
        if ((int const   )*(file_name___0 + data->file_name_len) == 47) {
#line 846
          goto _L;
        } else
#line 846
        if ((int const   )*(file_name___0 + (data->file_name_len - 1UL)) == 47) {
          _L: /* CIL Label */ 
          {
#line 846
          tmp___0 = memcmp((void const   *)file_name___0, (void const   *)data->file_name,
                           data->file_name_len);
          }
#line 846
          if (tmp___0 == 0) {
#line 852
            goto while_break;
          }
        }
      }
    }
    {
#line 854
    chdir_do(data->change_dir);
    }
#line 856
    if (check_for_renamed_directories) {
      {
#line 858
      tmp___3 = fstatat(chdir_fd, (char const   */* __restrict  */)data->file_name,
                        (struct stat */* __restrict  */)(& st), data->atflag);
      }
#line 858
      if (tmp___3 != 0) {
        {
#line 860
        stat_error((char const   *)data->file_name);
#line 861
        skip_this_one = (_Bool)1;
        }
      } else {
#line 865
        current_mode = st.st_mode;
#line 866
        current_mode_mask = ~ ((mode_t )0);
#line 867
        if (st.st_dev == data->dev) {
#line 867
          if (! (st.st_ino == data->ino)) {
#line 867
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          {
#line 869
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 869
            if (error_hook) {
              {
#line 869
              (*error_hook)();
              }
            }
            {
#line 869
            tmp___1 = quotearg_colon((char const   *)data->file_name);
#line 869
            tmp___2 = gettext("%s: Directory renamed before its status could be extracted");
#line 869
            error(0, 0, (char const   *)tmp___2, tmp___1);
#line 869
            exit_status = 2;
            }
#line 869
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
#line 872
          skip_this_one = (_Bool)1;
        }
      }
    }
#line 877
    if (! skip_this_one) {
      {
#line 880
      sb.stat.st_mode = data->mode;
#line 881
      sb.stat.st_uid = data->uid;
#line 882
      sb.stat.st_gid = data->gid;
#line 883
      sb.atime = data->atime;
#line 884
      sb.mtime = data->mtime;
#line 885
      sb.cntx_name = data->cntx_name;
#line 886
      sb.acls_a_ptr = data->acls_a_ptr;
#line 887
      sb.acls_a_len = data->acls_a_len;
#line 888
      sb.acls_d_ptr = data->acls_d_ptr;
#line 889
      sb.acls_d_len = data->acls_d_len;
#line 890
      sb.xattr_map = data->xattr_map;
#line 891
      sb.xattr_map_size = data->xattr_map_size;
#line 892
      set_stat((char const   *)data->file_name, (struct tar_stat_info  const  *)(& sb),
               -1, current_mode, current_mode_mask, (char )'5', data->interdir, data->atflag);
      }
    }
    {
#line 897
    delayed_set_stat_head = data->next;
#line 898
    free_delayed_set_stat(data);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 900
  return;
}
}
#line 903 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static _Bool is_directory_link(char const   *file_name___0 ) 
{ 
  struct stat st ;
  int e ;
  int *tmp ;
  int res ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 907
  tmp = __errno_location();
#line 907
  e = *tmp;
#line 910
  tmp___0 = fstatat(chdir_fd, (char const   */* __restrict  */)file_name___0, (struct stat */* __restrict  */)(& st),
                    256);
  }
#line 910
  if (tmp___0 == 0) {
#line 910
    if ((st.st_mode & 61440U) == 40960U) {
      {
#line 910
      tmp___1 = fstatat(chdir_fd, (char const   */* __restrict  */)file_name___0,
                        (struct stat */* __restrict  */)(& st), 0);
      }
#line 910
      if (tmp___1 == 0) {
#line 910
        if ((st.st_mode & 61440U) == 16384U) {
#line 910
          tmp___2 = 1;
        } else {
#line 910
          tmp___2 = 0;
        }
      } else {
#line 910
        tmp___2 = 0;
      }
    } else {
#line 910
      tmp___2 = 0;
    }
  } else {
#line 910
    tmp___2 = 0;
  }
  {
#line 910
  res = tmp___2;
#line 914
  tmp___3 = __errno_location();
#line 914
  *tmp___3 = e;
  }
#line 915
  return ((_Bool )res);
}
}
#line 920 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_dir(char *file_name___0 , int typeflag ) 
{ 
  int status ;
  mode_t mode ;
  mode_t current_mode ;
  mode_t current_mode_mask ;
  int atflag ;
  _Bool interdir_made ;
  struct stat st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct stat st___0 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
#line 925
  current_mode = (mode_t )0;
#line 926
  current_mode_mask = (mode_t )0;
#line 927
  atflag = 0;
#line 928
  interdir_made = (_Bool)0;
#line 931
  if (one_file_system_option) {
#line 931
    if (root_device == 0UL) {
      {
#line 935
      tmp = fstatat(chdir_fd, (char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st),
                    0);
      }
#line 935
      if (tmp != 0) {
        {
#line 936
        stat_diag(".");
        }
      } else {
#line 938
        root_device = st.st_dev;
      }
    }
  }
#line 941
  if (incremental_option) {
    {
#line 943
    purge_directory((char const   *)file_name___0);
    }
  } else
#line 944
  if (typeflag == 68) {
    {
#line 945
    skip_member();
    }
  }
#line 954
  if (0 < same_owner_option) {
#line 954
    tmp___0 = 448;
  } else
#line 954
  if (0 < same_permissions_option) {
#line 954
    tmp___0 = 448;
  } else {
#line 954
    tmp___0 = ((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
  }
#line 954
  if (we_are_root) {
#line 954
    tmp___1 = 0;
  } else {
#line 954
    tmp___1 = 192;
  }
#line 954
  mode = (current_stat_info.stat.st_mode & (unsigned int )tmp___0) | (unsigned int )tmp___1;
  {
#line 960
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 962
    status = mkdirat(chdir_fd, (char const   *)file_name___0, mode);
    }
#line 963
    if (status == 0) {
#line 965
      current_mode = mode & ~ current_umask;
#line 966
      current_mode_mask = (mode_t )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 967
      atflag = 256;
#line 968
      goto while_break;
    }
    {
#line 971
    tmp___5 = __errno_location();
    }
#line 971
    if (*tmp___5 == 17) {
#line 971
      if (interdir_made) {
#line 971
        goto _L;
      } else
#line 971
      if (keep_directory_symlink_option) {
#line 971
        goto _L;
      } else
#line 971
      if ((unsigned int )old_files_option == 0U) {
#line 971
        goto _L;
      } else
#line 971
      if ((unsigned int )old_files_option == 2U) {
        _L: /* CIL Label */ 
#line 979
        if (keep_directory_symlink_option) {
          {
#line 979
          tmp___2 = is_directory_link((char const   *)file_name___0);
          }
#line 979
          if (tmp___2) {
#line 980
            return (0);
          }
        }
        {
#line 982
        tmp___3 = deref_stat((char const   *)file_name___0, & st___0);
        }
#line 982
        if (tmp___3 == 0) {
#line 984
          current_mode = st___0.st_mode;
#line 985
          current_mode_mask = ~ ((mode_t )0);
#line 987
          if ((current_mode & 61440U) == 16384U) {
#line 989
            if (interdir_made) {
              {
#line 991
              repair_delayed_set_stat((char const   *)file_name___0, (struct stat  const  *)(& st___0));
              }
#line 992
              return (0);
            }
#line 994
            goto while_break;
          }
        }
        {
#line 997
        tmp___4 = __errno_location();
#line 997
        *tmp___4 = 17;
        }
      }
    }
    {
#line 1000
    tmp___6 = maybe_recoverable(file_name___0, (_Bool)0, & interdir_made);
    }
    {
#line 1002
    if (tmp___6 == 1) {
#line 1002
      goto case_1;
    }
#line 1005
    if (tmp___6 == 2) {
#line 1005
      goto case_2;
    }
#line 1008
    if (tmp___6 == 0) {
#line 1008
      goto case_0;
    }
#line 1000
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1003
    goto __Cont;
    case_2: /* CIL Label */ 
#line 1006
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1009
    tmp___7 = __errno_location();
    }
#line 1009
    if (*tmp___7 != 17) {
      {
#line 1011
      mkdir_error((char const   *)file_name___0);
      }
#line 1012
      return (1);
    }
#line 1014
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1016
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1019
  if (status == 0) {
    {
#line 1022
    delay_set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
                   current_mode, current_mode_mask, current_stat_info.stat.st_mode,
                   atflag);
    }
  } else
#line 1019
  if ((unsigned int )old_files_option == 0U) {
    {
#line 1022
    delay_set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
                   current_mode, current_mode_mask, current_stat_info.stat.st_mode,
                   atflag);
    }
  } else
#line 1019
  if ((unsigned int )old_files_option == 2U) {
    {
#line 1022
    delay_set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
                   current_mode, current_mode_mask, current_stat_info.stat.st_mode,
                   atflag);
    }
  }
#line 1025
  return (status);
}
}
#line 1049 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int conttype_diagnosed  ;
#line 1030 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int open_output_file(char const   *file_name___0 , int typeflag , mode_t mode ,
                            int file_created , mode_t *current_mode , mode_t *current_mode_mask ) 
{ 
  int fd ;
  _Bool overwriting_old_files ;
  int openflag ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  struct stat st___0 ;
  int e ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;

  {
#line 1036
  overwriting_old_files = (_Bool )((unsigned int )old_files_option == 2U);
#line 1037
  if (overwriting_old_files) {
#line 1037
    if (dereference_option) {
#line 1037
      tmp = 0;
    } else {
#line 1037
      tmp = 131072;
    }
#line 1037
    tmp___0 = 512 | tmp;
  } else {
#line 1037
    tmp___0 = 128;
  }
#line 1037
  openflag = 526657 | tmp___0;
#line 1044
  if (file_created) {
#line 1045
    openflag &= -129;
  }
#line 1047
  if (typeflag == 55) {
#line 1051
    if (! conttype_diagnosed) {
#line 1053
      conttype_diagnosed = 1;
      {
#line 1054
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1054
        if (warning_option & 8) {
          {
#line 1054
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1054
            if (error_hook) {
              {
#line 1054
              (*error_hook)();
              }
            }
            {
#line 1054
            tmp___1 = gettext("Extracting contiguous files as regular files");
#line 1054
            error(0, 0, (char const   *)tmp___1);
            }
#line 1054
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
#line 1054
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
  {
#line 1074
  fd = openat(chdir_fd, file_name___0, openflag, mode);
  }
#line 1075
  if (0 <= fd) {
#line 1077
    if (overwriting_old_files) {
      {
#line 1080
      tmp___6 = fstat(fd, & st___0);
      }
#line 1080
      if (tmp___6 != 0) {
        {
#line 1082
        tmp___4 = __errno_location();
#line 1082
        e = *tmp___4;
#line 1083
        close(fd);
#line 1084
        tmp___5 = __errno_location();
#line 1084
        *tmp___5 = e;
        }
#line 1085
        return (-1);
      }
#line 1087
      if (! ((st___0.st_mode & 61440U) == 32768U)) {
        {
#line 1089
        close(fd);
#line 1090
        tmp___7 = __errno_location();
#line 1090
        *tmp___7 = 17;
        }
#line 1091
        return (-1);
      }
#line 1093
      *current_mode = st___0.st_mode;
#line 1094
      *current_mode_mask = ~ ((mode_t )0);
    } else {
#line 1098
      *current_mode = mode & ~ current_umask;
#line 1099
      *current_mode_mask = (mode_t )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
    }
  }
#line 1103
  return (fd);
}
}
#line 1106 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_file(char *file_name___0 , int typeflag ) 
{ 
  int fd ;
  off_t size ;
  union block *data_block ;
  int status ;
  size_t count ;
  size_t written ;
  _Bool interdir_made ;
  mode_t mode ;
  int tmp ;
  mode_t invert_permissions ;
  unsigned int tmp___0 ;
  mode_t current_mode ;
  mode_t current_mode_mask ;
  int file_created ;
  int tmp___1 ;
  int recover ;
  int tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1115
  interdir_made = (_Bool)0;
#line 1116
  if (0 < same_owner_option) {
#line 1116
    tmp = (448 >> 3) | ((448 >> 3) >> 3);
  } else {
#line 1116
    tmp = 0;
  }
#line 1116
  mode = (current_stat_info.stat.st_mode & (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) & (unsigned int )(~ tmp);
#line 1118
  if (0 < same_owner_option) {
#line 1118
    tmp___0 = mode & (unsigned int )((448 >> 3) | ((448 >> 3) >> 3));
  } else {
#line 1118
    tmp___0 = 0U;
  }
#line 1118
  invert_permissions = tmp___0;
#line 1120
  current_mode = (mode_t )0;
#line 1121
  current_mode_mask = (mode_t )0;
#line 1123
  if (to_stdout_option) {
#line 1124
    fd = 1;
  } else
#line 1125
  if (to_command_option) {
    {
#line 1127
    fd = sys_exec_command(file_name___0, 'f', & current_stat_info);
    }
#line 1128
    if (fd < 0) {
      {
#line 1130
      skip_member();
      }
#line 1131
      return (0);
    }
  } else {
    {
#line 1136
    file_created = 0;
#line 1137
    tmp___1 = set_xattr((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
                        invert_permissions, (char )typeflag, & file_created);
    }
#line 1137
    if (tmp___1) {
      {
#line 1140
      skip_member();
#line 1141
      open_error((char const   *)file_name___0);
      }
#line 1142
      return (1);
    }
    {
#line 1145
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1145
      fd = open_output_file((char const   *)file_name___0, typeflag, mode, file_created,
                            & current_mode, & current_mode_mask);
      }
#line 1145
      if (! (fd < 0)) {
#line 1145
        goto while_break;
      }
      {
#line 1150
      tmp___2 = maybe_recoverable(file_name___0, (_Bool)1, & interdir_made);
#line 1150
      recover = tmp___2;
      }
#line 1151
      if (recover != 1) {
        {
#line 1153
        skip_member();
        }
#line 1154
        if (recover == 2) {
#line 1155
          return (0);
        }
        {
#line 1156
        open_error((char const   *)file_name___0);
        }
#line 1157
        return (1);
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1162
  mv_begin_read(& current_stat_info);
  }
#line 1163
  if (current_stat_info.is_sparse) {
    {
#line 1164
    sparse_extract_file(fd, & current_stat_info, & size);
    }
  } else {
#line 1166
    size = current_stat_info.stat.st_size;
    {
#line 1166
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1166
      if (! (size > 0L)) {
#line 1166
        goto while_break___0;
      }
      {
#line 1168
      mv_size_left(size);
#line 1174
      data_block = find_next_block();
      }
#line 1175
      if (! data_block) {
        {
#line 1177
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1177
          if (error_hook) {
            {
#line 1177
            (*error_hook)();
            }
          }
          {
#line 1177
          tmp___3 = gettext("Unexpected EOF in archive");
#line 1177
          error(0, 0, (char const   *)tmp___3);
#line 1177
          exit_status = 2;
          }
#line 1177
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1178
        goto while_break___0;
      }
      {
#line 1181
      written = available_space_after(data_block);
      }
#line 1183
      if (written > (size_t )size) {
#line 1184
        written = (size_t )size;
      }
      {
#line 1185
      tmp___4 = __errno_location();
#line 1185
      *tmp___4 = 0;
#line 1186
      count = blocking_write(fd, (void const   *)(data_block->buffer), written);
#line 1187
      size = (off_t )((size_t )size - written);
#line 1189
      set_next_block_after((union block *)((data_block->buffer + written) - 1));
      }
#line 1191
      if (count != written) {
#line 1193
        if (! to_command_option) {
          {
#line 1194
          write_error_details((char const   *)file_name___0, count, written);
          }
        }
#line 1196
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1200
  skip_file(size);
#line 1202
  mv_end();
  }
#line 1207
  if (to_stdout_option) {
#line 1208
    return (0);
  }
#line 1210
  if (! to_command_option) {
#line 1211
    if ((unsigned int )old_files_option == 2U) {
#line 1211
      tmp___5 = 0;
    } else {
#line 1211
      tmp___5 = 256;
    }
    {
#line 1211
    set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
             fd, current_mode, current_mode_mask, (char )typeflag, (_Bool)0, tmp___5);
    }
  }
  {
#line 1216
  status = close(fd);
  }
#line 1217
  if (status < 0) {
    {
#line 1218
    close_error((char const   *)file_name___0);
    }
  }
#line 1220
  if (to_command_option) {
    {
#line 1221
    sys_wait_command();
    }
  }
#line 1223
  return (status);
}
}
#line 1232 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int create_placeholder_file(char *file_name___0 , _Bool is_symlink , _Bool *interdir_made ) 
{ 
  int fd ;
  struct stat st ;
  int tmp ;
  struct delayed_set_stat *h ;
  struct delayed_link *p ;
  size_t tmp___0 ;
  void *tmp___1 ;
  struct timespec  __attribute__((__pure__)) tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1238
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1238
    fd = openat(chdir_fd, (char const   *)file_name___0, 193, 0);
    }
#line 1238
    if (! (fd < 0)) {
#line 1238
      goto while_break;
    }
    {
#line 1240
    tmp = maybe_recoverable(file_name___0, (_Bool)0, interdir_made);
    }
    {
#line 1242
    if (tmp == 1) {
#line 1242
      goto case_1;
    }
#line 1245
    if (tmp == 2) {
#line 1245
      goto case_2;
    }
#line 1248
    if (tmp == 0) {
#line 1248
      goto case_0;
    }
#line 1240
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1243
    goto while_continue;
    case_2: /* CIL Label */ 
#line 1246
    return (0);
    case_0: /* CIL Label */ 
    {
#line 1249
    open_error((char const   *)file_name___0);
    }
#line 1250
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1254
  tmp___8 = fstat(fd, & st);
  }
#line 1254
  if (tmp___8 != 0) {
    {
#line 1256
    stat_error((char const   *)file_name___0);
#line 1257
    close(fd);
    }
  } else {
    {
#line 1259
    tmp___7 = close(fd);
    }
#line 1259
    if (tmp___7 != 0) {
      {
#line 1260
      close_error((char const   *)file_name___0);
      }
    } else {
      {
#line 1264
      tmp___0 = strlen((char const   *)current_stat_info.link_name);
#line 1264
      tmp___1 = xmalloc(((unsigned long )(& ((struct delayed_link *)0)->target) + tmp___0) + 1UL);
#line 1264
      p = (struct delayed_link *)tmp___1;
#line 1268
      p->next = delayed_link_head;
#line 1269
      delayed_link_head = p;
#line 1270
      p->dev = st.st_dev;
#line 1271
      p->ino = st.st_ino;
#line 1272
      tmp___2 = get_stat_birthtime((struct stat  const  *)(& st));
#line 1272
      p->birthtime = (struct timespec )tmp___2;
#line 1273
      p->is_symlink = is_symlink;
      }
#line 1274
      if (is_symlink) {
#line 1276
        p->mode = current_stat_info.stat.st_mode;
#line 1277
        p->uid = current_stat_info.stat.st_uid;
#line 1278
        p->gid = current_stat_info.stat.st_gid;
#line 1279
        p->atime = current_stat_info.atime;
#line 1280
        p->mtime = current_stat_info.mtime;
      }
      {
#line 1282
      p->change_dir = chdir_current;
#line 1283
      tmp___3 = strlen((char const   *)file_name___0);
#line 1283
      tmp___4 = xmalloc(((unsigned long )(& ((struct string_list *)0)->string) + tmp___3) + 1UL);
#line 1283
      p->sources = (struct string_list *)tmp___4;
#line 1285
      (p->sources)->next = (struct string_list *)0;
#line 1286
      strcpy((char */* __restrict  */)((p->sources)->string), (char const   */* __restrict  */)file_name___0);
#line 1287
      p->cntx_name = (char *)((void *)0);
#line 1288
      assign_string(& p->cntx_name, (char const   *)current_stat_info.cntx_name);
#line 1289
      p->acls_a_ptr = (char *)((void *)0);
#line 1290
      p->acls_a_len = (size_t )0;
#line 1291
      p->acls_d_ptr = (char *)((void *)0);
#line 1292
      p->acls_d_len = (size_t )0;
#line 1293
      xheader_xattr_copy((struct tar_stat_info  const  *)(& current_stat_info), & p->xattr_map,
                         & p->xattr_map_size);
#line 1294
      strcpy((char */* __restrict  */)(p->target), (char const   */* __restrict  */)current_stat_info.link_name);
#line 1296
      h = delayed_set_stat_head;
      }
#line 1297
      if (h) {
#line 1297
        if (! h->after_links) {
          {
#line 1297
          tmp___5 = strncmp((char const   *)file_name___0, (char const   *)h->file_name,
                            h->file_name_len);
          }
#line 1297
          if (tmp___5 == 0) {
#line 1297
            if ((int )*(file_name___0 + h->file_name_len) == 47) {
              {
#line 1297
              tmp___6 = last_component((char const   *)file_name___0);
              }
#line 1297
              if ((unsigned long )tmp___6 == (unsigned long )((file_name___0 + h->file_name_len) + 1)) {
                {
#line 1301
                mark_after_links(h);
                }
              }
            }
          }
        }
      }
#line 1303
      return (0);
    }
  }
#line 1306
  return (-1);
}
}
#line 1309 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_link(char *file_name___0 , int typeflag ) 
{ 
  _Bool interdir_made ;
  char const   *link_name ;
  int rc ;
  int tmp ;
  _Bool tmp___0 ;
  struct stat st1 ;
  struct stat st2 ;
  int e ;
  int status ;
  int tmp___1 ;
  int *tmp___2 ;
  struct delayed_link *ds ;
  struct string_list *p ;
  size_t tmp___3 ;
  void *tmp___4 ;
  struct timespec  __attribute__((__pure__)) tmp___5 ;
  int __attribute__((__pure__))  tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 1312
  interdir_made = (_Bool)0;
#line 1316
  link_name = (char const   *)current_stat_info.link_name;
#line 1318
  if (! absolute_names_option) {
    {
#line 1318
    tmp___0 = contains_dot_dot(link_name);
    }
#line 1318
    if (tmp___0) {
      {
#line 1319
      tmp = create_placeholder_file(file_name___0, (_Bool)0, & interdir_made);
      }
#line 1319
      return (tmp);
    }
  }
  {
#line 1321
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1325
    tmp___1 = linkat(chdir_fd, link_name, chdir_fd, (char const   *)file_name___0,
                     0);
#line 1325
    status = tmp___1;
#line 1326
    tmp___2 = __errno_location();
#line 1326
    e = *tmp___2;
    }
#line 1328
    if (status == 0) {
#line 1330
      ds = delayed_link_head;
#line 1331
      if (ds) {
        {
#line 1331
        tmp___7 = fstatat(chdir_fd, (char const   */* __restrict  */)link_name, (struct stat */* __restrict  */)(& st1),
                          256);
        }
#line 1331
        if (tmp___7 == 0) {
          {
#line 1333
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1333
            if (! ds) {
#line 1333
              goto while_break___0;
            }
#line 1334
            if (ds->change_dir == chdir_current) {
#line 1334
              if (ds->dev == st1.st_dev) {
#line 1334
                if (ds->ino == st1.st_ino) {
                  {
#line 1334
                  tmp___5 = get_stat_birthtime((struct stat  const  *)(& st1));
#line 1334
                  tmp___6 = timespec_cmp(ds->birthtime, (struct timespec )tmp___5);
                  }
#line 1334
                  if (tmp___6 == (int __attribute__((__pure__))  )0) {
                    {
#line 1340
                    tmp___3 = strlen((char const   *)file_name___0);
#line 1340
                    tmp___4 = xmalloc(((unsigned long )(& ((struct string_list *)0)->string) + tmp___3) + 1UL);
#line 1340
                    p = (struct string_list *)tmp___4;
#line 1342
                    strcpy((char */* __restrict  */)(p->string), (char const   */* __restrict  */)file_name___0);
#line 1343
                    p->next = ds->sources;
#line 1344
                    ds->sources = p;
                    }
#line 1345
                    goto while_break___0;
                  }
                }
              }
            }
#line 1333
            ds = ds->next;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      }
#line 1347
      return (0);
    } else
#line 1349
    if (e == 17) {
      {
#line 1349
      tmp___8 = strcmp(link_name, (char const   *)file_name___0);
      }
#line 1349
      if (tmp___8 == 0) {
#line 1356
        return (0);
      } else {
#line 1349
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 1349
      tmp___9 = fstatat(chdir_fd, (char const   */* __restrict  */)link_name, (struct stat */* __restrict  */)(& st1),
                        256);
      }
#line 1349
      if (tmp___9 == 0) {
        {
#line 1349
        tmp___10 = fstatat(chdir_fd, (char const   */* __restrict  */)file_name___0,
                           (struct stat */* __restrict  */)(& st2), 256);
        }
#line 1349
        if (tmp___10 == 0) {
#line 1349
          if (st1.st_dev == st2.st_dev) {
#line 1349
            if (st1.st_ino == st2.st_ino) {
#line 1356
              return (0);
            }
          }
        }
      }
    }
    {
#line 1358
    tmp___11 = __errno_location();
#line 1358
    *tmp___11 = e;
#line 1321
    rc = maybe_recoverable(file_name___0, (_Bool)0, & interdir_made);
    }
#line 1321
    if (! (rc == 1)) {
#line 1321
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1363
  if (rc == 2) {
#line 1364
    return (0);
  }
#line 1365
  if (incremental_option) {
    {
#line 1365
    tmp___12 = __errno_location();
    }
#line 1365
    if (! (*tmp___12 == 17)) {
      {
#line 1367
      link_error(link_name, (char const   *)file_name___0);
      }
#line 1368
      return (1);
    }
  } else {
    {
#line 1367
    link_error(link_name, (char const   *)file_name___0);
    }
#line 1368
    return (1);
  }
#line 1370
  return (0);
}
}
#line 1373 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_symlink(char *file_name___0 , int typeflag ) 
{ 
  _Bool interdir_made ;
  int tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1377
  interdir_made = (_Bool)0;
#line 1379
  if (! absolute_names_option) {
#line 1379
    if ((int )*(current_stat_info.link_name + 0) == 47) {
      {
#line 1382
      tmp = create_placeholder_file(file_name___0, (_Bool)1, & interdir_made);
      }
#line 1382
      return (tmp);
    } else {
      {
#line 1379
      tmp___0 = contains_dot_dot((char const   *)current_stat_info.link_name);
      }
#line 1379
      if (tmp___0) {
        {
#line 1382
        tmp = create_placeholder_file(file_name___0, (_Bool)1, & interdir_made);
        }
#line 1382
        return (tmp);
      }
    }
  }
  {
#line 1384
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1384
    tmp___2 = symlinkat((char const   *)current_stat_info.link_name, chdir_fd, (char const   *)file_name___0);
    }
#line 1384
    if (! (tmp___2 != 0)) {
#line 1384
      goto while_break;
    }
    {
#line 1385
    tmp___1 = maybe_recoverable(file_name___0, (_Bool)0, & interdir_made);
    }
    {
#line 1387
    if (tmp___1 == 1) {
#line 1387
      goto case_1;
    }
#line 1390
    if (tmp___1 == 2) {
#line 1390
      goto case_2;
    }
#line 1393
    if (tmp___1 == 0) {
#line 1393
      goto case_0;
    }
#line 1385
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1388
    goto while_continue;
    case_2: /* CIL Label */ 
#line 1391
    return (0);
    case_0: /* CIL Label */ 
    {
#line 1394
    symlink_error((char const   *)current_stat_info.link_name, (char const   *)file_name___0);
    }
#line 1395
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1398
  set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
           -1, (mode_t )0, (mode_t )0, (char )'2', (_Bool)0, 256);
  }
#line 1400
  return (0);
}
}
#line 1417 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_node(char *file_name___0 , int typeflag ) 
{ 
  _Bool interdir_made ;
  mode_t mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1420
  interdir_made = (_Bool)0;
#line 1421
  if (0 < same_owner_option) {
#line 1421
    tmp = (448 >> 3) | ((448 >> 3) >> 3);
  } else {
#line 1421
    tmp = 0;
  }
#line 1421
  mode = (current_stat_info.stat.st_mode & (unsigned int )(((((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))) | 24576) | 8192)) & (unsigned int )(~ tmp);
  {
#line 1424
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1424
    tmp___1 = mknodat(chdir_fd, (char const   *)file_name___0, mode, current_stat_info.stat.st_rdev);
    }
#line 1424
    if (! (tmp___1 != 0)) {
#line 1424
      goto while_break;
    }
    {
#line 1426
    tmp___0 = maybe_recoverable(file_name___0, (_Bool)0, & interdir_made);
    }
    {
#line 1428
    if (tmp___0 == 1) {
#line 1428
      goto case_1;
    }
#line 1431
    if (tmp___0 == 2) {
#line 1431
      goto case_2;
    }
#line 1434
    if (tmp___0 == 0) {
#line 1434
      goto case_0;
    }
#line 1426
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1429
    goto while_continue;
    case_2: /* CIL Label */ 
#line 1432
    return (0);
    case_0: /* CIL Label */ 
    {
#line 1435
    mknod_error((char const   *)file_name___0);
    }
#line 1436
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1439
  set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
           -1, mode & ~ current_umask, (mode_t )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))),
           (char )typeflag, (_Bool)0, 256);
  }
#line 1442
  return (0);
}
}
#line 1447 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_fifo(char *file_name___0 , int typeflag ) 
{ 
  _Bool interdir_made ;
  mode_t mode ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1450
  interdir_made = (_Bool)0;
#line 1451
  if (0 < same_owner_option) {
#line 1451
    tmp = (448 >> 3) | ((448 >> 3) >> 3);
  } else {
#line 1451
    tmp = 0;
  }
#line 1451
  mode = (current_stat_info.stat.st_mode & (unsigned int )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))) & (unsigned int )(~ tmp);
  {
#line 1454
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1454
    tmp___1 = mkfifoat(chdir_fd, (char const   *)file_name___0, mode);
    }
#line 1454
    if (! (tmp___1 != 0)) {
#line 1454
      goto while_break;
    }
    {
#line 1455
    tmp___0 = maybe_recoverable(file_name___0, (_Bool)0, & interdir_made);
    }
    {
#line 1457
    if (tmp___0 == 1) {
#line 1457
      goto case_1;
    }
#line 1460
    if (tmp___0 == 2) {
#line 1460
      goto case_2;
    }
#line 1463
    if (tmp___0 == 0) {
#line 1463
      goto case_0;
    }
#line 1455
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1458
    goto while_continue;
    case_2: /* CIL Label */ 
#line 1461
    return (0);
    case_0: /* CIL Label */ 
    {
#line 1464
    mkfifo_error((char const   *)file_name___0);
    }
#line 1465
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1468
  set_stat((char const   *)file_name___0, (struct tar_stat_info  const  *)(& current_stat_info),
           -1, mode & ~ current_umask, (mode_t )(((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))),
           (char )typeflag, (_Bool)0, 256);
  }
#line 1471
  return (0);
}
}
#line 1475 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_volhdr(char *file_name___0 , int typeflag ) 
{ 


  {
  {
#line 1478
  skip_member();
  }
#line 1479
  return (0);
}
}
#line 1482 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_failure(char *file_name___0 , int typeflag ) 
{ 


  {
#line 1485
  return (1);
}
}
#line 1488 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int extract_skip(char *file_name___0 , int typeflag ) 
{ 


  {
  {
#line 1491
  skip_member();
  }
#line 1492
  return (0);
}
}
#line 1502 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static int prepare_to_extract(char const   *file_name___0 , int typeflag , tar_extractor_t *fun ) 
{ 
  int rc ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;

  {
#line 1505
  rc = 1;
#line 1507
  if (to_stdout_option) {
#line 1508
    rc = 0;
  } else
#line 1507
  if (to_command_option) {
#line 1508
    rc = 0;
  }
  {
#line 1513
  if (typeflag == 83) {
#line 1513
    goto case_83;
  }
#line 1520
  if (typeflag == 55) {
#line 1520
    goto case_55;
  }
#line 1520
  if (typeflag == 48) {
#line 1520
    goto case_55;
  }
#line 1520
  if (typeflag == 0) {
#line 1520
    goto case_55;
  }
#line 1532
  if (typeflag == 50) {
#line 1532
    goto case_50;
  }
#line 1536
  if (typeflag == 49) {
#line 1536
    goto case_49;
  }
#line 1541
  if (typeflag == 51) {
#line 1541
    goto case_51;
  }
#line 1548
  if (typeflag == 52) {
#line 1548
    goto case_52;
  }
#line 1555
  if (typeflag == 54) {
#line 1555
    goto case_54;
  }
#line 1561
  if (typeflag == 68) {
#line 1561
    goto case_68;
  }
#line 1561
  if (typeflag == 53) {
#line 1561
    goto case_68;
  }
#line 1567
  if (typeflag == 86) {
#line 1567
    goto case_86;
  }
#line 1571
  if (typeflag == 77) {
#line 1571
    goto case_77;
  }
#line 1579
  if (typeflag == 75) {
#line 1579
    goto case_75;
  }
#line 1579
  if (typeflag == 76) {
#line 1579
    goto case_75;
  }
#line 1584
  goto switch_default;
  case_83: /* CIL Label */ 
#line 1514
  *fun = & extract_file;
#line 1515
  rc = 1;
#line 1516
  goto switch_break;
  case_55: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 1523
  if (current_stat_info.had_trailing_slash) {
#line 1524
    *fun = & extract_dir;
  } else {
#line 1527
    *fun = & extract_file;
#line 1528
    rc = 1;
  }
#line 1530
  goto switch_break;
  case_50: /* CIL Label */ 
#line 1533
  *fun = & extract_symlink;
#line 1534
  goto switch_break;
  case_49: /* CIL Label */ 
#line 1537
  *fun = & extract_link;
#line 1538
  goto switch_break;
  case_51: /* CIL Label */ 
#line 1542
  current_stat_info.stat.st_mode |= 8192U;
#line 1543
  *fun = & extract_node;
#line 1544
  goto switch_break;
  case_52: /* CIL Label */ 
#line 1549
  current_stat_info.stat.st_mode |= 24576U;
#line 1550
  *fun = & extract_node;
#line 1551
  goto switch_break;
  case_54: /* CIL Label */ 
#line 1556
  *fun = & extract_fifo;
#line 1557
  goto switch_break;
  case_68: /* CIL Label */ 
  case_53: /* CIL Label */ 
#line 1562
  *fun = & extract_dir;
#line 1563
  if (current_stat_info.is_dumpdir) {
#line 1564
    delay_directory_restore_option = (_Bool)1;
  }
#line 1565
  goto switch_break;
  case_86: /* CIL Label */ 
#line 1568
  *fun = & extract_volhdr;
#line 1569
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 1572
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1572
    if (error_hook) {
      {
#line 1572
      (*error_hook)();
      }
    }
    {
#line 1572
    tmp = quotearg_colon((char const   *)current_stat_info.file_name);
#line 1572
    tmp___0 = gettext("%s: Cannot extract -- file is continued from another volume");
#line 1572
    error(0, 0, (char const   *)tmp___0, tmp);
#line 1572
    exit_status = 2;
    }
#line 1572
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1575
  *fun = & extract_skip;
#line 1576
  goto switch_break;
  case_75: /* CIL Label */ 
  case_76: /* CIL Label */ 
  {
#line 1580
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1580
    if (error_hook) {
      {
#line 1580
      (*error_hook)();
      }
    }
    {
#line 1580
    tmp___1 = gettext("Unexpected long name header");
#line 1580
    error(0, 0, (char const   *)tmp___1);
#line 1580
    exit_status = 2;
    }
#line 1580
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1581
  *fun = & extract_failure;
#line 1582
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1585
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1585
    if (warning_option & 65536) {
      {
#line 1585
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1585
        if (error_hook) {
          {
#line 1585
          (*error_hook)();
          }
        }
        {
#line 1585
        tmp___2 = quotearg_colon(file_name___0);
#line 1585
        tmp___3 = gettext("%s: Unknown file type \'%c\', extracted as normal file");
#line 1585
        error(0, 0, (char const   *)tmp___3, tmp___2, typeflag);
        }
#line 1585
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1585
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1589
  *fun = & extract_file;
  switch_break: /* CIL Label */ ;
  }
#line 1593
  if (rc == 0) {
#line 1594
    return (0);
  }
  {
#line 1598
  if ((unsigned int )old_files_option == 3U) {
#line 1598
    goto case_3;
  }
#line 1609
  if ((unsigned int )old_files_option == 6U) {
#line 1609
    goto case_6;
  }
#line 1619
  goto switch_default___0;
  case_3: /* CIL Label */ 
#line 1599
  if (recursive_unlink_option) {
#line 1599
    tmp___4 = 1;
  } else {
#line 1599
    tmp___4 = 0;
  }
  {
#line 1599
  tmp___5 = remove_any_file(file_name___0, (enum remove_option )tmp___4);
  }
#line 1599
  if (! tmp___5) {
    {
#line 1599
    tmp___6 = __errno_location();
    }
#line 1599
    if (*tmp___6) {
      {
#line 1599
      tmp___7 = __errno_location();
      }
#line 1599
      if (*tmp___7 != 2) {
        {
#line 1604
        unlink_error(file_name___0);
        }
#line 1605
        return (0);
      }
    }
  }
#line 1607
  goto switch_break___0;
  case_6: /* CIL Label */ 
  {
#line 1610
  tmp___10 = file_newer_p(file_name___0, (struct stat  const  *)0, & current_stat_info);
  }
#line 1610
  if (tmp___10) {
    {
#line 1612
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1612
      if (warning_option & 2048) {
        {
#line 1612
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 1612
          if (error_hook) {
            {
#line 1612
            (*error_hook)();
            }
          }
          {
#line 1612
          tmp___8 = quote(file_name___0);
#line 1612
          tmp___9 = gettext("Current %s is newer or same age");
#line 1612
          error(0, 0, (char const   *)tmp___9, tmp___8);
          }
#line 1612
          goto while_break___4;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 1612
      goto while_break___3;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1615
    return (0);
  }
#line 1617
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
#line 1620
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1623
  return (1);
}
}
#line 1627 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
void extract_archive(void) 
{ 
  char typeflag ;
  int (*fun)(char *file_name , int typeflag ) ;
  int tmp ;
  int dir ;
  int e ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1633
  fatal_exit_hook = & extract_finish;
#line 1635
  set_next_block_after(current_header);
  }
#line 1637
  if (! *(current_stat_info.file_name + 0)) {
    {
#line 1641
    skip_member();
    }
#line 1642
    return;
  } else
#line 1637
  if (interactive_option) {
    {
#line 1637
    tmp = confirm("extract", (char const   *)current_stat_info.file_name);
    }
#line 1637
    if (! tmp) {
      {
#line 1641
      skip_member();
      }
#line 1642
      return;
    }
  }
#line 1646
  if (verbose_option) {
    {
#line 1647
    print_header(& current_stat_info, current_header, (off_t )-1);
    }
  }
#line 1652
  if (! delay_directory_restore_option) {
    {
#line 1654
    dir = chdir_current;
#line 1655
    apply_nonancestor_delayed_set_stat((char const   *)current_stat_info.file_name,
                                       (_Bool)0);
#line 1656
    chdir_do(dir);
    }
  }
#line 1661
  if (backup_option) {
    {
#line 1662
    tmp___3 = maybe_backup_file((char const   *)current_stat_info.file_name, (_Bool)0);
    }
#line 1662
    if (! tmp___3) {
      {
#line 1664
      tmp___0 = __errno_location();
#line 1664
      e = *tmp___0;
      }
      {
#line 1665
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1665
        if (error_hook) {
          {
#line 1665
          (*error_hook)();
          }
        }
        {
#line 1665
        tmp___1 = quotearg_colon((char const   *)current_stat_info.file_name);
#line 1665
        tmp___2 = gettext("%s: Was unable to backup this file");
#line 1665
        error(0, e, (char const   *)tmp___2, tmp___1);
#line 1665
        exit_status = 2;
        }
#line 1665
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 1667
      skip_member();
      }
#line 1668
      return;
    }
  }
  {
#line 1673
  tmp___5 = sparse_member_p(& current_stat_info);
  }
#line 1673
  if (tmp___5) {
#line 1673
    typeflag = (char )'S';
  } else {
#line 1673
    typeflag = current_header->header.typeflag;
  }
  {
#line 1676
  tmp___7 = prepare_to_extract((char const   *)current_stat_info.file_name, (int )typeflag,
                               & fun);
  }
#line 1676
  if (tmp___7) {
#line 1678
    if (fun) {
      {
#line 1678
      tmp___6 = (*fun)(current_stat_info.file_name, (int )typeflag);
      }
#line 1678
      if (tmp___6) {
#line 1678
        if (backup_option) {
          {
#line 1680
          undo_last_backup();
          }
        }
      }
    }
  } else {
    {
#line 1683
    skip_member();
    }
  }
#line 1685
  return;
}
}
#line 1688 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
static void apply_delayed_links(void) 
{ 
  struct delayed_link *ds ;
  struct string_list *sources ;
  char const   *valid_source ;
  char const   *source ;
  struct stat st ;
  int tmp ;
  struct tar_stat_info st1 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct timespec  __attribute__((__pure__)) tmp___4 ;
  int __attribute__((__pure__))  tmp___5 ;
  struct string_list *next ;
  struct delayed_link *next___0 ;

  {
#line 1693
  ds = delayed_link_head;
  {
#line 1693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1693
    if (! ds) {
#line 1693
      goto while_break;
    }
    {
#line 1695
    sources = ds->sources;
#line 1696
    valid_source = (char const   *)0;
#line 1698
    chdir_do(ds->change_dir);
#line 1700
    sources = ds->sources;
    }
    {
#line 1700
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1700
      if (! sources) {
#line 1700
        goto while_break___0;
      }
      {
#line 1702
      source = (char const   *)(sources->string);
#line 1708
      tmp___3 = fstatat(chdir_fd, (char const   */* __restrict  */)source, (struct stat */* __restrict  */)(& st),
                        256);
      }
#line 1708
      if (tmp___3 == 0) {
#line 1708
        if (st.st_dev == ds->dev) {
#line 1708
          if (st.st_ino == ds->ino) {
            {
#line 1708
            tmp___4 = get_stat_birthtime((struct stat  const  *)(& st));
#line 1708
            tmp___5 = timespec_cmp((struct timespec )tmp___4, ds->birthtime);
            }
#line 1708
            if (tmp___5 == (int __attribute__((__pure__))  )0) {
              {
#line 1715
              tmp___2 = unlinkat(chdir_fd, source, 0);
              }
#line 1715
              if (tmp___2 != 0) {
                {
#line 1716
                unlink_error(source);
                }
              } else
#line 1717
              if (valid_source) {
                {
#line 1717
                tmp___1 = linkat(chdir_fd, valid_source, chdir_fd, source, 0);
                }
#line 1717
                if (! (tmp___1 == 0)) {
#line 1717
                  goto _L;
                }
              } else
              _L: /* CIL Label */ 
#line 1721
              if (! ds->is_symlink) {
                {
#line 1723
                tmp = linkat(chdir_fd, (char const   *)(ds->target), chdir_fd, source,
                             0);
                }
#line 1723
                if (tmp != 0) {
                  {
#line 1724
                  link_error((char const   *)(ds->target), source);
                  }
                }
              } else {
                {
#line 1726
                tmp___0 = symlinkat((char const   *)(ds->target), chdir_fd, source);
                }
#line 1726
                if (tmp___0 != 0) {
                  {
#line 1727
                  symlink_error((char const   *)(ds->target), source);
                  }
                } else {
                  {
#line 1731
                  st1.stat.st_mode = ds->mode;
#line 1732
                  st1.stat.st_uid = ds->uid;
#line 1733
                  st1.stat.st_gid = ds->gid;
#line 1734
                  st1.atime = ds->atime;
#line 1735
                  st1.mtime = ds->mtime;
#line 1736
                  st1.cntx_name = ds->cntx_name;
#line 1737
                  st1.acls_a_ptr = ds->acls_a_ptr;
#line 1738
                  st1.acls_a_len = ds->acls_a_len;
#line 1739
                  st1.acls_d_ptr = ds->acls_d_ptr;
#line 1740
                  st1.acls_d_len = ds->acls_d_len;
#line 1741
                  st1.xattr_map = ds->xattr_map;
#line 1742
                  st1.xattr_map_size = ds->xattr_map_size;
#line 1743
                  set_stat(source, (struct tar_stat_info  const  *)(& st1), -1, (mode_t )0,
                           (mode_t )0, (char )'2', (_Bool)0, 256);
#line 1745
                  valid_source = source;
                  }
                }
              }
            }
          }
        }
      }
#line 1700
      sources = sources->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1750
    sources = ds->sources;
    {
#line 1750
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1750
      if (! sources) {
#line 1750
        goto while_break___1;
      }
      {
#line 1752
      next = sources->next;
#line 1753
      free((void *)sources);
#line 1754
      sources = next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1757
    xheader_xattr_free(ds->xattr_map, ds->xattr_map_size);
#line 1758
    free((void *)ds->cntx_name);
#line 1761
    next___0 = ds->next;
#line 1762
    free((void *)ds);
#line 1763
    ds = next___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1767
  delayed_link_head = (struct delayed_link *)0;
#line 1768
  return;
}
}
#line 1771 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
void extract_finish(void) 
{ 


  {
  {
#line 1775
  apply_nonancestor_delayed_set_stat("", (_Bool)0);
#line 1779
  apply_delayed_links();
#line 1783
  apply_nonancestor_delayed_set_stat("", (_Bool)1);
  }
#line 1784
  return;
}
}
#line 1786 "/home/khheo/project/benchmark/tar-1.29/src/extract.c"
_Bool rename_directory(char *src , char *dst ) 
{ 
  int e ;
  int *tmp ;
  _Bool interdir_made ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 1789
  tmp___6 = renameat(chdir_fd, (char const   *)src, chdir_fd, (char const   *)dst);
  }
#line 1789
  if (tmp___6 == 0) {
    {
#line 1790
    fixup_delayed_set_stat((char const   *)src, (char const   *)dst);
    }
  } else {
    {
#line 1793
    tmp = __errno_location();
#line 1793
    e = *tmp;
    }
    {
#line 1798
    if (e == 2) {
#line 1798
      goto case_2;
    }
#line 1810
    goto switch_default;
    case_2: /* CIL Label */ 
    {
#line 1799
    tmp___2 = make_directories(dst, & interdir_made);
    }
#line 1799
    if (tmp___2 == 0) {
      {
#line 1801
      tmp___0 = renameat(chdir_fd, (char const   *)src, chdir_fd, (char const   *)dst);
      }
#line 1801
      if (tmp___0 == 0) {
#line 1802
        return ((_Bool)1);
      }
      {
#line 1803
      tmp___1 = __errno_location();
#line 1803
      e = *tmp___1;
      }
    }
#line 1805
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1811
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1814
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1814
      if (error_hook) {
        {
#line 1814
        (*error_hook)();
        }
      }
      {
#line 1814
      tmp___3 = quote_n(1, (char const   *)dst);
#line 1814
      tmp___4 = quote_n(0, (char const   *)src);
#line 1814
      tmp___5 = gettext("Cannot rename %s to %s");
#line 1814
      error(0, e, (char const   *)tmp___5, tmp___4, tmp___3);
#line 1814
      exit_status = 2;
      }
#line 1814
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1817
    return ((_Bool)0);
  }
#line 1819
  return ((_Bool)1);
}
}
#line 307 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) faccessat)(int __fd ,
                                                                                                char const   *__file ,
                                                                                                int __type ,
                                                                                                int __flag ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 974
#pragma GCC diagnostic pop
#line 37 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static struct vcs_ignore_file *get_vcs_ignore_file(char const   *name ) ;
#line 46 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static struct excfile *excfile_head  ;
#line 46 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static struct excfile *excfile_tail  ;
#line 48 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
void excfile_add(char const   *name , int flags ) 
{ 
  struct excfile *p ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 51
  tmp = strlen(name);
#line 51
  tmp___0 = xmalloc(sizeof(*p) + tmp);
#line 51
  p = (struct excfile *)tmp___0;
#line 52
  p->next = (struct excfile *)((void *)0);
#line 53
  p->flags = flags;
#line 54
  strcpy((char */* __restrict  */)(p->name), (char const   */* __restrict  */)name);
  }
#line 55
  if (excfile_tail) {
#line 56
    excfile_tail->next = p;
  } else {
#line 58
    excfile_head = p;
  }
#line 59
  excfile_tail = p;
#line 60
  return;
}
}
#line 69 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
void info_attach_exclist(struct tar_stat_info *dir ) 
{ 
  struct excfile *file ;
  struct exclist *head ;
  struct exclist *tail ;
  struct exclist *ent ;
  struct vcs_ignore_file *vcsfile ;
  FILE *fp ;
  struct exclude *ex ;
  int fd ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int e ;
  int *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 73
  head = (struct exclist *)((void *)0);
#line 73
  tail = (struct exclist *)((void *)0);
#line 76
  if (dir->exclude_list) {
#line 77
    return;
  }
#line 78
  file = excfile_head;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! file) {
#line 78
      goto while_break;
    }
#line 80
    if (dir) {
#line 80
      tmp___6 = dir->fd;
    } else {
#line 80
      tmp___6 = chdir_fd;
    }
    {
#line 80
    tmp___7 = faccessat(tmp___6, (char const   *)(file->name), 0, 0);
    }
#line 80
    if (tmp___7 == 0) {
      {
#line 83
      ex = (struct exclude *)((void *)0);
#line 84
      tmp = subfile_open((struct tar_stat_info  const  *)dir, (char const   *)(file->name),
                         0);
#line 84
      fd = tmp;
      }
#line 85
      if (fd == -1) {
        {
#line 87
        open_error((char const   *)(file->name));
        }
#line 88
        goto __Cont;
      }
      {
#line 90
      fp = fdopen(fd, "r");
      }
#line 91
      if (! fp) {
        {
#line 93
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 93
          if (error_hook) {
            {
#line 93
            (*error_hook)();
            }
          }
          {
#line 93
          tmp___0 = gettext("%s: fdopen failed");
#line 93
          tmp___1 = __errno_location();
#line 93
          error(0, *tmp___1, (char const   *)tmp___0, file->name);
#line 93
          exit_status = 2;
          }
#line 93
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 94
        close(fd);
        }
#line 95
        goto __Cont;
      }
#line 98
      if (! ex) {
        {
#line 99
        ex = new_exclude();
        }
      }
      {
#line 101
      vcsfile = get_vcs_ignore_file((char const   *)(file->name));
      }
#line 103
      if (vcsfile->initfn) {
        {
#line 104
        vcsfile->data = (*(vcsfile->initfn))(vcsfile->data);
        }
      }
      {
#line 106
      tmp___4 = add_exclude_fp(vcsfile->addfn, ex, fp, (1 << 28) | (1 << 30), (char )'\n',
                               vcsfile->data);
      }
#line 106
      if (tmp___4) {
        {
#line 110
        tmp___2 = __errno_location();
#line 110
        e = *tmp___2;
        }
        {
#line 111
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 111
          if (error_hook) {
            {
#line 111
            (*error_hook)();
            }
          }
          {
#line 111
          tmp___3 = quotearg_colon((char const   *)(file->name));
#line 111
          error(0, e, "%s", tmp___3);
#line 111
          fatal_exit();
          }
#line 111
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 113
      fclose(fp);
#line 115
      tmp___5 = xmalloc(sizeof(*ent));
#line 115
      ent = (struct exclist *)tmp___5;
#line 116
      ent->excluded = ex;
      }
#line 117
      if (file->flags == 0) {
#line 117
        ent->flags = file->flags;
      } else {
#line 117
        ent->flags = vcsfile->flags;
      }
#line 119
      ent->prev = tail;
#line 120
      ent->next = (struct exclist *)((void *)0);
#line 122
      if (tail) {
#line 123
        tail->next = ent;
      } else {
#line 125
        head = ent;
      }
#line 126
      tail = ent;
    }
    __Cont: /* CIL Label */ 
#line 78
    file = file->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  dir->exclude_list = head;
#line 130
  return;
}
}
#line 132 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
void info_free_exclist(struct tar_stat_info *dir ) 
{ 
  struct exclist *ep ;
  struct exclist *next ;

  {
#line 135
  ep = dir->exclude_list;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! ep) {
#line 137
      goto while_break;
    }
    {
#line 139
    next = ep->next;
#line 140
    free_exclude(ep->excluded);
#line 141
    free((void *)ep);
#line 142
    ep = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 145
  dir->exclude_list = (struct exclist *)((void *)0);
#line 146
  return;
}
}
#line 150 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
_Bool excluded_name(char const   *name , struct tar_stat_info *st ) 
{ 
  struct exclist *ep ;
  char const   *rname ;
  char *bname ;
  _Bool result ;
  int nr ;
  _Bool tmp ;

  {
  {
#line 154
  rname = (char const   *)((void *)0);
#line 155
  bname = (char *)((void *)0);
#line 157
  nr = 0;
#line 159
  name += 0;
#line 162
  tmp = excluded_file_name((struct exclude  const  *)excluded, name);
  }
#line 162
  if (tmp) {
#line 163
    return ((_Bool)1);
  }
#line 165
  if (! st) {
#line 166
    return ((_Bool)0);
  }
#line 168
  result = (_Bool)0;
  {
#line 168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 168
    if (st) {
#line 168
      if (! (! result)) {
#line 168
        goto while_break;
      }
    } else {
#line 168
      goto while_break;
    }
#line 170
    ep = st->exclude_list;
    {
#line 170
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 170
      if (! ep) {
#line 170
        goto while_break___0;
      }
#line 172
      if (ep->flags & nr) {
#line 173
        goto __Cont;
      }
      {
#line 174
      result = excluded_file_name((struct exclude  const  *)ep->excluded, name);
      }
#line 174
      if (result) {
#line 175
        goto while_break___0;
      }
#line 177
      if (! rname) {
#line 179
        rname = name;
        {
#line 181
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 181
          if ((int const   )*rname == 46) {
#line 181
            if (! ((int const   )*(rname + 1) == 47)) {
#line 181
              goto while_break___1;
            }
          } else {
#line 181
            goto while_break___1;
          }
#line 182
          rname += 2;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 184
      result = excluded_file_name((struct exclude  const  *)ep->excluded, rname);
      }
#line 184
      if (result) {
#line 185
        goto while_break___0;
      }
#line 187
      if (! bname) {
        {
#line 188
        bname = base_name(name);
        }
      }
      {
#line 189
      result = excluded_file_name((struct exclude  const  *)ep->excluded, (char const   *)bname);
      }
#line 189
      if (result) {
#line 190
        goto while_break___0;
      }
      __Cont: /* CIL Label */ 
#line 170
      ep = ep->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 168
    st = st->parent;
#line 168
    nr = 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 194
  free((void *)bname);
  }
#line 196
  return (result);
}
}
#line 199 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static void cvs_addfn(struct exclude *ex , char const   *pattern , int options___0 ,
                      void *data ) 
{ 
  struct wordsplit ws ;
  size_t i ;
  int tmp ;

  {
  {
#line 205
  tmp = wordsplit(pattern, & ws, 2116);
  }
#line 205
  if (tmp) {
#line 207
    return;
  }
#line 208
  i = (size_t )0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (i < ws.ws_wordc)) {
#line 208
      goto while_break;
    }
    {
#line 209
    add_exclude(ex, (char const   *)*(ws.ws_wordv + i), options___0);
#line 208
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 210
  wordsplit_free(& ws);
  }
#line 211
  return;
}
}
#line 213 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static void git_addfn(struct exclude *ex , char const   *pattern , int options___0 ,
                      void *data ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 216
    tmp = __ctype_b_loc();
    }
#line 216
    if (! ((int const   )*(*tmp + (int )*pattern) & 8192)) {
#line 216
      goto while_break;
    }
#line 217
    pattern ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 218
  if ((int const   )*pattern == 0) {
#line 219
    return;
  } else
#line 218
  if ((int const   )*pattern == 35) {
#line 219
    return;
  }
#line 220
  if ((int const   )*pattern == 92) {
#line 220
    if ((int const   )*(pattern + 1) == 35) {
#line 221
      pattern ++;
    }
  }
  {
#line 222
  add_exclude(ex, pattern, options___0);
  }
#line 223
  return;
}
}
#line 225 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static void bzr_addfn(struct exclude *ex , char const   *pattern , int options___0 ,
                      void *data ) 
{ 
  unsigned short const   **tmp ;
  int tmp___0 ;

  {
  {
#line 228
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 228
    tmp = __ctype_b_loc();
    }
#line 228
    if (! ((int const   )*(*tmp + (int )*pattern) & 8192)) {
#line 228
      goto while_break;
    }
#line 229
    pattern ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if ((int const   )*pattern == 0) {
#line 231
    return;
  } else
#line 230
  if ((int const   )*pattern == 35) {
#line 231
    return;
  }
#line 232
  if ((int const   )*pattern == 33) {
#line 234
    pattern ++;
#line 234
    if ((int const   )*pattern == 33) {
#line 235
      pattern ++;
    } else {
#line 237
      options___0 |= 1 << 29;
    }
  }
  {
#line 241
  tmp___0 = strncmp(pattern, "RE:", (size_t )3);
  }
#line 241
  if (tmp___0 == 0) {
#line 243
    pattern += 3;
#line 244
    options___0 &= ~ (1 << 28);
#line 245
    options___0 |= 1 << 27;
  }
  {
#line 247
  add_exclude(ex, pattern, options___0);
  }
#line 248
  return;
}
}
#line 253 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static int hg_options  ;
#line 250 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static void *hg_initfn(void *data ) 
{ 
  int *hgopt ;
  int *tmp ;

  {
#line 254
  if (data) {
#line 254
    tmp = (int *)data;
  } else {
#line 254
    tmp = & hg_options;
  }
#line 254
  hgopt = tmp;
#line 255
  *hgopt = 1 << 27;
#line 256
  return ((void *)hgopt);
}
}
#line 259 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static void hg_addfn(struct exclude *ex , char const   *pattern , int options___0 ,
                     void *data ) 
{ 
  int *hgopt ;
  size_t len ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *p ;
  void *tmp___4 ;
  int tmp___5 ;

  {
#line 262
  hgopt = (int *)data;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    tmp = __ctype_b_loc();
    }
#line 265
    if (! ((int const   )*(*tmp + (int )*pattern) & 8192)) {
#line 265
      goto while_break;
    }
#line 266
    pattern ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if ((int const   )*pattern == 0) {
#line 268
    return;
  } else
#line 267
  if ((int const   )*pattern == 35) {
#line 268
    return;
  }
  {
#line 269
  tmp___3 = strncmp(pattern, "syntax:", (size_t )7);
  }
#line 269
  if (tmp___3 == 0) {
#line 271
    pattern += 7;
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 271
      tmp___0 = __ctype_b_loc();
      }
#line 271
      if (! ((int const   )*(*tmp___0 + (int )*pattern) & 8192)) {
#line 271
        goto while_break___0;
      }
#line 271
      pattern ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 273
    tmp___2 = strcmp(pattern, "regexp");
    }
#line 273
    if (tmp___2 == 0) {
#line 275
      *hgopt = 1 << 27;
    } else {
      {
#line 276
      tmp___1 = strcmp(pattern, "glob");
      }
#line 276
      if (tmp___1 == 0) {
#line 277
        *hgopt = 1 << 28;
      }
    }
#line 279
    return;
  }
  {
#line 282
  len = strlen(pattern);
  }
#line 283
  if ((int const   )*(pattern + (len - 1UL)) == 47) {
    {
#line 287
    len --;
#line 288
    tmp___4 = xmalloc(len + 1UL);
#line 288
    p = (char *)tmp___4;
#line 289
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)pattern, len);
#line 290
    *(p + len) = (char)0;
#line 291
    pattern = (char const   *)p;
#line 292
    exclude_add_pattern_buffer(ex, p);
#line 293
    options___0 |= (1 << 3) | (1 << 26);
    }
  }
#line 296
  if (*hgopt == 1 << 27) {
#line 296
    tmp___5 = options___0 & ~ (1 << 28);
  } else {
#line 296
    tmp___5 = options___0 & ~ (1 << 27);
  }
  {
#line 296
  add_exclude(ex, pattern, tmp___5 | *hgopt);
  }
#line 300
  return;
}
}
#line 302 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static struct vcs_ignore_file vcs_ignore_files[5]  = {      {".cvsignore", 2, & cvs_addfn, (void *(*)(void * ))((void *)0), (void *)0}, 
        {".gitignore", 0, & git_addfn, (void *(*)(void * ))((void *)0), (void *)0}, 
        {".bzrignore", 0, & bzr_addfn, (void *(*)(void * ))((void *)0), (void *)0}, 
        {".hgignore", 0, & hg_addfn, & hg_initfn, (void *)0}, 
        {(char const   *)((void *)0), 0, & git_addfn, (void *(*)(void * ))((void *)0),
      (void *)0}};
#line 310 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
static struct vcs_ignore_file *get_vcs_ignore_file(char const   *name ) 
{ 
  struct vcs_ignore_file *p ;
  int tmp ;

  {
#line 315
  p = vcs_ignore_files;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! p->filename) {
#line 315
      goto while_break;
    }
    {
#line 316
    tmp = strcmp(p->filename, name);
    }
#line 316
    if (tmp == 0) {
#line 317
      goto while_break;
    }
#line 315
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  return (p);
}
}
#line 322 "/home/khheo/project/benchmark/tar-1.29/src/exclist.c"
void exclude_vcs_ignores(void) 
{ 
  struct vcs_ignore_file *p ;

  {
#line 327
  p = vcs_ignore_files;
  {
#line 327
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (! p->filename) {
#line 327
      goto while_break;
    }
    {
#line 328
    excfile_add(p->filename, 0);
#line 327
    p ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 329
  return;
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 954 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
void (*fatal_exit_hook)(void)  ;
#line 974
#pragma GCC diagnostic pop
#line 25 "/home/khheo/project/benchmark/tar-1.29/src/exit.c"
 __attribute__((__noreturn__)) void fatal_exit(void) ;
#line 25 "/home/khheo/project/benchmark/tar-1.29/src/exit.c"
void fatal_exit(void) 
{ 
  char *tmp ;

  {
#line 28
  if (fatal_exit_hook) {
    {
#line 29
    (*fatal_exit_hook)();
    }
  }
  {
#line 30
  tmp = gettext("Error is not recoverable: exiting now");
#line 30
  error(2, 0, (char const   *)tmp);
#line 31
  abort();
  }
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 437
_Bool write_archive_to_stdout ;
#line 453
void flush_read(void) ;
#line 454
void flush_write(void) ;
#line 455
void flush_archive(void) ;
#line 974
#pragma GCC diagnostic pop
#line 27 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static union block *new_record  ;
#line 28 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static int new_blocks  ;
#line 29 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static _Bool acting_as_filter  ;
#line 34
union block *record_end ;
#line 38
off_t records_read ;
#line 42 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
off_t records_skipped  ;
#line 48 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static void move_archive(off_t count ) 
{ 
  struct mtop operation ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  off_t position0 ;
  off_t tmp___7 ;
  __off_t tmp___8 ;
  off_t tmp___9 ;
  off_t increment ;
  off_t position ;
  off_t tmp___10 ;
  __off_t tmp___11 ;
  off_t tmp___12 ;

  {
#line 51
  if (count == 0L) {
#line 52
    return;
  }
#line 58
  if (count < 0L) {
#line 58
    operation.mt_op = (short)4;
#line 58
    operation.mt_count = (int )(- count);
#line 58
    tmp___6 = (off_t )operation.mt_count == - count;
  } else {
#line 58
    operation.mt_op = (short)3;
#line 58
    operation.mt_count = (int )count;
#line 58
    tmp___6 = (off_t )operation.mt_count == count;
  }
#line 58
  if (tmp___6) {
#line 66
    if (archive >= 1 << 30) {
      {
#line 66
      tmp = rmt_ioctl__(archive - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                        (char *)(& operation));
#line 66
      tmp___1 = tmp;
      }
    } else {
      {
#line 66
      tmp___0 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
                      (char *)(& operation));
#line 66
      tmp___1 = tmp___0;
      }
    }
#line 66
    if (0 <= tmp___1) {
#line 67
      return;
    }
    {
#line 69
    tmp___2 = __errno_location();
    }
#line 69
    if (*tmp___2 == 5) {
#line 69
      if (archive >= 1 << 30) {
        {
#line 69
        tmp___3 = rmt_ioctl__(archive - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                              (char *)(& operation));
#line 69
        tmp___5 = tmp___3;
        }
      } else {
        {
#line 69
        tmp___4 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
                        (char *)(& operation));
#line 69
        tmp___5 = tmp___4;
        }
      }
#line 69
      if (0 <= tmp___5) {
#line 71
        return;
      }
    }
  }
#line 77
  if (archive >= 1 << 30) {
    {
#line 77
    tmp___7 = rmt_lseek__(archive - (1 << 30), (off_t )0, 1);
#line 77
    tmp___9 = tmp___7;
    }
  } else {
    {
#line 77
    tmp___8 = lseek(archive, (off_t )0, 1);
#line 77
    tmp___9 = tmp___8;
    }
  }
#line 77
  position0 = tmp___9;
#line 78
  increment = (off_t )(record_size * (size_t )count);
#line 79
  position = position0 + increment;
#line 81
  if ((size_t )(increment / count) != record_size) {
    {
#line 85
    seek_error_details(*(archive_name_array + 0), position);
    }
  } else
#line 81
  if ((position < position0) != (increment < 0L)) {
    {
#line 85
    seek_error_details(*(archive_name_array + 0), position);
    }
  } else {
#line 81
    if (position < 0L) {
#line 81
      position = (off_t )0;
    } else {
#line 81
      position = position;
    }
#line 81
    if (archive >= 1 << 30) {
      {
#line 81
      tmp___10 = rmt_lseek__(archive - (1 << 30), position, 0);
#line 81
      tmp___12 = tmp___10;
      }
    } else {
      {
#line 81
      tmp___11 = lseek(archive, position, 0);
#line 81
      tmp___12 = tmp___11;
      }
    }
#line 81
    if (tmp___12 != position) {
      {
#line 85
      seek_error_details(*(archive_name_array + 0), position);
      }
    }
  }
#line 87
  return;
}
}
#line 93 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static void write_record(int move_back_flag ) 
{ 
  union block *save_record ;

  {
#line 96
  save_record = record_start;
#line 97
  record_start = new_record;
#line 99
  if (acting_as_filter) {
    {
#line 101
    archive = 1;
#line 102
    flush_write();
#line 103
    archive = 0;
    }
  } else {
    {
#line 107
    move_archive((records_written + records_skipped) - records_read);
#line 108
    flush_write();
    }
  }
#line 111
  record_start = save_record;
#line 113
  if (move_back_flag) {
#line 117
    if (! acting_as_filter) {
      {
#line 118
      move_archive(records_read - (records_written + records_skipped));
      }
    }
  }
#line 121
  new_blocks = 0;
#line 122
  return;
}
}
#line 124 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static void write_recent_blocks(union block *h , size_t blocks ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 128
  i = (size_t )0;
  {
#line 128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 128
    if (! (i < blocks)) {
#line 128
      goto while_break;
    }
#line 130
    tmp = new_blocks;
#line 130
    new_blocks ++;
#line 130
    *(new_record + tmp) = *(h + i);
#line 131
    if (new_blocks == blocking_factor) {
      {
#line 132
      write_record(1);
      }
    }
#line 128
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return;
}
}
#line 136 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
static void write_recent_bytes(char *data , size_t bytes ) 
{ 
  size_t blocks ;
  size_t rest ;

  {
  {
#line 139
  blocks = bytes / 512UL;
#line 140
  rest = bytes - blocks * 512UL;
#line 142
  write_recent_blocks((union block *)data, blocks);
#line 143
  memcpy((void */* __restrict  */)((new_record + new_blocks)->buffer), (void const   */* __restrict  */)(data + blocks * 512UL),
         rest);
  }
#line 144
  if (rest < 512UL) {
    {
#line 145
    memset((void *)((new_record + new_blocks)->buffer + rest), 0, 512UL - rest);
    }
  }
#line 146
  new_blocks ++;
#line 147
  if (new_blocks == blocking_factor) {
    {
#line 148
    write_record(1);
    }
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/tar-1.29/src/delete.c"
void delete_archive_members(void) 
{ 
  enum read_header logical_status ;
  enum read_header previous_status ;
  struct name *name ;
  off_t blocks_to_skip ;
  off_t blocks_to_keep ;
  int kept_blocks_in_record ;
  int tmp ;
  enum read_header status ;
  enum read_header tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  enum read_header status___0 ;
  char *tmp___5 ;
  int tmp___6 ;
  int count ;
  int total_zero_blocks ;
  int zero_blocks ;
  int tmp___7 ;

  {
  {
#line 154
  logical_status = (enum read_header )0;
#line 155
  previous_status = (enum read_header )0;
#line 159
  blocks_to_skip = (off_t )0;
#line 160
  blocks_to_keep = (off_t )0;
#line 163
  name_gather();
#line 164
  open_archive((enum access_mode )2);
#line 165
  tmp = strcmp(*(archive_name_array + 0), "-");
#line 165
  acting_as_filter = (_Bool )(tmp == 0);
  }
  {
#line 167
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    tmp___0 = read_header(& current_header, & current_stat_info, (enum read_header_mode )1);
#line 169
    status = tmp___0;
    }
    {
#line 175
    if ((unsigned int )status == 0U) {
#line 175
      goto case_0;
    }
#line 178
    if ((unsigned int )status == 1U) {
#line 178
      goto case_1;
    }
#line 192
    if ((unsigned int )status == 2U) {
#line 192
      goto case_2;
    }
#line 196
    if ((unsigned int )status == 3U) {
#line 196
      goto case_3;
    }
#line 203
    if ((unsigned int )status == 4U) {
#line 203
      goto case_4;
    }
#line 207
    if ((unsigned int )status == 5U) {
#line 207
      goto case_5;
    }
#line 173
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 176
    abort();
    }
    case_1: /* CIL Label */ 
    {
#line 179
    name = name_scan((char const   *)current_stat_info.file_name);
    }
#line 179
    if ((unsigned long )name == (unsigned long )((void *)0)) {
      {
#line 181
      skip_member();
      }
#line 182
      goto switch_break;
    }
#line 184
    (name->found_count) ++;
#line 185
    if (occurrence_option == 0UL) {
#line 185
      tmp___1 = name->found_count != 0UL;
    } else {
#line 185
      tmp___1 = name->found_count == occurrence_option;
    }
#line 185
    if (! tmp___1) {
      {
#line 187
      skip_member();
      }
#line 188
      goto switch_break;
    }
    case_2: /* CIL Label */ 
#line 193
    logical_status = status;
#line 194
    goto switch_break;
    case_3: /* CIL Label */ 
#line 197
    if (ignore_zeros_option) {
      {
#line 199
      set_next_block_after(current_header);
      }
#line 200
      goto switch_break;
    }
    case_4: /* CIL Label */ 
#line 204
    logical_status = (enum read_header )4;
#line 205
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 208
    set_next_block_after(current_header);
    }
    {
#line 211
    if ((unsigned int )previous_status == 0U) {
#line 211
      goto case_0___0;
    }
#line 217
    if ((unsigned int )previous_status == 3U) {
#line 217
      goto case_3___0;
    }
#line 217
    if ((unsigned int )previous_status == 2U) {
#line 217
      goto case_3___0;
    }
#line 217
    if ((unsigned int )previous_status == 1U) {
#line 217
      goto case_3___0;
    }
#line 221
    if ((unsigned int )previous_status == 5U) {
#line 221
      goto case_5___0;
    }
#line 224
    if ((unsigned int )previous_status == 4U) {
#line 224
      goto case_4___0;
    }
#line 209
    goto switch_break___0;
    case_0___0: /* CIL Label */ 
    {
#line 212
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 212
      if (error_hook) {
        {
#line 212
        (*error_hook)();
        }
      }
      {
#line 212
      tmp___2 = gettext("This does not look like a tar archive");
#line 212
      error(0, 0, (char const   *)tmp___2);
      }
#line 212
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    case_3___0: /* CIL Label */ 
    case_2___0: /* CIL Label */ 
    case_1___0: /* CIL Label */ 
    {
#line 218
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 218
      if (error_hook) {
        {
#line 218
        (*error_hook)();
        }
      }
      {
#line 218
      tmp___3 = gettext("Skipping to next header");
#line 218
      error(0, 0, (char const   *)tmp___3);
#line 218
      exit_status = 2;
      }
#line 218
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    case_5___0: /* CIL Label */ 
#line 222
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 225
    abort();
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 227
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 230
    previous_status = status;
#line 167
    if (! ((unsigned int )logical_status == 0U)) {
#line 167
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 234
  records_skipped = records_read - 1L;
#line 235
  tmp___4 = xmalloc(record_size);
#line 235
  new_record = (union block *)tmp___4;
  }
#line 237
  if ((unsigned int )logical_status == 1U) {
#line 237
    goto _L;
  } else
#line 237
  if ((unsigned int )logical_status == 2U) {
    _L: /* CIL Label */ 
#line 240
    write_archive_to_stdout = (_Bool)0;
#line 244
    new_blocks = (int )(current_block - record_start);
#line 245
    if (new_blocks) {
      {
#line 246
      memcpy((void */* __restrict  */)new_record, (void const   */* __restrict  */)record_start,
             (size_t )(new_blocks * 512));
      }
    }
#line 248
    if ((unsigned int )logical_status == 1U) {
#line 251
      logical_status = (enum read_header )0;
#line 252
      goto flush_file;
    }
    {
#line 258
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 264
      if ((unsigned long )current_block == (unsigned long )record_end) {
        {
#line 265
        flush_archive();
        }
      }
      {
#line 266
      status___0 = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
#line 269
      xheader_decode(& current_stat_info);
      }
#line 271
      if ((unsigned int )status___0 == 3U) {
#line 271
        if (ignore_zeros_option) {
          {
#line 273
          set_next_block_after(current_header);
          }
#line 274
          goto while_continue___2;
        }
      }
#line 276
      if ((unsigned int )status___0 == 4U) {
#line 278
        logical_status = (enum read_header )4;
#line 279
        goto while_break___2;
      } else
#line 276
      if ((unsigned int )status___0 == 3U) {
#line 278
        logical_status = (enum read_header )4;
#line 279
        goto while_break___2;
      }
#line 282
      if ((unsigned int )status___0 == 5U) {
        {
#line 284
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 284
          if (error_hook) {
            {
#line 284
            (*error_hook)();
            }
          }
          {
#line 284
          tmp___5 = gettext("Deleting non-header from archive");
#line 284
          error(0, 0, (char const   *)tmp___5);
#line 284
          exit_status = 2;
          }
#line 284
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 285
        set_next_block_after(current_header);
        }
#line 286
        goto while_continue___2;
      }
      {
#line 291
      name = name_scan((char const   *)current_stat_info.file_name);
      }
#line 291
      if ((unsigned long )name != (unsigned long )((void *)0)) {
#line 293
        (name->found_count) ++;
#line 294
        if (occurrence_option == 0UL) {
#line 294
          tmp___6 = name->found_count != 0UL;
        } else {
#line 294
          tmp___6 = name->found_count == occurrence_option;
        }
#line 294
        if (tmp___6) {
          flush_file: 
          {
#line 297
          set_next_block_after(current_header);
#line 298
          blocks_to_skip = ((current_stat_info.stat.st_size + 512L) - 1L) / 512L;
          }
          {
#line 301
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 301
            if (! (record_end - current_block <= blocks_to_skip)) {
#line 301
              goto while_break___4;
            }
            {
#line 303
            blocks_to_skip -= record_end - current_block;
#line 304
            flush_archive();
            }
          }
          while_break___4: /* CIL Label */ ;
          }
#line 306
          current_block += blocks_to_skip;
#line 307
          blocks_to_skip = (off_t )0;
#line 308
          goto while_continue___2;
        }
      }
#line 313
      if (current_stat_info.xhdr.size) {
        {
#line 315
        write_recent_bytes(current_stat_info.xhdr.buffer, current_stat_info.xhdr.size);
        }
      } else {
        {
#line 320
        write_recent_blocks(recent_long_name, recent_long_name_blocks);
#line 321
        write_recent_blocks(recent_long_link, recent_long_link_blocks);
        }
      }
      {
#line 323
      *(new_record + new_blocks) = *current_header;
#line 324
      new_blocks ++;
#line 325
      blocks_to_keep = ((current_stat_info.stat.st_size + 512L) - 1L) / 512L;
#line 327
      set_next_block_after(current_header);
      }
#line 328
      if (new_blocks == blocking_factor) {
        {
#line 329
        write_record(1);
        }
      }
#line 333
      kept_blocks_in_record = (int )(record_end - current_block);
#line 334
      if ((off_t )kept_blocks_in_record > blocks_to_keep) {
#line 335
        kept_blocks_in_record = (int )blocks_to_keep;
      }
      {
#line 337
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 337
        if (! blocks_to_keep) {
#line 337
          goto while_break___5;
        }
#line 341
        if ((unsigned long )current_block == (unsigned long )record_end) {
          {
#line 343
          flush_read();
#line 344
          current_block = record_start;
#line 345
          kept_blocks_in_record = blocking_factor;
          }
#line 346
          if ((off_t )kept_blocks_in_record > blocks_to_keep) {
#line 347
            kept_blocks_in_record = (int )blocks_to_keep;
          }
        }
#line 349
        count = kept_blocks_in_record;
#line 350
        if (blocking_factor - new_blocks < count) {
#line 351
          count = blocking_factor - new_blocks;
        }
#line 353
        if (! count) {
          {
#line 354
          abort();
          }
        }
        {
#line 356
        memcpy((void */* __restrict  */)(new_record + new_blocks), (void const   */* __restrict  */)current_block,
               (size_t )(count * 512));
#line 357
        new_blocks += count;
#line 358
        current_block += count;
#line 359
        blocks_to_keep -= (off_t )count;
#line 360
        kept_blocks_in_record -= count;
        }
#line 362
        if (new_blocks == blocking_factor) {
          {
#line 363
          write_record(1);
          }
        }
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 367
    if ((unsigned int )logical_status == 4U) {
#line 372
      total_zero_blocks = 0;
      {
#line 374
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 376
        zero_blocks = blocking_factor - new_blocks;
#line 377
        memset((void *)(new_record + new_blocks), 0, (size_t )(512 * zero_blocks));
#line 378
        total_zero_blocks += zero_blocks;
#line 379
        write_record(total_zero_blocks < 2);
        }
#line 374
        if (! (total_zero_blocks < 2)) {
#line 374
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 384
    if (! acting_as_filter) {
#line 384
      if (! (archive >= 1 << 30)) {
        {
#line 386
        tmp___7 = sys_truncate(archive);
        }
#line 386
        if (tmp___7) {
          {
#line 387
          truncate_warn(*(archive_name_array + 0));
          }
        }
      }
    }
  }
  {
#line 390
  free((void *)new_record);
#line 392
  close_archive();
#line 393
  names_notfound();
  }
#line 394
  return;
}
}
#line 124 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 508
union block *write_extended(_Bool global , struct tar_stat_info *st , union block *old_header ) ;
#line 524
_Bool time_to_chars(time_t v , char *p , size_t s ) ;
#line 974
#pragma GCC diagnostic pop
#line 52 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static struct exclusion_tag *exclusion_tags  ;
#line 54 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void add_exclusion_tag(char const   *name , enum exclusion_tag_type type , _Bool (*predicate)(int fd ) ) 
{ 
  struct exclusion_tag *tag ;
  void *tmp ;

  {
  {
#line 58
  tmp = xmalloc(sizeof(*(tag + 0)));
#line 58
  tag = (struct exclusion_tag *)tmp;
#line 59
  tag->next = exclusion_tags;
#line 60
  tag->name = name;
#line 61
  tag->type = type;
#line 62
  tag->predicate = predicate;
#line 63
  tag->length = strlen(name);
#line 64
  exclusion_tags = tag;
  }
#line 65
  return;
}
}
#line 67 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void exclusion_tag_warning(char const   *dirname , char const   *tagname , char const   *message ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 71
  if (verbose_option) {
    {
#line 72
    while (1) {
      while_continue: /* CIL Label */ ;
#line 72
      if (warning_option & 4) {
        {
#line 72
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 72
          if (error_hook) {
            {
#line 72
            (*error_hook)();
            }
          }
          {
#line 72
          tmp = quotearg_n(1, tagname);
#line 72
          tmp___0 = quotearg_colon(dirname);
#line 72
          tmp___1 = gettext("%s: contains a cache directory tag %s; %s");
#line 72
          error(0, 0, (char const   *)tmp___1, tmp___0, tmp, message);
          }
#line 72
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 72
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 78
  return;
}
}
#line 80 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
enum exclusion_tag_type check_exclusion_tags(struct tar_stat_info  const  *st , char const   **tag_file_name ) 
{ 
  struct exclusion_tag *tag ;
  int tagfd ;
  int tmp ;
  _Bool satisfied ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
#line 85
  tag = exclusion_tags;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! tag) {
#line 85
      goto while_break;
    }
    {
#line 87
    tmp = subfile_open(st, tag->name, open_read_flags);
#line 87
    tagfd = tmp;
    }
#line 88
    if (0 <= tagfd) {
#line 90
      if (! tag->predicate) {
#line 90
        tmp___1 = 1;
      } else {
        {
#line 90
        tmp___0 = (*(tag->predicate))(tagfd);
        }
#line 90
        if (tmp___0) {
#line 90
          tmp___1 = 1;
        } else {
#line 90
          tmp___1 = 0;
        }
      }
      {
#line 90
      satisfied = (_Bool )tmp___1;
#line 91
      close(tagfd);
      }
#line 92
      if (satisfied) {
#line 94
        if (tag_file_name) {
#line 95
          *tag_file_name = tag->name;
        }
#line 96
        return (tag->type);
      }
    }
#line 85
    tag = tag->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return ((enum exclusion_tag_type )0);
}
}
#line 114 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
_Bool cachedir_file_p(int fd ) 
{ 
  char tagbuf[sizeof("Signature: 8a477f597d28d172789f06886806bc55") - 1UL] ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 119
  tmp = read(fd, (void *)(tagbuf), sizeof("Signature: 8a477f597d28d172789f06886806bc55") - 1UL);
  }
#line 119
  if ((unsigned long )tmp == sizeof("Signature: 8a477f597d28d172789f06886806bc55") - 1UL) {
    {
#line 119
    tmp___0 = memcmp((void const   *)(tagbuf), (void const   *)"Signature: 8a477f597d28d172789f06886806bc55",
                     sizeof("Signature: 8a477f597d28d172789f06886806bc55") - 1UL);
    }
#line 119
    if (tmp___0 == 0) {
#line 119
      tmp___1 = 1;
    } else {
#line 119
      tmp___1 = 0;
    }
  } else {
#line 119
    tmp___1 = 0;
  }
#line 119
  return ((_Bool )tmp___1);
}
}
#line 140 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void to_octal(uintmax_t value___0 , char *where , size_t size ) 
{ 
  uintmax_t v ;
  size_t i ;

  {
#line 143
  v = value___0;
#line 144
  i = size;
  {
#line 146
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    i --;
#line 148
    *(where + i) = (char )(48UL + (v & (unsigned long )((1 << 3) - 1)));
#line 149
    v >>= 3;
#line 146
    if (! i) {
#line 146
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  return;
}
}
#line 157 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void tar_copy_str(char *dst , char const   *src , size_t len ) 
{ 
  size_t i ;
  char tmp ;

  {
#line 161
  i = (size_t )0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < len)) {
#line 161
      goto while_break;
    }
#line 162
    tmp = (char )*(src + i);
#line 162
    *(dst + i) = tmp;
#line 162
    if (! tmp) {
#line 163
      goto while_break;
    }
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 169 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void tar_name_copy_str(char *dst , char const   *src , size_t len ) 
{ 


  {
  {
#line 172
  tar_copy_str(dst, src, len);
  }
#line 173
  if ((unsigned int )archive_format == 2U) {
#line 174
    *(dst + (len - 1UL)) = (char)0;
  }
#line 175
  return;
}
}
#line 183 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void to_base256(int negative , uintmax_t value___0 , char *where , size_t size ) 
{ 
  uintmax_t v ;
  uintmax_t propagated_sign_bits ;
  size_t i ;

  {
#line 186
  v = value___0;
#line 187
  propagated_sign_bits = (uintmax_t )(- negative) << (8UL * sizeof(v) - 8UL);
#line 189
  i = size;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    i --;
#line 193
    *(where + i) = (char )(v & (unsigned long )((1 << 8) - 1));
#line 194
    v = propagated_sign_bits | (v >> 8);
#line 191
    if (! i) {
#line 191
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return;
}
}
#line 208
static _Bool to_chars(int negative , uintmax_t value___0 , size_t valsize , uintmax_t (*substitute)(int * ) ,
                      char *where , size_t size , char const   *type ) ;
#line 213 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool to_chars_subst(int negative , int gnu_format , uintmax_t value___0 ,
                            size_t valsize , uintmax_t (*substitute)(int * ) , char *where ,
                            size_t size , char const   *type ) 
{ 
  uintmax_t maxval ;
  uintmax_t tmp ;
  uintmax_t tmp___0 ;
  uintmax_t tmp___1 ;
  char valbuf[(((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char maxbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char minbuf[(((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char const   *minval_string ;
  char const   *maxval_string ;
  char *tmp___2 ;
  char const   *value_string ;
  uintmax_t m ;
  uintmax_t tmp___3 ;
  char *p ;
  char *tmp___4 ;
  char *p___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int negsub ;
  uintmax_t sub ;
  uintmax_t tmp___7 ;
  uintmax_t s ;
  uintmax_t tmp___8 ;
  char subbuf[(((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL) + 1UL] ;
  char *sub_string ;
  char *tmp___9 ;
  char *tmp___10 ;
  _Bool tmp___11 ;
  char *tmp___12 ;

  {
#line 218
  if (gnu_format) {
#line 218
    if ((size - 1UL) * 8UL < sizeof(uintmax_t ) * 8UL) {
#line 218
      tmp = (1UL << (size - 1UL) * 8UL) - 1UL;
    } else {
#line 218
      tmp = (uintmax_t )-1;
    }
#line 218
    tmp___1 = tmp;
  } else {
#line 218
    if ((size - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 218
      tmp___0 = (1UL << (size - 1UL) * 3UL) - 1UL;
    } else {
#line 218
      tmp___0 = (uintmax_t )-1;
    }
#line 218
    tmp___1 = tmp___0;
  }
  {
#line 218
  maxval = tmp___1;
#line 225
  tmp___2 = umaxtostr(maxval, maxbuf);
#line 225
  maxval_string = (char const   *)tmp___2;
  }
#line 228
  if (gnu_format) {
#line 230
    if (maxval + 1UL) {
#line 230
      tmp___3 = maxval + 1UL;
    } else {
#line 230
      tmp___3 = maxval / 2UL + 1UL;
    }
    {
#line 230
    m = tmp___3;
#line 231
    tmp___4 = umaxtostr(m, minbuf + 1);
#line 231
    p = tmp___4;
#line 232
    p --;
#line 232
    *p = (char )'-';
#line 233
    minval_string = (char const   *)p;
    }
  } else {
#line 236
    minval_string = "0";
  }
#line 238
  if (negative) {
    {
#line 240
    tmp___5 = umaxtostr(- value___0, valbuf + 1);
#line 240
    p___0 = tmp___5;
#line 241
    p___0 --;
#line 241
    *p___0 = (char )'-';
#line 242
    value_string = (char const   *)p___0;
    }
  } else {
    {
#line 245
    tmp___6 = umaxtostr(value___0, valbuf);
#line 245
    value_string = (char const   *)tmp___6;
    }
  }
#line 247
  if (substitute) {
    {
#line 250
    tmp___7 = (*substitute)(& negsub);
#line 250
    sub = tmp___7 & maxval;
#line 258
    negsub &= (unsigned int )archive_format == 6U;
    }
#line 258
    if (negsub) {
#line 258
      tmp___8 = - sub;
    } else {
#line 258
      tmp___8 = sub;
    }
    {
#line 258
    s = tmp___8;
#line 260
    tmp___9 = umaxtostr(s, subbuf + 1);
#line 260
    sub_string = tmp___9;
    }
#line 261
    if (negsub) {
#line 262
      sub_string --;
#line 262
      *sub_string = (char )'-';
    }
    {
#line 263
    while (1) {
      while_continue: /* CIL Label */ ;
#line 263
      if (error_hook) {
        {
#line 263
        (*error_hook)();
        }
      }
      {
#line 263
      tmp___10 = gettext("value %s out of %s range %s..%s; substituting %s");
#line 263
      error(0, 0, (char const   *)tmp___10, value_string, type, minval_string, maxval_string,
            sub_string);
      }
#line 263
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 266
    tmp___11 = to_chars(negsub, s, valsize, (uintmax_t (*)(int * ))0, where, size,
                        type);
    }
#line 266
    return (tmp___11);
  } else {
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (error_hook) {
        {
#line 269
        (*error_hook)();
        }
      }
      {
#line 269
      tmp___12 = gettext("value %s out of %s range %s..%s");
#line 269
      error(0, 0, (char const   *)tmp___12, value_string, type, minval_string, maxval_string);
#line 269
      exit_status = 2;
      }
#line 269
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 271
  return ((_Bool)0);
}
}
#line 325 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static int warned_once___1  ;
#line 288 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool to_chars(int negative , uintmax_t value___0 , size_t valsize , uintmax_t (*substitute)(int * ) ,
                      char *where , size_t size , char const   *type ) 
{ 
  int gnu_format ;
  int tmp ;
  char *tmp___0 ;
  uintmax_t tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;
  _Bool tmp___5 ;

  {
#line 293
  if ((unsigned int )archive_format == 6U) {
#line 293
    tmp = 1;
  } else
#line 293
  if ((unsigned int )archive_format == 2U) {
#line 293
    tmp = 1;
  } else {
#line 293
    tmp = 0;
  }
#line 293
  gnu_format = tmp;
#line 297
  if (! negative) {
#line 297
    if ((size - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 297
      tmp___4 = (1UL << (size - 1UL) * 3UL) - 1UL;
    } else {
#line 297
      tmp___4 = (uintmax_t )-1;
    }
#line 297
    if (value___0 <= tmp___4) {
      {
#line 299
      *(where + (size - 1UL)) = (char )'\000';
#line 300
      to_octal(value___0, where, size - 1UL);
      }
#line 301
      return ((_Bool)1);
    } else {
#line 297
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 303
  if (gnu_format) {
#line 309
    if (negative) {
#line 309
      tmp___2 = 0xffffffffffffffffUL - value___0;
    } else {
#line 309
      tmp___2 = value___0;
    }
#line 309
    if ((size - 1UL) * 8UL < sizeof(uintmax_t ) * 8UL) {
#line 309
      tmp___3 = (1UL << (size - 1UL) * 8UL) - 1UL;
    } else {
#line 309
      tmp___3 = (uintmax_t )-1;
    }
#line 309
    if (tmp___2 <= tmp___3) {
#line 312
      if (negative) {
#line 312
        *(where + 0) = (char)-1;
      } else {
#line 312
        *(where + 0) = (char )(1 << 7);
      }
      {
#line 313
      to_base256(negative, value___0, where + 1, size - 1UL);
      }
#line 314
      return ((_Bool)1);
    } else
#line 323
    if (negative) {
#line 323
      if (valsize * 8UL <= (size - 1UL) * 3UL) {
#line 326
        if (! warned_once___1) {
#line 328
          warned_once___1 = 1;
          {
#line 329
          while (1) {
            while_continue: /* CIL Label */ ;
#line 329
            if (error_hook) {
              {
#line 329
              (*error_hook)();
              }
            }
            {
#line 329
            tmp___0 = gettext("Generating negative octal headers");
#line 329
            error(0, 0, (char const   *)tmp___0);
            }
#line 329
            goto while_break;
          }
          while_break: /* CIL Label */ ;
          }
        }
#line 331
        *(where + (size - 1UL)) = (char )'\000';
#line 332
        if (valsize * 8UL < sizeof(uintmax_t ) * 8UL) {
#line 332
          tmp___1 = (1UL << valsize * 8UL) - 1UL;
        } else {
#line 332
          tmp___1 = (uintmax_t )-1;
        }
        {
#line 332
        to_octal(value___0 & tmp___1, where, size - 1UL);
        }
#line 334
        return ((_Bool)1);
      }
    }
  } else {
#line 339
    substitute = (uintmax_t (*)(int * ))((void *)0);
  }
  {
#line 341
  tmp___5 = to_chars_subst(negative, gnu_format, value___0, valsize, substitute, where,
                           size, type);
  }
#line 341
  return (tmp___5);
}
}
#line 352 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static gid_t gid_nobody  ;
#line 345 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static uintmax_t gid_substitute(int *negative ) 
{ 
  gid_t r ;
  int tmp ;

  {
#line 353
  if (! gid_nobody) {
    {
#line 353
    tmp = gname_to_gid("nobody", & gid_nobody);
    }
#line 353
    if (! tmp) {
#line 354
      gid_nobody = (gid_t )-2;
    }
  }
#line 355
  r = gid_nobody;
#line 357
  *negative = r < 0U;
#line 358
  return ((uintmax_t )r);
}
}
#line 361 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool gid_to_chars(gid_t v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 364
  tmp = to_chars(v < 0U, (uintmax_t )v, sizeof(v), & gid_substitute, p, s, "gid_t");
  }
#line 364
  return (tmp);
}
}
#line 367 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool major_to_chars(int v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 370
  tmp = to_chars(v < 0, (uintmax_t )v, sizeof(v), (uintmax_t (*)(int * ))0, p, s,
                 "major_t");
  }
#line 370
  return (tmp);
}
}
#line 373 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool minor_to_chars(int v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 376
  tmp = to_chars(v < 0, (uintmax_t )v, sizeof(v), (uintmax_t (*)(int * ))0, p, s,
                 "minor_t");
  }
#line 376
  return (tmp);
}
}
#line 379 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool mode_to_chars(mode_t v , char *p , size_t s ) 
{ 
  int negative ;
  uintmax_t u ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;

  {
#line 389
  if (256 >> 3 == 32) {
#line 389
    if (128 >> 3 == 16) {
#line 389
      if (64 >> 3 == 8) {
#line 389
        if ((256 >> 3) >> 3 == 4) {
#line 389
          if ((128 >> 3) >> 3 == 2) {
#line 389
            if ((64 >> 3) >> 3 == 1) {
#line 389
              if ((unsigned int )archive_format != 4U) {
#line 389
                if ((unsigned int )archive_format != 3U) {
#line 389
                  if ((unsigned int )archive_format != 6U) {
#line 397
                    negative = v < 0U;
#line 398
                    u = (uintmax_t )v;
                  } else {
#line 389
                    goto _L___6;
                  }
                } else {
#line 389
                  goto _L___6;
                }
              } else {
#line 389
                goto _L___6;
              }
            } else {
#line 389
              goto _L___6;
            }
          } else {
#line 389
            goto _L___6;
          }
        } else {
#line 389
          goto _L___6;
        }
      } else {
#line 389
        goto _L___6;
      }
    } else {
#line 389
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
#line 402
    negative = 0;
#line 403
    if (v & 2048U) {
#line 403
      tmp = 2048;
    } else {
#line 403
      tmp = 0;
    }
#line 403
    if (v & 1024U) {
#line 403
      tmp___0 = 1024;
    } else {
#line 403
      tmp___0 = 0;
    }
#line 403
    if (v & 512U) {
#line 403
      tmp___1 = 512;
    } else {
#line 403
      tmp___1 = 0;
    }
#line 403
    if (v & 256U) {
#line 403
      tmp___2 = 256;
    } else {
#line 403
      tmp___2 = 0;
    }
#line 403
    if (v & 128U) {
#line 403
      tmp___3 = 128;
    } else {
#line 403
      tmp___3 = 0;
    }
#line 403
    if (v & 64U) {
#line 403
      tmp___4 = 64;
    } else {
#line 403
      tmp___4 = 0;
    }
#line 403
    if (v & (unsigned int )(256 >> 3)) {
#line 403
      tmp___5 = 32;
    } else {
#line 403
      tmp___5 = 0;
    }
#line 403
    if (v & (unsigned int )(128 >> 3)) {
#line 403
      tmp___6 = 16;
    } else {
#line 403
      tmp___6 = 0;
    }
#line 403
    if (v & (unsigned int )(64 >> 3)) {
#line 403
      tmp___7 = 8;
    } else {
#line 403
      tmp___7 = 0;
    }
#line 403
    if (v & (unsigned int )((256 >> 3) >> 3)) {
#line 403
      tmp___8 = 4;
    } else {
#line 403
      tmp___8 = 0;
    }
#line 403
    if (v & (unsigned int )((128 >> 3) >> 3)) {
#line 403
      tmp___9 = 2;
    } else {
#line 403
      tmp___9 = 0;
    }
#line 403
    if (v & (unsigned int )((64 >> 3) >> 3)) {
#line 403
      tmp___10 = 1;
    } else {
#line 403
      tmp___10 = 0;
    }
#line 403
    u = (uintmax_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
  {
#line 416
  tmp___11 = to_chars(negative, u, sizeof(v), (uintmax_t (*)(int * ))0, p, s, "mode_t");
  }
#line 416
  return (tmp___11);
}
}
#line 419 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
_Bool off_to_chars(off_t v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 422
  tmp = to_chars(v < 0L, (uintmax_t )v, sizeof(v), (uintmax_t (*)(int * ))0, p, s,
                 "off_t");
  }
#line 422
  return (tmp);
}
}
#line 425 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
_Bool time_to_chars(time_t v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 428
  tmp = to_chars(v < 0L, (uintmax_t )v, sizeof(v), (uintmax_t (*)(int * ))0, p, s,
                 "time_t");
  }
#line 428
  return (tmp);
}
}
#line 438 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static uid_t uid_nobody  ;
#line 431 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static uintmax_t uid_substitute(int *negative ) 
{ 
  uid_t r ;
  int tmp ;

  {
#line 439
  if (! uid_nobody) {
    {
#line 439
    tmp = uname_to_uid("nobody", & uid_nobody);
    }
#line 439
    if (! tmp) {
#line 440
      uid_nobody = (uid_t )-2;
    }
  }
#line 441
  r = uid_nobody;
#line 443
  *negative = r < 0U;
#line 444
  return ((uintmax_t )r);
}
}
#line 447 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool uid_to_chars(uid_t v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 450
  tmp = to_chars(v < 0U, (uintmax_t )v, sizeof(v), & uid_substitute, p, s, "uid_t");
  }
#line 450
  return (tmp);
}
}
#line 453 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool uintmax_to_chars(uintmax_t v , char *p , size_t s ) 
{ 
  _Bool tmp ;

  {
  {
#line 456
  tmp = to_chars(0, v, sizeof(v), (uintmax_t (*)(int * ))0, p, s, "uintmax_t");
  }
#line 456
  return (tmp);
}
}
#line 459 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void string_to_chars(char const   *str , char *p , size_t s ) 
{ 


  {
  {
#line 462
  tar_copy_str(p, str, s);
#line 463
  *(p + (s - 1UL)) = (char )'\000';
  }
#line 464
  return;
}
}
#line 476 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool file_dumpable_p(struct stat  const  *st ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 479
  if ((st->st_mode & 61440U) == 16384U) {
#line 480
    return ((_Bool)1);
  }
#line 481
  if (! ((st->st_mode & 61440U) == 32768U)) {
#line 482
    return ((_Bool)0);
  }
#line 483
  if (dev_null_output) {
#line 484
    if (totals_option) {
#line 484
      if (sparse_option) {
#line 484
        if (st->st_size % 512L != 0L) {
#line 484
          if (st->st_size / 512L != 0L) {
#line 484
            tmp = 1;
          } else {
#line 484
            tmp = 0;
          }
        } else {
#line 484
          tmp = 0;
        }
#line 484
        if (st->st_blocks < st->st_size / 512L + (__off_t const   )tmp) {
#line 484
          tmp___0 = 1;
        } else {
#line 484
          tmp___0 = 0;
        }
      } else {
#line 484
        tmp___0 = 0;
      }
    } else {
#line 484
      tmp___0 = 0;
    }
#line 484
    return ((_Bool )tmp___0);
  }
#line 485
  if (st->st_size == 0L) {
#line 485
    if ((st->st_mode & (unsigned int const   )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) == (unsigned int const   )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
#line 485
      tmp___1 = 0;
    } else {
#line 485
      tmp___1 = 1;
    }
  } else {
#line 485
    tmp___1 = 1;
  }
#line 485
  return ((_Bool )tmp___1);
}
}
#line 494 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void write_eot(void) 
{ 
  union block *pointer ;
  union block *tmp ;
  size_t tmp___0 ;

  {
  {
#line 497
  tmp = find_next_block();
#line 497
  pointer = tmp;
#line 498
  memset((void *)(pointer->buffer), 0, (size_t )512);
#line 499
  set_next_block_after(pointer);
#line 500
  pointer = find_next_block();
#line 501
  tmp___0 = available_space_after(pointer);
#line 501
  memset((void *)(pointer->buffer), 0, tmp___0);
#line 502
  set_next_block_after(pointer);
  }
#line 503
  return;
}
}
#line 506 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
union block *start_private_header(char const   *name , size_t size , time_t t ) 
{ 
  union block *header ;
  union block *tmp ;
  uintmax_t tmp___1 ;
  uintmax_t tmp___2 ;
  uintmax_t tmp___3 ;
  uintmax_t tmp___4 ;

  {
  {
#line 509
  tmp = find_next_block();
#line 509
  header = tmp;
#line 511
  memset((void *)(header->buffer), 0, sizeof(union block ));
#line 513
  tar_name_copy_str(header->header.name, name, (size_t )100);
#line 514
  off_to_chars((off_t )size, header->header.size, sizeof(header->header.size));
  }
#line 516
  if (t < 0L) {
#line 516
    tmp___4 = (uintmax_t )0;
  } else {
#line 516
    if ((sizeof(header->header.mtime) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 516
      tmp___3 = (1UL << (sizeof(header->header.mtime) - 1UL) * 3UL) - 1UL;
    } else {
#line 516
      tmp___3 = (uintmax_t )-1;
    }
#line 516
    if ((uintmax_t )t < tmp___3) {
#line 516
      tmp___2 = (uintmax_t )t;
    } else {
#line 516
      if ((sizeof(header->header.mtime) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 516
        tmp___1 = (1UL << (sizeof(header->header.mtime) - 1UL) * 3UL) - 1UL;
      } else {
#line 516
        tmp___1 = (uintmax_t )-1;
      }
#line 516
      tmp___2 = tmp___1;
    }
#line 516
    tmp___4 = tmp___2;
  }
  {
#line 516
  time_to_chars((time_t )tmp___4, header->header.mtime, sizeof(header->header.mtime));
#line 518
  mode_to_chars((mode_t )((33152 | (256 >> 3)) | ((256 >> 3) >> 3)), header->header.mode,
                sizeof(header->header.mode));
#line 519
  uid_to_chars((uid_t )0, header->header.uid, sizeof(header->header.uid));
#line 520
  gid_to_chars((gid_t )0, header->header.gid, sizeof(header->header.gid));
#line 521
  strncpy((char */* __restrict  */)(header->header.magic), (char const   */* __restrict  */)"ustar",
          (size_t )6);
#line 522
  strncpy((char */* __restrict  */)(header->header.version), (char const   */* __restrict  */)"00",
          (size_t )2);
  }
#line 523
  return (header);
}
}
#line 529 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static union block *write_short_name(struct tar_stat_info *st ) 
{ 
  union block *header ;
  union block *tmp ;

  {
  {
#line 532
  tmp = find_next_block();
#line 532
  header = tmp;
#line 533
  memset((void *)(header->buffer), 0, sizeof(union block ));
#line 534
  tar_name_copy_str(header->header.name, (char const   *)st->file_name, (size_t )100);
  }
#line 535
  return (header);
}
}
#line 539 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void write_gnu_long_link(struct tar_stat_info *st , char const   *p , char type ) 
{ 
  size_t size ;
  size_t tmp ;
  size_t bufsize ;
  union block *header ;
  char *tmpname ;

  {
  {
#line 542
  tmp = strlen(p);
#line 542
  size = tmp + 1UL;
#line 547
  header = start_private_header("././@LongLink", size, (time_t )0);
#line 548
  uid_to_uname((uid_t )0, & tmpname);
#line 549
  string_to_chars((char const   *)tmpname, header->header.uname, sizeof(header->header.uname));
#line 550
  free((void *)tmpname);
#line 551
  gid_to_gname((gid_t )0, & tmpname);
#line 552
  string_to_chars((char const   *)tmpname, header->header.gname, sizeof(header->header.gname));
#line 553
  free((void *)tmpname);
#line 555
  strcpy((char */* __restrict  */)(header->buffer + (unsigned long )(& ((struct posix_header *)0)->magic)),
         (char const   */* __restrict  */)"ustar  ");
#line 557
  header->header.typeflag = type;
#line 558
  finish_header(st, header, (off_t )-1);
#line 560
  header = find_next_block();
#line 562
  bufsize = available_space_after(header);
  }
  {
#line 564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 564
    if (! (bufsize < size)) {
#line 564
      goto while_break;
    }
    {
#line 566
    memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)p,
           bufsize);
#line 567
    p += bufsize;
#line 568
    size -= bufsize;
#line 569
    set_next_block_after(header + (bufsize - 1UL) / 512UL);
#line 570
    header = find_next_block();
#line 571
    bufsize = available_space_after(header);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 573
  memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)p,
         size);
#line 574
  memset((void *)(header->buffer + size), 0, bufsize - size);
#line 575
  set_next_block_after(header + (size - 1UL) / 512UL);
  }
#line 576
  return;
}
}
#line 578 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static size_t split_long_name(char const   *name , size_t length ) 
{ 
  size_t i ;

  {
#line 583
  if (length > 156UL) {
#line 584
    length = (size_t )156;
  } else
#line 585
  if ((int const   )*(name + (length - 1UL)) == 47) {
#line 586
    length --;
  }
#line 587
  i = length - 1UL;
  {
#line 587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 587
    if (! (i > 0UL)) {
#line 587
      goto while_break;
    }
#line 588
    if ((int const   )*(name + i) == 47) {
#line 589
      goto while_break;
    }
#line 587
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  return (i);
}
}
#line 593 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static union block *write_ustar_long_name(char const   *name ) 
{ 
  size_t length ;
  size_t tmp ;
  size_t i ;
  size_t nlen ;
  union block *header ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 596
  tmp = strlen(name);
#line 596
  length = tmp;
  }
#line 600
  if (length > 256UL) {
    {
#line 602
    while (1) {
      while_continue: /* CIL Label */ ;
#line 602
      if (error_hook) {
        {
#line 602
        (*error_hook)();
        }
      }
      {
#line 602
      tmp___0 = quotearg_colon(name);
#line 602
      tmp___1 = gettext("%s: file name is too long (max %d); not dumped");
#line 602
      error(0, 0, (char const   *)tmp___1, tmp___0, 256);
#line 602
      exit_status = 2;
      }
#line 602
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 605
    return ((union block *)((void *)0));
  }
  {
#line 608
  i = split_long_name(name, length);
  }
#line 609
  if (i == 0UL) {
#line 609
    goto _L;
  } else {
#line 609
    nlen = (length - i) - 1UL;
#line 609
    if (nlen > 100UL) {
#line 609
      goto _L;
    } else
#line 609
    if (nlen == 0UL) {
      _L: /* CIL Label */ 
      {
#line 611
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 611
        if (error_hook) {
          {
#line 611
          (*error_hook)();
          }
        }
        {
#line 611
        tmp___2 = quotearg_colon(name);
#line 611
        tmp___3 = gettext("%s: file name is too long (cannot be split); not dumped");
#line 611
        error(0, 0, (char const   *)tmp___3, tmp___2);
#line 611
        exit_status = 2;
        }
#line 611
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 614
      return ((union block *)((void *)0));
    }
  }
  {
#line 617
  header = find_next_block();
#line 618
  memset((void *)(header->buffer), 0, sizeof(header->buffer));
#line 619
  memcpy((void */* __restrict  */)(header->header.prefix), (void const   */* __restrict  */)name,
         i);
#line 620
  memcpy((void */* __restrict  */)(header->header.name), (void const   */* __restrict  */)((name + i) + 1),
         (length - i) - 1UL);
  }
#line 622
  return (header);
}
}
#line 626 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void write_long_link(struct tar_stat_info *st ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 631
  if ((unsigned int )archive_format == 4U) {
#line 631
    goto case_4;
  }
#line 637
  if ((unsigned int )archive_format == 5U) {
#line 637
    goto case_5;
  }
#line 637
  if ((unsigned int )archive_format == 3U) {
#line 637
    goto case_5;
  }
#line 637
  if ((unsigned int )archive_format == 1U) {
#line 637
    goto case_5;
  }
#line 644
  if ((unsigned int )archive_format == 6U) {
#line 644
    goto case_6;
  }
#line 644
  if ((unsigned int )archive_format == 2U) {
#line 644
    goto case_6;
  }
#line 648
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 632
  xheader_store("linkpath", st, (void const   *)((void *)0));
  }
#line 633
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 638
  while (1) {
    while_continue: /* CIL Label */ ;
#line 638
    if (error_hook) {
      {
#line 638
      (*error_hook)();
      }
    }
    {
#line 638
    tmp = quotearg_colon((char const   *)st->link_name);
#line 638
    tmp___0 = gettext("%s: link name is too long; not dumped");
#line 638
    error(0, 0, (char const   *)tmp___0, tmp);
#line 638
    exit_status = 2;
    }
#line 638
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  goto switch_break;
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 645
  write_gnu_long_link(st, (char const   *)st->link_name, (char )'K');
  }
#line 646
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 649
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 651
  return;
}
}
#line 653 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static union block *write_long_name(struct tar_stat_info *st ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  union block *tmp___2 ;
  union block *tmp___3 ;

  {
  {
#line 658
  if ((unsigned int )archive_format == 4U) {
#line 658
    goto case_4;
  }
#line 662
  if ((unsigned int )archive_format == 1U) {
#line 662
    goto case_1;
  }
#line 673
  if ((unsigned int )archive_format == 5U) {
#line 673
    goto case_5;
  }
#line 673
  if ((unsigned int )archive_format == 3U) {
#line 673
    goto case_5;
  }
#line 677
  if ((unsigned int )archive_format == 6U) {
#line 677
    goto case_6;
  }
#line 677
  if ((unsigned int )archive_format == 2U) {
#line 677
    goto case_6;
  }
#line 681
  goto switch_default;
  case_4: /* CIL Label */ 
  {
#line 659
  xheader_store("path", st, (void const   *)((void *)0));
  }
#line 660
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 663
  tmp___1 = strlen((char const   *)st->file_name);
  }
#line 663
  if (tmp___1 > 99UL) {
    {
#line 665
    while (1) {
      while_continue: /* CIL Label */ ;
#line 665
      if (error_hook) {
        {
#line 665
        (*error_hook)();
        }
      }
      {
#line 665
      tmp = quotearg_colon((char const   *)st->file_name);
#line 665
      tmp___0 = gettext("%s: file name is too long (max %d); not dumped");
#line 665
      error(0, 0, (char const   *)tmp___0, tmp, 99);
#line 665
      exit_status = 2;
      }
#line 665
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 668
    return ((union block *)((void *)0));
  }
#line 670
  goto switch_break;
  case_5: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 674
  tmp___2 = write_ustar_long_name((char const   *)st->file_name);
  }
#line 674
  return (tmp___2);
  case_6: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 678
  write_gnu_long_link(st, (char const   *)st->file_name, (char )'L');
  }
#line 679
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 682
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 684
  tmp___3 = write_short_name(st);
  }
#line 684
  return (tmp___3);
}
}
#line 687 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
union block *write_extended(_Bool global , struct tar_stat_info *st , union block *old_header ) 
{ 
  union block *header ;
  union block hp ;
  char *p ;
  int type ;
  time_t t ;

  {
#line 695
  if (st->xhdr.buffer) {
#line 696
    return (old_header);
  } else
#line 695
  if ((unsigned long )st->xhdr.stk == (unsigned long )((void *)0)) {
#line 696
    return (old_header);
  }
  {
#line 698
  xheader_finish(& st->xhdr);
#line 699
  memcpy((void */* __restrict  */)(hp.buffer), (void const   */* __restrict  */)old_header,
         sizeof(hp));
  }
#line 700
  if (global) {
    {
#line 702
    type = 'g';
#line 703
    p = xheader_ghdr_name();
#line 704
    t = start_time.tv_sec;
    }
  } else {
    {
#line 708
    type = 'x';
#line 709
    p = xheader_xhdr_name(st);
    }
#line 710
    if (set_mtime_option) {
#line 710
      t = mtime_option.tv_sec;
    } else {
#line 710
      t = st->stat.st_mtim.tv_sec;
    }
  }
  {
#line 712
  xheader_write((char )type, p, t, & st->xhdr);
#line 713
  free((void *)p);
#line 714
  header = find_next_block();
#line 715
  memcpy((void */* __restrict  */)header, (void const   */* __restrict  */)(& hp.buffer),
         sizeof(hp.buffer));
  }
#line 716
  return (header);
}
}
#line 719 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static union block *write_header_name(struct tar_stat_info *st ) 
{ 
  union block *tmp ;
  union block *tmp___0 ;
  union block *tmp___1 ;
  size_t tmp___2 ;
  _Bool tmp___3 ;

  {
#line 722
  if ((unsigned int )archive_format == 4U) {
    {
#line 722
    tmp___3 = string_ascii_p((char const   *)st->file_name);
    }
#line 722
    if (tmp___3) {
#line 722
      goto _L;
    } else {
      {
#line 724
      xheader_store("path", st, (void const   *)((void *)0));
#line 725
      tmp = write_short_name(st);
      }
#line 725
      return (tmp);
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 727
    tmp___2 = strlen((char const   *)st->file_name);
    }
#line 727
    if ((size_t )(100 - ((unsigned int )archive_format == 2U)) < tmp___2) {
      {
#line 729
      tmp___0 = write_long_name(st);
      }
#line 729
      return (tmp___0);
    } else {
      {
#line 731
      tmp___1 = write_short_name(st);
      }
#line 731
      return (tmp___1);
    }
  }
}
}
#line 740 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
union block *start_header(struct tar_stat_info *st ) 
{ 
  union block *header ;
  char const   *uname ;
  char const   *gname ;
  mode_t tmp ;
  uid_t uid ;
  uintmax_t tmp___0 ;
  _Bool tmp___1 ;
  gid_t gid ;
  uintmax_t tmp___2 ;
  _Bool tmp___3 ;
  off_t size ;
  uintmax_t tmp___4 ;
  _Bool tmp___5 ;
  struct timespec mtime ;
  int __attribute__((__pure__))  tmp___7 ;
  uintmax_t tmp___8 ;
  uintmax_t tmp___9 ;
  _Bool tmp___10 ;
  int devmajor ;
  unsigned int tmp___11 ;
  int devminor ;
  unsigned int tmp___12 ;
  uintmax_t tmp___13 ;
  _Bool tmp___14 ;
  uintmax_t tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  size_t tmp___19 ;
  _Bool tmp___20 ;
  size_t tmp___21 ;
  _Bool tmp___22 ;
  size_t scan_xattr ;
  struct xattr_array *xattr_map ;

  {
  {
#line 744
  uname = (char const   *)((void *)0);
#line 745
  gname = (char const   *)((void *)0);
#line 747
  header = write_header_name(st);
  }
#line 748
  if (! header) {
#line 749
    return ((union block *)((void *)0));
  }
  {
#line 752
  owner_map_translate(st->stat.st_uid, & st->stat.st_uid, & uname);
#line 753
  group_map_translate(st->stat.st_gid, & st->stat.st_gid, & gname);
  }
#line 755
  if (mode_option) {
    {
#line 756
    tmp = mode_adjust(st->stat.st_mode, (_Bool )(((st->stat.st_mode & 61440U) == 16384U) != 0),
                      initial_umask, (struct mode_change  const  *)mode_option, (mode_t *)((void *)0));
#line 756
    st->stat.st_mode = (st->stat.st_mode & (unsigned int )(~ (3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) | tmp;
    }
  }
#line 784
  if ((unsigned int )archive_format == 1U) {
    {
#line 785
    mode_to_chars(st->stat.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))),
                  header->header.mode, sizeof(header->header.mode));
    }
  } else
#line 784
  if ((unsigned int )archive_format == 3U) {
    {
#line 785
    mode_to_chars(st->stat.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))),
                  header->header.mode, sizeof(header->header.mode));
    }
  } else {
    {
#line 787
    mode_to_chars(st->stat.st_mode, header->header.mode, sizeof(header->header.mode));
    }
  }
#line 790
  uid = st->stat.st_uid;
#line 791
  if ((unsigned int )archive_format == 4U) {
#line 791
    if ((sizeof(header->header.uid) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 791
      tmp___0 = (1UL << (sizeof(header->header.uid) - 1UL) * 3UL) - 1UL;
    } else {
#line 791
      tmp___0 = (uintmax_t )-1;
    }
#line 791
    if (tmp___0 < (uintmax_t )uid) {
      {
#line 794
      xheader_store("uid", st, (void const   *)((void *)0));
#line 795
      uid = (uid_t )0;
      }
    }
  }
  {
#line 797
  tmp___1 = uid_to_chars(uid, header->header.uid, sizeof(header->header.uid));
  }
#line 797
  if (! tmp___1) {
#line 798
    return ((union block *)((void *)0));
  }
#line 802
  gid = st->stat.st_gid;
#line 803
  if ((unsigned int )archive_format == 4U) {
#line 803
    if ((sizeof(header->header.gid) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 803
      tmp___2 = (1UL << (sizeof(header->header.gid) - 1UL) * 3UL) - 1UL;
    } else {
#line 803
      tmp___2 = (uintmax_t )-1;
    }
#line 803
    if (tmp___2 < (uintmax_t )gid) {
      {
#line 806
      xheader_store("gid", st, (void const   *)((void *)0));
#line 807
      gid = (gid_t )0;
      }
    }
  }
  {
#line 809
  tmp___3 = gid_to_chars(gid, header->header.gid, sizeof(header->header.gid));
  }
#line 809
  if (! tmp___3) {
#line 810
    return ((union block *)((void *)0));
  }
#line 814
  size = st->stat.st_size;
#line 815
  if ((unsigned int )archive_format == 4U) {
#line 815
    if ((sizeof(header->header.size) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 815
      tmp___4 = (1UL << (sizeof(header->header.size) - 1UL) * 3UL) - 1UL;
    } else {
#line 815
      tmp___4 = (uintmax_t )-1;
    }
#line 815
    if (tmp___4 < (uintmax_t )size) {
      {
#line 818
      xheader_store("size", st, (void const   *)((void *)0));
#line 819
      size = (off_t )0;
      }
    }
  }
  {
#line 821
  tmp___5 = off_to_chars(size, header->header.size, sizeof(header->header.size));
  }
#line 821
  if (! tmp___5) {
#line 822
    return ((union block *)((void *)0));
  }
  {
#line 830
  if ((unsigned int )set_mtime_option == 0U) {
#line 830
    goto case_0;
  }
#line 834
  if ((unsigned int )set_mtime_option == 1U) {
#line 834
    goto case_1;
  }
#line 838
  if ((unsigned int )set_mtime_option == 2U) {
#line 838
    goto case_2;
  }
#line 828
  goto switch_break;
  case_0: /* CIL Label */ 
#line 831
  mtime = st->mtime;
#line 832
  goto switch_break;
  case_1: /* CIL Label */ 
#line 835
  mtime = mtime_option;
#line 836
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 839
  tmp___7 = timespec_cmp(st->mtime, mtime_option);
  }
#line 839
  if (tmp___7 > (int __attribute__((__pure__))  )0) {
#line 839
    mtime = mtime_option;
  } else {
#line 839
    mtime = st->mtime;
  }
#line 841
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 844
  if ((unsigned int )archive_format == 4U) {
#line 846
    if ((sizeof(header->header.mtime) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 846
      tmp___8 = (1UL << (sizeof(header->header.mtime) - 1UL) * 3UL) - 1UL;
    } else {
#line 846
      tmp___8 = (uintmax_t )-1;
    }
#line 846
    if (tmp___8 < (uintmax_t )mtime.tv_sec) {
      {
#line 848
      xheader_store("mtime", st, (void const   *)(& mtime));
      }
    } else
#line 846
    if (mtime.tv_nsec != 0L) {
      {
#line 848
      xheader_store("mtime", st, (void const   *)(& mtime));
      }
    }
#line 849
    if ((sizeof(header->header.mtime) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 849
      tmp___9 = (1UL << (sizeof(header->header.mtime) - 1UL) * 3UL) - 1UL;
    } else {
#line 849
      tmp___9 = (uintmax_t )-1;
    }
#line 849
    if (tmp___9 < (uintmax_t )mtime.tv_sec) {
#line 850
      mtime.tv_sec = (__time_t )0;
    }
  }
  {
#line 852
  tmp___10 = time_to_chars(mtime.tv_sec, header->header.mtime, sizeof(header->header.mtime));
  }
#line 852
  if (! tmp___10) {
#line 853
    return ((union block *)((void *)0));
  }
#line 857
  if ((st->stat.st_mode & 61440U) == 8192U) {
#line 857
    goto _L;
  } else
#line 857
  if ((st->stat.st_mode & 61440U) == 24576U) {
    _L: /* CIL Label */ 
    {
#line 860
    tmp___11 = gnu_dev_major(st->stat.st_rdev);
#line 860
    devmajor = (int )tmp___11;
#line 861
    tmp___12 = gnu_dev_minor(st->stat.st_rdev);
#line 861
    devminor = (int )tmp___12;
    }
#line 863
    if ((unsigned int )archive_format == 4U) {
#line 863
      if ((sizeof(header->header.devmajor) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 863
        tmp___13 = (1UL << (sizeof(header->header.devmajor) - 1UL) * 3UL) - 1UL;
      } else {
#line 863
        tmp___13 = (uintmax_t )-1;
      }
#line 863
      if (tmp___13 < (uintmax_t )devmajor) {
        {
#line 866
        xheader_store("devmajor", st, (void const   *)((void *)0));
#line 867
        devmajor = 0;
        }
      }
    }
    {
#line 869
    tmp___14 = major_to_chars(devmajor, header->header.devmajor, sizeof(header->header.devmajor));
    }
#line 869
    if (! tmp___14) {
#line 870
      return ((union block *)((void *)0));
    }
#line 872
    if ((unsigned int )archive_format == 4U) {
#line 872
      if ((sizeof(header->header.devminor) - 1UL) * 3UL < sizeof(uintmax_t ) * 8UL) {
#line 872
        tmp___15 = (1UL << (sizeof(header->header.devminor) - 1UL) * 3UL) - 1UL;
      } else {
#line 872
        tmp___15 = (uintmax_t )-1;
      }
#line 872
      if (tmp___15 < (uintmax_t )devminor) {
        {
#line 875
        xheader_store("devminor", st, (void const   *)((void *)0));
#line 876
        devminor = 0;
        }
      }
    }
    {
#line 878
    tmp___16 = minor_to_chars(devminor, header->header.devminor, sizeof(header->header.devminor));
    }
#line 878
    if (! tmp___16) {
#line 879
      return ((union block *)((void *)0));
    }
  } else
#line 881
  if ((unsigned int )archive_format != 6U) {
#line 881
    if ((unsigned int )archive_format != 2U) {
      {
#line 883
      tmp___17 = major_to_chars(0, header->header.devmajor, sizeof(header->header.devmajor));
      }
#line 883
      if (tmp___17) {
        {
#line 883
        tmp___18 = minor_to_chars(0, header->header.devminor, sizeof(header->header.devminor));
        }
#line 883
        if (! tmp___18) {
#line 885
          return ((union block *)((void *)0));
        }
      } else {
#line 885
        return ((union block *)((void *)0));
      }
    }
  }
#line 888
  if ((unsigned int )archive_format == 4U) {
    {
#line 890
    xheader_store("atime", st, (void const   *)((void *)0));
#line 891
    xheader_store("ctime", st, (void const   *)((void *)0));
    }
  } else
#line 893
  if (incremental_option) {
#line 894
    if ((unsigned int )archive_format == 2U) {
      {
#line 896
      time_to_chars(st->atime.tv_sec, header->oldgnu_header.atime, sizeof(header->oldgnu_header.atime));
#line 897
      time_to_chars(st->ctime.tv_sec, header->oldgnu_header.ctime, sizeof(header->oldgnu_header.ctime));
      }
    } else
#line 894
    if ((unsigned int )archive_format == 6U) {
      {
#line 896
      time_to_chars(st->atime.tv_sec, header->oldgnu_header.atime, sizeof(header->oldgnu_header.atime));
#line 897
      time_to_chars(st->ctime.tv_sec, header->oldgnu_header.ctime, sizeof(header->oldgnu_header.ctime));
      }
    }
  }
#line 900
  if ((unsigned int )archive_format == 1U) {
#line 900
    header->header.typeflag = (char )'\000';
  } else {
#line 900
    header->header.typeflag = (char )'0';
  }
  {
#line 904
  if ((unsigned int )archive_format == 1U) {
#line 904
    goto case_1___0;
  }
#line 908
  if ((unsigned int )archive_format == 6U) {
#line 908
    goto case_6;
  }
#line 908
  if ((unsigned int )archive_format == 2U) {
#line 908
    goto case_6;
  }
#line 915
  if ((unsigned int )archive_format == 3U) {
#line 915
    goto case_3;
  }
#line 915
  if ((unsigned int )archive_format == 4U) {
#line 915
    goto case_3;
  }
#line 920
  goto switch_default;
  case_1___0: /* CIL Label */ 
#line 905
  goto switch_break___0;
  case_6: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
  {
#line 910
  strcpy((char */* __restrict  */)(header->buffer + (unsigned long )(& ((struct posix_header *)0)->magic)),
         (char const   */* __restrict  */)"ustar  ");
  }
#line 912
  goto switch_break___0;
  case_3: /* CIL Label */ 
  case_4: /* CIL Label */ 
  {
#line 916
  strncpy((char */* __restrict  */)(header->header.magic), (char const   */* __restrict  */)"ustar",
          (size_t )6);
#line 917
  strncpy((char */* __restrict  */)(header->header.version), (char const   */* __restrict  */)"00",
          (size_t )2);
  }
#line 918
  goto switch_break___0;
  switch_default: /* CIL Label */ 
  {
#line 921
  abort();
  }
  switch_break___0: /* CIL Label */ ;
  }
#line 924
  if (! ((unsigned int )archive_format == 1U)) {
#line 924
    if (! numeric_owner_option) {
#line 930
      if (uname) {
        {
#line 931
        st->uname = xstrdup(uname);
        }
      } else {
        {
#line 933
        uid_to_uname(st->stat.st_uid, & st->uname);
        }
      }
#line 935
      if (gname) {
        {
#line 936
        st->gname = xstrdup(gname);
        }
      } else {
        {
#line 938
        gid_to_gname(st->stat.st_gid, & st->gname);
        }
      }
#line 940
      if ((unsigned int )archive_format == 4U) {
        {
#line 940
        tmp___19 = strlen((char const   *)st->uname);
        }
#line 940
        if (tmp___19 > 32UL) {
          {
#line 943
          xheader_store("uname", st, (void const   *)((void *)0));
          }
        } else {
          {
#line 940
          tmp___20 = string_ascii_p((char const   *)st->uname);
          }
#line 940
          if (! tmp___20) {
            {
#line 943
            xheader_store("uname", st, (void const   *)((void *)0));
            }
          }
        }
      }
      {
#line 944
      string_to_chars((char const   *)st->uname, header->header.uname, sizeof(header->header.uname));
      }
#line 946
      if ((unsigned int )archive_format == 4U) {
        {
#line 946
        tmp___21 = strlen((char const   *)st->gname);
        }
#line 946
        if (tmp___21 > 32UL) {
          {
#line 949
          xheader_store("gname", st, (void const   *)((void *)0));
          }
        } else {
          {
#line 946
          tmp___22 = string_ascii_p((char const   *)st->gname);
          }
#line 946
          if (! tmp___22) {
            {
#line 949
            xheader_store("gname", st, (void const   *)((void *)0));
            }
          }
        }
      }
      {
#line 950
      string_to_chars((char const   *)st->gname, header->header.gname, sizeof(header->header.gname));
      }
    }
  }
#line 953
  if ((unsigned int )archive_format == 4U) {
#line 955
    if (acls_option > 0) {
#line 957
      if (st->acls_a_ptr) {
        {
#line 958
        xheader_store("SCHILY.acl.access", st, (void const   *)((void *)0));
        }
      }
#line 959
      if (st->acls_d_ptr) {
        {
#line 960
        xheader_store("SCHILY.acl.default", st, (void const   *)((void *)0));
        }
      }
    }
#line 962
    if (selinux_context_option > 0) {
#line 962
      if (st->cntx_name) {
        {
#line 963
        xheader_store("RHT.security.selinux", st, (void const   *)((void *)0));
        }
      }
    }
#line 964
    if (xattrs_option > 0) {
#line 966
      scan_xattr = (size_t )0;
#line 967
      xattr_map = st->xattr_map;
      {
#line 969
      while (1) {
        while_continue: /* CIL Label */ ;
#line 969
        if (! (scan_xattr < st->xattr_map_size)) {
#line 969
          goto while_break;
        }
        {
#line 971
        xheader_store((char const   *)(xattr_map + scan_xattr)->xkey, st, (void const   *)(& scan_xattr));
#line 972
        scan_xattr ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 977
  return (header);
}
}
#line 980 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void simple_finish_header(union block *header ) 
{ 
  size_t i ;
  int sum ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 987
  memcpy((void */* __restrict  */)(header->header.chksum), (void const   */* __restrict  */)"        ",
         sizeof(header->header.chksum));
#line 989
  sum = 0;
#line 990
  p = header->buffer;
#line 991
  i = sizeof(*header);
  }
  {
#line 991
  while (1) {
    while_continue: /* CIL Label */ ;
#line 991
    tmp___0 = i;
#line 991
    i --;
#line 991
    if (! (tmp___0 != 0UL)) {
#line 991
      goto while_break;
    }
#line 993
    tmp = p;
#line 993
    p ++;
#line 993
    sum += 255 & (int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1005
  uintmax_to_chars((uintmax_t )sum, header->header.chksum, (size_t )7);
#line 1007
  set_next_block_after(header);
  }
#line 1008
  return;
}
}
#line 1014 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void finish_header(struct tar_stat_info *st , union block *header , off_t block_ordinal ) 
{ 


  {
#line 1020
  if (verbose_option) {
#line 1020
    if ((int )header->header.typeflag != 75) {
#line 1020
      if ((int )header->header.typeflag != 76) {
#line 1020
        if ((int )header->header.typeflag != 120) {
#line 1020
          if ((int )header->header.typeflag != 103) {
            {
#line 1027
            current_format = archive_format;
#line 1028
            print_header(st, header, block_ordinal);
            }
          }
        }
      }
    }
  }
  {
#line 1031
  header = write_extended((_Bool)0, st, header);
#line 1032
  simple_finish_header(header);
  }
#line 1033
  return;
}
}
#line 1036 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void pad_archive(off_t size_left ) 
{ 
  union block *blk ;

  {
  {
#line 1040
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1040
    if (! (size_left > 0L)) {
#line 1040
      goto while_break;
    }
    {
#line 1042
    blk = find_next_block();
#line 1043
    memset((void *)(blk->buffer), 0, (size_t )512);
#line 1044
    set_next_block_after(blk);
#line 1045
    size_left -= 512L;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1047
  return;
}
}
#line 1049 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static enum dump_status dump_regular_file(int fd , struct tar_stat_info *st ) 
{ 
  off_t size_left ;
  off_t block_ordinal ;
  union block *blk ;
  size_t bufsize ;
  size_t count ;
  size_t tmp ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1052
  size_left = st->stat.st_size;
#line 1056
  block_ordinal = current_block_ordinal();
#line 1057
  blk = start_header(st);
  }
#line 1058
  if (! blk) {
#line 1059
    return ((enum dump_status )2);
  }
#line 1062
  if ((unsigned int )archive_format != 1U) {

  }
  {
#line 1065
  finish_header(st, blk, block_ordinal);
#line 1067
  mv_begin_write((char const   *)st->file_name, st->stat.st_size, st->stat.st_size);
  }
  {
#line 1068
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (size_left > 0L)) {
#line 1068
      goto while_break;
    }
    {
#line 1072
    blk = find_next_block();
#line 1074
    bufsize = available_space_after(blk);
    }
#line 1076
    if ((size_t )size_left < bufsize) {
#line 1079
      bufsize = (size_t )size_left;
#line 1080
      count = bufsize % 512UL;
#line 1081
      if (count) {
        {
#line 1082
        memset((void *)(blk->buffer + size_left), 0, 512UL - count);
        }
      }
    }
#line 1085
    if (fd <= 0) {
#line 1085
      count = bufsize;
    } else {
      {
#line 1085
      tmp = blocking_read(fd, (void *)(blk->buffer), bufsize);
#line 1085
      count = tmp;
      }
    }
#line 1086
    if (count == 0xffffffffffffffffUL) {
      {
#line 1088
      read_diag_details((char const   *)st->orig_file_name, st->stat.st_size - size_left,
                        bufsize);
#line 1090
      pad_archive(size_left);
      }
#line 1091
      return ((enum dump_status )1);
    }
    {
#line 1093
    size_left = (off_t )((size_t )size_left - count);
#line 1094
    set_next_block_after(blk + (bufsize - 1UL) / 512UL);
    }
#line 1096
    if (count != bufsize) {
      {
#line 1099
      memset((void *)(blk->buffer + count), 0, bufsize - count);
      }
      {
#line 1100
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1100
        if (warning_option & 128) {
          {
#line 1100
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1100
            if (error_hook) {
              {
#line 1100
              (*error_hook)();
              }
            }
            {
#line 1100
            tmp___0 = umaxtostr((uintmax_t )size_left, buf);
#line 1100
            tmp___1 = quotearg_colon((char const   *)st->orig_file_name);
#line 1100
            tmp___2 = ngettext("%s: File shrank by %s byte; padding with zeros", "%s: File shrank by %s bytes; padding with zeros",
                               (unsigned long )size_left);
#line 1100
            error(0, 0, (char const   *)tmp___2, tmp___1, tmp___0);
            }
#line 1100
            goto while_break___1;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1100
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1107
      if (! ignore_failed_read_option) {
        {
#line 1108
        set_exit_status(1);
        }
      }
      {
#line 1109
      pad_archive((off_t )((size_t )size_left - (bufsize - count)));
      }
#line 1110
      return ((enum dump_status )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1113
  return ((enum dump_status )0);
}
}
#line 1120 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void dump_dir0(struct tar_stat_info *st , char const   *directory ) 
{ 
  _Bool top_level ;
  char const   *tag_file_name ;
  union block *blk ;
  off_t block_ordinal ;
  off_t tmp ;
  char const   *tmp___0 ;
  off_t size_left ;
  off_t totsize ;
  size_t bufsize ;
  ssize_t count ;
  char const   *buffer___1 ;
  char const   *p_buffer ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *name_buf ;
  size_t name_size ;
  enum exclusion_tag_type tmp___4 ;
  char const   *entry___0 ;
  size_t entry_len ;
  size_t name_len ;
  void *tmp___5 ;
  _Bool tmp___6 ;
  char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  char *tmp___11 ;

  {
  {
#line 1123
  top_level = (_Bool )(! st->parent);
#line 1125
  blk = (union block *)((void *)0);
#line 1126
  tmp = current_block_ordinal();
#line 1126
  block_ordinal = tmp;
#line 1128
  st->stat.st_size = (__off_t )0;
#line 1130
  blk = start_header(st);
  }
#line 1131
  if (! blk) {
#line 1132
    return;
  }
  {
#line 1134
  info_attach_exclist(st);
  }
#line 1136
  if (incremental_option) {
#line 1136
    if ((unsigned int )archive_format != 4U) {
#line 1137
      blk->header.typeflag = (char )'D';
    } else {
#line 1139
      blk->header.typeflag = (char )'5';
    }
  } else {
#line 1139
    blk->header.typeflag = (char )'5';
  }
#line 1143
  if (! incremental_option) {
    {
#line 1144
    finish_header(st, blk, block_ordinal);
    }
  } else
#line 1145
  if (gnu_list_name->directory) {
#line 1147
    if ((unsigned int )archive_format == 4U) {
      {
#line 1149
      tmp___0 = safe_directory_contents(gnu_list_name->directory);
#line 1149
      xheader_store("GNU.dumpdir", st, (void const   *)tmp___0);
#line 1151
      finish_header(st, blk, block_ordinal);
      }
    } else {
      {
#line 1161
      block_ordinal = current_block_ordinal();
#line 1162
      buffer___1 = safe_directory_contents(gnu_list_name->directory);
#line 1163
      tmp___1 = dumpdir_size(buffer___1);
#line 1163
      totsize = (off_t )tmp___1;
#line 1164
      off_to_chars(totsize, blk->header.size, sizeof(blk->header.size));
#line 1165
      finish_header(st, blk, block_ordinal);
#line 1166
      p_buffer = buffer___1;
#line 1167
      size_left = totsize;
#line 1169
      mv_begin_write((char const   *)st->file_name, totsize, totsize);
      }
      {
#line 1170
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1170
        if (! (size_left > 0L)) {
#line 1170
          goto while_break;
        }
        {
#line 1172
        blk = find_next_block();
#line 1173
        bufsize = available_space_after(blk);
        }
#line 1174
        if ((size_t )size_left < bufsize) {
#line 1176
          bufsize = (size_t )size_left;
#line 1177
          count = (ssize_t )(bufsize % 512UL);
#line 1178
          if (count) {
            {
#line 1179
            memset((void *)(blk->buffer + size_left), 0, (size_t )(512L - count));
            }
          }
        }
        {
#line 1181
        memcpy((void */* __restrict  */)(blk->buffer), (void const   */* __restrict  */)p_buffer,
               bufsize);
#line 1182
        size_left = (off_t )((size_t )size_left - bufsize);
#line 1183
        p_buffer += bufsize;
#line 1184
        set_next_block_after(blk + (bufsize - 1UL) / 512UL);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1187
    return;
  }
#line 1190
  if (! recursion_option) {
#line 1191
    return;
  }
#line 1193
  if (one_file_system_option) {
#line 1193
    if (! top_level) {
#line 1193
      if ((st->parent)->stat.st_dev != st->stat.st_dev) {
#line 1197
        if (verbose_option) {
          {
#line 1198
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 1198
            if (warning_option & 262144) {
              {
#line 1198
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 1198
                if (error_hook) {
                  {
#line 1198
                  (*error_hook)();
                  }
                }
                {
#line 1198
                tmp___2 = quotearg_colon((char const   *)st->orig_file_name);
#line 1198
                tmp___3 = gettext("%s: file is on a different filesystem; not dumped");
#line 1198
                error(0, 0, (char const   *)tmp___3, tmp___2);
                }
#line 1198
                goto while_break___1;
              }
              while_break___1: /* CIL Label */ ;
              }
            }
#line 1198
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        }
      } else {
#line 1193
        goto _L___0;
      }
    } else {
#line 1193
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
    {
#line 1208
    tmp___4 = check_exclusion_tags((struct tar_stat_info  const  *)st, & tag_file_name);
    }
    {
#line 1210
    if ((unsigned int )tmp___4 == 3U) {
#line 1210
      goto case_3;
    }
#line 1214
    if ((unsigned int )tmp___4 == 0U) {
#line 1214
      goto case_0;
    }
#line 1241
    if ((unsigned int )tmp___4 == 1U) {
#line 1241
      goto case_1;
    }
#line 1252
    if ((unsigned int )tmp___4 == 2U) {
#line 1252
      goto case_2;
    }
#line 1208
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1212
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1220
    name_buf = xstrdup((char const   *)st->orig_file_name);
#line 1221
    name_len = strlen((char const   *)name_buf);
#line 1221
    name_size = name_len;
#line 1224
    entry___0 = directory;
    }
    {
#line 1224
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1224
      entry_len = strlen(entry___0);
      }
#line 1224
      if (! (entry_len != 0UL)) {
#line 1224
        goto while_break___2;
      }
#line 1227
      if (name_size < name_len + entry_len) {
        {
#line 1229
        name_size = name_len + entry_len;
#line 1230
        tmp___5 = xrealloc((void *)name_buf, name_size + 1UL);
#line 1230
        name_buf = (char *)tmp___5;
        }
      }
      {
#line 1232
      strcpy((char */* __restrict  */)(name_buf + name_len), (char const   */* __restrict  */)entry___0);
#line 1233
      tmp___6 = excluded_name((char const   *)name_buf, st);
      }
#line 1233
      if (! tmp___6) {
        {
#line 1234
        dump_file(st, entry___0, (char const   *)name_buf);
        }
      }
#line 1224
      entry___0 += entry_len + 1UL;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1237
    free((void *)name_buf);
    }
#line 1239
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1242
    tmp___7 = gettext("contents not dumped");
#line 1242
    exclusion_tag_warning((char const   *)st->orig_file_name, tag_file_name, (char const   *)tmp___7);
#line 1244
    tmp___8 = strlen((char const   *)st->orig_file_name);
#line 1244
    tmp___9 = strlen(tag_file_name);
#line 1244
    name_size = (tmp___8 + tmp___9) + 1UL;
#line 1245
    tmp___10 = xmalloc(name_size);
#line 1245
    name_buf = (char *)tmp___10;
#line 1246
    strcpy((char */* __restrict  */)name_buf, (char const   */* __restrict  */)st->orig_file_name);
#line 1247
    strcat((char */* __restrict  */)name_buf, (char const   */* __restrict  */)tag_file_name);
#line 1248
    dump_file(st, tag_file_name, (char const   *)name_buf);
#line 1249
    free((void *)name_buf);
    }
#line 1250
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1253
    tmp___11 = gettext("contents not dumped");
#line 1253
    exclusion_tag_warning((char const   *)st->orig_file_name, tag_file_name, (char const   *)tmp___11);
    }
#line 1255
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1258
  return;
}
}
#line 1261 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void ensure_slash(char **pstr ) 
{ 
  size_t len ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 1264
  tmp = strlen((char const   *)*pstr);
#line 1264
  len = tmp;
  }
  {
#line 1265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1265
    if (len >= 1UL) {
#line 1265
      if (! ((int )*(*pstr + (len - 1UL)) == 47)) {
#line 1265
        goto while_break;
      }
    } else {
#line 1265
      goto while_break;
    }
#line 1266
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1267
  if (! ((int )*(*pstr + len) == 47)) {
    {
#line 1268
    tmp___0 = xrealloc((void *)*pstr, len + 2UL);
#line 1268
    *pstr = (char *)tmp___0;
    }
  }
#line 1269
  tmp___1 = len;
#line 1269
  len ++;
#line 1269
  *(*pstr + tmp___1) = (char )'/';
#line 1270
  *(*pstr + len) = (char )'\000';
#line 1271
  return;
}
}
#line 1284 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool open_failure_recover(struct tar_stat_info  const  *dir ) 
{ 
  struct tar_stat_info *p ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 1287
  tmp___0 = __errno_location();
  }
#line 1287
  if (*tmp___0 == 24) {
#line 1287
    if (dir) {
#line 1287
      if (dir->parent) {
#line 1290
        p = (dir->parent)->parent;
        {
#line 1290
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1290
          if (! p) {
#line 1290
            goto while_break;
          }
#line 1291
          if (0 < p->fd) {
#line 1291
            if (! p->parent) {
              {
#line 1293
              tar_stat_close(p);
              }
#line 1294
              return ((_Bool)1);
            } else
#line 1291
            if ((p->parent)->fd <= 0) {
              {
#line 1293
              tar_stat_close(p);
              }
#line 1294
              return ((_Bool)1);
            }
          }
#line 1290
          p = p->parent;
        }
        while_break: /* CIL Label */ ;
        }
        {
#line 1296
        tmp = __errno_location();
#line 1296
        *tmp = 24;
        }
      }
    }
  }
#line 1299
  return ((_Bool)0);
}
}
#line 1305 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
char *get_directory_entries(struct tar_stat_info *st ) 
{ 
  _Bool tmp ;
  DIR *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1308
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1308
    tmp___0 = fdopendir(st->fd);
#line 1308
    st->dirstream = tmp___0;
    }
#line 1308
    if (tmp___0) {
#line 1308
      goto while_break;
    }
    {
#line 1309
    tmp = open_failure_recover((struct tar_stat_info  const  *)st);
    }
#line 1309
    if (! tmp) {
#line 1310
      return ((char *)0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1311
  tmp___1 = streamsavedir(st->dirstream, (enum savedir_option )savedir_sort_order);
  }
#line 1311
  return (tmp___1);
}
}
#line 1317 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool dump_dir(struct tar_stat_info *st ) 
{ 
  char *directory ;
  char *tmp ;

  {
  {
#line 1320
  tmp = get_directory_entries(st);
#line 1320
  directory = tmp;
  }
#line 1321
  if (! directory) {
    {
#line 1323
    savedir_diag((char const   *)st->orig_file_name);
    }
#line 1324
    return ((_Bool)0);
  }
  {
#line 1327
  dump_dir0(st, (char const   *)directory);
#line 1329
  restore_parent_fd((struct tar_stat_info  const  *)st);
#line 1330
  free((void *)directory);
  }
#line 1331
  return ((_Bool)1);
}
}
#line 1338 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static nlink_t trivial_link_count  ;
#line 1343 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void create_archive(void) 
{ 
  struct name  const  *p ;
  int tmp ;
  size_t buffer_size ;
  char *buffer___1 ;
  void *tmp___0 ;
  char const   *q ;
  _Bool tmp___1 ;
  struct tar_stat_info st ;
  size_t plen ;
  size_t tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t qlen ;
  size_t tmp___5 ;
  int fd ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  _Bool tmp___9 ;
  char const   *name ;
  _Bool tmp___10 ;

  {
#line 1348
  if (name_count <= 1UL) {
#line 1348
    if (! dereference_option) {
#line 1348
      tmp = 1;
    } else {
#line 1348
      tmp = 0;
    }
  } else {
#line 1348
    tmp = 0;
  }
  {
#line 1348
  trivial_link_count = (nlink_t )tmp;
#line 1350
  open_archive((enum access_mode )1);
#line 1351
  buffer_write_global_xheader();
  }
#line 1353
  if (incremental_option) {
    {
#line 1355
    buffer_size = (size_t )1000;
#line 1356
    tmp___0 = xmalloc(buffer_size);
#line 1356
    buffer___1 = (char *)tmp___0;
#line 1359
    collect_and_sort_names();
    }
    {
#line 1361
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1361
      p = name_from_list();
      }
#line 1361
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1361
        goto while_break;
      }
      {
#line 1362
      tmp___1 = excluded_name((char const   *)p->name, (struct tar_stat_info *)((void *)0));
      }
#line 1362
      if (! tmp___1) {
        {
#line 1363
        dump_file((struct tar_stat_info *)0, (char const   *)p->name, (char const   *)p->name);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1365
    blank_name_list();
    }
    {
#line 1366
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1366
      p = name_from_list();
      }
#line 1366
      if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1366
        goto while_break___0;
      }
      {
#line 1367
      tmp___9 = excluded_name((char const   *)p->name, (struct tar_stat_info *)((void *)0));
      }
#line 1367
      if (! tmp___9) {
        {
#line 1370
        tmp___2 = strlen((char const   *)p->name);
#line 1370
        plen = tmp___2;
        }
#line 1371
        if (buffer_size <= plen) {
          {
#line 1373
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1373
            buffer_size *= 2UL;
#line 1373
            if (! (buffer_size <= plen)) {
#line 1373
              goto while_break___1;
            }
#line 1374
            goto while_continue___1;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 1375
          tmp___3 = xrealloc((void *)buffer___1, buffer_size);
#line 1375
          buffer___1 = (char *)tmp___3;
          }
        }
        {
#line 1377
        memcpy((void */* __restrict  */)buffer___1, (void const   */* __restrict  */)p->name,
               plen);
        }
#line 1378
        if (! ((int )*(buffer___1 + (plen - 1UL)) == 47)) {
#line 1379
          tmp___4 = plen;
#line 1379
          plen ++;
#line 1379
          *(buffer___1 + tmp___4) = (char )'/';
        }
        {
#line 1380
        tar_stat_init(& st);
#line 1381
        q = directory_contents((struct directory *)p->directory);
        }
#line 1382
        if (q) {
          {
#line 1383
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 1383
            if (! *q) {
#line 1383
              goto while_break___2;
            }
            {
#line 1385
            tmp___5 = strlen(q);
#line 1385
            qlen = tmp___5;
            }
#line 1386
            if ((int const   )*q == 89) {
#line 1388
              if (! st.orig_file_name) {
                {
#line 1390
                tmp___6 = openat(chdir_fd, (char const   *)p->name, open_searchdir_flags);
#line 1390
                fd = tmp___6;
                }
#line 1392
                if (fd < 0) {
                  {
#line 1394
                  open_diag((char const   *)p->name);
                  }
#line 1395
                  goto while_break___2;
                }
                {
#line 1397
                st.fd = fd;
#line 1398
                tmp___7 = fstat(fd, & st.stat);
                }
#line 1398
                if (tmp___7 != 0) {
                  {
#line 1400
                  stat_diag((char const   *)p->name);
                  }
#line 1401
                  goto while_break___2;
                }
                {
#line 1403
                st.orig_file_name = xstrdup((char const   *)p->name);
                }
              }
#line 1405
              if (buffer_size < plen + qlen) {
                {
#line 1407
                while (1) {
                  while_continue___3: /* CIL Label */ ;
#line 1407
                  buffer_size *= 2UL;
#line 1407
                  if (! (buffer_size < plen + qlen)) {
#line 1407
                    goto while_break___3;
                  }
#line 1408
                  goto while_continue___3;
                }
                while_break___3: /* CIL Label */ ;
                }
                {
#line 1409
                tmp___8 = xrealloc((void *)buffer___1, buffer_size);
#line 1409
                buffer___1 = (char *)tmp___8;
                }
              }
              {
#line 1411
              strcpy((char */* __restrict  */)(buffer___1 + plen), (char const   */* __restrict  */)(q + 1));
#line 1412
              dump_file(& st, q + 1, (char const   *)buffer___1);
              }
            }
#line 1414
            q += qlen + 1UL;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
#line 1416
        tar_stat_destroy(& st);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1418
    free((void *)buffer___1);
    }
  } else {
    {
#line 1423
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 1423
      name = name_next(1);
      }
#line 1423
      if (! ((unsigned long )name != (unsigned long )((void *)0))) {
#line 1423
        goto while_break___4;
      }
      {
#line 1424
      tmp___10 = excluded_name(name, (struct tar_stat_info *)((void *)0));
      }
#line 1424
      if (! tmp___10) {
        {
#line 1425
        dump_file((struct tar_stat_info *)0, name, name);
        }
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 1428
  write_eot();
#line 1429
  close_archive();
#line 1430
  finish_deferred_unlinks();
  }
#line 1431
  if (listed_incremental_option) {
    {
#line 1432
    write_directory_file();
    }
  }
#line 1433
  return;
}
}
#line 1437 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static size_t hash_link(void const   *entry___0 , size_t n_buckets ) 
{ 
  struct link  const  *l ;
  uintmax_t num ;

  {
#line 1440
  l = (struct link  const  *)entry___0;
#line 1441
  num = (uintmax_t )(l->dev ^ l->ino);
#line 1442
  return (num % n_buckets);
}
}
#line 1446 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool compare_links(void const   *entry1 , void const   *entry2 ) 
{ 
  struct link  const  *link1 ;
  struct link  const  *link2 ;

  {
#line 1449
  link1 = (struct link  const  *)entry1;
#line 1450
  link2 = (struct link  const  *)entry2;
#line 1451
  return ((_Bool )(((link1->dev ^ link2->dev) | (link1->ino ^ link2->ino)) == 0UL));
}
}
#line 1454 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void unknown_file_error(char const   *p ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 1457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1457
    if (warning_option & 32) {
      {
#line 1457
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1457
        if (error_hook) {
          {
#line 1457
          (*error_hook)();
          }
        }
        {
#line 1457
        tmp = quotearg_colon(p);
#line 1457
        tmp___0 = gettext("%s: Unknown file type; file ignored");
#line 1457
        error(0, 0, (char const   *)tmp___0, tmp);
        }
#line 1457
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 1457
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1460
  if (! ignore_failed_read_option) {
    {
#line 1461
    set_exit_status(2);
    }
  }
#line 1462
  return;
}
}
#line 1470 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static Hash_table *link_table  ;
#line 1474 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool dump_hard_link(struct tar_stat_info *st ) 
{ 
  struct link lp ;
  struct link *duplicate ;
  off_t block_ordinal ;
  union block *blk ;
  char const   *link_name ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 1477
  if (link_table) {
#line 1477
    if (trivial_link_count < st->stat.st_nlink) {
#line 1477
      goto _L;
    } else
#line 1477
    if (remove_files_option) {
      _L: /* CIL Label */ 
      {
#line 1485
      lp.ino = st->stat.st_ino;
#line 1486
      lp.dev = st->stat.st_dev;
#line 1488
      tmp___1 = hash_lookup((Hash_table const   *)link_table, (void const   *)(& lp));
#line 1488
      duplicate = (struct link *)tmp___1;
      }
#line 1488
      if (duplicate) {
        {
#line 1491
        tmp = safer_name_suffix((char const   *)(duplicate->name), (_Bool)1, absolute_names_option);
#line 1491
        link_name = (char const   *)tmp;
        }
#line 1493
        if (duplicate->nlink) {
#line 1494
          (duplicate->nlink) --;
        }
        {
#line 1496
        block_ordinal = current_block_ordinal();
#line 1497
        assign_string(& st->link_name, link_name);
#line 1498
        tmp___0 = strlen(link_name);
        }
#line 1498
        if ((size_t )(100 - ((unsigned int )archive_format == 2U)) < tmp___0) {
          {
#line 1500
          write_long_link(st);
          }
        }
        {
#line 1502
        st->stat.st_size = (__off_t )0;
#line 1503
        blk = start_header(st);
        }
#line 1504
        if (! blk) {
#line 1505
          return ((_Bool)0);
        }
        {
#line 1506
        tar_copy_str(blk->header.linkname, link_name, (size_t )100);
#line 1508
        blk->header.typeflag = (char )'1';
#line 1509
        finish_header(st, blk, block_ordinal);
        }
#line 1511
        if (remove_files_option) {
          {
#line 1512
          queue_deferred_unlink((char const   *)st->orig_file_name, (_Bool)0);
          }
        }
#line 1514
        return ((_Bool)1);
      }
    }
  }
#line 1517
  return ((_Bool)0);
}
}
#line 1520 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void file_count_links(struct tar_stat_info *st ) 
{ 
  struct link *duplicate ;
  char *linkname ;
  struct link *lp ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1523
  if (hard_dereference_option) {
#line 1524
    return;
  }
#line 1525
  if (trivial_link_count < st->stat.st_nlink) {
    {
#line 1528
    linkname = (char *)((void *)0);
#line 1531
    assign_string(& linkname, (char const   *)st->orig_file_name);
#line 1532
    transform_name(& linkname, 2);
#line 1534
    tmp = strlen((char const   *)linkname);
#line 1534
    tmp___0 = xmalloc(((unsigned long )(& ((struct link *)0)->name) + tmp) + 1UL);
#line 1534
    lp = (struct link *)tmp___0;
#line 1536
    lp->ino = st->stat.st_ino;
#line 1537
    lp->dev = st->stat.st_dev;
#line 1538
    lp->nlink = st->stat.st_nlink;
#line 1539
    strcpy((char */* __restrict  */)(lp->name), (char const   */* __restrict  */)linkname);
#line 1540
    free((void *)linkname);
    }
#line 1542
    if (link_table) {
#line 1542
      goto _L;
    } else {
      {
#line 1542
      link_table = hash_initialize((size_t )0, (Hash_tuning const   *)0, & hash_link,
                                   & compare_links, (void (*)(void * ))0);
      }
#line 1542
      if (link_table) {
        _L: /* CIL Label */ 
        {
#line 1542
        tmp___1 = hash_insert(link_table, (void const   *)lp);
#line 1542
        duplicate = (struct link *)tmp___1;
        }
#line 1542
        if (! duplicate) {
          {
#line 1546
          xalloc_die();
          }
        }
      } else {
        {
#line 1546
        xalloc_die();
        }
      }
    }
#line 1548
    if ((unsigned long )duplicate != (unsigned long )lp) {
      {
#line 1549
      abort();
      }
    }
#line 1550
    (lp->nlink) --;
  }
#line 1552
  return;
}
}
#line 1556 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void check_links(void) 
{ 
  struct link *lp ;
  void *tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
#line 1561
  if (! link_table) {
#line 1562
    return;
  }
  {
#line 1564
  tmp = hash_get_first((Hash_table const   *)link_table);
#line 1564
  lp = (struct link *)tmp;
  }
  {
#line 1564
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1564
    if (! lp) {
#line 1564
      goto while_break;
    }
#line 1567
    if (lp->nlink) {
      {
#line 1569
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1569
        if (error_hook) {
          {
#line 1569
          (*error_hook)();
          }
        }
        {
#line 1569
        tmp___1 = quote((char const   *)(lp->name));
#line 1569
        tmp___2 = gettext("Missing links to %s.");
#line 1569
        error(0, 0, (char const   *)tmp___2, tmp___1);
        }
#line 1569
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 1564
    tmp___0 = hash_get_next((Hash_table const   *)link_table, (void const   *)lp);
#line 1564
    lp = (struct link *)tmp___0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1572
  return;
}
}
#line 1583 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static _Bool initialized  ;
#line 1578 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
int subfile_open(struct tar_stat_info  const  *dir , char const   *file , int flags ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 1584
  if (! initialized) {
    {
#line 1590
    initialized = (_Bool)1;
#line 1591
    strerror(2);
#line 1592
    gettext("");
    }
  }
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1595
    if (dir) {
#line 1595
      tmp = dir->fd;
    } else {
#line 1595
      tmp = (int const   )chdir_fd;
    }
    {
#line 1595
    fd = openat((int )tmp, file, flags);
    }
#line 1595
    if (fd < 0) {
      {
#line 1595
      tmp___0 = open_failure_recover(dir);
      }
#line 1595
      if (! tmp___0) {
#line 1595
        goto while_break;
      }
    } else {
#line 1595
      goto while_break;
    }
#line 1597
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 1598
  return (fd);
}
}
#line 1605 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void restore_parent_fd(struct tar_stat_info  const  *st ) 
{ 
  struct tar_stat_info *parent ;
  int parentfd ;
  int tmp ;
  struct stat parentstat ;
  int *tmp___0 ;
  int tmp___1 ;
  int origfd ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1608
  parent = (struct tar_stat_info *)st->parent;
#line 1609
  if (parent) {
#line 1609
    if (! parent->fd) {
      {
#line 1611
      tmp = openat((int )st->fd, "..", open_searchdir_flags);
#line 1611
      parentfd = tmp;
      }
#line 1614
      if (parentfd < 0) {
        {
#line 1615
        tmp___0 = __errno_location();
#line 1615
        parentfd = - *tmp___0;
        }
      } else {
        {
#line 1616
        tmp___1 = fstat(parentfd, & parentstat);
        }
#line 1616
        if (tmp___1 == 0) {
#line 1616
          if (parent->stat.st_ino == parentstat.st_ino) {
#line 1616
            if (! (parent->stat.st_dev == parentstat.st_dev)) {
              {
#line 1620
              close(parentfd);
#line 1621
              parentfd = 2;
              }
            }
          } else {
            {
#line 1620
            close(parentfd);
#line 1621
            parentfd = 2;
            }
          }
        } else {
          {
#line 1620
          close(parentfd);
#line 1621
          parentfd = 2;
          }
        }
      }
#line 1624
      if (parentfd < 0) {
        {
#line 1626
        tmp___2 = openat(chdir_fd, (char const   *)parent->orig_file_name, open_searchdir_flags);
#line 1626
        origfd = tmp___2;
        }
#line 1628
        if (0 <= origfd) {
          {
#line 1630
          tmp___3 = fstat(parentfd, & parentstat);
          }
#line 1630
          if (tmp___3 == 0) {
#line 1630
            if (parent->stat.st_ino == parentstat.st_ino) {
#line 1630
              if (parent->stat.st_dev == parentstat.st_dev) {
#line 1633
                parentfd = origfd;
              } else {
                {
#line 1635
                close(origfd);
                }
              }
            } else {
              {
#line 1635
              close(origfd);
              }
            }
          } else {
            {
#line 1635
            close(origfd);
            }
          }
        }
      }
#line 1639
      parent->fd = parentfd;
    }
  }
#line 1641
  return;
}
}
#line 1650 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
static void dump_file0(struct tar_stat_info *st , char const   *name , char const   *p ) 
{ 
  union block *header ;
  char type ;
  off_t original_size ;
  struct timespec original_ctime ;
  off_t block_ordinal ;
  int fd ;
  _Bool is_dir ;
  struct tar_stat_info  const  *parent ;
  _Bool top_level ;
  int parentfd ;
  int tmp ;
  void (*diag)(char const   * ) ;
  int tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  struct timespec  __attribute__((__pure__)) tmp___6 ;
  struct timespec  __attribute__((__pure__)) tmp___7 ;
  struct timespec  __attribute__((__pure__)) tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int __attribute__((__pure__))  tmp___11 ;
  int __attribute__((__pure__))  tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool ok ;
  struct stat final_stat ;
  char const   *tag_file_name ;
  char *tmp___17 ;
  enum exclusion_tag_type tmp___18 ;
  enum dump_status status ;
  int tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  struct timespec  __attribute__((__pure__)) tmp___27 ;
  int __attribute__((__pure__))  tmp___28 ;
  _Bool tmp___29 ;
  int *tmp___30 ;
  size_t tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  unsigned int tmp___36 ;
  unsigned int tmp___37 ;

  {
#line 1657
  block_ordinal = (off_t )-1;
#line 1658
  fd = 0;
#line 1660
  parent = (struct tar_stat_info  const  *)st->parent;
#line 1661
  top_level = (_Bool )(! parent);
#line 1662
  if (top_level) {
#line 1662
    tmp = chdir_fd;
  } else {
#line 1662
    tmp = (int )parent->fd;
  }
#line 1662
  parentfd = tmp;
#line 1663
  diag = (void (*)(char const   * ))0;
#line 1665
  if (interactive_option) {
    {
#line 1665
    tmp___0 = confirm("add", p);
    }
#line 1665
    if (! tmp___0) {
#line 1666
      return;
    }
  }
  {
#line 1668
  assign_string(& st->orig_file_name, p);
#line 1669
  tmp___1 = safer_name_suffix(p, (_Bool)0, absolute_names_option);
#line 1669
  assign_string(& st->file_name, (char const   *)tmp___1);
#line 1672
  transform_name(& st->file_name, 1);
  }
#line 1674
  if (parentfd < 0) {
#line 1674
    if (! top_level) {
      {
#line 1676
      tmp___2 = __errno_location();
#line 1676
      *tmp___2 = - parentfd;
#line 1677
      diag = & open_diag;
      }
    } else {
#line 1674
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1679
    tmp___5 = fstatat(parentfd, (char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& st->stat),
                      fstatat_flags);
    }
#line 1679
    if (tmp___5 != 0) {
#line 1680
      diag = & stat_diag;
    } else {
      {
#line 1681
      tmp___4 = file_dumpable_p((struct stat  const  *)(& st->stat));
      }
#line 1681
      if (tmp___4) {
        {
#line 1683
        fd = subfile_open(parent, name, open_read_flags);
        }
#line 1684
        if (fd < 0) {
#line 1685
          diag = & open_diag;
        } else {
          {
#line 1688
          st->fd = fd;
#line 1689
          tmp___3 = fstat(fd, & st->stat);
          }
#line 1689
          if (tmp___3 != 0) {
#line 1690
            diag = & stat_diag;
          }
        }
      }
    }
  }
#line 1693
  if (diag) {
    {
#line 1695
    file_removed_diag(p, top_level, diag);
    }
#line 1696
    return;
  }
  {
#line 1699
  original_size = st->stat.st_size;
#line 1699
  st->archive_file_size = original_size;
#line 1700
  tmp___6 = get_stat_atime((struct stat  const  *)(& st->stat));
#line 1700
  st->atime = (struct timespec )tmp___6;
#line 1701
  tmp___7 = get_stat_mtime((struct stat  const  *)(& st->stat));
#line 1701
  st->mtime = (struct timespec )tmp___7;
#line 1702
  tmp___8 = get_stat_ctime((struct stat  const  *)(& st->stat));
#line 1702
  original_ctime = (struct timespec )tmp___8;
#line 1702
  st->ctime = original_ctime;
  }
#line 1723
  if (incremental_option) {
#line 1723
    if (! (! top_level)) {
#line 1723
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1723
  if (! ((st->stat.st_mode & 61440U) == 16384U)) {
    {
#line 1723
    tmp___11 = timespec_cmp(st->mtime, newer_mtime_option);
    }
#line 1723
    if (tmp___11 < (int __attribute__((__pure__))  )0) {
#line 1723
      if (! after_date_option) {
#line 1723
        goto _L___0;
      } else {
        {
#line 1723
        tmp___12 = timespec_cmp(st->ctime, newer_mtime_option);
        }
#line 1723
        if (tmp___12 < (int __attribute__((__pure__))  )0) {
          _L___0: /* CIL Label */ 
#line 1728
          if (! incremental_option) {
#line 1728
            if (verbose_option) {
              {
#line 1729
              while (1) {
                while_continue: /* CIL Label */ ;
#line 1729
                if (warning_option & 256) {
                  {
#line 1729
                  while (1) {
                    while_continue___0: /* CIL Label */ ;
#line 1729
                    if (error_hook) {
                      {
#line 1729
                      (*error_hook)();
                      }
                    }
                    {
#line 1729
                    tmp___9 = quotearg_colon(p);
#line 1729
                    tmp___10 = gettext("%s: file is unchanged; not dumped");
#line 1729
                    error(0, 0, (char const   *)tmp___10, tmp___9);
                    }
#line 1729
                    goto while_break___0;
                  }
                  while_break___0: /* CIL Label */ ;
                  }
                }
#line 1729
                goto while_break;
              }
              while_break: /* CIL Label */ ;
              }
            }
          }
#line 1732
          return;
        }
      }
    }
  }
  {
#line 1736
  tmp___15 = sys_file_is_archive(st);
  }
#line 1736
  if (tmp___15) {
    {
#line 1738
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1738
      if (warning_option & 1024) {
        {
#line 1738
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1738
          if (error_hook) {
            {
#line 1738
            (*error_hook)();
            }
          }
          {
#line 1738
          tmp___13 = quotearg_colon(p);
#line 1738
          tmp___14 = gettext("%s: file is the archive; not dumped");
#line 1738
          error(0, 0, (char const   *)tmp___14, tmp___13);
          }
#line 1738
          goto while_break___2;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1738
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1741
    return;
  }
#line 1744
  is_dir = (_Bool )(((st->stat.st_mode & 61440U) == 16384U) != 0);
#line 1746
  if (! is_dir) {
    {
#line 1746
    tmp___16 = dump_hard_link(st);
    }
#line 1746
    if (tmp___16) {
#line 1747
      return;
    }
  }
#line 1749
  if (is_dir) {
#line 1749
    goto _L___5;
  } else
#line 1749
  if ((st->stat.st_mode & 61440U) == 32768U) {
#line 1749
    goto _L___5;
  } else
#line 1749
  if (0) {
    _L___5: /* CIL Label */ 
    {
#line 1754
    xattrs_acls_get(parentfd, name, st, 0, ! is_dir);
#line 1755
    xattrs_selinux_get(parentfd, name, st, fd);
#line 1756
    xattrs_xattrs_get(parentfd, name, st, fd);
    }
#line 1758
    if (is_dir) {
      {
#line 1761
      ensure_slash(& st->orig_file_name);
#line 1762
      ensure_slash(& st->file_name);
#line 1764
      tmp___18 = check_exclusion_tags((struct tar_stat_info  const  *)st, & tag_file_name);
      }
#line 1764
      if ((unsigned int )tmp___18 == 3U) {
        {
#line 1766
        tmp___17 = gettext("directory not dumped");
#line 1766
        exclusion_tag_warning((char const   *)st->orig_file_name, tag_file_name, (char const   *)tmp___17);
        }
#line 1768
        return;
      }
      {
#line 1771
      ok = dump_dir(st);
#line 1773
      fd = st->fd;
      }
#line 1774
      if (top_level) {
#line 1774
        parentfd = chdir_fd;
      } else {
#line 1774
        parentfd = (int )parent->fd;
      }
    } else {
#line 1780
      if (fd) {
#line 1780
        if (sparse_option) {
#line 1780
          if (st->stat.st_size % 512L != 0L) {
#line 1780
            if (st->stat.st_size / 512L != 0L) {
#line 1780
              tmp___19 = 1;
            } else {
#line 1780
              tmp___19 = 0;
            }
          } else {
#line 1780
            tmp___19 = 0;
          }
#line 1780
          if (st->stat.st_blocks < st->stat.st_size / 512L + (__off_t )tmp___19) {
            {
#line 1782
            status = sparse_dump_file(fd, st);
            }
#line 1783
            if ((unsigned int )status == 3U) {
              {
#line 1784
              status = dump_regular_file(fd, st);
              }
            }
          } else {
            {
#line 1787
            status = dump_regular_file(fd, st);
            }
          }
        } else {
          {
#line 1787
          status = dump_regular_file(fd, st);
          }
        }
      } else {
        {
#line 1787
        status = dump_regular_file(fd, st);
        }
      }
      {
#line 1792
      if ((unsigned int )status == 1U) {
#line 1792
        goto case_1;
      }
#line 1792
      if ((unsigned int )status == 0U) {
#line 1792
        goto case_1;
      }
#line 1796
      if ((unsigned int )status == 2U) {
#line 1796
        goto case_2;
      }
#line 1799
      if ((unsigned int )status == 3U) {
#line 1799
        goto case_3;
      }
#line 1789
      goto switch_break;
      case_1: /* CIL Label */ 
      case_0: /* CIL Label */ 
      {
#line 1793
      file_count_links(st);
      }
#line 1794
      goto switch_break;
      case_2: /* CIL Label */ 
#line 1797
      goto switch_break;
      case_3: /* CIL Label */ 
      {
#line 1800
      abort();
      }
      switch_break: /* CIL Label */ ;
      }
#line 1803
      ok = (_Bool )((unsigned int )status == 0U);
    }
#line 1806
    if (ok) {
#line 1808
      if (fd < 0) {
        {
#line 1810
        tmp___20 = __errno_location();
#line 1810
        *tmp___20 = - fd;
#line 1811
        ok = (_Bool)0;
        }
      } else
#line 1813
      if (fd == 0) {
#line 1815
        if (parentfd < 0) {
#line 1815
          if (! top_level) {
            {
#line 1817
            tmp___21 = __errno_location();
#line 1817
            *tmp___21 = - parentfd;
#line 1818
            ok = (_Bool)0;
            }
          } else {
            {
#line 1821
            tmp___22 = fstatat(parentfd, (char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& final_stat),
                               fstatat_flags);
#line 1821
            ok = (_Bool )(tmp___22 == 0);
            }
          }
        } else {
          {
#line 1821
          tmp___22 = fstatat(parentfd, (char const   */* __restrict  */)name, (struct stat */* __restrict  */)(& final_stat),
                             fstatat_flags);
#line 1821
          ok = (_Bool )(tmp___22 == 0);
          }
        }
      } else {
        {
#line 1824
        tmp___23 = fstat(fd, & final_stat);
#line 1824
        ok = (_Bool )(tmp___23 == 0);
        }
      }
#line 1826
      if (! ok) {
        {
#line 1827
        file_removed_diag(p, top_level, & stat_diag);
        }
      }
    }
#line 1830
    if (ok) {
      {
#line 1832
      tmp___27 = get_stat_ctime((struct stat  const  *)(& final_stat));
#line 1832
      tmp___28 = timespec_cmp((struct timespec )tmp___27, original_ctime);
      }
#line 1832
      if (tmp___28 != (int __attribute__((__pure__))  )0) {
#line 1832
        if (remove_files_option) {
#line 1832
          if (is_dir) {
#line 1832
            goto _L___4;
          } else {
#line 1832
            goto _L___3;
          }
        } else {
#line 1832
          goto _L___3;
        }
      } else
      _L___4: /* CIL Label */ 
#line 1832
      if (original_size < final_stat.st_size) {
        _L___3: /* CIL Label */ 
        {
#line 1838
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 1838
          if (warning_option & 16) {
            {
#line 1838
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1838
              if (error_hook) {
                {
#line 1838
                (*error_hook)();
                }
              }
              {
#line 1838
              tmp___24 = quotearg_colon(p);
#line 1838
              tmp___25 = gettext("%s: file changed as we read it");
#line 1838
              error(0, 0, (char const   *)tmp___25, tmp___24);
              }
#line 1838
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          }
#line 1838
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1841
        set_exit_status(1);
        }
      } else
#line 1843
      if ((unsigned int )atime_preserve_option == 1U) {
#line 1843
        if (fd) {
#line 1843
          if (is_dir) {
#line 1843
            goto _L___2;
          } else
#line 1843
          if (original_size != 0L) {
            _L___2: /* CIL Label */ 
            {
#line 1843
            tmp___26 = set_file_atime(fd, parentfd, name, st->atime);
            }
#line 1843
            if (tmp___26 != 0) {
              {
#line 1846
              utime_error(p);
              }
            }
          }
        }
      }
    }
    {
#line 1849
    tmp___29 = tar_stat_close(st);
#line 1849
    ok = (_Bool )((int )ok & (int )tmp___29);
    }
#line 1850
    if (ok) {
#line 1850
      if (remove_files_option) {
        {
#line 1851
        queue_deferred_unlink(p, is_dir);
        }
      }
    }
#line 1853
    return;
  } else
#line 1856
  if ((st->stat.st_mode & 61440U) == 40960U) {
    {
#line 1858
    st->link_name = areadlinkat_with_size(parentfd, name, (size_t )st->stat.st_size);
    }
#line 1859
    if (! st->link_name) {
      {
#line 1861
      tmp___30 = __errno_location();
      }
#line 1861
      if (*tmp___30 == 12) {
        {
#line 1862
        xalloc_die();
        }
      }
      {
#line 1863
      file_removed_diag(p, top_level, & readlink_diag);
      }
#line 1864
      return;
    }
    {
#line 1866
    transform_name(& st->link_name, 4);
#line 1867
    tmp___31 = strlen((char const   *)st->link_name);
    }
#line 1867
    if ((size_t )(100 - ((unsigned int )archive_format == 2U)) < tmp___31) {
      {
#line 1869
      write_long_link(st);
      }
    }
    {
#line 1871
    xattrs_selinux_get(parentfd, name, st, 0);
#line 1872
    xattrs_xattrs_get(parentfd, name, st, 0);
#line 1874
    block_ordinal = current_block_ordinal();
#line 1875
    st->stat.st_size = (__off_t )0;
#line 1876
    header = start_header(st);
    }
#line 1877
    if (! header) {
#line 1878
      return;
    }
    {
#line 1879
    tar_copy_str(header->header.linkname, (char const   *)st->link_name, (size_t )100);
#line 1880
    header->header.typeflag = (char )'2';
#line 1881
    finish_header(st, header, block_ordinal);
    }
#line 1884
    if (remove_files_option) {
      {
#line 1885
      queue_deferred_unlink(p, (_Bool)0);
      }
    }
    {
#line 1887
    file_count_links(st);
    }
#line 1888
    return;
  } else
#line 1891
  if ((st->stat.st_mode & 61440U) == 8192U) {
    {
#line 1893
    type = (char )'3';
#line 1894
    xattrs_acls_get(parentfd, name, st, 0, 1);
#line 1895
    xattrs_selinux_get(parentfd, name, st, 0);
#line 1896
    xattrs_xattrs_get(parentfd, name, st, 0);
    }
  } else
#line 1898
  if ((st->stat.st_mode & 61440U) == 24576U) {
    {
#line 1900
    type = (char )'4';
#line 1901
    xattrs_acls_get(parentfd, name, st, 0, 1);
#line 1902
    xattrs_selinux_get(parentfd, name, st, 0);
#line 1903
    xattrs_xattrs_get(parentfd, name, st, 0);
    }
  } else
#line 1905
  if ((st->stat.st_mode & 61440U) == 4096U) {
    {
#line 1907
    type = (char )'6';
#line 1908
    xattrs_acls_get(parentfd, name, st, 0, 1);
#line 1909
    xattrs_selinux_get(parentfd, name, st, 0);
#line 1910
    xattrs_xattrs_get(parentfd, name, st, 0);
    }
  } else
#line 1912
  if ((st->stat.st_mode & 61440U) == 49152U) {
    {
#line 1914
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1914
      if (warning_option & 32) {
        {
#line 1914
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 1914
          if (error_hook) {
            {
#line 1914
            (*error_hook)();
            }
          }
          {
#line 1914
          tmp___32 = quotearg_colon(p);
#line 1914
          tmp___33 = gettext("%s: socket ignored");
#line 1914
          error(0, 0, (char const   *)tmp___33, tmp___32);
          }
#line 1914
          goto while_break___6;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 1914
      goto while_break___5;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1916
    return;
  } else {
    {
#line 1926
    unknown_file_error(p);
    }
#line 1927
    return;
  }
#line 1930
  if ((unsigned int )archive_format == 1U) {
    {
#line 1932
    unknown_file_error(p);
    }
#line 1933
    return;
  }
  {
#line 1936
  block_ordinal = current_block_ordinal();
#line 1937
  st->stat.st_size = (__off_t )0;
#line 1938
  header = start_header(st);
  }
#line 1939
  if (! header) {
#line 1940
    return;
  }
#line 1941
  header->header.typeflag = type;
#line 1943
  if ((int )type != 54) {
    {
#line 1945
    tmp___36 = gnu_dev_major(st->stat.st_rdev);
#line 1945
    major_to_chars((int )tmp___36, header->header.devmajor, sizeof(header->header.devmajor));
#line 1947
    tmp___37 = gnu_dev_minor(st->stat.st_rdev);
#line 1947
    minor_to_chars((int )tmp___37, header->header.devminor, sizeof(header->header.devminor));
    }
  }
  {
#line 1951
  finish_header(st, header, block_ordinal);
  }
#line 1952
  if (remove_files_option) {
    {
#line 1953
    queue_deferred_unlink(p, (_Bool)0);
    }
  }
#line 1954
  return;
}
}
#line 1961 "/home/khheo/project/benchmark/tar-1.29/src/create.c"
void dump_file(struct tar_stat_info *parent , char const   *name , char const   *fullname ) 
{ 
  struct tar_stat_info st ;

  {
  {
#line 1966
  tar_stat_init(& st);
#line 1967
  st.parent = parent;
#line 1968
  dump_file0(& st, name, fullname);
  }
#line 1969
  if (parent) {
#line 1969
    if (listed_incremental_option) {
      {
#line 1970
      update_parent_directory(parent);
      }
    }
  }
  {
#line 1971
  tar_stat_destroy(& st);
  }
#line 1972
  return;
}
}
#line 957 "/usr/include/unistd.h"
extern int fsync(int __fd ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 432
enum access_mode access_mode ;
#line 528 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool now_verifying  ;
#line 532
void verify_volume(void) ;
#line 974
#pragma GCC diagnostic pop
#line 39 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static int diff_handle  ;
#line 42 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static char *diff_buffer  ;
#line 45 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
void diff_init(void) 
{ 
  void *ptr ;
  void *tmp ;

  {
  {
#line 49
  tmp = page_aligned_alloc(& ptr, record_size);
#line 49
  diff_buffer = (char *)tmp;
  }
#line 50
  if (listed_incremental_option) {
    {
#line 51
    read_directory_file();
    }
  }
#line 52
  return;
}
}
#line 56 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
void ( /* format attribute */  report_difference)(struct tar_stat_info *st , char const   *fmt 
                                                  , ...) 
{ 
  va_list ap ;
  char *tmp ;

  {
#line 59
  if (fmt) {
    {
#line 63
    tmp = quotearg_colon((char const   *)st->file_name);
#line 63
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"%s: ",
            tmp);
#line 64
    __builtin_va_start(ap, fmt);
#line 65
    vfprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)fmt,
             ap);
#line 66
    __builtin_va_end(ap);
#line 67
    fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 70
  set_exit_status(1);
  }
#line 71
  return;
}
}
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static int process_noop(size_t size  __attribute__((__unused__)) , char *data  __attribute__((__unused__)) ) 
{ 


  {
#line 78
  return (1);
}
}
#line 81 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static int process_rawdata(size_t bytes , char *buffer___1 ) 
{ 
  size_t status ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 84
  tmp = blocking_read(diff_handle, (void *)diff_buffer, bytes);
#line 84
  status = tmp;
  }
#line 86
  if (status != bytes) {
#line 88
    if (status == 0xffffffffffffffffUL) {
      {
#line 90
      read_error((char const   *)current_stat_info.file_name);
#line 91
      report_difference(& current_stat_info, (char const   *)((void *)0));
      }
    } else {
      {
#line 95
      tmp___0 = ngettext("Could only read %lu of %lu byte", "Could only read %lu of %lu bytes",
                         bytes);
#line 95
      report_difference(& current_stat_info, (char const   *)tmp___0, status, bytes);
      }
    }
#line 101
    return (0);
  }
  {
#line 104
  tmp___2 = memcmp((void const   *)buffer___1, (void const   *)diff_buffer, bytes);
  }
#line 104
  if (tmp___2) {
    {
#line 106
    tmp___1 = gettext("Contents differ");
#line 106
    report_difference(& current_stat_info, (char const   *)tmp___1);
    }
#line 107
    return (0);
  }
#line 110
  return (1);
}
}
#line 119 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void read_and_process(struct tar_stat_info *st , int (*processor)(size_t  ,
                                                                         char * ) ) 
{ 
  union block *data_block ;
  size_t data_size ;
  off_t size ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 124
  size = st->stat.st_size;
#line 126
  mv_begin_read(st);
  }
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 127
    if (! size) {
#line 127
      goto while_break;
    }
    {
#line 129
    data_block = find_next_block();
    }
#line 130
    if (! data_block) {
      {
#line 132
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 132
        if (error_hook) {
          {
#line 132
          (*error_hook)();
          }
        }
        {
#line 132
        tmp = gettext("Unexpected EOF in archive");
#line 132
        error(0, 0, (char const   *)tmp);
#line 132
        exit_status = 2;
        }
#line 132
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 133
      return;
    }
    {
#line 136
    data_size = available_space_after(data_block);
    }
#line 137
    if (data_size > (size_t )size) {
#line 138
      data_size = (size_t )size;
    }
    {
#line 139
    tmp___0 = (*processor)(data_size, data_block->buffer);
    }
#line 139
    if (! tmp___0) {
#line 140
      processor = & process_noop;
    }
    {
#line 141
    set_next_block_after((union block *)((data_block->buffer + data_size) - 1));
#line 143
    size = (off_t )((size_t )size - data_size);
#line 144
    mv_size_left(size);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 146
  mv_end();
  }
#line 147
  return;
}
}
#line 152 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static int get_stat_data(char const   *file_name___0 , struct stat *stat_data ) 
{ 
  int status ;
  int tmp ;
  int *tmp___0 ;

  {
  {
#line 155
  tmp = deref_stat(file_name___0, stat_data);
#line 155
  status = tmp;
  }
#line 157
  if (status != 0) {
    {
#line 159
    tmp___0 = __errno_location();
    }
#line 159
    if (*tmp___0 == 2) {
      {
#line 160
      stat_warn(file_name___0);
      }
    } else {
      {
#line 162
      stat_error(file_name___0);
      }
    }
    {
#line 163
    report_difference(& current_stat_info, (char const   *)((void *)0));
    }
#line 164
    return (0);
  }
#line 167
  return (1);
}
}
#line 171 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_dir(void) 
{ 
  struct stat stat_data ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 176
  tmp = get_stat_data((char const   *)current_stat_info.file_name, & stat_data);
  }
#line 176
  if (! tmp) {
#line 177
    return;
  }
#line 179
  if (! ((stat_data.st_mode & 61440U) == 16384U)) {
    {
#line 180
    tmp___0 = gettext("File type differs");
#line 180
    report_difference(& current_stat_info, (char const   *)tmp___0);
    }
  } else
#line 181
  if ((current_stat_info.stat.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (stat_data.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
    {
#line 183
    tmp___1 = gettext("Mode differs");
#line 183
    report_difference(& current_stat_info, (char const   *)tmp___1);
    }
  }
#line 184
  return;
}
}
#line 186 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_file(void) 
{ 
  char const   *file_name___0 ;
  struct stat stat_data ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  struct timespec  __attribute__((__pure__)) tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int status ;
  struct timespec atime ;
  struct timespec  __attribute__((__pure__)) tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  {
#line 189
  file_name___0 = (char const   *)current_stat_info.file_name;
#line 192
  tmp___11 = get_stat_data(file_name___0, & stat_data);
  }
#line 192
  if (tmp___11) {
#line 194
    if (! ((stat_data.st_mode & 61440U) == 32768U)) {
      {
#line 196
      tmp = gettext("File type differs");
#line 196
      report_difference(& current_stat_info, (char const   *)tmp);
#line 197
      skip_member();
      }
    } else {
#line 201
      if ((current_stat_info.stat.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (stat_data.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
        {
#line 203
        tmp___0 = gettext("Mode differs");
#line 203
        report_difference(& current_stat_info, (char const   *)tmp___0);
        }
      }
      {
#line 205
      tmp___2 = sys_compare_uid(& stat_data, & current_stat_info.stat);
      }
#line 205
      if (! tmp___2) {
        {
#line 206
        tmp___1 = gettext("Uid differs");
#line 206
        report_difference(& current_stat_info, (char const   *)tmp___1);
        }
      }
      {
#line 207
      tmp___4 = sys_compare_gid(& stat_data, & current_stat_info.stat);
      }
#line 207
      if (! tmp___4) {
        {
#line 208
        tmp___3 = gettext("Gid differs");
#line 208
        report_difference(& current_stat_info, (char const   *)tmp___3);
        }
      }
      {
#line 210
      tmp___6 = get_stat_mtime((struct stat  const  *)(& stat_data));
#line 210
      tmp___7 = tar_timespec_cmp((struct timespec )tmp___6, current_stat_info.mtime);
      }
#line 210
      if (tmp___7) {
        {
#line 212
        tmp___5 = gettext("Mod time differs");
#line 212
        report_difference(& current_stat_info, (char const   *)tmp___5);
        }
      }
#line 213
      if ((int )current_header->header.typeflag != 83) {
#line 213
        if (stat_data.st_size != current_stat_info.stat.st_size) {
          {
#line 216
          tmp___8 = gettext("Size differs");
#line 216
          report_difference(& current_stat_info, (char const   *)tmp___8);
#line 217
          skip_member();
          }
        } else {
#line 213
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 221
        diff_handle = openat(chdir_fd, file_name___0, open_read_flags);
        }
#line 223
        if (diff_handle < 0) {
          {
#line 225
          open_error(file_name___0);
#line 226
          skip_member();
#line 227
          report_difference(& current_stat_info, (char const   *)((void *)0));
          }
        } else {
#line 233
          if (current_stat_info.is_sparse) {
            {
#line 234
            sparse_diff_file(diff_handle, & current_stat_info);
            }
          } else {
            {
#line 236
            read_and_process(& current_stat_info, & process_rawdata);
            }
          }
#line 238
          if ((unsigned int )atime_preserve_option == 1U) {
#line 238
            if (stat_data.st_size != 0L) {
              {
#line 241
              tmp___9 = get_stat_atime((struct stat  const  *)(& stat_data));
#line 241
              atime = tmp___9;
#line 242
              tmp___10 = set_file_atime(diff_handle, chdir_fd, file_name___0, atime);
              }
#line 242
              if (tmp___10 != 0) {
                {
#line 244
                utime_error(file_name___0);
                }
              }
            }
          }
          {
#line 247
          status = close(diff_handle);
          }
#line 248
          if (status != 0) {
            {
#line 249
            close_error(file_name___0);
            }
          }
        }
      }
    }
  } else {
    {
#line 193
    skip_member();
    }
  }
#line 253
  return;
}
}
#line 255 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_link(void) 
{ 
  struct stat file_data ;
  struct stat link_data ;
  char const   *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  {
#line 261
  tmp___1 = get_stat_data((char const   *)current_stat_info.file_name, & file_data);
  }
#line 261
  if (tmp___1) {
    {
#line 261
    tmp___2 = get_stat_data((char const   *)current_stat_info.link_name, & link_data);
    }
#line 261
    if (tmp___2) {
      {
#line 261
      tmp___3 = sys_compare_links(& file_data, & link_data);
      }
#line 261
      if (! tmp___3) {
        {
#line 264
        tmp = quote((char const   *)current_stat_info.link_name);
#line 264
        tmp___0 = gettext("Not linked to %s");
#line 264
        report_difference(& current_stat_info, (char const   *)tmp___0, tmp);
        }
      }
    }
  }
#line 267
  return;
}
}
#line 270 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_symlink(void) 
{ 
  char buf[1024] ;
  size_t len ;
  size_t tmp ;
  char *linkbuf ;
  void *tmp___0 ;
  char *tmp___1 ;
  ssize_t status ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
  {
#line 274
  tmp = strlen((char const   *)current_stat_info.link_name);
#line 274
  len = tmp;
  }
#line 275
  if (len < sizeof(buf)) {
#line 275
    tmp___1 = buf;
  } else {
    {
#line 275
    tmp___0 = xmalloc(len + 1UL);
#line 275
    tmp___1 = (char *)tmp___0;
    }
  }
  {
#line 275
  linkbuf = tmp___1;
#line 277
  tmp___2 = readlinkat(chdir_fd, (char const   */* __restrict  */)current_stat_info.file_name,
                       (char */* __restrict  */)linkbuf, len + 1UL);
#line 277
  status = tmp___2;
  }
#line 280
  if (status < 0L) {
    {
#line 282
    tmp___3 = __errno_location();
    }
#line 282
    if (*tmp___3 == 2) {
      {
#line 283
      readlink_warn((char const   *)current_stat_info.file_name);
      }
    } else {
      {
#line 285
      readlink_error((char const   *)current_stat_info.file_name);
      }
    }
    {
#line 286
    report_difference(& current_stat_info, (char const   *)((void *)0));
    }
  } else
#line 288
  if ((size_t )status != len) {
    {
#line 290
    tmp___4 = gettext("Symlink differs");
#line 290
    report_difference(& current_stat_info, (char const   *)tmp___4);
    }
  } else {
    {
#line 288
    tmp___5 = memcmp((void const   *)current_stat_info.link_name, (void const   *)linkbuf,
                     len);
    }
#line 288
    if (tmp___5 != 0) {
      {
#line 290
      tmp___4 = gettext("Symlink differs");
#line 290
      report_difference(& current_stat_info, (char const   *)tmp___4);
      }
    }
  }
#line 292
  if ((unsigned long )linkbuf != (unsigned long )(buf)) {
    {
#line 293
    free((void *)linkbuf);
    }
  }
#line 294
  return;
}
}
#line 297 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_special(void) 
{ 
  struct stat stat_data ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 304
  tmp = get_stat_data((char const   *)current_stat_info.file_name, & stat_data);
  }
#line 304
  if (! tmp) {
#line 305
    return;
  }
#line 307
  if ((int )current_header->header.typeflag == 51) {
#line 307
    tmp___2 = ! ((stat_data.st_mode & 61440U) == 8192U);
  } else {
#line 307
    if ((int )current_header->header.typeflag == 52) {
#line 307
      tmp___1 = ! ((stat_data.st_mode & 61440U) == 24576U);
    } else {
#line 307
      tmp___1 = ! ((stat_data.st_mode & 61440U) == 4096U);
    }
#line 307
    tmp___2 = tmp___1;
  }
#line 307
  if (tmp___2) {
    {
#line 314
    tmp___0 = gettext("File type differs");
#line 314
    report_difference(& current_stat_info, (char const   *)tmp___0);
    }
#line 315
    return;
  }
#line 318
  if ((int )current_header->header.typeflag == 51) {
#line 318
    goto _L;
  } else
#line 318
  if ((int )current_header->header.typeflag == 52) {
    _L: /* CIL Label */ 
#line 318
    if (current_stat_info.stat.st_rdev != stat_data.st_rdev) {
      {
#line 322
      tmp___3 = gettext("Device number differs");
#line 322
      report_difference(& current_stat_info, (char const   *)tmp___3);
      }
#line 323
      return;
    }
  }
#line 326
  if ((current_stat_info.stat.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)))))) != (stat_data.st_mode & (unsigned int )(3584 | (((64 | (64 >> 3)) | ((64 >> 3) >> 3)) | (((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))))))) {
    {
#line 328
    tmp___4 = gettext("Mode differs");
#line 328
    report_difference(& current_stat_info, (char const   *)tmp___4);
    }
  }
#line 329
  return;
}
}
#line 331 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static int dumpdir_cmp(char const   *a , char const   *b ) 
{ 
  size_t len ;
  char *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 336
  while (1) {
    while_continue: /* CIL Label */ ;
#line 336
    if (! *a) {
#line 336
      goto while_break;
    }
    {
#line 340
    if ((int const   )*a == 78) {
#line 340
      goto case_78;
    }
#line 340
    if ((int const   )*a == 89) {
#line 340
      goto case_78;
    }
#line 350
    if ((int const   )*a == 68) {
#line 350
      goto case_68;
    }
#line 360
    if ((int const   )*a == 88) {
#line 360
      goto case_88;
    }
#line 360
    if ((int const   )*a == 84) {
#line 360
      goto case_88;
    }
#line 360
    if ((int const   )*a == 82) {
#line 360
      goto case_88;
    }
#line 337
    goto switch_break;
    case_78: /* CIL Label */ 
    case_89: /* CIL Label */ 
    {
#line 341
    tmp = strchr("YN", (int )*b);
    }
#line 341
    if (! tmp) {
#line 342
      return (1);
    }
    {
#line 343
    tmp___0 = strcmp(a + 1, b + 1);
    }
#line 343
    if (tmp___0) {
#line 344
      return (1);
    }
    {
#line 345
    tmp___1 = strlen(a);
#line 345
    len = tmp___1 + 1UL;
#line 346
    a += len;
#line 347
    b += len;
    }
#line 348
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 351
    tmp___2 = strcmp(a, b);
    }
#line 351
    if (tmp___2) {
#line 352
      return (1);
    }
    {
#line 353
    tmp___3 = strlen(a);
#line 353
    len = tmp___3 + 1UL;
#line 354
    a += len;
#line 355
    b += len;
    }
#line 356
    goto switch_break;
    case_88: /* CIL Label */ 
    case_84: /* CIL Label */ 
    case_82: /* CIL Label */ 
#line 361
    return ((int )*b);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 363
  return ((int )*b);
}
}
#line 366 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_dumpdir(struct tar_stat_info *dir ) 
{ 
  char const   *dumpdir_buffer ;
  void (*diag)(char const   * ) ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  struct directory *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
#line 371
  if (dir->fd == 0) {
    {
#line 373
    diag = (void (*)(char const   * ))((void *)0);
#line 374
    tmp = subfile_open((struct tar_stat_info  const  *)dir->parent, (char const   *)dir->orig_file_name,
                       open_read_flags);
#line 374
    fd = tmp;
    }
#line 375
    if (fd < 0) {
#line 376
      diag = & open_diag;
    } else {
      {
#line 377
      tmp___0 = fstat(fd, & dir->stat);
      }
#line 377
      if (tmp___0) {
        {
#line 379
        diag = & stat_diag;
#line 380
        close(fd);
        }
      } else {
#line 383
        dir->fd = fd;
      }
    }
#line 384
    if (diag) {
      {
#line 386
      file_removed_diag((char const   *)dir->orig_file_name, (_Bool)0, diag);
      }
#line 387
      return;
    }
  }
  {
#line 390
  tmp___1 = scan_directory(dir);
#line 390
  dumpdir_buffer = directory_contents(tmp___1);
  }
#line 392
  if (dumpdir_buffer) {
    {
#line 394
    tmp___3 = dumpdir_cmp((char const   *)dir->dumpdir, dumpdir_buffer);
    }
#line 394
    if (tmp___3) {
      {
#line 395
      tmp___2 = gettext("Contents differ");
#line 395
      report_difference(dir, (char const   *)tmp___2);
      }
    }
  } else {
    {
#line 398
    read_and_process(dir, & process_noop);
    }
  }
#line 399
  return;
}
}
#line 401 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
static void diff_multivol(void) 
{ 
  struct stat stat_data ;
  int fd ;
  int status ;
  off_t offset ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;

  {
#line 408
  if (current_stat_info.had_trailing_slash) {
    {
#line 410
    diff_dir();
    }
#line 411
    return;
  }
  {
#line 414
  tmp = get_stat_data((char const   *)current_stat_info.file_name, & stat_data);
  }
#line 414
  if (! tmp) {
#line 415
    return;
  }
#line 417
  if (! ((stat_data.st_mode & 61440U) == 32768U)) {
    {
#line 419
    tmp___0 = gettext("File type differs");
#line 419
    report_difference(& current_stat_info, (char const   *)tmp___0);
#line 420
    skip_member();
    }
#line 421
    return;
  }
  {
#line 424
  offset = off_from_header((char const   *)(current_header->oldgnu_header.offset),
                           sizeof(current_header->oldgnu_header.offset));
  }
#line 425
  if (offset < 0L) {
    {
#line 429
    tmp___1 = gettext("Size differs");
#line 429
    report_difference(& current_stat_info, (char const   *)tmp___1);
#line 430
    skip_member();
    }
#line 431
    return;
  } else {
#line 425
    if (-1L - (((1L << (sizeof(current_stat_info.stat.st_size) * 8UL - 2UL)) - 1L) * 2L + 1L) < 0L) {
#line 425
      if (offset < 0L) {
#line 425
        tmp___2 = current_stat_info.stat.st_size < (-1L - (((1L << (sizeof(current_stat_info.stat.st_size) * 8UL - 2UL)) - 1L) * 2L + 1L)) - offset;
      } else {
#line 425
        tmp___2 = (((1L << (sizeof(current_stat_info.stat.st_size) * 8UL - 2UL)) - 1L) * 2L + 1L) - offset < current_stat_info.stat.st_size;
      }
#line 425
      tmp___5 = tmp___2;
    } else {
#line 425
      if (current_stat_info.stat.st_size < 0L) {
#line 425
        tmp___4 = offset <= current_stat_info.stat.st_size + offset;
      } else {
#line 425
        if (offset < 0L) {
#line 425
          tmp___3 = current_stat_info.stat.st_size <= current_stat_info.stat.st_size + offset;
        } else {
#line 425
          tmp___3 = current_stat_info.stat.st_size + offset < offset;
        }
#line 425
        tmp___4 = tmp___3;
      }
#line 425
      tmp___5 = tmp___4;
    }
#line 425
    if (tmp___5) {
      {
#line 429
      tmp___1 = gettext("Size differs");
#line 429
      report_difference(& current_stat_info, (char const   *)tmp___1);
#line 430
      skip_member();
      }
#line 431
      return;
    } else
#line 425
    if (stat_data.st_size != current_stat_info.stat.st_size + offset) {
      {
#line 429
      tmp___1 = gettext("Size differs");
#line 429
      report_difference(& current_stat_info, (char const   *)tmp___1);
#line 430
      skip_member();
      }
#line 431
      return;
    }
  }
  {
#line 435
  fd = openat(chdir_fd, (char const   *)current_stat_info.file_name, open_read_flags);
  }
#line 437
  if (fd < 0) {
    {
#line 439
    open_error((char const   *)current_stat_info.file_name);
#line 440
    report_difference(& current_stat_info, (char const   *)((void *)0));
#line 441
    skip_member();
    }
#line 442
    return;
  }
  {
#line 445
  tmp___6 = lseek(fd, offset, 0);
  }
#line 445
  if (tmp___6 < 0L) {
    {
#line 447
    seek_error_details((char const   *)current_stat_info.file_name, offset);
#line 448
    report_difference(& current_stat_info, (char const   *)((void *)0));
    }
  } else {
    {
#line 451
    read_and_process(& current_stat_info, & process_rawdata);
    }
  }
  {
#line 453
  status = close(fd);
  }
#line 454
  if (status != 0) {
    {
#line 455
    close_error((char const   *)current_stat_info.file_name);
    }
  }
#line 456
  return;
}
}
#line 459 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
void diff_archive(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;

  {
  {
#line 463
  set_next_block_after(current_header);
  }
#line 467
  if (verbose_option) {
#line 469
    if (now_verifying) {
      {
#line 470
      tmp = gettext("Verify ");
#line 470
      fprintf((FILE */* __restrict  */)stdlis, (char const   */* __restrict  */)tmp);
      }
    }
    {
#line 471
    print_header(& current_stat_info, current_header, (off_t )-1);
    }
  }
  {
#line 485
  if ((int )current_header->header.typeflag == 55) {
#line 485
    goto case_55;
  }
#line 485
  if ((int )current_header->header.typeflag == 83) {
#line 485
    goto case_55;
  }
#line 485
  if ((int )current_header->header.typeflag == 48) {
#line 485
    goto case_55;
  }
#line 485
  if ((int )current_header->header.typeflag == 0) {
#line 485
    goto case_55;
  }
#line 495
  if ((int )current_header->header.typeflag == 49) {
#line 495
    goto case_49;
  }
#line 500
  if ((int )current_header->header.typeflag == 50) {
#line 500
    goto case_50;
  }
#line 507
  if ((int )current_header->header.typeflag == 54) {
#line 507
    goto case_54;
  }
#line 507
  if ((int )current_header->header.typeflag == 52) {
#line 507
    goto case_54;
  }
#line 507
  if ((int )current_header->header.typeflag == 51) {
#line 507
    goto case_54;
  }
#line 512
  if ((int )current_header->header.typeflag == 53) {
#line 512
    goto case_53;
  }
#line 512
  if ((int )current_header->header.typeflag == 68) {
#line 512
    goto case_53;
  }
#line 518
  if ((int )current_header->header.typeflag == 86) {
#line 518
    goto case_86;
  }
#line 521
  if ((int )current_header->header.typeflag == 77) {
#line 521
    goto case_77;
  }
#line 476
  goto switch_default;
  switch_default: /* CIL Label */ 
  {
#line 477
  while (1) {
    while_continue: /* CIL Label */ ;
#line 477
    if (error_hook) {
      {
#line 477
      (*error_hook)();
      }
    }
    {
#line 477
    tmp___0 = quotearg_colon((char const   *)current_stat_info.file_name);
#line 477
    tmp___1 = gettext("%s: Unknown file type \'%c\', diffed as normal file");
#line 477
    error(0, 0, (char const   *)tmp___1, tmp___0, (int )current_header->header.typeflag);
#line 477
    exit_status = 2;
    }
#line 477
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  case_55: /* CIL Label */ 
  case_83: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 489
  if (current_stat_info.had_trailing_slash) {
    {
#line 490
    diff_dir();
    }
  } else {
    {
#line 492
    diff_file();
    }
  }
#line 493
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 496
  diff_link();
  }
#line 497
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 501
  diff_symlink();
  }
#line 502
  goto switch_break;
  case_54: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  {
#line 508
  diff_special();
  }
#line 509
  goto switch_break;
  case_53: /* CIL Label */ 
  case_68: /* CIL Label */ 
  {
#line 513
  tmp___2 = is_dumpdir(& current_stat_info);
  }
#line 513
  if (tmp___2) {
    {
#line 514
    diff_dumpdir(& current_stat_info);
    }
  }
  {
#line 515
  diff_dir();
  }
#line 516
  goto switch_break;
  case_86: /* CIL Label */ 
#line 519
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 522
  diff_multivol();
  }
  switch_break: /* CIL Label */ ;
  }
#line 524
  return;
}
}
#line 526 "/home/khheo/project/benchmark/tar-1.29/src/compare.c"
void verify_volume(void) 
{ 
  int may_fail ;
  char *tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;
  char *tmp___3 ;
  struct mtop operation ;
  int status ;
  off_t tmp___4 ;
  __off_t tmp___5 ;
  off_t tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  enum read_header status___0 ;
  enum read_header tmp___12 ;
  int counter ;
  char *tmp___13 ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  off_t tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;

  {
  {
#line 529
  may_fail = 0;
#line 530
  tmp___0 = removed_prefixes_p();
  }
#line 530
  if (tmp___0) {
    {
#line 532
    while (1) {
      while_continue: /* CIL Label */ ;
#line 532
      if (error_hook) {
        {
#line 532
        (*error_hook)();
        }
      }
      {
#line 532
      tmp = gettext("Archive contains file names with leading prefixes removed.");
#line 532
      error(0, 0, (char const   *)tmp);
      }
#line 532
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 534
    may_fail = 1;
  }
  {
#line 536
  tmp___2 = transform_program_p();
  }
#line 536
  if (tmp___2) {
    {
#line 538
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 538
      if (error_hook) {
        {
#line 538
        (*error_hook)();
        }
      }
      {
#line 538
      tmp___1 = gettext("Archive contains transformed file names.");
#line 538
      error(0, 0, (char const   *)tmp___1);
      }
#line 538
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 540
    may_fail = 1;
  }
#line 542
  if (may_fail) {
    {
#line 543
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 543
      if (error_hook) {
        {
#line 543
        (*error_hook)();
        }
      }
      {
#line 543
      tmp___3 = gettext("Verification may fail to locate original files.");
#line 543
      error(0, 0, (char const   *)tmp___3);
      }
#line 543
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 546
  clear_directory_table();
  }
#line 548
  if (! diff_buffer) {
    {
#line 549
    diff_init();
    }
  }
  {
#line 562
  fsync(archive);
#line 565
  ioctl(archive, (unsigned long )((unsigned int )(2 << 8) | 75U));
#line 573
  operation.mt_op = (short)2;
#line 574
  operation.mt_count = 1;
  }
#line 575
  if (archive >= 1 << 30) {
    {
#line 575
    tmp___10 = rmt_ioctl__(archive - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                           (char *)(& operation));
#line 575
    status = tmp___10;
    }
  } else {
    {
#line 575
    tmp___11 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
                     (char *)(& operation));
#line 575
    status = tmp___11;
    }
  }
#line 575
  if (status < 0) {
    {
#line 577
    tmp___7 = __errno_location();
    }
#line 577
    if (*tmp___7 != 5) {
#line 577
      goto _L;
    } else {
#line 577
      if (archive >= 1 << 30) {
        {
#line 577
        tmp___8 = rmt_ioctl__(archive - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                              (char *)(& operation));
#line 577
        status = tmp___8;
        }
      } else {
        {
#line 577
        tmp___9 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
                        (char *)(& operation));
#line 577
        status = tmp___9;
        }
      }
#line 577
      if (status < 0) {
        _L: /* CIL Label */ 
#line 582
        if (archive >= 1 << 30) {
          {
#line 582
          tmp___4 = rmt_lseek__(archive - (1 << 30), (off_t )0, 0);
#line 582
          tmp___6 = tmp___4;
          }
        } else {
          {
#line 582
          tmp___5 = lseek(archive, (off_t )0, 0);
#line 582
          tmp___6 = tmp___5;
          }
        }
#line 582
        if (tmp___6 != 0L) {
          {
#line 585
          seek_warn(*(archive_name_array + 0));
          }
#line 586
          return;
        }
      }
    }
  }
  {
#line 594
  access_mode = (enum access_mode )0;
#line 595
  now_verifying = (_Bool)1;
#line 597
  flush_read();
  }
  {
#line 598
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 600
    tmp___12 = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
#line 600
    status___0 = tmp___12;
    }
#line 604
    if ((unsigned int )status___0 == 5U) {
#line 606
      counter = 0;
      {
#line 608
      while (1) {
        while_continue___3: /* CIL Label */ ;
        {
#line 610
        counter ++;
#line 611
        set_next_block_after(current_header);
#line 612
        status___0 = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
        }
#line 608
        if (! ((unsigned int )status___0 == 5U)) {
#line 608
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 617
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 617
        if (error_hook) {
          {
#line 617
          (*error_hook)();
          }
        }
        {
#line 617
        tmp___13 = ngettext("VERIFY FAILURE: %d invalid header detected", "VERIFY FAILURE: %d invalid headers detected",
                            (unsigned long )counter);
#line 617
        error(0, 0, (char const   *)tmp___13, counter);
#line 617
        exit_status = 2;
        }
#line 617
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 622
    if ((unsigned int )status___0 == 4U) {
#line 623
      goto while_break___2;
    }
#line 624
    if ((unsigned int )status___0 == 3U) {
      {
#line 626
      set_next_block_after(current_header);
      }
#line 627
      if (! ignore_zeros_option) {
        {
#line 631
        status___0 = read_header(& current_header, & current_stat_info, (enum read_header_mode )0);
        }
#line 633
        if ((unsigned int )status___0 == 3U) {
#line 634
          goto while_break___2;
        }
        {
#line 635
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 635
          if (warning_option & 1) {
            {
#line 635
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 635
              if (error_hook) {
                {
#line 635
                (*error_hook)();
                }
              }
              {
#line 635
              tmp___14 = current_block_ordinal();
#line 635
              tmp___15 = umaxtostr((uintmax_t )tmp___14, buf);
#line 635
              tmp___16 = gettext("A lone zero block at %s");
#line 635
              error(0, 0, (char const   *)tmp___16, tmp___15);
              }
#line 635
              goto while_break___6;
            }
            while_break___6: /* CIL Label */ ;
            }
          }
#line 635
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
#line 639
      goto while_continue___2;
    }
    {
#line 642
    decode_header(current_header, & current_stat_info, & current_format, 1);
#line 643
    diff_archive();
#line 644
    tar_stat_destroy(& current_stat_info);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 647
  access_mode = (enum access_mode )1;
#line 648
  now_verifying = (_Bool)0;
#line 649
  return;
}
}
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 471
int format_total_stats(FILE *fp , char const   * const  *formats , int eor , int eol ) ;
#line 902
void checkpoint_run(_Bool do_write ) ;
#line 974
#pragma GCC diagnostic pop
#line 50 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static unsigned int checkpoint  ;
#line 53 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static struct checkpoint_action *checkpoint_action  ;
#line 53 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static struct checkpoint_action *checkpoint_action_tail  ;
#line 55 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static struct checkpoint_action *alloc_action(enum checkpoint_opcode opcode ) 
{ 
  struct checkpoint_action *p ;
  void *tmp ;

  {
  {
#line 58
  tmp = xzalloc(sizeof(*p));
#line 58
  p = (struct checkpoint_action *)tmp;
  }
#line 59
  if (checkpoint_action_tail) {
#line 60
    checkpoint_action_tail->next = p;
  } else {
#line 62
    checkpoint_action = p;
  }
#line 63
  checkpoint_action_tail = p;
#line 64
  p->opcode = opcode;
#line 65
  return (p);
}
}
#line 68 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static char *copy_string_unquote(char const   *str ) 
{ 
  char *output ;
  char *tmp ;
  size_t len ;
  size_t tmp___0 ;

  {
  {
#line 71
  tmp = xstrdup(str);
#line 71
  output = tmp;
#line 72
  tmp___0 = strlen((char const   *)output);
#line 72
  len = tmp___0;
  }
#line 73
  if ((int )*output == 34) {
#line 73
    goto _L;
  } else
#line 73
  if ((int )*output == 39) {
    _L: /* CIL Label */ 
#line 73
    if ((int )*(output + (len - 1UL)) == (int )*output) {
      {
#line 76
      memmove((void *)output, (void const   *)(output + 1), len - 2UL);
#line 77
      *(output + (len - 2UL)) = (char)0;
      }
    }
  }
  {
#line 79
  unquote_string(output);
  }
#line 80
  return (output);
}
}
#line 83 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
void checkpoint_compile_action(char const   *str ) 
{ 
  struct checkpoint_action *act ;
  char *p ;
  time_t n ;
  unsigned long tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 88
  tmp___9 = strcmp(str, ".");
  }
#line 88
  if (tmp___9 == 0) {
    {
#line 89
    alloc_action((enum checkpoint_opcode )0);
    }
  } else {
    {
#line 88
    tmp___10 = strcmp(str, "dot");
    }
#line 88
    if (tmp___10 == 0) {
      {
#line 89
      alloc_action((enum checkpoint_opcode )0);
      }
    } else {
      {
#line 90
      tmp___8 = strcmp(str, "bell");
      }
#line 90
      if (tmp___8 == 0) {
        {
#line 91
        alloc_action((enum checkpoint_opcode )1);
        }
      } else {
        {
#line 92
        tmp___7 = strcmp(str, "echo");
        }
#line 92
        if (tmp___7 == 0) {
          {
#line 93
          alloc_action((enum checkpoint_opcode )2);
          }
        } else {
          {
#line 94
          tmp___6 = strncmp(str, "echo=", (size_t )5);
          }
#line 94
          if (tmp___6 == 0) {
            {
#line 96
            act = alloc_action((enum checkpoint_opcode )2);
#line 97
            act->v.command = copy_string_unquote(str + 5);
            }
          } else {
            {
#line 99
            tmp___5 = strncmp(str, "exec=", (size_t )5);
            }
#line 99
            if (tmp___5 == 0) {
              {
#line 101
              act = alloc_action((enum checkpoint_opcode )5);
#line 102
              act->v.command = copy_string_unquote(str + 5);
              }
            } else {
              {
#line 104
              tmp___4 = strncmp(str, "ttyout=", (size_t )7);
              }
#line 104
              if (tmp___4 == 0) {
                {
#line 106
                act = alloc_action((enum checkpoint_opcode )3);
#line 107
                act->v.command = copy_string_unquote(str + 7);
                }
              } else {
                {
#line 109
                tmp___3 = strncmp(str, "sleep=", (size_t )6);
                }
#line 109
                if (tmp___3 == 0) {
                  {
#line 112
                  tmp = strtoul((char const   */* __restrict  */)(str + 6), (char **/* __restrict  */)(& p),
                                10);
#line 112
                  n = (time_t )tmp;
                  }
#line 113
                  if (*p) {
                    {
#line 114
                    while (1) {
                      while_continue: /* CIL Label */ ;
#line 114
                      if (error_hook) {
                        {
#line 114
                        (*error_hook)();
                        }
                      }
                      {
#line 114
                      tmp___0 = gettext("%s: not a valid timeout");
#line 114
                      error(0, 0, (char const   *)tmp___0, str);
#line 114
                      fatal_exit();
                      }
#line 114
                      goto while_break;
                    }
                    while_break: /* CIL Label */ ;
                    }
                  }
                  {
#line 115
                  act = alloc_action((enum checkpoint_opcode )4);
#line 116
                  act->v.time = n;
                  }
                } else {
                  {
#line 118
                  tmp___2 = strcmp(str, "totals");
                  }
#line 118
                  if (tmp___2 == 0) {
                    {
#line 119
                    alloc_action((enum checkpoint_opcode )6);
                    }
                  } else {
                    {
#line 121
                    while (1) {
                      while_continue___0: /* CIL Label */ ;
#line 121
                      if (error_hook) {
                        {
#line 121
                        (*error_hook)();
                        }
                      }
                      {
#line 121
                      tmp___1 = gettext("%s: unknown checkpoint action");
#line 121
                      error(0, 0, (char const   *)tmp___1, str);
#line 121
                      fatal_exit();
                      }
#line 121
                      goto while_break___0;
                    }
                    while_break___0: /* CIL Label */ ;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 122
  return;
}
}
#line 124 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
void checkpoint_finish_compile(void) 
{ 


  {
#line 127
  if (checkpoint_option) {
#line 129
    if (! checkpoint_action) {
      {
#line 131
      checkpoint_compile_action("echo");
      }
    }
  } else
#line 133
  if (checkpoint_action) {
#line 135
    checkpoint_option = 10U;
  }
#line 136
  return;
}
}
#line 138 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static char const   *checkpoint_total_format[3]  = {      "R",      "W",      "D"};
#line 144 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static long getwidth(FILE *fp ) 
{ 
  char const   *columns ;
  struct winsize ws ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  long col ;
  long tmp___2 ;

  {
  {
#line 151
  tmp = fileno(fp);
#line 151
  tmp___0 = ioctl(tmp, 21523UL, & ws);
  }
#line 151
  if (tmp___0 == 0) {
#line 151
    if (0 < (int )ws.ws_col) {
#line 152
      return ((long )ws.ws_col);
    }
  }
  {
#line 155
  tmp___1 = getenv("COLUMNS");
#line 155
  columns = (char const   *)tmp___1;
  }
#line 156
  if (columns) {
    {
#line 158
    tmp___2 = strtol((char const   */* __restrict  */)columns, (char **/* __restrict  */)((void *)0),
                     10);
#line 158
    col = tmp___2;
    }
#line 159
    if (0L < col) {
#line 160
      return (col);
    }
  }
#line 163
  return (80L);
}
}
#line 166 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static char *getarg(char const   *input , char const   **endp , char **argbuf___0 ,
                    size_t *arglen___0 ) 
{ 
  char *p ;
  char *tmp ;
  size_t n ;
  void *tmp___0 ;

  {
#line 169
  if ((int const   )*(input + 0) == 123) {
    {
#line 171
    tmp = strchr(input + 1, '}');
#line 171
    p = tmp;
    }
#line 172
    if (p) {
#line 174
      n = (size_t )(p - (char *)input);
#line 175
      if (n > *arglen___0) {
        {
#line 177
        *arglen___0 = n;
#line 178
        tmp___0 = xrealloc((void *)*argbuf___0, *arglen___0);
#line 178
        *argbuf___0 = (char *)tmp___0;
        }
      }
      {
#line 180
      n --;
#line 181
      memcpy((void */* __restrict  */)*argbuf___0, (void const   */* __restrict  */)(input + 1),
             n);
#line 182
      *(*argbuf___0 + n) = (char)0;
#line 183
      *endp = (char const   *)(p + 1);
      }
#line 184
      return (*argbuf___0);
    }
  }
#line 188
  *endp = input;
#line 189
  return ((char *)((void *)0));
}
}
#line 192 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static int tty_cleanup  ;
#line 194 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static char const   *def_format  =    "%{%Y-%m-%d %H:%M:%S}t: %ds, %{read,wrote}T%*\r";
#line 207
static int format_checkpoint_string(FILE *fp , size_t len , char const   *input ,
                                    _Bool do_write , unsigned int cpn ) ;
#line 207 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static char *argbuf  =    (char *)((void *)0);
#line 208 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static size_t arglen  =    (size_t )0;
#line 197 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static int format_checkpoint_string(FILE *fp , size_t len , char const   *input ,
                                    _Bool do_write , unsigned int cpn ) 
{ 
  char const   *opstr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char uintbuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *cps ;
  char *tmp___2 ;
  char const   *ip ;
  char *arg___0 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  double tmp___8 ;
  int tmp___9 ;
  char const   **fmt ;
  char const   *fmtbuf[3] ;
  struct wordsplit ws ;
  char const   *tmp___10 ;
  char *tmp___11 ;
  int i ;
  int tmp___12 ;
  int tmp___13 ;
  struct timeval tv ;
  struct tm *tm ;
  char const   *fmt___0 ;
  char const   *tmp___14 ;
  size_t tmp___15 ;
  long w ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;

  {
#line 202
  if (do_write) {
    {
#line 202
    tmp = gettext("write");
#line 202
    tmp___1 = tmp;
    }
  } else {
    {
#line 202
    tmp___0 = gettext("read");
#line 202
    tmp___1 = tmp___0;
    }
  }
  {
#line 202
  opstr = (char const   *)tmp___1;
#line 204
  tmp___2 = umaxtostr((uintmax_t )cpn, uintbuf);
#line 204
  cps = tmp___2;
#line 209
  arg___0 = (char *)((void *)0);
  }
#line 211
  if (! input) {
#line 213
    if (do_write) {
      {
#line 218
      tmp___3 = gettext("Write checkpoint %u");
#line 218
      input = (char const   *)tmp___3;
      }
    } else {
      {
#line 224
      tmp___4 = gettext("Read checkpoint %u");
#line 224
      input = (char const   *)tmp___4;
      }
    }
  }
#line 227
  ip = input;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! *ip) {
#line 227
      goto while_break;
    }
#line 229
    if ((int const   )*ip == 37) {
#line 231
      ip ++;
#line 231
      if ((int const   )*ip == 123) {
        {
#line 233
        arg___0 = getarg(ip, & ip, & argbuf, & arglen);
        }
#line 234
        if (! arg___0) {
          {
#line 236
          fputc_unlocked('%', fp);
#line 237
          fputc_unlocked((int )*ip, fp);
#line 238
          len += 2UL;
          }
#line 239
          goto __Cont;
        }
      }
      {
#line 244
      if ((int const   )*ip == 99) {
#line 244
        goto case_99;
      }
#line 249
      if ((int const   )*ip == 117) {
#line 249
        goto case_117;
      }
#line 254
      if ((int const   )*ip == 115) {
#line 254
        goto case_115;
      }
#line 259
      if ((int const   )*ip == 100) {
#line 259
        goto case_100;
      }
#line 263
      if ((int const   )*ip == 84) {
#line 263
        goto case_84;
      }
#line 293
      if ((int const   )*ip == 116) {
#line 293
        goto case_116;
      }
#line 305
      if ((int const   )*ip == 42) {
#line 305
        goto case_42;
      }
#line 313
      goto switch_default;
      case_99: /* CIL Label */ 
      {
#line 245
      tmp___5 = format_checkpoint_string(fp, len, def_format, do_write, cpn);
#line 245
      len += (size_t )tmp___5;
      }
#line 247
      goto switch_break;
      case_117: /* CIL Label */ 
      {
#line 250
      fputs_unlocked((char const   */* __restrict  */)cps, (FILE */* __restrict  */)fp);
#line 251
      tmp___6 = strlen((char const   *)cps);
#line 251
      len += tmp___6;
      }
#line 252
      goto switch_break;
      case_115: /* CIL Label */ 
      {
#line 255
      fputs_unlocked((char const   */* __restrict  */)opstr, (FILE */* __restrict  */)fp);
#line 256
      tmp___7 = strlen(opstr);
#line 256
      len += tmp___7;
      }
#line 257
      goto switch_break;
      case_100: /* CIL Label */ 
      {
#line 260
      tmp___8 = compute_duration();
#line 260
      tmp___9 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%.0f",
                        tmp___8);
#line 260
      len += (size_t )tmp___9;
      }
#line 261
      goto switch_break;
      case_84: /* CIL Label */ 
      {
#line 265
      fmt = checkpoint_total_format;
#line 267
      compute_duration();
      }
#line 269
      if (arg___0) {
        {
#line 271
        ws.ws_delim = ",";
#line 272
        tmp___12 = wordsplit((char const   *)arg___0, & ws, 17988);
        }
#line 272
        if (tmp___12) {
          {
#line 274
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 274
            if (error_hook) {
              {
#line 274
              (*error_hook)();
              }
            }
            {
#line 274
            tmp___10 = wordsplit_strerror(& ws);
#line 274
            tmp___11 = gettext("cannot split string \'%s\': %s");
#line 274
            error(0, 0, (char const   *)tmp___11, arg___0, tmp___10);
#line 274
            exit_status = 2;
            }
#line 274
            goto while_break___0;
          }
          while_break___0: /* CIL Label */ ;
          }
        } else {
#line 280
          i = 0;
          {
#line 280
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 280
            if (! ((size_t )i < ws.ws_wordc)) {
#line 280
              goto while_break___1;
            }
#line 281
            fmtbuf[i] = (char const   *)*(ws.ws_wordv + i);
#line 280
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 282
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 282
            if (! (i < 3)) {
#line 282
              goto while_break___2;
            }
#line 283
            fmtbuf[i] = (char const   *)((void *)0);
#line 282
            i ++;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 284
          fmt = fmtbuf;
        }
      }
      {
#line 287
      tmp___13 = format_total_stats(fp, (char const   * const  *)fmt, ',', 0);
#line 287
      len += (size_t )tmp___13;
      }
#line 288
      if (arg___0) {
        {
#line 289
        wordsplit_free(& ws);
        }
      }
#line 291
      goto switch_break;
      case_116: /* CIL Label */ 
#line 297
      if (arg___0) {
#line 297
        tmp___14 = (char const   *)arg___0;
      } else {
#line 297
        tmp___14 = "%c";
      }
      {
#line 297
      fmt___0 = tmp___14;
#line 299
      gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 300
      tm = localtime((time_t const   *)(& tv.tv_sec));
#line 301
      tmp___15 = fprintftime(fp, fmt___0, (struct tm  const  *)tm, (timezone_t )0,
                             (int )(tv.tv_usec * 1000L));
#line 301
      len += tmp___15;
      }
#line 303
      goto switch_break;
      case_42: /* CIL Label */ 
#line 307
      if (arg___0) {
        {
#line 307
        tmp___16 = strtol((char const   */* __restrict  */)arg___0, (char **/* __restrict  */)((void *)0),
                          10);
#line 307
        tmp___18 = tmp___16;
        }
      } else {
        {
#line 307
        tmp___17 = getwidth(fp);
#line 307
        tmp___18 = tmp___17;
        }
      }
#line 307
      w = tmp___18;
      {
#line 308
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 308
        if (! ((size_t )w > len)) {
#line 308
          goto while_break___3;
        }
        {
#line 309
        fputc_unlocked(' ', fp);
#line 308
        len ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 311
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 314
      fputc_unlocked('%', fp);
#line 315
      fputc_unlocked((int )*ip, fp);
#line 316
      len += 2UL;
      }
#line 317
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 319
      arg___0 = (char *)((void *)0);
    } else {
      {
#line 323
      fputc_unlocked((int )*ip, fp);
      }
#line 324
      if ((int const   )*ip == 13) {
#line 326
        len = (size_t )0;
#line 327
        tty_cleanup = 1;
      } else {
#line 330
        len ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 227
    ip ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 333
  fflush_unlocked(fp);
  }
#line 334
  return ((int )len);
}
}
#line 337 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static FILE *tty  =    (FILE *)((void *)0);
#line 339 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
static void run_checkpoint_actions(_Bool do_write ) 
{ 
  struct checkpoint_action *p ;
  int n ;
  int tmp ;

  {
#line 344
  p = checkpoint_action;
  {
#line 344
  while (1) {
    while_continue: /* CIL Label */ ;
#line 344
    if (! p) {
#line 344
      goto while_break;
    }
    {
#line 348
    if ((unsigned int )p->opcode == 0U) {
#line 348
      goto case_0;
    }
#line 353
    if ((unsigned int )p->opcode == 1U) {
#line 353
      goto case_1;
    }
#line 363
    if ((unsigned int )p->opcode == 2U) {
#line 363
      goto case_2;
    }
#line 372
    if ((unsigned int )p->opcode == 3U) {
#line 372
      goto case_3;
    }
#line 380
    if ((unsigned int )p->opcode == 4U) {
#line 380
      goto case_4;
    }
#line 384
    if ((unsigned int )p->opcode == 5U) {
#line 384
      goto case_5;
    }
#line 390
    if ((unsigned int )p->opcode == 6U) {
#line 390
      goto case_6;
    }
#line 346
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 349
    fputc_unlocked('.', stdlis);
#line 350
    fflush_unlocked(stdlis);
    }
#line 351
    goto switch_break;
    case_1: /* CIL Label */ 
#line 354
    if (! tty) {
      {
#line 355
      tty = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w");
      }
    }
#line 356
    if (tty) {
      {
#line 358
      fputc_unlocked('\a', tty);
#line 359
      fflush_unlocked(tty);
      }
    }
#line 361
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 365
    tmp = fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
                  program_name);
#line 365
    n = tmp;
#line 366
    format_checkpoint_string(stderr, (size_t )n, (char const   *)p->v.command, do_write,
                             checkpoint);
#line 368
    fputc_unlocked('\n', stderr);
    }
#line 370
    goto switch_break;
    case_3: /* CIL Label */ 
#line 373
    if (! tty) {
      {
#line 374
      tty = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"w");
      }
    }
#line 375
    if (tty) {
      {
#line 376
      format_checkpoint_string(tty, (size_t )0, (char const   *)p->v.command, do_write,
                               checkpoint);
      }
    }
#line 378
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 381
    sleep((unsigned int )p->v.time);
    }
#line 382
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 385
    sys_exec_checkpoint_script((char const   *)p->v.command, *(archive_name_cursor + 0),
                               (int )checkpoint);
    }
#line 388
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 391
    compute_duration();
#line 392
    print_total_stats();
    }
    switch_break: /* CIL Label */ ;
    }
#line 344
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 395
  return;
}
}
#line 397 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
void checkpoint_flush_actions(void) 
{ 
  struct checkpoint_action *p ;
  long w ;
  long tmp ;
  long tmp___0 ;

  {
#line 402
  p = checkpoint_action;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! p) {
#line 402
      goto while_break;
    }
    {
#line 406
    if ((unsigned int )p->opcode == 3U) {
#line 406
      goto case_3;
    }
#line 416
    goto switch_default;
    case_3: /* CIL Label */ 
#line 407
    if (tty) {
#line 407
      if (tty_cleanup) {
        {
#line 409
        tmp = getwidth(tty);
#line 409
        w = tmp;
        }
        {
#line 410
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 410
          tmp___0 = w;
#line 410
          w --;
#line 410
          if (! tmp___0) {
#line 410
            goto while_break___0;
          }
          {
#line 411
          fputc_unlocked(' ', tty);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 412
        fputc_unlocked('\r', tty);
#line 413
        fflush_unlocked(tty);
        }
      }
    }
#line 415
    goto switch_break;
    switch_default: /* CIL Label */ ;
    switch_break: /* CIL Label */ ;
    }
#line 402
    p = p->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 420
  return;
}
}
#line 422 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
void checkpoint_run(_Bool do_write ) 
{ 


  {
#line 425
  if (checkpoint_option) {
#line 425
    checkpoint ++;
#line 425
    if (! (checkpoint % checkpoint_option)) {
      {
#line 426
      run_checkpoint_actions(do_write);
      }
    }
  }
#line 427
  return;
}
}
#line 429 "/home/khheo/project/benchmark/tar-1.29/src/checkpoint.c"
void checkpoint_finish(void) 
{ 


  {
#line 432
  if (checkpoint_option) {
    {
#line 434
    checkpoint_flush_actions();
    }
#line 435
    if (tty) {
      {
#line 436
      fclose(tty);
      }
    }
  }
#line 438
  return;
}
}
#line 782 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 137 "../gnu/unistd.h"
#pragma GCC diagnostic push
#line 137
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 137
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 1894
#pragma GCC diagnostic pop
#line 28 "../gnu/xalloc.h"
#pragma GCC diagnostic push
#line 28
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 28
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 262
#pragma GCC diagnostic pop
#line 29 "../gnu/stat-time.h"
#pragma GCC diagnostic push
#line 29
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 29
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 197
#pragma GCC diagnostic pop
#line 27 "../gnu/timespec.h"
#pragma GCC diagnostic push
#line 27
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 27
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 110
#pragma GCC diagnostic pop
#line 74 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
#pragma GCC diagnostic push
#line 74
#pragma GCC diagnostic ignored "-Wmissing-prototypes"
#line 74
#pragma GCC diagnostic ignored "-Wmissing-declarations"
#line 432 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
enum access_mode access_mode  ;
#line 436 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
FILE *stdlis  ;
#line 437 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
_Bool write_archive_to_stdout  ;
#line 438 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char *volume_label  ;
#line 440 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
char *continued_file_name  ;
#line 441 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
uintmax_t continued_file_size  ;
#line 442 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
uintmax_t continued_file_offset  ;
#line 443 "/home/khheo/project/benchmark/tar-1.29/src/common.h"
off_t records_written  ;
#line 720
 __attribute__((__noreturn__)) void write_fatal_details(char const   *name , ssize_t status ,
                                                        size_t size ) ;
#line 974
#pragma GCC diagnostic pop
#line 41 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static tarlong prev_written  ;
#line 42 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static tarlong bytes_written  ;
#line 43 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void *record_buffer[2]  ;
#line 44 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static union block *record_buffer_aligned[2]  ;
#line 45 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int record_index  ;
#line 50 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
union block *record_start  ;
#line 51 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
union block *record_end  ;
#line 52 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
union block *current_block  ;
#line 54 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
off_t records_read  ;
#line 59 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static off_t record_start_block  ;
#line 64
static void backspace_output(void) ;
#line 67 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static pid_t child_pid  ;
#line 70 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int read_error_count  ;
#line 73 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool hit_eof  ;
#line 75 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool read_full_records  =    (_Bool)0;
#line 86 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void (*flush_write_ptr)(size_t  )  ;
#line 87 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void (*flush_read_ptr)(void)  ;
#line 96 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int volno  =    1;
#line 98 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int global_volno  =    1;
#line 125 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct bufmap *bufmap_head  ;
#line 125 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct bufmap *bufmap_tail  ;
#line 129 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int inhibit_map  ;
#line 131 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void mv_begin_write(char const   *file_name___0 , off_t totsize , off_t sizeleft ) 
{ 
  struct bufmap *bp ;
  void *tmp ;

  {
#line 134
  if (multi_volume_option) {
    {
#line 136
    tmp = xmalloc(sizeof(*(bp + 0)));
#line 136
    bp = (struct bufmap *)tmp;
    }
#line 137
    if (bufmap_tail) {
#line 138
      bufmap_tail->next = bp;
    } else {
#line 140
      bufmap_head = bp;
    }
    {
#line 141
    bufmap_tail = bp;
#line 143
    bp->next = (struct bufmap *)((void *)0);
#line 144
    bp->start = (size_t )(current_block - record_start);
#line 145
    bp->file_name = xstrdup(file_name___0);
#line 146
    bp->sizetotal = totsize;
#line 147
    bp->sizeleft = sizeleft;
    }
  }
#line 149
  return;
}
}
#line 151 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct bufmap *bufmap_locate(size_t off ) 
{ 
  struct bufmap *map ;

  {
#line 156
  map = bufmap_head;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! map) {
#line 156
      goto while_break;
    }
#line 158
    if (! map->next) {
#line 160
      goto while_break;
    } else
#line 158
    if (off < (map->next)->start * 512UL) {
#line 160
      goto while_break;
    }
#line 156
    map = map->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  return (map);
}
}
#line 165 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void bufmap_free(struct bufmap *mark ) 
{ 
  struct bufmap *map ;
  struct bufmap *next ;

  {
#line 169
  map = bufmap_head;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
#line 169
    if (map) {
#line 169
      if (! ((unsigned long )map != (unsigned long )mark)) {
#line 169
        goto while_break;
      }
    } else {
#line 169
      goto while_break;
    }
    {
#line 171
    next = map->next;
#line 172
    free((void *)map->file_name);
#line 173
    free((void *)map);
#line 174
    map = next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 176
  bufmap_head = map;
#line 177
  if (! bufmap_head) {
#line 178
    bufmap_tail = bufmap_head;
  }
#line 179
  return;
}
}
#line 181 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void bufmap_reset(struct bufmap *map , ssize_t fixup ) 
{ 


  {
  {
#line 184
  bufmap_free(map);
  }
#line 185
  if (map) {
    {
#line 187
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      if (! map) {
#line 187
        goto while_break;
      }
#line 188
      map->start += (size_t )fixup;
#line 187
      map = map->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 190
  return;
}
}
#line 193 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct tar_stat_info dummy  ;
#line 195 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void buffer_write_global_xheader(void) 
{ 


  {
  {
#line 198
  xheader_write_global(& dummy.xhdr);
  }
#line 199
  return;
}
}
#line 201 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void mv_begin_read(struct tar_stat_info *st ) 
{ 


  {
  {
#line 204
  mv_begin_write((char const   *)st->orig_file_name, st->stat.st_size, st->stat.st_size);
  }
#line 205
  return;
}
}
#line 207 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void mv_end(void) 
{ 


  {
#line 210
  if (multi_volume_option) {
    {
#line 211
    bufmap_free((struct bufmap *)((void *)0));
    }
  }
#line 212
  return;
}
}
#line 214 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void mv_size_left(off_t size ) 
{ 


  {
#line 217
  if (bufmap_head) {
#line 218
    bufmap_head->sizeleft = size;
  }
#line 219
  return;
}
}
#line 224 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void clear_read_error_count(void) 
{ 


  {
#line 227
  read_error_count = 0;
#line 228
  return;
}
}
#line 233 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static double duration  ;
#line 235 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void set_start_time(void) 
{ 


  {
  {
#line 238
  gettime(& start_time);
#line 239
  volume_start_time = start_time;
#line 240
  last_stat_time = start_time;
  }
#line 241
  return;
}
}
#line 243 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void set_volume_start_time(void) 
{ 


  {
  {
#line 246
  gettime(& volume_start_time);
#line 247
  last_stat_time = volume_start_time;
  }
#line 248
  return;
}
}
#line 250 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
double compute_duration(void) 
{ 
  struct timespec now ;

  {
  {
#line 254
  gettime(& now);
#line 255
  duration += (double )(now.tv_sec - last_stat_time.tv_sec) + (double )(now.tv_nsec - last_stat_time.tv_nsec) / 1e9;
#line 257
  gettime(& last_stat_time);
  }
#line 258
  return (duration);
}
}
#line 276 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static enum compress_type archive_compression_type  =    (enum compress_type )0;
#line 292 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct zip_magic  const  magic[9]  = 
#line 292
  {      {(enum compress_type )0, (size_t )0, (char const   *)0}, 
        {(enum compress_type )1, (size_t )0, (char const   *)0}, 
        {(enum compress_type )2, (size_t )2, "\037\235"}, 
        {(enum compress_type )3, (size_t )2, "\037\213"}, 
        {(enum compress_type )4, (size_t )3, "BZh"}, 
        {(enum compress_type )5, (size_t )4, "LZIP"}, 
        {(enum compress_type )6, (size_t )6, "\377LZMA"}, 
        {(enum compress_type )7, (size_t )4, "\211LZO"}, 
        {(enum compress_type )8, (size_t )6, "\3757zXZ"}};
#line 306 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct zip_program zip_program[11]  = 
#line 306
  {      {(enum compress_type )2, "compress", "-Z"}, 
        {(enum compress_type )2, "gzip", "-z"}, 
        {(enum compress_type )3, "gzip", "-z"}, 
        {(enum compress_type )4, "bzip2", "-j"}, 
        {(enum compress_type )4, "lbzip2", "-j"}, 
        {(enum compress_type )5, "lzip", "--lzip"}, 
        {(enum compress_type )6, "lzma", "--lzma"}, 
        {(enum compress_type )6, "xz", "-J"}, 
        {(enum compress_type )7, "lzop", "--lzop"}, 
        {(enum compress_type )8, "xz", "-J"}, 
        {(enum compress_type )0, (char const   *)0, (char const   *)0}};
#line 320 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static struct zip_program  const  *find_zip_program(enum compress_type type , int *pstate ) 
{ 
  int i ;

  {
#line 325
  i = *pstate;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! ((unsigned int )zip_program[i].type != 0U)) {
#line 325
      goto while_break;
    }
#line 327
    if ((unsigned int )zip_program[i].type == (unsigned int )type) {
#line 329
      *pstate = i + 1;
#line 330
      return ((struct zip_program  const  *)(zip_program + i));
    }
#line 325
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 333
  *pstate = i;
#line 334
  return ((struct zip_program  const  *)((void *)0));
}
}
#line 337 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
char const   *first_decompress_program(int *pstate ) 
{ 
  struct zip_program  const  *zp ;
  char const   *tmp ;

  {
#line 342
  if (use_compress_program_option) {
#line 343
    return (use_compress_program_option);
  }
#line 345
  if ((unsigned int )archive_compression_type == 0U) {
#line 346
    return ((char const   *)((void *)0));
  }
  {
#line 348
  *pstate = 0;
#line 349
  zp = find_zip_program(archive_compression_type, pstate);
  }
#line 350
  if (zp) {
#line 350
    tmp = zp->program;
  } else {
#line 350
    tmp = (char const   */* const  */)((void *)0);
  }
#line 350
  return ((char const   *)tmp);
}
}
#line 353 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
char const   *next_decompress_program(int *pstate ) 
{ 
  struct zip_program  const  *zp ;
  char const   *tmp ;

  {
#line 358
  if (use_compress_program_option) {
#line 359
    return ((char const   *)((void *)0));
  }
  {
#line 360
  zp = find_zip_program(archive_compression_type, pstate);
  }
#line 361
  if (zp) {
#line 361
    tmp = zp->program;
  } else {
#line 361
    tmp = (char const   */* const  */)((void *)0);
  }
#line 361
  return ((char const   *)tmp);
}
}
#line 364 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static char const   *compress_option(enum compress_type type ) 
{ 
  struct zip_program  const  *zp ;
  int i ;
  char const   *tmp ;

  {
  {
#line 368
  i = 0;
#line 369
  zp = find_zip_program(type, & i);
  }
#line 370
  if (zp) {
#line 370
    tmp = zp->rpl_option;
  } else {
#line 370
    tmp = (char const   */* const  */)((void *)0);
  }
#line 370
  return ((char const   *)tmp);
}
}
#line 374 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static enum compress_type check_compressed_archive(_Bool *pshort ) 
{ 
  struct zip_magic  const  *p ;
  _Bool sfr ;
  _Bool temp ;
  union block *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  enum read_header tmp___2 ;
  int tmp___3 ;

  {
#line 381
  if (! pshort) {
#line 382
    pshort = & temp;
  }
  {
#line 385
  record_end = record_start;
#line 386
  sfr = read_full_records;
#line 387
  read_full_records = (_Bool)1;
#line 389
  tmp = find_next_block();
#line 389
  *pshort = (_Bool )((unsigned long )tmp == (unsigned long )((union block *)0));
#line 392
  read_full_records = sfr;
#line 394
  tmp___0 = strcmp((char const   *)(record_start->header.magic), "ustar");
  }
#line 394
  if (tmp___0 == 0) {
#line 394
    goto _L;
  } else {
    {
#line 394
    tmp___1 = strcmp((char const   *)(record_start->buffer + (unsigned long )(& ((struct posix_header *)0)->magic)),
                     "ustar  ");
    }
#line 394
    if (tmp___1 == 0) {
      _L: /* CIL Label */ 
      {
#line 394
      tmp___2 = tar_checksum(record_start, (_Bool)1);
      }
#line 394
      if ((unsigned int )tmp___2 == 1U) {
#line 399
        return ((enum compress_type )1);
      }
    }
  }
#line 401
  p = magic + 2;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! ((unsigned long )p < (unsigned long )(magic + sizeof(magic) / sizeof(magic[0])))) {
#line 401
      goto while_break;
    }
    {
#line 402
    tmp___3 = memcmp((void const   *)(record_start->buffer), (void const   *)p->magic,
                     (size_t )p->length);
    }
#line 402
    if (tmp___3 == 0) {
#line 403
      return ((enum compress_type )p->type);
    }
#line 401
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 405
  return ((enum compress_type )0);
}
}
#line 409 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void guess_seekable_archive(void) 
{ 
  struct stat st ;
  int tmp ;

  {
#line 414
  if ((unsigned int )subcommand_option == 4U) {
#line 423
    seekable_archive = (_Bool)0;
  }
#line 426
  if (seek_option != -1) {
#line 428
    seekable_archive = (_Bool )(! (! seek_option));
#line 429
    return;
  }
#line 432
  if (! multi_volume_option) {
#line 432
    if (! use_compress_program_option) {
      {
#line 432
      tmp = fstat(archive, & st);
      }
#line 432
      if (tmp == 0) {
#line 434
        seekable_archive = (_Bool )((st.st_mode & 61440U) == 32768U);
      } else {
#line 436
        seekable_archive = (_Bool)0;
      }
    } else {
#line 436
      seekable_archive = (_Bool)0;
    }
  } else {
#line 436
    seekable_archive = (_Bool)0;
  }
#line 437
  return;
}
}
#line 442 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int open_compressed_archive(void) 
{ 
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  _Bool shortfile ;
  enum compress_type type ;
  enum compress_type tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 445
  if (! force_local_option) {
    {
#line 445
    tmp___3 = strchr(*(archive_name_array + 0), ':');
#line 445
    rmt_dev_name__ = (char const   *)tmp___3;
    }
#line 445
    if (rmt_dev_name__) {
#line 445
      if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
        {
#line 445
        tmp___4 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
        }
#line 445
        if (tmp___4) {
          {
#line 445
          tmp___2 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 445
          archive = tmp___2;
          }
        } else {
          {
#line 445
          tmp___1 = rmt_open__(*(archive_name_array + 0), 0, 1 << 30, rsh_command_option);
#line 445
          archive = tmp___1;
          }
        }
      } else {
        {
#line 445
        tmp___2 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 445
        archive = tmp___2;
        }
      }
    } else {
      {
#line 445
      tmp___2 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 445
      archive = tmp___2;
      }
    }
  } else {
    {
#line 445
    tmp___2 = open(*(archive_name_array + 0), 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 445
    archive = tmp___2;
    }
  }
#line 447
  if (archive == -1) {
#line 448
    return (archive);
  }
#line 450
  if (! multi_volume_option) {
#line 452
    if (! use_compress_program_option) {
      {
#line 455
      tmp___5 = check_compressed_archive(& shortfile);
#line 455
      type = tmp___5;
      }
      {
#line 459
      if ((unsigned int )type == 1U) {
#line 459
        goto case_1;
      }
#line 464
      if ((unsigned int )type == 0U) {
#line 464
        goto case_0;
      }
#line 472
      goto switch_default;
      case_1: /* CIL Label */ 
#line 460
      if (shortfile) {
        {
#line 461
        while (1) {
          while_continue: /* CIL Label */ ;
#line 461
          if (error_hook) {
            {
#line 461
            (*error_hook)();
            }
          }
          {
#line 461
          tmp___6 = gettext("This does not look like a tar archive");
#line 461
          error(0, 0, (char const   *)tmp___6);
#line 461
          exit_status = 2;
          }
#line 461
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
#line 462
      return (archive);
      case_0: /* CIL Label */ 
#line 465
      if (shortfile) {
        {
#line 466
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 466
          if (error_hook) {
            {
#line 466
            (*error_hook)();
            }
          }
          {
#line 466
          tmp___7 = gettext("This does not look like a tar archive");
#line 466
          error(0, 0, (char const   *)tmp___7);
#line 466
          exit_status = 2;
          }
#line 466
          goto while_break___0;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 467
      set_compression_program_by_suffix(*(archive_name_array + 0), (char const   *)((void *)0));
      }
#line 468
      if (! use_compress_program_option) {
#line 469
        return (archive);
      }
#line 470
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 473
      archive_compression_type = type;
#line 474
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 479
    if (archive >= 1 << 30) {
      {
#line 479
      rmt_close__(archive - (1 << 30));
      }
    } else {
      {
#line 479
      close(archive);
      }
    }
    {
#line 481
    hit_eof = (_Bool)0;
#line 485
    child_pid = sys_child_open_for_uncompress();
#line 486
    read_full_records = (_Bool)1;
    }
  }
#line 489
  records_read = (off_t )0;
#line 490
  record_end = record_start;
#line 492
  return (archive);
}
}
#line 495 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int print_stats(FILE *fp , char const   *text , tarlong numbytes ) 
{ 
  char abbr[(((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL) + 1UL] ;
  char rate[(((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL) + 1UL] ;
  int n ;
  int human_opts ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 500
  n = 0;
#line 502
  human_opts = 432;
#line 504
  if (text) {
#line 504
    if (*(text + 0)) {
      {
#line 505
      tmp = gettext(text);
#line 505
      tmp___0 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ",
                        tmp);
#line 505
      n += tmp___0;
      }
    }
  }
#line 506
  if ((double )0 < duration) {
#line 506
    if (numbytes / duration < (tarlong )0xffffffffffffffffUL) {
      {
#line 506
      tmp___1 = human_readable((uintmax_t )(numbytes / duration), rate, human_opts,
                               (uintmax_t )1, (uintmax_t )1);
#line 506
      tmp___2 = (char const   *)tmp___1;
      }
    } else {
#line 506
      tmp___2 = "?";
    }
  } else {
#line 506
    tmp___2 = "?";
  }
  {
#line 506
  tmp___3 = human_readable((uintmax_t )numbytes, abbr, human_opts, (uintmax_t )1,
                           (uintmax_t )1);
#line 506
  tmp___4 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%.0f (%s, %s/s)",
                    numbytes, tmp___3, tmp___2);
  }
#line 506
  return (n + tmp___4);
}
}
#line 519 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
int format_total_stats(FILE *fp , char const   * const  *formats , int eor , int eol ) 
{ 
  int n ;
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 529
  if ((unsigned int )subcommand_option == 1U) {
#line 529
    goto case_1;
  }
#line 529
  if ((unsigned int )subcommand_option == 8U) {
#line 529
    goto case_1;
  }
#line 529
  if ((unsigned int )subcommand_option == 2U) {
#line 529
    goto case_1;
  }
#line 529
  if ((unsigned int )subcommand_option == 3U) {
#line 529
    goto case_1;
  }
#line 534
  if ((unsigned int )subcommand_option == 4U) {
#line 534
    goto case_4;
  }
#line 560
  if ((unsigned int )subcommand_option == 5U) {
#line 560
    goto case_5;
  }
#line 560
  if ((unsigned int )subcommand_option == 7U) {
#line 560
    goto case_5;
  }
#line 560
  if ((unsigned int )subcommand_option == 6U) {
#line 560
    goto case_5;
  }
#line 565
  goto switch_default;
  case_1: /* CIL Label */ 
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_3: /* CIL Label */ 
  {
#line 530
  n = print_stats(fp, (char const   *)*(formats + 1), prev_written + bytes_written);
  }
#line 532
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 537
  n = print_stats(fp, (char const   *)*(formats + 0), (tarlong )((size_t )records_read * record_size));
#line 540
  fputc_unlocked(eor, fp);
#line 541
  n ++;
#line 543
  tmp = print_stats(fp, (char const   *)*(formats + 1), prev_written + bytes_written);
#line 543
  n += tmp;
#line 546
  fputc_unlocked(eor, fp);
#line 547
  n ++;
  }
#line 549
  if (*(formats + 2)) {
#line 549
    if (*(*(formats + 2) + 0)) {
      {
#line 550
      tmp___0 = gettext((char const   *)*(formats + 2));
#line 550
      tmp___1 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s: ",
                        tmp___0);
#line 550
      n += tmp___1;
      }
    }
  }
  {
#line 551
  tmp___2 = umaxtostr((uintmax_t )((tarlong )((size_t )(records_read - records_skipped) * record_size) - (prev_written + bytes_written)),
                      buf);
#line 551
  tmp___3 = fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s",
                    tmp___2);
#line 551
  n += tmp___3;
  }
#line 556
  goto switch_break;
  case_5: /* CIL Label */ 
  case_7: /* CIL Label */ 
  case_6: /* CIL Label */ 
  {
#line 561
  tmp___4 = gettext((char const   *)*(formats + 0));
#line 561
  n = print_stats(fp, (char const   *)tmp___4, (tarlong )((size_t )records_read * record_size));
  }
#line 563
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 566
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 568
  if (eol) {
    {
#line 570
    fputc_unlocked(eol, fp);
#line 571
    n ++;
    }
  }
#line 573
  return (n);
}
}
#line 576 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static char const   * const  default_total_format[3]  = {      (char const   */* const  */)"Total bytes read",      (char const   */* const  */)"Total bytes written",      (char const   */* const  */)"Total bytes deleted"};
#line 583 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void print_total_stats(void) 
{ 


  {
  {
#line 586
  format_total_stats(stderr, default_total_format, '\n', '\n');
  }
#line 587
  return;
}
}
#line 590 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
off_t current_block_ordinal(void) 
{ 


  {
#line 593
  return (record_start_block + (current_block - record_start));
}
}
#line 597 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void reset_eof(void) 
{ 


  {
#line 600
  if (hit_eof) {
#line 602
    hit_eof = (_Bool)0;
#line 603
    current_block = record_start;
#line 604
    record_end = record_start + blocking_factor;
#line 605
    access_mode = (enum access_mode )1;
  }
#line 607
  return;
}
}
#line 612 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
union block *find_next_block(void) 
{ 


  {
#line 615
  if ((unsigned long )current_block == (unsigned long )record_end) {
#line 617
    if (hit_eof) {
#line 618
      return ((union block *)0);
    }
    {
#line 619
    flush_archive();
    }
#line 620
    if ((unsigned long )current_block == (unsigned long )record_end) {
#line 622
      hit_eof = (_Bool)1;
#line 623
      return ((union block *)0);
    }
  }
#line 626
  return (current_block);
}
}
#line 630 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void set_next_block_after(union block *block ) 
{ 


  {
  {
#line 633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 633
    if (! ((unsigned long )block >= (unsigned long )current_block)) {
#line 633
      goto while_break;
    }
#line 634
    current_block ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 640
  if ((unsigned long )current_block > (unsigned long )record_end) {
    {
#line 641
    abort();
    }
  }
#line 642
  return;
}
}
#line 648 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
size_t available_space_after(union block *pointer ) 
{ 


  {
#line 651
  return ((size_t )(record_end->buffer - pointer->buffer));
}
}
#line 655 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void xclose(int fd ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 658
  tmp___0 = close(fd);
  }
#line 658
  if (tmp___0 != 0) {
    {
#line 659
    tmp = gettext("(pipe)");
#line 659
    close_error((char const   *)tmp);
    }
  }
#line 660
  return;
}
}
#line 662 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void init_buffer(void) 
{ 
  void *tmp ;

  {
#line 665
  if (! record_buffer_aligned[record_index]) {
    {
#line 666
    tmp = page_aligned_alloc(& record_buffer[record_index], record_size);
#line 666
    record_buffer_aligned[record_index] = (union block *)tmp;
    }
  }
#line 669
  record_start = record_buffer_aligned[record_index];
#line 670
  current_block = record_start;
#line 671
  record_end = record_start + blocking_factor;
#line 672
  return;
}
}
#line 674 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void check_tty(enum access_mode mode ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 678
  tmp___2 = strcmp(*(archive_name_array + 0), "-");
  }
#line 678
  if (tmp___2 == 0) {
#line 678
    if ((unsigned int )mode == 0U) {
#line 678
      tmp___3 = 0;
    } else {
#line 678
      tmp___3 = 1;
    }
    {
#line 678
    tmp___4 = isatty(tmp___3);
    }
#line 678
    if (tmp___4) {
      {
#line 681
      while (1) {
        while_continue: /* CIL Label */ ;
#line 681
        if (error_hook) {
          {
#line 681
          (*error_hook)();
          }
        }
#line 681
        if ((unsigned int )mode == 0U) {
          {
#line 681
          tmp = gettext("Refusing to read archive contents from terminal (missing -f option?)");
#line 681
          tmp___1 = tmp;
          }
        } else {
          {
#line 681
          tmp___0 = gettext("Refusing to write archive contents to terminal (missing -f option?)");
#line 681
          tmp___1 = tmp___0;
          }
        }
        {
#line 681
        error(0, 0, (char const   *)tmp___1);
#line 681
        fatal_exit();
        }
#line 681
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 688
  return;
}
}
#line 692 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void _open_archive(enum access_mode wanted_access ) 
{ 
  int backed_up_flag ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  _Bool shortfile ;
  enum compress_type type ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  void *tmp___23 ;
  enum compress_type tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;
  int saved_errno ;
  int *tmp___27 ;
  int *tmp___28 ;
  _Bool tmp___29 ;

  {
#line 695
  backed_up_flag = 0;
#line 697
  if (record_size == 0UL) {
    {
#line 698
    while (1) {
      while_continue: /* CIL Label */ ;
#line 698
      if (error_hook) {
        {
#line 698
        (*error_hook)();
        }
      }
      {
#line 698
      tmp = gettext("Invalid value for record_size");
#line 698
      error(0, 0, (char const   *)tmp);
#line 698
      fatal_exit();
      }
#line 698
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 700
  if (archive_names == 0UL) {
    {
#line 701
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 701
      if (error_hook) {
        {
#line 701
        (*error_hook)();
        }
      }
      {
#line 701
      tmp___0 = gettext("No archive name given");
#line 701
      error(0, 0, (char const   *)tmp___0);
#line 701
      fatal_exit();
      }
#line 701
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 703
  tar_stat_destroy(& current_stat_info);
#line 705
  record_index = 0;
#line 706
  init_buffer();
  }
#line 709
  if ((unsigned int )wanted_access == 2U) {
#line 709
    access_mode = (enum access_mode )0;
  } else {
#line 709
    access_mode = wanted_access;
  }
  {
#line 710
  check_tty(access_mode);
#line 712
  read_full_records = read_full_records_option;
#line 714
  records_read = (off_t )0;
  }
#line 716
  if (use_compress_program_option) {
    {
#line 720
    if ((unsigned int )wanted_access == 0U) {
#line 720
      goto case_0;
    }
#line 726
    if ((unsigned int )wanted_access == 1U) {
#line 726
      goto case_1;
    }
#line 730
    if ((unsigned int )wanted_access == 2U) {
#line 730
      goto case_2;
    }
#line 718
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 721
    child_pid = sys_child_open_for_uncompress();
#line 722
    read_full_records = (_Bool)1;
#line 723
    record_end = record_start;
    }
#line 724
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 727
    child_pid = sys_child_open_for_compress();
    }
#line 728
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 731
    abort();
    }
#line 732
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 735
    if (! index_file_name) {
#line 735
      if ((unsigned int )wanted_access == 1U) {
        {
#line 735
        tmp___1 = strcmp(*(archive_name_array + 0), "-");
        }
#line 735
        if (tmp___1 == 0) {
#line 738
          stdlis = stderr;
        }
      }
    }
  } else {
    {
#line 740
    tmp___26 = strcmp(*(archive_name_array + 0), "-");
    }
#line 740
    if (tmp___26 == 0) {
#line 742
      read_full_records = (_Bool)1;
#line 743
      if (verify_option) {
        {
#line 744
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 744
          if (error_hook) {
            {
#line 744
            (*error_hook)();
            }
          }
          {
#line 744
          tmp___2 = gettext("Cannot verify stdin/stdout archive");
#line 744
          error(0, 0, (char const   *)tmp___2);
#line 744
          fatal_exit();
          }
#line 744
          goto while_break___1;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
#line 748
      if ((unsigned int )wanted_access == 0U) {
#line 748
        goto case_0___0;
      }
#line 764
      if ((unsigned int )wanted_access == 1U) {
#line 764
        goto case_1___0;
      }
#line 770
      if ((unsigned int )wanted_access == 2U) {
#line 770
        goto case_2___0;
      }
#line 746
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 753
      archive = 0;
#line 754
      type = check_compressed_archive(& shortfile);
      }
#line 755
      if ((unsigned int )type != 1U) {
#line 755
        if ((unsigned int )type != 0U) {
          {
#line 756
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 756
            if (error_hook) {
              {
#line 756
              (*error_hook)();
              }
            }
            {
#line 756
            tmp___3 = compress_option(type);
#line 756
            tmp___4 = gettext("Archive is compressed. Use %s option");
#line 756
            error(0, 0, (char const   *)tmp___4, tmp___3);
#line 756
            fatal_exit();
            }
#line 756
            goto while_break___2;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 759
      if (shortfile) {
        {
#line 760
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 760
          if (error_hook) {
            {
#line 760
            (*error_hook)();
            }
          }
          {
#line 760
          tmp___5 = gettext("This does not look like a tar archive");
#line 760
          error(0, 0, (char const   *)tmp___5);
#line 760
          exit_status = 2;
          }
#line 760
          goto while_break___3;
        }
        while_break___3: /* CIL Label */ ;
        }
      }
#line 762
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
#line 765
      archive = 1;
#line 766
      if (! index_file_name) {
#line 767
        stdlis = stderr;
      }
#line 768
      goto switch_break___0;
      case_2___0: /* CIL Label */ 
#line 771
      archive = 0;
#line 772
      write_archive_to_stdout = (_Bool)1;
#line 773
      record_end = record_start;
#line 774
      if (! index_file_name) {
#line 775
        stdlis = stderr;
      }
#line 776
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
    } else {
      {
#line 782
      if ((unsigned int )wanted_access == 0U) {
#line 782
        goto case_0___1;
      }
#line 788
      if ((unsigned int )wanted_access == 1U) {
#line 788
        goto case_1___1;
      }
#line 802
      if ((unsigned int )wanted_access == 2U) {
#line 802
        goto case_2___1;
      }
#line 780
      goto switch_break___1;
      case_0___1: /* CIL Label */ 
      {
#line 783
      archive = open_compressed_archive();
      }
#line 784
      if (archive >= 0) {
        {
#line 785
        guess_seekable_archive();
        }
      }
#line 786
      goto switch_break___1;
      case_1___1: /* CIL Label */ 
#line 789
      if (backup_option) {
        {
#line 791
        maybe_backup_file(*(archive_name_array + 0), (_Bool)1);
#line 792
        backed_up_flag = 1;
        }
      }
#line 794
      if (verify_option) {
#line 795
        if (! force_local_option) {
          {
#line 795
          tmp___10 = strchr(*(archive_name_array + 0), ':');
#line 795
          rmt_dev_name__ = (char const   *)tmp___10;
          }
#line 795
          if (rmt_dev_name__) {
#line 795
            if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
              {
#line 795
              tmp___11 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
              }
#line 795
              if (tmp___11) {
                {
#line 795
                tmp___9 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 795
                archive = tmp___9;
                }
              } else {
                {
#line 795
                tmp___8 = rmt_open__(*(archive_name_array + 0), 66, 1 << 30, rsh_command_option);
#line 795
                archive = tmp___8;
                }
              }
            } else {
              {
#line 795
              tmp___9 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 795
              archive = tmp___9;
              }
            }
          } else {
            {
#line 795
            tmp___9 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 795
            archive = tmp___9;
            }
          }
        } else {
          {
#line 795
          tmp___9 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 795
          archive = tmp___9;
          }
        }
      } else
#line 798
      if (! force_local_option) {
        {
#line 798
        tmp___16 = strchr(*(archive_name_array + 0), ':');
#line 798
        rmt_dev_name__ = (char const   *)tmp___16;
        }
#line 798
        if (rmt_dev_name__) {
#line 798
          if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
            {
#line 798
            tmp___17 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
            }
#line 798
            if (tmp___17) {
              {
#line 798
              tmp___15 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 798
              archive = tmp___15;
              }
            } else {
              {
#line 798
              tmp___14 = rmt_open__(*(archive_name_array + 0), 65, 1 << 30, rsh_command_option);
#line 798
              archive = tmp___14;
              }
            }
          } else {
            {
#line 798
            tmp___15 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 798
            archive = tmp___15;
            }
          }
        } else {
          {
#line 798
          tmp___15 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 798
          archive = tmp___15;
          }
        }
      } else {
        {
#line 798
        tmp___15 = creat(*(archive_name_array + 0), (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 798
        archive = tmp___15;
        }
      }
#line 800
      goto switch_break___1;
      case_2___1: /* CIL Label */ 
#line 803
      if (! force_local_option) {
        {
#line 803
        tmp___22 = strchr(*(archive_name_array + 0), ':');
#line 803
        rmt_dev_name__ = (char const   *)tmp___22;
        }
#line 803
        if (rmt_dev_name__) {
#line 803
          if ((unsigned long )rmt_dev_name__ > (unsigned long )*(archive_name_array + 0)) {
            {
#line 803
            tmp___23 = memchr((void const   *)*(archive_name_array + 0), '/', (size_t )(rmt_dev_name__ - *(archive_name_array + 0)));
            }
#line 803
            if (tmp___23) {
              {
#line 803
              tmp___21 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 803
              archive = tmp___21;
              }
            } else {
              {
#line 803
              tmp___20 = rmt_open__(*(archive_name_array + 0), 66, 1 << 30, rsh_command_option);
#line 803
              archive = tmp___20;
              }
            }
          } else {
            {
#line 803
            tmp___21 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 803
            archive = tmp___21;
            }
          }
        } else {
          {
#line 803
          tmp___21 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 803
          archive = tmp___21;
          }
        }
      } else {
        {
#line 803
        tmp___21 = open(*(archive_name_array + 0), 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 803
        archive = tmp___21;
        }
      }
      {
#line 807
      tmp___24 = check_compressed_archive((_Bool *)((void *)0));
      }
      {
#line 810
      if ((unsigned int )tmp___24 == 1U) {
#line 810
        goto case_1___2;
      }
#line 810
      if ((unsigned int )tmp___24 == 0U) {
#line 810
        goto case_1___2;
      }
#line 813
      goto switch_default;
      case_1___2: /* CIL Label */ 
      case_0___2: /* CIL Label */ 
#line 811
      goto switch_break___2;
      switch_default: /* CIL Label */ 
      {
#line 814
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 814
        if (error_hook) {
          {
#line 814
          (*error_hook)();
          }
        }
        {
#line 814
        tmp___25 = gettext("Cannot update compressed archives");
#line 814
        error(0, 0, (char const   *)tmp___25);
#line 814
        fatal_exit();
        }
#line 814
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      switch_break___2: /* CIL Label */ ;
      }
#line 817
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
    }
  }
#line 820
  if (archive < 0) {
#line 820
    goto _L;
  } else
#line 820
  if (! (archive >= 1 << 30)) {
    {
#line 820
    tmp___29 = sys_get_archive_stat();
    }
#line 820
    if (! tmp___29) {
      _L: /* CIL Label */ 
      {
#line 823
      tmp___27 = __errno_location();
#line 823
      saved_errno = *tmp___27;
      }
#line 825
      if (backed_up_flag) {
        {
#line 826
        undo_last_backup();
        }
      }
      {
#line 827
      tmp___28 = __errno_location();
#line 827
      *tmp___28 = saved_errno;
#line 828
      open_fatal(*(archive_name_array + 0));
      }
    }
  }
  {
#line 831
  sys_detect_dev_null_output();
#line 832
  sys_save_archive_dev_ino();
  }
  {
#line 837
  if ((unsigned int )wanted_access == 0U) {
#line 837
    goto case_0___3;
  }
#line 842
  if ((unsigned int )wanted_access == 1U) {
#line 842
    goto case_1___3;
  }
#line 842
  if ((unsigned int )wanted_access == 2U) {
#line 842
    goto case_1___3;
  }
#line 835
  goto switch_break___3;
  case_0___3: /* CIL Label */ 
  {
#line 838
  find_next_block();
  }
#line 839
  goto switch_break___3;
  case_1___3: /* CIL Label */ 
  case_2___2: /* CIL Label */ 
#line 843
  records_written = (off_t )0;
#line 844
  goto switch_break___3;
  switch_break___3: /* CIL Label */ ;
  }
#line 846
  return;
}
}
#line 849 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static ssize_t _flush_write(void) 
{ 
  ssize_t status ;
  int *tmp ;
  size_t tmp___0 ;
  struct bufmap *map ;
  struct bufmap *tmp___1 ;
  size_t delta ;
  size_t tmp___2 ;

  {
  {
#line 854
  checkpoint_run((_Bool)1);
  }
#line 855
  if (tape_length_option) {
#line 855
    if (tape_length_option <= bytes_written) {
      {
#line 857
      tmp = __errno_location();
#line 857
      *tmp = 28;
#line 858
      status = (ssize_t )0;
      }
    } else {
#line 855
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 860
  if (dev_null_output) {
#line 861
    status = (ssize_t )record_size;
  } else {
    {
#line 863
    tmp___0 = sys_write_archive_buffer();
#line 863
    status = (ssize_t )tmp___0;
    }
  }
#line 865
  if (status) {
#line 865
    if (multi_volume_option) {
#line 865
      if (! inhibit_map) {
        {
#line 867
        tmp___1 = bufmap_locate((size_t )status);
#line 867
        map = tmp___1;
        }
#line 868
        if (map) {
#line 870
          delta = (size_t )status - map->start * 512UL;
#line 871
          if (delta > (size_t )map->sizeleft) {
#line 872
            delta = (size_t )map->sizeleft;
          }
#line 873
          map->sizeleft = (off_t )((size_t )map->sizeleft - delta);
#line 874
          if (map->sizeleft == 0L) {
#line 875
            map = map->next;
          }
#line 876
          if (map) {
#line 876
            tmp___2 = - map->start;
          } else {
#line 876
            tmp___2 = (size_t )0;
          }
          {
#line 876
          bufmap_reset(map, (ssize_t )tmp___2);
          }
        }
      }
    }
  }
#line 879
  return (status);
}
}
#line 885
 __attribute__((__noreturn__)) void archive_write_error(ssize_t status ) ;
#line 885 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void archive_write_error(ssize_t status ) 
{ 
  int e ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 890
  if (totals_option) {
    {
#line 892
    tmp = __errno_location();
#line 892
    e = *tmp;
#line 893
    print_total_stats();
#line 894
    tmp___0 = __errno_location();
#line 894
    *tmp___0 = e;
    }
  }
  {
#line 897
  write_fatal_details(*archive_name_cursor, status, record_size);
  }
}
}
#line 902 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void archive_read_error(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 905
  read_error(*archive_name_cursor);
  }
#line 907
  if (record_start_block == 0L) {
    {
#line 908
    while (1) {
      while_continue: /* CIL Label */ ;
#line 908
      if (error_hook) {
        {
#line 908
        (*error_hook)();
        }
      }
      {
#line 908
      tmp = gettext("At beginning of tape, quitting now");
#line 908
      error(0, 0, (char const   *)tmp);
#line 908
      fatal_exit();
      }
#line 908
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 913
  tmp___1 = read_error_count;
#line 913
  read_error_count ++;
#line 913
  if (tmp___1 > 10) {
    {
#line 914
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 914
      if (error_hook) {
        {
#line 914
        (*error_hook)();
        }
      }
      {
#line 914
      tmp___0 = gettext("Too many errors, quitting");
#line 914
      error(0, 0, (char const   *)tmp___0);
#line 914
      fatal_exit();
      }
#line 914
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 915
  return;
}
}
#line 918 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool archive_is_dev(void) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 923
  tmp = fstat(archive, & st);
  }
#line 923
  if (tmp) {
    {
#line 925
    stat_diag(*archive_name_cursor);
    }
#line 926
    return ((_Bool)0);
  }
#line 928
  if ((st.st_mode & 61440U) == 24576U) {
#line 928
    tmp___0 = 1;
  } else
#line 928
  if ((st.st_mode & 61440U) == 8192U) {
#line 928
    tmp___0 = 1;
  } else {
#line 928
    tmp___0 = 0;
  }
#line 928
  return ((_Bool )tmp___0);
}
}
#line 931 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void short_read(size_t status ) 
{ 
  size_t left ;
  char *more ;
  unsigned long rsize ;
  char *tmp ;
  _Bool tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  unsigned long rest ;
  char *tmp___3 ;

  {
#line 937
  more = record_start->buffer + status;
#line 938
  left = record_size - status;
#line 940
  if (left) {
#line 940
    if (left % 512UL == 0UL) {
#line 940
      if (warning_option & 4194304) {
#line 940
        if (record_start_block == 0L) {
#line 940
          if (status != 0UL) {
            {
#line 940
            tmp___0 = archive_is_dev();
            }
#line 940
            if (tmp___0) {
#line 945
              rsize = status / 512UL;
              {
#line 946
              while (1) {
                while_continue: /* CIL Label */ ;
#line 946
                if (error_hook) {
                  {
#line 946
                  (*error_hook)();
                  }
                }
                {
#line 946
                tmp = ngettext("Record size = %lu block", "Record size = %lu blocks",
                               rsize);
#line 946
                error(0, 0, (char const   *)tmp, rsize);
                }
#line 946
                goto while_break;
              }
              while_break: /* CIL Label */ ;
              }
            }
          }
        }
      }
    }
  }
  {
#line 953
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 953
    if (! (left % 512UL != 0UL)) {
#line 953
      if (left) {
#line 953
        if (status) {
#line 953
          if (! read_full_records) {
#line 953
            goto while_break___0;
          }
        } else {
#line 953
          goto while_break___0;
        }
      } else {
#line 953
        goto while_break___0;
      }
    }
#line 956
    if (status) {
      {
#line 957
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 957
        if (archive >= 1 << 30) {
          {
#line 957
          tmp___1 = rmt_read__(archive - (1 << 30), more, left);
#line 957
          status = tmp___1;
          }
        } else {
          {
#line 957
          tmp___2 = safe_read(archive, (void *)more, left);
#line 957
          status = tmp___2;
          }
        }
#line 957
        if (! (status == 0xffffffffffffffffUL)) {
#line 957
          goto while_break___1;
        }
        {
#line 958
        archive_read_error();
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 960
    if (status == 0UL) {
#line 961
      goto while_break___0;
    }
#line 963
    if (! read_full_records) {
#line 965
      rest = record_size - left;
      {
#line 967
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 967
        if (error_hook) {
          {
#line 967
          (*error_hook)();
          }
        }
        {
#line 967
        tmp___3 = ngettext("Unaligned block (%lu byte) in archive", "Unaligned block (%lu bytes) in archive",
                           rest);
#line 967
        error(0, 0, (char const   *)tmp___3, rest);
#line 967
        fatal_exit();
        }
#line 967
        goto while_break___2;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 974
    left -= status;
#line 975
    more += status;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 978
  record_end = record_start + (record_size - left) / 512UL;
#line 979
  records_read ++;
#line 980
  return;
}
}
#line 983 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void flush_archive(void) 
{ 
  size_t buffer_level ;

  {
#line 988
  if ((unsigned int )access_mode == 0U) {
#line 988
    if (time_to_start_writing) {
      {
#line 990
      access_mode = (enum access_mode )1;
#line 991
      time_to_start_writing = (_Bool)0;
#line 992
      backspace_output();
      }
#line 993
      if (record_end - record_start < (long )blocking_factor) {
        {
#line 995
        memset((void *)record_end, 0, (size_t )(((long )blocking_factor - (record_end - record_start)) * 512L));
#line 998
        record_end = record_start + blocking_factor;
        }
#line 999
        return;
      }
    }
  }
#line 1003
  buffer_level = (size_t )(current_block->buffer - record_start->buffer);
#line 1004
  record_start_block += record_end - record_start;
#line 1005
  current_block = record_start;
#line 1006
  record_end = record_start + blocking_factor;
  {
#line 1010
  if ((unsigned int )access_mode == 0U) {
#line 1010
    goto case_0;
  }
#line 1014
  if ((unsigned int )access_mode == 1U) {
#line 1014
    goto case_1;
  }
#line 1018
  if ((unsigned int )access_mode == 2U) {
#line 1018
    goto case_2;
  }
#line 1008
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 1011
  flush_read();
  }
#line 1012
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1015
  (*flush_write_ptr)(buffer_level);
  }
#line 1016
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1019
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 1021
  return;
}
}
#line 1026 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void backspace_output(void) 
{ 
  struct mtop operation ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  off_t position ;
  off_t tmp___6 ;
  __off_t tmp___7 ;
  off_t tmp___8 ;
  char *tmp___9 ;
  off_t tmp___10 ;
  __off_t tmp___11 ;
  off_t tmp___12 ;

  {
#line 1033
  operation.mt_op = (short)4;
#line 1034
  operation.mt_count = 1;
#line 1035
  if (archive >= 1 << 30) {
    {
#line 1035
    tmp = rmt_ioctl__(archive - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                      (char *)(& operation));
#line 1035
    tmp___1 = tmp;
    }
  } else {
    {
#line 1035
    tmp___0 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
                    (char *)(& operation));
#line 1035
    tmp___1 = tmp___0;
    }
  }
#line 1035
  if (tmp___1 >= 0) {
#line 1036
    return;
  }
  {
#line 1037
  tmp___2 = __errno_location();
  }
#line 1037
  if (*tmp___2 == 5) {
#line 1037
    if (archive >= 1 << 30) {
      {
#line 1037
      tmp___3 = rmt_ioctl__(archive - (1 << 30), (int )((unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16)),
                            (char *)(& operation));
#line 1037
      tmp___5 = tmp___3;
      }
    } else {
      {
#line 1037
      tmp___4 = ioctl(archive, (unsigned long )(((1U << 30) | (unsigned int )(109 << 8)) | 1U) | (sizeof(struct mtop ) << 16),
                      (char *)(& operation));
#line 1037
      tmp___5 = tmp___4;
      }
    }
#line 1037
    if (tmp___5 >= 0) {
#line 1038
      return;
    }
  }
#line 1043
  if (archive >= 1 << 30) {
    {
#line 1043
    tmp___6 = rmt_lseek__(archive - (1 << 30), (off_t )0, 1);
#line 1043
    tmp___8 = tmp___6;
    }
  } else {
    {
#line 1043
    tmp___7 = lseek(archive, (off_t )0, 1);
#line 1043
    tmp___8 = tmp___7;
    }
  }
#line 1043
  position = tmp___8;
#line 1047
  position -= record_end->buffer - record_start->buffer;
#line 1048
  if (position < 0L) {
#line 1049
    position = (off_t )0;
  }
#line 1050
  if (archive >= 1 << 30) {
    {
#line 1050
    tmp___10 = rmt_lseek__(archive - (1 << 30), position, 0);
#line 1050
    tmp___12 = tmp___10;
    }
  } else {
    {
#line 1050
    tmp___11 = lseek(archive, position, 0);
#line 1050
    tmp___12 = tmp___11;
    }
  }
#line 1050
  if (tmp___12 != position) {
    {
#line 1054
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1054
      if (error_hook) {
        {
#line 1054
        (*error_hook)();
        }
      }
      {
#line 1054
      tmp___9 = gettext("Cannot backspace archive file; it may be unreadable without -i");
#line 1054
      error(0, 0, (char const   *)tmp___9);
      }
#line 1054
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1059
    if ((unsigned long )(record_start->buffer) != (unsigned long )output_start) {
      {
#line 1060
      memset((void *)(record_start->buffer), 0, (size_t )(output_start - record_start->buffer));
      }
    }
  }
#line 1064
  return;
}
}
#line 1066 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
off_t seek_archive(off_t size ) 
{ 
  off_t start ;
  off_t tmp ;
  off_t offset ;
  off_t nrec ;
  off_t nblk ;
  off_t skipped ;
  off_t tmp___0 ;
  __off_t tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 1069
  tmp = current_block_ordinal();
#line 1069
  start = tmp;
#line 1072
  skipped = ((long )blocking_factor - (current_block - record_start)) * 512L;
  }
#line 1075
  if (size <= skipped) {
#line 1076
    return ((off_t )0);
  }
#line 1079
  nrec = (off_t )((size_t )(size - skipped) / record_size);
#line 1080
  if (nrec == 0L) {
#line 1081
    return ((off_t )0);
  }
#line 1082
  if (archive >= 1 << 30) {
    {
#line 1082
    tmp___0 = rmt_lseek__(archive - (1 << 30), (off_t )((size_t )nrec * record_size),
                          1);
#line 1082
    offset = tmp___0;
    }
  } else {
    {
#line 1082
    tmp___1 = lseek(archive, (__off_t )((size_t )nrec * record_size), 1);
#line 1082
    offset = tmp___1;
    }
  }
#line 1083
  if (offset < 0L) {
#line 1084
    return (offset);
  }
#line 1086
  if ((unsigned long )offset % record_size) {
    {
#line 1087
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1087
      if (error_hook) {
        {
#line 1087
        (*error_hook)();
        }
      }
      {
#line 1087
      tmp___2 = gettext("rmtlseek not stopped at a record boundary");
#line 1087
      error(0, 0, (char const   *)tmp___2);
#line 1087
      fatal_exit();
      }
#line 1087
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1090
  offset /= 512L;
#line 1092
  nblk = offset - start;
#line 1095
  records_read += nblk / (off_t )blocking_factor;
#line 1096
  record_start_block = offset - (off_t )blocking_factor;
#line 1097
  current_block = record_end;
#line 1099
  return (nblk);
}
}
#line 1103 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void close_archive(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1106
  if (time_to_start_writing) {
#line 1106
    goto _L;
  } else
#line 1106
  if ((unsigned int )access_mode == 1U) {
    _L: /* CIL Label */ 
    {
#line 1108
    flush_archive();
    }
#line 1109
    if ((unsigned long )current_block > (unsigned long )record_start) {
      {
#line 1110
      flush_archive();
      }
    }
  }
  {
#line 1113
  compute_duration();
  }
#line 1114
  if (verify_option) {
    {
#line 1115
    verify_volume();
    }
  }
#line 1117
  if (archive >= 1 << 30) {
    {
#line 1117
    tmp = rmt_close__(archive - (1 << 30));
#line 1117
    tmp___1 = tmp;
    }
  } else {
    {
#line 1117
    tmp___0 = close(archive);
#line 1117
    tmp___1 = tmp___0;
    }
  }
#line 1117
  if (tmp___1 != 0) {
    {
#line 1118
    close_error(*archive_name_cursor);
    }
  }
  {
#line 1120
  sys_wait_for_child(child_pid, hit_eof);
#line 1122
  tar_stat_destroy(& current_stat_info);
#line 1123
  free(record_buffer[0]);
#line 1124
  free(record_buffer[1]);
#line 1125
  bufmap_free((struct bufmap *)((void *)0));
  }
#line 1126
  return;
}
}
#line 1128
 __attribute__((__noreturn__)) void write_fatal_details(char const   *name , ssize_t status ,
                                                        size_t size ) ;
#line 1128 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void write_fatal_details(char const   *name , ssize_t status , size_t size ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1131
  write_error_details(name, (size_t )status, size);
  }
#line 1132
  if (archive >= 1 << 30) {
    {
#line 1132
    tmp = rmt_close__(archive - (1 << 30));
#line 1132
    tmp___1 = tmp;
    }
  } else {
    {
#line 1132
    tmp___0 = close(archive);
#line 1132
    tmp___1 = tmp___0;
    }
  }
#line 1132
  if (tmp___1 != 0) {
    {
#line 1133
    close_error(*archive_name_cursor);
    }
  }
  {
#line 1134
  sys_wait_for_child(child_pid, (_Bool)0);
#line 1135
  fatal_exit();
  }
}
}
#line 1139 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void init_volume_number(void) 
{ 
  FILE *file ;
  FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
  {
#line 1142
  tmp = fopen((char const   */* __restrict  */)volno_file_option, (char const   */* __restrict  */)"r");
#line 1142
  file = tmp;
  }
#line 1144
  if (file) {
    {
#line 1146
    tmp___2 = fscanf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d",
                     & global_volno);
    }
#line 1146
    if (tmp___2 != 1) {
#line 1146
      goto _L;
    } else
#line 1146
    if (global_volno < 0) {
      _L: /* CIL Label */ 
      {
#line 1148
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1148
        if (error_hook) {
          {
#line 1148
          (*error_hook)();
          }
        }
        {
#line 1148
        tmp___0 = quotearg_colon(volno_file_option);
#line 1148
        tmp___1 = gettext("%s: contains invalid volume number");
#line 1148
        error(0, 0, (char const   *)tmp___1, tmp___0);
#line 1148
        fatal_exit();
        }
#line 1148
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1150
    tmp___3 = ferror_unlocked(file);
    }
#line 1150
    if (tmp___3) {
      {
#line 1151
      read_error(volno_file_option);
      }
    }
    {
#line 1152
    tmp___4 = fclose(file);
    }
#line 1152
    if (tmp___4 != 0) {
      {
#line 1153
      close_error(volno_file_option);
      }
    }
  } else {
    {
#line 1155
    tmp___5 = __errno_location();
    }
#line 1155
    if (*tmp___5 != 2) {
      {
#line 1156
      open_error(volno_file_option);
      }
    }
  }
#line 1157
  return;
}
}
#line 1160 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void closeout_volume_number(void) 
{ 
  FILE *file ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1163
  tmp = fopen((char const   */* __restrict  */)volno_file_option, (char const   */* __restrict  */)"w");
#line 1163
  file = tmp;
  }
#line 1165
  if (file) {
    {
#line 1167
    fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"%d\n",
            global_volno);
#line 1168
    tmp___0 = ferror_unlocked(file);
    }
#line 1168
    if (tmp___0) {
      {
#line 1169
      write_error(volno_file_option);
      }
    }
    {
#line 1170
    tmp___1 = fclose(file);
    }
#line 1170
    if (tmp___1 != 0) {
      {
#line 1171
      close_error(volno_file_option);
      }
    }
  } else {
    {
#line 1174
    open_error(volno_file_option);
    }
  }
#line 1175
  return;
}
}
#line 1178 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void increase_volume_number(void) 
{ 
  char *tmp ;

  {
#line 1181
  global_volno ++;
#line 1182
  if (global_volno < 0) {
    {
#line 1183
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1183
      if (error_hook) {
        {
#line 1183
        (*error_hook)();
        }
      }
      {
#line 1183
      tmp = gettext("Volume number overflow");
#line 1183
      error(0, 0, (char const   *)tmp);
#line 1183
      fatal_exit();
      }
#line 1183
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1184
  volno ++;
#line 1185
  return;
}
}
#line 1187 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void change_tape_menu(FILE *read_file___0 ) 
{ 
  char *input_buffer ;
  size_t size ;
  _Bool stop ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  __ssize_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *name ;
  char *cursor ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 1190
  input_buffer = (char *)((void *)0);
#line 1191
  size = (size_t )0;
#line 1192
  stop = (_Bool)0;
  {
#line 1194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1194
    if (! (! stop)) {
#line 1194
      goto while_break;
    }
    {
#line 1196
    fputc_unlocked('\a', stderr);
#line 1197
    tmp = quote(*archive_name_cursor);
#line 1197
    tmp___0 = gettext("Prepare volume #%d for %s and hit return: ");
#line 1197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0,
            global_volno + 1, tmp);
#line 1200
    fflush_unlocked(stderr);
#line 1202
    tmp___3 = getline((char **/* __restrict  */)(& input_buffer), (size_t */* __restrict  */)(& size),
                      (FILE */* __restrict  */)read_file___0);
    }
#line 1202
    if (tmp___3 <= 0L) {
      {
#line 1204
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1204
        if (error_hook) {
          {
#line 1204
          (*error_hook)();
          }
        }
        {
#line 1204
        tmp___1 = gettext("EOF where user reply was expected");
#line 1204
        error(0, 0, (char const   *)tmp___1);
        }
#line 1204
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1206
      if ((unsigned int )subcommand_option != 6U) {
#line 1206
        if ((unsigned int )subcommand_option != 7U) {
#line 1206
          if ((unsigned int )subcommand_option != 5U) {
            {
#line 1209
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 1209
              if (error_hook) {
                {
#line 1209
                (*error_hook)();
                }
              }
              {
#line 1209
              tmp___2 = gettext("WARNING: Archive is incomplete");
#line 1209
              error(0, 0, (char const   *)tmp___2);
              }
#line 1209
              goto while_break___1;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
      }
      {
#line 1211
      fatal_exit();
      }
    }
#line 1214
    if ((int )*(input_buffer + 0) == 10) {
#line 1217
      goto while_break;
    } else
#line 1214
    if ((int )*(input_buffer + 0) == 121) {
#line 1217
      goto while_break;
    } else
#line 1214
    if ((int )*(input_buffer + 0) == 89) {
#line 1217
      goto while_break;
    }
    {
#line 1221
    if ((int )*(input_buffer + 0) == 63) {
#line 1221
      goto case_63;
    }
#line 1233
    if ((int )*(input_buffer + 0) == 113) {
#line 1233
      goto case_113;
    }
#line 1245
    if ((int )*(input_buffer + 0) == 110) {
#line 1245
      goto case_110;
    }
#line 1273
    if ((int )*(input_buffer + 0) == 33) {
#line 1273
      goto case_33;
    }
#line 1281
    goto switch_default;
    case_63: /* CIL Label */ 
    {
#line 1223
    tmp___4 = gettext(" n name        Give a new file name for the next (and subsequent) volume(s)\n q             Abort tar\n y or newline  Continue operation\n");
#line 1223
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4);
    }
#line 1227
    if (! restrict_option) {
      {
#line 1228
      tmp___5 = gettext(" !             Spawn a subshell\n");
#line 1228
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
      }
    }
    {
#line 1229
    tmp___6 = gettext(" ?             Print this list\n");
#line 1229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
    }
#line 1231
    goto switch_break;
    case_113: /* CIL Label */ 
    {
#line 1236
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1236
      if (error_hook) {
        {
#line 1236
        (*error_hook)();
        }
      }
      {
#line 1236
      tmp___7 = gettext("No new volume; exiting.\n");
#line 1236
      error(0, 0, (char const   *)tmp___7);
      }
#line 1236
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1238
    if ((unsigned int )subcommand_option != 6U) {
#line 1238
      if ((unsigned int )subcommand_option != 7U) {
#line 1238
        if ((unsigned int )subcommand_option != 5U) {
          {
#line 1241
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1241
            if (error_hook) {
              {
#line 1241
              (*error_hook)();
              }
            }
            {
#line 1241
            tmp___8 = gettext("WARNING: Archive is incomplete");
#line 1241
            error(0, 0, (char const   *)tmp___8);
            }
#line 1241
            goto while_break___3;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
    }
    {
#line 1243
    fatal_exit();
    }
    case_110: /* CIL Label */ 
#line 1252
    name = input_buffer + 1;
    {
#line 1252
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1252
      if (! ((int )*name == 32)) {
#line 1252
        if (! ((int )*name == 9)) {
#line 1252
          goto while_break___4;
        }
      }
#line 1252
      name ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1257
    cursor = name;
    {
#line 1257
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1257
      if (*cursor) {
#line 1257
        if (! ((int )*cursor != 10)) {
#line 1257
          goto while_break___5;
        }
      } else {
#line 1257
        goto while_break___5;
      }
#line 1257
      cursor ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1259
    *cursor = (char )'\000';
#line 1261
    if (*(name + 0)) {
      {
#line 1264
      tmp___9 = xstrdup((char const   *)name);
#line 1264
      *archive_name_cursor = (char const   *)tmp___9;
#line 1265
      stop = (_Bool)1;
      }
    } else {
      {
#line 1268
      tmp___10 = gettext("File name not specified. Try again.\n");
#line 1268
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
              tmp___10);
      }
    }
#line 1271
    goto switch_break;
    case_33: /* CIL Label */ 
#line 1274
    if (! restrict_option) {
      {
#line 1276
      sys_spawn_shell();
      }
#line 1277
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
    {
#line 1282
    tmp___11 = gettext("Invalid input. Type ? for help.\n");
#line 1282
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___11);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1285
  free((void *)input_buffer);
  }
#line 1286
  return;
}
}
#line 1294 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static FILE *read_file  ;
#line 1295 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static int looped  ;
#line 1291 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool new_volume(enum access_mode mode ) 
{ 
  int prompt ;
  FILE *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  void *tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  void *tmp___23 ;
  int tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  void *tmp___29 ;
  int tmp___30 ;

  {
#line 1298
  if (! read_file) {
#line 1298
    if (! info_script_option) {
#line 1300
      if (archive == 0) {
        {
#line 1300
        tmp = fopen((char const   */* __restrict  */)"/dev/tty", (char const   */* __restrict  */)"r");
#line 1300
        read_file = tmp;
        }
      } else {
#line 1300
        read_file = stdin;
      }
    }
  }
#line 1302
  if (now_verifying) {
#line 1303
    return ((_Bool)0);
  }
#line 1304
  if (verify_option) {
    {
#line 1305
    verify_volume();
    }
  }
  {
#line 1307
  assign_string(& volume_label, (char const   *)((void *)0));
#line 1308
  assign_string(& continued_file_name, (char const   *)((void *)0));
#line 1309
  continued_file_offset = (uintmax_t )0;
#line 1309
  continued_file_size = continued_file_offset;
#line 1310
  current_block = record_start;
  }
#line 1312
  if (archive >= 1 << 30) {
    {
#line 1312
    tmp___0 = rmt_close__(archive - (1 << 30));
#line 1312
    tmp___2 = tmp___0;
    }
  } else {
    {
#line 1312
    tmp___1 = close(archive);
#line 1312
    tmp___2 = tmp___1;
    }
  }
#line 1312
  if (tmp___2 != 0) {
    {
#line 1313
    close_error(*archive_name_cursor);
    }
  }
#line 1315
  archive_name_cursor ++;
#line 1316
  if ((unsigned long )archive_name_cursor == (unsigned long )(archive_name_array + archive_names)) {
#line 1318
    archive_name_cursor = archive_name_array;
#line 1319
    looped = 1;
  }
#line 1321
  prompt = looped;
  tryagain: 
#line 1324
  if (prompt) {
#line 1328
    if (info_script_option) {
#line 1330
      if (volno_file_option) {
        {
#line 1331
        closeout_volume_number();
        }
      }
      {
#line 1332
      tmp___5 = sys_exec_info_script(archive_name_cursor, global_volno + 1);
      }
#line 1332
      if (tmp___5) {
        {
#line 1333
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1333
          if (error_hook) {
            {
#line 1333
            (*error_hook)();
            }
          }
          {
#line 1333
          tmp___3 = quote(info_script_option);
#line 1333
          tmp___4 = gettext("%s command failed");
#line 1333
          error(0, 0, (char const   *)tmp___4, tmp___3);
#line 1333
          fatal_exit();
          }
#line 1333
          goto while_break;
        }
        while_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 1337
      change_tape_menu(read_file);
      }
    }
  }
  {
#line 1340
  tmp___30 = strcmp(*(archive_name_cursor + 0), "-");
  }
#line 1340
  if (tmp___30 == 0) {
#line 1342
    read_full_records = (_Bool)1;
#line 1343
    archive = 0;
  } else
#line 1345
  if (verify_option) {
#line 1346
    if (! force_local_option) {
      {
#line 1346
      tmp___10 = strchr(*archive_name_cursor, ':');
#line 1346
      rmt_dev_name__ = (char const   *)tmp___10;
      }
#line 1346
      if (rmt_dev_name__) {
#line 1346
        if ((unsigned long )rmt_dev_name__ > (unsigned long )*archive_name_cursor) {
          {
#line 1346
          tmp___11 = memchr((void const   *)*archive_name_cursor, '/', (size_t )(rmt_dev_name__ - *archive_name_cursor));
          }
#line 1346
          if (tmp___11) {
            {
#line 1346
            tmp___9 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1346
            archive = tmp___9;
            }
          } else {
            {
#line 1346
            tmp___8 = rmt_open__(*archive_name_cursor, 66, 1 << 30, rsh_command_option);
#line 1346
            archive = tmp___8;
            }
          }
        } else {
          {
#line 1346
          tmp___9 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1346
          archive = tmp___9;
          }
        }
      } else {
        {
#line 1346
        tmp___9 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1346
        archive = tmp___9;
        }
      }
    } else {
      {
#line 1346
      tmp___9 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1346
      archive = tmp___9;
      }
    }
  } else {
    {
#line 1351
    if ((unsigned int )mode == 0U) {
#line 1351
      goto case_0;
    }
#line 1357
    if ((unsigned int )mode == 1U) {
#line 1357
      goto case_1;
    }
#line 1364
    if ((unsigned int )mode == 2U) {
#line 1364
      goto case_2;
    }
#line 1349
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1352
    if (! force_local_option) {
      {
#line 1352
      tmp___16 = strchr(*archive_name_cursor, ':');
#line 1352
      rmt_dev_name__ = (char const   *)tmp___16;
      }
#line 1352
      if (rmt_dev_name__) {
#line 1352
        if ((unsigned long )rmt_dev_name__ > (unsigned long )*archive_name_cursor) {
          {
#line 1352
          tmp___17 = memchr((void const   *)*archive_name_cursor, '/', (size_t )(rmt_dev_name__ - *archive_name_cursor));
          }
#line 1352
          if (tmp___17) {
            {
#line 1352
            tmp___15 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1352
            archive = tmp___15;
            }
          } else {
            {
#line 1352
            tmp___14 = rmt_open__(*archive_name_cursor, 0, 1 << 30, rsh_command_option);
#line 1352
            archive = tmp___14;
            }
          }
        } else {
          {
#line 1352
          tmp___15 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1352
          archive = tmp___15;
          }
        }
      } else {
        {
#line 1352
        tmp___15 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1352
        archive = tmp___15;
        }
      }
    } else {
      {
#line 1352
      tmp___15 = open(*archive_name_cursor, 0, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1352
      archive = tmp___15;
      }
    }
    {
#line 1354
    guess_seekable_archive();
    }
#line 1355
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1358
    if (backup_option) {
      {
#line 1359
      maybe_backup_file(*archive_name_cursor, (_Bool)1);
      }
    }
#line 1360
    if (! force_local_option) {
      {
#line 1360
      tmp___22 = strchr(*archive_name_cursor, ':');
#line 1360
      rmt_dev_name__ = (char const   *)tmp___22;
      }
#line 1360
      if (rmt_dev_name__) {
#line 1360
        if ((unsigned long )rmt_dev_name__ > (unsigned long )*archive_name_cursor) {
          {
#line 1360
          tmp___23 = memchr((void const   *)*archive_name_cursor, '/', (size_t )(rmt_dev_name__ - *archive_name_cursor));
          }
#line 1360
          if (tmp___23) {
            {
#line 1360
            tmp___21 = creat(*archive_name_cursor, (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1360
            archive = tmp___21;
            }
          } else {
            {
#line 1360
            tmp___20 = rmt_open__(*archive_name_cursor, 65, 1 << 30, rsh_command_option);
#line 1360
            archive = tmp___20;
            }
          }
        } else {
          {
#line 1360
          tmp___21 = creat(*archive_name_cursor, (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1360
          archive = tmp___21;
          }
        }
      } else {
        {
#line 1360
        tmp___21 = creat(*archive_name_cursor, (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1360
        archive = tmp___21;
        }
      }
    } else {
      {
#line 1360
      tmp___21 = creat(*archive_name_cursor, (mode_t )(((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3))));
#line 1360
      archive = tmp___21;
      }
    }
#line 1362
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1365
    if (! force_local_option) {
      {
#line 1365
      tmp___28 = strchr(*archive_name_cursor, ':');
#line 1365
      rmt_dev_name__ = (char const   *)tmp___28;
      }
#line 1365
      if (rmt_dev_name__) {
#line 1365
        if ((unsigned long )rmt_dev_name__ > (unsigned long )*archive_name_cursor) {
          {
#line 1365
          tmp___29 = memchr((void const   *)*archive_name_cursor, '/', (size_t )(rmt_dev_name__ - *archive_name_cursor));
          }
#line 1365
          if (tmp___29) {
            {
#line 1365
            tmp___27 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1365
            archive = tmp___27;
            }
          } else {
            {
#line 1365
            tmp___26 = rmt_open__(*archive_name_cursor, 66, 1 << 30, rsh_command_option);
#line 1365
            archive = tmp___26;
            }
          }
        } else {
          {
#line 1365
          tmp___27 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1365
          archive = tmp___27;
          }
        }
      } else {
        {
#line 1365
        tmp___27 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1365
        archive = tmp___27;
        }
      }
    } else {
      {
#line 1365
      tmp___27 = open(*archive_name_cursor, 66, ((128 | (128 >> 3)) | ((128 >> 3) >> 3)) | ((256 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 1365
      archive = tmp___27;
      }
    }
#line 1367
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1370
  if (archive < 0) {
    {
#line 1372
    open_warn(*archive_name_cursor);
    }
#line 1373
    if (! verify_option) {
#line 1373
      if ((unsigned int )mode == 1U) {
#line 1373
        if (backup_option) {
          {
#line 1374
          undo_last_backup();
          }
        }
      }
    }
#line 1375
    prompt = 1;
#line 1376
    goto tryagain;
  }
#line 1381
  return ((_Bool)1);
}
}
#line 1384 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool read_header0(struct tar_stat_info *info ) 
{ 
  enum read_header rc ;
  char *tmp ;

  {
  {
#line 1389
  tar_stat_init(info);
#line 1390
  rc = read_header(& current_header, info, (enum read_header_mode )0);
  }
#line 1391
  if ((unsigned int )rc == 1U) {
    {
#line 1393
    set_next_block_after(current_header);
    }
#line 1394
    return ((_Bool)1);
  }
  {
#line 1396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1396
    if (error_hook) {
      {
#line 1396
      (*error_hook)();
      }
    }
    {
#line 1396
    tmp = gettext("This does not look like a tar archive");
#line 1396
    error(0, 0, (char const   *)tmp);
#line 1396
    exit_status = 2;
    }
#line 1396
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1397
  return ((_Bool)0);
}
}
#line 1400 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool try_new_volume(void) 
{ 
  size_t status ;
  union block *header ;
  enum access_mode acc ;
  _Bool tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  enum read_header tmp___4 ;
  enum read_header tmp___5 ;
  char *tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  uintmax_t s ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char totsizebuf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char s1buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char s2buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  char totsizebuf___0[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char s1buf___0[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char s2buf___0[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;

  {
  {
#line 1411
  if ((unsigned int )subcommand_option == 8U) {
#line 1411
    goto case_8;
  }
#line 1411
  if ((unsigned int )subcommand_option == 2U) {
#line 1411
    goto case_8;
  }
#line 1411
  if ((unsigned int )subcommand_option == 1U) {
#line 1411
    goto case_8;
  }
#line 1415
  goto switch_default;
  case_8: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 1412
  acc = (enum access_mode )2;
#line 1413
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1416
  acc = (enum access_mode )0;
#line 1417
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1420
  tmp = new_volume(acc);
  }
#line 1420
  if (! tmp) {
#line 1421
    return ((_Bool)1);
  }
  {
#line 1423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1423
    if (archive >= 1 << 30) {
      {
#line 1423
      tmp___0 = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
#line 1423
      status = tmp___0;
      }
    } else {
      {
#line 1423
      tmp___1 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 1423
      status = tmp___1;
      }
    }
#line 1423
    if (! (status == 0xffffffffffffffffUL)) {
#line 1423
      goto while_break;
    }
    {
#line 1425
    archive_read_error();
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1427
  if (status != record_size) {
    {
#line 1428
    short_read(status);
    }
  }
  {
#line 1430
  header = find_next_block();
  }
#line 1431
  if (! header) {
    {
#line 1433
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1433
      if (error_hook) {
        {
#line 1433
        (*error_hook)();
        }
      }
      {
#line 1433
      tmp___2 = gettext("This does not look like a tar archive");
#line 1433
      error(0, 0, (char const   *)tmp___2);
      }
#line 1433
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1434
    return ((_Bool)0);
  }
  {
#line 1439
  if ((int )header->header.typeflag == 103) {
#line 1439
    goto case_103;
  }
#line 1480
  if ((int )header->header.typeflag == 86) {
#line 1480
    goto case_86;
  }
#line 1491
  if ((int )header->header.typeflag == 77) {
#line 1491
    goto case_77;
  }
#line 1502
  goto switch_default___1;
  case_103: /* CIL Label */ 
  {
#line 1441
  tar_stat_init(& dummy);
#line 1442
  tmp___4 = read_header(& header, & dummy, (enum read_header_mode )2);
  }
#line 1442
  if ((unsigned int )tmp___4 != 2U) {
    {
#line 1445
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1445
      if (error_hook) {
        {
#line 1445
        (*error_hook)();
        }
      }
      {
#line 1445
      tmp___3 = gettext("This does not look like a tar archive");
#line 1445
      error(0, 0, (char const   *)tmp___3);
      }
#line 1445
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1446
    return ((_Bool)0);
  }
  {
#line 1449
  xheader_decode(& dummy);
#line 1450
  tar_stat_destroy(& dummy);
#line 1464
  tmp___5 = read_header(& header, & dummy, (enum read_header_mode )0);
  }
  {
#line 1466
  if ((unsigned int )tmp___5 == 1U) {
#line 1466
    goto case_1___0;
  }
#line 1470
  if ((unsigned int )tmp___5 == 5U) {
#line 1470
    goto case_5;
  }
#line 1473
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 1467
  set_next_block_after(header);
  }
#line 1468
  goto switch_break___1;
  case_5: /* CIL Label */ 
#line 1471
  goto switch_break___1;
  switch_default___0: /* CIL Label */ 
  {
#line 1474
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1474
    if (error_hook) {
      {
#line 1474
      (*error_hook)();
      }
    }
    {
#line 1474
    tmp___6 = gettext("This does not look like a tar archive");
#line 1474
    error(0, 0, (char const   *)tmp___6);
    }
#line 1474
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1475
  return ((_Bool)0);
  switch_break___1: /* CIL Label */ ;
  }
#line 1477
  goto switch_break___0;
  case_86: /* CIL Label */ 
  {
#line 1481
  tmp___7 = read_header0(& dummy);
  }
#line 1481
  if (! tmp___7) {
#line 1482
    return ((_Bool)0);
  }
  {
#line 1483
  tar_stat_destroy(& dummy);
#line 1484
  assign_string(& volume_label, (char const   *)(current_header->header.name));
#line 1485
  set_next_block_after(header);
#line 1486
  header = find_next_block();
  }
#line 1487
  if ((int )header->header.typeflag != 77) {
#line 1488
    goto switch_break___0;
  }
  case_77: /* CIL Label */ 
  {
#line 1492
  tmp___8 = read_header0(& dummy);
  }
#line 1492
  if (! tmp___8) {
#line 1493
    return ((_Bool)0);
  }
  {
#line 1494
  tar_stat_destroy(& dummy);
#line 1495
  assign_string(& continued_file_name, (char const   *)(current_header->header.name));
#line 1496
  continued_file_size = uintmax_from_header((char const   *)(current_header->header.size),
                                            sizeof(current_header->header.size));
#line 1498
  continued_file_offset = uintmax_from_header((char const   *)(current_header->oldgnu_header.offset),
                                              sizeof(current_header->oldgnu_header.offset));
  }
#line 1500
  goto switch_break___0;
  switch_default___1: /* CIL Label */ 
#line 1503
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 1506
  if (bufmap_head) {
#line 1509
    if (! continued_file_name) {
      {
#line 1511
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1511
        if (error_hook) {
          {
#line 1511
          (*error_hook)();
          }
        }
        {
#line 1511
        tmp___9 = quote((char const   *)bufmap_head->file_name);
#line 1511
        tmp___10 = gettext("%s is not continued on this volume");
#line 1511
        error(0, 0, (char const   *)tmp___10, tmp___9);
        }
#line 1511
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1513
      return ((_Bool)0);
    }
    {
#line 1516
    tmp___17 = strcmp((char const   *)continued_file_name, (char const   *)bufmap_head->file_name);
    }
#line 1516
    if (tmp___17) {
#line 1518
      if ((unsigned int )archive_format == 6U) {
#line 1518
        goto _L___1;
      } else
#line 1518
      if ((unsigned int )archive_format == 2U) {
        _L___1: /* CIL Label */ 
        {
#line 1518
        tmp___15 = strlen((char const   *)bufmap_head->file_name);
        }
#line 1518
        if (tmp___15 >= 100UL) {
          {
#line 1518
          tmp___16 = strncmp((char const   *)continued_file_name, (char const   *)bufmap_head->file_name,
                             (size_t )100);
          }
#line 1518
          if (tmp___16 == 0) {
            {
#line 1522
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1522
              if (error_hook) {
                {
#line 1522
                (*error_hook)();
                }
              }
              {
#line 1522
              tmp___11 = quote((char const   *)bufmap_head->file_name);
#line 1522
              tmp___12 = gettext("%s is possibly continued on this volume: header contains truncated name");
#line 1522
              error(0, 0, (char const   *)tmp___12, tmp___11);
              }
#line 1522
              goto while_break___4;
            }
            while_break___4: /* CIL Label */ ;
            }
          } else {
#line 1518
            goto _L___0;
          }
        } else {
#line 1518
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 1527
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1527
          if (error_hook) {
            {
#line 1527
            (*error_hook)();
            }
          }
          {
#line 1527
          tmp___13 = quote((char const   *)bufmap_head->file_name);
#line 1527
          tmp___14 = gettext("%s is not continued on this volume");
#line 1527
          error(0, 0, (char const   *)tmp___14, tmp___13);
          }
#line 1527
          goto while_break___5;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1529
        return ((_Bool)0);
      }
    }
#line 1533
    s = continued_file_size + continued_file_offset;
#line 1535
    if ((uintmax_t )bufmap_head->sizetotal != s) {
#line 1535
      goto _L___2;
    } else
#line 1535
    if (s < continued_file_offset) {
      _L___2: /* CIL Label */ 
      {
#line 1541
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1541
        if (error_hook) {
          {
#line 1541
          (*error_hook)();
          }
        }
        {
#line 1541
        tmp___18 = umaxtostr(continued_file_offset, s2buf);
#line 1541
        tmp___19 = umaxtostr(continued_file_size, s1buf);
#line 1541
        tmp___20 = umaxtostr((uintmax_t )bufmap_head->sizetotal, totsizebuf);
#line 1541
        tmp___21 = quote((char const   *)continued_file_name);
#line 1541
        tmp___22 = gettext("%s is the wrong size (%s != %s + %s)");
#line 1541
        error(0, 0, (char const   *)tmp___22, tmp___21, tmp___20, tmp___19, tmp___18);
        }
#line 1541
        goto while_break___6;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1546
      return ((_Bool)0);
    }
#line 1549
    if ((uintmax_t )(bufmap_head->sizetotal - bufmap_head->sizeleft) != continued_file_offset) {
      {
#line 1556
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1556
        if (error_hook) {
          {
#line 1556
          (*error_hook)();
          }
        }
        {
#line 1556
        tmp___23 = umaxtostr(continued_file_offset, s2buf___0);
#line 1556
        tmp___24 = umaxtostr((uintmax_t )bufmap_head->sizeleft, s1buf___0);
#line 1556
        tmp___25 = umaxtostr((uintmax_t )bufmap_head->sizetotal, totsizebuf___0);
#line 1556
        tmp___26 = gettext("This volume is out of sequence (%s - %s != %s)");
#line 1556
        error(0, 0, (char const   *)tmp___26, tmp___25, tmp___24, tmp___23);
        }
#line 1556
        goto while_break___7;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1561
      return ((_Bool)0);
    }
  }
  {
#line 1565
  increase_volume_number();
  }
#line 1566
  return ((_Bool)1);
}
}
#line 1573 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
char *drop_volume_label_suffix(char const   *label ) 
{ 
  char const   *p ;
  size_t len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char *s ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 1577
  tmp = strlen(label);
#line 1577
  len = tmp;
  }
#line 1579
  if (len < 1UL) {
#line 1580
    return ((char *)((void *)0));
  }
#line 1582
  p = (label + len) - 1;
  {
#line 1582
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1582
    if ((unsigned long )p > (unsigned long )label) {
      {
#line 1582
      tmp___0 = __ctype_b_loc();
      }
#line 1582
      if (! ((int const   )*(*tmp___0 + (int )((unsigned char )*p)) & 2048)) {
#line 1582
        goto while_break;
      }
    } else {
#line 1582
      goto while_break;
    }
#line 1582
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1584
  if ((unsigned long )p > (unsigned long )label) {
#line 1584
    if ((unsigned long )(p - ((sizeof(" Volume ") - 1UL) - 1UL)) > (unsigned long )label) {
      {
#line 1586
      p -= (sizeof(" Volume ") - 1UL) - 1UL;
#line 1587
      tmp___2 = memcmp((void const   *)p, (void const   *)" Volume ", sizeof(" Volume ") - 1UL);
      }
#line 1587
      if (tmp___2 == 0) {
        {
#line 1589
        len = (size_t )(p - label);
#line 1589
        tmp___1 = xmalloc(len + 1UL);
#line 1589
        s = (char *)tmp___1;
#line 1590
        memcpy((void */* __restrict  */)s, (void const   */* __restrict  */)label,
               len);
#line 1591
        *(s + len) = (char)0;
        }
#line 1592
        return (s);
      }
    }
  }
#line 1596
  return ((char *)((void *)0));
}
}
#line 1603 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static _Bool check_label_pattern(char const   *label ) 
{ 
  char *string ;
  _Bool result ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1607
  result = (_Bool)0;
#line 1609
  tmp = fnmatch(volume_label_option, label, 0);
  }
#line 1609
  if (tmp == 0) {
#line 1610
    return ((_Bool)1);
  }
#line 1612
  if (! multi_volume_option) {
#line 1613
    return ((_Bool)0);
  }
  {
#line 1615
  string = drop_volume_label_suffix(label);
  }
#line 1616
  if (string) {
    {
#line 1618
    tmp___0 = fnmatch((char const   *)string, volume_label_option, 0);
#line 1618
    result = (_Bool )(tmp___0 == 0);
#line 1619
    free((void *)string);
    }
  }
#line 1621
  return (result);
}
}
#line 1626 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void match_volume_label(void) 
{ 
  union block *label ;
  union block *tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  struct tar_stat_info st ;
  off_t tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  _Bool tmp___10 ;

  {
#line 1629
  if (! volume_label) {
    {
#line 1631
    tmp = find_next_block();
#line 1631
    label = tmp;
    }
#line 1633
    if (! label) {
      {
#line 1634
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1634
        if (error_hook) {
          {
#line 1634
          (*error_hook)();
          }
        }
        {
#line 1634
        tmp___0 = quote(volume_label_option);
#line 1634
        tmp___1 = gettext("Archive not labeled to match %s");
#line 1634
        error(0, 0, (char const   *)tmp___1, tmp___0);
#line 1634
        fatal_exit();
        }
#line 1634
        goto while_break;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1636
    if ((int )label->header.typeflag == 86) {
      {
#line 1638
      tmp___3 = memchr((void const   *)(label->header.name), '\000', sizeof(label->header.name));
      }
#line 1638
      if (tmp___3) {
        {
#line 1639
        assign_string(& volume_label, (char const   *)(label->header.name));
        }
      } else {
        {
#line 1642
        tmp___2 = xmalloc(sizeof(label->header.name) + 1UL);
#line 1642
        volume_label = (char *)tmp___2;
#line 1643
        memcpy((void */* __restrict  */)volume_label, (void const   */* __restrict  */)(label->header.name),
               sizeof(label->header.name));
#line 1645
        *(volume_label + sizeof(label->header.name)) = (char)0;
        }
      }
    } else
#line 1648
    if ((int )label->header.typeflag == 103) {
      {
#line 1651
      tar_stat_init(& st);
#line 1652
      tmp___4 = off_from_header((char const   *)(label->header.size), sizeof(label->header.size));
#line 1652
      xheader_read(& st.xhdr, label, tmp___4);
#line 1654
      xheader_decode(& st);
#line 1655
      tar_stat_destroy(& st);
      }
    }
  }
#line 1659
  if (! volume_label) {
    {
#line 1660
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1660
      if (error_hook) {
        {
#line 1660
        (*error_hook)();
        }
      }
      {
#line 1660
      tmp___5 = quote(volume_label_option);
#line 1660
      tmp___6 = gettext("Archive not labeled to match %s");
#line 1660
      error(0, 0, (char const   *)tmp___6, tmp___5);
#line 1660
      fatal_exit();
      }
#line 1660
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 1663
  tmp___10 = check_label_pattern((char const   *)volume_label);
  }
#line 1663
  if (! tmp___10) {
    {
#line 1664
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1664
      if (error_hook) {
        {
#line 1664
        (*error_hook)();
        }
      }
      {
#line 1664
      tmp___7 = quote_n(1, volume_label_option);
#line 1664
      tmp___8 = quote_n(0, (char const   *)volume_label);
#line 1664
      tmp___9 = gettext("Volume %s does not match %s");
#line 1664
      error(0, 0, (char const   *)tmp___9, tmp___8, tmp___7);
#line 1664
      fatal_exit();
      }
#line 1664
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1667
  return;
}
}
#line 1670 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void _write_volume_label(char const   *str ) 
{ 
  union block *label ;
  union block *tmp ;

  {
#line 1673
  if ((unsigned int )archive_format == 4U) {
    {
#line 1674
    xheader_store("GNU.volume.label", & dummy, (void const   *)str);
    }
  } else {
    {
#line 1677
    tmp = find_next_block();
#line 1677
    label = tmp;
#line 1679
    memset((void *)label, 0, (size_t )512);
#line 1681
    strcpy((char */* __restrict  */)(label->header.name), (char const   */* __restrict  */)str);
#line 1682
    assign_string(& current_stat_info.file_name, (char const   *)(label->header.name));
#line 1684
    current_stat_info.had_trailing_slash = strip_trailing_slashes(current_stat_info.file_name);
#line 1687
    label->header.typeflag = (char )'V';
#line 1688
    time_to_chars(start_time.tv_sec, label->header.mtime, sizeof(label->header.mtime));
#line 1689
    finish_header(& current_stat_info, label, (off_t )-1);
#line 1690
    set_next_block_after(label);
    }
  }
#line 1692
  return;
}
}
#line 1697 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void add_volume_label(void) 
{ 
  char buf[((sizeof(uintmax_t ) * 8UL) * 146UL + 484UL) / 485UL + 1UL] ;
  char *p ;
  char *tmp ;
  char *s ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1701
  tmp = umaxtostr((uintmax_t )volno, buf);
#line 1701
  p = tmp;
#line 1702
  tmp___0 = strlen(volume_label_option);
#line 1702
  tmp___1 = strlen((char const   *)p);
#line 1702
  tmp___2 = xmalloc(((tmp___0 + sizeof("Volume")) + tmp___1) + 2UL);
#line 1702
  s = (char *)tmp___2;
#line 1704
  sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"%s %s %s",
          volume_label_option, "Volume", p);
#line 1705
  _write_volume_label((char const   *)s);
#line 1706
  free((void *)s);
  }
#line 1707
  return;
}
}
#line 1709 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void add_chunk_header(struct bufmap *map ) 
{ 
  off_t block_ordinal ;
  union block *blk ;
  struct tar_stat_info st ;

  {
#line 1712
  if ((unsigned int )archive_format == 4U) {
    {
#line 1718
    memset((void *)(& st), 0, sizeof(st));
#line 1719
    st.file_name = map->file_name;
#line 1719
    st.orig_file_name = st.file_name;
#line 1720
    st.stat.st_mode = (__mode_t )((33152 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 1721
    st.stat.st_uid = getuid();
#line 1722
    st.stat.st_gid = getgid();
#line 1723
    st.orig_file_name = xheader_format_name(& st, "%d/GNUFileParts.%p/%f.%n", (size_t )volno);
#line 1726
    st.file_name = st.orig_file_name;
#line 1727
    st.stat.st_size = map->sizeleft;
#line 1727
    st.archive_file_size = st.stat.st_size;
#line 1729
    block_ordinal = current_block_ordinal();
#line 1730
    blk = start_header(& st);
    }
#line 1731
    if (! blk) {
      {
#line 1732
      abort();
      }
    }
    {
#line 1733
    finish_header(& st, blk, block_ordinal);
#line 1734
    free((void *)st.orig_file_name);
    }
  }
#line 1736
  return;
}
}
#line 1740 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void write_volume_label(void) 
{ 


  {
#line 1743
  if (multi_volume_option) {
    {
#line 1744
    add_volume_label();
    }
  } else {
    {
#line 1746
    _write_volume_label(volume_label_option);
    }
  }
#line 1747
  return;
}
}
#line 1750 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void gnu_add_multi_volume_header(struct bufmap *map ) 
{ 
  int tmp ;
  union block *block ;
  union block *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 1754
  tmp___0 = find_next_block();
#line 1754
  block = tmp___0;
#line 1756
  tmp___3 = strlen((char const   *)map->file_name);
  }
#line 1756
  if (tmp___3 > 100UL) {
    {
#line 1757
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1757
      if (error_hook) {
        {
#line 1757
        (*error_hook)();
        }
      }
      {
#line 1757
      tmp___1 = quotearg_colon((char const   *)map->file_name);
#line 1757
      tmp___2 = gettext("%s: file name too long to be stored in a GNU multivolume header, truncated");
#line 1757
      error(0, 0, (char const   *)tmp___2, tmp___1);
      }
#line 1757
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1761
  memset((void *)block, 0, (size_t )512);
#line 1763
  strncpy((char */* __restrict  */)(block->header.name), (char const   */* __restrict  */)map->file_name,
          (size_t )100);
#line 1764
  block->header.typeflag = (char )'M';
#line 1766
  off_to_chars(map->sizeleft, block->header.size, sizeof(block->header.size));
#line 1767
  off_to_chars(map->sizetotal - map->sizeleft, block->oldgnu_header.offset, sizeof(block->oldgnu_header.offset));
#line 1770
  tmp = verbose_option;
#line 1771
  verbose_option = 0;
#line 1772
  finish_header(& current_stat_info, block, (off_t )-1);
#line 1773
  verbose_option = tmp;
#line 1774
  set_next_block_after(block);
  }
#line 1775
  return;
}
}
#line 1779 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void add_multi_volume_header(struct bufmap *map ) 
{ 
  off_t d ;

  {
#line 1782
  if ((unsigned int )archive_format == 4U) {
    {
#line 1784
    d = map->sizetotal - map->sizeleft;
#line 1785
    xheader_store("GNU.volume.filename", & dummy, (void const   *)map->file_name);
#line 1786
    xheader_store("GNU.volume.size", & dummy, (void const   *)(& map->sizeleft));
#line 1787
    xheader_store("GNU.volume.offset", & dummy, (void const   *)(& d));
    }
  } else {
    {
#line 1790
    gnu_add_multi_volume_header(map);
    }
  }
#line 1791
  return;
}
}
#line 1797 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void simple_flush_read(void) 
{ 
  size_t status ;
  size_t tmp ;
  size_t tmp___0 ;

  {
  {
#line 1802
  checkpoint_run((_Bool)0);
#line 1807
  read_error_count = 0;
  }
#line 1809
  if (write_archive_to_stdout) {
#line 1809
    if (record_start_block != 0L) {
      {
#line 1811
      archive = 1;
#line 1812
      status = sys_write_archive_buffer();
#line 1813
      archive = 0;
      }
#line 1814
      if (status != record_size) {
        {
#line 1815
        archive_write_error((ssize_t )status);
        }
      }
    }
  }
  {
#line 1818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1820
    if (archive >= 1 << 30) {
      {
#line 1820
      tmp = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
#line 1820
      status = tmp;
      }
    } else {
      {
#line 1820
      tmp___0 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 1820
      status = tmp___0;
      }
    }
#line 1821
    if (status == record_size) {
#line 1823
      records_read ++;
#line 1824
      return;
    }
#line 1826
    if (status == 0xffffffffffffffffUL) {
      {
#line 1828
      archive_read_error();
      }
#line 1829
      goto __Cont;
    }
#line 1831
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1833
  short_read(status);
  }
#line 1834
  return;
}
}
#line 1837 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void simple_flush_write(size_t level  __attribute__((__unused__)) ) 
{ 
  ssize_t status ;

  {
  {
#line 1842
  status = _flush_write();
  }
#line 1843
  if ((size_t )status != record_size) {
    {
#line 1844
    archive_write_error(status);
    }
  } else {
#line 1847
    records_written ++;
#line 1848
    bytes_written += (tarlong )status;
  }
#line 1850
  return;
}
}
#line 1856 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void _gnu_flush_read(void) 
{ 
  size_t status ;
  size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 1861
  checkpoint_run((_Bool)0);
#line 1866
  read_error_count = 0;
  }
#line 1868
  if (write_archive_to_stdout) {
#line 1868
    if (record_start_block != 0L) {
      {
#line 1870
      archive = 1;
#line 1871
      status = sys_write_archive_buffer();
#line 1872
      archive = 0;
      }
#line 1873
      if (status != record_size) {
        {
#line 1874
        archive_write_error((ssize_t )status);
        }
      }
    }
  }
  {
#line 1877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1879
    if (archive >= 1 << 30) {
      {
#line 1879
      tmp = rmt_read__(archive - (1 << 30), record_start->buffer, record_size);
#line 1879
      status = tmp;
      }
    } else {
      {
#line 1879
      tmp___0 = safe_read(archive, (void *)(record_start->buffer), record_size);
#line 1879
      status = tmp___0;
      }
    }
#line 1880
    if (status == record_size) {
#line 1882
      records_read ++;
#line 1883
      return;
    }
#line 1891
    if (status == 0UL) {
#line 1891
      goto _L___0;
    } else
#line 1891
    if (status == 0xffffffffffffffffUL) {
      {
#line 1891
      tmp___2 = __errno_location();
      }
#line 1891
      if (*tmp___2 == 28) {
        _L___0: /* CIL Label */ 
#line 1891
        if (multi_volume_option) {
          {
#line 1895
          while (1) {
            while_continue___0: /* CIL Label */ ;
            {
#line 1895
            tmp___1 = try_new_volume();
            }
#line 1895
            if (tmp___1) {
#line 1895
              goto while_break___0;
            }
          }
          while_break___0: /* CIL Label */ ;
          }
#line 1897
          if ((unsigned long )current_block == (unsigned long )record_end) {
            {
#line 1899
            flush_archive();
            }
          }
#line 1900
          return;
        } else {
#line 1891
          goto _L___1;
        }
      } else {
#line 1891
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 1902
    if (status == 0xffffffffffffffffUL) {
      {
#line 1904
      archive_read_error();
      }
#line 1905
      goto __Cont;
    }
#line 1907
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1909
  short_read(status);
  }
#line 1910
  return;
}
}
#line 1912 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void gnu_flush_read(void) 
{ 


  {
  {
#line 1915
  flush_read_ptr = & simple_flush_read;
#line 1916
  _gnu_flush_read();
#line 1917
  flush_read_ptr = & gnu_flush_read;
  }
#line 1918
  return;
}
}
#line 1920 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void _gnu_flush_write(size_t buffer_level ) 
{ 
  ssize_t status ;
  union block *header ;
  char *copy_ptr ;
  size_t copy_size ;
  size_t bufsize ;
  struct bufmap *map ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  union block *tmp___4 ;

  {
  {
#line 1930
  status = _flush_write();
  }
#line 1931
  if ((size_t )status != record_size) {
#line 1931
    if (! multi_volume_option) {
      {
#line 1932
      archive_write_error(status);
      }
    } else {
#line 1931
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1935
    if (status) {
#line 1936
      records_written ++;
    }
#line 1937
    bytes_written += (tarlong )status;
  }
#line 1940
  if ((size_t )status == record_size) {
#line 1942
    return;
  }
  {
#line 1945
  map = bufmap_locate((size_t )status);
  }
#line 1947
  if (status % 512L) {
    {
#line 1949
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1949
      if (error_hook) {
        {
#line 1949
        (*error_hook)();
        }
      }
      {
#line 1949
      tmp = gettext("write did not end on a block boundary");
#line 1949
      error(0, 0, (char const   *)tmp);
#line 1949
      exit_status = 2;
      }
#line 1949
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1950
    archive_write_error(status);
    }
  }
#line 1955
  if (status < 0L) {
    {
#line 1955
    tmp___0 = __errno_location();
    }
#line 1955
    if (*tmp___0 != 28) {
      {
#line 1955
      tmp___1 = __errno_location();
      }
#line 1955
      if (*tmp___1 != 5) {
        {
#line 1955
        tmp___2 = __errno_location();
        }
#line 1955
        if (*tmp___2 != 6) {
          {
#line 1956
          archive_write_error(status);
          }
        }
      }
    }
  }
  {
#line 1958
  tmp___3 = new_volume((enum access_mode )1);
  }
#line 1958
  if (! tmp___3) {
#line 1959
    return;
  }
  {
#line 1961
  tar_stat_destroy(& dummy);
#line 1963
  increase_volume_number();
#line 1964
  prev_written += bytes_written;
#line 1965
  bytes_written = (tarlong )0;
#line 1967
  copy_ptr = record_start->buffer + status;
#line 1968
  copy_size = buffer_level - (size_t )status;
#line 1971
  record_index = ! record_index;
#line 1972
  init_buffer();
#line 1974
  inhibit_map = 1;
  }
#line 1976
  if (volume_label_option) {
    {
#line 1977
    add_volume_label();
    }
  }
#line 1979
  if (map) {
    {
#line 1980
    add_multi_volume_header(map);
    }
  }
  {
#line 1982
  tmp___4 = find_next_block();
#line 1982
  write_extended((_Bool)1, & dummy, tmp___4);
#line 1983
  tar_stat_destroy(& dummy);
  }
#line 1985
  if (map) {
    {
#line 1986
    add_chunk_header(map);
    }
  }
  {
#line 1987
  header = find_next_block();
#line 1988
  bufmap_reset(map, header - record_start);
#line 1989
  bufsize = available_space_after(header);
#line 1990
  inhibit_map = 0;
  }
  {
#line 1991
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1991
    if (! (bufsize < copy_size)) {
#line 1991
      goto while_break___0;
    }
    {
#line 1993
    memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)copy_ptr,
           bufsize);
#line 1994
    copy_ptr += bufsize;
#line 1995
    copy_size -= bufsize;
#line 1996
    set_next_block_after(header + (bufsize - 1UL) / 512UL);
#line 1997
    header = find_next_block();
#line 1998
    bufsize = available_space_after(header);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2000
  memcpy((void */* __restrict  */)(header->buffer), (void const   */* __restrict  */)copy_ptr,
         copy_size);
#line 2001
  memset((void *)(header->buffer + copy_size), 0, bufsize - copy_size);
#line 2002
  set_next_block_after(header + (copy_size - 1UL) / 512UL);
#line 2003
  find_next_block();
  }
#line 2004
  return;
}
}
#line 2006 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
static void gnu_flush_write(size_t buffer_level ) 
{ 


  {
  {
#line 2009
  flush_write_ptr = & simple_flush_write;
#line 2010
  _gnu_flush_write(buffer_level);
#line 2011
  flush_write_ptr = & gnu_flush_write;
  }
#line 2012
  return;
}
}
#line 2014 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void flush_read(void) 
{ 


  {
  {
#line 2017
  (*flush_read_ptr)();
  }
#line 2018
  return;
}
}
#line 2020 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void flush_write(void) 
{ 


  {
  {
#line 2023
  (*flush_write_ptr)(record_size);
  }
#line 2024
  return;
}
}
#line 2026 "/home/khheo/project/benchmark/tar-1.29/src/buffer.c"
void open_archive(enum access_mode wanted_access ) 
{ 


  {
  {
#line 2029
  flush_read_ptr = & gnu_flush_read;
#line 2030
  flush_write_ptr = & gnu_flush_write;
#line 2032
  _open_archive(wanted_access);
  }
  {
#line 2036
  if ((unsigned int )wanted_access == 2U) {
#line 2036
    goto case_2;
  }
#line 2036
  if ((unsigned int )wanted_access == 0U) {
#line 2036
    goto case_2;
  }
#line 2041
  if ((unsigned int )wanted_access == 1U) {
#line 2041
    goto case_1;
  }
#line 2033
  goto switch_break;
  case_2: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 2037
  if (volume_label_option) {
    {
#line 2038
    match_volume_label();
    }
  }
#line 2039
  goto switch_break;
  case_1: /* CIL Label */ 
#line 2042
  records_written = (off_t )0;
#line 2043
  if (volume_label_option) {
    {
#line 2044
    write_volume_label();
    }
  }
#line 2045
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2047
  set_volume_start_time();
  }
#line 2048
  return;
}
}
